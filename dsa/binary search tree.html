<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>binary search tree - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>binary search tree</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">63</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Add all greater values to every node in a BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-1" class="toc-link">All Elements in Two Binary Search Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Array to BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-3" class="toc-link">AVL Tree Insertion</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-4" class="toc-link">Balance a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Bheem Wants Ladoos</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-6" class="toc-link">Binary Search Tree Iterator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Binary Search Tree to Greater Sum Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Binary Tree to BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-9" class="toc-link">BST Keys in a Range</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-10" class="toc-link">BST to greater sum tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-11" class="toc-link">BST to max heap</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-12" class="toc-link">BST with Dead End</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-13" class="toc-link">Check for BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-14" class="toc-link">Closest in BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-15" class="toc-link">Closest Neighbour in BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-16" class="toc-link">Closest Nodes Queries in a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Construct Binary Search Tree from Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Convert BST to Greater Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Convert Sorted Array to Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Convert Sorted List to Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Count BST nodes that lie in a given range</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-22" class="toc-link">Delete Node in a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Delete nodes greater than k</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-24" class="toc-link">Find Common Nodes in two BSTs</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-25" class="toc-link">Find Mode in Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Increasing Order Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Inorder Traversal and BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-28" class="toc-link">Insert into a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Is Binary Tree Heap</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-30" class="toc-link">Kth Largest Element in a Stream</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Kth largest element in BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-32" class="toc-link">Kth Smallest Element in a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Largest BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-34" class="toc-link">Lowest Common Ancestor in a BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-35" class="toc-link">Lowest Common Ancestor of a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Maximum Sum BST in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Maximum sum leaf to root path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-38" class="toc-link">Max Level Sum in Binary Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-39" class="toc-link">Merge two BST &#39;s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-40" class="toc-link">Minimum Absolute Difference in BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Minimum BST Sum Subtree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-42" class="toc-link">Minimum Distance Between BST Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Minimum element in BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-44" class="toc-link">Number of Ways to Reorder Array to Get Same BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Predecessor and Successor</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-46" class="toc-link">Preorder to BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-47" class="toc-link">Preorder Traversal and BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-48" class="toc-link">Print leaf nodes from preorder traversal of BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-49" class="toc-link">Range Sum of BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Recover Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Root to Leaf Paths</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-52" class="toc-link">Search in a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Serialize and Deserialize BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Shortest Range In BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-55" class="toc-link">Sorted Linked List to BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-56" class="toc-link">Top View of Binary Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-57" class="toc-link">Trim a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Two Sum IV - Input is a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Unique Binary Search Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Unique Binary Search Trees II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Valentine Sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-62" class="toc-link">Validate Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/add-all-greater-values-to-every-node-in-a-bst/1" target="_blank" rel="noopener noreferrer">Add all greater values to every node in a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a BST,&nbsp;modify it so that all greater values in the given BST are added to every node.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
&nbsp;          50
&nbsp;        /    \
&nbsp;       30    70
&nbsp;     /  \     / \  
&nbsp;    20  40 60 80<strong>
Output: </strong>350 330 300 260 210 150 80<strong>
Explanation:</strong>The tree should be modified to
following:
&nbsp;            260
&nbsp;         /       \
        330      150
       /   \      /     \
&nbsp;   350   300 210    80</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
&nbsp;         2
&nbsp;       /   \
&nbsp;      1     5
&nbsp;           /  \
&nbsp;          4    7<strong>
Output: </strong>19 18 16 12 7</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function</span><span style="font-size: 18px;"> <strong>modify()&nbsp;</strong>which takes one argument: the root of the BST. The function should contain the logic to modify the BST so that in the modified BST, every node has a value equal to the sum of its value in the original BST and values of all the elements larger than it in the original BST. Return the root of the modified BST. The driver code will print the inorder traversal of the returned BST/<br /><br /><strong>Expected Time Complexity:&nbsp;</strong>O(N)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(Height of the BST).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=N&lt;=100000</span></p>
<p><br /><span style="font-size: 12px;"><strong>Note:</strong> The <strong>Input/Output</strong> format and <strong>Example</strong> is given are used for the system's internal purpose, and should be used by a user for <strong>Expected Output</strong> only. As it is a function problem, hence a user should not read any input from the stdin/console. The task is to complete the function specified, and not to write the full code.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-elements-in-two-binary-search-trees/description" target="_blank" rel="noopener noreferrer">All Elements in Two Binary Search Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two binary search trees <code>root1</code> and <code>root2</code>, return <em>a list containing all the integers from both trees sorted in <strong>ascending</strong> order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/18/q2-e1.png" style="width: 457px; height: 207px;" />
<pre>
<strong>Input:</strong> root1 = [2,1,4], root2 = [1,0,3]
<strong>Output:</strong> [0,1,1,2,3,4]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/18/q2-e5-.png" style="width: 352px; height: 197px;" />
<pre>
<strong>Input:</strong> root1 = [1,null,8], root2 = [8,1]
<strong>Output:</strong> [1,1,8,8]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each tree is in the range <code>[0, 5000]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/array-to-bst4443/1" target="_blank" rel="noopener noreferrer">Array to BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>sorted </strong>array. Convert it into a <strong>Height Balanced</strong> Binary Search Tree (BST). Return the <strong>root </strong>of the BST.</span></p>
<blockquote>
<p><span style="font-size: 18px;"><strong>Height-balanced</strong> BST means a binary tree in which the depth of the left subtree and the right subtree of every node never differ by more than 1.</span></p>
</blockquote>
<p><span style="font-size: 18px;">Note: The driver code will check the BST, if it is a Height-balanced BST, the output will be <strong>true</strong> otherwise the output will be <strong>false</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> nums = [1, 2, 3, 4]
<strong>Output:</strong> true
<strong>Explanation:</strong> The preorder traversal of the following BST formed is [2, 1, 3, 4]:
</span><span style="font-size: 18px;">&nbsp;          2
</span><span style="font-size: 18px;">&nbsp;        /   \
</span>        <span style="font-size: 18px;">1     3
</span><span style="font-size: 18px;">&nbsp;              \
&nbsp;               4</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>nums = [1, 2, 3, 4, 5, 6, 7]
<strong>Ouput: </strong>true
<strong>Explanation: </strong>The preorder traversal of the following BST formed is [4, 2, 1, 3, 6, 5, 7]:
        4
       / \
      2   6
     / \   / \
    1 3  5 7</span>
</pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(n)<br /><strong>Expected Auxillary Space: </strong>O(n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; nums.size() &le; 10<sup>5</sup><br />1 &le; nums[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/avl-tree-insertion/1" target="_blank" rel="noopener noreferrer">AVL Tree Insertion</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an AVL tree and N values to be inserted in the tree. Write a function to insert elements into the given&nbsp;<strong>AVL tree</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong><br />The tree will be checked after each insertion.&nbsp;<br />If it violates the properties of balanced BST, an error message will be printed followed by the inorder traversal of the tree at that moment.<br />If instead all insertions are successful, inorder traversal of the tree will be printed.</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:<br /></strong>N = 3<strong><br /></strong>Values to be inserted = {5,1,4}<strong> </strong>
<strong>Output:<br /></strong>1 4 5<br /><strong>Explanation:<br /></strong>Value to be inserted = 5<strong><br /></strong>    5
Value to be inserted = 1
    5
   /
  1
Value to be inserted = 4
  5                     4
 /    <strong>LR rotation</strong>        /  \
1    -----------&gt;       1   5
&nbsp;\
&nbsp;4<br />Therefore the inorder of the final tree will be 1, 4, 5.</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong><br />N = 7<strong><br /></strong>Values to be inserted = {21,26,30,9,4,14,28}<strong> </strong>
<strong>Output:<br /></strong>4 9 14 21 26 28 30<br /><strong style="font-family: sans-serif;">Explanation:</strong><br />Value to be inserted = 21<strong><br /></strong>    21
Value to be inserted = 26
    21
     \
     26
Value to be inserted = 30
  21                        26
   \      <strong>LL rotation</strong>         /  \
   26    -----------&gt;       21  30
    \
     30<br />Value to be inserted = 9<br />    26<br />   /  \<br />  21  30<br /> /<br />9<br />Value to be inserted = 4<br />      26                          26<br />     /  \                          /  \<br />    21  30                      9   30<br />   /          <strong>RR rotation</strong>        /  \<br />  9          -----------&gt;       4  21<br /> /<br />4<br />Value to be inserted = 14<br />      26                          21<br />     /  \                          /  \<br />    9   30                      9   26<br />   / \          <strong>LR rotation</strong>      /  \    \<br />  4  21        -----------&gt;    4  14  30<br /> &nbsp; &nbsp; /<br />    14<br />Value to be inserted = 28<br />      21                          21<br />     /  \                          /  \<br />    9   26                      9   28<br />   / \    \     <strong>RL rotation</strong>       / \    / \<br />  4  14   30   -----------&gt;   4  14 26 30<br />          /<br />         28<br />Therefore the inorder of the final tree will be 4, 9, 14, 21, 26, 28, 30.</span></pre>
<p><span style="font-size: 14pt;"><strong>Your Task: &nbsp;</strong><br />You don't need to read input or print anything. Complete the function<strong>&nbsp;insertToAVL()</strong>&nbsp;which takes the root of the tree and the value of the node to be inserted as input parameters and returns the root of the modified tree.</span></p>
<p><span style="font-size: 14pt;"><strong>Expected Time Complexity:</strong>&nbsp;O(log N)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(height of tree)</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; N &le; 2000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/balance-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Balance a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">greedy</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p>

<p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg" style="width: 500px; height: 319px;" />
<pre>
<strong>Input:</strong> root = [1,null,2,null,3,null,4,null,null]
<strong>Output:</strong> [2,1,3,null,null,null,4]
<b>Explanation:</b> This is not the only correct answer, [3,1,4,null,2] is also correct.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg" style="width: 224px; height: 145px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,1,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to balance a binary search tree rooted at the <code>root</code> such that the difference between the depths of the two subtrees of every node never exceeds one. As a reminder, the depth of a given node in a tree is the number of edges from the root of the tree to that node.</p>
<blockquote>
<p>Note: Binary search trees (BSTs) are structured such that the value of each node is greater than all values in its left subtree and less than all values in its right subtree. Please refer to LeetCode's Explore Card on binary trees for a more detailed explanation: <a href="https://leetcode.com/explore/learn/card/data-structure-tree/"><strong>Binary Trees</strong></a></p>
</blockquote>
<p>We call such BSTs balanced BSTs. Balanced BSTs are efficient because they keep the tree height low, usually in logarithmic proportion to the number of nodes. This balance allows operations like insertion, deletion, and lookup to be done in logarithmic time on average. Keeping the tree balanced prevents it from becoming too deep, which would otherwise slow these operations down to linear time. This efficiency makes balanced BSTs ideal for tasks that need fast updates and quick searches.</p>
<p>There are two main approaches to balance a BST.</p>
<p>The first approach is to traverse and store all the BST nodes in a sorted array, then reconstruct the BST from scratch. Storing the values in sorted order ensures the new tree maintains the BST properties, where each node's left subtree contains only values less than the node's value, and the right subtree contains only values greater.</p>
<p>The second approach is to balance the BST in-place by restructuring it without additional storage. This involves performing rotations and rearrangements directly on the existing nodes to achieve balance while preserving BST properties.</p>
<p>This approach is more complex and is unlikely to be asked in an interview setting. However, it's worth understanding for deeper insights into tree rotations, balancing techniques, and the workings of self-balancing trees like AVL and Red-Black trees.</p>
<hr />
<h3 id="approach-1-inorder-traversal--recursive-construction">Approach 1: Inorder Traversal + Recursive Construction</h3>
<h4 id="intuition">Intuition</h4>
<p>In the overview, we mentioned the need to traverse and store the nodes of the BST in increasing order. This can be achieved by iteratively visiting each node in the following order: first the left subtree, then the node itself, and finally the right subtree, known as an inorder traversal.</p>
<p>If you are not familiar with the three main traversal methods (inorder, preorder, and postorder), we encourage you to read about them here:</p>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/editorial/">Inorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/editorial/">Preorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/editorial/">Postorder Traversal</a></li>
</ul>
<p>We can perform the inorder traversal either recursively or iteratively. In this editorial, we will use the recursive approach for its simplicity and brevity, though you are encouraged to try both methods.</p>
<p>With the nodes of the BST stored in an array in increasing order, we can now reconstruct the BST to be balanced.</p>
<p>The stored values in the array have a convenient property: for any given element that serves as the root, all elements to its left belong to the left subtree, and all elements to its right belong to the right subtree. To construct a balanced BST, we pick the middle element of the array as the root, ensuring the number of elements in the left and right subtrees differs by at most one. We then recursively apply the same process to the left and right subarrays to build the left and right subtrees. This approach ensures the balanced property of the BST.</p>
<p>!?!../Documents/1382/slideshow1.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialization:
<ul>
<li>Create an empty list <code>inorder</code> to store the nodes' values after the inorder traversal.</li>
</ul>
</li>
<li>Perform inorder traversal:
<ul>
<li>Traverse the BST and populate the <code>inorder</code> list with the node values in sorted order.</li>
</ul>
</li>
<li>Reconstruct the balanced BST:
<ul>
<li>Define a recursive function <code>createBalancedBST</code> that takes the <code>inorder</code> list, <code>start</code> index, and <code>end</code> index as parameters.
<ul>
<li>If <code>start</code> is greater than <code>end</code>, return <code>null</code> (or equivalent).</li>
<li>Calculate the <code>mid</code> index as the middle of the current range.</li>
<li>Create a new tree node with the value at the <code>mid</code> index.</li>
<li>Recursively build the left subtree using the left half of the current range.</li>
<li>Recursively build the right subtree using the right half of the current range.</li>
</ul>
</li>
</ul>
</li>
<li>Return the root of the newly constructed balanced BST.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JcbyAFbA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the BST.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>inorderTraversal</code> function visits each node exactly once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Constructing the balanced BST with the <code>createBalancedBST</code> function also involves visiting each node exactly once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>inorderTraversal</code> function uses an additional array to store the inorder traversal, which requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>The recursive calls in the <code>inorderTraversal</code> and <code>createBalancedBST</code> functions contribute to the space complexity. In the worst case, the recursion stack can grow to <span class="math inline">\(O(n)\)</span> for a skewed tree.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-day-stout-warren-algorithm--in-place-balancing">Approach 2: Day-Stout-Warren Algorithm / In-Place Balancing</h3>
<h4 id="intuition-1">Intuition</h4>
<blockquote>
<p><strong>Note:</strong> This approach is very advanced and would not be expected in an interview. We have included it for completeness.</p>
</blockquote>
<p>The Day-Stout-Warren (DSW) algorithm provides an in-place method for balancing Binary Search Trees (BSTs). To understand DSW, we first need to grasp the concept of rotations, which are fundamental operations for restructuring the tree to reduce its height and improve balance.</p>
<p>Rotations come in two forms:</p>
<ul>
<li>Right Rotation: This operation elevates the left child of a node to take its place, while the original node becomes the right child of its former left child.</li>
<li>Left Rotation: Conversely, this operation elevates the right child of a node to take its place, with the original node becoming the left child of its former right child.</li>
</ul>
<p>It's important to note that right and left rotations are inverse operations, each undoing the effect of the other.</p>
<p><img src="../Figures/1382/1382_DSW_slides_1_fix.png" alt="rotate1" /></p>
<p>With this foundation, we can now explore how DSW leverages these rotations. The algorithm employs a three-phase approach to balance a BST:</p>
<ol>
<li>Create the Backbone (vine)</li>
</ol>
<p>In this initial phase, DSW transforms the BST into a right-skewed tree, resembling a vine or linked list. This is achieved through a series of right rotations. The process involves traversing the tree and performing a right rotation whenever a node with a left child is encountered, continuing until the entire tree is right-skewed.</p>
<p>The slideshow is shown below:</p>
<p>!?!../Documents/1382/1382_DSW_slides_Re.json:1320,850!?!</p>
<ol start="2">
<li>Count the nodes</li>
</ol>
<p>Once the backbone is created, the next step is to determine the total number of nodes in the vine. This is done by traversing the right-skewed structure and counting each node. Let's denote this count as <code>n</code>. This count becomes crucial for the final balancing phase.</p>
<ol start="3">
<li>Balance the vine</li>
</ol>
<p>The final phase aims to convert the right-skewed vine into a balanced BST. This is accomplished through a series of left rotations. The process begins by calculating <code>m</code>, which is the largest power of 2 less than <code>n + 1</code>, minus 1. This calculation is significant as it identifies the largest complete subtree that can be fully balanced.</p>
<p>The balancing then proceeds in two steps:</p>
<p>a) Perform <code>n - m</code> left rotations to partially balance the tree. This ensures that the remaining nodes will form a complete binary tree after the first set of rotations.</p>
<p>b) Enter a loop where <code>m</code> is halved repeatedly. For each iteration, perform left rotations to balance the next level of the tree. This process continues until the vine is fully transformed into a balanced BST.</p>
<p>!?!../Documents/1382/slideshow3.json:960,540!?!</p>
<blockquote>
<p><strong>Note:</strong> While this approach is space-efficient, it modifies the tree structure during traversal, which might not be suitable in all scenarios, especially if the tree is being accessed concurrently by other processes. The constant modification of tree links may have a slight impact on performance compared to straightforward recursive approaches, especially for smaller trees.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialization:
<ul>
<li>If the root is <code>null</code>, return <code>null</code>.</li>
<li>Create a temporary dummy node <code>vineHead</code>.</li>
<li>Set the right child of <code>vineHead</code> as the root of the BST.</li>
<li>Initialize a pointer <code>current</code> to <code>vineHead</code>.</li>
</ul>
</li>
<li>Create the Backbone (Vine):
<ul>
<li>While <code>current</code> has a right child:
<ul>
<li>If <code>current</code>'s right child has a left child:
<ul>
<li>Perform a right rotation on <code>current</code> and its right child.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Move <code>current</code> to its right child.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Count the Nodes:
<ul>
<li>Initialize <code>nodeCount</code> to 0.</li>
<li>Set <code>current</code> as the right child of <code>vineHead</code>.</li>
<li>While <code>current</code> is not <code>null</code>:
<ul>
<li>Increment <code>nodeCount</code>.</li>
<li>Move <code>current</code> to its right child.</li>
</ul>
</li>
</ul>
</li>
<li>Create a Balanced BST:
<ul>
<li>Calculate <code>m</code> as the largest power of 2 less than <code>nodeCount + 1</code> minus 1.</li>
<li>Perform <code>nodeCount - m</code> left rotations on the vine to partially balance it.</li>
<li>While <code>m</code> is greater than 1:
<ul>
<li>Halve <code>m</code>.</li>
<li>Perform <code>m</code> left rotations on the vine to further balance it.</li>
</ul>
</li>
</ul>
</li>
<li>Return the Balanced BST:
<ul>
<li>Set <code>balancedRoot</code> to the right child of <code>vineHead</code>.</li>
<li>Delete the temporary dummy node <code>vineHead</code>.</li>
<li>Return <code>balancedRoot</code>.</li>
</ul>
</li>
</ol>
<ul>
<li>Right Rotation:
<ul>
<li>Given a parent node and its right child:
<ul>
<li>Set <code>tmp</code> to the left child of the right child.</li>
<li>Set the left child of the right child to the right child of <code>tmp</code>.</li>
<li>Set the right child of <code>tmp</code> to the right child of the parent node.</li>
<li>Set the right child of the parent node to <code>tmp</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Left Rotation:
<ul>
<li>Given a parent node and its right child:
<ul>
<li>Set <code>tmp</code> to the right child of the right child.</li>
<li>Set the right child of the right child to the left child of <code>tmp</code>.</li>
<li>Set the left child of <code>tmp</code> to the right child of the parent node.</li>
<li>Set the right child of the parent node to <code>tmp</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Make Rotations:
<ul>
<li>Given <code>vineHead</code> and <code>count</code>:
<ul>
<li>Set <code>current</code> to <code>vineHead</code>.</li>
<li>For <code>i</code> from 0 to <code>count - 1</code>:
<ul>
<li>Set <code>tmp</code> to the right child of <code>current</code>.</li>
<li>Perform a left rotation on <code>current</code> and <code>tmp</code>.</li>
<li>Move <code>current</code> to its right child.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/TZ3STb7N/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the BST at <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The loop that creates the vine visits each node exactly once, and each right rotation is <span class="math inline">\(O(1)\)</span>, resulting in <span class="math inline">\(O(n)\)</span> time.</p>
<p>Counting nodes in the vine involves a single traversal of the vine, which is <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>makeRotations</code> function performs a series of left rotations. Each rotation is <span class="math inline">\(O(1)\)</span>, and the total number of rotations across all iterations is <span class="math inline">\(O(n)\)</span>. Although the number of rotations is bounded by a logarithmic factor due to iteratively halving <span class="math inline">\(m\)</span>, the overall complexity remains <span class="math inline">\(O(n)\)</span> due to the linear traversal and rotation steps.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm primarily uses a temporary pointer structure and the original nodes, contributing to <span class="math inline">\(O(1)\)</span> additional space. The vine structure uses the existing nodes in-place, without requiring extra memory.</p>
<p>However, the depth of the recursion stack in the worst case can reach <span class="math inline">\(O(n)\)</span> if the tree is skewed.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bheem-wants-ladoos--170647/1" target="_blank" rel="noopener noreferrer">Bheem Wants Ladoos</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a binary tree where each node contains a number of ladoos equal to its value, and a starting node, <strong>src,</strong> find the maximum sum of ladoos that can be collected within a distance <strong><code>k</code></strong> from the starting node. The value at the starting node, <strong>src</strong>, should be included in the sum. Each node has a unique number of ladoos.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
    &nbsp;              <strong>1</strong>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   2&nbsp; &nbsp; &nbsp; <strong>9</strong>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    /&nbsp; &nbsp; &nbsp;&nbsp;/&nbsp;&nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     4&nbsp; &nbsp; &nbsp; <strong>5</strong>&nbsp; &nbsp; &nbsp;<strong>7</strong>
&nbsp; &nbsp; &nbsp; &nbsp;     /&nbsp; &nbsp;\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; \
&nbsp; &nbsp; &nbsp;      8&nbsp; &nbsp;  19&nbsp; &nbsp; &nbsp;20&nbsp; &nbsp; 11
&nbsp; &nbsp;       /&nbsp; &nbsp; &nbsp;/&nbsp; \
 &nbsp;       30&nbsp; &nbsp;40&nbsp; &nbsp;50
src = 9, k = 1
<strong>Output: </strong>22
<strong>Explanation: </strong>Initially we're at 9, so sum = 9. In 2nd move we went to 5, sum=9+5=14. In 3rd move we went to 7, sum=14+7=21. In 4th move we went to 1, sum=21+1=22. So, within k distance we can get 22 ladoos.  
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
    &nbsp;              1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   2&nbsp; &nbsp; &nbsp; 9
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    /&nbsp; &nbsp; &nbsp;&nbsp;/&nbsp;&nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     <strong>4</strong>&nbsp; &nbsp; &nbsp; 5&nbsp; &nbsp; &nbsp;7
&nbsp; &nbsp; &nbsp; &nbsp;     /&nbsp; &nbsp;\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; \
&nbsp; &nbsp; &nbsp;      8&nbsp; &nbsp;  <strong>19</strong>&nbsp; &nbsp; &nbsp;20&nbsp; &nbsp; 11
&nbsp; &nbsp;       /&nbsp; &nbsp; &nbsp;/&nbsp; \
 &nbsp;       30&nbsp; &nbsp;<strong>40</strong>&nbsp; &nbsp;<strong>50</strong>
src = 40, k = 2
<strong>Output: </strong>113
<strong>Explanation: </strong>Initially we're at 40, so sum = 40. In 2nd move we went to 19, sum=40+19=59. In 3rd move we went to 4, sum=59+4=63. In 4th move we went to 50, sum=63+50=113. So, within K distance we can get 113 ladoos.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>1
src = 1, k = 1
<strong>Output: </strong>1</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; number of nodes, src &le; 10<sup>5<br /></sup><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1 &le; node-&gt;data &le; 10</span><sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">5<br /></sup><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1 &le; k &le; 20</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-search-tree-iterator/description" target="_blank" rel="noopener noreferrer">Binary Search Tree Iterator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">design</span> <span class="topic-badge">iterator</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)" target="_blank">in-order traversal</a></strong> of a binary search tree (BST):</p>

<ul>
	<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>
	<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>
	<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>
</ul>

<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>

<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" style="width: 189px; height: 178px;" />
<pre>
<strong>Input</strong>
[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
<strong>Output</strong>
[null, 3, 7, true, 9, true, 15, true, 20, false]

<strong>Explanation</strong>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-search-tree-to-greater-sum-tree/description" target="_blank" rel="noopener noreferrer">Binary Search Tree to Greater Sum Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>

<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" style="width: 400px; height: 273px;" />
<pre>
<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0,null,1]
<strong>Output:</strong> [1,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 538: <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/" target="_blank">https://leetcode.com/problems/convert-bst-to-greater-tree/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem requires modifying the binary search tree rooted at the <code>root</code> so that each node has a new value equal to the sum of all original tree values that are greater than or equal to <code>node.val</code>. The tree contains between 0 and 100 unique nodes.</p>
<p>Check out the example below to understand how the root value gets replaced by adding greater values:</p>
<p><img src="../Figures/1038/visual1.png" alt="figB" /></p>
<hr />
<h3 id="approach-1-in-order-traversal-brute-force">Approach 1: In-order Traversal (Brute-Force)</h3>
<h4 id="intuition">Intuition</h4>
<p>In a binary search tree, all nodes in the left subtree of a node have values less than the node, and all nodes in the right subtree have values greater. During an in-order traversal, we move from the left subtree to the root node, then to the right subtree. Thus, in a binary search tree, in-order traversal yields node values in ascending order.</p>
<p>Given that the number of nodes is small, we can consider using a brute-force approach to solve the problem.</p>
<p>We can store all node values in an array as we traverse the tree using in-order traversal. Now, we can traverse the tree again and modify each node's value by incrementing the original value with the sum of all the greater values in the array.</p>
<p>Since the array is sorted in ascending order, we can start iterating from the end of the array. If we reach any value in the array less than the current node value, we can break the iteration to further optimize this approach.</p>
<h4 id="algorithm">Algorithm</h4>
<p><strong>Main function - <code>bstToGst(root)</code></strong></p>
<ol>
<li>Initialize an integer array <code>inorderTraversal</code>.</li>
<li>Call <code>inorder(root)</code>.</li>
<li>Reverse the <code>inorderTraversal</code> array.</li>
<li>Call <code>replaceValues(root)</code>.</li>
<li>Return <code>root</code>.</li>
</ol>
<p><strong><code>inorder(root)</code></strong></p>
<ol>
<li>If the root is <code>null</code>, return.</li>
<li>Make a call to <code>inorder(root-&gt;left)</code>.</li>
<li>Store the value of the current node in the <code>inorderTraversal</code> array.</li>
<li>Make a call to <code>inorder(root-&gt;right)</code>.</li>
</ol>
<p><strong><code>replaceValues(root)</code></strong></p>
<ol>
<li>If the root is <code>null</code>, return.</li>
<li>Make calls to the left and right child, i.e. call the <code>replaceValues(root-&gt;left)</code> and <code>replaceValues(root-&gt;right)</code>.</li>
<li>Initialize <code>nodeSum</code> with 0.</li>
<li>Iterate through the <code>inorderTraversal</code> array:
<ul>
<li>If the current value is greater than <code>root-&gt;val</code>:
<ul>
<li>Add this value to the <code>nodeSum</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>root-&gt;val</code> by <code>nodeSum</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/oQyR8Jh9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The <code>inorder</code> function traverses all the nodes exactly once. All other operations in <code>inorder</code> are constant time. Therefore, the time complexity for this function is <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>replaceValues</code> function iterates all the values in <code>inorderTraversal</code> of size <code>n</code> in each iteration. It iterates all the nodes exactly once. Therefore, the time complexity for this function is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The time complexity for the main function is given by <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>While traversing the tree, the recursion stack in both functions stores exactly <code>n</code> nodes in the worst case. Also, the size of the <code>inorderTraversal</code> array is <code>n</code>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-reverse-in-order-traversal">Approach 2: Reverse In-order Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Traversing the right subtree before the left subtree during an in-order traversal means we can visit the greater values before the smaller ones. This approach will traverse the tree so that all the nodes are visited in descending order. An example of this reverse in-order traversal is shown below:</p>
<p><img src="../Figures/1038/Slide1.PNG" alt="figA" /></p>
<p>We use recursion to visit the right subtree first, reaching the rightmost node with the maximum value. During traversal, each node's value is updated with a running sum of all previously visited nodes. This approach works because visiting nodes in descending order allows us to accumulate and update the sum progressively.</p>
<p>Next, we move to the left subtree and repeat the process, using the call stack to return to nodes with smaller values.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong>Main function</strong></p>
<ol>
<li>Initialize an integer <code>nodeSum</code> with 0.</li>
<li>Call <code>bstToGstHelper(root)</code>.</li>
<li>Return the value of <code>root</code>.</li>
</ol>
<p><strong>Helper function - <code>bstToGstHelper(TreeNode root,int nodeSum)</code></strong></p>
<ol>
<li>If the <code>root</code> is null:
<ul>
<li>Return the <code>root</code> without any changes.</li>
</ul>
</li>
<li>Recursively call the right subtree of root.</li>
<li>Increment <code>nodeSum</code> by the value of the current node and replace current node's value with <code>nodeSum</code>.</li>
<li>Recursively call the left subtree of the root.</li>
<li>Return <code>root</code>.</li>
</ol>
<p>!?!../Documents/1038/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/P4NiS6sq/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursive function is called for every node exactly once. All the operations performed in the <code>bstToGst</code> function are constant time. Therefore, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursive function is called exactly <code>n</code> times. In the worst case where the binary search tree is skewed such that all the nodes only have the right children, the call stack size will grow up to <code>n</code>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterative-reverse-in-order-traversal">Approach 3: Iterative Reverse In-order Traversal</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can perform a reverse in-order traversal by emulating the recursion call stack iteratively using a stack.</p>
<p>We can iterate the nodes of the tree, and push them in the stack until we reach the rightmost node of the tree, similar to the recursive process.</p>
<p>We need to maintain the sum while traversing in decreasing order and increment the value of the top node of the stack by this sum. Similarly, we can repeat this process for the left subtree of the current node.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize integer <code>nodeSum</code> with 0 and a stack <code>st</code> to store the nodes of the tree. Create a copy of the <code>root</code> in <code>node</code>.</li>
<li>Iterate until <code>st</code> is not empty or <code>node</code> is not <code>null</code>:
<ul>
<li>While <code>node</code> is not null:
<ul>
<li>Push the current node in <code>st</code>.</li>
<li>Replace <code>node</code> with the right child of <code>node</code>.</li>
</ul>
</li>
<li>Store the top element of <code>st</code> in <code>node</code> and pop <code>st</code>.</li>
<li>Increment <code>nodeSum</code> with the value of <code>node</code>.</li>
<li>Replace the value of <code>node</code> with this value.</li>
<li>Replace <code>node</code> with the left child of <code>node</code>.</li>
</ul>
</li>
<li>Return <code>root</code>.</li>
</ol>
<p>!?!../Documents/1038/slideshow2.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/7ecgLZtM/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Every node is pushed into the stack and popped from the stack exactly once. All the other operations performed in the loop are constant time. Therefore, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>The recursive function is called exactly <code>n</code> times. In the worst case where the binary search tree is skewed such that all the nodes only have the right children, the call stack size will grow up to <code>n</code>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
<hr />
<h3 id="approach-4-morris-traversal">Approach 4: Morris Traversal</h3>
<h4 id="intuition-3">Intuition</h4>
<blockquote>
<p>This approach is very advanced and would not be expected in an interview. We have included it for completeness.</p>
</blockquote>
<p>We will continue using the same idea from the previous approach. Is there a way for us to perform the inorder traversal without using any space, including the recursion call stack?</p>
<p>Morris Traversal is an efficient algorithm used to perform in-order tree traversal without using any extra space for recursion or a stack, which is typically required in conventional tree traversal methods. The algorithm uses the concept of threaded binary trees, temporarily modifying the tree structure during traversal to avoid additional memory usage.</p>
<p>Before diving into Morris traversal, it's crucial to understand threaded binary trees:</p>
<ol>
<li>In a threaded binary tree, &quot;null&quot; right pointers are replaced with pointers to the in-order successor of the node.</li>
<li>This threading allows for efficient traversal without recursion or a stack.</li>
</ol>
<p><strong>Note:</strong> If you are new to the concept of Morris traversal, we recommend you first read <a href="https://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded Binary Trees</a> and <a href="https://stackoverflow.com/a/5506601">Working of the Morris traversal algorithm</a>. You can also understand the implementation of the algorithm <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/editorial/#approach-3-morris-traversal">here</a>.</p>
<p>To apply the reverse in-order traversal using Morris traversal, we can swap all <code>left</code> and <code>right</code> pointer references to the BST. This would return all the nodes in the descending order of their values.</p>
<p>Check out the example given below to understand the conversion process:</p>
<p>!?!../Documents/1038/slideshow3.json:960,540!?!</p>
<p>In the final tree obtained, if there is no right subtree, then we can visit this node and continue traversing left. If there is a right subtree, then there is at least one node that has a greater value than the current one. Therefore, we must traverse that subtree first before the current node which would help us to traverse all the node values in decreasing order.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p><strong>Main function - <code>bstToGst(root)</code></strong></p>
<ol>
<li>Initialize an integer <code>sum</code> with 0 and a dummy node <code>node</code> with root.</li>
<li>Iterate while node's value is not <code>null</code>:
<ul>
<li>If node's right child is not <code>null</code>:
<ul>
<li>Increment <code>sum</code> with node's value.</li>
<li>Replace node's value with this sum and move to the left child.</li>
</ul>
</li>
<li>Otherwise, if the right child is <code>null</code>:
<ul>
<li>Store the in-order successor of <code>node</code> in <code>succ</code>, calculated using <code>getSuccessor(node)</code>.
<ul>
<li>If left child of <code>succ</code> is <code>null</code>:
<ul>
<li>Store <code>node</code> as the left child of <code>succ</code>.</li>
<li>Move towards the right child of <code>node</code>.</li>
</ul>
</li>
<li>Otherwise, if the left child isn't <code>null</code>:
<ul>
<li>Set left child of <code>succ</code> as null.</li>
<li>Increment <code>sum</code> with node's value.</li>
<li>Replace node's value with this sum and move to the left child.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>root</code>.</li>
</ol>
<p><strong><code>getSuccessor(node)</code></strong></p>
<ol>
<li>Initialize <code>succ</code> with right child of <code>node</code>.</li>
<li>Return the left-most child of <code>succ</code>.</li>
</ol>
<blockquote>
<p>Note: While this approach is space-efficient, it modifies the tree structure during traversal, which might not be suitable in all scenarios, especially if the tree is being accessed concurrently by other processes. The constant modification and restoration of tree links may have a slight impact on performance compared to straightforward recursive approaches, especially for smaller trees.</p>
</blockquote>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/5Uz6xMNm/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Note that <code>getSuccessor</code> is called at most twice per node. On the first invocation, the temporary link back to the node in question is created, and on the second invocation, the temporary link is erased.</p>
<p>Then, the algorithm steps into the left subtree with no way to return to the node. Therefore, each edge can only be traversed 3 times: once when we move the node pointer, and once for each of the two calls to getSuccessor.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Because we only manipulate pointers that already exist, the Morris traversal uses constant space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/binary-tree-to-bst/1" target="_blank" rel="noopener noreferrer">Binary Tree to BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Binary Tree, convert it to Binary Search Tree in such a way <strong>that keeps the original structure of Binary Tree intact</strong>.</span><br />&nbsp;<span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
&nbsp;     </strong>1
&nbsp;   /   \
<strong>   </strong>2     3<strong>
Output: <br /></strong>1 2 3<br /><strong>Explanation:</strong><br />The converted BST will be <br />      2<br />    /   \<br />   1     3</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>    </span>   <span style="font-size: 18px;">   1
       /    \
     2       3
   /        
 4       </span><span style="font-size: 18px;"><strong>
Output: <br /></strong>1 2 3 4<strong>
Explanation:
</strong>The converted BST will be</span>

<span style="font-size: 18px;">        3
      /   \
    2     4
  /
 1</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>binaryTreeToBST()</strong>&nbsp;which takes the root of the Binary tree as input and returns the root of the BST. The driver code will print<strong> inorder</strong> traversal of the converted BST.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(NLogN).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= Number of nodes &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-bst-elements-in-given-range/1" target="_blank" rel="noopener noreferrer">BST Keys in a Range</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Binary Search Tree<strong>&nbsp;</strong>and a range <strong>[low, high]</strong>. Find all&nbsp;the numbers&nbsp;in the BST that lie in the given range.<br /><strong>Note:</strong> Element greater than or equal to root go to the right side.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>&nbsp; &nbsp; &nbsp; &nbsp;17
 &nbsp; &nbsp; /&nbsp; &nbsp; \
 &nbsp; &nbsp;4&nbsp; &nbsp; &nbsp;18
 &nbsp;/&nbsp; &nbsp;\
 2&nbsp; &nbsp; &nbsp;9&nbsp;
l = 4, h = 24
<strong>Output: <br /></strong>4 9 17 18&nbsp;</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>&nbsp; &nbsp; &nbsp; &nbsp;16
 &nbsp; &nbsp; /&nbsp; &nbsp; \
 &nbsp; &nbsp;7&nbsp; &nbsp; &nbsp;20
 &nbsp;/&nbsp; &nbsp;\
 1&nbsp; &nbsp;&nbsp;10
l = 13, h = 23
<strong>Output: <br /></strong>16 20<strong>&nbsp;
</strong></span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>printNearNodes()</strong>&nbsp;which takes the root Node of the BST and the range elements low and high as inputs and returns an array that contains the BST elements in the given range low to high (inclusive) in <strong>non-decreasing&nbsp;</strong>order.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; Number of nodes &le; 10<sup>5</sup><br />1 &le; l &le; h &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bst-to-greater-sum-tree/1" target="_blank" rel="noopener noreferrer">BST to greater sum tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a BST with unique node values, transform it into greater sum tree where each node contains sum of all nodes greater than that node.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
           2
         /    \
        1      6
              /  \
             3    7
<strong>Output:</strong> 18 16 13 7 0
<strong>Explanation:</strong>
Every node is replaced with the 
sum of nodes greater than itself. 
The resultant tree is:
               16
             /    \
           18       7
                  /   \
                 13    0
</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input</strong><strong>:</strong>
</span><span style="font-size: 18px;">          2
         /
        1</span>
<span style="font-size: 18px;"><strong>Output: </strong>2 0</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">The resultant tree is :</span>
<span style="font-size: 18px;">             0</span>
<span style="font-size: 18px;">            /</span>
<span style="font-size: 18px;">          2</span>
</pre>
<div><span style="font-size: 18px;"><strong>Your task :</strong></span></div>
<div><span style="font-size: 18px;">You don't have to read input or print anything. Your task is to complete the function <strong>transformTree() </strong>which takes the root of the tree as input and transforms the BST to a greater sum tree.</span></div>
<div><span style="font-size: 18px;"><strong>Note :</strong> The driver code prints the inorder traversal of the transformed BST.</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(N), N = number of nodes</span></div>
<div><span style="font-size: 18px;"><strong>Expected Auxiliary Space: </strong>O(N), N = number of nodes</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 18px;"><strong>Constraints :</strong></span></div>
<div><span style="font-size: 18px;">1 &le; N &le; 10<sup>4</sup></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bst-to-max-heap/1" target="_blank" rel="noopener noreferrer">BST to max heap</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">heap</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a&nbsp;Binary Search Tree. Convert a given BST into a Special Max Heap with the condition that all the values in the left subtree of a node should be less than all the values in the right subtree of the node. This condition is applied on all the nodes in the so converted Max Heap.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input :</strong>
                 4
               /   \
              2     6
            /  \   /  \
           1   3  5    7  

<strong>Output :</strong> 1 2 3 4 5 6 7 
<strong>Exaplanation :</strong>
               7
             /   \
            3     6
          /   \  /   \
         1    2 4     5
The given <strong>BST</strong> has been transformed into a
<strong>Max Heap </strong>and it&#39;s postorder traversal is
1 2 3 4 5 6 7.</span>

</pre>

<div><span style="font-size:18px"><strong>Your task :</strong></span></div>

<div><span style="font-size:18px">You don&#39;t need to read input or print anything. Your task is to complete the function convertToMaxHeapUtil() which takes the root of the tree as input and converts the BST to max heap. </span></div>

<div><span style="font-size:18px">Note : The driver code prints the postorder traversal of the converted BST.</span></div>

<div>&nbsp;</div>

<div><span style="font-size:18px"><strong>Expected Time Complexity : </strong>O(n)</span></div>

<div><span style="font-size:18px"><strong>Expected Auxiliary Space : </strong>O(n)</span></div>

<div>&nbsp;</div>

<div><span style="font-size:18px"><strong>Constraints :</strong></span></div>

<div><span style="font-size:18px">1 &le; n &le; 10<sup>5</sup></span></div>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/check-whether-bst-contains-dead-end/1" target="_blank" rel="noopener noreferrer">BST with Dead End</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="101" data-end="197"><span style="font-size: 14pt;">You are given a Binary Search Tree (BST) containing unique positive integers greater than 0.</span></p>
<p data-start="199" data-end="265"><span style="font-size: 14pt;">Your task is to determine whether the BST contains a <strong data-start="252" data-end="264">dead end</strong>.</span></p>
<p data-start="267" data-end="286"><span style="font-size: 14pt;"><strong>Note:</strong> A <strong data-start="290" data-end="302">dead end</strong> is a <strong data-start="308" data-end="321">leaf node</strong> in the BST such that no new node can be inserted in the BST at or below this node while maintaining the BST property and the constraint that<strong> </strong>all node values must be &gt; 0.</span></p>
<p><strong><span style="font-size: 20px;">Examples:</span></strong></p>
<pre><span style="font-size: 20px;"><strong>Input: </strong>root[] = [8, 5, 9, 2, 7, N, N, 1]</span><br /><span style="font-size: 20px;"><strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700425/Web/Other/blobid1_1748007119.webp" width="190" height="184" /></strong></span><br /><span style="font-size: 20px;"><strong>Output: </strong>true
<strong>Explanation: </strong>Node 1 is a Dead End in the given BST.</span></pre>
<pre><span style="font-size: 20px;"><strong>Input:</strong> root[] = [8, 7, 10, 2, N, 9, 13]<strong><br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700425/Web/Other/blobid3_1748007366.webp" width="184" height="138" /></span><br /><span style="font-size: 20px;"><strong>Output:</strong> true
<strong>Explanation: </strong>Node 9 is a Dead End in the given BST.</span></pre>
<p><span style="font-size: 20px;"><strong>Constraints:</strong></span><span style="font-size: 20px;"><br />1 &le; number of nodes &le; 3000<sup><br /></sup>1 &le; node-&gt;data &le; 10<sup>5</sup><sup><br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/check-for-bst/1" target="_blank" rel="noopener noreferrer">Check for BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given the root of a&nbsp;binary tree. Check whether it is a BST or not.<br /><strong>Note: </strong>We are considering that BSTs can not contain duplicate Nodes.</span><br /><span style="font-size: 18px;">A&nbsp;<strong>BST</strong>&nbsp;is defined as follows:</span></p>
<ul>
<li>
<div><span style="font-size: 18px;">The left subtree of a node contains only nodes with keys <strong>less than</strong> the node's key.</span></div>
</li>
<li>
<div><span style="font-size: 18px;">The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node's key.</span></div>
</li>
<li>
<div><span style="font-size: 18px;">Both the left and right subtrees must also be binary search trees.</span></div>
</li>
</ul>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> root = [2, 1, 3, N, N, N, 5]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700149/Web/Other/blobid0_1739182093.jpg" width="249" height="220" /></span><br /><br /><span style="font-size: 18px;"><strong>Output: </strong>true 
<strong>Explanation: </strong></span><span style="font-size: 18px;">The left subtree of every node contains smaller keys and right subtree of every node contains greater keys. Hence, the tree is a BST.<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root = [2, N, 7, N, 6, N, 9] </span><br /><br /><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700149/Web/Other/blobid2_1739182131.jpg" width="238" height="211" /></span><br /><br /><span style="font-size: 18px;"><strong>Output: </strong>false 
<strong>Explanation: </strong>Since the node to the right of node with key 7 has lesser key value, hence it is not a valid BST.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root = [10, 5, 20, N, N, 9, 25]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700149/Web/Other/blobid3_1739182159.jpg" width="240" height="212" /></span><br /><br /><span style="font-size: 18px;"><strong>Output: </strong>false
<strong>Explanation: </strong>The node with key 9 present in the right subtree has lesser key value than root node.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1 &le; number of nodes &le; 10<sup>5<br /></sup></span><span style="font-size: 18px;">1 &le; node-&gt;data &le; 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-closest-element-in-bst/1" target="_blank" rel="noopener noreferrer">Closest in BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong><a href="http://quiz.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/">BST</a></strong>&nbsp;and an integer. Find the least absolute difference between any node value of the BST and the given integer.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>        10
&nbsp;     /   \
&nbsp;    2    11
&nbsp;  /  \ 
&nbsp; 1    5
&nbsp;     /  \
&nbsp;    3    6
&nbsp;     \
&nbsp;      4
K = 13
<strong>Output: </strong>2<strong>
Explanation: </strong>K=13. The node that has value nearest to K is 11. so the answer is 2</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>      8
&nbsp;   /   \
&nbsp;  1     9
&nbsp;   \     \
&nbsp;    4    10
&nbsp;   /
&nbsp;  3
K = 9
<strong>Output: </strong>0<strong>
Explanation: </strong>K=9. The node that has value nearest to K is 9. so the answer is 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= Number of nodes &lt;= 10<sup>5<br /></sup></span><span style="font-size: 18px;">1 &lt;= Value stored at nodes(data), K &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/closest-neighbor-in-bst/1" target="_blank" rel="noopener noreferrer">Closest Neighbour in BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given the <strong>root</strong> of a<strong> <a title="BST" href="https://www.geeksforgeeks.org/binary-search-tree-data-structure/" target="_blank" rel="noopener">binary search tree</a></strong> and a number <strong>k</strong>, find the greatest number in the binary search tree that is less than or equal to <strong>k</strong>.</span></p>
<p>Note: "If no such node value exists that is smaller than <em data-start="198" data-end="201">k</em>, then return -1."</p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root = [10</span><span style="font-size: 18.6667px;">, 7, 15, 2, 8, 11, 16</span><span style="font-size: 14pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">], k = 14</span><br /><span style="font-size: 14pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895571/Web/Other/blobid3_1747652897.jpg" width="250" height="195" /><br /><strong>Output:</strong> 11
<strong>Explanation:</strong> The greatest element in the tree which is less than or equal to 14, is 11.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root = [</span><span style="font-size: 18.6667px;">5, 2, 12, 1, 3, 9, 21, N, N, N, N, N, N, 19, 25</span><span style="font-size: 14pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">], k = 24</span><br /><span style="font-size: 14pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895571/Web/Other/blobid0_1747652607.jpg" width="288" height="251" /><br /><strong>Output:</strong> 21
<strong>Explanation:</strong> The greatest element in the tree which is less than or equal to 24, is 21. <br /></span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input:</strong><span style="font-size: 14pt;"> root = </span><span style="font-size: 18.6667px;">[5, 2, 12, 1, 3, 9, 21, N, N, N, N, N, N, 19, 25], k = 4</span><span style="font-size: 14pt;"><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895571/Web/Other/blobid2_1747652761.jpg" width="281" height="244" /><br /></span><strong style="font-size: 14pt;">Output:</strong><span style="font-size: 14pt;"> 3
</span><strong style="font-size: 14pt;">Explanation:</strong><span style="font-size: 14pt;"> The greatest element in the tree which is less than or equal to 4, is 3.<br /></span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>5<br /></sup>1 &lt;= node-&gt;data, k &lt;= 10<sup>5<br /></sup>All nodes are unique in the BST</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Closest Nodes Queries in a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary search tree </strong>and an array <code>queries</code> of size <code>n</code> consisting of positive integers.</p>

<p>Find a <strong>2D</strong> array <code>answer</code> of size <code>n</code> where <code>answer[i] = [min<sub>i</sub>, max<sub>i</sub>]</code>:</p>

<ul>
	<li><code>min<sub>i</sub></code> is the <strong>largest</strong> value in the tree that is smaller than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
	<li><code>max<sub>i</sub></code> is the <strong>smallest</strong> value in the tree that is greater than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
</ul>

<p>Return <em>the array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png" style="width: 261px; height: 281px;" />
<pre>
<strong>Input:</strong> root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
<strong>Output:</strong> [[2,2],[4,6],[15,-1]]
<strong>Explanation:</strong> We answer the queries in the following way:
- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].
- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].
- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png" style="width: 101px; height: 121px;" />
<pre>
<strong>Input:</strong> root = [4,null,9], queries = [3]
<strong>Output:</strong> [[-1,4]]
<strong>Explanation:</strong> The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>n == queries.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Construct Binary Search Tree from Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers preorder, which represents the <strong>preorder traversal</strong> of a BST (i.e., <strong>binary search tree</strong>), construct the tree and return <em>its root</em>.</p>

<p>It is <strong>guaranteed</strong> that there is always possible to find a binary search tree with the given requirements for the given test cases.</p>

<p>A <strong>binary search tree</strong> is a binary tree where for every node, any descendant of <code>Node.left</code> has a value <strong>strictly less than</strong> <code>Node.val</code>, and any descendant of <code>Node.right</code> has a value <strong>strictly greater than</strong> <code>Node.val</code>.</p>

<p>A <strong>preorder traversal</strong> of a binary tree displays the value of the node first, then traverses <code>Node.left</code>, then traverses <code>Node.right</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" style="height: 386px; width: 590px;" />
<pre>
<strong>Input:</strong> preorder = [8,5,1,7,10,12]
<strong>Output:</strong> [8,5,10,1,7,null,12]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> preorder = [1,3]
<strong>Output:</strong> [1,null,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 100</code></li>
	<li><code>1 &lt;= preorder[i] &lt;= 1000</code></li>
	<li>All the values of <code>preorder</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-bst-to-greater-tree/description" target="_blank" rel="noopener noreferrer">Convert BST to Greater Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>

<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" style="width: 500px; height: 341px;" />
<pre>
<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0,null,1]
<strong>Output:</strong> [1,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
	<li><code>root</code> is guaranteed to be a valid binary search tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1038: <a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank">https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Convert Sorted Array to Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword="height-balanced"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" style="width: 302px; height: 222px;" />
<pre>
<strong>Input:</strong> nums = [-10,-3,0,5,9]
<strong>Output:</strong> [0,-3,9,-10,null,5]
<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" style="width: 302px; height: 222px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" style="width: 342px; height: 142px;" />
<pre>
<strong>Input:</strong> nums = [1,3]
<strong>Output:</strong> [3,1]
<strong>Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Convert Sorted List to Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list where elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword="height-balanced"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" style="width: 500px; height: 388px;" />
<pre>
<strong>Input:</strong> head = [-10,-3,0,5,9]
<strong>Output:</strong> [0,-3,9,-10,null,5]
<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-bst-nodes-that-lie-in-a-given-range/1" target="_blank" rel="noopener noreferrer">Count BST nodes that lie in a given range</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Binary Search Tree (BST) and a range <strong>l-h (inclusive)</strong>, your task is to return the number of nodes in the BST whose value lie in the given range. </span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> root[] = [10, 5, 50, 1, N, 40, 100], l = 5, h = 45
         <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886458/Web/Other/blobid5_1738407930.png" alt="" width="267" height="239" />
<strong>Output: </strong>3<strong>
Explanation: </strong></span><span style="font-size: 18px;">There are three nodes in range [5, 45] =  5, 10 and 40.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root[] = [10, 5, 50, 1, N, 40, 100], l = 10, h = 100<br />         <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886458/Web/Other/blobid6_1738407930.png" alt="" width="266" height="219" />
<strong>Output: </strong>4<strong>
Explanation: </strong>There are four nodes in range [10, 100] = 10, 40, 50 and 100.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">root[] = [1, 2, 3], l = 23, h = 95<br />         <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUMAAAEbCAYAAABA7uadAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAEl0SURBVHhe7d0HuC1FlfbxVhQFw0gSlSgSJCtZco6CiiBDjgIKKqKgXCSLBCUoiAICklERVBgxIEkJo5JBQIIYQEQRBgcDYfzOr+5d52uaE+69Z+9zdlj/5+lnp94dV7+1atWqqpf97W9/+3eVJEnS57x8ymuSJElfk2KYJEkyQIphkiTJACmGSZIkA6QYJkmSDJBimCRJMkCKYZIkyQAphkmSJAOkGCZJkgyQYpgkSTJAimGSJMkAKYZJkiQDpBgmSZIMkGKYJEkyQIphkiTJACmGSZIkA6QYJkmSDJBimHQtL395mm/SOtKakrbxile8ovr3v/9dveY1r6lmnHHG6v/+7//KZyLmt1e96lXl+1jvueeeq55//vny3vLCCy+U/8S6//rXv8rvvkO8JkkryDlQkrZB9GaYYYbq73//e3l99atfXQSO6D377LNlnVe+8pXle6L41FNPlfV897KXvaz8jhBH4hcCabFeeodJq0gxTNpGeHc8Q6/3339/9fDDD1d33XVX9Zvf/Kb661//WkTxn//8Z3l9+umnq9e//vXVHHPMUf3Hf/xH9Y53vKN6y1veUr397W+v5pprrrK98BJj25YkaQUphknb4Omdf/751SOPPFJdcMEF1RNPPDHll5fCE+TphcjVq8DhOa6++urVRhttVG222WbVG97whim/JklrSDFMphtV2plmmqmInOqq6u9rX/va6qyzzqouueSS6qqrriqf//d//7cIGg9xvvnmq5Zccslq/vnnL15fnVlnnbV4h0R0wC6rBx54oLr77rurBx98sMQLLbCv9ddfv4iiV//jSfr9mWeeKZ6jYxuNjDkmdVIMk+mGKBGUEKnPfe5z1de+9rVS5fUdT2+xxRYr3txqq61WhJDnZwFvMGKDtqUKXP+OMBK6EEbV68svv7y66aabyu8EVrV6zTXXrA4++OBq0UUXLfFJeCXEI5FimNRJMUymm2j5PeKII4o3+I9//KN4h2J9W2+9dbXCCitUs802WxEsvxHJELu6+AX/8z//M+htevVbCJbPqs/WEWO88cYbq3POOae68847B0V52223rfbbb79q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" alt="" width="271" height="238" />
</span><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">0<br /></span><span style="font-size: 18.6667px;"><strong>Explanation:</strong> There are no nodes in range [23, 95].</span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= Number of nodes &lt;= 10<sup>5</sup><br />1 &lt;= l &lt;= h &lt; =10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-node-in-a-bst/description" target="_blank" rel="noopener noreferrer">Delete Node in a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>

<p>Basically, the deletion can be divided into two stages:</p>

<ol>
	<li>Search for a node to remove.</li>
	<li>If the node is found, delete the node.</li>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" style="width: 800px; height: 214px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 3
<strong>Output:</strong> [5,4,6,2,null,null,7]
<strong>Explanation:</strong> Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it&#39;s also accepted.
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" style="width: 350px; height: 255px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 0
<strong>Output:</strong> [5,3,6,2,4,null,7]
<strong>Explanation:</strong> The tree does not contain a node with value = 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [], key = 0
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>Each node has a <strong>unique</strong> value.</li>
	<li><code>root</code> is a valid binary search tree.</li>
	<li><code>-10<sup>5</sup> &lt;= key &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you solve it with time complexity <code>O(height of tree)</code>?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/delete-nodes-greater-than-k/1" target="_blank" rel="noopener noreferrer">Delete nodes greater than k</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a <strong>BST</strong> and a <strong>value k</strong>, the task is to delete the nodes having values <strong>greater than or equal to k</strong>.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
    4 &nbsp; 
   / \ <strong> </strong>
  1   9 
k = 2<strong> </strong>
<strong>Output:</strong>
1</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
The task is to complete the function <strong>deleteNode()</strong> which takes root, k as the argument, and returns the root of tree after deleting values greater than or equal to k. The driver code will print the inorder traversal of the updated tree in output itself. </span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(Size of tree)<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= T &lt;= 100<br />
1 &lt;= N &lt;= 10<sup>3</sup><br />
1 &lt;= A[] &lt;= 10<sup>3</sup><br />
1 &lt;= k&nbsp;&lt;= N</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-common-nodes-in-bst/1" target="_blank" rel="noopener noreferrer">Find Common Nodes in two BSTs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two Binary Search Trees. Find&nbsp;the&nbsp;nodes that are common in both of them, ie-&nbsp;find the intersection of the two BSTs.</span></p>
<p><span style="font-size: 18px;"><strong>Note</strong>: Return&nbsp;</span><span style="font-size: 18px;">the common nodes in <strong>sorted </strong>order.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong></span><strong><span style="font-size: 18px;">BST1:
</span></strong> <span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;5
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; &nbsp; \
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;  10
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; \ &nbsp; &nbsp;  /
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; 4&nbsp;&nbsp;&nbsp; 7
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;9
</span><strong><span style="font-size: 18px;">BST2:
</span></strong> <span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 10 
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  / &nbsp; &nbsp;\
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7&nbsp; &nbsp; &nbsp;20
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; \ 
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  4&nbsp; &nbsp; &nbsp;9
<strong><br />Output: </strong>4 7 9 10

</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:
BST1:
</strong>&nbsp;    10
&nbsp;   /  \
&nbsp;  2   11
&nbsp; /  \
&nbsp;1   3
<strong>BST2:
</strong>&nbsp;      2
&nbsp;    /  \
&nbsp;   1    3
<strong>Output: </strong>1 2 3
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= Number of Nodes &lt;= 10<sup>5</sup><br />1 &lt;= Node data &lt;= 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-mode-in-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Find Mode in Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)" target="_blank">mode(s)</a> (i.e., the most frequently occurred element) in it</em>.</p>

<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>

<p>Assume a BST is defined as follows:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" style="width: 142px; height: 222px;" />
<pre>
<strong>Input:</strong> root = [1,null,2,2]
<strong>Output:</strong> [2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this article, we will present many different approaches to solving this problem.</p>
<p>The level of these approaches varies greatly. Some approaches have different time complexities, while some simply present a different way of attacking the problem.</p>
<p>Note that not all of these approaches will be expected in an interview. At the start of each approach, there will be a comment regarding the difficulty of the approach and if it should be used in an interview.</p>
<p>For all approaches, we will assume that you are already familiar with how trees are given in LeetCode problems and how to traverse them.</p>
<hr />
<h3 id="approach-1-count-frequency-with-hash-map-dfs">Approach 1: Count Frequency With Hash Map (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This is a great first approach to use in an interview. It is simple, easy to implement, has good complexity, and demonstrates an understanding of binary trees and hash maps. You should be prepared for follow-ups after implementing this solution.</p>
</blockquote>
<p>Our goal is to find all the modes in the tree. A mode is a value that has the maximum frequency. Note that there could be multiple modes: for example, if we had the following tree:</p>
<p><img src="../Figures/501/1.png" alt="example" /><br />
<br></p>
<p>The frequency of each value is as follows:</p>
<table>
<thead>
<tr>
<th align="center">Value</th>
<th align="center">Frequency</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<br>
<p>The maximum frequency is <code>2</code>, thus we have two modes: <code>4</code> and <code>8</code>.</p>
<p>We can solve this problem by collecting the frequency of all values in the tree, finding the maximum frequency <code>maxFreq</code>, then checking which values have a frequency of <code>maxFreq</code>.</p>
<p>To count the frequency of each value, we will perform a depth-first search (DFS) on the tree to visit every node. We can initialize a hash map <code>counter</code> before starting the DFS. At each node we visit, we will update the frequency of <code>node.val</code> in <code>counter</code>.</p>
<p>Once we have finished the DFS (visited every node), <code>counter</code> will hold the frequency of all values. We will save the maximum frequency as <code>maxFreq</code>, then iterate over all the elements of <code>counter</code> and check which ones have a frequency equal to <code>maxFreq</code>. Each of those elements will be in our final answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a hash map <code>counter</code>.</li>
<li>Create a function <code>dfs(node, counter)</code>:
<ul>
<li>If <code>node</code> is null, immediately exit the function.</li>
<li>Increment the frequency of <code>node.val</code> in <code>counter</code>.</li>
<li>Call <code>dfs</code> on both children with <code>dfs(node.left, counter)</code> and <code>dfs(node.right, counter)</code>.</li>
</ul>
</li>
<li>Call <code>dfs(root, counter)</code>.</li>
<li>Find the maximum value in <code>counter</code> as <code>maxFreq</code>.</li>
<li>Initialize the answer list <code>ans</code>.</li>
<li>Iterate over all key-value pairs in <code>counter</code>. If the value is equal to <code>maxFreq</code>, add the key to <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>In Python, we are using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">collections.defaultdict</a> to make the code cleaner. It is similar to <code>std::unordered_map</code> in C++.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/BH7zk7gP/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work since hash map operations cost <span class="math inline">\(O(1)\)</span>.</p>
<p>Next, we find <code>maxFreq</code>, which involves iterating over <code>counter</code>. In the worst case scenario where the tree has only unique values, <code>counter</code> will have a size of <span class="math inline">\(n\)</span>, and thus this will cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we construct <code>ans</code>, which involves iterating over <code>counter</code> again. Overall, our time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, recursion is executed using the call stack. This call stack is equal to the depth of the tree, which in the worst case scenario is <span class="math inline">\(O(n)\)</span>. Also, as mentioned above, if the tree only has unique values then <code>counter</code> will have a size of <span class="math inline">\(n\)</span>. Thus, <code>counter</code> also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-iterative-dfs">Approach 2: Iterative DFS</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach may be asked as a follow-up to the previous approach, or vice-versa if you implement this one first. It is common for interviewers to ask you to solve a problem with DFS both recursively and iteratively.</p>
</blockquote>
<p>In this approach, we will use the same algorithm from the previous approach, except that we will implement the DFS iteratively.</p>
<p>Instead of using recursion, we will use a stack <code>stack</code>. Initially, we will have the <code>root</code> in the <code>stack</code>. Then, we will perform a DFS until the <code>stack</code> is empty using a while loop. At each iteration, we pop a <code>node</code> from the <code>stack</code>. We will increment the frequency of <code>node</code> in <code>counter</code> just like we did in the previous approach, then push the children of <code>node</code> to <code>stack</code> if they exist. In this way, we go as deep into the tree as possible before backtracking, similar to node exploration in recursive DFS.</p>
<p>Each iteration of the while loop is analogous to a function call from the previous approach, as we are handling a given <code>node</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a hash map <code>counter</code> and a stack <code>stack</code> that contains <code>root</code>.</li>
<li>Perform a DFS. While <code>stack</code> is not empty:
<ul>
<li>Pop <code>node</code> from the top of <code>stack</code>.</li>
<li>Increment the frequency of <code>node.val</code> in <code>counter</code>.</li>
<li>If <code>node.left</code> is not null, push it to <code>stack</code>.</li>
<li>If <code>node.right</code> is not null, push it to <code>stack</code>.</li>
</ul>
</li>
<li>Find the maximum value in <code>counter</code> as <code>maxFreq</code>.</li>
<li>Initialize the answer list <code>ans</code>.</li>
<li>Iterate over all key-value pairs in <code>counter</code>. If the value is equal to <code>maxFreq</code>, add the key to <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/QiC3LGWA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work since hash map and stack operations cost <span class="math inline">\(O(1)\)</span>.</p>
<p>Next, we find <code>maxFreq</code>, which involves iterating over <code>counter</code>. In the worst case scenario where the tree has only unique values, <code>counter</code> will have a size of <span class="math inline">\(n\)</span>, and thus this will cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we construct <code>ans</code>, which involves iterating over <code>counter</code> again. Overall, our time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, <code>stack</code> may grow to a size of <span class="math inline">\(O(n)\)</span>. Also, as mentioned above, if the tree only has unique values then <code>counter</code> will have a size of <span class="math inline">\(n\)</span>. Thus, <code>counter</code> also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-breadth-first-search-bfs">Approach 3: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>Again, this approach may be asked as a follow-up if you implemented DFS first, or vice-versa. It is also common for interviewers to ask you to implement both DFS and BFS.</p>
<p>We have included approaches 2 and 3 to demonstrate the usage of iterative DFS and BFS to solve this problem. We are able to do this because there isn't really a difference in using recursive DFS, iterative DFS, or BFS for this algorithm - we simply need to visit each node.</p>
</blockquote>
<p>In this approach, we again use the same algorithm from the first two approaches. This time, we will perform the traversal using BFS.</p>
<p>With BFS, instead of using a stack (or the recursion stack) like in DFS, we use a queue. The main difference is that we handle nodes in a first-in, first-out fashion (FIFO) as opposed to in DFS where we handle nodes in a last-in, first-out (LIFO) fashion. This results in us visiting each node by depth - we can imagine the root at depth <code>0</code>, the root's children at depth <code>1</code>, the children of those children at depth <code>2</code>, and so on.</p>
<p><img src="../Figures/501/bfs.png" alt="example" /><br />
<br></p>
<p>With BFS, we visit all nodes at a depth of <code>x</code> before visiting any node at a depth of <code>x + 1</code>. While BFS excels over DFS for many problems, in this problem it is just another way for us to perform the traversal. We simply need to visit each node in the tree so that we can record the frequencies in <code>counter</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a hash map <code>counter</code> and a queue <code>queue</code> that contains <code>root</code>.</li>
<li>Perform a BFS. While <code>queue</code> is not empty:
<ul>
<li>Pop <code>node</code> from the front of <code>queue</code>.</li>
<li>Increment the frequency of <code>node.val</code> in <code>counter</code>.</li>
<li>If <code>node.left</code> is not null, push it to <code>queue</code>.</li>
<li>If <code>node.right</code> is not null, push it to <code>queue</code>.</li>
</ul>
</li>
<li>Find the maximum value in <code>counter</code> as <code>maxFreq</code>.</li>
<li>Initialize the answer list <code>ans</code>.</li>
<li>Iterate over all key-value pairs in <code>counter</code>. If the value is equal to <code>maxFreq</code>, add the key to <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>In Python, we are using <a href="https://docs.python.org/3/library/collections.html#collections.deque">collections.deque</a> to implement an efficient queue.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/maqHS24V/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the BFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work since hash map and queue operations cost <span class="math inline">\(O(1)\)</span>. Note that this assumes that the implementation of <code>queue</code> is efficient. In the code we presented above, all implementations are efficient.</p>
<p>Next, we find <code>maxFreq</code>, which involves iterating over <code>counter</code>. In the worst-case scenario where the tree has only unique values, <code>counter</code> will have a size of <span class="math inline">\(n\)</span>, and thus this will cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we construct <code>ans</code>, which involves iterating over <code>counter</code> again. Overall, our time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, <code>queue</code> may grow to a size of <span class="math inline">\(O(n)\)</span>. Also, as mentioned above, if the tree only has unique values then <code>counter</code> will have a size of <span class="math inline">\(n\)</span>. Thus, <code>counter</code> also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-4-no-hash-map">Approach 4: No Hash-Map</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach is another way to attack the problem compared to the previous three approaches. It is slightly more complex and can be implemented if the interviewer asks for an alternate way to solve the problem. While this approach has the same time and space complexity as the first three, it runs slightly faster as we avoid the overhead associated with hash maps.</p>
</blockquote>
<p>So far, we have not taken advantage of the fact that the input tree is a binary search tree (with duplicates). The first three approaches would work for <strong>any</strong> binary tree.</p>
<p>If you perform an inorder DFS traversal on a binary search tree (BST), you will handle the nodes in <strong>sorted</strong> order. Why?</p>
<p>Recall that in a BST, all nodes to the left are less than the current node and all nodes to the right are greater than the current node. In an inorder traversal, we handle all the nodes on the left first, then the current node, and then all the nodes to the right.</p>
<p>The fact that there are duplicates in the BSTs given in this problem does not change this property - we will still handle nodes in sorted order during an inorder traversal. So how does this help us? If we can obtain the nodes in sorted order, then we can find the most frequent elements without needing a hash map.</p>
<p>Let's say we have a list <code>values</code> that has all the values in the tree in sorted order. Any duplicated values must be adjacent to each other in this list since it is sorted. We can iterate over this list from left to right and keep count of a streak - how many of the same number we have seen in a row. Let's call our current streak <code>currStreak</code>, and the number we have seen most recently <code>currNum</code>. For each <code>num</code> we iterate over:</p>
<ul>
<li>If <code>num = currNum</code>, then we can increment <code>currStreak</code> by <code>1</code>.</li>
<li>If <code>num != currNum</code>, then we must start a new streak. We update <code>currNum = num</code> and reset <code>currStreak = 1</code>.</li>
</ul>
<p>We will also maintain the <code>maxStreak</code> we have seen so far. When we find a new streak with a longer length, i.e. <code>currStreak &gt; maxStreak</code>, we update <code>maxStreak</code> and reset the answer, since all the numbers stored in the answer are guaranteed not to be modes. When we find that <code>currStreak = maxStreak</code>, we can add the current <code>num</code> to the answer.</p>
<p>!?!../Documents/501.json:960,540!?!<br />
<br></p>
<p>Once we have finished iterating through the array, <code>maxStreak</code> represents the max frequency and our answer list <code>ans</code> will hold all the values that have this frequency.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Perform an inorder DFS using a recursive <code>dfs</code> function to traverse the input tree. At each <code>node</code>, add <code>node.val</code> to a list <code>values</code>.</li>
<li>Initialize variables <code>maxStreak, currStreak, currNum</code> to <code>0</code> and an empty list <code>ans</code>.</li>
<li>Iterate over <code>values</code>. At each <code>num</code>:
<ul>
<li>If <code>num = currNum</code>, increment <code>currStreak</code>. Otherwise, set <code>currStreak = 1, currNum = num</code>.</li>
<li>If <code>currStreak &gt; maxStreak</code>, update <code>maxStreak = currStreak</code> and reset <code>ans</code>.</li>
<li>If <code>currStreak = maxStreak</code>, add <code>num</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/3Yvsv9sP/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
<p>After the DFS, we iterate over <code>values</code> which has a length of <span class="math inline">\(n\)</span>. At each iteration, we perform <span class="math inline">\(O(1)\)</span> work. Overall, we perform <span class="math inline">\(O(n)\)</span> work.</p>
<p>You may notice that the runtime of this algorithm is faster than the first three approaches. This is because while hash map operations are <span class="math inline">\(O(1)\)</span>, the constant overhead still takes a little bit of time, especially compared to just using a list.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, recursion is executed using the call stack. This call stack is equal to the depth of the tree, which in the worst-case scenario is <span class="math inline">\(O(n)\)</span>. Also, the <code>values</code> array always grows to a size of <span class="math inline">\(n\)</span>, and thus also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-5-no-values-array">Approach 5: No &quot;Values&quot; Array</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach could be asked as a follow-up to the previous approach. It also satisfies the follow-up given in the problem description (at the bottom, under the constraints). The only extra space we will use in this approach is the call stack from recursion.</p>
</blockquote>
<p>In the previous approach, we perform an inorder traversal to create a <code>values</code> list. We then iterate over the <code>values</code> list. Do we need this extra list?</p>
<p>The answer is no: because by definition, the values we iterate over in <code>values</code> are the same values we visit during the inorder traversal, in the same order. Thus, we can perform the same logic on the fly during the inorder DFS, instead of performing DFS once to record the numbers in <code>values</code>, and then traversing <code>values</code> to count the recorded numbers.</p>
<p>We will use the same process: initialize <code>maxStreak, currStreak, currNum</code> as global variables. Perform an inorder traversal using recursion, and at each <code>node</code>, treat <code>num = node.val</code> and perform the same logic from the previous approach.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize global variables <code>maxStreak, currStreak, currNum</code> to <code>0</code> and an empty list <code>ans</code>.</li>
<li>Perform an inorder traversal from <code>root</code>. At each <code>node</code>:
<ul>
<li>If <code>node</code> is null, immediately exit the function.</li>
<li>Call <code>dfs(node.left)</code>.</li>
<li>Set <code>num = node.val</code>.</li>
<li>If <code>num = currNum</code>, increment <code>currStreak</code>. Otherwise, set <code>currStreak = 1, currNum = num</code>.</li>
<li>If <code>currStreak &gt; maxStreak</code>, update <code>maxStreak = currStreak</code> and reset <code>ans</code>.</li>
<li>If <code>currStreak = maxStreak</code>, add <code>num</code> to <code>ans</code>.</li>
<li>Call <code>dfs(node.right)</code>.</li>
</ul>
</li>
<li>Return <code>ans.</code></li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/6ueeqDnu/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We perform a DFS, visiting each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, recursion is executed using the call stack. This call stack is equal to the depth of the tree, which in the worst case scenario is <span class="math inline">\(O(n)\)</span>.</p>
<p>Note that space used by the answer is not considered part of the space complexity. If we don't count the recursion call stack space either (as suggested in the problem description's follow-up), then this approach uses <span class="math inline">\(O(1)\)</span> space as we only use a few extra variables like <code>maxStreak, currStreak, currNum</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-6-true-constant-space-morris-traversal">Approach 6: True Constant Space: Morris Traversal</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach is very advanced and would not be expected in an interview. We have included it for completeness.</p>
</blockquote>
<p>We will continue using the same idea from the previous approach. Is there a way for us to perform the inorder traversal without using any space, including the recursion call stack?</p>
<p>Morris traversal is an advanced technique that allows us to traverse a binary tree with constant auxiliary space. In this approach, we will implement a variant of Morris traversal that will still allow us to achieve an <span class="math inline">\(O(1)\)</span> space complexity. To understand Morris traversal, we must first understand why a stack is &quot;necessary&quot; during DFS.</p>
<p><img src="../Figures/501/10.png" alt="example" /><br />
<br></p>
<p>In the above tree, we start at the root and move to the left child. Once we are finished fully handling the left subtree, we then handle the root, and finally the right subtree. The reason we use extra stack space during DFS is to &quot;remember&quot; the root and right subtree. Think about it: if we move to <code>root.left</code>, how can we get back to <code>root</code> and thus <code>root.right</code>?</p>
<p><img src="../Figures/501/11.png" alt="example" /><br />
<br></p>
<p>Furthermore, when we are the green node, how do we get back to the blue nodes? Let's assign each node a <strong>friend</strong>. A node's friend is the <strong>rightmost</strong> node in the left subtree. That is, to find the friend of <code>node</code>, we first do <code>node = node.left</code>, then do <code>node = node.right</code> until there is no right child.</p>
<p><img src="../Figures/501/12.png" alt="example" /><br />
<br></p>
<p>You may notice that some nodes will not have a friend. Namely, a node will not have a friend if it does not have a left child.</p>
<p><img src="../Figures/501/13.png" alt="example" /><br />
<br></p>
<p>Morris traversal takes advantage of the following facts:</p>
<blockquote>
<ol>
<li>
<p>All friends are unique. That is, a node cannot be the friend of more than one node.</p>
</li>
<li>
<p>Friend nodes do not have the right children. This is because, by definition, we find friend nodes by traversing right until there is no right child.</p>
</li>
</ol>
</blockquote>
<p>Thus, we can safely assign the right child of each friend to the node it is a friend to. In the following examples, we are numbering the nodes arbitrarily (these are not the values of a binary search tree):</p>
<p><img src="../Figures/501/14.png" alt="example" /><br />
<br></p>
<p>The rightmost node in the left subtree of the root is the node labeled <code>4</code>. Thus, we can assign the right child of <code>4</code> to the root.</p>
<p><img src="../Figures/501/15.png" alt="example" /><br />
<br></p>
<p>In these example images, green edges will indicate &quot;friend&quot; edges. Notice that now, we have a way back to the root (and thus the right subtree of the root) after entering the left subtree! Let's add the other friend edges.</p>
<p><img src="../Figures/501/16.png" alt="example" /><br />
<br></p>
<p>With these friend edges, we can now perform an inorder traversal without recursion or a stack! We start by handling the <code>3</code>, then use the friend edge to get back to <code>1</code>. We handle the <code>1</code>, then the <code>4</code>, and then use the friend edge to get back to the root. After handling the root, we handle the <code>5</code>, then use the friend edge to get back to the <code>2</code>, which is the final node in our inorder traversal.</p>
<p>Now comes the tricky part: how do we implement this idea? We will use the following process. First, initialize <code>curr = root</code>. This represents the current node that we iterating on. Next, we perform the following in a while loop until <code>curr = null</code>, indicating we have finished the traversal:</p>
<ul>
<li>If <code>curr.left != null</code>, we will find the <code>friend</code> of <code>curr</code>. After finding <code>friend</code>, we set <code>friend.right = curr</code> then move to the left subtree with <code>curr = curr.left</code>. Once we are in the left subtree, we should delete the edge to prevent any infinite loops.</li>
<li>If <code>curr.left = null</code>, it means there is no left subtree. We can handle this node now, then move to the right with <code>curr = curr.right</code>.</li>
</ul>
<p>We will quickly demonstrate the traversal using the previous example. At any given time, the green node is <code>curr</code>.</p>
<p><img src="../Figures/501/17.png" alt="example" /><br />
<br></p>
<p>Initially, <code>curr = root</code>. Because there is a left subtree, we will find the friend.</p>
<p><img src="../Figures/501/18.png" alt="example" /><br />
<br></p>
<p>We find the friend by moving to the left subtree, then moving right as much as we can. Set <code>friend.right = curr</code>. Next, we set <code>curr = curr.left</code>.</p>
<p><img src="../Figures/501/19.png" alt="example" /><br />
<br></p>
<p>After we move to the left subtree, we must delete the edge we used. This is is so when we return back to the root, we don't repeat the process we just performed (as without deleting the edge, <code>root.left != null</code>).</p>
<p><img src="../Figures/501/20.png" alt="example" /><br />
<br></p>
<p>Again, <code>curr.left != null</code>, so we find the <code>friend</code> and set <code>friend.right = curr</code>. Then we move to the left subtree and delete the edge.</p>
<p><img src="../Figures/501/21.png" alt="example" /><br />
<br></p>
<p>At the node labeled <code>3</code>, we have no left subtree. Thus we can now handle this node and move to <code>curr.right</code>, which you will notice is the friend edge we created earlier.</p>
<p><img src="../Figures/501/22.png" alt="example" /><br />
<br></p>
<p><img src="../Figures/501/23.png" alt="example" /><br />
<br></p>
<p>The next two nodes, <code>1</code> and <code>4</code> are handled the same way. Notice that so far, we have handled nodes in the order <code>3, 1, 4</code>, which is the correct order for an inorder traversal. Now, we find ourselves back at the <code>root</code>. Because we deleted the left edge earlier, we now move to handle the <code>root</code> and move right.</p>
<p><img src="../Figures/501/24.png" alt="example" /><br />
<br></p>
<p><img src="../Figures/501/25.png" alt="example" /><br />
<br></p>
<p>We have reached another node where <code>curr.left != null</code>. We find the friend and set the right edge.</p>
<p><img src="../Figures/501/26.png" alt="example" /><br />
<br></p>
<p>At the node labeled <code>5</code>, we find that <code>curr.left = null</code>. Thus, we handle the node and then move right (back to the <code>2</code>, as we set this &quot;friend&quot; edge earlier).</p>
<p><img src="../Figures/501/27.png" alt="example" /><br />
<br></p>
<p>We finally handle the last node. The traversal ends as we move right, but there is no right child. We handled the nodes in the correct order: <code>3, 1, 4, 0, 5, 2</code>.</p>
<p>Finally, we solve the problem by using the same algorithm from the previous approach during our Morris traversal.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize variables <code>maxStreak, currStreak, currNum</code> to <code>0</code> and an empty list <code>ans</code>. Also, initialize <code>curr = root</code>.</li>
<li>While <code>curr != null</code>, perform Morris traversal:
<ul>
<li>If <code>curr.left != null</code>:
<ul>
<li>Find <code>friend</code>. We first set <code>friend = curr.left</code>, then move with <code>friend = friend.right</code> as long as <code>friend.right</code> exists.</li>
<li>Once <code>friend</code> is found, we set <code>friend.right = curr</code>.</li>
<li>Move to <code>curr.left</code> and delete the edge. You can do this by first saving <code>left = curr.left</code>, then setting <code>curr.left = null</code>, and finally performing <code>curr = left</code>.</li>
</ul>
</li>
<li>Otherwise, <code>curr.left = null</code>:
<ul>
<li>Set <code>num = curr.val</code>.</li>
<li>If <code>num = currNum</code>, increment <code>currStreak</code>. Otherwise, set <code>currStreak = 1, currNum = num</code>.</li>
<li>If <code>currStreak &gt; maxStreak</code>, update <code>maxStreak = currStreak</code> and reset <code>ans</code>.</li>
<li>If <code>currStreak = maxStreak</code>, add <code>num</code> to <code>ans</code>.</li>
<li>Perform <code>curr = curr.right</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans.</code></li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note: <code>friend</code> is a keyword in C++, so we will use <code>friendNode</code> as the variable name instead.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/8HrkiKo3/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>You may be thinking: there is a nested while loop, wouldn't this algorithm have a time complexity of <span class="math inline">\(O(n^2)\)</span>? The answer is no because the inner while loop can only iterate <span class="math inline">\(O(n)\)</span> times total across the entire algorithm.</p>
<p>In a binary tree with <span class="math inline">\(n\)</span> nodes, there are <span class="math inline">\(n - 1\)</span> edges. This is because every node except for the root has a parent. During a Morris traversal, we never use an edge more than twice. We use each edge once to move <code>curr</code> through the tree, and we use each edge another time to find friends.</p>
<p>This means we have <span class="math inline">\(O(2 \cdot (n - 1)) = O(n)\)</span> edge iterations. Thus, the Morris traversal overall costs <span class="math inline">\(O(n)\)</span>, since everything else we do costs <span class="math inline">\(O(1)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We don't count the answer as part of the space complexity. The only extra space we use is a few extra variables like <code>maxStreak, currStreak, currNum</code>. Thus, we have achieved a true <span class="math inline">\(O(1)\)</span> space complexity.</p>
<p>Note that we are modifying the input in this algorithm, which may be considered a bad practice. Some people will also argue that by modifying the input, we should also include it in the space complexity.</p>
</li>
</ul>
<br/>
<p><strong>Morris Traversal Follow-Up</strong></p>
<p>As mentioned before, what we have implemented above is a variant of the traditional Morris traversal. One drawback to this variant is that the tree is heavily modified after the traversal. With some small changes, we can actually &quot;repair&quot; the tree to its original state while still accomplishing an <span class="math inline">\(O(1)\)</span> space traversal!</p>
<p>This article focused on the variant for the sake of brevity. We encourage any eager readers to try and implement the standard traversal on their own as a follow-up.</p>
<details>
<summary>Click here to see the solution!</summary>
<p><a href="https://leetcode.com/playground/X5m5zXQy/shared">code</a></p>
</details>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/increasing-order-search-tree/description" target="_blank" rel="noopener noreferrer">Increasing Order Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" style="width: 600px; height: 350px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" style="width: 300px; height: 114px;" />
<pre>
<strong>Input:</strong> root = [5,1,7]
<strong>Output:</strong> [1,null,5,null,7]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/inorder-traversal-and-bst5855/1" target="_blank" rel="noopener noreferrer">Inorder Traversal and BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr&nbsp;</strong>of size <strong>N,&nbsp;</strong>determine whether this array represents an <strong>inorder traversal</strong> of a <strong>BST.&nbsp;</strong></span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;All keys in BST must be unique.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 3
arr = {2, 4, 5}
<strong>Output:</strong> 1
<strong>Explaination:</strong> <br />Given array is inorder traversal for the following tree:<br /> &nbsp; &nbsp;<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/705301/Web/Other/blobid0_1749732160.webp" height="100" /><br /></span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 3
arr = {2, 4, 1}
<strong>Output:</strong> 0
<strong>Explaination:</strong> <br />Given array can not represent any BST.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>isRepresentingBST()</strong>&nbsp;which takes the array <strong>arr[]</strong> and its size <strong>N&nbsp;</strong>as input parameters&nbsp;and returns&nbsp;<strong>1</strong> if array represents Inorder traversal of a BST, else returns <strong>0</strong>. </span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N)<br /><strong>Expected Auxiliary Space:</strong> O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 10<sup>5</sup><br />1 &le; arr[i]&nbsp;&le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/insert-into-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Insert into a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>

<p><strong>Notice</strong>&nbsp;that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" style="width: 752px; height: 221px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3], val = 5
<strong>Output:</strong> [4,2,7,1,3,5]
<strong>Explanation:</strong> Another accepted tree is:
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" style="width: 352px; height: 301px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [40,20,60,10,30,50,70], val = 25
<strong>Output:</strong> [40,20,60,10,30,50,70,null,null,25]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
<strong>Output:</strong> [4,2,7,1,3,5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in&nbsp;the tree will be in the range <code>[0,&nbsp;10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>8</sup> &lt;= Node.val &lt;= 10<sup>8</sup></code></li>
	<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>-10<sup>8</sup> &lt;= val &lt;= 10<sup>8</sup></code></li>
	<li>It&#39;s <strong>guaranteed</strong> that <code>val</code> does not exist in the original BST.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/is-binary-tree-heap/1" target="_blank" rel="noopener noreferrer">Is Binary Tree Heap</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">heap</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a binary tree, and the task is to determine whether it satisfies the properties of a max-heap.</span></p>
<p><span style="font-size: 14pt;">A binary tree is considered a max-heap if it satisfies the following conditions:</span></p>
<ol>
<li><span style="font-size: 14pt;"><strong>Completeness</strong>: Every level of the tree, except possibly the last, is completely filled, and all nodes are as far left as possible.</span></li>
<li><span style="font-size: 14pt;"><strong>Max-Heap Property</strong>: The value of each node is greater than or equal to the values of its children.</span></li>
</ol>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> root[] = [97, 46, 37, 12, 3, 7, 31, 6, 9]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/881982/Web/Other/blobid0_1733648140.jpg" width="300" height="268" /> <br /><strong>Output: </strong>true
<strong>Explanation:</strong> The tree is complete and satisfies the max-heap property.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> root[] = [97, 46, 37, 12, 3, 7, 31, N, 2, 4] <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/881982/Web/Other/blobid1_1733648320.jpg" width="300" height="268" /> <br /><strong>Output:</strong> false<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation:</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> </span>The tree is not complete and does not follow the Max-Heap Property, hence it is not a max-heap.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; number of nodes &le; 10<sup>3</sup><br />1 &le; node-&gt;data &le;&nbsp;10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-largest-element-in-a-stream/description" target="_blank" rel="noopener noreferrer">Kth Largest Element in a Stream</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are part of a university admissions office and need to keep track of the <code>kth</code> highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.</p>

<p>You are tasked to implement a class which, for a given integer&nbsp;<code>k</code>, maintains a stream of test scores and continuously returns the&nbsp;<code>k</code>th highest test score&nbsp;<strong>after</strong>&nbsp;a new score has been submitted. More specifically, we are looking for the <code>k</code>th highest score in the sorted list of all scores.</p>

<p>Implement the&nbsp;<code>KthLargest</code> class:</p>

<ul>
	<li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of test scores&nbsp;<code>nums</code>.</li>
	<li><code>int add(int val)</code> Adds a new test score&nbsp;<code>val</code> to the stream and returns the element representing the <code>k<sup>th</sup></code> largest element in the pool of test scores so far.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]<br />
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[null, 4, 5, 5, 8, 8]</span></p>

<p><strong>Explanation:</strong></p>

<p>KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);<br />
kthLargest.add(3); // return 4<br />
kthLargest.add(5); // return 5<br />
kthLargest.add(10); // return 5<br />
kthLargest.add(9); // return 8<br />
kthLargest.add(4); // return 8</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]<br />
[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[null, 7, 7, 7, 8]</span></p>

<p><strong>Explanation:</strong></p>
KthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);<br />
kthLargest.add(2); // return 7<br />
kthLargest.add(10); // return 7<br />
kthLargest.add(9); // return 7<br />
kthLargest.add(9); // return 8</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= k &lt;= nums.length + 1</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Imagine a university admissions office wants to keep track of the <code>k-th</code> highest test scores from applicants in real time. This allows them to dynamically determine the cut-off score as new applications come in. To achieve this, we'll create a class <code>KthLargest</code> that can return the <code>k-th</code> largest element for an incoming stream of numbers. Specifically, we need to implement:</p>
<ol>
<li>The constructor <code>KthLargest(int k, int[] nums)</code>, which initializes the class with <code>k</code> and the initial stream of numbers <code>num</code>,</li>
<li>The function <code>add(int val)</code>, which adds a new number <code>val</code> into the existing stream of numbers, and returns the <code>k-th</code> largest element of the updated stream.</li>
</ol>
<h3 id="approach-1-maintain-sorted-list">Approach 1: Maintain Sorted List</h3>
<h3 id="intuition">Intuition</h3>
<p>In this problem, we need to be able to repeatedly fetch the <code>k-th</code> largest element from a growing stream of numbers. Suppose we assume that the stream of numbers is always sorted in ascending order. In that case, returning the <code>k-th</code> largest element becomes a straightforward operation of fetching the <code>k-th</code> element from the end of the stream.</p>
<p>Thus, one approach is to maintain a list that stores the entire stream of numbers seen so far, and ensure the list remains sorted each time we add a new element. This allows us to fetch the <code>k-th</code> largest element with no extra work.</p>
<p>For our constructor, we can initialize our list <code>stream</code> with the initial set of numbers <code>nums</code> provided, and then sort <code>stream</code> in ascending order.</p>
<p>For every new <code>val</code> added to the <code>stream</code> by the <code>add(int val)</code> call, we ensure <code>val</code> is inserted at the correct position so that <code>stream</code> remains sorted. Because <code>stream</code> is sorted beforehand, we can efficiently find the correct position for <code>val</code> by using <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search</a>.</p>
<p>For this binary search insertion:</p>
<ol>
<li>We start with the entirety of <code>stream</code> as our search space</li>
<li>We check the middle element <code>stream[mid]</code>
<ul>
<li>If <code>stream[mid] == val</code> then we know that we can add <code>val</code> at index <code>mid</code></li>
<li>If <code>stream[mid] &lt; val</code>, then <code>val</code> needs to be added to the right of <code>stream[mid]</code>, so we limit the search space to the right half of <code>stream</code>.</li>
<li>If <code>stream[mid]</code> is greater than <code>val</code>,<code>val</code> needs to be added to the left of <code>stream[mid]</code>, so we limit the search space to the left half of <code>stream</code>.</li>
</ul>
</li>
<li>We can repeat this procedure until we narrow down our search space to the correct index to add <code>val</code>.</li>
</ol>
<p>After inserting <code>val</code> in the correct position, we can return <code>stream[stream.length - k]</code>, which is the <code>k-th</code> largest element in the stream.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>In the constructor:
<ul>
<li>Initialize class variable <code>k</code></li>
<li>Initialize class variable list <code>stream</code></li>
<li>Add all of <code>nums</code> to <code>stream</code>, used to keep track of the total stream.</li>
<li>Sort <code>stream</code> in ascending order</li>
</ul>
</li>
<li>In the <code>add(int val)</code> function:
<ul>
<li>Call helper function <code>getIndex(int val)</code> to find the index <code>i</code> to add <code>val</code></li>
<li>Insert <code>val</code> in <code>stream</code> at index <code>i</code></li>
<li>Return the <code>k-th</code> largest element in <code>stream</code>, at index <code>stream.size() - k</code></li>
</ul>
</li>
<li>In the <code>getIndex(int val)</code>:
<ul>
<li><strong>Define starting search space</strong>: Initialize <code>left</code> to <code>0</code> and <code>right</code> to <code>stream.size() - 1</code></li>
<li>While <code>left &lt;= right</code>:
<ul>
<li><strong>Calculate index for middle element</strong>: Initialize <code>mid</code> to <code>(left + right) / 2</code></li>
<li><strong>Get middle element</strong>: Initialize <code>midElement</code> to <code>stream.get(mid)</code></li>
<li>If <code>midElement == val</code> return <code>mid</code></li>
<li>If <code>midElement &gt; val</code>:
<ul>
<li><strong>Go to left half of search space</strong>: Reassign <code>right</code> to <code>mid - 1</code></li>
</ul>
</li>
<li>If <code>midElement &lt; val</code>:
<ul>
<li><strong>Go to right half of search space</strong>: Reassign <code>left</code> to <code>mid + 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/eBbNQ3hn/shared">code</a></p>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<p>Let <span class="math inline">\(M\)</span> be the size of the initial stream <code>nums</code> given in the constructor. Let <span class="math inline">\(N\)</span> be the number of calls of <code>add</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N^2 + N \cdot M)\)</span></p>
<p>The constructor involves creating a list <code>stream</code> from <code>nums</code>, which takes <span class="math inline">\(O(M)\)</span> time. Then, sorting this list takes <span class="math inline">\(O(M \cdot \log M)\)</span> time. Thus, the time complexity of the constructor is <span class="math inline">\(O(M \cdot \log M)\)</span> time.</p>
<p>The <code>add</code> function involves running a binary search on <code>stream</code>. Because the total size of <code>stream</code> at the end would be <span class="math inline">\(O(M + N)\)</span>, each binary search is bounded by a time complexity of <span class="math inline">\(O(\log(M + N))\)</span>. Moreover, adding a number in <code>stream</code> can take worst-case <span class="math inline">\(O(M + N)\)</span> time, as adding an element in the middle of a list can offset all the elements to its right. Then, the time complexity of a single <code>add</code> call would be <span class="math inline">\(O(M + N + \log(M + N))\)</span>. Because <code>add</code> is called <span class="math inline">\(N\)</span> times, the time complexity of all the <code>add</code> calls would be <span class="math inline">\(O(N \cdot (M + N + \log(M + N)))\)</span>.</p>
<p>We see that after expanding the time complexity for the <code>add</code> function, the <span class="math inline">\(N \cdot M\)</span> and <span class="math inline">\(N^2\)</span> terms dominate all the other <span class="math inline">\(\log\)</span> terms in our calculations, so the total time complexity is <span class="math inline">\(O(N^2 + N \cdot M)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>The maximum size for <code>stream</code> is <span class="math inline">\(M + N\)</span>, so the total space complexity is <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-heap">Approach 2: Heap</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In Approach 1, sorting the entire stream of numbers seems unnecessary because we only need the <code>k-th</code> largest element. Maintaining a sorted list becomes costly as its size increases. To optimize, we can focus on only the necessary elements for retrieving and updating the <code>k-th</code> largest element.</p>
<p>!?!../Documents/703/slideshow1.json:960,540!?!</p>
<p>Consider a stream of numbers <code>[0, 4, 6, 9]</code> where <code>k = 3</code> and incoming <code>val = 2</code>. Before adding <code>2</code>, the <code>k-th</code> largest element is <code>4</code>. Adding <code>2</code> does not affect <code>4</code>'s position since <code>2</code> is smaller. Now, if the incoming value is <code>7</code>, which is greater than both <code>4</code> and <code>6</code>, <code>7</code> would become the 2nd largest number, pushing <code>6</code> to be the new <code>k-th</code> largest element, and <code>4</code> is no longer in the top <code>k</code>.</p>
<p>!?!../Documents/703/slideshow2.json:960,540!?!</p>
<p>From this example, we see that keeping track of just the <code>k</code> largest elements allows us to efficiently maintain the <code>k-th</code> largest element:</p>
<ol>
<li><strong>If an incoming element <code>val</code> is smaller than or equal to the existing <code>k-th</code> largest element</strong>: The <code>k</code> largest elements remain unchanged, and we can return the current <code>k-th</code> largest element.</li>
<li><strong>If <code>val</code> is larger than the current <code>k-th</code> largest element</strong>: It replaces the current <code>k-th</code> largest element. After adding <code>val</code>, the new <code>k-th</code> largest element is the next largest element.</li>
</ol>
<p>To efficiently maintain the <code>k</code> largest elements, we use a min-heap. In a min-heap, elements are organized such that the smallest element is always at the top (root node), providing <span class="math inline">\(O(1)\)</span> access time. Adding elements and removing the top element from the min-heap can be done in <span class="math inline">\(O(\log n)\)</span> time.</p>
<p>For our problem, the min-heap will contain the <code>k</code> largest elements, with the <code>k-th</code> largest element at the top. If a new <code>val</code> is greater than the <code>k-th</code> largest element, we add <code>val</code> to the heap and remove the top element, keeping the heap size at <code>k</code> and updating the <code>k-th</code> largest element.</p>
<p>In our optimized approach, we initialize the min-heap with the initial stream <code>nums</code> in the constructor and ensure it contains only the <code>k</code> largest elements. In the <code>add(int val)</code> function, if <code>val</code> is smaller than the current <code>k-th</code> largest element and the heap already contains <code>k</code> elements, we return the top element. Otherwise, we add <code>val</code>, remove the top element if the heap size exceeds <code>k</code>, and return the updated top element.</p>
<p>This approach is more efficient in both time and space complexity compared to maintaining a fully sorted list, as the relaxed ordering of a heap allows quick access and updates to the <code>k</code> largest elements without the overhead of sorting the entire stream.</p>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>In the constructor:
<ul>
<li>Initialize class variable <code>k</code> to the input value <code>k</code></li>
<li>Initialize a class <code>PriorityQueue</code> <code>minHeap</code> to hold the <code>k</code> largest elements</li>
<li>Iterate through each element <code>num</code> in the initial stream <code>nums</code>:
<ul>
<li>Call <code>add(num)</code></li>
</ul>
</li>
</ul>
</li>
<li>In the <code>add(int val)</code> function:
<ul>
<li>If <code>val</code> is greater than the smallest element in <code>minHeap</code> or the size of <code>minHeap</code> is less than <code>k</code> elements:
<ul>
<li>Add <code>val</code> to <code>minHeap</code></li>
<li>If the size of <code>minHeap</code> is greater than <code>k</code>, then remove the top element</li>
</ul>
</li>
<li>Return the top element as the <code>k-th</code> largest element in the stream</li>
</ul>
</li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/7W8gK6JG/shared">code</a></p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<p>Let <span class="math inline">\(M\)</span> be the size of the initial stream <code>nums</code> given in the constructor, and let <span class="math inline">\(N\)</span> be the number of calls to <code>add</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((M + N) \cdot \log k)\)</span></p>
<p>The <code>add</code> function involves adding and removing an element from a heap of size <span class="math inline">\(k\)</span>, which is an <span class="math inline">\(O( \log k)\)</span> operation. Since the <code>add</code> function is called <span class="math inline">\(N\)</span> times, the total time complexity for all <code>add</code> calls is <span class="math inline">\(O(N \cdot \log k)\)</span>.</p>
<p>The constructor also calls <code>add</code> <span class="math inline">\(M\)</span> times to initialize the heap, leading to a time complexity of <span class="math inline">\(O(M \cdot \log k)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((M + N) \cdot \log k)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(k)\)</span></p>
<p>The <code>minHeap</code> maintains at most <span class="math inline">\(k\)</span> elements, so the space complexity is <span class="math inline">\(O(k)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/kth-largest-element-in-bst/1" target="_blank" rel="noopener noreferrer">Kth largest element in BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>Binary Search Tree</strong>. Your task is to complete the function which will return the <strong>kth largest</strong> element without doing any modification in the Binary Search Tree.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
&nbsp;     4</strong>
&nbsp;   /   \
<strong>   </strong>2     9
k = 2<strong> 
Output: </strong>4<br /><strong>Explanation:</strong> 2nd Largest element in BST is 4</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>&nbsp; &nbsp; &nbsp; &nbsp;9
&nbsp; &nbsp; &nbsp;&nbsp;  \&nbsp;
&nbsp;  &nbsp;&nbsp;  &nbsp;  <strong>10</strong>
k = 1<strong>
Output: </strong>10<br /><strong>Explanation:</strong> 1st Largest element in BST is 10</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:
&nbsp;     </strong><span style="font-size: 18px;">4
&nbsp;   /   \
</span><strong style="font-size: 18px;">   2 </strong><span style="font-size: 18px;">    9
k = 3</span><strong style="font-size: 18px;"> 
Output: </strong><span style="font-size: 18px;">2<br /><strong>Explanation:</strong> 3rd Largest element in BST is 2</span></span></pre>
<p><span style="font-size: 18px;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Constraints:<br /></strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1 &lt;= number of nodes &lt;= 10</span><sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">5<br /></sup><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1 &lt;= node-&gt;data &lt;= 10</span><sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">5<br /></sup><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1 &lt;= k &lt;= number of nodes</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-smallest-element-in-a-bst/description" target="_blank" rel="noopener noreferrer">Kth Smallest Element in a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" style="width: 212px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [3,1,4,null,2], k = 1
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" style="width: 382px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-bst/1" target="_blank" rel="noopener noreferrer">Largest BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You're given a binary tree. Your task is to find the<strong> size </strong>of the largest subtree within this binary tree that also satisfies the properties of a Binary Search Tree (BST). </span><span style="font-size: 18px;">The size of a subtree is defined as the number of nodes it contains.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> A subtree of the binary tree is considered a BST if for every node in that subtree, the left child is less than the node, and the right child is greater than the node, without any duplicate values in the subtree.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: root = [5, 2, 4, 1, 3]<br /></span><img src="https://media.geeksforgeeks.org/wp-content/uploads/20241007154946544659/Root-to-leaf-path-sum-equal-to-a-given-number-copy.webp" alt="Root-to-leaf-path-sum-equal-to-a-given-number-copy" width="300" height="267" /><br /><span style="font-size: 18px;"><strong>Output</strong>: 3</span><br /><span style="font-size: 18px;"><strong>Explanation</strong>:</span><span style="font-size: 14pt;">The following sub-tree is a BST of size 3<br /></span><img style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" src="https://media.geeksforgeeks.org/wp-content/uploads/20241008164418969970/Balance-a-Binary-Search-Tree-3-copy.webp" alt="Balance-a-Binary-Search-Tree-3-copy" width="249" height="221" /></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: root = [6, 7, 3, N, 2, 2, 4]<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700351/Web/Other/blobid0_1732253153.png" width="302" height="267" /><br /><span style="font-size: 14pt;"><strong>Output</strong>: 3</span><br /><span style="font-size: 14pt;"><strong>Explanation</strong>: The following sub-tree is a BST of size 3:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700351/Web/Other/blobid1_1732253193.png" width="250" height="221" /><br /></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; number of nodes &le; 10<sup>5</sup><br />1 &le; node-&gt;data &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/lowest-common-ancestor-in-a-bst/1" target="_blank" rel="noopener noreferrer">Lowest Common Ancestor in a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Binary Search Tree (with all values unique) and two nodes <strong>n1 </strong>and <strong>n2 </strong>(n1 != n2). </span><span style="font-size: 18px;">You may assume that both nodes exist in the tree. Find the </span><strong style="font-size: 18px;">Lowest Common Ancestor (LCA)</strong><span style="font-size: 18px;"> of the given two nodes in the BST.</span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><strong>LCA</strong> between two nodes <strong>n1 </strong>and <strong>n2 </strong>is defined as the lowest node that has both n1 and n2 as descendants (where we allow a node to be a descendant of itself).</span></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root = [5, 4, 6, 3, N, N, 7, N, N, N, 8], n1 = 7, n2 = 8
        <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700236/Web/Other/blobid0_1738413634.png" alt="" width="301" height="263" />
<strong>Output: </strong>7<br /><strong>Explanation:</strong> 7 is the closest node to both 7 and 8, which is also an ancestor of both the nodes.
</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">root = [20, 8, 22, 4, 12, N, N, N, N, 10, 14], n1 = 8, n2 = 14<br />        <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700236/Web/Other/blobid1_1739265251.png" width="288" height="254" /> &nbsp; &nbsp; &nbsp;  
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">8<br /><strong>Explanation:</strong> 8 is the closest node to both 8 and 14, which is also an ancestor of both the nodes.</span></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root = [2, 1, 3], n1 = 1, n2 = 3
        <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700236/Web/Other/blobid1_1738413633.png" alt="" width="309" height="249" />
<strong>Output: </strong>2<br /><strong>Explanation:</strong> 2 is the closest node to both 1 and 3, which is also an ancestor of both the nodes.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>5<br /></sup></span><span style="font-size: 18px;">1 &lt;= node-&gt;data &lt;= 10<sup>5<br /></sup></span><span style="font-size: 18px;">1 &lt;= n1, n2 &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Lowest Common Ancestor of a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>

<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).&rdquo;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" style="width: 200px; height: 190px;" />
<pre>
<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
<strong>Output:</strong> 6
<strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" style="width: 200px; height: 190px;" />
<pre>
<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [2,1], p = 2, q = 1
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
	<li>All <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>p != q</code></li>
	<li><code>p</code> and <code>q</code> will exist in the BST.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-bst-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Sum BST in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>binary tree</strong> <code>root</code>, return <em>the maximum sum of all keys of <strong>any</strong> sub-tree which is also a Binary Search Tree (BST)</em>.</p>

<p>Assume a BST is defined as follows:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png" style="width: 320px; height: 250px;" /></p>

<pre>
<strong>Input:</strong> root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
<strong>Output:</strong> 20
<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/01/30/sample_2_1709.png" style="width: 134px; height: 180px;" /></p>

<pre>
<strong>Input:</strong> root = [4,3,null,1,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [-4,-2,-5]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All values are negatives. Return an empty BST.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li>
	<li><code>-4 * 10<sup>4</sup> &lt;= Node.val &lt;= 4 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-sum-leaf-to-root-path/1" target="_blank" rel="noopener noreferrer">Maximum sum leaf to root path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a Binary Tree, find the maximum sum path from a leaf to root.</span></p>

<p><br />
<strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:</span></strong>
<span style="font-size:18px">        1
       / \
      2   3 </span>
<span style="font-size:18px"><strong>Output:</strong>
4</span>
<strong><span style="font-size:18px">Explanation: </span></strong>
<span style="font-size:18px">Following the path 3 -&gt; 1, results in a
sum of 4, which is the maximum path sum
from leaf to root for the given tree.</span>
</pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:</span></strong>
<span style="font-size:18px">       10
      /  \
    -2    7
    / \   
   8  -4    </span>
<span style="font-size:18px"><strong>Output:</strong>
17</span>
<strong><span style="font-size:18px">Explanation : </span></strong>
<span style="font-size:18px">Following the path 7 -&gt; 10, results in a
sum of 17, which is the maximum path sum
from leaf to root for the given tree.</span></pre>

<div><br />
<strong><span style="font-size:18px">Your task :</span></strong></div>

<div><span style="font-size:18px">You don&#39;t need to read input or print anything. Your task is to complete the function <strong>maxPathSum()</strong> which takes the root node of the tree as input and returns an integer denoting the maximum possible leaf to root path sum.</span></div>

<div><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(n) , where n = number of nodes</span></div>

<div><span style="font-size:18px"><strong>Expected Auxiliary Space:</strong> O(1)</span></div>

<div><br />
<strong><span style="font-size:18px">Constraints :&nbsp;</span></strong></div>

<div><span style="font-size:18px">1 &lt;= Number of nodes &lt;= 10^5</span></div>

<div><span style="font-size:18px">-10<sup>6</sup>&nbsp;&lt;= max sum path &lt;= 10<sup>6</sup></span></div>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/max-level-sum-in-binary-tree--170647/1" target="_blank" rel="noopener noreferrer">Max Level Sum in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a Binary Tree having positive and negative nodes. Find the maximum sum of a level in the given Binary Tree.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input :               </strong>
             4
          /    \
         2     -5
        / \    / \
      -1   3  -2  6</span>

<span style="font-size:18px"><strong>Output:</strong> 6</span>

<span style="font-size:18px"><strong>Explanation :</strong>
Sum of all nodes of 0&#39;th level is 4
Sum of all nodes of 1&#39;th level is -3
Sum of all nodes of 2&#39;th level is 6
Hence maximum sum is 6</span></pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input :          </strong>
            1
          /   \
         2     3
        / \     \
       4   5     8
                / \
               6   7  </span>

<span style="font-size:18px"><strong>Output : </strong> 17</span>

<span style="font-size:18px"><strong>Explanation: </strong>Maximum sum is at level 2.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task: &nbsp;</strong><br />
You dont need to read input or print anything. Complete the function <strong>maxLevelSum()</strong> which takes root node as input parameter and returns the maximum sum of any horizontal level in the given Binary Tree.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)</span>, <span style="font-size:18px">where N is no of node.</span><br />
<span style="font-size:18px"><strong>Expected Auxiliary Space:</strong> O(W), Where W is the max width of the tree.</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<sup>4</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/merge-two-bst-s/1" target="_blank" rel="noopener noreferrer">Merge two BST &#39;s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two BSTs, return elements of merged BSTs in <strong>sorted </strong>form.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root1 = [</span>5, 3, 6, 2, 4]<br /><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700440/Web/Other/blobid3_1750056501.webp" height="100" /> <br /></span><span style="font-size: 18px;">root2 = [</span>2, 1, 3, N, N, N, 7, 6<span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">]</span><br /><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700440/Web/Other/blobid6_1750056541.webp" height="100" /></span><span style="font-size: 18px;"> <br /><strong>Output: </strong>[1, 2, 2, 3, 3, 4, 5, 6, 6, 7]<strong>
Explanation: </strong>After merging and sorting the two BST we get [1, 2, 2, 3, 3, 4, 5, 6, 6, 7]</span>.</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root1 = [12, 9, N, 6, 11]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700440/Web/Other/blobid9_1750056608.webp" height="100" /><br />root2 = [8, 5, 10, 2]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700440/Web/Other/blobid12_1750056651.webp" height="100" /><br /><strong>Output: </strong>[2, 5, 6, 8, 9, 10, 11, 12]<strong>
Explanation: </strong>After merging and sorting the two BST we get [2, 5, 6, 8, 9, 10, 11, 12]</span>.</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; number of nodes, root-&gt;data &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-absolute-difference-in-bst/description" target="_blank" rel="noopener noreferrer">Minimum Absolute Difference in BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [1,0,48,null,null,12,49]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 783: <a href="https://leetcode.com/problems/minimum-distance-between-bst-nodes/" target="_blank">https://leetcode.com/problems/minimum-distance-between-bst-nodes/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-bst-sum-subtree--170647/1" target="_blank" rel="noopener noreferrer">Minimum BST Sum Subtree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>binary tree </strong>and a <strong>target</strong>, find the number of node in the minimum sub-tree with the given sum equal to the target which is also a binary search tree.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
           13
         /    \
       5       23
      / \      / \
     N   17   N   N
&nbsp;        /
&nbsp;       16
<strong>Target</strong>: 38
<strong>Output:</strong> 3
<strong>Explanation</strong>: 5,17,16 is the smallest subtree
with length 3.</span></pre>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
             7
           /   \
          N    23
             /   \
            10    23
&nbsp;          /  \   / \
&nbsp;         N   17 N   N
<strong>Target</strong>: 73
<strong>Output:</strong> -1
<strong>Explanation</strong>: No subtree is bst for the given target.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong> &nbsp;<br />You don't need to read input or print anything. Your task is to complete the function <strong>minSubtreeSumBST</strong>() which takes the tree <strong>root</strong> and <strong>target</strong> as input parameters which is a <strong>binary Tree </strong>and returns the length of the minimum subtree having a sum equal to the target but which is a&nbsp;<strong>binary search tree</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>: O(N), where N is no. of nodes</span><br /><span style="font-size: 18px;"><strong>Expected Space Complexity:&nbsp;</strong>O(h), where h is the height of the tree</span><br /><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10^5</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-distance-between-bst-nodes/description" target="_blank" rel="noopener noreferrer">Minimum Distance Between BST Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum difference between the values of any two different nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [1,0,48,null,null,12,49]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 530: <a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/" target="_blank">https://leetcode.com/problems/minimum-absolute-difference-in-bst/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-element-in-bst/1" target="_blank" rel="noopener noreferrer">Minimum element in BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given the root of a <strong>Binary Search Tree</strong>. The task is to find the minimum valued element in this given BST. </span></p>
<p><span style="font-size: 14pt;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 14pt;">Input: root = [5, 4, 6, 3, N, N, 7, 1]
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240924170437/ex-1.webp" alt="ex-1" width="302" height="268" />
<strong>Output: </strong>1
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root =<strong> </strong>[10, 5, 20, 2]
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240924170436/ex-2.webp" alt="ex-2" width="300" height="266" />
<strong>Output: </strong>2</span></pre>
<pre><span style="font-size: 14pt;">Input: root = [10, N, 10, N, 11]
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;11
<strong>Output: </strong>10</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />0 &lt;= number of nodes &lt;= 10<sup>5<br /></sup>0 &lt;= node-&gt;data &lt;= 10<sup>5</sup><sup><br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description" target="_blank" rel="noopener noreferrer">Number of Ways to Reorder Array to Get Same BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> that represents a permutation of integers from <code>1</code> to <code>n</code>. We are going to construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST. Find the number of different ways to reorder <code>nums</code> so that the constructed BST is identical to that formed from the original array <code>nums</code>.</p>

<ul>
	<li>For example, given <code>nums = [2,1,3]</code>, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array <code>[2,3,1]</code> also yields the same BST but <code>[3,2,1]</code> yields a different BST.</li>
</ul>

<p>Return <em>the number of ways to reorder</em> <code>nums</code> <em>such that the BST formed is identical to the original BST formed from</em> <code>nums</code>.</p>

<p>Since the answer may be very large, <strong>return it modulo </strong><code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/bb.png" style="width: 121px; height: 101px;" />
<pre>
<strong>Input:</strong> nums = [2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex1.png" style="width: 241px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [3,4,5,1,2]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The following 5 arrays will yield the same BST: 
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex4.png" style="width: 121px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no other orderings of nums that will yield the same BST.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
	<li>All integers in <code>nums</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-recursion">Approach: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>We can make the following conclusions:</p>
<ul>
<li>
<p>The first element of <code>nums</code> always corresponds to the root node of the corresponding BST.</p>
</li>
<li>
<p>According to the definition of a binary search tree (BST), all elements less than the root value belong to the left subtree, while all elements greater than the root value belong to the right subtree (as shown in the figure below). Let's temporarily ignore the specific structure of the left and right subtrees for now.</p>
</li>
</ul>
<p><img src="../Figures/1569/1.png" alt="img" /></p>
<p>Let <code>dfs(nums)</code> denote the number of permutations of <code>nums</code> that result in the same BST as <code>nums</code>. When iterating over the elements of <code>nums[1:]</code>, we can construct two subtrees using the subsequences <code>left_nodes = [1, 2]</code> and <code>right_nodes = [4, 5]</code> by adding each element to either the left or right subtree of the root. As long as the <strong>relative position</strong> of the elements within <code>[1, 2]</code> or <code>[4, 5]</code> remains unchanged, rearranging their positions in <code>nums</code> does not affect the construction of the subtrees.</p>
<blockquote>
<p>It should be noted that maintaining the relative positions of the numbers in each sequence does not necessarily mean that rearranging the order will always result in a different BST. However, this issue will be addressed in the next level of the subproblem, which will be considered in <code>dfs(left_nodes)</code> or <code>dfs(right_nodes)</code> by allowing the order to be changed. In the current level of recursion <code>dfs(nums)</code>, we do not consider the issue of the next level.</p>
</blockquote>
<p><img src="../Figures/1569/6.png" alt="img" /></p>
<p>Therefore, we obtain the following recursive relation:</p>
<p><span class="math display">\[
However, it is important to note that the actual number of valid permutations may exceed the calculated number from above. This is because there are some permutations that do not alter the relative order of the nodes in `left_nodes` and `right_nodes` thus resulting in the same BST.

<br>

For instance, let's consider the original array `[3,4,5,1,2]`. Here, we use `[1, 2]` to construct the left subtree and `[4, 5]` to construct the right subtree. If we only change the positions of `1` and `2` in `nums[1:]` without altering their relative order, the subsequences used to construct the left and right subtree will still be `[1, 2]` and `[4, 5]`, resulting in the same left subtree.


![img](../Figures/1569/2.png)


This implies that we need to adjust the formula by multiplying it with a coefficient ($$P$$) that represents the number of permutations that preserve the relative order of nodes in the two subsequence `left_nodes` and `right_nodes`. This leads to the modified equation:

$$\text{dfs(nums)} = P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$


It is possible to arbitrarily select two cells to hold the nodes of the left subtree, and there are 6 permutations that generate the same `left_nodes` and `right_nodes`. Therefore, we set $$P=6$$ in the above equation.

![img](../Figures/1569/3.png)


In general, for an array of length `m` with `left` nodes in the left subtree, then the number of valid permutations is equal to the number of ways of selecting `k` cells from `m - 1` cells (excluding the first cell that represents the root). This can be expressed using the binomial coefficient formula:

$$C_{m-1}^\text{left} = \binom{m-1}{\text{left}} = \frac{(m-1)!}{\text{left}!(m-1-\text{left})!}$$



<details> <summary>
        <b> &ensp; If you are not aware of the binomial coefficient, let's get a brief idea about it (click to expand) We have hidden this section in order to keep the main content coherent. Our focus is on practical applications rather than on specific implementations and theories. </b> </summary>

<br>

To efficiently compute the binomial coefficients, we can use Pascal's triangle and precompute a table to avoid repetitive calculations. To build this table, we first determine the number of rows we need based on the size of `nums`, denoted as `m`. We create a $$m \times m$$ table to represent the first `m - 1` rows of Pascal's triangle.

The numbers in Pascal's triangle are generated by summing the two numbers directly above it. We initialize the first column and the main diagonal as `1`. We then iterate over the lower-left half of the table, starting from `table[2][1]`, and compute `table[i][j]` as the sum of `table[i - 1][j - 1]` and `table[i - 1][j]`.

![img](../Figures/1569/5.png)

After building the table, we can efficiently compute the value of $$C_n^k$$ by directly looking up `table[n][k]`.

</details>

<br>

Now we can recursively solve this problem by dividing `nums` into two subsequences `left_nodes` (of length `k`) and `right_nodes`, and the number of valid permutations is denoted as 
$$ \text{dfs(nums)} \\= P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)} \\= C_{n}^{k}\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$. 


where $$C_{n}^{k}$$ can be obtained by using the precomputed table we discussed before or built-in functions. We treat the calls to `dfs` on the two subsequences as subproblems, and recursively solve them. The algorithm always selects the first element as the root value, and the size of the input array gradually decreases as the recursion progresses.


If the input array `nums` contains one or two elements, it only has one permutation that constructs the same BST (which is `nums` itself). Thus we have `dfs(nums) = 1` when `nums.length < 3`, which are the base cases.


<br>

Take the picture below as a detailed example.

- For `nums = [5, 1, 8, 3, 7, 9, 4, 2, 6]`, we need to keep the relative order in `[1, 3, 4, 2]` and `[8, 7, 9, 6]` unchanged, there could be $$C_8^4$$ different permutations.

- Now we move on to the left subtree constructed by `[1, 3, 4, 2]`, there is no left subtree for `root = 1` so we have the coefficient as $$C_3^0$$.

- For the right subtree constructed by `[3, 2, 4]`, we have the coefficient as $$C_2^1$$.

and so on.

![img](../Figures/1569/40.png)

Therefore, the number of permutations is equal to the product of all coefficients, which is $$\text{answer} = C_8^4 \cdot C_3^0 \cdot C_3^2 \cdot C_2^1  \cdot 1 \cdot 1 \cdot 1$$. 

Lastly, don't forget to return $$(\text{answer} - 1) \% (10^9 +7)$$ as we don't count the original `nums` as a valid permutation.


<br>

#### Algorithm


1) Define a function `dfs(nums)` as the number of valid permutations.
    - If the size of `nums` is less than 3, meaning there are 0, 1, or 2 nodes, the function returns 1, as there is only one possible permutation in each of these cases.
    - Otherwise, the function selects the first element of `nums` as the value of the root node. It then partitions the remaining elements `nums[1:]` into two subsequences, `left_nodes` and `right_nodes`, representing the values of the nodes in the left and right subtrees, respectively.
    - Let `m` be the size of `nums` and `k` be the size of `left_nodes`. Return the product of `dfs(left_nodes) * dfs(right_nodes)` and $$C_n^k$$.

2) In Java or C++, we need to build a table of Pascal's of size $$m \times m$$, since there are at most $$m - 1$$ nodes in a subtree, 
    - Initialize the first column and the main diagonal of the table to `1`.
    - Iterate over each empty cell in the lower left triangle of `table` from top to bottom and from left to right. Set `table[i][j]` as `table[i - 1][j] + table[i - 1][j - 1]`.

    Return `table[n][k]` if we need to compute $$C_n^k$$.


3) Return `(dfs(nums) - 1) % (1_000_000_007)`.

#### Implementation

[code](https://leetcode.com/playground/NmZAKnGX/shared)


#### Complexity Analysis

Let $$m$$ be the size of `nums`.

* Time complexity: $$O(m^2)$$
    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built, which takes $$O(m^2)$$ time.
    - `dfs(nums)` recursively calls itself to process the left and right subtrees of the current node `nums[0]`. Since the total size of the subtrees decreases by 1 at each level of the recursion, the maximum height of the recursion tree is $$m$$. Thus the total time complexity of the recursive solution is $$O(m^2)$$ because in each call we are doing $$O(m)$$ work creating the subsequences.

    

* Space complexity: $$O(m^2)$$ or $$O(m)$$

    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built.
    - The recursive solution uses the call stack to keep track of the current subtree being processed. The maximum depth of the call stack is equal to the height of the BST constructed from the input array. In the worst case, `nums` may form a degenerate BST (e.g., a sorted array), which has a height of $$m - 1$$, and the stack can hold up to $$m - 1$$ calls, resulting in a space complexity of $$O(m)$$.

<br/>\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/predecessor-and-successor/1" target="_blank" rel="noopener noreferrer">Predecessor and Successor</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given root node of the <strong>BST</strong> and an integer <strong>key</strong>. You need to find the in-order <strong>successor</strong> and <strong>predecessor</strong> of the given key. If either predecessor or successor is not found, then set it to <strong>NULL</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note</strong>:- In an inorder traversal the number just <strong>smaller</strong> than the target is the predecessor and the number just <strong>greater</strong> than the target is the successor.&nbsp;</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root[] = [8, 1, 9, N, 4, N, 10, 3, N, N, N], key = 8<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700614/Web/Other/blobid4_1746526041.webp" width="188" height="190" />
<strong>Output: </strong>4 9<strong>
Explanation: </strong>In the given BST the inorder predecessor of 8 is 4 and inorder successor of 8 is 9.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root[] = [10, 2, 11, 1, 5, N, N, N, N, 3, 6, N, 4, N, N], key = 11<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700614/Web/Other/blobid6_1746526133.webp" width="178" height="274" />
<strong>Output: </strong>10 -1<strong>
Explanation: </strong>In given BST, the inorder predecessor of 11 is 10 whereas it does not have any inorder successor.</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">root[] = [2, 1, 3], key = 3<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700614/Web/Other/blobid7_1746526171.webp" width="158" height="173" />
</span><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">2 -1<br /></span><span style="font-size: 18.6667px;"><strong>Explanation:</strong> In given BST, the inorder predecessor of 3 is 2 whereas it does not have any inorder successor.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:&nbsp;</strong><br />1 &lt;= no. of nodes &lt;= 10<sup>5<br /></sup>1 &lt;= node-&gt;data &lt;= 10<sup>6</sup><sup><br /></sup></span><span style="font-size: 14pt;">1 &lt;= key &lt;= 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/preorder-to-postorder4423/1" target="_blank" rel="noopener noreferrer">Preorder to BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array arr[] of N nodes representing preorder traversal of some BST. You have to build the </span><strong style="font-size: 18px;">BST</strong><span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;"> from the given preorder traversal.&nbsp;</span></p>
<p><span style="font-size: 18px;">In Pre-Order traversal,&nbsp;<strong>the root node is visited before the left child and right child nodes</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 5
arr[]  = {40,30,35,80,100}
<strong>Output: </strong>35 30 100 80 40<strong>
Explanation:</strong>&nbsp;PreOrder: 40 30 35 80 100
Therefore, the BST will be:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 40
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; &nbsp;&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30&nbsp; &nbsp; &nbsp; &nbsp;80
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\&nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;35&nbsp; &nbsp; &nbsp; 100
Hence, the postOrder traversal will
be: 35 30 100 80 40</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 8
arr[]  = {40,30,32,35,80,90,100,120}
<strong>Output: </strong>35 32 30 120 100 90 80 40</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You need to complete the given function and<strong> return the root </strong>of the tree. The driver code will then use this root to print the post order traversal.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(N).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>3</sup><br />1 &lt;= arr[i] &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/preorder-traversal-and-bst4006/1" target="_blank" rel="noopener noreferrer">Preorder Traversal and BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an array <strong>arr[ ]&nbsp;</strong>of size <strong>N&nbsp;</strong>consisting of <strong>distinct</strong> integers, write a program that&nbsp;returns&nbsp;<strong>1</strong> if given array can represent preorder traversal of a possible BST, else returns<strong>&nbsp;0</strong>.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 3
arr = {2, 4, 3</span><span style="font-size:18px">}
<strong>Output:</strong> 1
<strong>Explaination:</strong> Given arr[] can represent
preorder traversal of following BST:
&nbsp;              2
&nbsp;               \
&nbsp;                4
&nbsp;               /
&nbsp;              3</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 3
Arr = {2, 4, 1}
<strong>Output:</strong> 0
<strong>Explaination:</strong> Given arr[] cannot represent
preorder traversal of a BST.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>canRepresentBST()</strong>&nbsp;which takes the array a<strong>rr[]</strong> and its size <strong>N&nbsp;</strong>as input parameters&nbsp;and returns&nbsp;<strong>1</strong> if given array can represent preorder traversal of a BST, else returns<strong>&nbsp;0</strong>.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<sup>5</sup><br />
0 &le; arr[i]&nbsp;&le; 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-leaf-nodes-from-preorder-traversal-of-bst2657/1" target="_blank" rel="noopener noreferrer">Print leaf nodes from preorder traversal of BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>preorder</strong> traversal of a <strong>BST</strong>, find&nbsp;the <strong>leaf nodes</strong> of the tree without building the tree.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>preorder[] = [5, 2, 10]<strong><br /></strong><strong>Output:</strong> [2, 10]
<strong>Explaination:</strong> <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895564/Web/Other/blobid0_1747480179.jpg" width="196" height="140" /><br />2 and 10 are the leaf nodes as shown in the figure.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>preorder[] = [4, 2, 1, 3, 6, 5]
<strong>Output:</strong> [1, 3, 5]
<strong>Explaination:</strong> <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895564/Web/Other/blobid1_1747480193.jpg" width="223" height="187" /><br />1, 3 and 5 are the leaf nodes as shown in the figure.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>preorder[] = [8, 2, 5, 10, 12]<strong><br /></strong><strong>Output:</strong> [5, 12]
<strong>Explaination:</strong> <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895564/Web/Other/blobid2_1747480202.jpg" width="206" height="200" /><br />5 and 12 are the leaf nodes as shown in the figure.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le;&nbsp;</span><span style="font-size: 18px;">preorder.size()</span><span style="font-size: 18px;">&nbsp;&le; 10</span><sup>3<br /></sup><span style="font-size: 18px;">1 &le;&nbsp;</span><span style="font-size: 18px;">preorder</span><span style="font-size: 18px;">[i]&nbsp;&le; 10</span><sup>3</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-of-bst/description" target="_blank" rel="noopener noreferrer">Range Sum of BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> node of a binary search tree and two integers <code>low</code> and <code>high</code>, return <em>the sum of values of all nodes with a value in the <strong>inclusive</strong> range </em><code>[low, high]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" style="width: 400px; height: 222px;" />
<pre>
<strong>Input:</strong> root = [10,5,15,3,7,null,18], low = 7, high = 15
<strong>Output:</strong> 32
<strong>Explanation:</strong> Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" style="width: 400px; height: 335px;" />
<pre>
<strong>Input:</strong> root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
<strong>Output:</strong> 23
<strong>Explanation:</strong> Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 2 * 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>
	<li>All <code>Node.val</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/recover-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Recover Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary search tree (BST), where the values of <strong>exactly</strong> two nodes of the tree were swapped by mistake. <em>Recover the tree without changing its structure</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" style="width: 422px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,3,null,null,2]
<strong>Output:</strong> [3,1,null,null,2]
<strong>Explanation:</strong> 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" style="width: 581px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,1,4,null,null,2]
<strong>Output:</strong> [2,1,4,null,null,3]
<strong>Explanation:</strong> 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 1000]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> A solution using <code>O(n)</code> space is pretty straight-forward. Could you devise a constant <code>O(1)</code> space solution?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/root-to-leaf-paths/1" target="_blank" rel="noopener noreferrer">Root to Leaf Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-size: 18px;">Given a <strong>Binary Tree</strong>, you need to <strong>find all the possible paths</strong> from the <strong>root node</strong> to all the <strong>leaf nodes</strong> of the binary tree. </span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><strong>Note:</strong> The paths should be returned such that paths from the left subtree of any node are <strong>listed first</strong>, followed by paths from the right subtree.</span></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root[] = [1, 2, 3, 4, 5, N, N]
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20241007105251989873/ex-3.webp" alt="ex-3" width="276" height="245" />
<strong>Output: </strong>[[1, 2, 4], [1, 2, 5], [1, 3]]
<strong>Explanation: </strong>All the possible paths from root node to leaf nodes are: 1 -&gt; 2 -&gt; 4, 1 -&gt; 2 -&gt; 5 and 1 -&gt; 3</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root[] = [1, 2, 3]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700553/Web/Other/blobid0_1745821559.jpg" width="244" height="203" /><br /><strong>Output: </strong>[[1, 2], [1, 3]] 
<strong>Explanation: </strong>All the possible paths from root node to leaf nodes are: 1 -&gt; 2 and 1 -&gt; 3</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> root[] = [10, 20, 30, 40, 60, N, N]
<strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700553/Web/Other/blobid1_1745821586.jpg" width="249" height="265" /><br />Output: </strong>[[10, 20, 40], [10, 20, 60], [10, 30]]<br /></span><strong style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation: </strong><span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">All the possible paths from root node to leaf nodes are: 10 -&gt; 20 -&gt; 40, 10 -&gt; 20 -&gt; 60 and 10 -&gt; 30</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>4<br /></sup>1 &lt;= node-&gt;data &lt;= 10<sup>4</sup><sup><br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-in-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Search in a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p>

<p>Find the node in the BST that the node&#39;s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" style="width: 422px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3], val = 2
<strong>Output:</strong> [2,1,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" style="width: 422px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3], val = 5
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 5000]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>7</sup></code></li>
	<li><code>root</code> is a binary search tree.</li>
	<li><code>1 &lt;= val &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/serialize-and-deserialize-bst/description" target="_blank" rel="noopener noreferrer">Serialize and Deserialize BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>

<p><b>The encoded string should be as compact as possible.</b></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,1,3]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-range-in-bst--141631/1" target="_blank" rel="noopener noreferrer">Shortest Range In BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a BST (Binary Search Tree), find the shortest range <strong>[x, y]</strong>, such that,&nbsp;at least one node of every level of the&nbsp;BST lies in the&nbsp;range.<br />
If there are multiple ranges with the same gap (i.e. <strong>(y-x)</strong>) return the range with<strong> </strong>the<strong> smallest x</strong>.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
    </span>&nbsp;        <span style="font-size:18px"> 8
&nbsp; &nbsp; &nbsp; &nbsp;   /&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3&nbsp; &nbsp;  10
&nbsp; &nbsp;    /&nbsp; \&nbsp; &nbsp; &nbsp; \
&nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; 6&nbsp; &nbsp; &nbsp; 14
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp;\&nbsp; &nbsp; &nbsp;/
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4&nbsp;  7&nbsp; &nbsp;12
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; \
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11&nbsp;  13
<strong>Output:</strong> 6 11
<strong>Explanation:</strong> Level order traversal of the tree 
is [8], [3, 10], [2, 6, 14], [4, 7, 12], [11, 13]. 
The shortest range which satisfies the above 
mentioned condition is [6, 11]. </span></pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
   12
&nbsp; &nbsp; \
&nbsp; &nbsp; &nbsp;13
&nbsp; &nbsp; &nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; 14
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \
&nbsp; &nbsp; &nbsp; &nbsp;    16

<strong>Output:</strong> 12 16
<strong>Explanation:</strong> Each level contains one node, 
so the shortest range is [12, 16].</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>shortestRange() </strong>which takes the root of the tree as an input parameter and returns the pair of numbers</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N&nbsp;&le; 10<sup>5</sup><br />
1 &le; Node Value &le; 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sorted-list-to-bst/1" target="_blank" rel="noopener noreferrer">Sorted Linked List to BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 12pt;">Given a Singly Linked List which has data members sorted in ascending order. Construct a&nbsp;Balanced Binary Search Tree&nbsp;which has same data members as the given Linked List.<br /><strong>Note: </strong>There might be nodes with the same value.</span></p>
<p><span style="font-size: 12pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>Linked List: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706336/Web/Other/blobid0_1722838240.png" width="404" height="63" />
<strong>Output: </strong>4 2 1 3 6 5 7<br /><strong>Explanation : </strong>The BST formed using elements of the linked list is -
        4
      /   \
     2     6
   /  \   / \
  1   3  5   7  
Hence, preorder traversal of this tree is 4 2 1 3 6 5 7
</span></pre>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>Linked List : 1-&gt;2-&gt;3-&gt;4<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706336/Web/Other/blobid1_1722838295.png" width="404" height="63" /> <br /><strong>Ouput: </strong>3 2 1 4<br /></span><strong style="font-size: 12pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation: </strong><span style="font-size: 12pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">The BST formed using elements of the linked list is -</span><br /><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706336/Web/Other/blobid2_1722838310.png" width="402" height="141" />
Hence, the preorder traversal of this tree is 3 2 1 4
</span></pre>
<div><span style="font-size: 12pt;"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Auxiliary Space:</strong> O(n)</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 12pt;"><strong>Constraints</strong>:</span></div>
<div><span style="font-size: 12pt;">1 &le; Number of Nodes &le; 10<sup>6</sup></span></div>
<div><span style="font-size: 12pt;">1 &le; Value of each node &le; 10<sup>6</sup></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1" target="_blank" rel="noopener noreferrer">Top View of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a binary tree, and your task is to return its <strong>top view</strong>. The top view of a binary tree is the set of nodes visible when the tree is viewed from the top.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:&nbsp;</strong></span></p>
<ul>
<li><span style="font-size: 14pt;">Return the nodes from the leftmost node to the rightmost node.</span></li>
<li><span style="font-size: 14pt;">If two nodes are at the same position (horizontal distance) and are outside the shadow of the tree, consider the leftmost node only.&nbsp;<br /></span></li>
</ul>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root[] = [1, 2, 3] <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700490/Web/Other/blobid0_1733898095.png" width="249" height="219" /> <br /><strong>Output: </strong>[2, 1, 3]
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> root[] = [10, 20, 30, 40, 60, 90, 100]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700490/Web/Other/blobid1_1733898122.png" width="306" height="271" /> <br /><strong>Output: </strong>[40, 20, 10, 30, 100]<br /><strong>Explanation: </strong>The root 10 is visible.
On the left, 40 is the leftmost node and visible, followed by 20.
On the right, 30 and 100 are visible. Thus, the top view is 40 20 10 30 100.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> root[] = [1, 2, 3, N, 4, N, N, N, 5, N, 6]
       1
     /   \
    2     3
     \   
      4
       \
        5
         \
          6
<strong>Output: </strong>[2, 1, 3, 6]<br /><strong>Explanation: </strong>Node 1 is the root and visible.
Node 2 is the left child and visible from the left side.
Node 3 is the right child and visible from the right side.
Nodes 4, 5, and 6 are vertically aligned, but only the lowest node 6 is visible from the top view. Thus, the top view is 2 1 3 6.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; number of nodes &le; 10<sup>5</sup><br />1 &le; node-&gt;data &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/trim-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Trim a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>

<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" style="width: 450px; height: 126px;" />
<pre>
<strong>Input:</strong> root = [1,0,2], low = 1, high = 2
<strong>Output:</strong> [1,null,2]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" style="width: 450px; height: 277px;" />
<pre>
<strong>Input:</strong> root = [3,0,4,null,2,null,null,1], low = 1, high = 3
<strong>Output:</strong> [3,2,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>The value of each node in the tree is <strong>unique</strong>.</li>
	<li><code>root</code> is guaranteed to be a valid binary search tree.</li>
	<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/two-sum-iv-input-is-a-bst/description" target="_blank" rel="noopener noreferrer">Two Sum IV - Input is a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree and an integer <code>k</code>, return <code>true</code> <em>if there exist two elements in the BST such that their sum is equal to</em> <code>k</code>, <em>or</em> <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 9
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 28
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li><code>root</code> is guaranteed to be a <strong>valid</strong> binary search tree.</li>
	<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-binary-search-trees/description" target="_blank" rel="noopener noreferrer">Unique Binary Search Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">math</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST&#39;</strong>s (binary search trees) which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" style="width: 600px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 5
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-binary-search-trees-ii/description" target="_blank" rel="noopener noreferrer">Unique Binary Search Trees II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST&#39;</strong>s (binary search trees), which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" style="width: 600px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> [[1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an integer <code>n</code>, our task is to return all unique BSTs (binary search trees) that have exactly <code>n</code> nodes of unique values from <code>1</code> to <code>n</code>.</p>
<hr />
<h3 id="approach-1-recursive-dynamic-programming">Approach 1: Recursive Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>In each node of a binary search tree (BST), all values in the left subtree are smaller and all values in the right subtree are greater.</p>
<p>To find all the possible permutations of BSTs with <code>n</code> nodes, we can lock one node as the <code>root</code> node and split <code>n - 1</code> nodes between the left and right subtrees in all the possible ways. Let's say we place a node with value <code>i</code> as the root node and place <code>i - 1</code> nodes having values from <code>1</code> to <code>i - 1</code> in the left subtree. (If <code>i == 1</code>, the left child is null). Similarly, we place the remaining <code>n - i</code> nodes having values from <code>i + 1</code> to <code>n</code> in the right subtree. (If <code>i == n</code>, the right child is null).</p>
<p>Now, we create a list of nodes called <code>leftSubTrees</code> for all the possible BSTs that could be the left subtree. Similarly, we create a list of nodes called <code>rightSubTrees</code> for all the BSTs that could be the right subtree.</p>
<blockquote>
<p>In a BST, every subtree is also a BST.</p>
</blockquote>
<p>We iterate over both the lists and for each node pair <code>l</code> in <code>leftSubTrees</code> and <code>r</code> in <code>rightSubTrees</code>, we create a new <code>root</code> node with value <code>i</code> and set the left and right child of <code>root</code> to <code>l</code> and <code>r</code> respectively to form all the BSTs with the root node as <code>i</code>.</p>
<p>We can iterate over the root's value from <code>i = 1</code> to <code>n</code> and repeat the process for each root value to get all the BSTs.</p>
<p>You may notice that the subproblem of finding the arrays <code>leftSubTrees</code> and <code>rightSubTrees</code> are similar to the original problem. We can implement this approach using recursion as we are breaking down a problem with <code>n</code> nodes to smaller, repetitive subproblems with <code>i - 1</code> and <code>n - i</code> nodes (for <code>i = 1</code> till <code>n</code>) to compute the answer for <code>n</code> nodes. We only need the range of node values as the parameters to create the BSTs with nodes having values in that range.</p>
<p>We implement a recursive function <code>allPossibleBST(start, end)</code> where <code>start</code> and <code>end</code> correspond to the range of node values that should be present in the BSTs created by this call. For a root node with value <code>i</code>, we will find all the left subtrees using <code>leftSubTrees = allPossibleBST(start, i - 1)</code> and also compute all the right subtrees using <code>rightSubTrees = allPossibleBST(i + 1, right)</code>. Finally, we iterate over all pairs between <code>leftSubTrees</code> and <code>rightSubTrees</code> and create a new root with value <code>i</code> for each pair.</p>
<p>The base case of this function is when <code>start &gt; end</code>. We have no values in our range and thus we will return <code>null</code> (an empty tree).</p>
<p>Here is a visual representation of the recursion tree with <code>3</code> nodes:</p>
<p><img src="../Figures/95/95-1.png" alt="img" /></p>
<p>Several subproblems, such as <code>allPossibleBST(1, 1)</code>, <code>allPossibleBST(3, 3)</code>, etc., are solved multiple times in the small partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.</p>
<p>To avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from a range of nodes values to the list of root nodes of all possible BSTs that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of <code>TreeNode</code>. This is called <strong>memoization</strong>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a hash map <code>memo</code> where <code>memo[(start, end)]</code> contains the list of root nodes of all possible BSTs with the range of node values from <code>start</code> to <code>end</code>.</li>
<li>We implement a recursive function <code>allPossibleBST</code> which takes the starting range of node values <code>start</code>, ending range <code>end</code>, and <code>memo</code> as parameters. It returns a list of <code>TreeNode</code> corresponding to all the BSTs that can be formed with this range of node values. We call <code>allPossibleBST(1, n, memo)</code> and perform the following:
<ul>
<li>We declare a list of <code>TreeNode</code> called <code>res</code> to store the list of root nodes of all possible BSTs.</li>
<li>If <code>start &gt; end</code>, we push <code>null</code> to <code>res</code> and return it.</li>
<li>If we already have solved this subproblem, i.e., <code>memo</code> contains the pair <code>(start, end)</code>, we return <code>memo[(start, end)]</code>.</li>
<li>Select the root node value from <code>i = start</code> to <code>end</code> incrementing <code>i</code> by <code>1</code> after each iteration. We recursively call <code>leftSubtrees = llPossibleBST(start, i - 1, memo)</code> and <code>rightSubTrees = allPossibleBST(i + 1, end, memo)</code>. We iterate over all pairs between <code>leftSubtrees</code> and <code>rightSubTrees</code> and create a new root with value <code>i</code> for each pair. We push <code>root</code> of the new formed BST into <code>res</code>.</li>
<li>Set <code>memo[(start, end)] = res</code> and return <code>res</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FiZegYw8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Note, the time and space complexity of this problem is difficult to derive. In an interview, you should do your best to find an upper bound. The level of analysis here would not be expected in an interview.</p>
<p>The number of unique BSTs that can be formed with <code>n</code> nodes is <span class="math inline">\(G(n)\)</span> where <span class="math inline">\(G(n)\)</span> is the <span class="math inline">\(n^{th}\)</span> <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a>. <span class="math inline">\(G(n) = O(\dfrac{4^{n}}{n^{1.5}})\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>There are <span class="math inline">\(G(n) = \dfrac{4^n}{n^{1.5}}\)</span> BSTs in our answer. Each of these BSTs has <span class="math inline">\(n\)</span> nodes, so it cost us <span class="math inline">\(O(n)\)</span> to build each one. This gives us a time complexity of <span class="math inline">\(O(n \cdot G(n)) = O(\dfrac{4^n}{\sqrt{n}})\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]})\)</span>.</p>
<p>We use some space for the recursion call stack, but the majority of the space used by the algorithm is storing the lists of BSTs in <code>memo</code>. Let's analyze how many nodes are stored in <code>memo</code>.</p>
<p>The number of nodes in a range <code>start, end</code> is <code>end - start + 1</code>. Let <span class="math inline">\(k = \text{end} - \text{start} + 1\)</span> represent this formula.</p>
<p>There are <span class="math inline">\(n\)</span> states <code>start, end</code> with one node, that is <span class="math inline">\(k = 1\)</span>.</p>
<p>There are <span class="math inline">\(n - 1\)</span> states <code>start, end</code> with two nodes, that is <span class="math inline">\(k = 2\)</span>.</p>
<p>There are <span class="math inline">\(n - 2\)</span> states <code>start, end</code> with three nodes, that is <span class="math inline">\(k = 3\)</span>.</p>
<p>This continues until there is only one state with <span class="math inline">\(n\)</span> nodes (the original input). In general, a value of <span class="math inline">\(k\)</span> has <span class="math inline">\(n - k + 1\)</span> states.</p>
<p>For a given state with value <span class="math inline">\(k\)</span>, there are <span class="math inline">\(G(k) = \dfrac{4^k}{k^{1.5}}\)</span> BSTs. Each of these BSTs has <span class="math inline">\(k\)</span> nodes, and thus takes up <span class="math inline">\(k \cdot G(k) = \dfrac{4^k}{\sqrt{k}}\)</span> space in <code>memo</code>.</p>
<p>A given value <span class="math inline">\(k\)</span> has <span class="math inline">\(n - k + 1\)</span> states and thus takes up <span class="math inline">\((n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}\)</span> space. In our algorithm, <span class="math inline">\(k\)</span> ranges from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>.</p>
<p>The space complexity is the summation for all values of <span class="math inline">\(k\)</span>:</p>
<p><span class="math inline">\(\Large{\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]}}\)</span></p>
<p>This is a difficult sum to compute and involves higher-level mathematics. Using a program like WolframAlpha, we find that the sum is equal to:</p>
<p><span class="math inline">\(4^{1 + n} \cdot \Phi(4, -0.5, 1 + n) - 4^{1 + n} \cdot (1 + n) \cdot \Phi(4, 0.5, 1 + n) - \text{Li}_{-0.5}(4) + \text{Li}_{0.5}(4) + n \cdot \text{Li}_{0.5}(4)\)</span></p>
<p>Where <span class="math inline">\(\Phi\)</span> is the <a href="https://en.wikipedia.org/wiki/Lerch_zeta_function">Lerch transcendent</a> and <span class="math inline">\(\text{Li}_n(x)\)</span> is the <a href="https://en.wikipedia.org/wiki/Polylogarithm">polylogarithm function</a>. Needless to say, computing this sum by hand is not necessary in an interview. Even reaching the summation expression would likely impress any interviewer.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-dynamic-programming">Approach 2: Iterative Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.</p>
<p>We create a 3D list <code>dp[n + 1][n + 1]</code> where <code>dp[i][j]</code> will store a list of all BSTs that have node values ranging from <code>i</code> to <code>j</code>. Note that <code>dp[i][j] = allPossibleBST(i, j)</code> from the previous approach.</p>
<p>When <code>i = j</code>, the range contains only one node with value <code>i</code>. We push a single node with value <code>i</code> in the list <code>dp[i][i]</code> for all the values of <code>i</code> from <code>1</code> to <code>n</code>. This acts as the base case of our solution while we move in bottom to top manner.</p>
<p>We form the answer with a smaller number of nodes having consecutive node values and move on to form answers for a bigger number of nodes. We run an outer loop from <code>numberOfNodes = 2</code> to <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. This loop controls the total number of nodes under consideration.</p>
<p>We further need to choose a node value we start with. Let's call it <code>start</code>. As we have <code>numberOfNodes</code> nodes under consideration with consecutive values, the maximum node value in such a BST would be <code>end = start + numberOfNodes - 1</code>. We will move <code>start</code> from <code>1</code> to <code>n - numberOfNodes + 1</code>.</p>
<p>Now we have the <code>start</code> value and the <code>end</code> value, we can implement the same logic that we did in the <code>allPossibleBST</code> function from the previous approach. Lock a value <code>i</code>, find all left and right subtrees, and then iterate over each <code>left, right</code> pair and create a new root with value <code>i</code> for each pair.</p>
<p>As we move from bottom to top, we will have a list of all the root nodes for all BSTs for every range of node values with lesser nodes.</p>
<p>Locking a value <code>i</code> as the root node, we can find all left subtrees in <code>dp[start][i - 1]</code> and all right subtrees in <code>dp[i + 1][end]</code>. If <code>i == start</code>, the left subtree would be empty. Similarly, if <code>i == end</code>, the right subtree would be empty. We can handle these cases separately.</p>
<p>We run an outer loop from <code>numberOfNodes = 2</code> to <code>n</code>. We run an inner loop that selects the starting node value. It runs from <code>start = 1</code> to <code>n - numberOfNodes + 1</code>. We define <code>end = start + numberOfNodes - 1</code>. We run a third nested loop that selects the root of the BSTs under consideration. It runs from <code>i = start</code> to <code>end</code>.</p>
<p>We then iterate over the both the lists of left and right subtrees. For each root node <code>l</code> of the left subtree and <code>r</code> of the right subtree, we create a new <code>root</code> node with value <code>i</code> and set the left and right child to <code>l</code> and <code>r</code> respectively to form all the BSTs with root node as <code>i</code>. We also push each BST into <code>dp[start][end]</code> to be used later to build answer for other <code>dp</code> states with larger number of nodes.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a 3D list <code>dp[n + 1][n + 1]</code> where <code>dp[i][j]</code> will store a list of root nodes for all possible BSTs using <code>j - i + 1</code> nodes with values from <code>i</code> to <code>j</code> nodes.</li>
<li>We initialize each list <code>dp[i][i]</code> to a <code>TreeNode</code> having value <code>i</code> for <code>i = 0</code> to <code>n</code>.</li>
<li>Iterate from <code>numberOfNodes = 2</code> till <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. We start an inner loop from <code>start = 1</code> to <code>n - numberOfNodes + 1</code> incrementing <code>start</code> by <code>1</code>. We create an integer variable <code>end = start + numberOfNodes - 1</code> which stores the highest node value of the BSTs that will be formed. We run another loop from <code>i = start</code> to <code>end</code> to use all the permutations as the root node value. We perform the following in this loop:
<ul>
<li>We create a list of <code>TreeNode</code> called <code>leftSubtrees</code> which will store all the BSTs that can be formed with node values from <code>start</code> to <code>i - 1</code>. If <code>i == start</code>, we just add <code>null</code> to <code>leftSubtrees</code>, else <code>leftSubtrees == dp[start][i - 1]</code>.</li>
<li>Similarly, we create a list of <code>TreeNode</code> called <code>rightSubtrees</code> which will store all the BSTs that can be formed with node values from <code>i + 1</code> to <code>end</code>. If <code>i == end</code>, we just add <code>null</code> to <code>rightSubtrees</code>, else <code>rightSubtrees == dp[i + 1][end]</code>.</li>
<li>We form a new BST by creating a new node which acts as a root node with value <code>i</code>. For each element <code>left</code> in <code>leftSubtrees</code> and <code>right</code> in <code>rightSubtrees</code>, we set <code>root.left = left</code> and <code>root.right = right</code>. Finally, we add <code>root</code> to <code>dp[start][end]</code>.</li>
</ul>
</li>
<li>Return <code>dp[1][n]</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/hj8MdGva/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>The time complexity of this approach will be similar to the <strong>time complexity</strong> of the first approach because we are iterating over the same <code>dp</code> states in bottom-up manner as compared to the previous approach where we used top-down approach with memoization.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]})\)</span>.</p>
<ul>
<li>The space complexity would also be the number of BSTs stored in the <code>dp</code> list which is equal to the number of BSTs stored in <code>memo</code> in the worst-case. Hence, we have the same space complexity as the first approach.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming-with-space-optimization">Approach 3: Dynamic Programming with Space Optimization</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We used a 3D list where we used <code>dp[start][end]</code> to store all the BSTs having <code>end - start + 1</code> nodes with range from <code>start</code> to <code>end</code>. Let's think if we can reduce the 3D <code>dp</code> list to a 2D list.</p>
<p>If we compare all the BSTs that can be created from a set of consecutive values from <code>start</code> to <code>end</code> to those that can be created with the same number of nodes from a set of values starting at <code>1</code> and ending at <code>end - start + 1</code>, we will find that <strong>the structure of all the BSTs created with the above two ranges would be identical</strong>. The only difference is an offset of <code>start - 1</code> in the node values.</p>
<p>Here's a visual representation of BSTs with 3 nodes from range <code>[1, 3]</code> and all BSTs with range <code>[4, 6]</code>:</p>
<p><img src="../Figures/95/95-2.png" alt="img" /></p>
<p>We can see the structure of all the BSTs created with the above two ranges are identical.</p>
<p>So, we can just store the BSTs for all the ranges starting from <code>1</code> and add the offset to convert them to required ranges.</p>
<p>We create a 2D list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of all BSTs with <code>i</code> nodes having values from <code>1</code> to <code>i</code>. <code>dp[n]</code> would be the answer to the problem. Similar to the above approach, we will move in bottom to top manner.</p>
<p>We push a <code>null</code> node (empty tree) to <code>dp[0]</code> which acts as the base case.</p>
<p>To get the list of root nodes for all possible BSTs with <code>numberOfNodes</code> nodes, we would split the <code>numberOfNodes</code> nodes with <code>i - 1</code> nodes with values <code>1</code> to <code>i - 1</code> in the left subtree, a root node with value <code>i</code> and the remaining <code>numberOfNodes - i</code> nodes with values <code>i + 1</code> to <code>numberOfNodes</code> in the right subtree where <code>1 &lt;= i &lt;= numberOfNodes</code>. Note that we do not need the starting of the range here, unlike the previous approach. It is always <code>1</code>.</p>
<p>As we are executing in bottom-up manner and figuring out the answer for <code>numberOfNodes</code> nodes, we will already have the list of root nodes for all BSTs with <code>i - 1</code> and <code>numberOfNodes - i</code> nodes (for all values of <code>i = 1</code> to <code>numberOfNodes</code>).</p>
<p>However, you may realize that <code>dp[i - 1]</code> will give all the BSTs having values from <code>1</code> to <code>i - 1</code> which is exactly what we want but <code>dp[numberOfNodes - i]</code> will give all the BSTs having values from <code>1</code> to <code>numberOfNodes - i</code> which isn't what we want. We want the right subtree to have <code>numberOfNodes - i</code> nodes but the range of nodes should be from <code>i + 1</code> to <code>numberOfNodes</code>. If we add the offset <code>(i + 1) - 1 = i</code> to all the nodes, it would solve this as we would now have trees with <code>numberOfNodes - i</code> nodes from values <code>i + 1</code> to <code>numberOfNodes</code>. Let us form the BSTs now.</p>
<p>Similar to the previous approach, we create a new instance of <code>TreeNode</code> called <code>root</code> with the value <code>i</code>. We set the left child of <code>root</code> to an element in <code>dp[i - 1]</code>.</p>
<p>Now, let's set the right child of <code>root</code>. We know every element in <code>dp[numberOfNodes - i]</code> is a root node that stores a BST with <code>numberOfNodes - 1</code> nodes having values from <code>1</code> to <code>numberOfNodes - i</code>. To set the right child of <code>root</code>, we create a new tree exactly similar to the tree stored by an element of <code>dp[numberOfNodes - i]</code> but increment all the node values of the new tree by <code>i</code>. We then set the right child of <code>root</code> to this newer tree.</p>
<p>The required tree with <code>i</code> offset can be created by using a recursive function <code>clone</code> in which we pass a <code>TreeNode node</code> which corresponds to an element in <code>dp[numberOfNodes - i]</code> and an integer <code>offset</code>. We create a new <code>TreeNode clonedNode</code> with value <code>node.val + offset</code>. We then recursively set the left and the right child of <code>clonedNode</code> by performing <code>clonedNode.left = clone(node.left, offset)</code> and <code>clonedNode.right = clone(node.right, offset)</code>. Finally, return <code>clonedNode</code>.</p>
<p>It is important to note that we are creating new trees to set the right child of <code>root</code> to preserve the original trees as it might be used directly (as <code>dp[i - 1]</code>) in some other iteration of <code>i</code> and <code>numberOfNodes</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create a list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of root nodes for all possible BSTs using <code>i</code> nodes. We initialize each list <code>dp[i]</code> to an empty list for <code>i = 0</code> to <code>n</code>.</li>
<li>We push a <code>null</code> node (empty tree) into <code>dp[0]</code> because with <code>n = 0</code> we can't have any BST. This forms the base case.</li>
<li>Iterate from <code>numberOfNodes = 1</code> till <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. We start an inner loop from <code>i = 1</code> to <code>numberOfNodes</code> incrementing <code>i</code> by <code>1</code>. We perform the following in this loop:
<ul>
<li>Create a variable <code>j = numberOfNodes - i - 1</code>. It presents the number of nodes in the right subtree under consideration.</li>
<li>We can form a new BST by creating a new node which acts as a root node with value <code>i</code>. We assign its left child to any element in <code>dp[i]</code> and right child to a new tree where tree is similar to an element in <code>dp[j]</code> but all node values are incremented by <code>i</code>. As a result, we need two loops to iterate through the lists <code>dp[i]</code> and <code>dp[j]</code>. We create a new <code>root</code> node with value <code>i</code>. For each element <code>left</code> in <code>dp[i]</code> and <code>right</code> in <code>dp[j]</code>, we set <code>root.left = left</code> and <code>root.right = clone(right, i)</code>. Finally, we add <code>root</code> to <code>dp[numberOfNodes]</code>.</li>
</ul>
</li>
<li>Return <code>dp[n]</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/a8x29E6y/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>In this approach we are not storing all the BSTs with all the ranges. We are just storing BSTs starting from range <code>1</code>. However, we are creating all the BSTs for all the ranges from <code>[start, end]</code> (for <code>1 &lt;= start, end  &lt;= 1</code>) using the <code>clone</code> method by iterating over the BSTs starting with range <code>1</code>.</li>
<li>As a result, the time complexity should be similar to the previous approach as we are generating the same number of BSTs.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}\dfrac{4^k}{{\sqrt{k}}})\)</span>.</p>
<ul>
<li>For any state <code>dp[k]</code>, we are storing all the BSTs that can be formed with <span class="math inline">\(k\)</span> nodes. We know there are <span class="math inline">\(G(k)\)</span> BSTs that can be formed with <span class="math inline">\(k\)</span> nodes. As we have <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> states, the total space consumed would be <span class="math inline">\(O(\sum_{k=1}^{n} k \cdot G(k))\)</span> = <span class="math inline">\(O(\sum_{k=1}^{n}\dfrac{4^k}{{\sqrt{k}}})\)</span>.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/valentine-sum--141631/1" target="_blank" rel="noopener noreferrer">Valentine Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Cupid wants to strike maximum houses in Geek Land on Valentine&#39;s Day. The houses in Geek Land are arranged in the form of a <strong>binary tree</strong>. Cupid is standing at <strong>target</strong> node initially.&nbsp;<br />
Find the sum of all nodes within a maximum distance <strong>k</strong> from target node. The target node should be included in the sum.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
    &nbsp;              1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   2&nbsp; &nbsp; &nbsp; 9
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    /&nbsp; &nbsp; &nbsp;&nbsp;/&nbsp;&nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     4&nbsp; &nbsp; &nbsp; 5&nbsp; &nbsp; &nbsp;7
&nbsp; &nbsp; &nbsp; &nbsp;     /&nbsp; &nbsp;\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; \
&nbsp; &nbsp; &nbsp;      8&nbsp; &nbsp;  19&nbsp; &nbsp; &nbsp;20&nbsp; &nbsp; 11
&nbsp; &nbsp;       /&nbsp; &nbsp; &nbsp;/&nbsp; \
 &nbsp;       30&nbsp; &nbsp;40&nbsp; &nbsp;50
target = 9, K = 1
<strong>Output:</strong>
22
<strong>Explanation:</strong>
Nodes within distance 1 from 9 are 9, 5, 7, 1  
</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
    &nbsp;              1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   2&nbsp; &nbsp; &nbsp; 9
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    /&nbsp; &nbsp; &nbsp;&nbsp;/&nbsp;&nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     4&nbsp; &nbsp; &nbsp; 5&nbsp; &nbsp; &nbsp;7
&nbsp; &nbsp; &nbsp; &nbsp;     /&nbsp; &nbsp;\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; \
&nbsp; &nbsp; &nbsp;      8&nbsp; &nbsp;  19&nbsp; &nbsp; &nbsp;20&nbsp; &nbsp; 11
&nbsp; &nbsp;       /&nbsp; &nbsp; &nbsp;/&nbsp; \
 &nbsp;       30&nbsp; &nbsp;40&nbsp; &nbsp;50
target = 40, K = 2
<strong>Output:</strong>
113
<strong>Explanation:</strong>
Nodes within distance 2 from 40 are 40, 19, 50, 4
</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>sum_at_distK() </strong>which takes the root of the&nbsp;tree, target, and K&nbsp; as input parameter and returns the&nbsp;sum of all nodes within&nbsp;a max&nbsp;distance of<strong> k</strong> from the <strong>target</strong> </span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N, Node Value &le; 10<sup>5</sup><br />
1 &le; K &le; 20</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/validate-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Validate Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>

<p>A <strong>valid BST</strong> is defined as follows:</p>

<ul>
	<li>The left <span data-keyword="subtree">subtree</span> of a node contains only nodes with keys&nbsp;<strong>strictly less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>strictly greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;" />
<pre>
<strong>Input:</strong> root = [5,1,4,null,null,3,6]
<strong>Output:</strong> false
<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>