<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>binary search - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>binary search</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">293</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">132 Pattern</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Activity Selection</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-2" class="toc-link">Adjacent Increasing Subarrays Detection II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Apply Operations to Maximize Frequency Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Arranging Coins</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Avoid Flood in The City</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Binary Matrix with at most K 1s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-7" class="toc-link">Binary Search</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Block Placement Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Booking Concert Tickets in Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Building Boxes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Capacity To Ship Packages Within D Days</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Ceil in a Sorted Array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-13" class="toc-link">Check If N and Its Double Exist</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Closer to sort</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-15" class="toc-link">Closest Equal Element Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Closest Nodes Queries in a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Closest Room</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Coin Piles</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-19" class="toc-link">Compare Strings by Frequency of the Smallest Character</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Count Complete Tree Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Count Good Triplets in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Count Negative Numbers in a Sorted Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Count Number of Rectangles Containing Each Point</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Count Occurrences in a Fully Sorted Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-25" class="toc-link">Count of Range Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Count of Smaller Numbers After Self</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Count Pairs Of Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Count Pairs Whose Sum is Less than Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Count Smaller elements</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-30" class="toc-link">Count Subarrays With Score Less Than K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Count Substrings That Satisfy K-Constraint II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Count the Number of Fair Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Count the Number of Incremovable Subarrays I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Count the Number of Incremovable Subarrays II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Create Sorted Array through Instructions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Data Stream as Disjoint Intervals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Earliest Finish Time for Land and Water Rides I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Earliest Finish Time for Land and Water Rides II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Earliest Second to Mark Indices I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Earliest Second to Mark Indices II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Escape the Spreading Fire</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Fair Candy Swap</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Fill the Tank</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-44" class="toc-link">Find a Peak Element II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Find a Value of a Mysterious Function Closest to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Find Beautiful Indices in the Given Array I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Find Beautiful Indices in the Given Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Find Building Where Alice and Bob Can Meet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Find First and Last Position of Element in Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Find H-Index</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-51" class="toc-link">Find in Mountain Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Find K Closest Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Find K-th Smallest Pair Distance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Find Latest Group of Size M</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Find Longest Special Substring That Occurs Thrice I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Find Longest Special Substring That Occurs Thrice II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Find Maximum Non-decreasing Array Length</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Find Minimum in Rotated Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Find Minimum in Rotated Sorted Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Find Pair Given Difference</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-61" class="toc-link">Find Peak Element</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Find Positive Integer Solution for a Given Equation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Find Products of Elements of Big Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Find Right Interval</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Find Smallest Letter Greater Than Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Find Subarray With Bitwise OR Closest to K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Find Target Indices After Sorting Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Find the Distance Value Between Two Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Find the Duplicate Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Find the Kth Smallest Sum of a Matrix With Sorted Rows</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Find the Longest Equal Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Find the Longest Valid Obstacle Course at Each Position</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Find the Maximum Number of Marked Indices</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Find the Median of the Uniqueness Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Find the Number of Subarrays Where Boundary Elements Are Maximum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Find the Peak Element in a 2D Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-77" class="toc-link">Find the Safest Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Find the Smallest Divisor Given a Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Find the Student that Will Replace the Chalk</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Find Two Non-overlapping Sub-arrays Each With Target Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-81" class="toc-link">Find Weighted Median Node in Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">First Bad Version</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Frequency of the Most Frequent Element</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-84" class="toc-link">Friends Of Appropriate Ages</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-85" class="toc-link">Frog Jump II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">Fruits Into Baskets II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Fruits Into Baskets III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Get Equal Substrings Within Budget</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Guess Number Higher or Lower</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Heaters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-91" class="toc-link">H-Index II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">House Robber IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Implement Router</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-94" class="toc-link">Intersection of Two Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Intersection of Two Arrays II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-96" class="toc-link">K-diff Pairs in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-97" class="toc-link">Koko Eating Bananas</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-98" class="toc-link">Kth Ancestor of a Tree Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Kth Missing Positive Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-100" class="toc-link">Kth Smallest Amount With Single Denomination Combination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Kth smallest element in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-102" class="toc-link">Kth Smallest Element in a Sorted Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-103" class="toc-link">Kth Smallest Number in Multiplication Table</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">K-th Smallest Prime Fraction</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">Kth Smallest Product of Two Sorted Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Last Day Where You Can Still Cross</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-107" class="toc-link">Length of the Longest Increasing Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Longest Arithmetic Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Longest Common Subpath</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Longest Duplicate Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Longest Increasing Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Longest Square Streak in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Longest Subsequence With Limited Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Longest Uploaded Prefix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Magnetic Force Between Two Balls</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Make Array Empty</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Make Array Strictly Increasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-118" class="toc-link">Max Consecutive Ones III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Maximize Active Section with Trade II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">Maximize Score of Numbers in Ranges</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Maximize Spanning Tree Stability with Upgrades</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-122" class="toc-link">Maximize the Confusion of an Exam</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Maximize the Distance Between Points on a Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Maximize the minimum difference between k elements</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-125" class="toc-link">Maximize the Minimum Game Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Maximize the Minimum Powered City</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-127" class="toc-link">Maximize the Profit as the Salesman</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Maximize Win From Two Segments</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-129" class="toc-link">Maximum Balanced Subsequence Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Maximum Beauty of an Array After Applying Operation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Maximum Candies Allocated to K Children</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Maximum Coins From K Consecutive Bags</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Maximum Count of Positive Integer and Negative Integer</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Maximum Distance Between a Pair of Values</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Maximum Earnings From Taxi</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Maximum Frequency of an Element After Performing Operations I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">Maximum Frequency of an Element After Performing Operations II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-138" class="toc-link">Maximum Fruits Harvested After at Most K Steps</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-139" class="toc-link">Maximum Length of Repeated Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-140" class="toc-link">Maximum Number of Alloys</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-141" class="toc-link">Maximum Number of Events That Can Be Attended II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-142" class="toc-link">Maximum Number of Groups Entering a Competition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-143" class="toc-link">Maximum Number of Groups With Increasing Length</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-144" class="toc-link">Maximum Number of Integers to Choose From a Range I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-145" class="toc-link">Maximum Number of Removable Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-146" class="toc-link">Maximum Number of Robots Within Budget</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-147" class="toc-link">Maximum Number of Tasks You Can Assign</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Maximum Number That Sum of the Prices Is Less Than or Equal to K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-149" class="toc-link">Maximum Points Inside the Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-150" class="toc-link">Maximum Profit in Job Scheduling</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-151" class="toc-link">Maximum Running Time of N Computers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-152" class="toc-link">Maximum Score of a Good Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-153" class="toc-link">Maximum Score of Non-overlapping Intervals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-154" class="toc-link">Maximum Side Length of a Square with Sum Less than or Equal to Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-155" class="toc-link">Maximum Strictly Increasing Cells in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-156" class="toc-link">Maximum Sum Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-157" class="toc-link">Maximum Tastiness of Candy Basket</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-158" class="toc-link">Maximum Total Beauty of the Gardens</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-159" class="toc-link">Maximum Total Damage With Spell Casting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-160" class="toc-link">Maximum Value at a Given Index in a Bounded Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-161" class="toc-link">Maximum White Tiles Covered by a Carpet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-162" class="toc-link">Max Level Sum in Binary Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-163" class="toc-link">Max Sum of Rectangle No Larger Than K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-164" class="toc-link">Median in a row-wise sorted Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-165" class="toc-link">Median of Two Sorted Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-166" class="toc-link">Merge BSTs to Create Single BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-167" class="toc-link">Minimized Maximum of Products Distributed to Any Store</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-168" class="toc-link">Minimize Maximum Component Cost</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-169" class="toc-link">Minimize Maximum of Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-170" class="toc-link">Minimize the Maximum Adjacent Element Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-171" class="toc-link">Minimize the Maximum Difference of Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-172" class="toc-link">Minimize the Maximum Edge Weight of Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-173" class="toc-link">Minimize the Maximum of Two Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-174" class="toc-link">Minimum Absolute Difference Between Elements With Constraint</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-175" class="toc-link">Minimum Absolute Sum Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-176" class="toc-link">Minimum Array Length After Pair Removals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-177" class="toc-link">Minimum Common Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-178" class="toc-link">Minimum Cost to Make Array Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-179" class="toc-link">Minimum Cost to Make Array Equalindromic</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-180" class="toc-link">Minimum Garden Perimeter to Collect Enough Apples</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-181" class="toc-link">Minimum Interval to Include Each Query</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-182" class="toc-link">Minimum Limit of Balls in a Bag</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-183" class="toc-link">Minimum Number of Days to Make m Bouquets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-184" class="toc-link">Minimum Number of Operations to Make Array Continuous</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-185" class="toc-link">Minimum Number of Removals to Make Mountain Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-186" class="toc-link">Minimum Number of Seconds to Make Mountain Height Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-187" class="toc-link">Minimum Number of Valid Strings to Form Target I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-188" class="toc-link">Minimum Number of Valid Strings to Form Target II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-189" class="toc-link">Minimum Operations to Make All Array Elements Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-190" class="toc-link">Minimum Operations to Make a Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-191" class="toc-link">Minimum Operations to Make the Array K-Increasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-192" class="toc-link">Minimum Operations to Reduce X to Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-193" class="toc-link">Minimum Platforms</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-194" class="toc-link">Minimum Size Subarray Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-195" class="toc-link">Minimum Space Wasted From Packaging</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-196" class="toc-link">Minimum Speed to Arrive on Time</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-197" class="toc-link">Minimum Stability Factor of Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-198" class="toc-link">Minimum sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-199" class="toc-link">Minimum Sum of Squared Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-200" class="toc-link">Minimum Sum of Values by Dividing Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-201" class="toc-link">Minimum Time for K Connected Components</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-202" class="toc-link">Minimum Time to Activate String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-203" class="toc-link">Minimum Time to Complete All Tasks</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-204" class="toc-link">Minimum Time to Complete Trips</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-205" class="toc-link">Minimum Time to Repair Cars</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-206" class="toc-link">Missing Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-207" class="toc-link">Most Beautiful Item for Each Query</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-208" class="toc-link">Most Profit Assigning Work</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-209" class="toc-link">My Calendar I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-210" class="toc-link">My Calendar II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-211" class="toc-link">My Calendar III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-212" class="toc-link">Network Recovery Pathways</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-213" class="toc-link">Next Greater Element IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-214" class="toc-link">Nth Digit</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-215" class="toc-link">Nth Magical Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-216" class="toc-link">Number of Excellent Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-217" class="toc-link">Number of Flowers in Full Bloom</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-218" class="toc-link">Number of Matching Subsequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-219" class="toc-link">Number of Pairs Satisfying Inequality</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-220" class="toc-link">Number of Subarrays With AND Value of K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-221" class="toc-link">Number of Subsequences That Satisfy the Given Sum Condition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-222" class="toc-link">Numbers At Most N Given Digit Set</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-223" class="toc-link">Online Election</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-224" class="toc-link">Online Majority Element In Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-225" class="toc-link">Partition Array Into Two Arrays to Minimize Sum Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-226" class="toc-link">Path Existence Queries in a Graph I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-227" class="toc-link">Path Existence Queries in a Graph II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-228" class="toc-link">Path With Minimum Effort</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-229" class="toc-link">Peak Index in a Mountain Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-230" class="toc-link">Plates Between Candles</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-231" class="toc-link">Preimage Size of Factorial Zeroes Function</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-232" class="toc-link">Prime Subtraction Operation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-233" class="toc-link">Random Pick with Blacklist</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-234" class="toc-link">Random Pick with Weight</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-235" class="toc-link">Random Point in Non-overlapping Rectangles</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-236" class="toc-link">Range Frequency Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-237" class="toc-link">Range Sum of Sorted Subarray Sums</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-238" class="toc-link">Reach a Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-239" class="toc-link">Reverse Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-240" class="toc-link">Row with Max 1s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-241" class="toc-link">Russian Doll Envelopes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-242" class="toc-link">Search a 2D Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-243" class="toc-link">Search a 2D Matrix II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-244" class="toc-link">Search in an almost Sorted Array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-245" class="toc-link">Search in a row-wise sorted matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-246" class="toc-link">Search in fully rotated sorted 2D matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-247" class="toc-link">Search in Rotated Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-248" class="toc-link">Search in Rotated Sorted Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-249" class="toc-link">Search Insert Position</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-250" class="toc-link">Search Suggestions System</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-251" class="toc-link">Sell Diminishing-Valued Colored Balls</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-252" class="toc-link">Separate Squares I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-253" class="toc-link">Separate Squares II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-254" class="toc-link">Shortest Matching Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-255" class="toc-link">Shortest Subarray to be Removed to Make Array Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-256" class="toc-link">Shortest Subarray with Sum at Least K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-257" class="toc-link">Single Element in a Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-258" class="toc-link">Smallest Good Base</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-259" class="toc-link">Smallest Subarrays With Maximum Bitwise OR</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-260" class="toc-link">Smallest Substring With Identical Characters I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-261" class="toc-link">Smallest Substring With Identical Characters II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-262" class="toc-link">Snapshot Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-263" class="toc-link">Sorted GCD Pair Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-264" class="toc-link">Sorting Three Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-265" class="toc-link">Special Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-266" class="toc-link">Special Array With X Elements Greater Than or Equal X</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-267" class="toc-link">Split Array Largest Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-268" class="toc-link">Split Message Based on Limit</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-269" class="toc-link">Sqrt(x)</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-270" class="toc-link">Subarray Product Less Than K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-271" class="toc-link">Subsequence With the Minimum Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-272" class="toc-link">Successful Pairs of Spells and Potions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-273" class="toc-link">Sum of Floored Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-274" class="toc-link">Sum of Mutated Array Closest to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-275" class="toc-link">Sum of Scores of Built Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-276" class="toc-link">Sum of Square Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-277" class="toc-link">Super Egg Drop</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-278" class="toc-link">Swim in Rising Water</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-279" class="toc-link">The K Weakest Rows in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-280" class="toc-link">The Latest Time to Catch a Bus</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-281" class="toc-link">The problem of identical arrays</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-282" class="toc-link">Three machines</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-283" class="toc-link">Threshold Majority Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-284" class="toc-link">Time Based Key-Value Store</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-285" class="toc-link">Tweet Counts Per Frequency</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-286" class="toc-link">Two Best Non-Overlapping Events</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-287" class="toc-link">Two Sum II - Input Array Is Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-288" class="toc-link">Ugly Number III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-289" class="toc-link">Valid Perfect Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-290" class="toc-link">Valid Triangle Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-291" class="toc-link">Ways to Split Array Into Three Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-292" class="toc-link">Zero Array Transformation II</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/132-pattern/description" target="_blank" rel="noopener noreferrer">132 Pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>

<p>Return <code>true</code><em> if there is a <strong>132 pattern</strong> in </em><code>nums</code><em>, otherwise, return </em><code>false</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no 132 pattern in the sequence.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,4,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a 132 pattern in the sequence: [1, 4, 2].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,3,2,0]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p>The simplest solution is to consider every triplet <span class="math inline">\((i, j, k)\)</span> and check if the corresponding numbers satisfy the 132 criteria. If any such triplet is found, we can return a True value. If no such triplet is found, we need to return a False value.</p>
<p><a href="https://leetcode.com/playground/hGnnTJMn/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^3)\)</span>. Three loops are used to consider every possible triplet. Here, <span class="math inline">\(n\)</span> refers to the size of <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant extra space is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force">Approach 2: Better Brute Force</h3>
<p><strong>Algorithm</strong></p>
<p>We can improve the last approach to some extent, if we make use of some observations. We can note that for a particular number <span class="math inline">\(nums[j]\)</span> chosen as 2nd element in the 132 pattern, if we don't consider <span class="math inline">\(nums[k]\)</span>(the 3rd element) for the time being, our job is to find out the first element, <span class="math inline">\(nums[i]$$(\)</span>i&lt;j<span class="math inline">\() which is lesser than \)</span>nums[j]$$.</p>
<p>Now, assume that we have somehow found a <span class="math inline">\(nums[i],nums[j]\)</span> pair. Our task now reduces to finding out a <span class="math inline">\(nums[k]$$(\)</span>Kk&gt;j&gt;i)<span class="math inline">\(, which falls in the range \)</span>(nums[i], nums[j])<span class="math inline">\(. Now, to maximize the likelihood of a \)</span>nums[k]$$ falling in this range, we need to increase this range as much as possible.</p>
<p>Since, we started off by fixing a <span class="math inline">\(nums[j]\)</span>, the only option in our hand is to choose a minimum value of <span class="math inline">\(nums[i]\)</span> given a particular <span class="math inline">\(nums[j]\)</span>. Once, this pair <span class="math inline">\(nums[i],nums[j]\)</span>, has been found out, we simply need to traverse beyond the index <span class="math inline">\(j\)</span> to find if a <span class="math inline">\(nums[k]\)</span> exists for this pair satisfying the 132 criteria.</p>
<p>Based on the above observations, while traversing over the <span class="math inline">\(nums\)</span> array choosing various values of <span class="math inline">\(nums[j]\)</span>, we simultaneously keep a track of the minimum element found so far(excluding <span class="math inline">\(nums[j]\)</span>). This minimum element always serves as the <span class="math inline">\(nums[i]\)</span> for the current <span class="math inline">\(nums[j]\)</span>. Thus, we only need to traverse beyond the <span class="math inline">\(j^{th}\)</span> index to check the <span class="math inline">\(nums[k]\)</span>'s to determine if any of them satisfies the 132 criteria.</p>
<p><a href="https://leetcode.com/playground/4Mv4ZmY8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. Two loops are used to find the <span class="math inline">\(nums[j],nums[k]\)</span> pairs. Here, <span class="math inline">\(n\)</span> refers to the size of <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant extra space is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-3-searching-intervals">Approach 3: Searching Intervals</h3>
<p><strong>Algorithm</strong></p>
<p>As discussed in the last approach, once we've fixed a <span class="math inline">\(nums[i],nums[j]\)</span> pair, we just need to determine a <span class="math inline">\(nums[k]\)</span> which falls in the range <span class="math inline">\((nums[i],nums[j])\)</span>. Further, to maximize the likelihood of any arbitrary <span class="math inline">\(nums[k]\)</span> falling in this range, we need to try to keep this range as much as possible. But, in the last approach, we tried to work only on <span class="math inline">\(nums[i]\)</span>. But, it'll be a better choice, if we can somehow work out on <span class="math inline">\(nums[j]\)</span> as well.</p>
<p>To do so, we can look at the given <span class="math inline">\(nums\)</span> array in the form of a graph, as shown below:</p>
<p><img src="../Figures/456/456_132_Pattern.PNG" alt="Graph" /></p>
<p>From the above graph, which consists of rising and falling slopes, we know, the best qualifiers to act as the <span class="math inline">\(nums[i],nums[j]\)</span> pair,  as discussed above, to maximize the range <span class="math inline">\(nums[i], nums[j]\)</span>, at any instant, while traversing the <span class="math inline">\(nums\)</span> array, will be the points at the endpoints of a local rising slope. Thus, once we've found such points, we can traverse over the <span class="math inline">\(nums\)</span> array to find a <span class="math inline">\(nums[k]\)</span> satisfying the given 132 criteria.</p>
<p>To find these points at the ends of a local rising slope, we can traverse over the given <span class="math inline">\(nums\)</span> array. While traversing, we can keep a track of the minimum point found after the last peak(<span class="math inline">\(nums[s]\)</span>).</p>
<p>Now, whenever we encounter a falling slope, say, at index <span class="math inline">\(i\)</span>, we know, that <span class="math inline">\(nums[i-1]\)</span> was the endpoint of the last rising slope found. Thus, we can scan over the <span class="math inline">\(k\)</span> indices(k&gt;i), to find a 132 pattern.</p>
<p>But, instead of traversing over <span class="math inline">\(nums\)</span> to find a <span class="math inline">\(k\)</span> satisfying the 132 pattern for every such rising slope, we can store this range <span class="math inline">\((nums[s], nums[i-1])\)</span>(acting as <span class="math inline">\((nums[i], nums[j])\)</span>) in, say an <span class="math inline">\(intervals\)</span> array.</p>
<p>While traversing over the <span class="math inline">\(nums\)</span> array to check the rising/falling slopes, whenever we find any rising slope, we can keep adding the endpoint pairs to this <span class="math inline">\(intervals\)</span> array. At the same time, we can also check if the current element falls in any of the ranges found so far. If so, this element satisfies the 132 criteria for that range.</p>
<p>If no such element is found till the end, we need to return a False value.</p>
<p><a href="https://leetcode.com/playground/Zy6HRCyV/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. We traverse over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to find the slopes. But for every element, we also need to traverse over the <span class="math inline">\(intervals\)</span> to check if any element falls in any range found so far. This array can contain at most <span class="math inline">\((n/2)\)</span> pairs, in the case of an alternate increasing-decreasing sequence(worst case e.g.<code>[5 6 4 7 3 8 2 9]</code>).</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(intervals\)</span> array can contain at most <span class="math inline">\(n/2\)</span> pairs, in the worst case(alternate increasing-decreasing sequence).<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-4-stack">Approach 4: Stack</h3>
<p><strong>Algorithm</strong></p>
<p>In Approach 2, we found out <span class="math inline">\(nums[i]\)</span> corresponding to a particular <span class="math inline">\(nums[j]\)</span> directly without having to consider every pair possible in <span class="math inline">\(nums\)</span> to find this <span class="math inline">\(nums[i],nums[j]\)</span> pair. If we do some preprocessing, we can make the process of finding a <span class="math inline">\(nums[k]\)</span> corresponding to this <span class="math inline">\(nums[i],nums[j]\)</span> pair also easy.</p>
<p>The preprocessing required is to just find the best <span class="math inline">\(nums[i]\)</span> value corresponding to every <span class="math inline">\(nums[j]\)</span> value. This is done in the same manner as in the second approach i.e. we find the minimum element found till the <span class="math inline">\(j^{th}\)</span> element which acts as the <span class="math inline">\(nums[i]\)</span> for the current <span class="math inline">\(nums[j]\)</span>. We maintain thes values in a <span class="math inline">\(min\)</span> array. Thus, <span class="math inline">\(min[j]\)</span> now refers to the best <span class="math inline">\(nums[i]\)</span> value for a particular <span class="math inline">\(nums[j]\)</span>.</p>
<p>Now, we traverse back from the end of the <span class="math inline">\(nums\)</span> array to find the <span class="math inline">\(nums[k]\)</span>'s. Suppose, we keep a track of the <span class="math inline">\(nums[k]\)</span> values which can potentially satisfy the 132 criteria for the current <span class="math inline">\(nums[j]\)</span>. We know, one of the conditions to be satisfied by such a <span class="math inline">\(nums[k]\)</span> is that it must be greater than <span class="math inline">\(nums[i]\)</span>. Or in other words, we can also say that it must be greater than <span class="math inline">\(min[j]\)</span> for a particular <span class="math inline">\(nums[j]\)</span> chosen.</p>
<p>Once it is ensured that the elements left for competing for the <span class="math inline">\(nums[k]\)</span> are all greater than <span class="math inline">\(min[j]\)</span>(or <span class="math inline">\(nums[i]\)</span>), our only task is to ensure that it should be lesser than <span class="math inline">\(nums[j]\)</span>. Now, the best element from among the competitors, for satisfying this condition will be the minimum one from out of these elements.</p>
<p>If this element, <span class="math inline">\(nums[k]\)</span> satisfies <span class="math inline">\(nums[k] < nums[j]\)</span>, we've found a 132 pattern. If not, no other element will satisfy this criteria, since they are all greater than or equal to <span class="math inline">\(nums[min]\)</span> and thus greater than or equal to <span class="math inline">\(nums[j]\)</span> as well.</p>
<p>To keep a track of these potential <span class="math inline">\(nums[k]\)</span> values for a particular <span class="math inline">\(nums[i],nums[j]\)</span> considered currently, we maintain a <span class="math inline">\(stack\)</span> on which these potential <span class="math inline">\(nums[k]\)</span>'s satisfying the 132 criteria lie in a descending order(minimum element on the top). We need not sort these elements on the <span class="math inline">\(stack\)</span>, but they'll be sorted automatically as we'll discuss along with the process.</p>
<p>After creating a <span class="math inline">\(min\)</span> array, we start traversing the <span class="math inline">\(nums[j]\)</span> array in a backward manner. Let's say, we are currently at the <span class="math inline">\(j^{th}\)</span> element and let's also assume that the <span class="math inline">\(stack\)</span> is sorted right now. Now, firstly, we check if <span class="math inline">\(nums[j] > min[j]\)</span>. If not, we continue with the <span class="math inline">\((j-1)^{th}\)</span> element and the <span class="math inline">\(stack\)</span> remains sorted. If not, we keep on popping the elements from the top of the <span class="math inline">\(stack\)</span> till we find an element, <span class="math inline">\(stack[top]\)</span> such that, <span class="math inline">\(stack[top] > min[j]\)</span>(or <span class="math inline">\(stack[top] > nums[i]\)</span>).</p>
<p>Once the popping is done, we're sure that all the elements pending on the <span class="math inline">\(stack\)</span> are greater than <span class="math inline">\(nums[i]\)</span> and are thus, the potential candidates for <span class="math inline">\(nums[k]\)</span> satisfying the 132 criteria. We can also note that the elements which have been popped from the <span class="math inline">\(stack\)</span>, all satisfy <span class="math inline">\(stack[top] &leq; min[j]\)</span>.</p>
<p>Since, in the <span class="math inline">\(min\)</span> array, <span class="math inline">\(min[p] &leq; min[q]\)</span>, for every <span class="math inline">\(p > q\)</span>, these popped elements also satisfy <span class="math inline">\(stack[top] &leq; min[k]\)</span>, for all <span class="math inline">\(0 &leq; k < j\)</span>. Thus, they are not the potential <span class="math inline">\(nums[k]\)</span> candidates for even the preceding elements. Even after  doing the popping, the <span class="math inline">\(stack\)</span> remains sorted.</p>
<p>After the popping is done, we've got the minimum element from amongst all the potential <span class="math inline">\(nums[k]\)</span>'s on the top of the <span class="math inline">\(stack\)</span>(as per the assumption). We can check if it is less than or equal to <span class="math inline">\(nums[j]\)</span> to satisfy the 132 criteria(we've already checked <span class="math inline">\(stack[top] > nums[i]\)</span>). If this element satisfies the 132 criteria, we can return a True value. If not, we know that for the current <span class="math inline">\(j\)</span>, <span class="math inline">\(nums[j] > min[j]\)</span>. Thus, the element <span class="math inline">\(nums[j]\)</span> could be a potential <span class="math inline">\(nums[k]\)</span> value, for the preceding <span class="math inline">\(nums[i]'s\)</span>.</p>
<p>Thus, we push it over the <span class="math inline">\(stack\)</span>. We can note that, we need to push this element <span class="math inline">\(nums[j]\)</span> on the <span class="math inline">\(stack\)</span> only when it didn't satisfy <span class="math inline">\(stack[top]<nums[j]\)</span>. Thus, <span class="math inline">\(nums[j] &leq; stack[top]\)</span>. Thus, even after pushing this element on the <span class="math inline">\(stack\)</span>, the <span class="math inline">\(stack\)</span> remains sorted. Thus, we've seen by induction, that the <span class="math inline">\(stack\)</span> always remains sorted.</p>
<p>Also, note that in case <span class="math inline">\(nums[j] &leq; min[j]\)</span>, we don't push <span class="math inline">\(nums[j]\)</span> onto the <span class="math inline">\(stack\)</span>. This is because this <span class="math inline">\(nums[j]\)</span> isn't greater than even the minimum element lying towards its left and thus can't act as <span class="math inline">\(nums[k]\)</span> in the future.</p>
<p>If no element is found satisfying the 132 criteria till reaching the first element, we return a False value.</p>
<p>The following animation better illustrates the process.</p>
<p>!?!../Documents/456_132_Pattern.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/kueGKV2B/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We travesre over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to fill the <span class="math inline">\(min\)</span> array. After this, we traverse over <span class="math inline">\(nums\)</span> to find the <span class="math inline">\(nums[k]\)</span>. During this process, we also push and pop the elements on the <span class="math inline">\(stack\)</span>. But, we can note that at most <span class="math inline">\(n\)</span> elements can be pushed and popped off the <span class="math inline">\(stack\)</span> in total. Thus, the second traversal requires only <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The <span class="math inline">\(stack\)</span> can grow upto a maximum depth of <span class="math inline">\(n\)</span>. Furhter, <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-5-binary-search">Approach 5: Binary Search</h3>
<p><strong>Algorithm</strong></p>
<p>In the last approach, we've made use of a separate <span class="math inline">\(stack\)</span> to push and pop the <span class="math inline">\(nums[k]\)</span>'s. But, we can also note that when we reach the index <span class="math inline">\(j\)</span> while scanning backwards for finding <span class="math inline">\(nums[k]\)</span>, the <span class="math inline">\(stack\)</span> can contain at most <span class="math inline">\(n-j-1\)</span> elements. Here, <span class="math inline">\(n\)</span> refers to the number of elements in <span class="math inline">\(nums\)</span> array.</p>
<p>We can also note that this is the same number of elements which lie beyond the <span class="math inline">\(j^{th}\)</span> index in <span class="math inline">\(nums\)</span> array. We also know that these elements lying beyond the <span class="math inline">\(j^{th}\)</span> index won't be needed in the future ever again. Thus, we can make use of this space in <span class="math inline">\(nums\)</span> array instead of using a separate <span class="math inline">\(stack\)</span>. The rest of the process can be carried on in the same manner as discussed in the last approach.</p>
<p>We can try to go for another optimization here. Since, we've got an array for storing the potential <span class="math inline">\(nums[k]\)</span> values now, we need not do the popping process for a <span class="math inline">\(min[j]\)</span> to find an element just larger than <span class="math inline">\(min[j]\)</span> from amongst these potential values.</p>
<p>Instead, we can make use of Binary Search to directly find an element, which is just larger than <span class="math inline">\(min[j]\)</span> in the required interval, if it exists. If such an element is found, we can compare it with <span class="math inline">\(nums[j]\)</span> to check the 132 criteria. Otherwise, we continue the process as in the last approach.</p>
<p><a href="https://leetcode.com/playground/8yeXd5nB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\big(n \log n\big)\)</span>. Filling <span class="math inline">\(min\)</span> array requires <span class="math inline">\(O(n)\)</span> time. The second traversal is done over the whole <span class="math inline">\(nums\)</span> array of length <span class="math inline">\(n\)</span>. For every current <span class="math inline">\(nums[j]\)</span> we need to do the Binary Search, which requires <span class="math inline">\(O\big(\log n\big)\)</span>. In the worst case, this Binary Search will be done for all the <span class="math inline">\(n\)</span> elements, and the required element won't be found in any case, leading to a complexity of <span class="math inline">\(O\big(n \log n\big)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-6-using-array-as-a-stack">Approach 6: Using Array as a Stack</h3>
<p><strong>Algorithm</strong></p>
<p>In the last approach, we've seen that in the worst case, the required element won't be found for all the <span class="math inline">\(n\)</span> elements and thus Binary Search is done at every step increasing the time complexity.</p>
<p>To remove this problem, we can follow the same steps as in Approach 4 i.e. We can remove those elements(update the index <span class="math inline">\(k\)</span>) which aren't greater than <span class="math inline">\(nums[i]$$(\)</span>min[j]<span class="math inline">\(). Thus, in case no element is larger than \)</span>min[j]<span class="math inline">\( the index $$k\)</span> reaches the last element.</p>
<p>Now, at every step, only <span class="math inline">\(nums[j]\)</span> will be added and removed from consideration in the next step, improving the time complexity in the worst case. The rest of the method remains the same as in Approach 4.</p>
<p>This approach is inspired by <a href="https://leetcode.com/fun4leetcode/">@fun4leetcode</a></p>
<p><a href="https://leetcode.com/playground/gN3j3eSo/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We travesre over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to fill the <span class="math inline">\(min\)</span> array. After this, we traverse over <span class="math inline">\(nums\)</span> to find the <span class="math inline">\(nums[k]\)</span>. At most <span class="math inline">\(n\)</span> elements can be put in and out of the <span class="math inline">\(nums\)</span> array in total. Thus, the second traversal requires only <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/activity-selection-1587115620/1" target="_blank" rel="noopener noreferrer">Activity Selection</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18.6667px;">You are given a set of activities, each with a <strong>start time</strong> and a <strong>finish time</strong>, represented by the arrays <strong>start[]</strong> and <strong>finish[]</strong>, respectively. A single person can perform only <strong>one activity</strong> at a time, meaning <strong>no two activities can overlap</strong>. Your task is to determine the <strong>maximum number of activities</strong> that a person can complete in a day.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong><strong>Input: </strong></strong>start[] = [1, 3, 0, 5, 8, 5], <span style="color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px; white-space: normal; background-color: #ffffff;">finish</span>[] = [2, 4, 6, 7, 9, 9]<br /><strong><strong>Output: </strong></strong>4<br /><strong><strong>Explanation: </strong></strong>A person can perform at most four activities. The maximum set of activities that can be executed is {0, 1, 3, 4}</span></pre>
<pre><span style="font-size: 14pt;"><strong><strong>Input:</strong></strong> start[] = [10, 12, 20], finish[] = [20, 25, 30]<br /><strong><strong>Output: </strong></strong>1<br /><strong><strong>Explanation: </strong></strong>A person can perform at most one activity.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>start[] = [1, 3, 2, 5], finish[] = [2, 4, 3, 6]
<strong>Output: </strong>3<strong>
Explanation: </strong>A person can perform activities 0, 1 and 3.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; start.size() = finish.size() &le; 2*10<sup>5</sup><br />0 &le; start[i] &le; finish[i] &le; 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description" target="_blank" rel="noopener noreferrer">Adjacent Increasing Subarrays Detection II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> of <code>n</code> integers, your task is to find the <strong>maximum</strong> value of <code>k</code> for which there exist <strong>two</strong> adjacent <span data-keyword="subarray-nonempty">subarrays</span> of length <code>k</code> each, such that both subarrays are <strong>strictly</strong> <strong>increasing</strong>. Specifically, check if there are <strong>two</strong> subarrays of length <code>k</code> starting at indices <code>a</code> and <code>b</code> (<code>a &lt; b</code>), where:</p>

<ul>
	<li>Both subarrays <code>nums[a..a + k - 1]</code> and <code>nums[b..b + k - 1]</code> are <strong>strictly increasing</strong>.</li>
	<li>The subarrays must be <strong>adjacent</strong>, meaning <code>b = a + k</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> <em>possible</em> value of <code>k</code>.</p>

<p>A <strong>subarray</strong> is a contiguous <b>non-empty</b> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,5,7,8,9,2,3,4,3,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The subarray starting at index 2 is <code>[7, 8, 9]</code>, which is strictly increasing.</li>
	<li>The subarray starting at index 5 is <code>[2, 3, 4]</code>, which is also strictly increasing.</li>
	<li>These two subarrays are adjacent, and 3 is the <strong>maximum</strong> possible value of <code>k</code> for which two such adjacent strictly increasing subarrays exist.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4,4,4,4,5,6,7]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The subarray starting at index 0 is <code>[1, 2]</code>, which is strictly increasing.</li>
	<li>The subarray starting at index 2 is <code>[3, 4]</code>, which is also strictly increasing.</li>
	<li>These two subarrays are adjacent, and 2 is the <strong>maximum</strong> possible value of <code>k</code> for which two such adjacent strictly increasing subarrays exist.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/apply-operations-to-maximize-frequency-score/description" target="_blank" rel="noopener noreferrer">Apply Operations to Maximize Frequency Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>.</p>

<p>You can perform the following operation on the array <strong>at most</strong> <code>k</code> times:</p>

<ul>
	<li>Choose any index <code>i</code> from the array and <strong>increase</strong> or <strong>decrease</strong> <code>nums[i]</code> by <code>1</code>.</li>
</ul>

<p>The score of the final array is the <strong>frequency</strong> of the most frequent element in the array.</p>

<p>Return <em>the <strong>maximum</strong> score you can achieve</em>.</p>

<p>The frequency of an element is the number of occurences of that element in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,6,4], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can do the following operations on the array:
- Choose i = 0, and increase the value of nums[0] by 1. The resulting array is [2,2,6,4].
- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,3].
- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,2].
The element 2 is the most frequent in the final array so our score is 3.
It can be shown that we cannot achieve a better score.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,4,2,4], k = 0
<strong>Output:</strong> 3
<strong>Explanation:</strong> We cannot apply any operations so our score will be the frequency of the most frequent element in the original array, which is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>14</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/arranging-coins/description" target="_blank" rel="noopener noreferrer">Arranging Coins</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> coins and you want to build a staircase with these coins. The staircase consists of <code>k</code> rows where the <code>i<sup>th</sup></code> row has exactly <code>i</code> coins. The last row of the staircase <strong>may be</strong> incomplete.</p>

<p>Given the integer <code>n</code>, return <em>the number of <strong>complete rows</strong> of the staircase you will build</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> n = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> Because the 3<sup>rd</sup> row is incomplete, we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg" style="width: 333px; height: 333px;" />
<pre>
<strong>Input:</strong> n = 8
<strong>Output:</strong> 3
<strong>Explanation:</strong> Because the 4<sup>th</sup> row is incomplete, we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/avoid-flood-in-the-city/description" target="_blank" rel="noopener noreferrer">Avoid Flood in The City</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the <code>nth</code> lake, the <code>nth</code> lake becomes full of water. If it rains over a lake that is <strong>full of water</strong>, there will be a <strong>flood</strong>. Your goal is to avoid floods in any lake.</p>

<p>Given an integer array <code>rains</code> where:</p>

<ul>
	<li><code>rains[i] &gt; 0</code> means there will be rains over the <code>rains[i]</code> lake.</li>
	<li><code>rains[i] == 0</code> means there are no rains this day and you can choose <strong>one lake</strong> this day and <strong>dry it</strong>.</li>
</ul>

<p>Return <em>an array <code>ans</code></em> where:</p>

<ul>
	<li><code>ans.length == rains.length</code></li>
	<li><code>ans[i] == -1</code> if <code>rains[i] &gt; 0</code>.</li>
	<li><code>ans[i]</code> is the lake you choose to dry in the <code>ith</code> day if <code>rains[i] == 0</code>.</li>
</ul>

<p>If there are multiple valid answers return <strong>any</strong> of them. If it is impossible to avoid flood return <strong>an empty array</strong>.</p>

<p>Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> rains = [1,2,3,4]
<strong>Output:</strong> [-1,-1,-1,-1]
<strong>Explanation:</strong> After the first day full lakes are [1]
After the second day full lakes are [1,2]
After the third day full lakes are [1,2,3]
After the fourth day full lakes are [1,2,3,4]
There&#39;s no day to dry any lake and there is no flood in any lake.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> rains = [1,2,0,0,2,1]
<strong>Output:</strong> [-1,-1,2,1,-1,-1]
<strong>Explanation:</strong> After the first day full lakes are [1]
After the second day full lakes are [1,2]
After the third day, we dry lake 2. Full lakes are [1]
After the fourth day, we dry lake 1. There is no full lakes.
After the fifth day, full lakes are [2].
After the sixth day, full lakes are [1,2].
It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> rains = [1,2,0,1,2]
<strong>Output:</strong> []
<strong>Explanation:</strong> After the second day, full lakes are  [1,2]. We have to dry one lake in the third day.
After that, it will rain over lakes [1,2]. It&#39;s easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rains.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= rains[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-square-in-a-binary-matrix-with-at-most-k-1s-for-multiple-queries/1" target="_blank" rel="noopener noreferrer">Binary Matrix with at most K 1s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">matrix</span> <span class="topic-badge">searching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary matrix <strong>M</strong> with <strong>R </strong>rows and <strong>C</strong> columns, where each element of the matrix will be 0 or 1. Find the largest square that can be formed with center <strong>(i, j)</strong> and contains atmost <strong>K</strong> 1s. There are Q queries, a single query has two integers denoting the centre (i,j) of the square.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>R = 4, C = 5
M = {{1, 0, 1, 0, 0}&nbsp;
     {1, 0, 1, 1, 1}&nbsp;
     {1, 1, 1, 1, 1}&nbsp;
     {1, 0, 0, 1, 0}}
K = 9, Q = 1
q_i[] = {1}
q_j[] = {2}
<strong>Output:
</strong>3
<strong>Explanation:</strong>
Maximum length square with center
at (1, 2)&nbsp;that can be formed is of
3 length from (0, 1) to (2, 3).</span>
</pre>
<div><span style="font-size: 18px;"><strong>Example 2:</strong></span></div>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>R = 3, C = 3
M = {{1, 1, 1}&nbsp;
     {1, 1, 1}&nbsp;
     {1, 1, 1}}
K = 9, Q = 2
q_i[] = {1, 2}
q_j[] = {1, 2}
<strong>Output :</strong>
3 1</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>largestSquare()</strong>&nbsp;which takes 2 integers R, and C followed by a list of lists M denoting the binary matrix and then three integers i,j, and K as input and returns a list of integers denting the largest Square possible for each query.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(R*C + Q*log(MIN_DIST)), <br /></span><span style="font-size: 18px;"><strong>Expected Auxiliary Space:</strong> O(R*C)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; R,C &le; 500<br />1 &le; Q &le; 10<sup>4</sup><br />0 &le; K &le; R*C<br />0 &le; i &lt; R<br />0 &le; j &lt; C</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-search/description" target="_blank" rel="noopener noreferrer">Binary Search</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>

<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 9
<strong>Output:</strong> 4
<strong>Explanation:</strong> 9 exists in nums and its index is 4
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> 2 does not exist in nums so return -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt; nums[i], target &lt; 10<sup>4</sup></code></li>
	<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>
	<li><code>nums</code> is sorted in ascending order.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>If you don't have much experience with binary-search-related problems, we strongly suggest you read this <a href="https://leetcode.com/explore/learn/card/binary-search/">LeetCode Explore Card</a>, our explore card for binary search! We'll cover four methods, the first three of which are closely related to those presented in this card, so it's helpful to look ahead!</p>
<hr />
<h3 id="approach-1-find-the-exact-value">Approach 1: Find the Exact Value</h3>
<h4 id="intuition">Intuition</h4>
<p>We start from the most basic and elementary template.</p>
<p>First, we define the search space using two boundary indexes, <code>left</code> and <code>right</code>, all possible indexes are within the inclusive range <code>[left, right]</code>. We shall continue searching over the search space as long as it is not empty. A general way is to use a while loop with the condition <code>left &lt;= right</code>, so we can break out of this loop if we empty the range or trigger other conditions which we will discuss later.</p>
<p><img src="../Figures/704_fix/b1_fix.png" alt="alt text" /></p>
<p>The next step is to find the 'pivot point', the middle index that divides the search space into two halves. We need to compare the value at the middle index <code>nums[mid]</code> with <code>target</code>, the purpose of this step is to cut one half that is guaranteed not to contain <code>target</code>.</p>
<ul>
<li>If <code>nums[mid] = target</code>, it means we find <code>target</code>, and the job is done! We can break the loop by returning <code>mid</code>.</li>
<li>If <code>nums[mid] &lt; target</code>, combined with the array is sorted, we know that all values in the left half are smaller than <code>target</code>, so we can safely cut this half by letting <code>left = mid + 1</code>.</li>
<li>If <code>nums[mid] &gt; target</code>, it means all values in the right half are larger than <code>target</code> and can be cut safely!</li>
</ul>
<p><img src="../Figures/704_fix/b2_fix.png" alt="alt text" /></p>
<p>Does this loop ever stop? Yes, take the following picture as an example, suppose we are searching over an array of size 1, in this case, <code>left</code>, <code>right</code>, and <code>mid</code> all stand for the only index in the array. In any of the three conditions, we trigger one of the break statements and stop the loop.</p>
<p><img src="../Figures/704_fix/b3_fix.png" alt="alt text" /></p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize the boundaries of the search space as <code>left = 0</code> and <code>right = nums.size - 1</code>.</li>
<li>If there are elements in the range <code>[left, right]</code>, we find the middle index <code>mid = (left + right) / 2</code> and compare the middle value <code>nums[mid]</code> with <code>target</code>:
<ul>
<li>If <code>nums[mid] = target</code>, return <code>mid</code>.</li>
<li>If <code>nums[mid] &lt; target</code>, let <code>left = mid + 1</code> and repeat step 2.</li>
<li>If <code>nums[mid] &gt; target</code>, let <code>right = mid - 1</code> and repeat step 2.</li>
</ul>
</li>
<li>We finish the loop without finding <code>target</code>, return <code>-1</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Bpknge2T/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log n)\)</span></p>
<ul>
<li><code>nums</code> is divided into half each time. In the worst-case scenario, we need to cut <code>nums</code> until the range has no element, and it takes logarithmic time to reach this break condition.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>During the loop, we only need to record three indexes, <code>left</code>, <code>right</code>, and <code>mid</code>, they take constant space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-find-upper-bound">Approach 2: Find Upper bound</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Here we introduce an alternative way to implement binary search: instead of looking for <code>target</code> in the array <code>nums</code>, we look for the insert position where we can put <code>target</code> in without disrupting the order.</p>
<p><img src="../Figures/704_fix/u1_fix.png" alt="alt text" /></p>
<p>Generally, we have two inserting ways, insert into the rightmost possible position which we called finding the <strong>upper bound</strong>, and insert into the leftmost possible position which we called finding the <strong>lower bound</strong>. We will implement them in the following approaches.</p>
<p>Take the picture below as an example. Assume that we want to insert <code>9</code> into array <code>A</code>. If we look for the <strong>upper bound</strong>, we have to insert <code>9</code> to the right of all existing <code>9</code>s in the array. Similarly, if we look for the <strong>lower bound</strong>, we have to insert <code>9</code> to the left of all existing <code>9</code>s. (Although we don't have duplicate elements in this problem, having duplicate elements is more common in problems so we would better know this concept in advance!)</p>
<p><img src="../Figures/704_fix/u3_fix.png" alt="alt text" /></p>
<p>Now we start the binary search. Similar to the previous approach, we still use <code>left</code> and <code>right</code> as two boundary indexes. The question is, what is the next step after we find the middle index <code>mid</code>?</p>
<p><img src="../Figures/704_fix/upper2_fix.png" alt="alt text" /></p>
<ul>
<li>
<p>If <code>nums[mid] &lt; target</code>, the insert position is on <code>mid</code>'s right, so we let <code>left = mid + 1</code> to discard the left half and <code>mid</code>.</p>
</li>
<li>
<p>If <code>nums[mid] = target</code>, the insert position is on <code>mid</code>'s right, so we let <code>left = mid + 1</code> to discard the left half and <code>mid</code>.</p>
</li>
</ul>
<p><img src="../Figures/704_fix/u4_fix.png" alt="alt text" /></p>
<ul>
<li>If <code>nums[mid] &gt; target</code>, <code>mid</code> can also be the insert position. So we let <code>right = mid</code> to discard the right half while keeping <code>mid</code>.</li>
</ul>
<p>Therefore, we merged the two conditions <code>nums[mid] = target</code> and <code>nums[mid] &lt; target</code> and there are only two conditions in the <code>if-else</code> statement!</p>
<p><img src="../Figures/704_fix/upper5_fix.png" alt="alt text" /></p>
<p>Once the loop stops, <code>left</code> stands for the insert position and <code>left - 1</code> is the largest element that is no larger than <code>target</code>. We just need to check if <code>nums[left - 1]</code> equals <code>target</code>. Note this boundary condition where <code>left = 0</code>, which means all elements in <code>nums</code> are larger than <code>target</code>, so there is no <code>target</code> in <code>nums</code>.</p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize the boundaries of the search space as <code>left = 0</code> and <code>right = nums.size</code> (Note that the maximum insert position can be <code>nums.size</code>)</li>
<li>If there are elements in the range <code>[left, right]</code>, we find the middle index <code>mid = (left + right) / 2</code> and compare the middle value <code>nums[mid]</code> with <code>target</code>:
<ul>
<li>If <code>nums[mid] &lt;= target</code>, let <code>left = mid + 1</code> and repeat step 2.</li>
<li>If <code>nums[mid] &gt; target</code>, let <code>right = mid</code> and repeat step 2.</li>
</ul>
</li>
<li>We finish the loop and <code>left</code> stands for the insert position:
<ul>
<li>If <code>left &gt; 0</code> and <code>nums[left - 1] = target</code>, return <code>left - 1</code>.</li>
<li>Otherwise, return <code>-1</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/EbGiVeiU/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log n)\)</span></p>
<ul>
<li><code>nums</code> is divided into half each time. In the worst-case scenario, we need to cut <code>nums</code> until the range has no element, it takes logarithmic time to reach this break condition.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>During the loop, we only need to record three indexes, <code>left</code>, <code>right</code>, and <code>mid</code>, they take constant space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-find-lower-bound">Approach 3: Find Lower bound</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Different from the previous method, here we are looking for the <strong>leftmost</strong> insert position. Therefore, we will make the following changes to the judgment condition:</p>
<ul>
<li>
<p>If <code>nums[mid] &lt; target</code>, <code>mid</code> can also be the insertion position. So we let <code>left = mid + 1</code>, that is, discard the left half while keeping <code>mid</code>.</p>
</li>
<li>
<p>If <code>nums[mid] = target</code>, the insert position is on <code>mid</code>'s left, so we let <code>right = mid</code> to discard both the right half and <code>mid</code>.</p>
</li>
</ul>
<p><img src="../Figures/704_fix/lower1_fix.png" alt="alt text" /></p>
<ul>
<li>If <code>nums[mid] &gt; target</code>, the insert position is on <code>mid</code>'s left, so we let <code>right = mid</code> to discard both the right half and <code>mid</code>.</li>
</ul>
<p>Therefore, we merged the two conditions <code>nums[mid] = target</code> and <code>nums[mid] &gt; target</code> and there are only two conditions in the <code>if-else</code> statement!</p>
<p><img src="../Figures/704_fix/lower2_fix.png" alt="alt text" /></p>
<p>Once the loop stops, <code>left</code> stands for the insert position and <code>nums[left]</code> is the smallest element that is no less than <code>target</code>. We just need to check if <code>nums[left]</code> equals <code>target</code>. Note this boundary condition <code>left = nums.size</code>, which means all elements in <code>nums</code> are smaller than <code>target</code>, so there is no <code>target</code> in <code>nums</code>.</p>
<br>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize the boundaries of the search space as <code>left = 0</code> and <code>right = nums.size</code> (Note that the maximum insert position can be <code>nums.size</code>)</li>
<li>If there are elements in the range <code>[left, right]</code>, we find the middle index <code>mid = (left + right) / 2</code> and compare the middle value <code>nums[mid]</code> with <code>target</code>:
<ul>
<li>If <code>nums[mid] &gt;= target</code>, let <code>right = mid</code> and repeat step 2.</li>
<li>If <code>nums[mid] &lt; target</code>, let <code>left = mid + 1</code> and repeat step 2.</li>
</ul>
</li>
<li>We finish the loop and <code>left</code> stands for the insert position:
<ul>
<li>If <code>left &lt; nums.size</code> and <code>nums[left] = target</code>, return <code>left</code>.</li>
<li>Otherwise, return <code>-1</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/PtMd9Lfm/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log n)\)</span></p>
<ul>
<li><code>nums</code> is divided into half each time. In the worst-case scenario, we need to cut <code>nums</code> until the range has no element, it takes logarithmic time to reach this break condition.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>During the loop, we only need to record three indexes, <code>left</code>, <code>right</code>, and <code>mid</code>, they take constant space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-4-use-built-in-tools">Approach 4: Use built-in tools.</h3>
<h4 id="intuition-3">Intuition</h4>
<p>We have implemented various templates of binary search, now let's quickly go through the last approach that uses built-in functions. C++ provides the <code>&lt;algorithm&gt;</code> library that defines functions for binary searching, Python provides <code>bisect</code> module which also supports binary search functions. If we are solving some standard problems that do not require a lot of customization, it's feasible to rely on these built-in tools to save time.</p>
<p>Note that <code>upper_bound</code> and <code>bisect.bisect_right</code> look for the rightmost insertion position and bring the same result as approach 2, while <code>lower_bound</code> and <code>bisect.bisect_left</code> look for the leftmost insertion position and end up with the same result as approach 3. Once we find the insertion position, check if the value at the corresponding position equals <code>target</code>.</p>
<p>Here we implement the method that uses <strong>upper_bound</strong> or <strong>bisect.bisect_right</strong> and leave another half as a practice!</p>
<br>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Use built-in tools to locate the rightmost insertion position <code>idx</code>.</li>
<li>If <code>idx &gt; 0</code> and <code>nums[idx - 1] = target</code>, return <code>idx -1</code>. Otherwise, return <code>-1</code>.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/oXjRqYX9/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log n)\)</span></p>
<ul>
<li>The time complexity of the built-in binary search is <span class="math inline">\(O(\log n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>The built-in binary search only takes <span class="math inline">\(O(1)\)</span> space.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/block-placement-queries/description" target="_blank" rel="noopener noreferrer">Block Placement Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exists an infinite number line, with its origin at 0 and extending towards the <strong>positive</strong> x-axis.</p>

<p>You are given a 2D array <code>queries</code>, which contains two types of queries:</p>

<ol>
	<li>For a query of type 1, <code>queries[i] = [1, x]</code>. Build an obstacle at distance <code>x</code> from the origin. It is guaranteed that there is <strong>no</strong> obstacle at distance <code>x</code> when the query is asked.</li>
	<li>For a query of type 2, <code>queries[i] = [2, x, sz]</code>. Check if it is possible to place a block of size <code>sz</code> <em>anywhere</em> in the range <code>[0, x]</code> on the line, such that the block <strong>entirely</strong> lies in the range <code>[0, x]</code>. A block <strong>cannot </strong>be placed if it intersects with any obstacle, but it may touch it. Note that you do<strong> not</strong> actually place the block. Queries are separate.</li>
</ol>

<p>Return a boolean array <code>results</code>, where <code>results[i]</code> is <code>true</code> if you can place the block specified in the <code>i<sup>th</sup></code> query of type 2, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false,true,true]</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example0block.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 309px; height: 129px;" /></strong></p>

<p>For query 0, place an obstacle at <code>x = 2</code>. A block of size at most 2 can be placed before <code>x = 3</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">queries = </span>[[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]<!-- notionvc: 4a471445-5af1-4d72-b11b-94d351a2c8e9 --></p>

<p><strong>Output:</strong> [true,true,false]</p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example1block.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 310px; height: 130px;" /></strong></p>

<ul>
	<li>Place an obstacle at <code>x = 7</code> for query 0. A block of size at most 7 can be placed before <code>x = 7</code>.</li>
	<li>Place an obstacle at <code>x = 2</code> for query 2. Now, a block of size at most 5 can be placed before <code>x = 7</code>, and a block of size at most 2 before <code>x = 2</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= queries.length &lt;= 15 * 10<sup>4</sup></code></li>
	<li><code>2 &lt;= queries[i].length &lt;= 3</code></li>
	<li><code>1 &lt;= queries[i][0] &lt;= 2</code></li>
	<li><code>1 &lt;= x, sz &lt;= min(5 * 10<sup>4</sup>, 3 * queries.length)</code></li>
	<li>The input is generated such that for queries of type 1, no obstacle exists at distance <code>x</code> when the query is asked.</li>
	<li>The input is generated such that there is at least one query of type 2.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/booking-concert-tickets-in-groups/description" target="_blank" rel="noopener noreferrer">Booking Concert Tickets in Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A concert hall has <code>n</code> rows numbered from <code>0</code> to <code>n - 1</code>, each with <code>m</code> seats, numbered from <code>0</code> to <code>m - 1</code>. You need to design a ticketing system that can allocate seats in the following cases:</p>

<ul>
	<li>If a group of <code>k</code> spectators can sit <strong>together</strong> in a row.</li>
	<li>If <strong>every</strong> member of a group of <code>k</code> spectators can get a seat. They may or <strong>may not</strong> sit together.</li>
</ul>

<p>Note that the spectators are very picky. Hence:</p>

<ul>
	<li>They will book seats only if each member of their group can get a seat with row number <strong>less than or equal</strong> to <code>maxRow</code>. <code>maxRow</code> can <strong>vary</strong> from group to group.</li>
	<li>In case there are multiple rows to choose from, the row with the <strong>smallest</strong> number is chosen. If there are multiple seats to choose in the same row, the seat with the <strong>smallest</strong> number is chosen.</li>
</ul>

<p>Implement the <code>BookMyShow</code> class:</p>

<ul>
	<li><code>BookMyShow(int n, int m)</code> Initializes the object with <code>n</code> as number of rows and <code>m</code> as number of seats per row.</li>
	<li><code>int[] gather(int k, int maxRow)</code> Returns an array of length <code>2</code> denoting the row and seat number (respectively) of the <strong>first seat</strong> being allocated to the <code>k</code> members of the group, who must sit <strong>together</strong>. In other words, it returns the smallest possible <code>r</code> and <code>c</code> such that all <code>[c, c + k - 1]</code> seats are valid and empty in row <code>r</code>, and <code>r &lt;= maxRow</code>. Returns <code>[]</code> in case it is <strong>not possible</strong> to allocate seats to the group.</li>
	<li><code>boolean scatter(int k, int maxRow)</code> Returns <code>true</code> if all <code>k</code> members of the group can be allocated seats in rows <code>0</code> to <code>maxRow</code>, who may or <strong>may not</strong> sit together. If the seats can be allocated, it allocates <code>k</code> seats to the group with the <strong>smallest</strong> row numbers, and the smallest possible seat numbers in each row. Otherwise, returns <code>false</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;BookMyShow&quot;, &quot;gather&quot;, &quot;gather&quot;, &quot;scatter&quot;, &quot;scatter&quot;]
[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]
<strong>Output</strong>
[null, [0, 0], [], true, false]

<strong>Explanation</strong>
BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each 
bms.gather(4, 0); // return [0, 0]
                  // The group books seats [0, 3] of row 0. 
bms.gather(2, 0); // return []
                  // There is only 1 seat left in row 0,
                  // so it is not possible to book 2 consecutive seats. 
bms.scatter(5, 1); // return True
                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. 
bms.scatter(5, 1); // return False
                   // There is only one seat left in the hall.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>
	<li>At most <code>5 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>gather</code> and <code>scatter</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/building-boxes/description" target="_blank" rel="noopener noreferrer">Building Boxes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a cubic storeroom where the width, length, and height of the room are all equal to <code>n</code> units. You are asked to place <code>n</code> boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:</p>

<ul>
	<li>You can place the boxes anywhere on the floor.</li>
	<li>If box <code>x</code> is placed on top of the box <code>y</code>, then each side of the four vertical sides of the box <code>y</code> <strong>must</strong> either be adjacent to another box or to a wall.</li>
</ul>

<p>Given an integer <code>n</code>, return<em> the <strong>minimum</strong> possible number of boxes touching the floor.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/3-boxes.png" style="width: 135px; height: 143px;" /></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> The figure above is for the placement of the three boxes.
These boxes are placed in the corner of the room, where the corner is on the left side.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/4-boxes.png" style="width: 135px; height: 179px;" /></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> The figure above is for the placement of the four boxes.
These boxes are placed in the corner of the room, where the corner is on the left side.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/10-boxes.png" style="width: 271px; height: 257px;" /></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 6
<strong>Explanation:</strong> The figure above is for the placement of the ten boxes.
These boxes are placed in the corner of the room, where the corner is on the back side.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/capacity-to-ship-packages-within-d-days/description" target="_blank" rel="noopener noreferrer">Capacity To Ship Packages Within D Days</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A conveyor belt has packages that must be shipped from one port to another within <code>days</code> days.</p>

<p>The <code>i<sup>th</sup></code> package on the conveyor belt has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt (in the order given by <code>weights</code>). We may not load more weight than the maximum weight capacity of the ship.</p>

<p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within <code>days</code> days.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> weights = [1,2,3,4,5,6,7,8,9,10], days = 5
<strong>Output:</strong> 15
<strong>Explanation:</strong> A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> weights = [3,2,2,4,1,4], days = 3
<strong>Output:</strong> 6
<strong>Explanation:</strong> A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> weights = [1,2,3,1,1], days = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong>
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= days &lt;= weights.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= weights[i] &lt;= 500</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/ceil-in-a-sorted-array/1" target="_blank" rel="noopener noreferrer">Ceil in a Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">searching</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a sorted array&nbsp;<strong>arr[]&nbsp;</strong>and an integer&nbsp;<strong>x</strong>, find the index (0-based) of the smallest element in arr[] that is greater than or equal to x. This element is called the&nbsp;<strong>ceil</strong> of x. If such an element does not exist, return -1.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;In case of multiple occurrences of ceil of x, return the index of the first occurrence.</span></p>
<p><strong style="font-size: 18px;">Examples</strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 2, 8, 10, 11, 12, 19], x = 5
<strong>Output: </strong>2<strong>
Explanation: </strong>Smallest number greater than 5 is 8, whose index is 2.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 2, 8, 10, 11, 12, 19], x = 20
<strong>Output: </strong>-1<strong>
Explanation: </strong></span><span style="font-size: 18px;">No element greater than 20 is found. So output is -1.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1, 1, 2, 8, 10, 11, 12, 19], x = 0
<strong>Output: </strong>0<strong>
Explanation: </strong>Smallest number greater than 0 is 1, whose indices are 0 and 1. The index of the first occurrence is 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />1 &le; arr[i] &le; 10<sup>6</sup><br />0 &le; x &le;<sup>&nbsp;</sup>arr[n-1]</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-n-and-its-double-exist/description" target="_blank" rel="noopener noreferrer">Check If N and Its Double Exist</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>arr</code> of integers, check if there exist two indices <code>i</code> and <code>j</code> such that :</p>

<ul>
	<li><code>i != j</code></li>
	<li><code>0 &lt;= i, j &lt; arr.length</code></li>
	<li><code>arr[i] == 2 * arr[j]</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [10,2,5,3]
<strong>Output:</strong> true
<strong>Explanation:</strong> For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,1,7,11]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no i and j that satisfy the conditions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= arr.length &lt;= 500</code></li>
	<li><code>-10<sup>3</sup> &lt;= arr[i] &lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>This problem is designed to help beginners get comfortable with basic array operations and the implementation of basic data structures. We are given an array and our goal is to find out if there are two different indices, represented by <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, where the value of one is twice the value of the other.</p>
<p>How to interpret the three conditions:</p>
<ul>
<li><code>i</code> and <code>j</code> must be different indices. This might seem like an obvious point unless you consider that <span class="math inline">\(0 = 2 \times 0\)</span>. Without this condition, we'd be able to count just one <code>0</code> in the array as satisfying the goal. With this condition, an array would need two <code>0</code>s to satisfy the conditions.</li>
<li><code>0 &lt;= i, j &lt; arr.length</code> just means that the indices are within the bounds of the array. This condition doesn't mean much, it's essentially a requirement for any array-based algorithm.</li>
<li><code>arr[i] == 2 * arr[j]</code> is how we know <code>i</code> needs to be double <code>j</code>.</li>
</ul>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>One simple approach is to calculate the double of each number and then check if that value is in the array. This brute force method directly explores all possible pairs for each element until the result is found. This approach works but is not the most efficient.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Iterate through all pairs of indices <code>i</code> and <code>j</code> in the array <code>arr</code>.</p>
<ul>
<li>For each pair, check if:
<ul>
<li><code>i != j</code> (to ensure we aren't comparing the same element).</li>
<li><code>arr[i] == 2 * arr[j]</code> (one element is double the other).</li>
</ul>
</li>
<li>If both conditions are met, return <code>true</code> to indicate a valid pair is found.</li>
</ul>
</li>
<li>
<p>If no valid pair is found after checking all pairs, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4wc64szF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm consists of two nested loops. The outer loop iterates over each element in the array <code>arr</code>, and the inner loop also iterates over all elements of <code>arr</code>. For each pair of indices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, the algorithm checks the condition <span class="math inline">\(arr[i] == 2 \times arr[j]\)</span> and ensures <span class="math inline">\(i \neq j\)</span>.</p>
<p>Since both loops iterate <code>n</code> times, the time complexity of the nested loops is <span class="math inline">\(O(n \times n) = O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm does not use any additional data structures that grow with the size of the input. The space used by the algorithm is constant, as it only requires a few variables for the loop indices and condition checking. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-set-lookup">Approach 2: Set Lookup</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The brute force method doesn’t keep track of what it’s seen, so it wastes effort by revisiting the same values each time it loops through the array. Let's break down a solution where we can &quot;store what we’ve seen&quot; to speed up lookups.</p>
<p>A hash set works well here because it allows constant-time insertion and lookup. Instead of scanning the array multiple times, we use the set to check if <span class="math inline">\(2 \times arr[i]\)</span> or <span class="math inline">\(arr[i] / 2\)</span> (when divisible) already exists. If neither condition is met, we add <span class="math inline">\(arr[i]\)</span> to the set and continue.</p>
<p>This way, we only iterate through the array once and eliminate the unnecessary comparisons we made in the brute force approach.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty set named <code>seen</code> to store numbers encountered so far.</p>
</li>
<li>
<p>For each <code>num</code> in the array <code>arr</code>:</p>
<ul>
<li>Check if <code>2 * num</code> or <code>num / 2</code> exists in the <code>seen</code> set:
<ul>
<li>If <code>2 * num</code> is found in the set, or if <code>num</code> is divisible by 2 and <code>num / 2</code> is found in the set, return <code>true</code> (a valid pair is found).</li>
</ul>
</li>
<li>Add the current number <code>num</code> to the <code>seen</code> set for future checks.</li>
</ul>
</li>
<li>
<p>If no valid pair is found after checking all elements, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/XXqGNvZy/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the array <code>arr</code> once, processing each element individually. For each element, it performs two operations:</p>
<ol>
<li>Checking if <span class="math inline">\(2 \times \text{num}\)</span> or <span class="math inline">\(\text{num} / 2\)</span> is in the set, which takes <span class="math inline">\(O(1)\)</span> on average due to the constant-time lookup in the set.</li>
<li>Adding the current element to the set, which also takes <span class="math inline">\(O(1)\)</span> on average for each insertion.</li>
</ol>
<p>Since both operations inside the loop take constant time, and the loop runs <code>n</code> times, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The primary space usage comes from the set, which stores up to <code>n</code> unique elements from the array <code>arr</code>. In the worst case, when all elements are unique, the set will contain <code>n</code> elements, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>No additional significant data structures are used, so the auxiliary space complexity is <span class="math inline">\(O(1)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sorting--binary-search">Approach 3: Sorting + Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's make a simple observation: except when the values of <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are both 0, <span class="math inline">\(j\)</span> will always be greater than <span class="math inline">\(i\)</span>. Since the relationship between the two is directional, we can sort the array in ascending order and apply one of the most fundamental search algorithms: binary search.</p>
<p>Binary search is a two-pointer technique for efficiently locating a value in an ordered collection. Unlike Approach One, which checks each element individually, binary search repeatedly divides the search range in half which significantly reduces the number of comparisons we need to make.</p>
<blockquote>
<p>For a more comprehensive understanding of binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card 🔗</a>. This resource offers an in-depth look at binary search, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>We start by setting one pointer to the first possible element and the second pointer to the last. At each step, we compare the target value to the middle element of the current range. If the target is greater than the midpoint, we eliminate all elements before the midpoint by moving the first pointer to the position just right of it. If the target is smaller, we eliminate all elements after the midpoint by moving the second pointer to the position just left of it. This process continues until the target is found or the range is empty.</p>
<p>!?!../Documents/1346/1346_approach3.json:805,545!?!</p>
</br>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Sort the array <code>arr</code> in ascending order to enable efficient searching.</p>
</li>
<li>
<p>For each element <code>arr[i]</code> in the array:</p>
<ul>
<li>
<p>Calculate the target value as <code>2 * arr[i]</code> (double the current number).</p>
</li>
<li>
<p>Perform a custom binary search for the target in the array:</p>
<ul>
<li>In the <code>customBinarySearch</code> function:
<ul>
<li>Set <code>left</code> to 0 and <code>right</code> to <code>arr.length - 1</code> to define the search range.</li>
<li>While <code>left &lt;= right</code>, calculate the midpoint <code>mid</code>.
<ul>
<li>If <code>arr[mid] == target</code>, return the index <code>mid</code> (target found).</li>
<li>If <code>arr[mid] &lt; target</code>, move the <code>left</code> pointer to <code>mid + 1</code> to search the right half.</li>
<li>If <code>arr[mid] &gt; target</code>, move the <code>right</code> pointer to <code>mid - 1</code> to search the left half.</li>
</ul>
</li>
<li>If the target is not found, return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the target exists and its index is not the same as the current index <code>i</code>, return <code>true</code> (found a pair where one element is double the other).</p>
</li>
</ul>
</li>
<li>
<p>If no valid pair is found after iterating through the array, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/nk58Tg9Z/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The sort function sorts the array in <span class="math inline">\(O(n \log n)\)</span> time. Sorting is the most time-consuming operation here.</p>
<p>The for loop iterates through each element in the array, and for each element, it calls the <code>customBinarySearch</code> function. The binary search operation itself takes <span class="math inline">\(O(\log n)\)</span> time, as it divides the search space in half at each step.</p>
<p>Therefore, the time complexity of the loop is <span class="math inline">\(O(n)\)</span> for iterating through the array, and for each iteration, the binary search takes <span class="math inline">\(O(\log n)\)</span>. Thus, the total time complexity for the loop is <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Combining both parts, the overall time complexity is <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span></p>
<p>The space taken by the sorting algorithm depends on the language of implementation:</p>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</p>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</p>
<p>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The binary search uses constant space for variables like <code>left</code>, <code>right</code>, and <code>mid</code>. The loop also does not use any additional space other than a few variables. Therefore, the space used by the loop is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-frequency-hash-map">Approach 4: Frequency Hash Map</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of using a hash set to find the pair like we did in Approach 2, we can use a frequency map. Some may understandably wonder why we don't use a frequency array instead of a map, which could be more memory-efficient and an excellent choice if the constraint were <code>&gt;= 0</code>. However, since this problem allows negative numbers, a frequency map is the better choice.</p>
<p>First, we will count the number of occurrences of each number and store their counts in their respective indices. Then, we will iterate again and check each element:</p>
<ol>
<li>If <code>num</code> is in the array, we check if <code>2 * num</code> also exists using the map.</li>
<li>If <code>num = 0</code>, we ensure its count is at least 2 to satisfy <code>i ≠ j</code>.</li>
</ol>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty hash map called <code>map</code> to store the count of occurrences of each number in the array.</p>
</li>
<li>
<p>For each number <code>num</code> in <code>arr</code>:</p>
<ul>
<li>Update the map with the count of <code>num</code> by incrementing the value associated with <code>num</code> in <code>map</code>.</li>
</ul>
</li>
<li>
<p>After populating the map, check for the condition where a number has a double in the array:</p>
<ul>
<li>For each <code>num</code> in <code>arr</code>, if <code>num</code> is not zero and <code>map</code> contains <code>2 * num</code>, return <code>true</code> (found a number with its double).</li>
<li>If <code>num</code> is zero and there are more than one zero in the array (i.e., <code>map.get(num) &gt; 1</code>), return <code>true</code> (special case where 0 is double of 0).</li>
</ul>
</li>
<li>
<p>If no such pair is found, return <code>false</code> (no number has its double in the array).</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/9e6gbmPT/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm consists of two main loops. The first loop iterates through the array <code>arr</code> and inserts or updates each element in the hash map. The insertion operation in the hash map takes <span class="math inline">\(O(1)\)</span> on average, so the time complexity of this loop is <span class="math inline">\(O(n)\)</span>.</p>
<p>The second loop also iterates through the array <code>arr</code> and performs constant-time operations for each element, including lookups in the hash map (which are <span class="math inline">\(O(1)\)</span> on average). Therefore, the time complexity of this loop is also <span class="math inline">\(O(n)\)</span>.</p>
<p>As a result, the overall time complexity is <span class="math inline">\(O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the hash map, which stores up to <code>n</code> unique elements from the array <code>arr</code>. Each key-value pair in the hash map consumes space, so in the worst case, the space required is proportional to the number of unique elements in <code>arr</code>, which is <span class="math inline">\(O(n)\)</span>.</p>
<p>No additional data structures that depend on the size of the input are used, so the auxiliary space is <span class="math inline">\(O(1)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</br>
<h4 id="note-on-hash-maps-and-sets">Note on Hash Maps and Sets</h4>
<p>Hash maps and hash sets are widely used data structures that provide efficient storage and retrieval of data. Their average-case time complexity for most operations, such as insertion, deletion, and lookup, is often <span class="math inline">\(O(1)\)</span>. However, this efficiency depends on several factors, and there are edge cases where performance can degrade.</p>
<h5 id="average-case-complexity-o1">Average-Case Complexity: <span class="math inline">\(O(1)\)</span></h5>
<p>Hashing Process: The operation relies on a hash function, which maps keys to specific &quot;buckets&quot; in memory.</p>
<ul>
<li>A well-designed hash function ensures uniform distribution of keys across buckets. The hash computation itself is expected to be a constant-time operation in most cases.</li>
<li>Once the hash is computed, the bucket corresponding to the hash is accessed directly, making the lookup process efficient.</li>
</ul>
<h5 id="worst-case-complexity-on">Worst-Case Complexity: <span class="math inline">\(O(n)\)</span></h5>
<p>Hash Collisions: When multiple keys map to the same bucket due to the hash function returning the same hash code, a collision occurs.</p>
<ul>
<li>In such cases, the hash map stores all colliding entries in a bucket, typically as a linked list.</li>
<li>To resolve collisions, the hash map iterates through the bucket, checking each entry with an equality comparison, leading to <span class="math inline">\(O(n)\)</span> time complexity if all keys hash to the same bucket.</li>
<li>This worst-case scenario is extremelly rare with a good hash function, but it is still a theoretical limitation to consider when designing or selecting algorithms.</li>
</ul>
<h5 id="improvements-in-modern-implementations-eg-java-hashmap-in-jdk-8">Improvements in Modern Implementations (e.g., Java HashMap in JDK 8)</h5>
<p>Tree-Backed Buckets: In modern hash map implementations, buckets that become densely populated are converted into balanced binary trees.</p>
<ul>
<li>This reduces the lookup time complexity in such cases from <span class="math inline">\(O(n)\)</span> to <span class="math inline">\(O(\log n)\)</span>. The tree structure leverages key ordering for efficient traversal.</li>
<li>If the key type's equality (<code>equals</code>) and ordering (<code>compareTo</code>) logic are inconsistent, this optimization sometimes leads to unpredictable behavior.</li>
</ul>
<h5 id="takeaway">Takeaway:</h5>
<p>In most real-world scenarios, hash maps and sets offer excellent performance and are the default choice for many applications requiring fast lookups.</p>
<p>However, be cautious of:</p>
<ul>
<li>Poor hash functions.</li>
<li>Memory limitations.</li>
<li>Keys with inconsistent equality and ordering logic in modern implementations.</li>
</ul>
<p>In general, when analyzing time complexity and space complexity in editorials, videos or discussions on the internet, most assume that hash functions are well-designed. This assumption allows us to consider the complexity of hash table operations as <span class="math inline">\(O(1)\)</span>, rather than <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>. This consistent behavior is reflected in almost all articles or videos you may encounter, where lookups are always described as constant time, never as <span class="math inline">\(O(n)\)</span> due to the underlying principles of hash functions.</p>
<p>To deepen your understanding of hash maps, sets, and their underlying principles, the following resources are highly recommended:</p>
<ol>
<li><a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card 🔗</a>: This card has some great explanations on how it is applied to different DSA problems and how to recognize this pattern.</li>
<li><a href="https://en.wikipedia.org/wiki/Universal_hashing">Universal Hashing</a>: This explains the principles behind creating hash functions that achieve the ideal <span class="math inline">\(O(1)\)</span> performance.</li>
<li><a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table</a>: This covers collision handling techniques (like chaining and open addressing) and practical trade-offs in hash table design.</li>
</ol>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/closer-to-sort-1587115620/1" target="_blank" rel="noopener noreferrer">Closer to sort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">searching</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an array <strong>arr[]</strong> of distinct positive integers that is closely sorted, and a target element <strong>x</strong>, your task is to find the index of <strong>x</strong> in the array. If <strong>x</strong> is not present, return -1.</span><br /><span style="font-size: 18px;"><strong>Closer Sorted</strong>: The first array is sorted, but after sorting some elements are moved to either of the adjacent positions, i.e, maybe to the <strong>arr[i+1]</strong> or <strong>arr[i-1]</strong>.<br /><br /><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [3 2 10 4 40], x = 2
<strong>Output</strong>: 1
<strong>Explanation</strong>: 2 is present at index 1 (0-based indexing) in the given array.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [2 1 4 3], x = 5
<strong>Output</strong>: -1
<strong>Explanation</strong>: 5 is not in the array so the output will be -1.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />1 &le; arr[i],x &le; 10</span><sup><span style="font-size: 15px;">9</span></sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-equal-element-queries/description" target="_blank" rel="noopener noreferrer">Closest Equal Element Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>circular</strong> array <code>nums</code> and an array <code>queries</code>.</p>

<p>For each query <code>i</code>, you have to find the following:</p>

<ul>
	<li>The <strong>minimum</strong> distance between the element at index <code>queries[i]</code> and <strong>any</strong> other index <code>j</code> in the <strong>circular</strong> array, where <code>nums[j] == nums[queries[i]]</code>. If no such index exists, the answer for that query should be -1.</li>
</ul>

<p>Return an array <code>answer</code> of the <strong>same</strong> size as <code>queries</code>, where <code>answer[i]</code> represents the result for query <code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,3,1,4,1,3,2], queries = [0,3,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,-1,3]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Query 0: The element at <code>queries[0] = 0</code> is <code>nums[0] = 1</code>. The nearest index with the same value is 2, and the distance between them is 2.</li>
	<li>Query 1: The element at <code>queries[1] = 3</code> is <code>nums[3] = 4</code>. No other index contains 4, so the result is -1.</li>
	<li>Query 2: The element at <code>queries[2] = 5</code> is <code>nums[5] = 3</code>. The nearest index with the same value is 1, and the distance between them is 3 (following the circular path: <code>5 -&gt; 6 -&gt; 0 -&gt; 1</code>).</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4], queries = [0,1,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[-1,-1,-1,-1]</span></p>

<p><strong>Explanation:</strong></p>

<p>Each value in <code>nums</code> is unique, so no index shares the same value as the queried element. This results in -1 for all queries.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= queries.length &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>0 &lt;= queries[i] &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Closest Nodes Queries in a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary search tree </strong>and an array <code>queries</code> of size <code>n</code> consisting of positive integers.</p>

<p>Find a <strong>2D</strong> array <code>answer</code> of size <code>n</code> where <code>answer[i] = [min<sub>i</sub>, max<sub>i</sub>]</code>:</p>

<ul>
	<li><code>min<sub>i</sub></code> is the <strong>largest</strong> value in the tree that is smaller than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
	<li><code>max<sub>i</sub></code> is the <strong>smallest</strong> value in the tree that is greater than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
</ul>

<p>Return <em>the array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png" style="width: 261px; height: 281px;" />
<pre>
<strong>Input:</strong> root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
<strong>Output:</strong> [[2,2],[4,6],[15,-1]]
<strong>Explanation:</strong> We answer the queries in the following way:
- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].
- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].
- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png" style="width: 101px; height: 121px;" />
<pre>
<strong>Input:</strong> root = [4,null,9], queries = [3]
<strong>Output:</strong> [[-1,4]]
<strong>Explanation:</strong> The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>n == queries.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-room/description" target="_blank" rel="noopener noreferrer">Closest Room</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a hotel with <code>n</code> rooms. The rooms are represented by a 2D integer array <code>rooms</code> where <code>rooms[i] = [roomId<sub>i</sub>, size<sub>i</sub>]</code> denotes that there is a room with room number <code>roomId<sub>i</sub></code> and size equal to <code>size<sub>i</sub></code>. Each <code>roomId<sub>i</sub></code> is guaranteed to be <strong>unique</strong>.</p>

<p>You are also given <code>k</code> queries in a 2D array <code>queries</code> where <code>queries[j] = [preferred<sub>j</sub>, minSize<sub>j</sub>]</code>. The answer to the <code>j<sup>th</sup></code> query is the room number <code>id</code> of a room such that:</p>

<ul>
	<li>The room has a size of <strong>at least</strong> <code>minSize<sub>j</sub></code>, and</li>
	<li><code>abs(id - preferred<sub>j</sub>)</code> is <strong>minimized</strong>, where <code>abs(x)</code> is the absolute value of <code>x</code>.</li>
</ul>

<p>If there is a <strong>tie</strong> in the absolute difference, then use the room with the <strong>smallest</strong> such <code>id</code>. If there is <strong>no such room</strong>, the answer is <code>-1</code>.</p>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>k</code><em> where </em><code>answer[j]</code><em> contains the answer to the </em><code>j<sup>th</sup></code><em> query</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
<strong>Output:</strong> [3,-1,3]
<strong>Explanation: </strong>The answers to the queries are as follows:
Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.
Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.
Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
<strong>Output:</strong> [2,1,3]
<strong>Explanation: </strong>The answers to the queries are as follows:
Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.
Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.
Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == rooms.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>k == queries.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= roomId<sub>i</sub>, preferred<sub>j</sub> &lt;= 10<sup>7</sup></code></li>
	<li><code>1 &lt;= size<sub>i</sub>, minSize<sub>j</sub> &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/coin-piles5152/1" target="_blank" rel="noopener noreferrer">Coin Piles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="246" data-end="383"><span style="font-size: 14pt;">You are given an array <strong>arr[]</strong> of integers, where each element represents the number of coins in a pile. You are also given an integer <strong>k.</strong><br /></span><span style="font-size: 14pt;">Your task is to remove the minimum number of <strong>coins</strong> such that the absolute difference between the number of coins in any two updated piles is at most <strong>k.</strong></span></p>
<p><span style="font-size: 18px;"> <strong>Note</strong>:&nbsp;You can also remove a pile by removing all the coins of that pile.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [2, 2, 2, 2], k = 0
<strong>Output: </strong>0
<strong>Explanation: </strong></span><span style="font-size: 18px;">For any two piles the difference in the number of coins is &lt;= 0. So no need to remove any coin.</span> 
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[]<strong> = </strong>[1, 5, 1, 2, 5, 1], k = 3
<strong>Output: </strong>2</span>
<span style="font-size: 18px;"><strong>Explanation: </strong></span><span style="font-size: 18px;">If we remove one coin each from both the piles containing 5 coins, then for any two piles the absolute difference in the number of coins is &lt;= 3.</span> 
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; arr.size() &le; 10<sup>5<br /></sup><span style="font-size: 18.6667px;">1 &le; arr[i] &le; 10</span><sup>4</sup><sup><br /></sup></span><span style="font-size: 18px;">0 &le; k &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/description" target="_blank" rel="noopener noreferrer">Compare Strings by Frequency of the Smallest Character</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Let the function <code>f(s)</code> be the <strong>frequency of the lexicographically smallest character</strong> in a non-empty string <code>s</code>. For example, if <code>s = &quot;dcce&quot;</code> then <code>f(s) = 2</code> because the lexicographically smallest character is <code>&#39;c&#39;</code>, which has a frequency of 2.</p>

<p>You are given an array of strings <code>words</code> and another array of query strings <code>queries</code>. For each query <code>queries[i]</code>, count the <strong>number of words</strong> in <code>words</code> such that <code>f(queries[i])</code> &lt; <code>f(W)</code> for each <code>W</code> in <code>words</code>.</p>

<p>Return <em>an integer array </em><code>answer</code><em>, where each </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> On the first query we have f(&quot;cbd&quot;) = 1, f(&quot;zaaaz&quot;) = 3 so f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= queries.length &lt;= 2000</code></li>
	<li><code>1 &lt;= words.length &lt;= 2000</code></li>
	<li><code>1 &lt;= queries[i].length, words[i].length &lt;= 10</code></li>
	<li><code>queries[i][j]</code>, <code>words[i][j]</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-complete-tree-nodes/description" target="_blank" rel="noopener noreferrer">Count Complete Tree Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>

<p>According to <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>

<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type="code">O(n)</code>&nbsp;time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" style="width: 372px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> 6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The tree is guaranteed to be <strong>complete</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-good-triplets-in-an-array/description" target="_blank" rel="noopener noreferrer">Count Good Triplets in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> arrays <code>nums1</code> and <code>nums2</code> of length <code>n</code>, both of which are <strong>permutations</strong> of <code>[0, 1, ..., n - 1]</code>.</p>

<p>A <strong>good triplet</strong> is a set of <code>3</code> <strong>distinct</strong> values which are present in <strong>increasing order</strong> by position both in <code>nums1</code> and <code>nums2</code>. In other words, if we consider <code>pos1<sub>v</sub></code> as the index of the value <code>v</code> in <code>nums1</code> and <code>pos2<sub>v</sub></code> as the index of the value <code>v</code> in <code>nums2</code>, then a good triplet will be a set <code>(x, y, z)</code> where <code>0 &lt;= x, y, z &lt;= n - 1</code>, such that <code>pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z</sub></code> and <code>pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub></code>.</p>

<p>Return <em>the <strong>total number</strong> of good triplets</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,0,1,3], nums2 = [0,1,2,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
There are 4 triplets (x,y,z) such that pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z</sub>. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). 
Out of those triplets, only the triplet (0,1,3) satisfies pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub>. Hence, there is only 1 good triplet.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length == nums2.length</code></li>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= n - 1</code></li>
	<li><code>nums1</code> and <code>nums2</code> are permutations of <code>[0, 1, ..., n - 1]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-indexed-tree">Approach 1: Binary Indexed Tree</h3>
<h4 id="intuition">Intuition</h4>
<p>If <span class="math inline">\(i, j, k\)</span> satisfy <span class="math inline">\(0 \leq i < j < k < n\)</span> and <span class="math inline">\(0 \leq \textit{pos2}_{\textit{nums1}[i]} < \textit{pos2}_{\textit{nums1}[j]} < \textit{pos2}_{\textit{nums1}[k]} < n\)</span>, then <span class="math inline">\(\textit{nums1}[i]\)</span>, <span class="math inline">\(\textit{nums1}[j]\)</span>, <span class="math inline">\(\textit{nums1}[k]\)</span> form a good triplet. Because both <span class="math inline">\(\textit{nums1}\)</span> and <span class="math inline">\(\textit{nums2}\)</span> are permutations of <span class="math inline">\(0\)</span> to <span class="math inline">\(n-1\)</span>, we can count the number of good triplets by calculating the number of triplets <span class="math inline">\(i, j, k\)</span> that meet the conditions.</p>
<p>An array <span class="math inline">\(\textit{indexMapping}\)</span> is used to express the above relationship, where <span class="math inline">\(\textit{indexMapping}[i] = \textit{pos2}_{\textit{nums1}[i]}\)</span>, and <span class="math inline">\(\textit{indexMapping}\)</span> is also a permutation of <span class="math inline">\(0\)</span> to <span class="math inline">\(n-1\)</span>. When calculating the number of triplets <span class="math inline">\(i, j, k\)</span> that meet the conditions, we can first fix <span class="math inline">\(j\)</span>, then count how many numbers are less than <span class="math inline">\(\textit{indexMapping}[j]\)</span> in the <span class="math inline">\(\textit{indexMapping}\)</span> array to the left of index <span class="math inline">\(j\)</span>, and denote it as <span class="math inline">\(\textit{left}\)</span>. Next, count how many numbers are greater than <span class="math inline">\(\textit{indexMapping}[j]\)</span> to the right of index <span class="math inline">\(j\)</span>, and denote it as <span class="math inline">\(\textit{right}\)</span>. Thus, <span class="math inline">\(\textit{left}\times\textit{right}\)</span> represents the number of triplets with the middle element as <span class="math inline">\(j\)</span>. By traversing all <span class="math inline">\(j\)</span>, the answer can be calculated.</p>
<p>The above calculation process can be referred to <a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/">315. Count of Smaller Numbers After Self</a>, using a binary indexed tree to solve. The binary indexed tree can complete increment and prefix sum operations for a certain index in <span class="math inline">\(O(\log{n})\)</span> time. When applying the binary indexed tree, we need to traverse the values in <span class="math inline">\(\textit{indexMapping}\)</span> from small to large, and calculate the prefix sum for the current index <span class="math inline">\(\textit{pos}\)</span>, which represents how many numbers are less than <span class="math inline">\(\textit{indexMapping}[pos]\)</span> to the left of index <span class="math inline">\(pos\)</span>. We can also calculate how many numbers are greater than <span class="math inline">\(\textit{indexMapping}[pos]\)</span> to the right of index <span class="math inline">\(pos\)</span>, and then add <span class="math inline">\(1\)</span> to the value of the current index. Since we are traversing according to the value size, we need another array <span class="math inline">\(\textit{reversedIndexMapping}\)</span> to save the indices of each value in <span class="math inline">\(\textit{indexMapping}\)</span>. In the code, the variable <span class="math inline">\(\textit{indexMapping}\)</span> can be omitted. The result can be returned after the traversal is completed.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/CL98TQtb/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time complexity: <span class="math inline">\(O(n\times\log{n})\)</span>.</li>
</ul>
<p>The binary indexed tree requires <span class="math inline">\(O(\log{n})\)</span> for each query and update operation, and we need to perform query and update operations on each index of the array during traversal.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>The binary indexed tree requires <span class="math inline">\(O(n)\)</span> space.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description" target="_blank" rel="noopener noreferrer">Count Negative Numbers in a Sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> matrix <code>grid</code> which is sorted in non-increasing order both row-wise and column-wise, return <em>the number of <strong>negative</strong> numbers in</em> <code>grid</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> There are 8 negatives number in the matrix.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[3,2],[1,0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you find an <code>O(n + m)</code> solution?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-number-of-rectangles-containing-each-point/description" target="_blank" rel="noopener noreferrer">Count Number of Rectangles Containing Each Point</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>rectangles</code> where <code>rectangles[i] = [l<sub>i</sub>, h<sub>i</sub>]</code> indicates that <code>i<sup>th</sup></code> rectangle has a length of <code>l<sub>i</sub></code> and a height of <code>h<sub>i</sub></code>. You are also given a 2D integer array <code>points</code> where <code>points[j] = [x<sub>j</sub>, y<sub>j</sub>]</code> is a point with coordinates <code>(x<sub>j</sub>, y<sub>j</sub>)</code>.</p>

<p>The <code>i<sup>th</sup></code> rectangle has its <strong>bottom-left corner</strong> point at the coordinates <code>(0, 0)</code> and its <strong>top-right corner</strong> point at <code>(l<sub>i</sub>, h<sub>i</sub>)</code>.</p>

<p>Return<em> an integer array </em><code>count</code><em> of length </em><code>points.length</code><em> where </em><code>count[j]</code><em> is the number of rectangles that <strong>contain</strong> the </em><code>j<sup>th</sup></code><em> point.</em></p>

<p>The <code>i<sup>th</sup></code> rectangle <strong>contains</strong> the <code>j<sup>th</sup></code> point if <code>0 &lt;= x<sub>j</sub> &lt;= l<sub>i</sub></code> and <code>0 &lt;= y<sub>j</sub> &lt;= h<sub>i</sub></code>. Note that points that lie on the <strong>edges</strong> of a rectangle are also considered to be contained by that rectangle.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/example1.png" style="width: 300px; height: 509px;" />
<pre>
<strong>Input:</strong> rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]
<strong>Output:</strong> [2,1]
<strong>Explanation:</strong> 
The first rectangle contains no points.
The second rectangle contains only the point (2, 1).
The third rectangle contains the points (2, 1) and (1, 4).
The number of rectangles that contain the point (2, 1) is 2.
The number of rectangles that contain the point (1, 4) is 1.
Therefore, we return [2, 1].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/example2.png" style="width: 300px; height: 312px;" />
<pre>
<strong>Input:</strong> rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]
<strong>Output:</strong> [1,3]
<strong>Explanation:
</strong>The first rectangle contains only the point (1, 1).
The second rectangle contains only the point (1, 1).
The third rectangle contains the points (1, 3) and (1, 1).
The number of rectangles that contain the point (1, 3) is 1.
The number of rectangles that contain the point (1, 1) is 3.
Therefore, we return [1, 3].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rectangles.length, points.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>rectangles[i].length == points[j].length == 2</code></li>
	<li><code>1 &lt;= l<sub>i</sub>, x<sub>j</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= h<sub>i</sub>, y<sub>j</sub> &lt;= 100</code></li>
	<li>All the <code>rectangles</code> are <strong>unique</strong>.</li>
	<li>All the <code>points</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-occurrences-in-a-fully-sorted-matrix/1" target="_blank" rel="noopener noreferrer">Count Occurrences in a Fully Sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;"><span style="font-size: 14pt;">Given a sorted 2D matrix</span><strong style="font-size: 14pt;">&nbsp;mat</strong><span style="font-size: 14pt;">[][] of size&nbsp;</span><strong style="font-size: 14pt;">n x m&nbsp;</strong><span style="font-size: 14pt;">and</span><strong style="font-size: 14pt;">&nbsp;</strong><span style="font-size: 14pt;">a number&nbsp;</span><strong style="font-size: 14pt;">x.</strong><span style="font-size: 14pt;"> C</span><span style="font-size: 18.6667px;">ount the number of times <strong>x</strong> appears in the matrix.</span><br /><strong style="font-size: 14pt;">Note:</strong><span style="font-size: 14pt;">&nbsp;In a sorted matrix, each row is sorted in increasing order, and the first element of the&nbsp;</span><strong style="font-size: 14pt;">i</strong><sup style="font-size: 14pt;">th</sup><span style="font-size: 14pt;">&nbsp;row (</span><strong style="font-size: 14pt;">i</strong><span style="font-size: 14pt;">!=0) is greater than or equal to the last element of the (</span><strong style="font-size: 14pt;">i-1</strong><span style="font-size: 14pt;">)</span><sup style="font-size: 14pt;">th&nbsp;</sup><span style="font-size: 14pt;">row.</span></span><br style="font-size: 18px;" /><br /><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 3, 5], [6, 7, 8], [10, 10, 12]], x = 10
<strong>Output</strong>: 2
<strong>Explanation</strong>: The number 10 appears twice in the matrix at mat[2][0] and mat[2][1].
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 2, 4], [5, 6, 7], [8, 9, 10]], x = 3<br /><strong>Output</strong>: 0
<strong>Explanation</strong>: The number 3 is not present in the matrix at any position, so the result is 0.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[2, 5, 7], [7, 7, 7], [7, 8, 8]], x = 7</span><br /><span style="font-size: 14pt;"><strong>Output</strong>: 5
<strong>Explanation</strong>: The number 7 appears 5 times in the matrix at mat[0][2], mat[1][0], mat[1][1], mat[1][2] and mat[2][0].</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; n, m &le; 1000<br />1 &le; mat[i][j] &le; 10<sup>9</sup><br />1 &le; x &le; 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-of-range-sum/description" target="_blank" rel="noopener noreferrer">Count of Range Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and two integers <code>lower</code> and <code>upper</code>, return <em>the number of range sums that lie in</em> <code>[lower, upper]</code> <em>inclusive</em>.</p>

<p>Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and <code>j</code> inclusive, where <code>i &lt;= j</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,5,-1], lower = -2, upper = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0], lower = 0, upper = 0
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>
	<li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-of-smaller-numbers-after-self/description" target="_blank" rel="noopener noreferrer">Count of Smaller Numbers After Self</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return<em> an integer array </em><code>counts</code><em> where </em><code>counts[i]</code><em> is the number of smaller elements to the right of </em><code>nums[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,2,6,1]
<strong>Output:</strong> [2,1,1,0]
<strong>Explanation:</strong>
To the right of 5 there are <b>2</b> smaller elements (2 and 1).
To the right of 2 there is only <b>1</b> smaller element (1).
To the right of 6 there is <b>1</b> smaller element (1).
To the right of 1 there is <b>0</b> smaller element.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1]
<strong>Output:</strong> [0]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,-1]
<strong>Output:</strong> [0,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-of-nodes/description" target="_blank" rel="noopener noreferrer">Count Pairs Of Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected graph defined by an integer <code>n</code>, the number of nodes, and a 2D integer array <code>edges</code>, the edges in the graph, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an <strong>undirected</strong> edge between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>. You are also given an integer array <code>queries</code>.</p>

<p>Let <code>incident(a, b)</code> be defined as the <strong>number of edges</strong> that are connected to <strong>either</strong> node <code>a</code> or <code>b</code>.</p>

<p>The answer to the <code>j<sup>th</sup></code> query is the <strong>number of pairs</strong> of nodes <code>(a, b)</code> that satisfy <strong>both</strong> of the following conditions:</p>

<ul>
	<li><code>a &lt; b</code></li>
	<li><code>incident(a, b) &gt; queries[j]</code></li>
</ul>

<p>Return <em>an array </em><code>answers</code><em> such that </em><code>answers.length == queries.length</code><em> and </em><code>answers[j]</code><em> is the answer of the </em><code>j<sup>th</sup></code><em> query</em>.</p>

<p>Note that there can be <strong>multiple edges</strong> between the same two nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/winword_2021-06-08_00-58-39.png" style="width: 529px; height: 305px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
<strong>Output:</strong> [6,5]
<strong>Explanation:</strong> The calculations for incident(a, b) are shown in the table above.
The answers for each of the queries are as follows:
- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.
- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
<strong>Output:</strong> [10,10,9,8,6]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>0 &lt;= queries[j] &lt; edges.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/description" target="_blank" rel="noopener noreferrer">Count Pairs Whose Sum is Less than Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, return <em>the number of pairs</em> <code>(i, j)</code> <em>where</em> <code>0 &lt;= i &lt; j &lt; n</code> <em>and</em> <code>nums[i] + nums[j] &lt; target</code>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,1,2,3,1], target = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = 0 &lt; target
- (0, 2) since 0 &lt; 2 and nums[0] + nums[2] = 1 &lt; target 
- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = 0 &lt; target
Note that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-6,2,5,-2,-7,-1,3], target = -2
<strong>Output:</strong> 10
<strong>Explanation:</strong> There are 10 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = -4 &lt; target
- (0, 3) since 0 &lt; 3 and nums[0] + nums[3] = -8 &lt; target
- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = -13 &lt; target
- (0, 5) since 0 &lt; 5 and nums[0] + nums[5] = -7 &lt; target
- (0, 6) since 0 &lt; 6 and nums[0] + nums[6] = -3 &lt; target
- (1, 4) since 1 &lt; 4 and nums[1] + nums[4] = -5 &lt; target
- (3, 4) since 3 &lt; 4 and nums[3] + nums[4] = -9 &lt; target
- (3, 5) since 3 &lt; 5 and nums[3] + nums[5] = -3 &lt; target
- (4, 5) since 4 &lt; 5 and nums[4] + nums[5] = -8 &lt; target
- (4, 6) since 4 &lt; 6 and nums[4] + nums[6] = -4 &lt; target
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == n &lt;= 50</code></li>
	<li><code>-50 &lt;= nums[i], target &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-smaller-elements2214/1" target="_blank" rel="noopener noreferrer">Count Smaller elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr</strong> containing non-negative integers. Count and return an array&nbsp;<strong>res</strong> where <strong>res[i]</strong>&nbsp;denotes the number of smaller elements on right side of&nbsp;<strong>arr[i]</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [12, 1, 2, 3, 0, 11, 4]
<strong>Output:</strong> [6, 1, 1, 1, 0, 1, 0]
<strong>Explanation:</strong> There are 6 smaller elements right after 12. There is 1 smaller element right after 1. And so on.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 2, 3, 4, 5]
<strong>Output:</strong> [0, 0, 0, 0, 0]
<strong>Explanation:</strong> There are 0 smaller elements right after 1. There are 0 smaller elements right after 2. And so on.
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />0 &le; arr[i]<sub>&nbsp;&nbsp;</sub>&le; 10<sup>8</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-subarrays-with-score-less-than-k/description" target="_blank" rel="noopener noreferrer">Count Subarrays With Score Less Than K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>score</strong> of an array is defined as the <strong>product</strong> of its sum and its length.</p>

<ul>
	<li>For example, the score of <code>[1, 2, 3, 4, 5]</code> is <code>(1 + 2 + 3 + 4 + 5) * 5 = 75</code>.</li>
</ul>

<p>Given a positive integer array <code>nums</code> and an integer <code>k</code>, return <em>the <strong>number of non-empty subarrays</strong> of</em> <code>nums</code> <em>whose score is <strong>strictly less</strong> than</em> <code>k</code>.</p>

<p>A <strong>subarray</strong> is a contiguous sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,4,3,5], k = 10
<strong>Output:</strong> 6
<strong>Explanation:</strong>
The 6 subarrays having scores less than 10 are:
- [2] with score 2 * 1 = 2.
- [1] with score 1 * 1 = 1.
- [4] with score 4 * 1 = 4.
- [3] with score 3 * 1 = 3. 
- [5] with score 5 * 1 = 5.
- [2,1] with score (2 + 1) * 2 = 6.
Note that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1], k = 5
<strong>Output:</strong> 5
<strong>Explanation:</strong>
Every subarray except [1,1,1] has a score less than 5.
[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.
Thus, there are 5 subarrays having scores less than 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-sliding-window">Approach: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the definition of array scores in the question, and given that <span class="math inline">\(\textit{nums}\)</span> is an array of positive integers, for a subarray <span class="math inline">\([i, j]\)</span>, as the right endpoint <span class="math inline">\(j\)</span> is fixed, the sum of the subarray decreases and its length shortens with the increase of the left endpoint <span class="math inline">\(i\)</span>, so the score of the subarray monotonically decreases. If the score of the subarray <span class="math inline">\([i, j]\)</span> is less than <span class="math inline">\(k\)</span>, since the score is monotonically decreasing, then the score of the subarray <span class="math inline">\([p, j], i < p \leq j\)</span> is also less than <span class="math inline">\(k\)</span>.</p>
<p>Based on the above properties, we can use the sliding window method to solve the question. Starting from <span class="math inline">\(j = 0\)</span>, enumerate the right endpoint of the subarray and maintain a left endpoint <span class="math inline">\(i\)</span> (initially set to <span class="math inline">\(0\)</span>). For each <span class="math inline">\(j\)</span>:</p>
<ul>
<li>
<p>Expand window: Add <span class="math inline">\(\textit{nums}[j]\)</span> to the subarray sum corresponding to the current window <span class="math inline">\(\textit{total}\)</span>.</p>
</li>
<li>
<p>Shrink window: If the score of the corresponding subarray in the current window, <span class="math inline">\(\textit{total} \times (j - i + 1)\)</span>, is greater than or equal to <span class="math inline">\(k\)</span>, it indicates that the subarray does not meet the requirements, and therefore, the left endpoint <span class="math inline">\(i\)</span> needs to be moved to the right until the score is less than <span class="math inline">\(k\)</span>.</p>
</li>
<li>
<p>Count the number of subarrays: At this moment, the number of subarrays with <span class="math inline">\(j\)</span> as the right endpoint and a score less than <span class="math inline">\(k\)</span> is <span class="math inline">\(j - i + 1\)</span>, and it is accumulated into the final result <span class="math inline">\(\textit{res}\)</span>.</p>
</li>
</ul>
<p>After the enumeration, return the final result <span class="math inline">\(\textit{res}\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5CroPzAm/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <span class="math inline">\(\textit{nums}\)</span>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>We only need to traverse the array once.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<p>Only a few additional variables are needed.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-substrings-that-satisfy-k-constraint-ii/description" target="_blank" rel="noopener noreferrer">Count Substrings That Satisfy K-Constraint II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>binary</strong> string <code>s</code> and an integer <code>k</code>.</p>

<p>You are also given a 2D integer array <code>queries</code>, where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code>.</p>

<p>A <strong>binary string</strong> satisfies the <strong>k-constraint</strong> if <strong>either</strong> of the following conditions holds:</p>

<ul>
	<li>The number of <code>0</code>&#39;s in the string is at most <code>k</code>.</li>
	<li>The number of <code>1</code>&#39;s in the string is at most <code>k</code>.</li>
</ul>

<p>Return an integer array <code>answer</code>, where <code>answer[i]</code> is the number of <span data-keyword="substring-nonempty">substrings</span> of <code>s[l<sub>i</sub>..r<sub>i</sub>]</code> that satisfy the <strong>k-constraint</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;0001111&quot;, k = 2, queries = [[0,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[26]</span></p>

<p><strong>Explanation:</strong></p>

<p>For the query <code>[0, 6]</code>, all substrings of <code>s[0..6] = &quot;0001111&quot;</code> satisfy the k-constraint except for the substrings <code>s[0..5] = &quot;000111&quot;</code> and <code>s[0..6] = &quot;0001111&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;010101&quot;, k = 1, queries = [[0,5],[1,4],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[15,9,3]</span></p>

<p><strong>Explanation:</strong></p>

<p>The substrings of <code>s</code> with a length greater than 3 do not satisfy the k-constraint.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>1 &lt;= k &lt;= s.length</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i] == [l<sub>i</sub>, r<sub>i</sub>]</code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; s.length</code></li>
	<li>All queries are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-fair-pairs/description" target="_blank" rel="noopener noreferrer">Count the Number of Fair Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> and two integers <code>lower</code> and <code>upper</code>, return <em>the number of fair pairs</em>.</p>

<p>A pair <code>(i, j)</code> is <b>fair </b>if:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; n</code>, and</li>
	<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,7,4,4,5], lower = 3, upper = 6
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,7,9,2,5], lower = 11, upper = 11
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is a single fair pair: (2,3).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums.length == n</code></li>
	<li><code><font face="monospace">-10<sup>9</sup></font>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code><font face="monospace">-10<sup>9</sup>&nbsp;&lt;= lower &lt;= upper &lt;= 10<sup>9</sup></font></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have an array called <code>nums</code> with <code>n</code> elements, along with two integers, <code>lower</code> and <code>upper</code>. Our task is to find out how many pairs of indices <code>(i, j)</code> exist in the array such that the sum of the elements at these indices, <code>nums[i] + nums[j]</code>, falls between <code>lower</code> and <code>upper</code>. Plus, we need to make sure that <code>i</code> is less than <code>j</code>.</p>
<p>Given that the number of elements in the array can be as large as <span class="math inline">\(10^5\)</span>, we need to think about an efficient solution—something that works in linear or log-linear time.</p>
<p>If you're feeling stuck, it might help to look at <a href="https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/description/">this similar problem</a> before diving deeper.</p>
<p>Since we’re dealing with specific lower and upper bounds, it’s natural to think about using binary search. However, for binary search to be effective, we need to sort the array first. You might wonder if sorting will mess up our index requirements. The good news is that it won’t! Sorting the array allows us to find pairs easily because the order of addition doesn’t change the sum; that is, <code>nums[i] + nums[j]</code> is the same as <code>nums[j] + nums[i]</code>.</p>
<p>So, our goal is to count unique pairs where <code>i</code> is not equal to <code>j</code> while ensuring their sums fall within the specified range.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with binary search, please refer to our explore cards <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>We can iterate through the sorted array while keeping one element of the pair fixed. For each fixed element, we'll find out how many valid choices we have for the second element. Because the array is sorted, the first valid choice will give us a sum that is just greater than or equal to <code>lower</code>, and the last valid choice will yield a sum that is just less than or equal to <code>upper</code>. Since the sums increase steadily, all valid second elements will cluster together in the array.</p>
<p>To count the number of pairs with sums that fall within the range <code>[lower, upper]</code>, we can use a clever technique. First, we calculate how many pairs have sums that are less than <code>lower</code>. Then, we count how many pairs have sums that are less than <code>upper + 1</code>. By taking the difference between these two counts, we can easily determine how many pairs have sums within the desired range.</p>
<p>Now, how do we find the number of pairs for the lower limit using binary search? After fixing the first element <code>nums[i]</code>, the second element must be less than <code>lower - nums[i]</code> to keep the sum below <code>lower</code>. We can efficiently find how many elements meet this condition by performing a binary search in the array for values less than or equal to <code>lower - nums[i]</code>.</p>
<p>Similarly, we can find the number of elements that are less than or equal to <code>upper + 1 - nums[i]</code>. The difference between these two counts will give us the total number of valid pairs for that particular fixed element.</p>
<h4 id="algorithm">Algorithm</h4>
<blockquote>
<p>Note: The typical way to calculate the midpoint is <code>(left + right) / 2</code>. However, a safer approach is to use <code>left + (right - left) / 2</code>. While both formulas yield the same result, the second method is safer because it prevents overflow by ensuring that no value larger than <code>right</code> is stored. In contrast, the first method can lead to overflow if <code>left</code> and <code>right</code> are very large.</p>
</blockquote>
<p>Function - <code>lower_bound(nums, low, high, element)</code>:</p>
<ol>
<li>Initialize a loop that continues as long as <code>low</code> is less than or equal to <code>high</code>:
<ul>
<li>Calculate the middle index <code>mid</code> using the formula <code>low + (high - low) / 2</code>.</li>
<li>If <code>nums[mid]</code> is greater than or equal to <code>element</code>, adjust the <code>high</code> index to <code>mid - 1</code>.</li>
<li>Otherwise, adjust the <code>low</code> index to <code>mid + 1</code>.</li>
</ul>
</li>
<li>Return the <code>low</code> index after the loop ends, which represents the lower bound position.</li>
</ol>
<p>Main Function - <code>countFairPairs(nums, lower, upper)</code>:</p>
<ol>
<li>Sort the array <code>nums</code>.</li>
<li>Initialize a variable <code>ans</code> to 0, which will hold the count of valid pairs.</li>
<li>Iterate through each element in the sorted array using index <code>i</code>:
<ul>
<li>For each element <code>nums[i]</code>, determine the number of possible pairs with a sum less than <code>lower</code>:
<ul>
<li>Use <code>lower_bound</code> to find the index of the first element in the subarray <code>nums[i + 1]</code> to <code>nums[end]</code> that is greater than or equal to <code>lower - nums[i]</code>.</li>
</ul>
</li>
<li>Similarly, determine the number of possible pairs with a sum less than or equal to <code>upper</code>:
<ul>
<li>Use <code>lower_bound</code> to find the index of the first element in the subarray that is greater than or equal to <code>upper - nums[i] + 1</code>.</li>
</ul>
</li>
<li>The difference <code>high - low</code> gives the count of valid pairs with sums within the range <code>[lower, upper]</code> for the current element.</li>
<li>Update <code>ans</code> by adding the difference calculated.</li>
</ul>
</li>
<li>After iterating through all elements, return the value of <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/PtF5DvjT/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given <code>nums</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>Sorting the <code>nums</code> array takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>The loop iterates through each element of the sorted array and calls the <code>lower_bound</code> function twice, which itself takes <span class="math inline">\(O(logn)\)</span> time. Therefore, the overall time complexity for processing all <code>n</code> elements is <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Combining these, the total time complexity is: <span class="math inline">\(O(n \log n + n \log n)\)</span> = <span class="math inline">\(O(n \log n)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
<p>The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and  Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
</li>
</ul>
<blockquote>
<p>In this problem, we’re assuming it’s okay to sort the input to solve it. But in real-world scenarios, that might not always be the best approach. Sorting can change the original order of the input, which might be important in some cases where we have to use it later.</p>
</blockquote>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous solution, we noticed that when selecting the second element of our pair, it’s important to consider only those that are consecutive to the first element. This creates a “window” of valid choices. Specifically, this window starts from the index right after our chosen first element (which we can call <code>current index + 1</code>). We ignore elements before this index because they would lead to redundant pairs.</p>
<p>As we move to the next element in the array, we adjust this window. Since the new first element we’re considering is larger but we want the same target sum, the second element must now be smaller. This means we gradually shift the end of our window backward to focus on smaller values in the array.</p>
<p>To visualize this, we can use two pointers: <code>left</code> for the current element and <code>right</code> for the end of our window. The size of the window can be calculated with the formula <code>right - (left + 1) + 1</code>, which simplifies to <code>right - left</code>. As we progress through the array, we keep moving the <code>right</code> pointer back until we find that the sum of <code>nums[left] + nums[right]</code> is just below our target sum. For each index, we then add the size of this window to our result.</p>
<p>The difference between these two counts will give us the number of pairs that fall within our desired range.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Function - <code>lower_bound(nums, value)</code>:</p>
<ol>
<li>Initialize two pointers, <code>left</code> to 0 and <code>right</code> to the last index of <code>nums</code>.</li>
<li>Initialize a variable <code>result</code> to 0.</li>
<li>While <code>left</code> is less than <code>right</code>:
<ul>
<li>Calculate the sum of <code>nums[left]</code> and <code>nums[right]</code>.</li>
<li>If the sum is less than <code>value</code>:
<ul>
<li>Add the number of valid pairs <code>(right - left)</code> to <code>result</code>.</li>
<li>Increment <code>left</code> to consider the next element.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Decrement <code>right</code> to reduce the sum.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value of <code>result</code>.</li>
</ol>
<p>Main Function - <code>countFairPairs(nums, lower, upper)</code>:</p>
<ol>
<li>Sort the array <code>nums</code>.</li>
<li>Return the difference between the result of <code>lower_bound(nums, upper + 1)</code> and <code>lower_bound(nums, lower)</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/iidN9v9x/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given <code>nums</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>Sorting the <code>nums</code> array takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>The method lower_bound is called twice, but its complexity is <span class="math inline">\(O(n)\)</span> because it iterates through the entire array to count the valid pairs.</p>
<p>Thus, the overall time complexity is dominated by the sorting step, resulting in <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
<p>The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and  Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/description" target="_blank" rel="noopener noreferrer">Count the Number of Incremovable Subarrays I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <strong>positive</strong> integers <code>nums</code>.</p>

<p>A subarray of <code>nums</code> is called <strong>incremovable</strong> if <code>nums</code> becomes <strong>strictly increasing</strong> on removing the subarray. For example, the subarray <code>[3, 4]</code> is an incremovable subarray of <code>[5, 3, 4, 6, 7]</code> because removing this subarray changes the array <code>[5, 3, 4, 6, 7]</code> to <code>[5, 6, 7]</code> which is strictly increasing.</p>

<p>Return <em>the total number of <strong>incremovable</strong> subarrays of</em> <code>nums</code>.</p>

<p><strong>Note</strong> that an empty array is considered strictly increasing.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,5,7,8]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].
It can be shown that there are only 7 incremovable subarrays in nums.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,7,6,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-incremovable-subarrays-ii/description" target="_blank" rel="noopener noreferrer">Count the Number of Incremovable Subarrays II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <strong>positive</strong> integers <code>nums</code>.</p>

<p>A subarray of <code>nums</code> is called <strong>incremovable</strong> if <code>nums</code> becomes <strong>strictly increasing</strong> on removing the subarray. For example, the subarray <code>[3, 4]</code> is an incremovable subarray of <code>[5, 3, 4, 6, 7]</code> because removing this subarray changes the array <code>[5, 3, 4, 6, 7]</code> to <code>[5, 6, 7]</code> which is strictly increasing.</p>

<p>Return <em>the total number of <strong>incremovable</strong> subarrays of</em> <code>nums</code>.</p>

<p><strong>Note</strong> that an empty array is considered strictly increasing.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,5,7,8]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].
It can be shown that there are only 7 incremovable subarrays in nums.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,7,6,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/create-sorted-array-through-instructions/description" target="_blank" rel="noopener noreferrer">Create Sorted Array through Instructions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>instructions</code>, you are asked to create a sorted array from the elements in <code>instructions</code>. You start with an empty container <code>nums</code>. For each element from <strong>left to right</strong> in <code>instructions</code>, insert it into <code>nums</code>. The <strong>cost</strong> of each insertion is the <b>minimum</b> of the following:</p>

<ul>
	<li>The number of elements currently in <code>nums</code> that are <strong>strictly less than</strong> <code>instructions[i]</code>.</li>
	<li>The number of elements currently in <code>nums</code> that are <strong>strictly greater than</strong> <code>instructions[i]</code>.</li>
</ul>

<p>For example, if inserting element <code>3</code> into <code>nums = [1,2,3,5]</code>, the <strong>cost</strong> of insertion is <code>min(2, 1)</code> (elements <code>1</code> and <code>2</code> are less than <code>3</code>, element <code>5</code> is greater than <code>3</code>) and <code>nums</code> will become <code>[1,2,3,3,5]</code>.</p>

<p>Return <em>the <strong>total cost</strong> to insert all elements from </em><code>instructions</code><em> into </em><code>nums</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> instructions = [1,5,6,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 5 with cost min(1, 0) = 0, now nums = [1,5].
Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6].
Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].
The total cost is 0 + 0 + 0 + 1 = 1.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> instructions = [1,2,3,6,5,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 2 with cost min(1, 0) = 0, now nums = [1,2].
Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3].
Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].
Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].
Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].
The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> instructions = [1,3,3,3,2,4,2,1,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].
Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].
Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].
​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].
The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= instructions.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= instructions[i] &lt;= 10<sup>5</sup></code></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/data-stream-as-disjoint-intervals/description" target="_blank" rel="noopener noreferrer">Data Stream as Disjoint Intervals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>

<p>Implement the <code>SummaryRanges</code> class:</p>

<ul>
	<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>
	<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>
	<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;SummaryRanges&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
<strong>Output</strong>
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

<strong>Explanation</strong>
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // return [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>
	<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>
	<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-save-all-values-in-an-ordered-set">Approach 1: Save all values in an ordered set</h3>
<h4 id="intuition">Intuition</h4>
<p>The question asks to combine consecutive values into intervals, namely, if we have values of 1, 2, 3, and 4, we can make an interval that starts from 1 and ends at 4. If the data is sorted, we can easily iterate over it to find the intervals. A data structure is needed that allows us to insert elements while maintaining sorted order, otherwise we would need to sort the data every time we call <code>getIntervals</code>, which is expensive.</p>
<p>Java's TreeSet can do the work. The reason to use a TreeSet is that we can iterate on the values in it in the increasing order and elements can be added in <span class="math inline">\(O(\log{}n)\)</span>. In Python we can use SortedList and in C++ we can use the standard library's set. To find the intervals, we can look at each value and check whether it is adjacent to the previous one. If it is, we can build an interval, otherwise we need to start a new one.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Initialize a TreeSet equivalent data structure <code>values</code>.</p>
<h5 id="addnumint-value">addNum(int value)</h5>
<p>Simply add <code>value</code> into <code>values</code>. If your language's TreeSet equivalent allows duplicate values like Python's SortedList, you will also need to check that <code>value</code> does not already exist in <code>values</code> as duplicates will break the algorithm.</p>
<h5 id="getintervals">getIntervals</h5>
<ul>
<li>If <code>values</code> is empty, return an empty array.</li>
<li>Create an empty list of intervals.</li>
<li>Set <code>left = right = -1</code>. <code>left</code> represents the left bound of the current interval and <code>right</code> represents the right bound.</li>
<li>Iterate over <code>values</code>. At each iteration:
<ul>
<li>If <code>left &lt; 0</code> set <code>left = right = value</code></li>
<li>else if <code>value = right + 1</code>, set <code>right = value</code> as we can continue the current interval.</li>
<li>else, we cannot continue the current interval. Insert <code>[left, right]</code> into <code>intervals</code> and set <code>left = right = value</code> to start a new one.</li>
</ul>
</li>
<li>Insert <code>[left, right]</code> into <code>intervals</code> and return <code>intervals</code></li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/GQnYWXuW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the total number of calls of <code>addNum</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(log(N))\)</span> for addNum, <span class="math inline">\(O(N)\)</span> for getIntervals.</p>
<p>For <code>addNum</code>, we insert a value into the TreeSet which takes <span class="math inline">\(O(log(N))\)</span> time.<br />
For <code>getIntervals</code>, we iterate all the values in the TreeSet which is the same as traversing the whole tree, so the time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>This is just the space to save all the values in the TreeSet.</p>
</li>
</ul>
<h3 id="approach-2-maintain-all-the-intervals-in-ordered-map">Approach 2: Maintain all the intervals in ordered map</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of storing the values and then building the intervals every time we call <code>getIntervals</code>, we can just store the intervals themselves and update them every time we add a number.</p>
<p>In Java, we can maintain a TreeMap in which each entry represents an interval. The key and value are the left and right bounds of an interval. We still want to maintain the intervals in sorted order so that when we add a number, we can easily find the interval a number is close to and perform merges if necessary. <code>getIntervals</code> then returns all the entries in the TreeMap. In Python, SortedDict can be used. In C++, STL map can be used.</p>
<p>When we insert a <code>value</code>, there are 3 non-trivial cases (in all cases, blue represents existing intervals, red is the number being added, and cyan is the result after our operations):</p>
<ol>
<li>There is an interval with a right bound of <code>value - 1</code>.<br />
In this case, we need to merge the this interval and the <code>value</code>, namely change the the interval's right bound into <code>value</code>.</li>
</ol>
<center>
<img src="../Figures/352/352_Data_Stream_as_Disjoint_Intervals_2.png" width="500"/>
</center>
<br>
<ol start="2">
<li>There is an interval with a left bound of <code>value + 1</code>.<br />
In this case, we need to merge this interval and the <code>value</code>, namely change the interval's left bound into <code>value</code>.</li>
</ol>
<center>
<img src="../Figures/352/352_Data_Stream_as_Disjoint_Intervals_1.png" width="500"/>
</center>
<br>
<ol start="3">
<li>Both condition 1 and 2 are satisfied.<br />
This is the combination of the previous 2 cases. We should make a new interval which &quot;connects&quot; the two intervals and replace them with the new one.</li>
</ol>
<center>
<img src="../Figures/352/352_Data_Stream_as_Disjoint_Intervals_3.png" width="500"/>
</center>
<br>
<p>To be complete, there are 2 trivial cases as well:</p>
<ol>
<li>
<p>The <code>value</code> is already in the existing intervals.<br />
We do nothing.</p>
</li>
<li>
<p>All other cases.<br />
We need to insert a new interval [<code>value</code>, <code>value</code>].</p>
</li>
</ol>
<h4 id="algorithm-1">Algorithm</h4>
<p>Initialize a TreeMap equivalent data structure <code>intervals</code>.</p>
<h5 id="addnumint-value-1">addNum(int value)</h5>
<ul>
<li>Set <code>left = right = value</code>. These variables will represent the bounds of a new interval to be created.</li>
<li>Let <code>smallEntry</code> be the entry with the greatest key (left bound) no larger than <code>value</code> in <code>intervals</code>.</li>
<li>If <code>smallEntry</code> exists
<ul>
<li>Let <code>previous</code> be the value (right bound) in <code>smallEntry</code>, if <code>previous &gt;= value</code> then this is the first trivial case, so return.</li>
<li>If <code>previous == value - 1</code>, set <code>left</code> to the key (left bound) in <code>smallEntry</code>. This is the first non trivial case, so we will prepare a merge.</li>
</ul>
</li>
<li>Let <code>maxEntry</code> be the entry with the smallest key (left bound) larger than <code>value</code> in <code>intervals</code>.</li>
<li>If <code>maxEntry</code> exists and the key in it is <code>value + 1</code>, then this is the second non trivial case.
<ul>
<li>Set <code>right</code> to the value in <code>maxEntry</code>.</li>
<li>Remove the key <code>value + 1</code> from <code>intervals</code>.</li>
</ul>
</li>
<li>Insert <code>[left, right]</code> into <code>intervals</code>. All cases are covered here.</li>
</ul>
<ol>
<li>In the first case, we are updating the existing interval's entry since we set <code>left</code> to be that interval's key.</li>
<li>In the second case, we removed the old interval and are now adding a new one with the <code>right</code> bound set to be the removed interval's old <code>right</code> bound and <code>left</code> updated to <code>value</code>.</li>
<li>In the third case, we have done both of the above. We are replacing the interval on the left and deleting the interval on the right.</li>
<li>For the 2nd trivial case, we didn't modify any intervals and <code>[left, right] = [value, value]</code>.</li>
</ol>
<h5 id="getintervals-1">getIntervals</h5>
<p>Iterate over all the entries in <code>intervals</code> and return them in order.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/c7bDrXgu/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the total number of calls of <code>addNum</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(log(N))\)</span> for <code>addNum</code>, <span class="math inline">\(O(N)\)</span> for <code>getIntervals</code>.</p>
<p>For <code>addNum</code>, in the worst case, we remove 2 entries from the TreeMap and add 1 entry, the time complexity for each operation is <span class="math inline">\(O(log(N))\)</span>.<br />
For <code>getIntervals</code>, we iterate all the entries in the TreeMap which is the same as traversing the whole tree, so the time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>This is just the space to save all the intervals in the TreeMap.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/earliest-finish-time-for-land-and-water-rides-i/description" target="_blank" rel="noopener noreferrer">Earliest Finish Time for Land and Water Rides I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="143" data-start="53">You are given two categories of theme park attractions: <strong data-end="122" data-start="108">land rides</strong> and <strong data-end="142" data-start="127">water rides</strong>.</p>

<ul>
	<li data-end="163" data-start="147"><strong data-end="161" data-start="147">Land rides</strong>

	<ul>
		<li data-end="245" data-start="168"><code data-end="186" data-start="168">landStartTime[i]</code> &ndash; the earliest time the <code>i<sup>th</sup></code> land ride can be boarded.</li>
		<li data-end="306" data-start="250"><code data-end="267" data-start="250">landDuration[i]</code> &ndash; how long the <code>i<sup>th</sup></code> land ride lasts.</li>
	</ul>
	</li>
	<li><strong data-end="325" data-start="310">Water rides</strong>
	<ul>
		<li><code data-end="351" data-start="332">waterStartTime[j]</code> &ndash; the earliest time the <code>j<sup>th</sup></code> water ride can be boarded.</li>
		<li><code data-end="434" data-start="416">waterDuration[j]</code> &ndash; how long the <code>j<sup>th</sup></code> water ride lasts.</li>
	</ul>
	</li>
</ul>

<p data-end="569" data-start="476">A tourist must experience <strong data-end="517" data-start="502">exactly one</strong> ride from <strong data-end="536" data-start="528">each</strong> category, in <strong data-end="566" data-start="550">either order</strong>.</p>

<ul>
	<li data-end="641" data-start="573">A ride may be started at its opening time or <strong data-end="638" data-start="618">any later moment</strong>.</li>
	<li data-end="715" data-start="644">If a ride is started at time <code data-end="676" data-start="673">t</code>, it finishes at time <code data-end="712" data-start="698">t + duration</code>.</li>
	<li data-end="834" data-start="718">Immediately after finishing one ride the tourist may board the other (if it is already open) or wait until it opens.</li>
</ul>

<p data-end="917" data-start="836">Return the <strong data-end="873" data-start="847">earliest possible time</strong> at which the tourist can finish both rides.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [2,8], landDuration = [4,1], waterStartTime = [6], waterDuration = [3]</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul>
	<li data-end="181" data-start="145">Plan A (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="272" data-start="186">Start land ride 0 at time <code data-end="234" data-start="212">landStartTime[0] = 2</code>. Finish at <code data-end="271" data-start="246">2 + landDuration[0] = 6</code>.</li>
		<li data-end="392" data-start="277">Water ride 0 opens at time <code data-end="327" data-start="304">waterStartTime[0] = 6</code>. Start immediately at <code data-end="353" data-start="350">6</code>, finish at <code data-end="391" data-start="365">6 + waterDuration[0] = 9</code>.</li>
	</ul>
	</li>
	<li data-end="432" data-start="396">Plan B (water ride 0 &rarr; land ride 1):
	<ul>
		<li data-end="526" data-start="437">Start water ride 0 at time <code data-end="487" data-start="464">waterStartTime[0] = 6</code>. Finish at <code data-end="525" data-start="499">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="632" data-start="531">Land ride 1 opens at <code data-end="574" data-start="552">landStartTime[1] = 8</code>. Start at time <code data-end="593" data-start="590">9</code>, finish at <code data-end="631" data-start="605">9 + landDuration[1] = 10</code>.</li>
	</ul>
	</li>
	<li data-end="672" data-start="636">Plan C (land ride 1 &rarr; water ride 0):
	<ul>
		<li data-end="763" data-start="677">Start land ride 1 at time <code data-end="725" data-start="703">landStartTime[1] = 8</code>. Finish at <code data-end="762" data-start="737">8 + landDuration[1] = 9</code>.</li>
		<li data-end="873" data-start="768">Water ride 0 opened at <code data-end="814" data-start="791">waterStartTime[0] = 6</code>. Start at time <code data-end="833" data-start="830">9</code>, finish at <code data-end="872" data-start="845">9 + waterDuration[0] = 12</code>.</li>
	</ul>
	</li>
	<li data-end="913" data-start="877">Plan D (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1007" data-start="918">Start water ride 0 at time <code data-end="968" data-start="945">waterStartTime[0] = 6</code>. Finish at <code data-end="1006" data-start="980">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="1114" data-start="1012">Land ride 0 opened at <code data-end="1056" data-start="1034">landStartTime[0] = 2</code>. Start at time <code data-end="1075" data-start="1072">9</code>, finish at <code data-end="1113" data-start="1087">9 + landDuration[0] = 13</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1161" data-is-last-node="" data-is-only-node="" data-start="1116">Plan A gives the earliest finish time of 9.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [5], landDuration = [3], waterStartTime = [1], waterDuration = [10]</span></p>

<p><strong>Output:</strong> <span class="example-io">14</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul data-end="1589" data-start="1086">
	<li data-end="1124" data-start="1088">Plan A (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1219" data-start="1129">Start water ride 0 at time <code data-end="1179" data-start="1156">waterStartTime[0] = 1</code>. Finish at <code data-end="1218" data-start="1191">1 + waterDuration[0] = 11</code>.</li>
		<li data-end="1338" data-start="1224">Land ride 0 opened at <code data-end="1268" data-start="1246">landStartTime[0] = 5</code>. Start immediately at <code data-end="1295" data-start="1291">11</code> and finish at <code data-end="1337" data-start="1310">11 + landDuration[0] = 14</code>.</li>
	</ul>
	</li>
	<li data-end="1378" data-start="1342">Plan B (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="1469" data-start="1383">Start land ride 0 at time <code data-end="1431" data-start="1409">landStartTime[0] = 5</code>. Finish at <code data-end="1468" data-start="1443">5 + landDuration[0] = 8</code>.</li>
		<li data-end="1589" data-start="1474">Water ride 0 opened at <code data-end="1520" data-start="1497">waterStartTime[0] = 1</code>. Start immediately at <code data-end="1546" data-start="1543">8</code> and finish at <code data-end="1588" data-start="1561">8 + waterDuration[0] = 18</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1640" data-is-last-node="" data-is-only-node="" data-start="1591">Plan A provides the earliest finish time of 14.<strong>​​​​​​​</strong></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="38" data-start="16"><code data-end="36" data-start="16">1 &lt;= n, m &lt;= 100</code></li>
	<li data-end="93" data-start="41"><code data-end="91" data-start="41">landStartTime.length == landDuration.length == n</code></li>
	<li data-end="150" data-start="96"><code data-end="148" data-start="96">waterStartTime.length == waterDuration.length == m</code></li>
	<li data-end="237" data-start="153"><code data-end="235" data-start="153">1 &lt;= landStartTime[i], landDuration[i], waterStartTime[j], waterDuration[j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/earliest-finish-time-for-land-and-water-rides-ii/description" target="_blank" rel="noopener noreferrer">Earliest Finish Time for Land and Water Rides II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="143" data-start="53">You are given two categories of theme park attractions: <strong data-end="122" data-start="108">land rides</strong> and <strong data-end="142" data-start="127">water rides</strong>.</p>

<ul>
	<li data-end="163" data-start="147"><strong data-end="161" data-start="147">Land rides</strong>

	<ul>
		<li data-end="245" data-start="168"><code data-end="186" data-start="168">landStartTime[i]</code> &ndash; the earliest time the <code>i<sup>th</sup></code> land ride can be boarded.</li>
		<li data-end="306" data-start="250"><code data-end="267" data-start="250">landDuration[i]</code> &ndash; how long the <code>i<sup>th</sup></code> land ride lasts.</li>
	</ul>
	</li>
	<li><strong data-end="325" data-start="310">Water rides</strong>
	<ul>
		<li><code data-end="351" data-start="332">waterStartTime[j]</code> &ndash; the earliest time the <code>j<sup>th</sup></code> water ride can be boarded.</li>
		<li><code data-end="434" data-start="416">waterDuration[j]</code> &ndash; how long the <code>j<sup>th</sup></code> water ride lasts.</li>
	</ul>
	</li>
</ul>

<p data-end="569" data-start="476">A tourist must experience <strong data-end="517" data-start="502">exactly one</strong> ride from <strong data-end="536" data-start="528">each</strong> category, in <strong data-end="566" data-start="550">either order</strong>.</p>

<ul>
	<li data-end="641" data-start="573">A ride may be started at its opening time or <strong data-end="638" data-start="618">any later moment</strong>.</li>
	<li data-end="715" data-start="644">If a ride is started at time <code data-end="676" data-start="673">t</code>, it finishes at time <code data-end="712" data-start="698">t + duration</code>.</li>
	<li data-end="834" data-start="718">Immediately after finishing one ride the tourist may board the other (if it is already open) or wait until it opens.</li>
</ul>

<p data-end="917" data-start="836">Return the <strong data-end="873" data-start="847">earliest possible time</strong> at which the tourist can finish both rides.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [2,8], landDuration = [4,1], waterStartTime = [6], waterDuration = [3]</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul>
	<li data-end="181" data-start="145">Plan A (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="272" data-start="186">Start land ride 0 at time <code data-end="234" data-start="212">landStartTime[0] = 2</code>. Finish at <code data-end="271" data-start="246">2 + landDuration[0] = 6</code>.</li>
		<li data-end="392" data-start="277">Water ride 0 opens at time <code data-end="327" data-start="304">waterStartTime[0] = 6</code>. Start immediately at <code data-end="353" data-start="350">6</code>, finish at <code data-end="391" data-start="365">6 + waterDuration[0] = 9</code>.</li>
	</ul>
	</li>
	<li data-end="432" data-start="396">Plan B (water ride 0 &rarr; land ride 1):
	<ul>
		<li data-end="526" data-start="437">Start water ride 0 at time <code data-end="487" data-start="464">waterStartTime[0] = 6</code>. Finish at <code data-end="525" data-start="499">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="632" data-start="531">Land ride 1 opens at <code data-end="574" data-start="552">landStartTime[1] = 8</code>. Start at time <code data-end="593" data-start="590">9</code>, finish at <code data-end="631" data-start="605">9 + landDuration[1] = 10</code>.</li>
	</ul>
	</li>
	<li data-end="672" data-start="636">Plan C (land ride 1 &rarr; water ride 0):
	<ul>
		<li data-end="763" data-start="677">Start land ride 1 at time <code data-end="725" data-start="703">landStartTime[1] = 8</code>. Finish at <code data-end="762" data-start="737">8 + landDuration[1] = 9</code>.</li>
		<li data-end="873" data-start="768">Water ride 0 opened at <code data-end="814" data-start="791">waterStartTime[0] = 6</code>. Start at time <code data-end="833" data-start="830">9</code>, finish at <code data-end="872" data-start="845">9 + waterDuration[0] = 12</code>.</li>
	</ul>
	</li>
	<li data-end="913" data-start="877">Plan D (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1007" data-start="918">Start water ride 0 at time <code data-end="968" data-start="945">waterStartTime[0] = 6</code>. Finish at <code data-end="1006" data-start="980">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="1114" data-start="1012">Land ride 0 opened at <code data-end="1056" data-start="1034">landStartTime[0] = 2</code>. Start at time <code data-end="1075" data-start="1072">9</code>, finish at <code data-end="1113" data-start="1087">9 + landDuration[0] = 13</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1161" data-is-last-node="" data-is-only-node="" data-start="1116">Plan A gives the earliest finish time of 9.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [5], landDuration = [3], waterStartTime = [1], waterDuration = [10]</span></p>

<p><strong>Output:</strong> <span class="example-io">14</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul data-end="1589" data-start="1086">
	<li data-end="1124" data-start="1088">Plan A (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1219" data-start="1129">Start water ride 0 at time <code data-end="1179" data-start="1156">waterStartTime[0] = 1</code>. Finish at <code data-end="1218" data-start="1191">1 + waterDuration[0] = 11</code>.</li>
		<li data-end="1338" data-start="1224">Land ride 0 opened at <code data-end="1268" data-start="1246">landStartTime[0] = 5</code>. Start immediately at <code data-end="1295" data-start="1291">11</code> and finish at <code data-end="1337" data-start="1310">11 + landDuration[0] = 14</code>.</li>
	</ul>
	</li>
	<li data-end="1378" data-start="1342">Plan B (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="1469" data-start="1383">Start land ride 0 at time <code data-end="1431" data-start="1409">landStartTime[0] = 5</code>. Finish at <code data-end="1468" data-start="1443">5 + landDuration[0] = 8</code>.</li>
		<li data-end="1589" data-start="1474">Water ride 0 opened at <code data-end="1520" data-start="1497">waterStartTime[0] = 1</code>. Start immediately at <code data-end="1546" data-start="1543">8</code> and finish at <code data-end="1588" data-start="1561">8 + waterDuration[0] = 18</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1640" data-is-last-node="" data-is-only-node="" data-start="1591">Plan A provides the earliest finish time of 14.<strong>​​​​​​​</strong></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="38" data-start="16"><code data-end="36" data-start="16">1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="93" data-start="41"><code data-end="91" data-start="41">landStartTime.length == landDuration.length == n</code></li>
	<li data-end="150" data-start="96"><code data-end="148" data-start="96">waterStartTime.length == waterDuration.length == m</code></li>
	<li data-end="237" data-start="153"><code data-end="235" data-start="153">1 &lt;= landStartTime[i], landDuration[i], waterStartTime[j], waterDuration[j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/earliest-second-to-mark-indices-i/description" target="_blank" rel="noopener noreferrer">Earliest Second to Mark Indices I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>1-indexed</strong> integer arrays, <code>nums</code> and, <code>changeIndices</code>, having lengths <code>n</code> and <code>m</code>, respectively.</p>

<p>Initially, all indices in <code>nums</code> are unmarked. Your task is to mark <strong>all</strong> indices in <code>nums</code>.</p>

<p>In each second, <code>s</code>, in order from <code>1</code> to <code>m</code> (<strong>inclusive</strong>), you can perform <strong>one</strong> of the following operations:</p>

<ul>
	<li>Choose an index <code>i</code> in the range <code>[1, n]</code> and <strong>decrement</strong> <code>nums[i]</code> by <code>1</code>.</li>
	<li>If <code>nums[changeIndices[s]]</code> is <strong>equal</strong> to <code>0</code>, <strong>mark</strong> the index <code>changeIndices[s]</code>.</li>
	<li>Do nothing.</li>
</ul>

<p>Return <em>an integer denoting the <strong>earliest second</strong> in the range </em><code>[1, m]</code><em> when <strong>all</strong> indices in </em><code>nums</code><em> can be marked by choosing operations optimally, or </em><code>-1</code><em> if it is impossible.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]
<strong>Output:</strong> 8
<strong>Explanation:</strong> In this example, we have 8 seconds. The following operations can be performed to mark all indices:
Second 1: Choose index 1 and decrement nums[1] by one. nums becomes [1,2,0].
Second 2: Choose index 1 and decrement nums[1] by one. nums becomes [0,2,0].
Second 3: Choose index 2 and decrement nums[2] by one. nums becomes [0,1,0].
Second 4: Choose index 2 and decrement nums[2] by one. nums becomes [0,0,0].
Second 5: Mark the index changeIndices[5], which is marking index 3, since nums[3] is equal to 0.
Second 6: Mark the index changeIndices[6], which is marking index 2, since nums[2] is equal to 0.
Second 7: Do nothing.
Second 8: Mark the index changeIndices[8], which is marking index 1, since nums[1] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 8th second.
Hence, the answer is 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3], changeIndices = [1,1,1,2,1,1,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> In this example, we have 7 seconds. The following operations can be performed to mark all indices:
Second 1: Choose index 2 and decrement nums[2] by one. nums becomes [1,2].
Second 2: Choose index 2 and decrement nums[2] by one. nums becomes [1,1].
Second 3: Choose index 2 and decrement nums[2] by one. nums becomes [1,0].
Second 4: Mark the index changeIndices[4], which is marking index 2, since nums[2] is equal to 0.
Second 5: Choose index 1 and decrement nums[1] by one. nums becomes [0,0].
Second 6: Mark the index changeIndices[6], which is marking index 1, since nums[1] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 6th second.
Hence, the answer is 6.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1], changeIndices = [2,2,2]
<strong>Output:</strong> -1
<strong>Explanation:</strong> In this example, it is impossible to mark all indices because index 1 isn&#39;t in changeIndices.
Hence, the answer is -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= m == changeIndices.length &lt;= 2000</code></li>
	<li><code>1 &lt;= changeIndices[i] &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/earliest-second-to-mark-indices-ii/description" target="_blank" rel="noopener noreferrer">Earliest Second to Mark Indices II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>1-indexed</strong> integer arrays, <code>nums</code> and, <code>changeIndices</code>, having lengths <code>n</code> and <code>m</code>, respectively.</p>

<p>Initially, all indices in <code>nums</code> are unmarked. Your task is to mark <strong>all</strong> indices in <code>nums</code>.</p>

<p>In each second, <code>s</code>, in order from <code>1</code> to <code>m</code> (<strong>inclusive</strong>), you can perform <strong>one</strong> of the following operations:</p>

<ul>
	<li>Choose an index <code>i</code> in the range <code>[1, n]</code> and <strong>decrement</strong> <code>nums[i]</code> by <code>1</code>.</li>
	<li>Set <code>nums[changeIndices[s]]</code> to any <strong>non-negative</strong> value.</li>
	<li>Choose an index <code>i</code> in the range <code>[1, n]</code>, where <code>nums[i]</code> is <strong>equal</strong> to <code>0</code>, and <strong>mark</strong> index <code>i</code>.</li>
	<li>Do nothing.</li>
</ul>

<p>Return <em>an integer denoting the <strong>earliest second</strong> in the range </em><code>[1, m]</code><em> when <strong>all</strong> indices in </em><code>nums</code><em> can be marked by choosing operations optimally, or </em><code>-1</code><em> if it is impossible.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3]
<strong>Output:</strong> 6
<strong>Explanation:</strong> In this example, we have 7 seconds. The following operations can be performed to mark all indices:
Second 1: Set nums[changeIndices[1]] to 0. nums becomes [0,2,3].
Second 2: Set nums[changeIndices[2]] to 0. nums becomes [0,2,0].
Second 3: Set nums[changeIndices[3]] to 0. nums becomes [0,0,0].
Second 4: Mark index 1, since nums[1] is equal to 0.
Second 5: Mark index 2, since nums[2] is equal to 0.
Second 6: Mark index 3, since nums[3] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 6th second.
Hence, the answer is 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2]
<strong>Output:</strong> 7
<strong>Explanation:</strong> In this example, we have 8 seconds. The following operations can be performed to mark all indices:
Second 1: Mark index 1, since nums[1] is equal to 0.
Second 2: Mark index 2, since nums[2] is equal to 0.
Second 3: Decrement index 4 by one. nums becomes [0,0,1,1].
Second 4: Decrement index 4 by one. nums becomes [0,0,1,0].
Second 5: Decrement index 3 by one. nums becomes [0,0,0,0].
Second 6: Mark index 3, since nums[3] is equal to 0.
Second 7: Mark index 4, since nums[4] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 7th second.
Hence, the answer is 7.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], changeIndices = [1,2,3]
<strong>Output:</strong> -1
<strong>Explanation: </strong>In this example, it can be shown that it is impossible to mark all indices, as we don&#39;t have enough seconds. 
Hence, the answer is -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 5000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= m == changeIndices.length &lt;= 5000</code></li>
	<li><code>1 &lt;= changeIndices[i] &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/escape-the-spreading-fire/description" target="_blank" rel="noopener noreferrer">Escape the Spreading Fire</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code> which represents a field. Each cell has one of three values:</p>

<ul>
	<li><code>0</code> represents grass,</li>
	<li><code>1</code> represents fire,</li>
	<li><code>2</code> represents a wall that you and fire cannot pass through.</li>
</ul>

<p>You are situated in the top-left cell, <code>(0, 0)</code>, and you want to travel to the safehouse at the bottom-right cell, <code>(m - 1, n - 1)</code>. Every minute, you may move to an <strong>adjacent</strong> grass cell. <strong>After</strong> your move, every fire cell will spread to all <strong>adjacent</strong> cells that are not walls.</p>

<p>Return <em>the <strong>maximum</strong> number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse</em>. If this is impossible, return <code>-1</code>. If you can <strong>always</strong> reach the safehouse regardless of the minutes stayed, return <code>10<sup>9</sup></code>.</p>

<p>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.</p>

<p>A cell is <strong>adjacent</strong> to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg" style="width: 650px; height: 404px;" />
<pre>
<strong>Input:</strong> grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The figure above shows the scenario where you stay in the initial position for 3 minutes.
You will still be able to safely reach the safehouse.
Staying for more than 3 minutes will not allow you to safely reach the safehouse.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg" style="width: 515px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The figure above shows the scenario where you immediately move towards the safehouse.
Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.
Thus, -1 is returned.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg" style="width: 174px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0],[2,2,0],[1,2,0]]
<strong>Output:</strong> 1000000000
<strong>Explanation:</strong> The figure above shows the initial grid.
Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.
Thus, 10<sup>9</sup> is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 300</code></li>
	<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/fair-candy-swap/description" target="_blank" rel="noopener noreferrer">Fair Candy Swap</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob have a different total number of candies. You are given two integer arrays <code>aliceSizes</code> and <code>bobSizes</code> where <code>aliceSizes[i]</code> is the number of candies of the <code>i<sup>th</sup></code> box of candy that Alice has and <code>bobSizes[j]</code> is the number of candies of the <code>j<sup>th</sup></code> box of candy that Bob has.</p>

<p>Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.</p>

<p>Return a<em>n integer array </em><code>answer</code><em> where </em><code>answer[0]</code><em> is the number of candies in the box that Alice must exchange, and </em><code>answer[1]</code><em> is the number of candies in the box that Bob must exchange</em>. If there are multiple answers, you may <strong>return any</strong> one of them. It is guaranteed that at least one answer exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> aliceSizes = [1,1], bobSizes = [2,2]
<strong>Output:</strong> [1,2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> aliceSizes = [1,2], bobSizes = [2,3]
<strong>Output:</strong> [1,2]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> aliceSizes = [2], bobSizes = [1,3]
<strong>Output:</strong> [2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= aliceSizes.length, bobSizes.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 10<sup>5</sup></code></li>
	<li>Alice and Bob have a different total number of candies.</li>
	<li>There will be at least one valid answer for the given input.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/fill-the-tank3026/1" target="_blank" rel="noopener noreferrer">Fill the Tank</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">In a city,&nbsp;<strong>N</strong> water tanks are connected by pipeline(As a tree) where the <strong>ith</strong> tank has a capacity <strong>cap[i]</strong>. The <strong>ith </strong>element of the given <strong>Edge</strong> array of length <strong>N-1</strong> represents that there is a pipeline between <strong>Edge[i][0]</strong> and <strong>Edge[i][1]</strong> tank.&nbsp;Since people working at the city corporation are lazy they usually select one of the tank and pour complete amount of water into it, <strong>when the tank is filled, the excess water evenly flows to the connected tanks.</strong> The head of city corporation has instructed to <strong>pour minimum amount of water into the selected tank so that all other tank is filled</strong>. As the labours of the corporation are not intelligent enough to figure out the minimum amount of water required to fill all the tanks they have asked your help. Also Maximum amount of water available with city corporation is 10<sup>18</sup>.</span></p>

<p><span style="font-size:18px"><strong>NOTE</strong>: If the tank if full, the water flows to all of its connected tanks except the tank from which the water had come to it. i.e, to all tanks except the source for that particular tank. If it has no option to flow the water is considered to be wasted.<strong> S</strong> is the source tank.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
N = 4 and S = 1
Edges = [[1, 2], [1, 3], [2, 4]]
Cap = [1, 1, 1, 1]
<strong>Output:</strong>&nbsp;5
<strong>Explanation</strong>:
Initially 5 unit of water is poured into 
tank 1. 2 unit of it flows to tank 2 <strong>and</strong> 
2 unit of it flows into tank 3. From 2 
unit of water in tank 2, 1 unit flows into 
tank 4 <strong>and</strong> 1 unit from tank 3 is wasted.
<img alt="" src="https://contribute.geeksforgeeks.org/wp-content/uploads/fill-the-tank.jpg" style="height:500px; width:667px" />

</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 3 and S = 2
Edges = [[1, 2], [2, 3]]
Cap = [1, 1, 1]
<strong>Output: </strong>3
</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>minimum_amount()</strong>&nbsp;which takes an integer <strong>N</strong>, an&nbsp;integer&nbsp;<strong>S</strong>, 2-d array <strong>Edges</strong>, and an array <strong>Cap</strong>&nbsp;of length&nbsp;N as input parameters and returns the minimum amount of water required to fill all the tanks. If it is not possible to fill all the tanks print -1.<br />
<br />
<strong>Expected Time Complexity:</strong> O(N*log(S))<br />
<strong>Expected Auxiliary Space:</strong> O(1)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n &le; 100000<br />
1&nbsp;&le; s,u,v &le; n<br />
1 &le; capacity of each tank &le; 1000000007</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-peak-element-ii/description" target="_blank" rel="noopener noreferrer">Find a Peak Element II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>peak</strong> element in a 2D grid is an element that is <strong>strictly greater</strong> than all of its <strong>adjacent </strong>neighbors to the left, right, top, and bottom.</p>

<p>Given a <strong>0-indexed</strong> <code>m x n</code> matrix <code>mat</code> where <strong>no two adjacent cells are equal</strong>, find <strong>any</strong> peak element <code>mat[i][j]</code> and return <em>the length 2 array </em><code>[i,j]</code>.</p>

<p>You may assume that the entire matrix is surrounded by an <strong>outer perimeter</strong> with the value <code>-1</code> in each cell.</p>

<p>You must write an algorithm that runs in <code>O(m log(n))</code> or <code>O(n log(m))</code> time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/1.png" style="width: 206px; height: 209px;" /></p>

<pre>
<strong>Input:</strong> mat = [[1,4],[3,2]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong>&nbsp;Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/07/3.png" style="width: 254px; height: 257px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[10,20,15],[21,30,14],[7,16,32]]
<strong>Output:</strong> [1,1]
<strong>Explanation:</strong>&nbsp;Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
	<li>No two adjacent cells are equal.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/description" target="_blank" rel="noopener noreferrer">Find a Value of a Mysterious Function Closest to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><img alt="" src="https://assets.leetcode.com/uploads/2020/07/09/change.png" style="width: 635px; height: 312px;" /></p>

<p>Winston was given the above mysterious function <code>func</code>. He has an integer array <code>arr</code> and an integer <code>target</code> and he wants to find the values <code>l</code> and <code>r</code> that make the value <code>|func(arr, l, r) - target|</code> minimum possible.</p>

<p>Return <em>the minimum possible value</em> of <code>|func(arr, l, r) - target|</code>.</p>

<p>Notice that <code>func</code> should be called with the values <code>l</code> and <code>r</code> where <code>0 &lt;= l, r &lt; arr.length</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [9,12,3,7,15], target = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1000000,1000000,1000000], target = 1
<strong>Output:</strong> 999999
<strong>Explanation:</strong> Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,4,8,16], target = 0
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>0 &lt;= target &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-i/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 10</code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-building-where-alice-and-bob-can-meet/description" target="_blank" rel="noopener noreferrer">Find Building Where Alice and Bob Can Meet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>heights</code> of positive integers, where <code>heights[i]</code> represents the height of the <code>i<sup>th</sup></code> building.</p>

<p>If a person is in building <code>i</code>, they can move to any other building <code>j</code> if and only if <code>i &lt; j</code> and <code>heights[i] &lt; heights[j]</code>.</p>

<p>You are also given another array <code>queries</code> where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>. On the <code>i<sup>th</sup></code> query, Alice is in building <code>a<sub>i</sub></code> while Bob is in building <code>b<sub>i</sub></code>.</p>

<p>Return <em>an array</em> <code>ans</code> <em>where</em> <code>ans[i]</code> <em>is <strong>the index of the leftmost building</strong> where Alice and Bob can meet on the</em> <code>i<sup>th</sup></code> <em>query</em>. <em>If Alice and Bob cannot move to a common building on query</em> <code>i</code>, <em>set</em> <code>ans[i]</code> <em>to</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
<strong>Output:</strong> [2,5,-1,5,2]
<strong>Explanation:</strong> In the first query, Alice and Bob can move to building 2 since heights[0] &lt; heights[2] and heights[1] &lt; heights[2]. 
In the second query, Alice and Bob can move to building 5 since heights[0] &lt; heights[5] and heights[3] &lt; heights[5]. 
In the third query, Alice cannot meet Bob since Alice cannot move to any other building.
In the fourth query, Alice and Bob can move to building 5 since heights[3] &lt; heights[5] and heights[4] &lt; heights[5].
In the fifth query, Alice and Bob are already in the same building.  
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
<strong>Output:</strong> [7,6,-1,4,6]
<strong>Explanation:</strong> In the first query, Alice can directly move to Bob&#39;s building since heights[0] &lt; heights[7].
In the second query, Alice and Bob can move to building 6 since heights[3] &lt; heights[6] and heights[5] &lt; heights[6].
In the third query, Alice cannot meet Bob since Bob cannot move to any other building.
In the fourth query, Alice and Bob can move to building 4 since heights[3] &lt; heights[4] and heights[0] &lt; heights[4].
In the fifth query, Alice can directly move to Bob&#39;s building since heights[1] &lt; heights[6].
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= heights.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= heights.length - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>heights</code> and an array of pairs <code>queries</code>, where each pair is of the form <span class="math inline">\([a_i, b_i]\)</span>, representing the positions of Alice and Bob at indices <code>i</code> and <code>j</code>, respectively. For each query, the task is to find the closest value to the right in the <code>heights</code> array that is greater than the <code>heights</code> at both the given positions.</p>
<p>In other words, given indices <code>i</code> and <code>j</code>, we need to find the first value in the <code>heights</code> array that is greater than the values at <code>heights[i]</code> and <code>heights[j]</code>. If no such value exists, return -1.</p>
<hr />
<h3 id="approach-1-monotonic-stack">Approach 1: Monotonic Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Let’s start by breaking down the problem into simpler terms. Suppose <code>queries</code> only contained single integer indices. The goal would then be to find, for each index, the first building to the right in the <code>heights</code> array that is taller than the building at that index. Instead of scanning the array repeatedly for each query, we can preprocess the <code>heights</code> array to store this &quot;next taller building&quot; information in advance.</p>
<p>The key insight here is that for each building, the next taller building to its right depends only on the heights of the buildings that come after it. Using a monotonic stack, we can compute this efficiently. By traversing the <code>heights</code> array from right to left, we maintain a stack of indices in decreasing order of heights. For the current building, any shorter or equal buildings already in the stack cannot be the answer, so we remove them. If the stack is not empty, the top element gives the position of the next taller building. If the stack is empty, it means no taller building exists to the right, so we store <code>-1</code>. This preprocessing step allows us to handle single queries in constant time. For a better understanding of this idea, you can refer to <a href="https://leetcode.com/problems/next-greater-element-ii/">Next Greater Element - II</a>, which applies a similar technique.</p>
<p>Now, let’s extend this idea to handle queries that are pairs of values. In this scenario, the task is to find the first height to the right in the <code>heights</code> array that is greater than both values in each pair. Here the key realization is that the answer for a pair depends on the larger of the two values since a building must be taller than both. This simplifies the problem by reducing it to a comparison with a single threshold for each query.</p>
<p>While traversing the <code>heights</code> array, we use a monotonic stack to maintain all elements greater than the current height, with the nearest greater height at the top of the stack. When processing a query, the stack already contains all elements greater than the current height.</p>
<p>For each query pair, we use binary search on the stack to quickly find the first element greater than the larger value in the pair. This ensures that each query is processed in <span class="math inline">\(O(\log n)\)</span> time.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main function - <code>leftmostBuildingQueries(heights, queries)</code></p>
<ol>
<li>Create a list <code>newQueries</code> where each index stores the list of queries that require this index as the maximum index of the query pair. Each query is stored as a pair containing the required height (<code>heights[a]</code>) and the query index.</li>
<li>Initialize a monotonic stack <code>monoStack</code> to keep track of building heights and their indices in decreasing order of height while iterating from right to left in the <code>heights</code> array.</li>
<li>Initialize an array <code>result</code> to store the answers for each query, with all elements initially set to <code>-1</code>.</li>
<li>Iterate over the <code>queries</code>:
<ul>
<li>For each query, extract the two indices <code>a</code> and <code>b</code>.</li>
<li>If <code>a &gt; b</code>, swap the indices to ensure <code>a &lt;= b</code>.</li>
<li>If <code>heights[b] &gt; heights[a]</code> or <code>a == b</code>, set <code>result[currQuery] = b</code>.</li>
<li>Otherwise, add the query to <code>newQueries[b]</code> with its required height (<code>heights[a]</code>) and the query index.</li>
</ul>
</li>
<li>Iterate over the indices of the <code>heights</code> array from right to left:
<ul>
<li>For each query stored at the current index in <code>newQueries</code>, use binary search on the <code>monoStack</code> to find the first building with a height greater than the query's required height. If such a building exists, set the result for the query to the index of this building.</li>
<li>Remove all elements from the top of the <code>monoStack</code> where the height is less than or equal to the current height, as they are no longer relevant.</li>
<li>Push the current height and index onto the <code>monoStack</code>.</li>
</ul>
</li>
<li>Return the <code>result</code> array.</li>
</ol>
<p>Helper Binary Search function - <code>search(height, monoStack)</code></p>
<ol>
<li>Initialize two pointers <code>left = 0</code> and <code>right = size of monoStack - 1</code>. Set a variable <code>ans = -1</code> to store the search result.</li>
<li>Perform a binary search:
<ul>
<li>Calculate <code>mid = (left + right) / 2</code>.</li>
<li>If the height at <code>monoStack[mid]</code> is greater than the required height:
<ul>
<li>Update <code>ans = max(ans, mid)</code> and set <code>left = mid + 1</code>.</li>
</ul>
</li>
<li>Otherwise, set <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>, which will be the index of the first building with a height greater than the required height. If no such building exists, <code>ans</code> remains <code>-1</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AFfMGimL/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>heights</code> and <span class="math inline">\(q\)</span> be the number of queries in the <code>queries</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \cdot \log n + n)\)</span></p>
<p>The algorithm  processes each query using binary search on the monotonic stack, which takes <span class="math inline">\(O(\log n)\)</span> per query. With <span class="math inline">\(q\)</span> queries, the total query processing time is <span class="math inline">\(O(q \cdot \log n)\)</span>. Apart from this, we also iterate through the <code>heights</code> and <code>queries</code> arrays, that takes <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(q)\)</span> time, respectively.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(q \cdot \log n + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The algorithm uses a monotonic stack to store building indices, requiring <span class="math inline">\(O(n)\)</span> space. It also stores queries in the <code>newQueries</code> array and results in the <code>result</code> array, each taking <span class="math inline">\(O(q)\)</span> space.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we calculated the answer using a monotonic stack. Each query asks for the closest index to the right with a value greater than both elements in the query pair. Instead of processing each query one at a time, we can optimize by checking, for each index in the <code>heights</code> array, if it can serve as the answer for any query.</p>
<p>To do this efficiently, we can iterate through the <code>heights</code> array from left to right. For each index, we look for query pairs where both indices are smaller than the current index, and both values in the pair are smaller than the value at the current index. To make this process faster, we prioritize assigning answers to the smallest query pairs first.</p>
<p>By maintaining the query pairs sorted based on their maximum value and index up to the current position, we can process them more efficiently.</p>
<p>To implement this idea, we process the <code>heights</code> array while managing the queries by storing them in a 2D array of arrays, where each subarray holds the queries for the corresponding building.</p>
<p>We begin by sorting and mapping the queries to track the index and values that we need. Using a priority queue, we store queries based on their maximum value and index. This helps us quickly retrieve the smallest index for processing.</p>
<p>As we move through the <code>heights</code> array, we pop the queries from the queue. For each query, if the current index is greater than both indices of the query, we assign the current index as the answer and store it. We also check if new queries, whose maximum index matches the current one, should be added to the queue for future processing.</p>
<p>This allows us to handle queries without reprocessing them repeatedly.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>storeQueries</code> as a 2D array of arrays to store queries for each building.</p>
</li>
<li>
<p>Initialize <code>maxIndex</code> as a priority queue to track the queries that need to be answered based on building heights.</p>
</li>
<li>
<p>Initialize <code>result</code> as an array of <code>-1</code> to store the answers for each query.</p>
</li>
<li>
<p>Loop through each query:</p>
<ul>
<li>For each query <code>(a, b)</code>:
<ul>
<li>If the height of building <code>a</code> is less than building <code>b</code> and <code>a</code> is smaller than <code>b</code>, set <code>result[currQuery]</code> to <code>b</code> (building <code>b</code> is the answer).</li>
<li>If the height of building <code>a</code> is greater than building <code>b</code> and <code>a</code> is greater than <code>b</code>, set <code>result[currQuery]</code> to <code>a</code> (building <code>a</code> is the answer).</li>
<li>If <code>a</code> is equal to <code>b</code>, set <code>result[currQuery]</code> to <code>a</code> (both are the same building).</li>
<li>Otherwise, store the query in <code>storeQueries[max(a, b)]</code> for future processing.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Loop through each building index <code>index</code>:</p>
<ul>
<li>While the priority queue <code>maxIndex</code> has elements and the minimum value in <code>maxIndex</code> is smaller than the current building height:
<ul>
<li>Set the corresponding query's result in <code>result</code> and pop the element from <code>maxIndex</code> (this query is answered).</li>
</ul>
</li>
<li>Push new queries from <code>storeQueries[index]</code> into <code>maxIndex</code>, sorting them by height.</li>
</ul>
</li>
<li>
<p>Return the <code>result</code> array containing the answers to all queries.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gobEvzsi/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>heights</code> and <span class="math inline">\(q\)</span> be the number of queries in the <code>queries</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \cdot \log q + n)\)</span></p>
<p>The algorithm first iterates over the <code>queries</code> array to map the maximum indices and heights in <code>storeQueries</code>, taking <span class="math inline">\(O(q)\)</span> time. It then processes each index in the <code>heights</code> array, updating results via a priority queue. Insertion and deletion operations in the priority queue take <span class="math inline">\(O(\log q)\)</span> each, with at most <span class="math inline">\(q\)</span> queries processed. For each index, the algorithm checks and pushes relevant queries from <code>storeQueries</code>, resulting in an overall <span class="math inline">\(O(n)\)</span> time for all iterations.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(q \cdot \log q + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The algorithm uses a array <code>storeQueries</code> to store query mappings, which requires <span class="math inline">\(O(n)\)</span> space, as each element corresponds to an index in <code>heights</code>. Additionally, a priority queue <code>maxIndex</code> is used to handle queries, which at most can store <span class="math inline">\(O(q)\)</span> elements. The <code>result</code> array also requires <span class="math inline">\(O(q)\)</span> space to store the answers.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description" target="_blank" rel="noopener noreferrer">Find First and Last Position of Element in Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>

<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>

<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8
<strong>Output:</strong> [3,4]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6
<strong>Output:</strong> [-1,-1]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [], target = 0
<strong>Output:</strong> [-1,-1]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>
	<li><code>nums</code> is a non-decreasing array.</li>
	<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-h-index--165609/1" target="_blank" rel="noopener noreferrer">Find H-Index</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-pm-slice="1 1 []"><span style="font-size: 18.6667px;">You are given an array </span><strong style="font-size: 18.6667px;">citations[],</strong><span style="font-size: 18.6667px;"> where each element </span><strong style="font-size: 18.6667px;">citations[i]</strong><span style="font-size: 18.6667px;"> represents the number of </span><strong style="font-size: 18.6667px;">citations</strong><span style="font-size: 18.6667px;"> received by the </span><strong style="font-size: 18.6667px;">i<sup>th</sup></strong><span style="font-size: 18.6667px;"> paper of a researcher. You have to calculate the researcher&rsquo;s <strong>H</strong></span><strong style="font-size: 18.6667px;">-index</strong><span style="font-size: 18.6667px;">.</span><br /><span style="font-size: 18.6667px;">The <strong>H-index</strong> is defined as the maximum value <strong>H</strong>, such that the researcher has published at least <strong>H papers</strong>, and all those papers have <strong>citation value</strong> greater than or equal to <strong>H</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; white-space: normal;">citations</span>[] = [3, 0, 5, 3, 0]<br /></span><span style="font-size: 14pt;"><strong>Output:</strong> 3<br /><strong>Explanation:</strong> There are at least 3 papers with citation counts of 3, 5, and 3, all having citations greater than or equal to 3.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> citations[] = [5, 1, 2, 4, 1]<br /><strong>Output:</strong> 2<br /><strong>Explanation:</strong> There are 3 papers (with citation counts of 5, 2, and 4) that have 2 or more citations. However, the H-Index cannot be 3 because there aren't 3 papers with 3 or more citations.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> citations[] = [0, 0]<br /><strong>Output:</strong> 0<br /><strong>Explanation:</strong> The H-index is <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">0</span></span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> <span style="font-size: 14pt;">because there are no papers with at least 1 citation.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le;&nbsp;</span><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; font-size: 14pt;">citations</span><span style="font-size: 14pt;">.size() &le; 10</span><sup>6<br /></sup><span style="font-size: 14pt;">0 &le;&nbsp;</span><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; font-size: 14pt;">citations</span><span style="font-size: 14pt;">[i] &le; 10</span><sup>6</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-in-mountain-array/description" target="_blank" rel="noopener noreferrer">Find in Mountain Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">interactive</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><em>(This problem is an <strong>interactive problem</strong>.)</em></p>

<p>You may recall that an array <code>arr</code> is a <strong>mountain array</strong> if and only if:</p>

<ul>
	<li><code>arr.length &gt;= 3</code></li>
	<li>There exists some <code>i</code> with <code>0 &lt; i &lt; arr.length - 1</code> such that:
	<ul>
		<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
		<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>
	</ul>
	</li>
</ul>

<p>Given a mountain array <code>mountainArr</code>, return the <strong>minimum</strong> <code>index</code> such that <code>mountainArr.get(index) == target</code>. If such an <code>index</code> does not exist, return <code>-1</code>.</p>

<p><strong>You cannot access the mountain array directly.</strong> You may only access the array using a <code>MountainArray</code> interface:</p>

<ul>
	<li><code>MountainArray.get(k)</code> returns the element of the array at index <code>k</code> (0-indexed).</li>
	<li><code>MountainArray.length()</code> returns the length of the array.</li>
</ul>

<p>Submissions making more than <code>100</code> calls to <code>MountainArray.get</code> will be judged <em>Wrong Answer</em>. Also, any solutions that attempt to circumvent the judge will result in disqualification.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mountainArr = [1,2,3,4,5,3,1], target = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mountainArr = [0,1,2,4,2,1], target = 3
<strong>Output:</strong> -1
<strong>Explanation:</strong> 3 does not exist in <code>the array,</code> so we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= mountainArr.length() &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= target &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= mountainArr.get(index) &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <strong>mountain array</strong>. Based on the definition given in the problem description, any mountain array, can in general be represented as a <strong>strictly increasing</strong> array followed by a <strong>strictly decreasing</strong> array.</p>
<p><img src="../Figures/1095/1095_used/Slide1.PNG" alt="representation" /></p>
<p>The problem asks us to find the (minimum) index of a given <code>target</code> element in the given <code>mountainArr</code>. There might be a case where the <code>target</code> element is not present in the <code>mountainArr</code>. In such a case, we need to return <code>-1</code>.</p>
<p>Before moving further, let's focus on the term <strong>minimum index</strong>. Is there a possibility of multiple occurrences of the <code>target</code> element in the <code>mountainArr</code>?</p>
<p>Due to the phrase <strong>strictly</strong> in definition, it may seem that there is no possibility of multiple occurrences of any element. However, further thought on the graph suggests that corresponding to any element, there can be at most two occurrences of the element, one in the <strong>strictly increasing</strong> array and the other in the <strong>strictly decreasing</strong> array.<br />
<em>Or one before the peak and the other after the peak.</em></p>
<p><img src="../Figures/1095/1095_used/Slide2.PNG" alt="two_occurrences" /></p>
<p>In such a case, we should return the index of the element in the <strong>strictly increasing</strong> array. If the element is not present in the <strong>strictly increasing</strong> array, then we should return the index of the element in the <strong>strictly decreasing</strong> array.</p>
<p>Like any other array search problem, the <strong>Linear Search</strong> may sound very natural.</p>
<p>However, we cannot access the element of the given <code>mountainArr</code> directly. To access the element at index <code>k</code>, we need to call the function <code>mountainArr.get(k)</code>.</p>
<p>Still, we can call <code>get</code> for indices varying from <code>0</code> to <code>mountainArr.length() - 1</code>, and find the index of the <code>target</code> element.</p>
<p>However, there is a catch. The problem description also mentions that the function <code>mountainArr.get(k)</code> will be called at most <code>100</code> times, but the size of the <code>mountainArr</code> can be as large as <code>10000</code>.</p>
<p>Thus, <strong>Linear Search will not work here!</strong></p>
<p>Recall that when search space is sorted, we can use <strong>Binary Search</strong> to find the element in <span class="math inline">\(O(\log_2 {N})\)</span> time complexity, where <span class="math inline">\(N\)</span> is the size of the search space.</p>
<blockquote>
<p><strong>Binary Search</strong> is an algorithm for searching in a sorted array by repeatedly dividing the search interval in half.</p>
<p>While the basic algorithm sounds simpler, backed by in-built functions such as <code>bisect.bisect_left</code>, <code>upper_bound</code>, <code>lower_bound</code>, etc., the implementation has a good number of corner cases to handle, particularly off-by-one errors.</p>
<p>Hence, readers are strongly advised to follow the template given in <a href="https://leetcode.com/explore/learn/card/binary-search/"><strong>Leetcode Binary Search Explore Card</strong></a>. The templates there standardize the implementation of binary search and help in avoiding silly mistakes.</p>
</blockquote>
<p>In a sorted array, examination of only <span class="math inline">\(O(\log_2 {N})\)</span> elements is sufficient to search an element, or <span class="math inline">\(O(\log_2 {N})\)</span> calls to the <code>get</code> function is sufficient to find the element.</p>
<p>Taking the upper bound of the length of the <code>mountainArr</code> as <code>10000</code>, we can say that around <code>14</code> calls to <code>get(k)</code> will be sufficient to find the <code>target</code> element <strong>if</strong> array was sorted. <strong>However, <code>mountainArr</code> is not exactly sorted.</strong></p>
<ul>
<li>
<p>It has a peak element <code>peak</code> at index <code>peakIndex</code>.</p>
<blockquote>
<p>Finding the <code>peakIndex</code> in the <code>mountainArr</code> is another algorithmic problem. Readers are strongly advised to solve the problem <a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/description/"><strong>Peak Index in a Mountain Array</strong></a> before proceeding further.</p>
<p>After solving, readers can appreciate that the <code>peakIndex</code> can be found in <span class="math inline">\(O(\log_2 {N})\)</span> time complexity.</p>
<p>However, it is worth noting that although the time complexity of finding <code>peakIndex</code> is <span class="math inline">\(O(\log_2 {N})\)</span>, at each step, we need to examine at least two neighboring elements. Hence, the number of calls to <code>get(k)</code> will be around <span class="math inline">\(2 \log_2 {N}\)</span>.</p>
</blockquote>
</li>
<li>
<p>The array is <strong>strictly increasing</strong> from index <code>0</code> to <code>peakIndex</code>. Thus, we can use <strong>Binary Search</strong> to find the <code>target</code> element in the range <code>[0, peakIndex]</code>.</p>
<blockquote>
<p>The time complexity of <strong>Binary Search</strong> is <span class="math inline">\(O(\log_2 {N})\)</span>. For searching, at each step, we need to examine only one element. Hence, the number of calls to <code>get(k)</code> will be around <span class="math inline">\(\log_2 N\)</span>.</p>
</blockquote>
</li>
<li>
<p>The array is <strong>strictly decreasing</strong> from index <code>peakIndex + 1</code> to <code>mountainArr.length() - 1</code>. Thus, we can use <strong>Binary Search</strong> to find the <code>target</code> element in the range <code>[peakIndex + 1, mountainArr.length() - 1]</code>.</p>
<blockquote>
<p>The time complexity of <strong>Binary Search</strong> is <span class="math inline">\(O(\log_2 {N})\)</span>. For searching, at each step, we need to examine only one element. Hence, the number of calls to <code>get(k)</code> will be around <span class="math inline">\(\log_2 {N}\)</span>.</p>
</blockquote>
</li>
</ul>
<p>Hence, by using <strong>Binary Search</strong> thrice, and by making about <span class="math inline">\(4 \log_2 {N}\)</span> calls to <code>get(k)</code>, we can find the <code>target</code> element in the <code>mountainArr</code>.</p>
<p><strong>Will the number of calls to <code>mountainArr.get(k)</code> be less than <code>100</code>?</strong><br />
In the worst case, there will be about <span class="math inline">\(4 \log_2 {N}\)</span> calls to <code>mountainArr.get(k)</code>. Taking the upper bound of the length of the <code>mountainArr</code> as <code>10000</code>, we can say that <strong>Binary Search</strong> will take around <code>56</code> calls to <code>get(k)</code>. Thus, the number of calls to <code>get(k)</code> will be less than <code>100</code>.</p>
<p>This editorial has two pre-requisites:</p>
<ol>
<li>
<p>Proficiency in implementing Binary Search, which takes care of off-by-one errors. If not, readers are strongly advised to deep dive into <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card</a>.</p>
</li>
<li>
<p>Solving the problem <a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/description/">Peak Index in a Mountain Array</a>. If not, readers are strongly advised to solve the problem before proceeding further. The problem is a good warm-up exercise for the current problem.</p>
</li>
</ol>
<p>The editorial also tries to capture these prerequisites briefly.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>As discussed in <a href="#overview">overview</a>, we will break the problem into three parts, but before doing that, readers should keep in mind the following fact of Binary Search</p>
<blockquote>
<p>In Binary Search, we discard half of the search space at each step, based on the test condition on the middle element of the search space.</p>
<p>We must ensure that we don't end up discarding the element we are looking for. Our <code>[low, high]</code> search space must always contain the element we are looking for.</p>
</blockquote>
<p><strong>1. FIND INDEX OF PEAK ELEMENT</strong></p>
<ul>
<li>
<p><strong>What's the possible range of <code>peakIndex</code>?</strong></p>
<p>Looking at the problem description, we are sure that index-<code>0</code> and index-<code>mountainArr.length() - 1</code> are not the peak indices. Hence, the lowest possible value of <code>peakIndex</code> is <code>1</code>, and the highest possible value of <code>peakIndex</code> is <code>mountainArr.length() - 2</code>.</p>
<p>Hence, we can set</p>
<ul>
<li>
<p><code>low = 1</code></p>
</li>
<li>
<p><code>high = mountainArr.length() - 2</code></p>
</li>
</ul>
<p><code>testIndex</code> will be the middle index of the search space <code>[low, high]</code>.</p>
</li>
<li>
<p><strong>How to test if <code>testIndex</code> is the <code>peakIndex</code>?</strong></p>
<p>Element at <code>peakIndex</code> is greater than its neighbors. However, this would require 3 calls to <code>mountainArr.get(k)</code>. We can do better.</p>
<p>Let's compare the element at <code>testIndex</code> with its right neighbor only</p>
<p>We can have three markers on the graph</p>
<ul>
<li>
<p><code>i</code> for arbitrary index at strictly increasing part of the array</p>
</li>
<li>
<p><code>d</code> for arbitrary index at strictly decreasing part of the array</p>
</li>
<li>
<p><code>p</code> for the <code>peakIndex</code></p>
</li>
</ul>
<p><img src="../Figures/1095/1095_used/Slide3.PNG" alt="arbitrarypoints" /></p>
<ul>
<li>
<p>For all <code>i</code>, we have <code>mountainArr.get(i) &lt; mountainArr.get(i + 1)</code>.</p>
</li>
<li>
<p>For all <code>d</code>, we have <code>mountainArr.get(d) &gt; mountainArr.get(d + 1)</code>.</p>
</li>
<li>
<p>For <code>p</code>, we have <code>mountainArr.get(p) &gt; mountainArr.get(p + 1)</code>.</p>
</li>
</ul>
<p>Thus,</p>
<ul>
<li>
<p>if <code>mountainArr.get(testIndex) &lt; mountainArr.get(testIndex + 1)</code>, then <code>testIndex</code> is <code>i</code> only.</p>
<p>In this case, we can discard the left half of the search space, and search in the right half of the search space. This can be done by setting <code>low = testIndex + 1</code>. The <code>testIndex</code> was not at all a candidate for <code>peakIndex</code>. Hence, by discarding the left half of the search space, we are not discarding the <code>peakIndex</code>.</p>
</li>
<li>
<p>the case <code>mountainArr.get(testIndex) == mountainArr.get(testIndex + 1)</code> is not possible.</p>
</li>
<li>
<p>if <code>mountainArr.get(testIndex) &gt; mountainArr.get(testIndex + 1)</code>, then <code>testIndex</code> is either <code>d</code> or <code>p</code>.</p>
<p>In this case, we can discard the right half of the search space, and search in the left half of the search space. This can be done by setting <code>high = testIndex</code>. We cannot discard <code>testIndex</code> as it is a candidate for <code>peakIndex</code>. Hence, by setting <code>high = testIndex</code>, we are not discarding candidates for <code>peakIndex</code>.</p>
<p>Note that failure of the first <code>if</code> condition (<code>mountainArr.get(testIndex) &lt; mountainArr.get(testIndex + 1)</code>) implies passing of this <code>if</code> condition (<code>mountainArr.get(testIndex) &gt; mountainArr.get(testIndex + 1)</code>). Hence, we can use <code>else</code> instead of the <code>if</code> condition. This will prevent unnecessary comparison calls to <code>get</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>When to stop the search?</strong></p>
<p>The discarding of search space is done in such a way that the <strong><code>peakIndex</code> is always present in the search space</strong>. A quick check of the above algorithm shows that the search space will be reduced to a single element, i.e. <code>low == high</code>.</p>
<blockquote>
<p>Readers are encouraged to do this on pen and paper and convince themselves for smaller search space.</p>
</blockquote>
<blockquote>
<p>Assume search space reduces to three element array <code>[f, g, h]</code>. It's worth noting that <code>[f, g, h]</code> is not the input array, but the reduced search space. The <code>testIndex</code> will be the index of <code>g</code>.</p>
<ul>
<li>If <code>mountainArr.get(testIndex) &lt; mountainArr.get(testIndex + 1)</code>, then in the next iteration, the search space will reduce to a single element <code>[h]</code>.</li>
<li>If <code>mountainArr.get(testIndex) &gt; mountainArr.get(testIndex + 1)</code>, then in the next iteration, the search space will reduce to <code>[f, g]</code>.</li>
</ul>
</blockquote>
<blockquote>
<p>Let's see what happens when search space reduces to an array <code>[f, g]</code> with only two elements. It's worth noting that <code>[f, g]</code> is not the input array. In fact, <code>mountainArr</code> needs to have at least 3 elements. The <code>[f, g]</code> is reduced search space. The <code>testIndex</code> will be the index of <code>f</code>.</p>
<ul>
<li>If <code>mountainArr.get(testIndex) &lt; mountainArr.get(testIndex + 1)</code>, then in the next iteration, the search space will reduce to a single element <code>[g]</code>.</li>
<li>If <code>mountainArr.get(testIndex) &gt; mountainArr.get(testIndex + 1)</code>, then in the next iteration, the search space will reduce to a single element <code>[f]</code>.</li>
</ul>
</blockquote>
<blockquote>
<p>Thus, every two-element search space will be reduced to a single-element search space. We can prove by induction that every search space reduces to a single-element search space.</p>
</blockquote>
<p>Hence, we can stop the search when <code>low == high</code>. In this case, <code>low</code> (which is equal to <code>high</code>) will be the <code>peakIndex</code>.</p>
</li>
</ul>
<p><strong>2. SEARCH IN STRICTLY INCREASING PART OF THE ARRAY</strong></p>
<p>We will first search in the strictly increasing part of the array because if <code>target</code> exists, we need to return the minimum index of the <code>target</code> element. The minimum index of the <code>target</code> element will be in the strictly increasing part of the array.</p>
<p>If we fail to find the <code>target</code> element in the strictly increasing part of the array, then we will search in the strictly decreasing part of the array.</p>
<ul>
<li>
<p><strong>What's the possible range of <code>targetIndex</code> in the strictly increasing part of the array?</strong></p>
<p>The <code>targetIndex</code> will be in the range <code>[0, peakIndex]</code>. Hence, we can set</p>
<ul>
<li>
<p><code>low = 0</code></p>
</li>
<li>
<p><code>high = peakIndex</code></p>
</li>
</ul>
<p>Both are inclusive. <code>testIndex</code> will be the middle index of the search space <code>[low, high]</code>.</p>
</li>
<li>
<p><strong>How to test if <code>testIndex</code> is the <code>targetIndex</code>?</strong></p>
<p>The array is strictly increasing.</p>
<p><img src="../Figures/1095/1095_used/Slide4_1.PNG" alt="increasing" /></p>
<ul>
<li>
<p>If <code>mountainArr.get(testIndex) &lt; target</code>, then we are sure that all elements at indices less than or equal to <code>testIndex</code> are less than <code>target</code>. Hence, we can discard the left half of the search space, and search in the right half of the search space. This can be done by setting <code>low = testIndex + 1</code>. The <code>testIndex</code> was not at all a candidate for <code>targetIndex</code>. Hence, by discarding the left half of the search space, we are not discarding the <code>targetIndex</code>.</p>
</li>
<li>
<p>Otherwise, it means <code>mountainArr.get(testIndex) &gt;= target</code>, then we are sure that all elements at indices greater than <code>testIndex</code> are greater than or equal to <code>target</code>. Here, we can discard the right half of the search space, and search in the left half of the search space. This can be done by setting <code>high = testIndex</code>. We cannot discard <code>testIndex</code> as it is a candidate for <code>targetIndex</code>. Hence, by setting <code>high = testIndex</code>, we are not discarding candidates for <code>targetIndex</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>When to stop the search?</strong></p>
<p>The discarding of search space is done in such a way that the <strong>candidate for <code>targetIndex</code> is always present in the search space</strong>. A quick check of the above algorithm shows that the search space will be reduced to a single element, i.e. <code>low == high</code>.</p>
<blockquote>
<p>Assume search space reduces to three element array <code>[f, g, h]</code>. The <code>testIndex</code> will be the index of <code>g</code>.</p>
<ul>
<li>If <code>mountainArr.get(testIndex) &lt; target</code>, then in the next iteration, the search space will reduce to a single element <code>[h]</code>.</li>
<li>If <code>mountainArr.get(testIndex) &gt;= target</code>, then in the next iteration, the search space will reduce to a single element <code>[f, g]</code>.</li>
</ul>
</blockquote>
<blockquote>
<p>Let's see what happens when search space reduces to <code>[f, g]</code>, an array containing two elements. the <code>testIndex</code> will be the index of <code>f</code>.</p>
<ul>
<li>If <code>mountainArr.get(testIndex) &lt; target</code>, then in the next iteration, the search space will reduce to a single element <code>[g]</code>.</li>
<li>If <code>mountainArr.get(testIndex) &gt;= target</code>, then in the next iteration, the search space will reduce to a single element <code>[f]</code>.</li>
</ul>
</blockquote>
<blockquote>
<p>We can prove by induction that every search space reduces to a single-element search space.</p>
</blockquote>
<p>Hence, we can stop the search when <code>low == high</code>. In this case, <code>low</code> (which is equal to <code>high</code>) is the only candidate for <code>targetIndex</code> in the strictly increasing part of the array.</p>
</li>
<li>
<p><strong>What if <code>target</code> is not present in the strictly increasing part of the array?</strong></p>
<p><code>low</code> was the only candidate for <code>targetIndex</code> in the strictly increasing part of the array.</p>
<ul>
<li>
<p>If <code>mountainArr.get(low) == target</code>, then <code>low</code> is the <code>targetIndex</code>. Hence, we will return <code>low</code>.</p>
</li>
<li>
<p>Otherwise, if <code>mountainArr.get(low) != target</code>, then <code>target</code> is not present in the strictly increasing part of the array. In this case, we will search in the strictly decreasing part of the array.</p>
</li>
</ul>
</li>
</ul>
<p><strong>3. SEARCH IN STRICTLY DECREASING PART OF THE ARRAY</strong></p>
<p>If <code>target</code> is not present in the strictly increasing part of the array, then we will search in the strictly decreasing part of the array. If we fail to find the <code>target</code> element in the strictly decreasing part of the array, then we will return <code>-1</code>.</p>
<ul>
<li>
<p><strong>What's the possible range of <code>targetIndex</code> in the strictly decreasing part of the array?</strong></p>
<p>The <code>targetIndex</code> will be in the range <code>[peakIndex + 1, mountainArr.length() - 1]</code>. Hence, we can set</p>
<ul>
<li>
<p><code>low = peakIndex + 1</code></p>
</li>
<li>
<p><code>high = mountainArr.length() - 1</code></p>
</li>
</ul>
<p>Both are inclusive. <code>testIndex</code> will be the middle index of the search space <code>[low, high]</code>.</p>
</li>
<li>
<p><strong>How to test if <code>testIndex</code> is the <code>targetIndex</code>?</strong></p>
<p>The array is strictly decreasing.</p>
<p><img src="../Figures/1095/1095_used/Slide4_2.PNG" alt="decreasing" /></p>
<ul>
<li>
<p>If <code>mountainArr.get(testIndex) &gt; target</code>, then we are sure that all elements at indices less than or equal to <code>testIndex</code> are greater than <code>target</code>. Hence, we can discard the left half of the search space, and search in the right half of the search space. This can be done by setting <code>low = testIndex + 1</code>. The <code>testIndex</code> was not at all a candidate for <code>targetIndex</code>. Hence, by discarding the left half of the search space, we are not discarding the <code>targetIndex</code>.</p>
</li>
<li>
<p>Otherwise, it means <code>mountainArr.get(testIndex) &lt;= target</code>, then we are sure that all elements at indices greater than <code>testIndex</code> are less than or equal to <code>target</code>. Here, we can discard the right half of the search space, and search in the left half of the search space. This can be done by setting <code>high = testIndex</code>. We cannot discard <code>testIndex</code> as it is a candidate for <code>targetIndex</code>. Hence, by setting <code>high = testIndex</code>, we are not discarding the candidate for <code>targetIndex</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>When to stop the search?</strong></p>
<p>The discarding of search space is done in such a way that the <strong>candidate for <code>targetIndex</code> is always present in the search space</strong>. A quick check of the above algorithm shows that the search space will be reduced to a single element, i.e. <code>low == high</code>.</p>
<blockquote>
<p>Assume search space reduces to three element array <code>[r, q, p]</code>. The <code>testIndex</code> will be the index of <code>q</code>.</p>
<ul>
<li>If <code>mountainArr.get(testIndex) &gt; target</code>, then in the next iteration, the search space will reduce to a single element <code>[p]</code>.</li>
<li>If <code>mountainArr.get(testIndex) &lt;= target</code>, then in the next iteration, the search space will reduce to a single element <code>[r, q]</code>.</li>
</ul>
</blockquote>
<blockquote>
<p>Let's see what happens when search space reduces to a two-element array <code>[r, q]</code>. the <code>testIndex</code> will be the index of <code>r</code>.</p>
<ul>
<li>If <code>mountainArr.get(testIndex) &gt; target</code>, then in the next iteration, the search space will reduce to a single element <code>[q]</code>.</li>
<li>If <code>mountainArr.get(testIndex) &lt;= target</code>, then in the next iteration, the search space will reduce to a single element <code>[r]</code>.</li>
</ul>
</blockquote>
<blockquote>
<p>We can prove by induction that every search space reduces to a single-element search space.</p>
</blockquote>
<p>Hence, we can stop the search when <code>low == high</code>. In this case, <code>low</code> (which is equal to <code>high</code>) is the only candidate for <code>targetIndex</code> in the strictly decreasing part of the array.</p>
</li>
<li>
<p><strong>What if <code>target</code> is not present in the strictly decreasing part of the array?</strong></p>
<p><code>low</code> was the only candidate for <code>targetIndex</code> in the strictly decreasing part of the array.</p>
<ul>
<li>
<p>If <code>mountainArr.get(low) == target</code>, then <code>low</code> is the <code>targetIndex</code>. Hence, we will return <code>low</code>.</p>
</li>
<li>
<p>Otherwise, if <code>mountainArr.get(low) != target</code>, then <code>target</code> is not present in the strictly decreasing part of the array. Searching in the strictly decreasing part of the array implies that <code>target</code> was not present in the strictly increasing part of the array. Hence, <code>target</code> is not present in the <code>mountainArr</code>. In this case, we will return <code>-1</code>.</p>
</li>
</ul>
</li>
</ul>
<p>Hence, by breaking the problem into three parts, we can find the <code>target</code> element in the <code>mountainArr</code>.</p>
<blockquote>
<p>The <code>testIndex</code> is the middle value of the search space <code>[low, high]</code>.</p>
<ul>
<li>Now, <code>testIndex = (low + high) / 2</code> is a natural way to find the middle value of the search space. However, this can cause overflow. Hence, many often use the formula <code>testIndex = low + (high - low) / 2</code>.</li>
<li>In our problem, <code>high</code> and <code>low</code> can be at most <code>10000</code>. Thus, <code>low + high</code>, will probably not cause overflow. Hence, we can use sum.</li>
</ul>
</blockquote>
<p>With all details minutely discussed, readers are encouraged to implement the algorithm.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>In a variable <code>length</code>, save the length of the <code>mountainArr</code> by calling the function <code>mountainArr.length()</code>.</p>
</li>
<li>
<p>Find the index of the <code>peak</code> element in the <code>mountainArr</code>.</p>
<ul>
<li>Set <code>low = 1</code> and <code>high = length - 2</code>.</li>
<li>While <code>low != high</code>, do the following:
<ul>
<li>Find the middle index of the search space <code>[low, high]</code>. Let's call the index <code>testIndex</code>.</li>
<li>If <code>mountainArr.get(testIndex) &lt; mountainArr.get(testIndex + 1)</code>, then set <code>low = testIndex + 1</code>.</li>
<li>Otherwise, set <code>high = testIndex</code>.</li>
</ul>
</li>
<li>After the loop, <code>low</code> (which is equal to <code>high</code>) will be the <code>peakIndex</code>.</li>
</ul>
</li>
<li>
<p>Search for the <code>target</code> element in the strictly increasing part of the array.</p>
<ul>
<li>Set <code>low = 0</code> and <code>high = peakIndex</code>.</li>
<li>While <code>low != high</code>, do the following:
<ul>
<li>Find the middle index of the search space <code>[low, high]</code>. Let's call the index <code>testIndex</code>.</li>
<li>If <code>mountainArr.get(testIndex) &lt; target</code>, then set <code>low = testIndex + 1</code>.</li>
<li>Otherwise, set <code>high = testIndex</code>.</li>
</ul>
</li>
<li>If <code>mountainArr.get(low) == target</code>, then return <code>low</code>.</li>
<li>Otherwise, search for the <code>target</code> element in the strictly decreasing part of the array.</li>
</ul>
</li>
<li>
<p>Search for the <code>target</code> element in the strictly decreasing part of the array.</p>
<ul>
<li>Set <code>low = peakIndex + 1</code> and <code>high = length - 1</code>.</li>
<li>While <code>low != high</code>, do the following:
<ul>
<li>Find the middle index of the search space <code>[low, high]</code>. Let's call the index <code>testIndex</code>.</li>
<li>If <code>mountainArr.get(testIndex) &gt; target</code>, then set <code>low = testIndex + 1</code>.</li>
<li>Otherwise, set <code>high = testIndex</code>.</li>
</ul>
</li>
<li>If <code>mountainArr.get(low) == target</code>, then return <code>low</code>.</li>
</ul>
</li>
<li>
<p><code>target</code> not found in the <code>mountainArr</code>. Return <code>-1</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/53C2gv93/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>mountainArr</code>. Moreover, let's assume that each call to <code>mountainArr.get(k)</code> takes <span class="math inline">\(O(1)\)</span> time.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log N)\)</span></p>
<ul>
<li>
<p><strong>Finding the <code>peakIndex</code></strong><br />
There will be <span class="math inline">\(O(\log_2 {N})\)</span> iterations in the <code>while</code> loop. The reason is that at each iteration, the search space is reduced to half. At each iteration, we are</p>
<ul>
<li>
<p>computing <code>testIndex</code> using addition and division. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>calling <code>mountainArr.get(testIndex)</code> twice. This we assume takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>resetting <code>low</code> or <code>high</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Thus, the time complexity of finding the <code>peakIndex</code> is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
<li>
<p><strong>Searching in the strictly increasing part of the array</strong><br />
There will be <span class="math inline">\(O(\log_2 {N})\)</span> iterations in the <code>while</code> loop. The reason is that at each iteration, the search space is reduced to half. At each iteration, we are</p>
<ul>
<li>
<p>computing <code>testIndex</code> using addition and division. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>calling <code>mountainArr.get(testIndex)</code> once. This we assume takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>resetting <code>low</code> or <code>high</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Thus, the time complexity of searching in the strictly increasing part of the array is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
<li>
<p><strong>Searching in the strictly decreasing part of the array</strong><br />
There will be <span class="math inline">\(O(\log_2 {N})\)</span> iterations in the <code>while</code> loop. The reason is that at each iteration, the search space is reduced to half. At each iteration, we are</p>
<ul>
<li>
<p>computing <code>testIndex</code> using addition and division. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>calling <code>mountainArr.get(testIndex)</code> once. This we assume takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>resetting <code>low</code> or <code>high</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Thus, the time complexity of searching in the strictly decreasing part of the array is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
</ul>
<p>Hence, the overall time complexity of the algorithm is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We are using only constant extra space which includes a bunch of variables. Hence, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-minimizing-get-calls-with-early-stopping-and-caching">Approach 2: Minimizing <code>get</code> Calls with Early Stopping and Caching</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The purpose of <a href="#approach-1-binary-search">Approach 1</a> was to slowly build the intuition for the problem. Therefore, the three parts of the problem contain several redundant steps.</p>
<p>In this approach, we will avoid redundant work that will minimize the number of calls to <code>mountainArr.get(k)</code>. In addition, we will look at the &quot;caching&quot; technique that can accomplish the task more efficiently.</p>
<ul>
<li>
<p>We are examining <span class="math inline">\(2 \log N\)</span> elements for finding <code>peakIndex</code>. What if while examining an element at index <code>testIndex</code>, we came to know that element is equal to <code>target</code> itself? Can we immediately return <code>testIndex</code> as the <code>targetIndex</code>?</p>
<p>Not every time! In the problem, we want to return the minimum index of the <code>target</code> element. Hence, we can do so only when we are sure that the element at index <code>testIndex</code> is in the strictly increasing part of the array. If the element at index <code>testIndex</code> is in the strictly decreasing part of the array, then we aren't sure if it is the minimum index of the <code>target</code> element.</p>
</li>
<li>
<p>For search in strictly increasing (and after that strictly decreasing) part, if we came to know that element at <code>testIndex</code> is equal to <code>target</code>, then there we can immediately return the <code>testIndex</code> as <code>targetIndex</code>. However, here is a word of caution.</p>
<p>Let's take the example of the strictly increasing portion.</p>
<ul>
<li>
<p>if <code>mountainArr.get(testIndex) == target</code>, then we can return <code>testIndex</code> as <code>targetIndex</code>.</p>
</li>
<li>
<p>if <code>mountainArr.get(testIndex) &lt; target</code>, then we can set <code>low = testIndex + 1</code>.</p>
</li>
<li>
<p>if <code>mountainArr.get(testIndex) &gt; target</code>, then we can set <code>high = testIndex - 1</code>. Because we know that <code>testIndex</code> is no longer a candidate for <code>targetIndex</code>. In <a href="#approach-1-binary-search">Approach-1</a>, we were setting <code>high = testIndex</code> because it was a potential candidate. The condition there was <code>mountainArr.get(testIndex) &gt;= target</code>. Here, the condition is <code>mountainArr.get(testIndex) &gt; target</code>. Hence, we can set <code>high = testIndex - 1</code>.</p>
</li>
</ul>
<p>Now, this may seem like no issue, but there are chances that <code>low</code> and <code>high</code> don't converge to a single element.</p>
<blockquote>
<p>Take for example a two array search space <code>[f, g]</code>.</p>
<ul>
<li>
<p><code>low</code> will be the index of <code>f</code>.</p>
</li>
<li>
<p><code>high</code> will be the index of <code>g</code>.</p>
</li>
<li>
<p><code>testIndex</code> will be the index of <code>f</code>.</p>
</li>
</ul>
<p>Now, if <code>mountainArr.get(testIndex) &gt; target</code>, then we will set <code>high = testIndex - 1</code>. This will make the <code>high</code> point to <code>f - 1</code>. However, <code>low</code> will still point to <code>f</code>. Hence, the search space will be <code>[f, f - 1]</code>. This is not a valid search space.</p>
</blockquote>
<p>Thus, the condition of the stop of the search will be <code>low &gt; high</code>, and while loop condition will be <code>low &lt;= high</code>.</p>
</li>
<li>
<p>We computed <code>testIndex</code> as <code>testIndex = (low + high) / 2</code>. The floor division by <code>2</code> can be computed by right shift by <code>1</code>. Hence, we can compute <code>testIndex</code> as <code>testIndex = (low + high) &gt;&gt; 1</code>.</p>
</li>
<li>
<p>In strictly increasing (or strictly decreasing) subarray, we are doing Binary Search. Turns out that we can also do a Ternary Search, by reducing search space to one-third at each iteration. Will it reduce the number of calls to <code>mountainArr.get(k)</code>? Let's see.</p>
<p>The number of iterations in ternary search will be <span class="math inline">\(O(\log_3 N)\)</span>. The reason is that at each iteration, the search space is reduced to one-third. Now at each iteration, we need to examine two indices, <code>testIndex1</code> and <code>testIndex2</code>. Thus, the number of calls to <code>mountainArr.get(k)</code> will be <span class="math inline">\(2 \log_3 N\)</span>.</p>
<p>Using the base change formula,<br />
<span class="math inline">\(= 2 \log_3 N\)</span><br />
<span class="math inline">\(= 2 \frac{\log_2 {N}}{\log_2 3}\)</span><br />
<span class="math inline">\(= 2 \frac{\log_2 {N}}{1.585}\)</span><br />
<span class="math inline">\(= 1.26 \log_2 {N}\)</span></p>
<p>The number of calls to <code>mountainArr.get(k)</code> in Binary Search is <span class="math inline">\(\log_2 {N}\)</span>.</p>
<p>Thus, ternary search provides less number of iterations, but more number of calls to <code>mountainArr.get(k)</code>. Hence, we will stick to Binary Search.</p>
</li>
</ul>
<p>The above ideas sound good. Let's see one more idea.</p>
<p>In <a href="#complexity-analysis">complexity analysis</a> of <a href="#approach-1-binary-search">Approach 1</a>, we assumed that each call to <code>mountainArr.get(k)</code> takes <span class="math inline">\(O(1)\)</span> time. However, we don't know the time complexity of <code>mountainArr.get(k)</code>. What if calls to the <code>get()</code> API are very expensive? We certainly need to minimize function calls as much as we can.</p>
<blockquote>
<p>Assume <code>get()</code> was retrieving data from a huge database that is on the other side of the world. One would appreciate our algorithm finishing faster, even if that difference is constant.</p>
</blockquote>
<p>Assume an element at index <code>i</code> in the strictly increasing part of the array, and we called <code>get(i)</code> while computing the <code>peakIndex</code>. Now, we are searching for <code>target</code> in the strictly increasing part of the array. We might again need to call <code>get(i)</code> while searching for <code>target</code>. Is it truly a better idea to call <code>get(i)</code> twice?</p>
<p>We perhaps can cache the values of <code>mountainArr.get(k)</code> in an array, or perhaps in a Hash Map. This will increase the space complexity. However, we won't be calling <code>mountainArr.get(k)</code> twice. Before calling <code>mountainArr.get(k)</code>, we will check if the value is already cached. If it is, then we will use the cached value. Otherwise, we will call <code>mountainArr.get(k)</code> and cache the value.</p>
<p>This parallels the way web browsers store data. Often, the expense associated with reacquiring a page is considered to be greater than that of storing it in a cache.</p>
<blockquote>
<p>Briefly, the following major modifications will be done in three parts.</p>
<ol>
<li>
<p><strong>FINDING <code>peakIndex</code></strong></p>
<ul>
<li>
<p>If <code>mountainArr.get(testIndex)</code> is in the cache, then use the cached value. Otherwise, call <code>mountainArr.get(testIndex)</code> and cache the value. Call this as <code>curr</code>. If <code>curr == target</code>, check if it is in the strictly increasing part of the array. If it is, then return <code>testIndex</code> as <code>targetIndex</code>. Otherwise, continue the search for <code>peakIndex</code>.</p>
</li>
<li>
<p>If <code>mountainArr.get(testIndex + 1)</code> is in the cache, then use the cached value. Otherwise, call <code>mountainArr.get(testIndex + 1)</code> and cache the value. Call this <code>next</code>. If <code>next == target</code>, check if it is in the strictly increasing part of the array. If it is, then return <code>testIndex + 1</code> as <code>targetIndex</code>. Otherwise, continue the search for <code>peakIndex</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>SEARCH IN STRICTLY INCREASING PART OF THE ARRAY</strong></p>
<p>If <code>mountainArr.get(testIndex)</code> is in the cache, then use the cached value.</p>
<p>Otherwise, call <code>mountainArr.get(testIndex)</code>. Note that we don't need to cache the value of <code>mountainArr.get(testIndex)</code> as this is the last time we need to access this value. Call this as <code>curr</code>. If <code>curr == target</code>, then return <code>testIndex</code> as <code>targetIndex</code>.</p>
</li>
<li>
<p><strong>SEARCH IN STRICTLY DECREASING PART OF THE ARRAY</strong></p>
<p>If <code>mountainArr.get(testIndex)</code> is in the cache, then use the cached value. Call it <code>curr</code>. If <code>curr == target</code>, then return <code>testIndex</code> as <code>targetIndex</code>. We perhaps didn't return in the first while loop because it was in the strictly decreasing part of the array.</p>
<p>Otherwise, call <code>mountainArr.get(testIndex)</code>. Note that we don't need to cache the value of <code>mountainArr.get(testIndex)</code> as this is the last time we need to access this value. Call this as <code>curr</code>. If <code>curr == target</code>, then return <code>testIndex</code> as <code>targetIndex</code>.</p>
</li>
</ol>
</blockquote>
<p>A quick note on <strong>how to cache the values</strong> of <code>mountainArr.get(k)</code>.</p>
<ul>
<li>
<p>We can use an array of size <code>mountainArr.length()</code> to cache the values of <code>mountainArr.get(k)</code>. The index of the array will be the index of the <code>mountainArr</code>. The value at the index will be the value of <code>mountainArr.get(k)</code>. This will increase the space complexity by <span class="math inline">\(O(N)\)</span>. However, is it a truly good idea? There will be many indices in the array that will not be used because we will call <code>mountainArr.get(k)</code> only for <span class="math inline">\(4 \log N\)</span> indices. Hence, we will be wasting space.</p>
</li>
<li>
<p>Therefore, use a Hash Map which gives constant time lookups. The key of the Hash Map will be the index of the <code>mountainArr</code>. The value at the key will be the value of <code>mountainArr.get(k)</code>. This will increase the space complexity by <span class="math inline">\(O(\log N)\)</span> reducing it from previously proposed <span class="math inline">\(O(N)\)</span>. The reduction of this space complexity is significant.</p>
</li>
</ul>
<p>With these thoughts in mind, we can implement the algorithm.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Save the length of the <code>mountainArr</code> by calling the function <code>mountainArr.length()</code> in the variable <code>length</code>.</p>
</li>
<li>
<p>Initialize a Hash Map <code>cache</code> to cache the values of <code>mountainArr.get(k)</code>.</p>
</li>
<li>
<p>Find the index of the <code>peak</code> element in the <code>mountainArr</code>.</p>
<ul>
<li>Set <code>low = 1</code> and <code>high = length - 2</code>.</li>
<li>While <code>low != high</code>, do the following:
<ul>
<li>Find the middle index of the search space <code>[low, high]</code>. Let's call the index <code>testIndex</code>.</li>
<li>If <code>testIndex</code> is in the <code>cache</code>, then set <code>curr = cache.get(testIndex)</code>. Otherwise, call <code>mountainArr.get(testIndex)</code> and set <code>curr = mountainArr.get(testIndex)</code>. Cache the value of <code>curr</code> in the <code>cache</code>.</li>
<li>If <code>testIndex + 1</code> is in the <code>cache</code>, then set <code>next = cache.get(testIndex + 1)</code>. Otherwise, call <code>mountainArr.get(testIndex + 1)</code> and set <code>next = mountainArr.get(testIndex + 1)</code>. Cache the value of <code>next</code> in the <code>cache</code>.</li>
<li>If <code>curr &lt; next</code>, check if <code>curr == target</code> or <code>next == target</code>. If yes, then return the index of the <code>target</code> element. Otherwise, set <code>low = testIndex + 1</code>.</li>
<li>Otherwise, set <code>high = testIndex</code>.</li>
</ul>
</li>
<li>After the loop, <code>low</code> (which is equal to <code>high</code>) will be the <code>peakIndex</code>.</li>
</ul>
</li>
<li>
<p>Search for the <code>target</code> element in the strictly increasing part of the array.</p>
<ul>
<li>Set <code>low = 0</code> and <code>high = peakIndex</code>.</li>
<li>While <code>low &lt;= high</code>, do the following:
<ul>
<li>Find the middle index of the search space <code>[low, high]</code>. Let's call the index <code>testIndex</code>.</li>
<li>If <code>testIndex</code> is in the <code>cache</code>, then set <code>curr = cache.get(testIndex)</code>. Otherwise, call <code>mountainArr.get(testIndex)</code> and set <code>curr = mountainArr.get(testIndex)</code>.</li>
<li>If <code>curr == target</code>, then return <code>testIndex</code>.</li>
<li>If <code>curr &lt; target</code>, then set <code>low = testIndex + 1</code>.</li>
<li>Otherwise, set <code>high = testIndex - 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Search for the <code>target</code> element in the strictly decreasing part of the array.</p>
<ul>
<li>Set <code>low = peakIndex + 1</code> and <code>high = length - 1</code>.</li>
<li>While <code>low &lt;= high</code>, do the following:
<ul>
<li>Find the middle index of the search space <code>[low, high]</code>. Let's call the index <code>testIndex</code>.</li>
<li>If <code>testIndex</code> is in the <code>cache</code>, then set <code>curr = cache.get(testIndex)</code>. Otherwise, call <code>mountainArr.get(testIndex)</code> and set <code>curr = mountainArr.get(testIndex)</code>.</li>
<li>If <code>curr == target</code>, then return <code>testIndex</code>.</li>
<li>If <code>curr &gt; target</code>, then set <code>low = testIndex + 1</code>.</li>
<li>Otherwise, set <code>high = testIndex - 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>target</code> not found in the <code>mountainArr</code>. Return <code>-1</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/kW5svw5e/shared">code</a></p>
<p>Readers might be prompted to think that <code>cache</code> is redundant. It might be because in this problem <code>get(k)</code> looks like <span class="math inline">\(O(1)\)</span> operation. However, when the time complexity of any function is not specified explicitly, it is better to call that function the minimum possible number of times.</p>
<p>Here is the implementation without caching.</p>
<p><a href="https://leetcode.com/playground/nPj8cjko/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>mountainArr</code>. Moreover, let's assume that each call to <code>mountainArr.get(k)</code> takes <span class="math inline">\(O(1)\)</span> time.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log N)\)</span></p>
<ul>
<li>
<p><strong>Finding the <code>peakIndex</code></strong><br />
There will be <span class="math inline">\(O(\log_2 {N})\)</span> iterations in the <code>while</code> loop. The reason is that at each iteration, the search space is reduced to half. At each iteration, we are</p>
<ul>
<li>
<p>computing <code>testIndex</code> using addition and bit shift. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Getting the value of <code>mountainArr.get(testIndex)</code> from the <code>cache</code> or from the <code>mountainArr</code>. Caching if not present in the <code>cache</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Getting the value of <code>mountainArr.get(testIndex + 1)</code> from the <code>cache</code> or from the <code>mountainArr</code>. Caching if not present in the <code>cache</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Returning or resetting <code>low</code> or <code>high</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Thus, the time complexity of finding the <code>peakIndex</code> is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
<li>
<p><strong>Searching in the strictly increasing part of the array</strong><br />
There will be <span class="math inline">\(O(\log_2 {N})\)</span> iterations in the <code>while</code> loop. The reason is that at each iteration, the search space is reduced to half. At each iteration, we are</p>
<ul>
<li>
<p>computing <code>testIndex</code> using addition and bit shift. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Getting the value of <code>mountainArr.get(testIndex)</code> from the <code>cache</code> or from the <code>mountainArr</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Returning or resetting <code>low</code> or <code>high</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Thus, the time complexity of searching in the strictly increasing part of the array is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
<li>
<p><strong>Searching in the strictly decreasing part of the array</strong><br />
There will be <span class="math inline">\(O(\log_2 {N})\)</span> iterations in the <code>while</code> loop. The reason is that at each iteration, the search space is reduced to half. At each iteration, we are</p>
<ul>
<li>
<p>computing <code>testIndex</code> using addition and bit shift. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Getting the value of <code>mountainArr.get(testIndex)</code> from the <code>cache</code> or from the <code>mountainArr</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Returning or resetting <code>low</code> or <code>high</code>. This takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Thus, the time complexity of searching in the strictly decreasing part of the array is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
</ul>
<p>Hence, the overall time complexity is <span class="math inline">\(O(\log_2 {N})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log N)\)</span></p>
<p>The <code>cache</code> will contain <span class="math inline">\(O(\log N)\)</span> elements because we are caching only the elements for which we are calling <code>mountainArr.get(k)</code>.</p>
<p>Hence, the space complexity is <span class="math inline">\(O(\log N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-k-closest-elements/description" target="_blank" rel="noopener noreferrer">Find K Closest Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>sorted</strong> integer array <code>arr</code>, two integers <code>k</code> and <code>x</code>, return the <code>k</code> closest integers to <code>x</code> in the array. The result should also be sorted in ascending order.</p>

<p>An integer <code>a</code> is closer to <code>x</code> than an integer <code>b</code> if:</p>

<ul>
	<li><code>|a - x| &lt; |b - x|</code>, or</li>
	<li><code>|a - x| == |b - x|</code> and <code>a &lt; b</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">arr = [1,2,3,4,5], k = 4, x = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,3,4]</span></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">arr = [1,1,2,3,4,5], k = 4, x = -1</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1,2,3]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= arr.length</code></li>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>
	<li><code>arr</code> is sorted in <strong>ascending</strong> order.</li>
	<li><code>-10<sup>4</sup> &lt;= arr[i], x &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-k-th-smallest-pair-distance/description" target="_blank" rel="noopener noreferrer">Find K-th Smallest Pair Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>distance of a pair</strong> of integers <code>a</code> and <code>b</code> is defined as the absolute difference between <code>a</code> and <code>b</code>.</p>

<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest <strong>distance among all the pairs</strong></em> <code>nums[i]</code> <em>and</em> <code>nums[j]</code> <em>where</em> <code>0 &lt;= i &lt; j &lt; nums.length</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1], k = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> Here are all the pairs:
(1,3) -&gt; 2
(1,1) -&gt; 0
(3,1) -&gt; 2
Then the 1<sup>st</sup> smallest distance pair is (1,1), and its distance is 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1], k = 2
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,6,1], k = 3
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The goal is to find the <code>k</code>-th smallest distance between any two different elements in an array <code>nums</code>. The distance between two elements <code>nums[i]</code> and <code>nums[j]</code> is defined as the absolute difference between their values, <code>|nums[i] - nums[j]|</code>. We only consider pairs where <code>i</code> is less than <code>j</code> to avoid counting the same pair twice.</p>
<p>For example:</p>
<blockquote>
<p><strong>Input:</strong> <code>nums = [1, 3, 1]</code>, <code>k = 1</code><br />
<strong>Output:</strong> <code>0</code></p>
</blockquote>
<p>Let's look at all possible pairs of elements and their distances:</p>
<ol>
<li>
<p>Pair (1, 3):</p>
<ul>
<li>Distance: |1 - 3| = 2</li>
</ul>
</li>
<li>
<p>Pair (1, 1):</p>
<ul>
<li>Distance: |1 - 1| = 0</li>
</ul>
</li>
<li>
<p>Pair (3, 1):</p>
<ul>
<li>Distance: |3 - 1| = 2</li>
</ul>
</li>
</ol>
<p>So, the distances are <code>[2, 0, 2]</code>.</p>
<p>To find the <code>k</code>-th smallest distance, we sort these distances: <code>[0, 2, 2]</code>.</p>
<p>Since <code>k = 1</code>, we need the 1st smallest distance, which is <code>0</code>.</p>
<p>Thus, the result is <code>0</code>.</p>
<p>The brute-force approach involves checking the distance for every possible pair of elements in the array and maintaining the <code>k</code> smallest distances using a heap. Specifically, we iterate over all pairs, calculate their absolute distances, and use a max-heap to keep track of the <code>k</code> smallest distances. If the heap size exceeds <code>k</code>, we remove the largest element. After processing all pairs, the root of the heap will represent the <code>k-th</code> smallest distance.</p>
<p>However, this method is computationally heavy and will lead to a Time Limit Exceeded (TLE) error. The time complexity is dominated by the need to examine all pairs, which is <span class="math inline">\(O(n^2)\)</span>, combined with the overhead of maintaining a heap of size <code>k</code>, resulting in an overall time complexity of <span class="math inline">\(O(n^2 \log k)\)</span>, where <code>n</code> is the number of elements. This makes the approach impractical for large values of <code>n</code>.</p>
<hr />
<h3 id="approach-1-bucket-sort">Approach 1: Bucket Sort</h3>
<h4 id="intuition">Intuition</h4>
<p>Given that array elements can be as large as <code>1,000,000</code>, a direct comparison approach would be computationally expensive. However, since the distances are bounded by the maximum element in the array, we can leverage this property to use a bucket sort approach, which is efficient for problems with a known range of values. This transforms the problem of finding the <code>k</code>-th smallest distance into a counting problem within a fixed range.</p>
<p>We first observe that the range of possible distances is finite and bounded:</p>
<ul>
<li>The minimum distance is 0, occurring when two numbers in the array are identical.</li>
<li>The maximum distance is the difference between the largest and smallest numbers in the array.</li>
</ul>
<p>This bounded range forms the foundation of our approach. With this range established, we conceptualize a series of &quot;buckets,&quot; each representing a specific distance within our range. These buckets serve as counters, allowing us to tally the frequency of each distance without needing to store the actual pairs that produce them. This abstraction significantly reduces memory requirements and computational complexity.</p>
<p>Now for each pair of numbers in the array, calculate the absolute difference and increment the corresponding bucket count.</p>
<p>After processing all pairs, our bucket array contains a comprehensive frequency distribution of all distances present in the original array. Now traverse the bucket array from the smallest distance upwards, maintaining a running sum of counts. The distance where this running sum first equals or exceeds is the  k-th smallest distance.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Determine the size of the input array <code>nums</code> and store it in <code>arraySize</code>.</p>
</li>
<li>
<p>Find the maximum element in the array <code>nums</code> and store it in <code>maxElement</code>.</p>
</li>
<li>
<p>Create a bucket array <code>distanceBucket</code> with size <code>maxElement + 1</code>, initialized to 0, to store the counts of each distance.</p>
</li>
<li>
<p>Populate the <code>distanceBucket</code> array:</p>
<ul>
<li>Iterate over all pairs of indices <code>(i, j)</code> where <code>i &lt; j</code> in the array <code>nums</code>.
<ul>
<li>Calculate the distance between <code>nums[i]</code> and <code>nums[j]</code> as <code>abs(nums[i] - nums[j])</code>.</li>
<li>Increment the count for this distance in the <code>distanceBucket</code> array.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Find the k-th smallest distance:</p>
<ul>
<li>Iterate over all possible distances from 0 to <code>maxElement</code>.
<ul>
<li>Subtract the count of pairs with the current distance from <code>k</code>.</li>
<li>If <code>k</code> becomes less than or equal to 0, return the current distance as it is the k-th smallest distance.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the function does not return within the loop, return <code>-1</code> indicating no distance was found, although this case should not occur with valid inputs.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: The Python implementation for this approach will encounter a Time Limit Exceeded (TLE) error because Python's inherent slower execution speed.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/H5scviJc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements and <span class="math inline">\(M\)</span> be the maximum possible distance.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + M)\)</span></p>
<p>The <span class="math inline">\(O(n^2)\)</span> term arises from the nested loops used to calculate all pairwise distances between elements. Since we are examining every possible pair of elements in the array, this results in <span class="math inline">\(n(n-1)/2\)</span> comparisons, which simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
<p>After calculating all distances, we traverse the <code>distanceBucket</code> array to find the k-th smallest distance. This traversal is <span class="math inline">\(O(M)\)</span>, where <span class="math inline">\(M\)</span> is the maximum possible distance, which is proportional to the largest element in the array. Thus, the total time complexity is <span class="math inline">\(O(n^2 + M)\)</span>, accounting for both the pair distance calculations and the bucket traversal.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M)\)</span></p>
<p>The space complexity is dominated by the <code>distanceBucket</code> array, which is used to count occurrences of each possible distance. The size of this array is proportional to the maximum possible distance <span class="math inline">\(M\)</span>. Aside from this array, the space usage is minimal and does not depend on the number of elements, leading to a space complexity of <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search--dynamic-programming-dp">Approach 2: Binary Search + Dynamic Programming (DP)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We now explore a sophisticated approach that combines binary search with dynamic programming, especially effective for arrays with a broad range of values where bucket sort might be impractical due to memory constraints.</p>
<p>First, recognize that our solution space—the range of possible distances—is bounded. The minimum distance is 0, and the maximum is the difference between the largest and smallest elements in the array. This bounded range allows us to use binary search to efficiently find the <code>k</code>-th smallest distance.</p>
<p>Our key insight is that for any given distance <code>d</code>, we can count the number of pairs in the array with a distance less than or equal to <code>d</code>. If this count is less than <code>k</code>, the <code>k</code>-th smallest distance must be greater than <code>d</code>. Conversely, if the count is at least <code>k</code>, the <code>k</code>-th smallest distance must be less than or equal to <code>d</code>. This forms the basis of our binary search approach.</p>
<p>To implement this, we first sort the input array. Sorting is crucial because it enables us to efficiently count pairs with distances less than or equal to a given value.</p>
<p>We then set up our binary search:</p>
<ul>
<li>The lower bound of our search range is <code>0</code>, and the upper bound is the difference between the maximum and minimum elements in the sorted array.</li>
<li>In each iteration, we calculate the midpoint of the current range and count the number of pairs with distances less than or equal to this midpoint.</li>
</ul>
<p>The counting process is where dynamic programming comes into play. We use two auxiliary arrays to optimize our pair counting:</p>
<ol>
<li><strong>prefixCount</strong>: This array maintains the cumulative count of elements up to each value in the sorted array. For any index <code>i</code>, <code>prefixCount[i]</code> represents the number of elements less than or equal to <code>i</code>.</li>
<li><strong>valueCount</strong>: Implemented as a hash map, <code>valueCount[i]</code> stores the count of occurrences of the value <code>i</code> in the array.</li>
</ol>
<p>To count pairs for a given distance <code>d</code>, we iterate through the sorted array. For each element <code>x</code>, we calculate:</p>
<ul>
<li>The number of elements within distance <code>d</code> of <code>x</code> using <code>prefixCount</code>.</li>
<li>The number of pairs formed by duplicate occurrences of <code>x</code> using <code>valueCount</code>.</li>
</ul>
<p>Based on the count of pairs at the current midpoint distance, we adjust our binary search range:</p>
<ul>
<li>If the count is less than <code>k</code>, we need to look at larger distances by adjusting the lower bound.</li>
<li>If the count is greater than or equal to <code>k</code>, we need to look at smaller distances by adjusting the upper bound.</li>
</ul>
<p>We repeat this process, halving the search range each time, until the lower and upper bounds converge, giving us the <code>k</code>-th smallest pair distance.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Sort the array <code>nums</code> to simplify distance calculations.</p>
</li>
<li>
<p>Determine the size of the sorted array <code>nums</code> and store it in <code>arraySize</code>.</p>
</li>
<li>
<p>Find the largest element in the sorted array <code>nums</code> and store it in <code>maxElement</code>.</p>
</li>
<li>
<p>Calculate the maximum possible distance as <code>maxElement * 2</code>.</p>
</li>
<li>
<p>Initialize arrays and maps:</p>
<ul>
<li>Create an array <code>prefixCount</code> with size <code>maxPossibleDistance</code> to store prefix counts of distances.</li>
<li>Create a map <code>valueCount</code> to count occurrences of each value in the array.</li>
</ul>
</li>
<li>
<p>Populate the <code>prefixCount</code> array:</p>
<ul>
<li>Iterate through possible distance values from 0 to <code>maxPossibleDistance - 1</code>.
<ul>
<li>For each distance value, determine the number of elements in the array <code>nums</code> that are less than or equal to this distance.</li>
<li>Store this count in <code>prefixCount</code> for the current distance.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Populate the <code>valueCount</code> map:</p>
<ul>
<li>Iterate through the array <code>nums</code>.
<ul>
<li>Count occurrences of each value and store in <code>valueCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform binary search for the k-th smallest distance:</p>
<ul>
<li>Set <code>low</code> to 0 and <code>high</code> to <code>maxElement</code>.</li>
<li>While <code>low</code> is less than <code>high</code>:
<ul>
<li>Calculate the middle point <code>mid</code> as <code>(low + high) / 2</code>.</li>
<li>Count the number of pairs with distance ≤ <code>mid</code> using the helper function <code>countPairs</code>.</li>
<li>Adjust the binary search bounds based on whether the count is less than or greater than or equal to <code>k</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the smallest distance found by the binary search.</p>
</li>
<li>
<p>Helper function <code>countPairs</code>:</p>
<ul>
<li>Count the number of pairs with distance ≤ <code>maxDistance</code>:
<ul>
<li>Iterate through the array <code>nums</code>.</li>
<li>Calculate the number of pairs involving the current value that are within the allowed distance.</li>
<li>Accumulate the total count of such pairs.</li>
</ul>
</li>
<li>Return the count of pairs with distance ≤ <code>maxDistance</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/SU4MpYrm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements and <span class="math inline">\(M\)</span> be the maximum possible distance.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + n \log M + M)\)</span></p>
<p>The <span class="math inline">\(O(n \log n)\)</span> term arises from sorting the array, which is necessary for efficiently calculating distances and performing binary search. Sorting takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>The <span class="math inline">\(O(n \log M)\)</span> term comes from the binary search over the range of possible distances and counting pairs for each mid-value. Counting pairs involves traversing the array, and the binary search operations are logarithmic with respect to the maximum possible distance <span class="math inline">\(M\)</span>. And we populate the <code>prefixCount</code> array by iterating through the possible values from 0 to <code>maxPossibleDistance</code> - 1 taking <span class="math inline">\(O(M)\)</span>. Hence, the combined time complexity is <span class="math inline">\(O(n \log n + n \log M + M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + M + S)\)</span></p>
<p>The space complexity includes <span class="math inline">\(O(n)\)</span> for storing the <code>prefixCount</code> array and the value counts in the <code>valueCount</code> map. The <code>prefixCount</code> array tracks the number of elements up to each possible distance, while <code>valueCount</code> stores counts of each unique element. Additionally, <span class="math inline">\(O(M)\)</span> is required for the <code>prefixCount</code> array.</p>
<p>Some extra space is used when we sort an array of size <span class="math inline">\(n\)</span> in place. The space complexity of the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the programming language. The value of <span class="math inline">\(S\)</span> depends on the programming language and the sorting algorithm being used:</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span></li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O( \log n )\)</span></li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span></li>
</ul>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + M + S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-binary-search--sliding-window">Approach 3: Binary Search + Sliding Window</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The core idea remains similar to our previous approach: for any given distance <code>d</code>, we aim to count the number of pairs in the array with a distance less than or equal to <code>d</code>. If this count is less than <code>k</code>, we know the <code>k</code>-th smallest distance must be greater than <code>d</code>. If the count is greater than or equal to <code>k</code>, the <code>k</code>-th smallest distance must be less than or equal to <code>d</code>.</p>
<p>Where this approach diverges is in how we perform this counting operation. Instead of using pre-computed dynamic programming arrays, we employ a sliding window technique that takes advantage of the sorted nature of our array.</p>
<p>We begin by sorting the input array and then we set up binary search as before, with the lower bound at 0 and the upper bound at the difference between the maximum and minimum elements in the sorted array. In each iteration of the binary search, we calculate the midpoint of our current range.</p>
<p>The key innovation in this approach is the sliding window method used to count pairs with distances less than or equal to our current midpoint distance. Here's how it works:</p>
<ul>
<li>Start with two pointers, <code>left</code> and <code>right</code>, both at the start of the array. Move the <code>right</code> pointer to check distances.</li>
<li>As long as the distance between <code>right</code> and <code>left</code> is within the allowed range, keep moving <code>right</code> forward. Once we find a distance greater than our midpoint, we know that all elements between <code>left</code> and <code>right</code> (exclusive) form valid pairs with the element at <code>left</code>. We add this count to our total and then move the <code>left</code> pointer forward. Repeat until all pairs are checked.</li>
</ul>
<p>This sliding window technique counts valid pairs in linear time for each binary search iteration. The efficiency arises because the <code>right</code> pointer doesn't need to reset for each new <code>left</code> position; it continues from where it left off, leveraging the sorted array.</p>
<p>Based on the count of pairs for the current midpoint distance, we adjust our binary search range as follows:</p>
<ul>
<li>If the count is less than <code>k</code>, we increase the distance by adjusting our lower bound.</li>
<li>If the count is greater than or equal to <code>k</code>, we decrease the distance by adjusting our upper bound.</li>
</ul>
<p>We continue this process, halving our search range each time, until the lower and upper bounds converge. At this point, we identify the <code>k</code>-th smallest pair distance.</p>
<p>The efficiency of this approach is due to the combination of binary search, which reduces the search space logarithmically, and the sliding window technique, which allows us to count pairs in linear time for each binary search iteration, given that the array is sorted.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Sort the array <code>nums</code> to simplify distance calculations.</p>
</li>
<li>
<p>Determine the size of the sorted array <code>nums</code> and store it in <code>arraySize</code>.</p>
</li>
<li>
<p>Initialize the binary search range:</p>
<ul>
<li>Set <code>low</code> to 0.</li>
<li>Set <code>high</code> to the difference between the maximum and minimum elements in <code>nums</code> (i.e., <code>nums[arraySize - 1] - nums[0]</code>).</li>
</ul>
</li>
<li>
<p>Perform binary search to find the smallest distance:</p>
<ul>
<li>While <code>low</code> is less than <code>high</code>:
<ul>
<li>Calculate the middle point <code>mid</code> as <code>(low + high) / 2</code>.</li>
<li>Count the number of pairs with distance ≤ <code>mid</code> using the helper function <code>countPairsWithMaxDistance</code>.</li>
<li>Adjust the binary search bounds:
<ul>
<li>If the count of pairs is less than <code>k</code>, set <code>low</code> to <code>mid + 1</code>.</li>
<li>Otherwise, set <code>high</code> to <code>mid</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the smallest distance found by the binary search.</p>
</li>
<li>
<p>Helper function <code>countPairsWithMaxDistance</code>:</p>
<ul>
<li>Count the number of pairs with distance ≤ <code>maxDistance</code> using a sliding window:
<ul>
<li>Initialize <code>count</code> to 0.</li>
<li>Set <code>left</code> pointer to 0.</li>
<li>Iterate with <code>right</code> pointer from 0 to the end of the array:
<ul>
<li>Adjust the <code>left</code> pointer to maintain the window where the distance between <code>nums[right]</code> and <code>nums[left]</code> is ≤ <code>maxDistance</code>.</li>
<li>Add the number of valid pairs ending at the current <code>right</code> index to <code>count</code> (i.e., <code>right - left</code>).</li>
</ul>
</li>
</ul>
</li>
<li>Return the total count of pairs with distance ≤ <code>maxDistance</code>.</li>
</ul>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/719/approach4.json:980,760!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/VeCnLoRm/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements and <span class="math inline">\(M\)</span> be the maximum possible distance.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log M + n \log n)\)</span></p>
<p>The <span class="math inline">\(O(n \log M)\)</span> term arises from the binary search over possible distances, where the search space is up to the maximum possible distance <span class="math inline">\(M\)</span>. For each mid-value in the binary search, the <code>countPairsWithMaxDistance</code> function is called, which operates in linear time <span class="math inline">\(O(n)\)</span>.</p>
<p>The binary search itself runs in <span class="math inline">\(O(\log M)\)</span> time. Hence, the combined time complexity is <span class="math inline">\(O(n \log M + n \log n)\)</span>, where the binary search and pair counting operations are combined.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(S)\)</span></p>
<p>The space complexity is constant because the algorithm only uses a fixed amount of extra space for the left and right pointers, the mid-value, and counters. It does not require additional data structures that scale with the input size, so the space complexity is <span class="math inline">\(O(1)\)</span>, excluding the space used to store the input array.</p>
<p>Some extra space is used when we sort an array of size <span class="math inline">\(n\)</span> in place. The space complexity of the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the programming language. The value of <span class="math inline">\(S\)</span> depends on the programming language and the sorting algorithm being used:</p>
<ul>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span></li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O( \log n )\)</span></li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span></li>
</ul>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(O(S)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-latest-group-of-size-m/description" target="_blank" rel="noopener noreferrer">Find Latest Group of Size M</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>arr</code> that represents a permutation of numbers from <code>1</code> to <code>n</code>.</p>

<p>You have a binary string of size <code>n</code> that initially has all its bits set to zero. At each step <code>i</code> (assuming both the binary string and <code>arr</code> are 1-indexed) from <code>1</code> to <code>n</code>, the bit at position <code>arr[i]</code> is set to <code>1</code>.</p>

<p>You are also given an integer <code>m</code>. Find the latest step at which there exists a group of ones of length <code>m</code>. A group of ones is a contiguous substring of <code>1</code>&#39;s such that it cannot be extended in either direction.</p>

<p>Return <em>the latest step at which there exists a group of ones of length <strong>exactly</strong></em> <code>m</code>. <em>If no such group exists, return</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,5,1,2,4], m = 1
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
Step 1: &quot;00<u>1</u>00&quot;, groups: [&quot;1&quot;]
Step 2: &quot;0010<u>1</u>&quot;, groups: [&quot;1&quot;, &quot;1&quot;]
Step 3: &quot;<u>1</u>0101&quot;, groups: [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]
Step 4: &quot;1<u>1</u>101&quot;, groups: [&quot;111&quot;, &quot;1&quot;]
Step 5: &quot;111<u>1</u>1&quot;, groups: [&quot;11111&quot;]
The latest step at which there exists a group of size 1 is step 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,1,5,4,2], m = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
Step 1: &quot;00<u>1</u>00&quot;, groups: [&quot;1&quot;]
Step 2: &quot;<u>1</u>0100&quot;, groups: [&quot;1&quot;, &quot;1&quot;]
Step 3: &quot;1010<u>1</u>&quot;, groups: [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]
Step 4: &quot;101<u>1</u>1&quot;, groups: [&quot;1&quot;, &quot;111&quot;]
Step 5: &quot;1<u>1</u>111&quot;, groups: [&quot;11111&quot;]
No group of size 2 exists during any step.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == arr.length</code></li>
	<li><code>1 &lt;= m &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= n</code></li>
	<li>All integers in <code>arr</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description" target="_blank" rel="noopener noreferrer">Find Longest Special Substring That Occurs Thrice I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that consists of lowercase English letters.</p>

<p>A string is called <strong>special</strong> if it is made up of only a single character. For example, the string <code>&quot;abc&quot;</code> is not special, whereas the strings <code>&quot;ddd&quot;</code>, <code>&quot;zz&quot;</code>, and <code>&quot;f&quot;</code> are special.</p>

<p>Return <em>the length of the <strong>longest special substring</strong> of </em><code>s</code> <em>which occurs <strong>at least thrice</strong></em>, <em>or </em><code>-1</code><em> if no special substring occurs at least thrice</em>.</p>

<p>A <strong>substring</strong> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaaa&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;aa&quot;: substrings &quot;<u><strong>aa</strong></u>aa&quot;, &quot;a<u><strong>aa</strong></u>a&quot;, and &quot;aa<u><strong>aa</strong></u>&quot;.
It can be shown that the maximum length achievable is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcdef&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> There exists no special substring which occurs at least thrice. Hence return -1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcaba&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;a&quot;: substrings &quot;<u><strong>a</strong></u>bcaba&quot;, &quot;abc<u><strong>a</strong></u>ba&quot;, and &quot;abcab<u><strong>a</strong></u>&quot;.
It can be shown that the maximum length achievable is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 50</code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> consisting of lowercase letters. Our task is to return the length of the longest substring of <code>s</code> that has at least 3 of the same letters - we'll call this a special substring. If no such special substring exists, we should return -1.</p>
<blockquote>
<p>A substring is a contiguous, non-empty sequence of characters within a string.</p>
</blockquote>
<p>The length of the string <code>s</code> can be at most 50. Therefore, we can use brute force techniques to solve this problem. After solving this one, you might want to try the <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/description/">harder version</a> of the problem.</p>
<hr />
<h3 id="approach-1-brute-force-approach">Approach 1: Brute-Force Approach</h3>
<h4 id="intuition">Intuition</h4>
<p>A logical approach would be to generate all substrings of the string <code>s</code> and check if each substring is special or not.</p>
<p>To generate all substrings, we can use two loop pointers: <code>start</code> and <code>end</code>. The <code>start</code> pointer indicates the starting index of the substring, and the <code>end</code> pointer indicates the ending index. We will loop through all possible values of <code>start</code> and <code>end</code> where <code>end</code> is greater than <code>start</code>. For each <code>start</code> and <code>end</code> grouping, we will extract the substring and store it in a string (say <code>currString</code>).</p>
<p>Since appending a character to the end of a list or string takes constant time, we can avoid using another loop to generate the substring. Instead, we will add the character at the <code>end</code> index to <code>currString</code>. While doing this, we can check if the newly added character maintains the &quot;special&quot; property. If the newly added character is not equal to the previous character, we can stop processing this substring further.</p>
<p>For every valid substring, we will increment its frequency in a map, where the substring is the key and its frequency is the value. After processing all substrings, we can find the longest substring in the map that has a frequency of at least three and return its length as the result.</p>
<p><img src="../Figures/2981/image1.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a map <code>count</code> to store the frequency of all substrings.</li>
<li>Iterate over the string <code>s</code> using two nested loops:
<ul>
<li>Outer loop with index <code>start</code> from 0 to the length of the string:
<ul>
<li>Create a string <code>currString</code> to store the substrings.</li>
<li>Inner loop with index <code>end</code> starting from <code>start</code> to the length of the string:
<ul>
<li>If the current substring is empty or the last character matches the current character, append the character to <code>currString</code> and increment its frequency in <code>count</code>.</li>
<li>If the current character does not match the last character, stop processing this substring.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize a variable <code>ans</code> to store the length of the longest substring with a frequency of at least 3.</li>
<li>Iterate over the map <code>count</code>:
<ul>
<li>For each substring, if its frequency is at least 3 and its length is greater than <code>ans</code>, update <code>ans</code> with the length of the substring.</li>
</ul>
</li>
<li>If no substring with the required frequency is found, return -1. Otherwise, return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/K9YykFH9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^3)\)</span></p>
<p>The algorithm generates all substrings of the input string <code>s</code> using two nested loops. The outer loop runs <code>n</code> times. For each iteration of the outer loop, the inner loop iterates <code>n - i</code> times, where <code>i</code> is the index of the outer loop. This means the total number of iterations is the sum of the first <code>n</code> natural numbers, which equals <span class="math inline">\(n \cdot (n+1) / 2\)</span>. Therefore, the time complexity for generating all substrings is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For each substring, the algorithm checks and updates the frequency in a map, which takes <span class="math inline">\(O(size)\)</span> time, where <code>size</code> denotes the length of the substring added in the map.</p>
<p>Therefore, the overall time complexity of the algorithm is given by O(n^3).</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a temporary string, <code>currString</code>, to store substrings. The size of <code>currString</code> varies, but in the worst case, it can hold the entire string, contributing <span class="math inline">\(O(n)\)</span> additional space. Since the string <code>currString</code> is initialized <code>n</code> times, the total space is given by <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The algorithm uses a map to store all unique substrings and their frequencies. In the worst case, such as when all characters in the string are identical, the total number of substrings can go up to <span class="math inline">\(n \cdot (n+1) / 2\)</span>. Additionally, each substring requires space proportional to its length, leading to an overall space requirement of <span class="math inline">\(O(n^2)\)</span> in the worst case.</p>
<p>Therefore, the total space complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-hashing">Approach 2: Optimized Hashing</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we stored substrings in a map with their frequency. Since all special substrings consist of equal characters, we can optimize by storing them as a pair <code>{char character, int substringLength}</code>.</p>
<p>This optimization improves the algorithm because adding a string to the map takes <code>O(substringLength)</code> time. By storing <code>{character, substringLength}</code> as a pair, which behaves like an array of length 2, insertion into the map now takes constant time.</p>
<p>After populating the map with these pairs, we find the maximum <code>substringLength</code> value for any pair with a frequency of at least 3 and return it as the result.</p>
<blockquote>
<p>Note: A frequency array can also be used in this scenario. It is a good choice as it provides an efficient way to count and track occurrences, particularly when the range of values is limited.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a map <code>count</code> of type <code>map&lt;pair&lt;char, int&gt;, int&gt;</code> to store the frequency of substrings, where each key is a pair of a character and the substring length, and the value is its frequency.</li>
<li>Use an outer loop with index <code>start</code> from <code>0</code> to the length of the string (<code>s.length()</code>):
<ul>
<li>Initialize <code>substringLength</code> to <code>0</code> to track the length of the current substring of repeated characters.</li>
<li>Store the current character <code>character = s[start]</code>.</li>
</ul>
</li>
<li>Use an inner loop with index <code>end</code> starting from <code>start</code> and iterating to the end of the string (<code>s.length()</code>):
<ul>
<li>If the character <code>s[end]</code> matches <code>character</code>:
<ul>
<li>Increment <code>substringLength</code>.</li>
<li>Update the frequency of the pair <code>{character, substringLength}</code> in the <code>count</code> map.</li>
</ul>
</li>
<li>If the character <code>s[end]</code> does not match <code>c</code>, break the loop.</li>
</ul>
</li>
<li>Initialize a variable <code>ans</code> to <code>-1</code>.</li>
<li>Iterate over the entries in the <code>count</code> map:
<ul>
<li>For each entry, check if its frequency is at least 3 and its substring length is greater than <code>ans</code>. If both conditions are true, update <code>ans</code> with the length of the substring.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/RTh9x9yB/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm generates all substrings of the input string <code>s</code> using two nested loops. The outer loop runs <code>n</code> times. For each iteration of the outer loop, the inner loop iterates <code>n - end</code> times, where <code>end</code> is the index of the outer loop. This means the total number of iterations is the sum of the first <code>n</code> natural numbers, which equals <span class="math inline">\(n \cdot (n+1) / 2\)</span>. Therefore, the time complexity for generating all substrings is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For each substring, the algorithm checks and updates the frequency of the pair in a map, which takes <span class="math inline">\(O(1)\)</span> time.</p>
<p>Therefore, the overall time complexity of the algorithm is given by O(n^2).</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a map to store all unique substrings and their frequencies. In the worst case, such as when all characters in the string are identical, the total number of substrings can go up to <span class="math inline">\(n \cdot (n+1) / 2\)</span>.</p>
<p>Additionally, each substring requires space proportional to its length, leading to an overall space requirement of <span class="math inline">\(O(n^2)\)</span> in the worst case.</p>
<p>Therefore, the total space complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="further-thoughts">Further Thoughts:</h3>
<p>This problem has solutions with time complexities of <span class="math inline">\(O(n^3)\)</span> and <span class="math inline">\(O(n^2)\)</span>, but there is an even more efficient solution that runs in <span class="math inline">\(O(n)\)</span> time.</p>
<p>The single pass solution will be the focus of the second part of this <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/">problem</a>, which is designed almost the same but with tighter constraints to encourage further optimization. We now recommend attempting to solve the second part using the single pass approach.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/description" target="_blank" rel="noopener noreferrer">Find Longest Special Substring That Occurs Thrice II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that consists of lowercase English letters.</p>

<p>A string is called <strong>special</strong> if it is made up of only a single character. For example, the string <code>&quot;abc&quot;</code> is not special, whereas the strings <code>&quot;ddd&quot;</code>, <code>&quot;zz&quot;</code>, and <code>&quot;f&quot;</code> are special.</p>

<p>Return <em>the length of the <strong>longest special substring</strong> of </em><code>s</code> <em>which occurs <strong>at least thrice</strong></em>, <em>or </em><code>-1</code><em> if no special substring occurs at least thrice</em>.</p>

<p>A <strong>substring</strong> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaaa&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;aa&quot;: substrings &quot;<u><strong>aa</strong></u>aa&quot;, &quot;a<u><strong>aa</strong></u>a&quot;, and &quot;aa<u><strong>aa</strong></u>&quot;.
It can be shown that the maximum length achievable is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcdef&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> There exists no special substring which occurs at least thrice. Hence return -1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcaba&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;a&quot;: substrings &quot;<u><strong>a</strong></u>bcaba&quot;, &quot;abc<u><strong>a</strong></u>ba&quot;, and &quot;abcab<u><strong>a</strong></u>&quot;.
It can be shown that the maximum length achievable is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> consisting of lowercase letters. A string is considered special if all its characters are the same. Our task is to find the longest special substring of <code>s</code> that appears at least three times. If no such substring exists, we should return -1.</p>
<blockquote>
<p>A substring is a contiguous, non-empty sequence of characters within a string.</p>
</blockquote>
<p>This problem is a more challenging version of the first part, <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/">2981. Find Longest Special Substring That Occurs Thrice I</a>. The constraints are significantly tighter, with the length of the string <code>s</code> now reaching up to 500,000 characters. This makes the problem more complex and resource-intensive to solve. Before tackling this harder version, it is strongly advised that you first solve the <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description/">easier version</a> of the problem. Solving the easier version will give you a solid understanding of the core concepts and techniques needed to approach the more demanding iteration.</p>
<p>In the first part, we discussed two solutions: an <span class="math inline">\(O(n^3)\)</span> solution and an <span class="math inline">\(O(n^2)\)</span> solution. Here, we will focus on more optimized versions of these solutions to ensure they can handle the tighter constraints and pass the test cases efficiently.</p>
<hr />
<h3 id="approach-1-hashing">Approach 1: Hashing</h3>
<h4 id="intuition">Intuition</h4>
<p>In the simpler version of this problem, we generated all substrings of <code>s</code> and tracked their counts using a map. However, in this version, we aim to find a more efficient approach—ideally, linear or log-linear. Therefore, we cannot afford to generate all substrings of <code>s</code>.</p>
<p>To optimize, we can focus on the special substrings of <code>s</code>. This means we don't need to generate all substrings and then filter for special ones. Instead, let's analyze some examples to understand the pattern:</p>
<ol>
<li>
<p>Example 1: <code>a</code></p>
<ul>
<li>There is exactly one special substring: <code>a</code>.</li>
</ul>
</li>
<li>
<p>Example 2: <code>aa</code></p>
<ul>
<li>There are three special substrings: <code>a</code>, <code>a</code>, <code>aa</code>.</li>
<li>Here, <code>a</code> appears twice and <code>aa</code> appears once.</li>
</ul>
</li>
<li>
<p>Example 3: <code>aaa</code></p>
<ul>
<li>There are six special substrings: <code>a</code>, <code>a</code>, <code>a</code>, <code>aa</code>, <code>aa</code>, <code>aaa</code>.</li>
<li>Here, <code>a</code> appears thrice, <code>aa</code> appears twice, and <code>aaa</code> appears once.</li>
</ul>
</li>
</ol>
<p>From these examples, we can make an observation:<br />
When a new character is added to <code>s</code>, if the length of the longest special substring ending at this character increases to <code>substringLength</code>, then the count of all shorter special substrings of length less than <code>substringLength</code> also increments by 1. This happens because new substrings can be formed by appending the current character to previously existing substrings.</p>
<p>While iterating through the string <code>s</code>, <code>substringLength</code> represents the length of the longest special substring ending at the current character. We can store the count of characters in <code>s</code> with the longest special substring length <code>substringLength</code> using a mapping, <code>frequency[character][substringLength]</code>.</p>
<p>As discussed, all substrings of lengths less than <code>substringLength</code> should also be incremented by the value of <code>frequency[character][substringLength]</code>. However, updating the frequencies for all lengths down to <code>1</code> each time a new character is processed would be inefficient.</p>
<p>To optimize this, we can calculate the cumulative sum of frequencies starting from the longest <code>substringLength</code> down to <code>1</code>, after processing all the characters of the string. If the cumulative sum reaches a value of <code>3</code> at any point, we can immediately conclude that there are at least <code>3</code> substrings of that length. We can repeat this process for all the possible <code>character</code> values and return the maximum result among them.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a map <code>frequency</code> to store the frequency of substrings.
<ul>
<li><code>frequency</code> is a 2D array where the first index represents the character and the second index represents the length of consecutive substrings.</li>
</ul>
</li>
<li>Initialize <code>substringLength</code> to 1 and <code>previousCharacter</code> to the first character, and set the frequency of the first character at length 1 to 1: <code>frequency[previousCharacter - 'a'][1] = 1</code>.</li>
<li>For each character in the string:
<ul>
<li>If the current character equals the previous character:
<ul>
<li>Increment <code>substringLength</code>.</li>
<li>Increment the frequency of the current character for the new substring length: <code>frequency[currentCharacter - 'a'][substringLength] += 1</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Reset <code>substringLength</code> to 1 and update the frequency of the current character for substring length 1: <code>frequency[currentCharacter - 'a'][1] += 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Calculate cumulative sums for the frequencies:
<ul>
<li>Outer loop iterates over all 26 characters:
<ul>
<li>Inner loop starts from the longest possible substring length (from the end of the string) and moves backward:
<ul>
<li>Update <code>frequency[i][j]</code> by adding the value from the next substring length: <code>frequency[i][j] += frequency[i][j + 1]</code>.</li>
<li>If <code>frequency[i][j] &gt;= 3</code>, it indicates that we have at least 3 substrings of the current length:
<ul>
<li>Update <code>ans</code> with the length <code>j</code> if it is greater than the current value of <code>ans</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the result, and if no valid substring is found, return <code>-1</code>. Otherwise, return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NyxcGzaS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code> and <span class="math inline">\(c\)</span> be the number of distinct characters (which is 26 in this case).</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + c \cdot n) \approx O(n)\)</span></p>
<p>The algorithm iterates through the string <code>s</code> once, performing constant-time operations for each character to update the <code>frequency</code> array. This results in a time complexity of <span class="math inline">\(O(n)\)</span>. Additionally, the nested loop that calculates the cumulative sum and finds the maximum possible answer iterates over the <code>frequency</code> array, which has dimensions <span class="math inline">\(26 \times (n + 1)\)</span>. This results in a time complexity of <span class="math inline">\(O(c \cdot n)\)</span>. Therefore, the overall time complexity is <span class="math inline">\(O(n + c \cdot n) \approx O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(c \cdot n) \approx O(n)\)</span></p>
<p>The space used by the algorithm is determined by the <code>frequency</code> array, which has a size of <span class="math inline">\(26 \times (n + 1)\)</span>. Thus, the space complexity is <span class="math inline">\(O(c \cdot n) \approx O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-store-the-three-maximum-substring-lengths">Approach 2: Store the Three Maximum Substring Lengths</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we stopped iterating through the string <code>s</code> once the cumulative sum reached at least <code>3</code>. However, we can optimize this by focusing on the fact that we are searching for the longest substring that occurs at least three times. Instead of maintaining a mapping to store the frequency of substring lengths for all characters, we can simplify the process by directly tracking the maximum lengths using integer variables.</p>
<p>Since we are looking for the longest substring that occurs at least three times, we can store the lengths of the three longest substrings in three integer variables. It is guaranteed that at least one of these will occur at least three times in the string <code>s</code>.</p>
<p>For example:</p>
<ul>
<li>
<p>If the longest substring lengths are <code>length1 = 8</code>, <code>length2 = 8</code>, and <code>length3 = 8</code>, then <code>8</code> is the length of the longest substring that occurs at least three times.</p>
</li>
<li>
<p>If the lengths are <code>length1 = 8</code>, <code>length2 = 8</code>, and <code>length3 = 7</code>, the substring of length <code>7</code> is part of the substrings of length <code>8</code>. In this case, the frequency of the substring of length <code>7</code> ensures it occurs at least three times, making <code>7</code> the desired length.</p>
</li>
<li>
<p>If the lengths are <code>length1 = 6</code>, <code>length2 = 8</code>, and <code>length3 = 7</code>, the substring of length <code>7</code> also occurs as part of the substring of length <code>8</code>. However, the cumulative frequency of substrings of length <code>7</code> may not meet the threshold, so the third-largest length, <code>6</code>, is returned as the result.</p>
</li>
</ul>
<p>To implement this, we use a data structure like <code>substringLengths[character][3]</code>, where the array <code>substringLengths[character]</code> stores the three longest substring lengths for each character. While iterating through the string <code>s</code>, if the current character matches the previous one, we increment a <code>substringLength</code> counter. If the updated length belongs among the three longest substrings for that character, we update the <code>substringLengths</code> array accordingly.</p>
<p>Finally, after processing all characters of <code>s</code>, we return the maximum value of the smallest length in the <code>substringLengths</code> array for all characters.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a matrix <code>substringLengths</code> of size <code>26 x 3</code> to track the maximum lengths of substrings.</li>
<li>Initialize <code>substringLength</code> to <code>0</code> to track the length of the current substring of repeated characters.</li>
<li>Initialize <code>previousCharacter</code> to <code>0</code> (or the first character of the string) to compare the consecutive characters.</li>
<li>Iterate over the string from <code>start</code> = <code>0</code> to <code>s.length()</code>:
<ul>
<li>If the current character matches the previous character, increment <code>substringLength</code>.</li>
<li>If it does not match, reset <code>substringLength</code> to <code>1</code> and update the <code>previousCharacter</code>.</li>
<li>Find the minimum length among the three values for the current character, and store it in <code>minLength</code>.</li>
</ul>
</li>
<li>Iterate over the <code>substringLengths</code> array and find the maximum substring length where its length is at least <code>3</code>.</li>
<li>If no valid substring length is found, return <code>-1</code>. Otherwise, return the maximum length.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5aJHgMJW/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>, <span class="math inline">\(c\)</span> the number of distinct characters (which is 26 in this case), and <span class="math inline">\(k = 3\)</span> the number of tracked substring lengths per character.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the string <code>s</code> once, performing constant-time operations for each character. For each character, it updates the <code>substringLengths</code> array, which involves checking and updating up to <span class="math inline">\(k\)</span> values. Additionally, the final loop to find the maximum value of the minimum frequency iterates over all distinct characters. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(c \cdot k) \approx O(1)\)</span></p>
<p>The space used by the algorithm is determined by the <code>substringLengths</code> array, which has a size of <span class="math inline">\(c \times k\)</span>. The other variables used (e.g., <code>substringLength</code>, <code>previousCharacter</code>, <code>ans</code>) consume constant space. Thus, the space complexity is <span class="math inline">\(O(c \cdot k) \approx O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-maximum-non-decreasing-array-length/description" target="_blank" rel="noopener noreferrer">Find Maximum Non-decreasing Array Length</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>You can perform any number of operations, where each operation involves selecting a <strong>subarray</strong> of the array and replacing it with the <strong>sum</strong> of its elements. For example, if the given array is <code>[1,3,5,6]</code> and you select subarray <code>[3,5]</code> the array will convert to <code>[1,8,6]</code>.</p>

<p>Return <em>the </em><strong><em>maximum</em></strong><em> length of a </em><strong><em>non-decreasing</em></strong><em> array that can be made after applying operations.</em></p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,2,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> This array with length 3 is not non-decreasing.
We have two ways to make the array length two.
First, choosing subarray [2,2] converts the array to [5,4].
Second, choosing subarray [5,2] converts the array to [7,2].
In these two ways the array is not non-decreasing.
And if we choose subarray [5,2,2] and replace it with [9] it becomes non-decreasing. 
So the answer is 1.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The array is non-decreasing. So the answer is 4.
</pre>

<p><strong>Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Replacing [3,2] with [5] converts the given array to [4,5,6] that is non-decreasing.
Because the given array is not non-decreasing, the maximum<!-- notionvc: 3447a505-d1ee-4411-8cae-e52162f53a55 --> possible answer is 3.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-in-rotated-sorted-array/description" target="_blank" rel="noopener noreferrer">Find Minimum in Rotated Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>

<ul>
	<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>
	<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>
</ul>

<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>

<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>

<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,5,1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,6,7,0,1,2]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [11,13,15,17]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 5000</code></li>
	<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
	<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>
	<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description" target="_blank" rel="noopener noreferrer">Find Minimum in Rotated Sorted Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>

<ul>
	<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>
	<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>
</ul>

<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>

<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>

<p>You must decrease the overall operation steps as much as possible.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,3,5]
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [2,2,2,0,1]
<strong>Output:</strong> 0
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 5000</code></li>
	<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
	<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank">Find Minimum in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>

<p>&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-pair-given-difference1559/1" target="_blank" rel="noopener noreferrer">Find Pair Given Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array, <strong>arr[]</strong>&nbsp;and an integer <strong>x</strong>, return true if there exists a pair of elements in the array whose absolute difference is <strong>x</strong>, otherwise, return false.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [5, 20, 3, 2, 5, 80], x = 78<strong>
Output: </strong>true
<strong>Explanation: </strong>Pair (2, 80) have an absolute difference of 78.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [90, 70, 20, 80, 50], x = 45
<strong>Output: </strong>false
<strong>Explanation: </strong>There is no pair with absolute difference of 45.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1], x = 1
<strong>Output: </strong>false</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1&lt;= arr.size() &lt;=10<sup>6&nbsp;</sup><br />1&lt;= arr[i] &lt;=10<sup>6&nbsp;<br /></sup>0&lt;= x &lt;=10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-peak-element/description" target="_blank" rel="noopener noreferrer">Find Peak Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A peak element is an element that is strictly greater than its neighbors.</p>

<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>

<p>You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p>

<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,3,5,6,4]
<strong>Output:</strong> 5
<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-positive-integer-solution-for-a-given-equation/description" target="_blank" rel="noopener noreferrer">Find Positive Integer Solution for a Given Equation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">interactive</span> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a callable function <code>f(x, y)</code> <strong>with a hidden formula</strong> and a value <code>z</code>, reverse engineer the formula and return <em>all positive integer pairs </em><code>x</code><em> and </em><code>y</code><em> where </em><code>f(x,y) == z</code>. You may return the pairs in any order.</p>

<p>While the exact formula is hidden, the function is monotonically increasing, i.e.:</p>

<ul>
	<li><code>f(x, y) &lt; f(x + 1, y)</code></li>
	<li><code>f(x, y) &lt; f(x, y + 1)</code></li>
</ul>

<p>The function interface is defined like this:</p>

<pre>
interface CustomFunction {
public:
  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.
  int f(int x, int y);
};
</pre>

<p>We will judge your solution as follows:</p>

<ul>
	<li>The judge has a list of <code>9</code> hidden implementations of <code>CustomFunction</code>, along with a way to generate an <strong>answer key</strong> of all valid pairs for a specific <code>z</code>.</li>
	<li>The judge will receive two inputs: a <code>function_id</code> (to determine which implementation to test your code with), and the target <code>z</code>.</li>
	<li>The judge will call your <code>findSolution</code> and compare your results with the <strong>answer key</strong>.</li>
	<li>If your results match the <strong>answer key</strong>, your solution will be <code>Accepted</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> function_id = 1, z = 5
<strong>Output:</strong> [[1,4],[2,3],[3,2],[4,1]]
<strong>Explanation:</strong> The hidden formula for function_id = 1 is f(x, y) = x + y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=4 -&gt; f(1, 4) = 1 + 4 = 5.
x=2, y=3 -&gt; f(2, 3) = 2 + 3 = 5.
x=3, y=2 -&gt; f(3, 2) = 3 + 2 = 5.
x=4, y=1 -&gt; f(4, 1) = 4 + 1 = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> function_id = 2, z = 5
<strong>Output:</strong> [[1,5],[5,1]]
<strong>Explanation:</strong> The hidden formula for function_id = 2 is f(x, y) = x * y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=5 -&gt; f(1, 5) = 1 * 5 = 5.
x=5, y=1 -&gt; f(5, 1) = 5 * 1 = 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= function_id &lt;= 9</code></li>
	<li><code>1 &lt;= z &lt;= 100</code></li>
	<li>It is guaranteed that the solutions of <code>f(x, y) == z</code> will be in the range <code>1 &lt;= x, y &lt;= 1000</code>.</li>
	<li>It is also guaranteed that <code>f(x, y)</code> will fit in 32 bit signed integer if <code>1 &lt;= x, y &lt;= 1000</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-products-of-elements-of-big-array/description" target="_blank" rel="noopener noreferrer">Find Products of Elements of Big Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>powerful array</strong> of a non-negative integer <code>x</code> is defined as the shortest sorted array of powers of two that sum up to <code>x</code>. The table below illustrates examples of how the <strong>powerful array</strong> is determined. It can be proven that the powerful array of <code>x</code> is unique.</p>

<table border="1">
	<tbody>
		<tr>
			<th>num</th>
			<th>Binary Representation</th>
			<th>powerful array</th>
		</tr>
		<tr>
			<td>1</td>
			<td>0000<u>1</u></td>
			<td>[1]</td>
		</tr>
		<tr>
			<td>8</td>
			<td>0<u>1</u>000</td>
			<td>[8]</td>
		</tr>
		<tr>
			<td>10</td>
			<td>0<u>1</u>0<u>1</u>0</td>
			<td>[2, 8]</td>
		</tr>
		<tr>
			<td>13</td>
			<td>0<u>11</u>0<u>1</u></td>
			<td>[1, 4, 8]</td>
		</tr>
		<tr>
			<td>23</td>
			<td><u>1</u>0<u>111</u></td>
			<td>[1, 2, 4, 16]</td>
		</tr>
	</tbody>
</table>

<p>The array <code>big_nums</code> is created by concatenating the <strong>powerful arrays</strong> for every positive integer <code>i</code> in ascending order: 1, 2, 3, and so on. Thus, <code>big_nums</code> begins as <code>[<u>1</u>, <u>2</u>, <u>1, 2</u>, <u>4</u>, <u>1, 4</u>, <u>2, 4</u>, <u>1, 2, 4</u>, <u>8</u>, ...]</code>.</p>

<p>You are given a 2D integer matrix <code>queries</code>, where for <code>queries[i] = [from<sub>i</sub>, to<sub>i</sub>, mod<sub>i</sub>]</code> you should calculate <code>(big_nums[from<sub>i</sub>] * big_nums[from<sub>i</sub> + 1] * ... * big_nums[to<sub>i</sub>]) % mod<sub>i</sub></code><!-- notionvc: a71131cc-7b52-4786-9a4b-660d6d864f89 -->.</p>

<p>Return an integer array <code>answer</code> such that <code>answer[i]</code> is the answer to the <code>i<sup>th</sup></code> query.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">queries = [[1,3,7]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4]</span></p>

<p><strong>Explanation:</strong></p>

<p>There is one query.</p>

<p><code>big_nums[1..3] = [2,1,2]</code>. The product of them is 4. The result is <code>4 % 7 = 4.</code></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">queries = [[2,5,3],[7,7,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p>There are two queries.</p>

<p>First query: <code>big_nums[2..5] = [1,2,4,1]</code>. The product of them is 8. The result is <code>8 % 3 = 2</code>.</p>

<p>Second query: <code>big_nums[7] = 2</code>. The result is <code>2 % 4 = 2</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= queries.length &lt;= 500</code></li>
	<li><code>queries[i].length == 3</code></li>
	<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;= 10<sup>15</sup></code></li>
	<li><code>1 &lt;= queries[i][2] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-right-interval/description" target="_blank" rel="noopener noreferrer">Find Right Interval</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <code>intervals</code>, where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> and each <code>start<sub>i</sub></code> is <strong>unique</strong>.</p>

<p>The <strong>right interval</strong> for an interval <code>i</code> is an interval <code>j</code> such that <code>start<sub>j</sub> &gt;= end<sub>i</sub></code> and <code>start<sub>j</sub></code> is <strong>minimized</strong>. Note that <code>i</code> may equal <code>j</code>.</p>

<p>Return <em>an array of <strong>right interval</strong> indices for each interval <code>i</code></em>. If no <strong>right interval</strong> exists for interval <code>i</code>, then put <code>-1</code> at index <code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,2]]
<strong>Output:</strong> [-1]
<strong>Explanation:</strong> There is only one interval in the collection, so it outputs -1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[3,4],[2,3],[1,2]]
<strong>Output:</strong> [-1,0,1]
<strong>Explanation:</strong> There is no right interval for [3,4].
The right interval for [2,3] is [3,4] since start<sub>0</sub> = 3 is the smallest start that is &gt;= end<sub>1</sub> = 3.
The right interval for [1,2] is [2,3] since start<sub>1</sub> = 2 is the smallest start that is &gt;= end<sub>2</sub> = 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,4],[2,3],[3,4]]
<strong>Output:</strong> [-1,2,-1]
<strong>Explanation:</strong> There is no right interval for [1,4] and [3,4].
The right interval for [2,3] is [3,4] since start<sub>2</sub> = 3 is the smallest start that is &gt;= end<sub>1</sub> = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= intervals.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>-10<sup>6</sup> &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>The start point of each interval is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-smallest-letter-greater-than-target/description" target="_blank" rel="noopener noreferrer">Find Smallest Letter Greater Than Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of characters <code>letters</code> that is sorted in <strong>non-decreasing order</strong>, and a character <code>target</code>. There are <strong>at least two different</strong> characters in <code>letters</code>.</p>

<p>Return <em>the smallest character in </em><code>letters</code><em> that is lexicographically greater than </em><code>target</code>. If such a character does not exist, return the first character in <code>letters</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;a&quot;
<strong>Output:</strong> &quot;c&quot;
<strong>Explanation:</strong> The smallest character that is lexicographically greater than &#39;a&#39; in letters is &#39;c&#39;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;c&quot;
<strong>Output:</strong> &quot;f&quot;
<strong>Explanation:</strong> The smallest character that is lexicographically greater than &#39;c&#39; in letters is &#39;f&#39;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> letters = [&quot;x&quot;,&quot;x&quot;,&quot;y&quot;,&quot;y&quot;], target = &quot;z&quot;
<strong>Output:</strong> &quot;x&quot;
<strong>Explanation:</strong> There are no characters in letters that is lexicographically greater than &#39;z&#39; so we return letters[0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= letters.length &lt;= 10<sup>4</sup></code></li>
	<li><code>letters[i]</code> is a lowercase English letter.</li>
	<li><code>letters</code> is sorted in <strong>non-decreasing</strong> order.</li>
	<li><code>letters</code> contains at least two different characters.</li>
	<li><code>target</code> is a lowercase English letter.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-subarray-with-bitwise-or-closest-to-k/description" target="_blank" rel="noopener noreferrer">Find Subarray With Bitwise OR Closest to K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> and an integer <code>k</code>. You need to find a <span data-keyword="subarray-nonempty">subarray</span> of <code>nums</code> such that the <strong>absolute difference</strong> between <code>k</code> and the bitwise <code>OR</code> of the subarray elements is as<strong> small</strong> as possible. In other words, select a subarray <code>nums[l..r]</code> such that <code>|k - (nums[l] OR nums[l + 1] ... OR nums[r])|</code> is minimum.</p>

<p>Return the <strong>minimum</strong> possible value of the absolute difference.</p>

<p>A <strong>subarray</strong> is a contiguous <b>non-empty</b> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,4,5], k = 3</span></p>

<p><strong>Output:</strong> 0</p>

<p><strong>Explanation:</strong></p>

<p>The subarray <code>nums[0..1]</code> has <code>OR</code> value 3, which gives the minimum absolute difference <code>|3 - 3| = 0</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,3,1,3], k = 2</span></p>

<p><strong>Output:</strong> 1</p>

<p><strong>Explanation:</strong></p>

<p>The subarray <code>nums[1..1]</code> has <code>OR</code> value 3, which gives the minimum absolute difference <code>|3 - 2| = 1</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong></p>

<p>There is a single subarray with <code>OR</code> value 1, which gives the minimum absolute difference <code>|10 - 1| = 9</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-target-indices-after-sorting-array/description" target="_blank" rel="noopener noreferrer">Find Target Indices After Sorting Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and a target element <code>target</code>.</p>

<p>A <strong>target index</strong> is an index <code>i</code> such that <code>nums[i] == target</code>.</p>

<p>Return <em>a list of the target indices of</em> <code>nums</code> after<em> sorting </em><code>nums</code><em> in <strong>non-decreasing</strong> order</em>. If there are no target indices, return <em>an <strong>empty</strong> list</em>. The returned list must be sorted in <strong>increasing</strong> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,5,2,3], target = 2
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> After sorting, nums is [1,<u><strong>2</strong></u>,<u><strong>2</strong></u>,3,5].
The indices where nums[i] == 2 are 1 and 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,5,2,3], target = 3
<strong>Output:</strong> [3]
<strong>Explanation:</strong> After sorting, nums is [1,2,2,<u><strong>3</strong></u>,5].
The index where nums[i] == 3 is 3.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,5,2,3], target = 5
<strong>Output:</strong> [4]
<strong>Explanation:</strong> After sorting, nums is [1,2,2,3,<u><strong>5</strong></u>].
The index where nums[i] == 5 is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i], target &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-distance-value-between-two-arrays/description" target="_blank" rel="noopener noreferrer">Find the Distance Value Between Two Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>arr1</code> and <code>arr2</code>, and the integer <code>d</code>, <em>return the distance value between the two arrays</em>.</p>

<p>The distance value is defined as the number of elements <code>arr1[i]</code> such that there is not any element <code>arr2[j]</code> where <code>|arr1[i]-arr2[j]| &lt;= d</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
For arr1[0]=4 we have: 
|4-10|=6 &gt; d=2 
|4-9|=5 &gt; d=2 
|4-1|=3 &gt; d=2 
|4-8|=4 &gt; d=2 
For arr1[1]=5 we have: 
|5-10|=5 &gt; d=2 
|5-9|=4 &gt; d=2 
|5-1|=4 &gt; d=2 
|5-8|=3 &gt; d=2
For arr1[2]=8 we have:
<strong>|8-10|=2 &lt;= d=2</strong>
<strong>|8-9|=1 &lt;= d=2</strong>
|8-1|=7 &gt; d=2
<strong>|8-8|=0 &lt;= d=2</strong>
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li>
	<li><code>-1000 &lt;= arr1[i], arr2[j] &lt;= 1000</code></li>
	<li><code>0 &lt;= d &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-duplicate-number/description" target="_blank" rel="noopener noreferrer">Find the Duplicate Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> containing&nbsp;<code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>

<p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this&nbsp;repeated&nbsp;number</em>.</p>

<p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code>&nbsp;and using only constant extra space.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,4,2,2]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,3,4,2]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3,3,3,3]
<strong>Output:</strong> 3</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>nums.length == n + 1</code></li>
	<li><code>1 &lt;= nums[i] &lt;= n</code></li>
	<li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li>
</ul>

<p>&nbsp;</p>
<p><b>Follow up:</b></p>

<ul>
	<li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li>
	<li>Can you solve the problem in linear runtime complexity?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/description" target="_blank" rel="noopener noreferrer">Find the Kth Smallest Sum of a Matrix With Sorted Rows</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>mat</code> that has its rows sorted in non-decreasing order and an integer <code>k</code>.</p>

<p>You are allowed to choose <strong>exactly one element</strong> from each row to form an array.</p>

<p>Return <em>the </em><code>k<sup>th</sup></code><em> smallest array sum among all possible arrays</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,3,11],[2,4,6]], k = 5
<strong>Output:</strong> 7
<strong>Explanation:</strong> Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,3,11],[2,4,6]], k = 9
<strong>Output:</strong> 17
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
<strong>Output:</strong> 9
<strong>Explanation:</strong> Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat.length[i]</code></li>
	<li><code>1 &lt;= m, n &lt;= 40</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>
	<li><code>1 &lt;= k &lt;= min(200, n<sup>m</sup>)</code></li>
	<li><code>mat[i]</code> is a non-decreasing array.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-longest-equal-subarray/description" target="_blank" rel="noopener noreferrer">Find the Longest Equal Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>.</p>

<p>A subarray is called <strong>equal</strong> if all of its elements are equal. Note that the empty subarray is an <strong>equal</strong> subarray.</p>

<p>Return <em>the length of the <strong>longest</strong> possible equal subarray after deleting <strong>at most</strong> </em><code>k</code><em> elements from </em><code>nums</code>.</p>

<p>A <b>subarray</b> is a contiguous, possibly empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,2,3,1,3], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> It&#39;s optimal to delete the elements at index 2 and index 4.
After deleting them, nums becomes equal to [1, 3, 3, 3].
The longest equal subarray starts at i = 1 and ends at j = 3 with length equal to 3.
It can be proven that no longer equal subarrays can be created.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,2,1,1], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> It&#39;s optimal to delete the elements at index 2 and index 3.
After deleting them, nums becomes equal to [1, 1, 1, 1].
The array itself is an equal subarray, so the answer is 4.
It can be proven that no longer equal subarrays can be created.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
	<li><code>0 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/description" target="_blank" rel="noopener noreferrer">Find the Longest Valid Obstacle Course at Each Position</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You want to build some obstacle courses. You are given a <strong>0-indexed</strong> integer array <code>obstacles</code> of length <code>n</code>, where <code>obstacles[i]</code> describes the height of the <code>i<sup>th</sup></code> obstacle.</p>

<p>For every index <code>i</code> between <code>0</code> and <code>n - 1</code> (<strong>inclusive</strong>), find the length of the <strong>longest obstacle course</strong> in <code>obstacles</code> such that:</p>

<ul>
	<li>You choose any number of obstacles between <code>0</code> and <code>i</code> <strong>inclusive</strong>.</li>
	<li>You must include the <code>i<sup>th</sup></code> obstacle in the course.</li>
	<li>You must put the chosen obstacles in the <strong>same order</strong> as they appear in <code>obstacles</code>.</li>
	<li>Every obstacle (except the first) is <strong>taller</strong> than or the <strong>same height</strong> as the obstacle immediately before it.</li>
</ul>

<p>Return <em>an array</em> <code>ans</code> <em>of length</em> <code>n</code>, <em>where</em> <code>ans[i]</code> <em>is the length of the <strong>longest obstacle course</strong> for index</em> <code>i</code><em> as described above</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> obstacles = [1,2,3,2]
<strong>Output:</strong> [1,2,3,3]
<strong>Explanation:</strong> The longest valid obstacle course at each position is:
- i = 0: [<u>1</u>], [1] has length 1.
- i = 1: [<u>1</u>,<u>2</u>], [1,2] has length 2.
- i = 2: [<u>1</u>,<u>2</u>,<u>3</u>], [1,2,3] has length 3.
- i = 3: [<u>1</u>,<u>2</u>,3,<u>2</u>], [1,2,2] has length 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> obstacles = [2,2,1]
<strong>Output:</strong> [1,2,1]
<strong>Explanation: </strong>The longest valid obstacle course at each position is:
- i = 0: [<u>2</u>], [2] has length 1.
- i = 1: [<u>2</u>,<u>2</u>], [2,2] has length 2.
- i = 2: [2,2,<u>1</u>], [1] has length 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> obstacles = [3,1,5,6,4,2]
<strong>Output:</strong> [1,1,2,3,2,2]
<strong>Explanation:</strong> The longest valid obstacle course at each position is:
- i = 0: [<u>3</u>], [3] has length 1.
- i = 1: [3,<u>1</u>], [1] has length 1.
- i = 2: [<u>3</u>,1,<u>5</u>], [3,5] has length 2. [1,5] is also valid.
- i = 3: [<u>3</u>,1,<u>5</u>,<u>6</u>], [3,5,6] has length 3. [1,5,6] is also valid.
- i = 4: [<u>3</u>,1,5,6,<u>4</u>], [3,4] has length 2. [1,4] is also valid.
- i = 5: [3,<u>1</u>,5,6,4,<u>2</u>], [1,2] has length 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == obstacles.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-maximum-number-of-marked-indices/description" target="_blank" rel="noopener noreferrer">Find the Maximum Number of Marked Indices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:</p>

<ul>
	<li>Pick two <strong>different unmarked</strong> indices <code>i</code> and <code>j</code> such that <code>2 * nums[i] &lt;= nums[j]</code>, then mark <code>i</code> and <code>j</code>.</li>
</ul>

<p>Return <em>the maximum possible number of marked indices in <code>nums</code> using the above operation any number of times</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,2,4]
<strong>Output:</strong> 2
<strong>Explanation: </strong>In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] &lt;= nums[1]. Then mark index 2 and 1.
It can be shown that there&#39;s no other valid operation so the answer is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,2,5,4]
<strong>Output:</strong> 4
<strong>Explanation: </strong>In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] &lt;= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] &lt;= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,6,8]
<strong>Output:</strong> 0
<strong>Explanation: </strong>There is no valid operation to do, so the answer is 0.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-median-of-the-uniqueness-array/description" target="_blank" rel="noopener noreferrer">Find the Median of the Uniqueness Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. The <strong>uniqueness array</strong> of <code>nums</code> is the sorted array that contains the number of distinct elements of all the <span data-keyword="subarray-nonempty">subarrays</span> of <code>nums</code>. In other words, it is a sorted array consisting of <code>distinct(nums[i..j])</code>, for all <code>0 &lt;= i &lt;= j &lt; nums.length</code>.</p>

<p>Here, <code>distinct(nums[i..j])</code> denotes the number of distinct elements in the subarray that starts at index <code>i</code> and ends at index <code>j</code>.</p>

<p>Return the <strong>median</strong> of the <strong>uniqueness array</strong> of <code>nums</code>.</p>

<p><strong>Note</strong> that the <strong>median</strong> of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the <strong>smaller</strong> of the two values is taken.<!-- notionvc: 7e0f5178-4273-4a82-95ce-3395297921dc --></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The uniqueness array of <code>nums</code> is <code>[distinct(nums[0..0]), distinct(nums[1..1]), distinct(nums[2..2]), distinct(nums[0..1]), distinct(nums[1..2]), distinct(nums[0..2])]</code> which is equal to <code>[1, 1, 1, 2, 2, 3]</code>. The uniqueness array has a median of 1. Therefore, the answer is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,4,3,4,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The uniqueness array of <code>nums</code> is <code>[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]</code>. The uniqueness array has a median of 2. Therefore, the answer is 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,3,5,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The uniqueness array of <code>nums</code> is <code>[1, 1, 1, 1, 2, 2, 2, 3, 3, 3]</code>. The uniqueness array has a median of 2. Therefore, the answer is 2.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/description" target="_blank" rel="noopener noreferrer">Find the Number of Subarrays Where Boundary Elements Are Maximum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>positive</strong> integers <code>nums</code>.</p>

<p>Return the number of <span data-keyword="subarray-nonempty">subarrays</span> of <code>nums</code>, where the <strong>first</strong> and the <strong>last</strong> elements of the subarray are <em>equal</em> to the <strong>largest</strong> element in the subarray.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,3,3,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>

<ul>
	<li>subarray <code>[<strong><u>1</u></strong>,4,3,3,2]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</li>
	<li>subarray <code>[1,<u><strong>4</strong></u>,3,3,2]</code>, with its largest element 4. The first element is 4 and the last element is also 4.</li>
	<li>subarray <code>[1,4,<u><strong>3</strong></u>,3,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[1,4,3,<u><strong>3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[1,4,3,3,<u><strong>2</strong></u>]</code>, with its largest element 2. The first element is 2 and the last element is also 2.</li>
	<li>subarray <code>[1,4,<u><strong>3,3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
</ul>

<p>Hence, we return 6.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>

<ul>
	<li>subarray <code>[<u><strong>3</strong></u>,3,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,<strong><u>3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,3,<u><strong>3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[<strong><u>3,3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,<u><strong>3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[<u><strong>3,3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
</ul>

<p>Hence, we return 6.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>There is a single subarray of <code>nums</code> which is <code>[<strong><u>1</u></strong>]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</p>

<p>Hence, we return 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-peak-element-in-a-2d-matrix/1" target="_blank" rel="noopener noreferrer">Find the Peak Element in a 2D Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p class="MsoNormal"><span style="font-size: 18.6667px;">Given a 2D matrix <strong>mat[][]</strong>, identify any <strong>peak element</strong> within the matrix.</span></p>
<p class="MsoNormal"><span style="font-size: 18.6667px;">An element is considered a <strong>peak </strong>if it is <strong>greater than or equal</strong> to its <strong>four immediate neighbors:</strong> top, bottom, left, and right. For corner and edge elements, any missing neighbors are treated as having a value of <strong>negative infinity</strong>.</span></p>
<p class="MsoNormal"><span style="font-size: 18.6667px;"><strong>Note:</strong> A peak element is not necessarily the global maximum, it only needs to satisfy the condition relative to its adjacent elements. Multiple peak elements may exist, return any one of them.<br />Note that the driver code will print true if you return the correct position of peak element, else it will print false.</span></p>
<p class="MsoNormal"><span style="font-size: 14pt;"><strong>Examples:<br /></strong></span></p>
<pre class="MsoNormal"><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">mat[][] = </span>[[10, 20, 15],           
                [21, 30, 14],
                 [7, 16, 32]]<strong style="font-size: 14pt;"><br />Output: </strong>true<strong style="font-size: 14pt;"><br />Explanation: </strong></span><span style="font-size: 18.6667px;">One of the peak element is 30 at index (1, 1), which is greater than or equal to all its valid neighbors: Left = 21, Right = 14, Top = 20, Bottom = 16. So, it satisfies the peak condition. Alternatively, (2, 2) with value 32 also qualifies as a peak.</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong>mat[][] <strong>= </strong>[[17, 7],
                [11, 10]]<strong style="font-size: 14pt;"><br />Output: </strong>true<strong style="font-size: 14pt;"><br />Explanation: </strong></span><span style="font-size: 18.6667px;">17 is the only peak element at index (0, 0). Its neighbors are: Right= 7, Bottom = 11. Since 17 is greater than or equal to both (and top/left are out of bounds), it qualifies as a peak element.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Constraint:<br /></span></strong><span style="font-size: 18.6667px;">1 &le; n &times; m &le; 10<sup>6</sup><br /></span><span style="font-size: 18.6667px;">-10<sup>6</sup>&nbsp;&le; mat[i][j] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-safest-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Find the Safest Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>n x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A cell containing a thief if <code>grid[r][c] = 1</code></li>
	<li>An empty cell if <code>grid[r][c] = 0</code></li>
</ul>

<p>You are initially positioned at cell <code>(0, 0)</code>. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.</p>

<p>The <strong>safeness factor</strong> of a path on the grid is defined as the <strong>minimum</strong> manhattan distance from any cell in the path to any thief in the grid.</p>

<p>Return <em>the <strong>maximum safeness factor</strong> of all paths leading to cell </em><code>(n - 1, n - 1)</code><em>.</em></p>

<p>An <strong>adjacent</strong> cell of cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> and <code>(r - 1, c)</code> if it exists.</p>

<p>The <strong>Manhattan distance</strong> between two cells <code>(a, b)</code> and <code>(x, y)</code> is equal to <code>|a - x| + |b - y|</code>, where <code>|val|</code> denotes the absolute value of val.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example1.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example2.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1],[0,0,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example3.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length == n &lt;= 400</code></li>
	<li><code>grid[i].length == n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one thief in the <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <code>grid</code> representing a city layout where some cells contain thieves and others are empty, and we need to find the maximum safeness factor of all paths from the top-left corner to the bottom-right corner. The safeness factor of a path is defined as the minimum Manhattan distance from any cell in the path to any thief in the <code>grid</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>Manhattan distance between two cells is the sum of the absolute differences of their row and column indices.</li>
<li>All the cells in the <code>grid</code> contain either 0 or 1, representing empty cells and cells containing thieves respectively.</li>
<li>You start from the top-left corner <code>(0, 0)</code> and can move to adjacent cells in any of the four directions.</li>
<li>The maximum level of safety one can achieve while traversing from the starting point to the destination is by ensuring the least proximity to any cell containing a thief.</li>
</ol>
<h3 id="approach-1-breadth-first-search--binary-search">Approach 1: Breadth-First Search + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Since we need to find the safeness factor of a path from the source to the destination, the initial intuition to solve this problem is that we should first find the safeness factors of the cells in the path. The path can span across the entire <code>grid</code>, so we need to find the safeness factors for all the cells in the <code>grid</code>.</p>
<p>One approach to find the safeness factors of the cells would be to iterate over each cell in the <code>grid</code> and find its distance from all the thieves in the <code>grid</code>. We can then pick the smallest distance as the safeness factor for that cell.</p>
<p>However, this brute force approach would have a time complexity of <span class="math inline">\(O(n^4)\)</span>, which would not satisfy the constraints of the problem. Therefore, a more optimized approach is needed.</p>
<p>To optimize the solution, we can leverage the properties of a multi-source breadth-first Search (BFS). Instead of finding the distance of each cell from all the thieves, we can do the opposite: find the distance of all the thieves from each cell.</p>
<blockquote>
<p>Note: A multi-source breadth-first search is a BFS where multiple starting nodes are explored simultaneously. This is an efficient method to find the shortest distances from any of the starting nodes to all reachable nodes in the graph. You can refer to this excellent <strong><a href="https://leetcode.com/problems/rotting-oranges/">problem</a></strong> to gain some practice on multi-source BFS.</p>
</blockquote>
<p>The intuition for this can be,</p>
<ul>
<li>We start by adding all the thief coordinates to a queue as the initial points of exploration.</li>
<li>We then explore the neighboring cells (up, down, left, and right) from all the thieves in one iteration, like ripples spreading outwards from each thief.</li>
<li>As we visit each cell, we mark it with the minimum distance from the nearest thief. This is because the first time a cell is visited, it means that the current thief is the closest one to that cell.</li>
<li>We continue the BFS traversal until all the cells in the <code>grid</code> are marked with their corresponding safeness values.</li>
</ul>
<p>The following slideshow demonstrates how the BFS gradually populates the <code>grid</code> with its minimum distances from a thief.</p>
<p>!?!../Documents/2812/bfs_slideshow.json:412,291!?!</p>
<p>Now that we have the safeness factor of each cell, we need to find the maximum safeness factor for which a path exists from the source cell to the destination cell. This implies that for all safeness values greater than it, no path exists, and at least one path exists for all values less than it. We can visualize these safeness factors as a monotonic sequence on a number line. The values that satisfy the constraints of the problem will be a contiguous series. These will be followed by a series of values that do not satisfy the constraints. We will name this breakpoint the inflection point.</p>
<p>The following slideshow visualizes how we iteratively converge to the location of the inflection point using binary search.</p>
<p>!?!../Documents/2812/bs_slideshow.json:482,160!?!</p>
<p>During the binary search, to determine if a safeness value meets the problem constraints, we employ another breadth-first search (BFS) traversal on the <code>grid</code>. The traversal attempts to find a path where every cell in the path satisfies this minimum safeness value. If such a path is found, it indicates that the given safeness value is a valid solution to the problem.</p>
<p>Thus, to find the maximum safeness factor, we can use binary search to efficiently locate the inflection point in this monotonic sequence. The last &quot;True&quot; value at the inflection point will be the maximum safeness factor for which a path exists.</p>
<p>In summary, the final solution involves two key steps:</p>
<ol>
<li>Perform a breadth-first search to compute the safeness factor for each cell, leveraging the fact that the first time a cell is visited, it represents the minimum distance from the nearest thief.</li>
<li>Apply binary search to find the maximum safeness factor for which a path exists from the source to the destination cell.</li>
</ol>
<p>This approach is more efficient than the initial brute-force solution, as it avoids the need to calculate the distance of each cell from all the thieves. Instead, it focuses on finding the distance of each cell from all the thieves, which can be done more optimally manner using BFS.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
<li>Define <code>isValidSafeness</code> method to check if a path exists with a minimum safeness value.</li>
</ul>
<h5 id="isvalidcell-method"><code>isValidCell</code> Method</h5>
<ol>
<li>Take the <code>grid</code>, row <code>i</code>, and column <code>j</code> as input.</li>
<li>Get the size of the <code>grid</code>, denoted by <code>n</code>.</li>
<li>Check if the cell at (<code>i</code>, <code>j</code>) is within the <code>grid</code> boundaries.</li>
<li>Return <code>true</code> if the cell is valid, <code>false</code> otherwise.</li>
</ol>
<h5 id="isvalidsafeness-method"><code>isValidSafeness</code> Method</h5>
<ol>
<li>
<p>Take the <code>grid</code> and the minimum safeness value as input.</p>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
<li><code>visited</code> as a 2-D array to mark visited cells.</li>
</ul>
</li>
<li>
<p>Check if the source and destination cells satisfy the minimum safeness.</p>
</li>
<li>
<p>Perform a breadth-first search (BFS) to find a valid path:</p>
<ul>
<li>Initialize a queue <code>q</code> to contain the coordinates.</li>
<li>Add the source cell (<code>0</code>, <code>0</code>) to the queue.</li>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells in all directions:
<ul>
<li>If the neighboring cell is valid, unvisited and has a safeness value greater than or equal to the minimum safeness value:
<ul>
<li>Mark the cell as visited and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If a valid path is found, return <code>true</code>.</li>
</ul>
</li>
<li>
<p>Return <code>false</code> if no valid path is found.</p>
</li>
</ol>
<h5 id="signature-function-maximumsafenessfactor">Signature function <code>maximumSafenessFactor</code></h5>
<ol>
<li>
<p>Initialize a queue <code>q</code> to store the positions of thieves.</p>
</li>
<li>
<p>Mark thieves as <code>0</code> and empty cells as <code>-1</code>, and push thieves to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform a binary search for the maximum safeness factor:</p>
<ul>
<li>Initialize <code>start</code> and <code>end</code> variables.</li>
<li>Initialize <code>res</code> to store the maximum safeness value.</li>
<li>Loop through the <code>grid</code> to find the maximum safeness factor and assign it to <code>end</code>.</li>
<li>While <code>start</code> is less than or equal to <code>end</code>:
<ul>
<li>Calculate <code>mid</code>.</li>
<li>Check if a valid safeness exists for <code>mid</code> using <code>isValidSafeness</code> method.</li>
<li>Update <code>res</code> if valid safeness is found.</li>
<li>Update <code>start</code> or <code>end</code> based on the result of <code>isValidSafeness</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum safeness factor <code>res</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3UY5NMSg/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The time complexity for the initial BFS is <span class="math inline">\(O(n^2)\)</span>, as each cell in the <span class="math inline">\(n \cdot n\)</span> <code>grid</code> is visited once during the traversal.</p>
<p>The binary search occurs in the range [0, maximum safeness factor possible], where the maximum safeness factor possible is <span class="math inline">\(2 \cdot n\)</span>. The time complexity of the binary search is <span class="math inline">\(O(\log (2 \cdot n))\)</span>, which is equivalent to <span class="math inline">\(O(\log n)\)</span>.</p>
<p>For each iteration of the binary search, a breadth-first Search is conducted to verify validity, which has a time complexity of <span class="math inline">\(O(n^2)\)</span>. Thus, the total time complexity of the binary search portion is <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log n)\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The data structure used in the algorithm is a queue, which takes linear space. Since the total number of cells in the <code>grid</code> is <span class="math inline">\(n^2\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-bfs--greedy">Approach 2: BFS + Greedy</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a binary search strategy to find the maximum safeness factor for which a path exists from the source to the destination. While this was an efficient solution, the intuition behind this approach is to directly find the optimal path from the source to the destination by leveraging Dijkstra's algorithm.</p>
<p>Similar to the previous approach, we first need to populate the <code>grid</code> with the safeness values for each cell. The algorithm to achieve this is the same as before, using the breadth-first Search (BFS) technique to compute the distance of each cell from the nearest thief.</p>
<p>The key idea here is to use Dijkstra's single source shortest path algorithm to find the optimal path from the source cell <code>[0, 0]</code> to the destination cell <code>[n-1, n-1]</code>. However, since each cell in the <code>grid</code> already contains its safeness factor, we need to modify Dijkstra's algorithm to find the path with the maximum safeness factor. In our modified Dijkstra's algorithm, we can greedily prioritize cells with a higher safeness factor to append to our path. The safeness factor of the path would be the minimum of the safeness values encountered in that path so far. Once we reach the destination cell, the safeness factor of the path would represent the required maximum safeness factor.</p>
<p>The modified Dijkstra's algorithm works as follows:</p>
<ul>
<li>We start with the source cell <code>[0, 0]</code> in a priority queue, where the priority is based on the highest safeness factor encountered in the path so far.</li>
<li>For efficiency, cells we've explored are marked as -1 in the <code>grid</code> itself.</li>
<li>If the current cell is the destination <code>[n-1, n-1]</code>, the traversal is over, and we return the maximum safeness factor encountered so far.</li>
<li>If the current cell is not the destination, we explore the valid adjacent cells. A cell is considered valid if it is within the <code>grid</code> boundaries and not visited yet (not -1).</li>
<li>For each valid neighbor, we calculate the potential safeness factor considering the current path's safeness and the new cell's distance to thieves. The minimum of these two values becomes the new safeness for the path with the addition of the neighbor.</li>
<li>We add the valid neighbors to the priority queue, prioritizing them based on their safeness factor.</li>
<li>We continue the exploration until we reach the destination cell.</li>
</ul>
<p>The key advantage of this approach is that it directly finds the optimal path from the source to the destination instead of relying on a binary search to find the maximum safeness factor. By using Dijkstra's algorithm, we can ensure that we find the path with the maximum safeness factor, without the need to perform a separate binary search.</p>
<p>Additionally, this approach may be more intuitive for some users, as it closely resembles the problem of finding the shortest path with the maximum weight (safeness factor) on a weighted graph.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define the <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
</ul>
<ol>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
</ul>
</li>
<li>
<p>Mark thieves as 0 and empty cells as -1 in the <code>grid</code>. Push thieves' coordinates to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize a priority queue <code>pq</code> to prioritize cells with a higher safeness factor. Push the starting cell to <code>pq</code>.</p>
</li>
<li>
<p>Perform BFS to find the path with the maximum safeness factor:</p>
<ul>
<li>While the priority queue <code>pq</code> is not empty:
<ul>
<li>Retrieve the top element <code>curr</code> from <code>pq</code>.</li>
<li>If the destination is reached, return the safeness factor of the path.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and not marked as visited:
<ul>
<li>Update the safeness factor for the path and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no path is found, return -1.</p>
</li>
</ol>
<blockquote>
<p>Note: In the C++ implementation, the elements in the priority queue are stored as <code>[safeness, row, col]</code> to leverage C++'s default comparison capabilities.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/UHkVoNQF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2 \cdot \log (n))\)</span></p>
<p>Similar to Approach 1, the time complexity of the initial BFS is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>To find the optimal path, we use Dijkstra's single source shortest path algorithm, which has a time complexity of <span class="math inline">\(O(n^2 \cdot \log (n))\)</span> when implemented in a <code>grid</code> of size <span class="math inline">\(n \cdot n\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log (n))\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log (n))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The two data structures used in this approach are the queue and the priority queue, both of which have a linear space complexity. Since the maximum number of elements that can be present in the queues is <span class="math inline">\(n \cdot n\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description" target="_blank" rel="noopener noreferrer">Find the Smallest Divisor Given a Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>threshold</code>, we will choose a positive integer <code>divisor</code>, divide all the array by it, and sum the division&#39;s result. Find the <strong>smallest</strong> <code>divisor</code> such that the result mentioned above is less than or equal to <code>threshold</code>.</p>

<p>Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: <code>7/3 = 3</code> and <code>10/2 = 5</code>).</p>

<p>The test cases are generated so&nbsp;that there will be an answer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,5,9], threshold = 6
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [44,22,33,11,1], threshold = 5
<strong>Output:</strong> 44
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>nums.length &lt;= threshold &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-student-that-will-replace-the-chalk/description" target="_blank" rel="noopener noreferrer">Find the Student that Will Replace the Chalk</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> students in a class numbered from <code>0</code> to <code>n - 1</code>. The teacher will give each student a problem starting with the student number <code>0</code>, then the student number <code>1</code>, and so on until the teacher reaches the student number <code>n - 1</code>. After that, the teacher will restart the process, starting with the student number <code>0</code> again.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>chalk</code> and an integer <code>k</code>. There are initially <code>k</code> pieces of chalk. When the student number <code>i</code> is given a problem to solve, they will use <code>chalk[i]</code> pieces of chalk to solve that problem. However, if the current number of chalk pieces is <strong>strictly less</strong> than <code>chalk[i]</code>, then the student number <code>i</code> will be asked to <strong>replace</strong> the chalk.</p>

<p>Return <em>the <strong>index</strong> of the student that will <strong>replace</strong> the chalk pieces</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> chalk = [5,1,5], k = 22
<strong>Output:</strong> 0
<strong>Explanation: </strong>The students go in turns as follows:
- Student number 0 uses 5 chalk, so k = 17.
- Student number 1 uses 1 chalk, so k = 16.
- Student number 2 uses 5 chalk, so k = 11.
- Student number 0 uses 5 chalk, so k = 6.
- Student number 1 uses 1 chalk, so k = 5.
- Student number 2 uses 5 chalk, so k = 0.
Student number 0 does not have enough chalk, so they will have to replace it.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> chalk = [3,4,1,2], k = 25
<strong>Output:</strong> 1
<strong>Explanation: </strong>The students go in turns as follows:
- Student number 0 uses 3 chalk so k = 22.
- Student number 1 uses 4 chalk so k = 18.
- Student number 2 uses 1 chalk so k = 17.
- Student number 3 uses 2 chalk so k = 15.
- Student number 0 uses 3 chalk so k = 12.
- Student number 1 uses 4 chalk so k = 8.
- Student number 2 uses 1 chalk so k = 7.
- Student number 3 uses 2 chalk so k = 5.
- Student number 0 uses 3 chalk so k = 2.
Student number 1 does not have enough chalk, so they will have to replace it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>chalk.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= chalk[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-prefix-sum">Approach 1: Prefix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>In this problem, we have an array <code>chalk</code> of <code>n</code> elements representing the number of chalks used by each student, and an integer <code>k</code> indicating the total number of chalks available. The brute force approach would involve repeatedly subtracting the number of chalks from <code>k</code> until it reaches zero, cycling through the array if necessary. Given that <code>k</code> can be as large as 1,000,000,000, this approach is impractical.</p>
<p>To optimize, observe that the total number of chalks used in one complete cycle through the array is given by <code>sum</code>, the sum of all elements in <code>chalk</code>. If <code>k</code> is less than <code>sum</code>, we will reach zero within the first cycle. If <code>k</code> is greater than <code>sum</code>, after the first cycle, <code>k</code> will be reduced to <code>k - sum</code>, and after subsequent cycles, it will be reduced further. This process continues until <code>k</code> becomes less than <code>sum</code>, which is equivalent to computing <code>k % sum</code>.</p>
<blockquote>
<p>This is because <code>k</code> reduced by multiples of <code>sum</code> will eventually be less than <code>sum</code>, and this final value is equivalent to <code>k % sum</code>.</p>
</blockquote>
<p>We then need to find the first index in the <code>chalk</code> array where the remaining <code>k % sum</code> becomes negative. We do this by maintaining a running prefix sum of <code>chalk</code> elements and iterating through the array to find the index where the prefix sum exceeds <code>k % sum</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an integer variable <code>sum</code> to 0.</li>
<li>Iterate over the chalk array from 0 to <code>chalk.size() - 1</code>:
<ul>
<li>Add the value at the current index <code>i</code> to <code>sum</code>.</li>
<li>If at any point <code>sum</code> exceeds <code>k</code>, exit the loop.</li>
</ul>
</li>
<li>Calculate <code>k</code> as <code>k % sum</code>, representing the remaining chalk after full rounds.</li>
<li>Iterate over the chalk array again from <code>0</code> to <code>chalk.size() - 1</code>:
<ul>
<li>If <code>k</code> is less than the value at the current index <code>i</code>, return <code>i</code> as the index of the student who will run out of chalk.</li>
<li>Otherwise, subtract the value at <code>chalk[i]</code> from <code>k</code>.</li>
</ul>
</li>
<li>If no student is found within the loop, return <code>0</code> (though this should not be reached given the problem constraints).</li>
</ol>
<p>!?!../Documents/1894/slideshow.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AnvPz9Gu/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>chalk</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the <code>chalk</code> array exactly twice. Apart from this, all operations are performed in constant time. Therefore, the total time complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No additional space is used proportional to the array size <code>n</code>. Therefore, the space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search">Approach 2: Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of iterating through the array to find the first index, we can use binary search. Binary search is ideal here because it quickly narrows down the search space in a sorted array.</p>
<p>We start by defining a predicate function that checks if the prefix sum at a given index is greater than the <code>k modulo sum</code>. This function returns <code>true</code> for indices where the prefix sum exceeds the target and <code>false</code> otherwise. Since the array is sorted based on the prefix sums, <code>true</code> indicates indices with no chalk left, while <code>false</code> indicates indices with some chalk remaining.</p>
<p>Using binary search, we locate the smallest index where the predicate returns <code>true</code>.</p>
<ul>
<li>If the predicate returns <code>true</code>, it means there might be smaller indices with <code>true</code> values, so we adjust the upper bound of the search space to the current index.</li>
<li>If the predicate returns <code>false</code>, it means all <code>true</code> values are beyond the current index, so we adjust the lower bound of the search space to the current index.</li>
</ul>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main Function - <code>chalkReplacer(chalk, k)</code>:</p>
<ol>
<li>Create an array <code>prefixSum</code> of length <code>n</code>to store prefix sums.</li>
<li>Initialize <code>prefixSum[0]</code> with <code>chalk[0]</code>.</li>
<li>Iterate through the chalk array from index <code>1</code> to <code>n-1</code> and update <code>prefixSum[i]</code> as the sum of <code>prefixSum[i-1]</code> and <code>chalk[i]</code>.</li>
<li>Calculate <code>sum</code> as <code>prefixSum[n-1]</code>, representing the total chalk needed for one full round.</li>
<li>Calculate <code>remainingChalk</code> as <code>k % sum</code>.</li>
<li>Call the helper function <code>binarySearch(prefixSum, remainingChalk)</code> to find the student who will run out of chalk and return the result of binarySearch.</li>
</ol>
<p>Helper Function - <code>binarySearch(arr, remainingChalk)</code></p>
<ol>
<li>Set <code>low</code> to 0 and <code>high</code> to arr.length - 1.</li>
<li>While <code>low</code> is less than <code>high</code>:
<ul>
<li>Calculate mid as the average of <code>low</code> and <code>high</code>.</li>
<li>If <code>arr[mid]</code> is less than or equal to <code>remainingChalk</code>, update <code>low to mid + 1</code>.</li>
<li>Otherwise, update <code>high</code> to <code>mid</code>.</li>
</ul>
</li>
<li>Return <code>high</code> as the index of the student who will run out of chalk.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9d8aK7JW/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>chalk</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the <code>chalk</code> array once. Apart from this, the binary search operation takes <span class="math inline">\(O(log n)\)</span> time. Therefore, the total time complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We initialize an array <code>prefixSum</code> of size <code>n</code> to store the prefix sums of the <code>chalk</code> array. Apart from this, no additional space is used. Therefore, the space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/description" target="_blank" rel="noopener noreferrer">Find Two Non-overlapping Sub-arrays Each With Target Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>arr</code> and an integer <code>target</code>.</p>

<p>You have to find <strong>two non-overlapping sub-arrays</strong> of <code>arr</code> each with a sum equal <code>target</code>. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is <strong>minimum</strong>.</p>

<p>Return <em>the minimum sum of the lengths</em> of the two required sub-arrays, or return <code>-1</code> if you cannot find such two sub-arrays.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,2,2,4,3], target = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [7,3,4,7], target = 7
<strong>Output:</strong> 2
<strong>Explanation:</strong> Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,3,2,6,2,3,4], target = 6
<strong>Output:</strong> -1
<strong>Explanation:</strong> We have only one sub-array of sum = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
	<li><code>1 &lt;= target &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-weighted-median-node-in-tree/description" target="_blank" rel="noopener noreferrer">Find Weighted Median Node in Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an <strong>undirected, weighted</strong> tree rooted at node 0 with <code>n</code> nodes numbered from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> indicates an edge from node <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>The <strong>weighted median node</strong> is defined as the <strong>first</strong> node <code>x</code> on the path from <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code> such that the sum of edge weights from <code>u<sub>i</sub></code> to <code>x</code> is <strong>greater than or equal to half</strong> of the total path weight.</p>

<p>You are given a 2D integer array <code>queries</code>. For each <code>queries[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>, determine the weighted median node along the path from <code>u<sub>j</sub></code> to <code>v<sub>j</sub></code>.</p>

<p>Return an array <code>ans</code>, where <code>ans[j]</code> is the node index of the weighted median for <code>queries[j]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1,7]], queries = [[1,0],[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/26/screenshot-2025-05-26-at-193447.png" style="width: 200px; height: 64px;" /></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Query</th>
			<th style="border: 1px solid black;">Path</th>
			<th style="border: 1px solid black;">Edge<br />
			Weights</th>
			<th style="border: 1px solid black;">Total<br />
			Path<br />
			Weight</th>
			<th style="border: 1px solid black;">Half</th>
			<th style="border: 1px solid black;">Explanation</th>
			<th style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;"><code>[1, 0]</code></td>
			<td style="border: 1px solid black;"><code>1 &rarr; 0</code></td>
			<td style="border: 1px solid black;"><code>[7]</code></td>
			<td style="border: 1px solid black;">7</td>
			<td style="border: 1px solid black;">3.5</td>
			<td style="border: 1px solid black;">Sum from <code>1 &rarr; 0 = 7 &gt;= 3.5</code>, median is node 0.</td>
			<td style="border: 1px solid black;">0</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[0, 1]</code></td>
			<td style="border: 1px solid black;"><code>0 &rarr; 1</code></td>
			<td style="border: 1px solid black;"><code>[7]</code></td>
			<td style="border: 1px solid black;">7</td>
			<td style="border: 1px solid black;">3.5</td>
			<td style="border: 1px solid black;">Sum from <code>0 &rarr; 1 = 7 &gt;= 3.5</code>, median is node 1.</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[2,0,4]], queries = [[0,1],[2,0],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,0,2]</span></p>

<p><strong>E</strong><strong>xplanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/26/screenshot-2025-05-26-at-193610.png" style="width: 180px; height: 149px;" /></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Query</th>
			<th style="border: 1px solid black;">Path</th>
			<th style="border: 1px solid black;">Edge<br />
			Weights</th>
			<th style="border: 1px solid black;">Total<br />
			Path<br />
			Weight</th>
			<th style="border: 1px solid black;">Half</th>
			<th style="border: 1px solid black;">Explanation</th>
			<th style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;"><code>[0, 1]</code></td>
			<td style="border: 1px solid black;"><code>0 &rarr; 1</code></td>
			<td style="border: 1px solid black;"><code>[2]</code></td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Sum from <code>0 &rarr; 1 = 2 &gt;= 1</code>, median is node 1.</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[2, 0]</code></td>
			<td style="border: 1px solid black;"><code>2 &rarr; 0</code></td>
			<td style="border: 1px solid black;"><code>[4]</code></td>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">Sum from <code>2 &rarr; 0 = 4 &gt;= 2</code>, median is node 0.</td>
			<td style="border: 1px solid black;">0</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1, 2]</code></td>
			<td style="border: 1px solid black;"><code>1 &rarr; 0 &rarr; 2</code></td>
			<td style="border: 1px solid black;"><code>[2, 4]</code></td>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">Sum from <code>1 &rarr; 0 = 2 &lt; 3</code>.<br />
			Sum from <code>1 &rarr; 2 = 2 + 4 = 6 &gt;= 3</code>, median is node 2.</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,2],[0,2,5],[1,3,1],[2,4,3]], queries = [[3,4],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/26/screenshot-2025-05-26-at-193857.png" style="width: 150px; height: 229px;" /></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Query</th>
			<th style="border: 1px solid black;">Path</th>
			<th style="border: 1px solid black;">Edge<br />
			Weights</th>
			<th style="border: 1px solid black;">Total<br />
			Path<br />
			Weight</th>
			<th style="border: 1px solid black;">Half</th>
			<th style="border: 1px solid black;">Explanation</th>
			<th style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;"><code>[3, 4]</code></td>
			<td style="border: 1px solid black;"><code>3 &rarr; 1 &rarr; 0 &rarr; 2 &rarr; 4</code></td>
			<td style="border: 1px solid black;"><code>[1, 2, 5, 3]</code></td>
			<td style="border: 1px solid black;">11</td>
			<td style="border: 1px solid black;">5.5</td>
			<td style="border: 1px solid black;">Sum from <code>3 &rarr; 1 = 1 &lt; 5.5</code>.<br />
			Sum from <code>3 &rarr; 0 = 1 + 2 = 3 &lt; 5.5</code>.<br />
			Sum from <code>3 &rarr; 2 = 1 + 2 + 5 = 8 &gt;= 5.5</code>, median is node 2.</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1, 2]</code></td>
			<td style="border: 1px solid black;"><code>1 &rarr; 0 &rarr; 2</code></td>
			<td style="border: 1px solid black;"><code>[2, 5]</code></td>
			<td style="border: 1px solid black;">7</td>
			<td style="border: 1px solid black;">3.5</td>
			<td style="border: 1px solid black;">
			<p>Sum from <code>1 &rarr; 0 = 2 &lt; 3.5</code>.<br />
			Sum from <code>1 &rarr; 2 = 2 + 5 = 7 &gt;= 3.5</code>, median is node 2.</p>
			</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[j] == [u<sub>j</sub>, v<sub>j</sub>]</code></li>
	<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt; n</code></li>
	<li>The input is generated such that <code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/first-bad-version/description" target="_blank" rel="noopener noreferrer">First Bad Version</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">interactive</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>

<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>

<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5, bad = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong>
call isBadVersion(3) -&gt; false
call isBadVersion(5)&nbsp;-&gt; true
call isBadVersion(4)&nbsp;-&gt; true
Then 4 is the first bad version.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1, bad = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= bad &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/frequency-of-the-most-frequent-element/description" target="_blank" rel="noopener noreferrer">Frequency of the Most Frequent Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>frequency</strong> of an element is the number of times it occurs in an array.</p>

<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. In one operation, you can choose an index of <code>nums</code> and increment the element at that index by <code>1</code>.</p>

<p>Return <em>the <strong>maximum possible frequency</strong> of an element after performing <strong>at most</strong> </em><code>k</code><em> operations</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,4], k = 5
<strong>Output:</strong> 3<strong>
Explanation:</strong> Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,8,13], k = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,9,6], k = 2
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sliding-window">Approach 1: Sliding Window</h3>
<p><strong>Intuition</strong></p>
<p>In this problem, we want to make as many elements as we can equal using <code>k</code> increments.</p>
<p>Let's say that we choose a number <code>target</code> and want to maximize its frequency. Intuitively, the elements that we would increment would be the elements that are closest to <code>target</code> (and less than <code>target</code>, since we can only increment).</p>
<p>So what number should we choose for <code>target</code>? The optimal <code>target</code> will already exist in the array. Why?</p>
<ul>
<li>Assume <code>target</code> is in <code>nums</code>, but <code>target - 1</code> and <code>target + 1</code> are not in <code>nums</code>. Let's say that we can increment <code>x</code> elements to be equal to <code>target</code> using at most <code>k</code> operations. We will prove that making <code>target - 1</code> or <code>target + 1</code> the most frequent element does not lead to better results.</li>
</ul>
<p><img src="../Figures/1838/1.png" alt="example" /><br />
<br></p>
<ul>
<li>It would be pointless to instead try to make <code>target + 1</code> the most frequent element, since this would cost us <code>x</code> extra operations and we would not improve on our answer. The same goes for even larger elements <code>target + 2</code> and etc.</li>
</ul>
<p><img src="../Figures/1838/2.png" alt="example" /><br />
<br></p>
<ul>
<li>What about <code>target - 1</code>? Compared with making <code>target</code> the most frequent element, we would lose the values representing these <code>target</code>s from our max frequency, but we would save <code>x</code> operations which we could potentially use to increment more than one extra element and thus improve our answer.</li>
</ul>
<p><img src="../Figures/1838/3.png" alt="example" /><br />
<br></p>
<ul>
<li>The above statement is true, but meaningless! Consider the greatest element in <code>nums</code> that is less than <code>target</code>. That is, if we were to sort <code>nums</code>, consider the element that comes right before <code>target</code>. If we were to instead consider this element as the target, we would save more than <code>x</code> operations without negatively affecting the frequency relative to considering <code>target - 1</code>.</li>
</ul>
<p><img src="../Figures/1838/4.png" alt="example" /><br />
<br></p>
<ul>
<li>In summary, for any given number <code>absent</code> that is not in <code>nums</code>, consider the greatest number in <code>nums</code> smaller than <code>absent</code> as <code>smallerTarget</code>. The number of operations to raise some number of elements to <code>smallerTarget</code> will always be less than the number of steps needed to raise them to <code>absent</code>.</li>
<li>Thus, the optimal value of <code>target</code> must exist in <code>nums</code>. We can iterate over <code>nums</code> and consider each element as <code>target</code>.</li>
</ul>
<p>For a given value of <code>target</code>, how can we efficiently check the frequency we could achieve? As we mentioned at the start, we would want to increment elements that are closest to <code>target</code>. As such, we will start by sorting <code>nums</code> so that as we iterate over the elements, we know the elements closest to <code>target</code> are just to the left of <code>target</code>.</p>
<p>Now that <code>nums</code> is sorted, consider the first element to the left of <code>target</code> as <code>smaller</code>. As <code>smaller</code> is the closest element to <code>target</code>, we want to increment it to equal <code>target</code>. This will cost us <code>target - smaller</code> operations. Now, consider the next element to the left as <code>smaller2</code>. Now this is the element closest to <code>target</code>, so we increment it using <code>target - smaller2</code> operations. We continue this process until we run out of operations.</p>
<p>As you can see, the number of operations required is simply the difference between <code>target</code> and the numbers we are incrementing. Let's say that the final frequency of <code>target</code> was <code>4</code>. We would have a sum of <code>4 * target</code>. The number of operations would be this sum minus the sum of the elements before we incremented them. Consider the following example:</p>
<p><img src="../Figures/1838/5.png" alt="example" /><br />
<br></p>
<blockquote>
<p>If you aren't already familiar with the sliding window technique, we highly recommend reading <a href="https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/">this free article</a> from LeetCode's official DSA course, where sliding window is explained in detail with multiple examples.</p>
</blockquote>
<p>This brings us to our solution. We will use a sliding window over the sorted <code>nums</code>. For each element <code>nums[right]</code>, we will treat <code>target</code> as this element and try to make every element in our window equal to <code>target</code>.</p>
<p>The size of the window is <code>right - left + 1</code>. That means we would have a final sum of <code>(right - left + 1) * target</code>. If we track the sum of our window in a variable <code>curr</code>, then we can calculate the required operations as <code>(right - left + 1) * target - curr</code>. If it requires more than <code>k</code> operations, we must shrink our window. Like in all sliding window problems, we will use a <code>while</code> loop to shrink our window by incrementing <code>left</code> until <code>k</code> operations are sufficient.</p>
<p>Once the <code>while</code> loop ends, we know that we can make all elements in the window equal to <code>target</code>. We can now update our answer with the current window size. The final answer will be the largest valid window we find after iterating <code>right</code> over the entire input.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort <code>nums</code>.</li>
<li>Initialize the following integers:
<ul>
<li><code>left = 0</code>, the left pointer.</li>
<li><code>ans = 0</code>, the best answer we have seen so far.</li>
<li><code>curr = 0</code>, the sum of the elements currently in our window.</li>
</ul>
</li>
<li>Iterate <code>right</code> over the indices of <code>nums</code>:
<ul>
<li>Consider <code>target = nums[right]</code>.</li>
<li>Add <code>target</code> to <code>curr</code>.</li>
<li>While the size of the window <code>right - left + 1</code> multiplied by <code>target</code>, minus <code>curr</code> is greater than <code>k</code>:
<ul>
<li>Subtract <code>nums[left]</code> from <code>curr</code>.</li>
<li>Increment <code>left</code>.</li>
</ul>
</li>
<li>Update <code>ans</code> with the current window size if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Be careful! Given the constraints, we may run into integer overflow. Use <code>long</code> accordingly in Java and C++ (Python doesn't have overflow).</p>
</blockquote>
<p><a href="https://leetcode.com/playground/3sv7JbQ8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>Despite the while loop, each iteration of the for loop is amortized <span class="math inline">\(O(1)\)</span>. The while loop only runs <span class="math inline">\(O(n)\)</span> times across all iterations. This is because each iteration of the while loop increments <code>left</code>. As <code>left</code> can only increase and cannot exceed <code>n</code>, the while loop never performs more than <code>n</code> iterations total. This means the sliding window process runs in <span class="math inline">\(O(n)\)</span>.</p>
<p>However, we need to sort the array, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log n)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>We only use a few integer variables, but some space is used to sort.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language:</p>
<ul>
<li>In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span></li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-advanced-sliding-window">Approach 2: Advanced Sliding Window</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach is an extension of the previous one.</p>
</blockquote>
<p>Notice that the only thing we care about is the <strong>length</strong> of the longest window. We don't need to know what the window itself is. As we slide the window over the array, let's say we find a valid window with a length of <code>len</code>. <strong>We no longer care about any windows with lengths less than <code>len</code></strong>, because they could not possibly improve on our answer.</p>
<p>The purpose of the while loop in the previous approach is to shrink the window until it is valid again. In this approach, we will not shrink the window - we will just try to grow it as large as we can.</p>
<p>We will keep the same condition in the while loop that checks if the current window <code>[left, right]</code> is valid, but instead of using a while loop, we will just use an if statement. This means <code>left</code> never increases by more than <code>1</code> per iteration. Because <code>right</code> also increases by <code>1</code> per iteration, if we cannot find a valid window, we will simply be sliding a window with static size across the array.</p>
<p>However, if we add an element <code>nums[right]</code> to the window and the window is valid, then the if statement will not trigger, and <code>left</code> will not be incremented. Thus, we will increase our window size by <code>1</code>. In this scenario, it implies the current window <code>[left, right]</code> is the best window we have seen so far.</p>
<blockquote>
<p>As you can see, it is actually impossible for our window size to decrease, since each iteration increases <code>right</code> by <code>1</code> and <code>left</code> by either <code>0</code> or <code>1</code>.</p>
</blockquote>
<p>Because our window size cannot decrease, it also means that the size of the window always represents the length of the best window we have found so far - analogous to <code>ans</code> from the previous approach.</p>
<p>At the end of the iteration, the size of our window is <code>n - left</code>. We return this as the answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort <code>nums</code>.</li>
<li>Initialize the following integers:
<ul>
<li><code>left = 0</code>, the left pointer.</li>
<li><code>curr = 0</code>, the sum of the elements currently in our window.</li>
</ul>
</li>
<li>Iterate <code>right</code> over the indices of <code>nums</code>:
<ul>
<li>Consider <code>target = nums[right]</code>.</li>
<li>Add <code>target</code> to <code>curr</code>.</li>
<li>If the size of the window <code>right - left + 1</code> multiplied by <code>target</code>, minus <code>curr</code> is greater than <code>k</code>:
<ul>
<li>Subtract <code>nums[left]</code> from <code>curr</code>.</li>
<li>Increment <code>left</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>nums.length - left</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/PxgSPnTe/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>Each iteration of the for loop costs <span class="math inline">\(O(1)\)</span>. This means the sliding window process runs in <span class="math inline">\(O(n)\)</span>.</p>
<p>However, we need to sort the array, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log n)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>We only use a few integer variables, but some space is used to sort.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language:</p>
<ul>
<li>In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span></li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-binary-search">Approach 3: Binary Search</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>Note: the previous two approaches are the optimal solutions and are sufficient to solve the problem. Here, we will look at another unique way to approach the problem for the sake of completeness.</p>
</blockquote>
<p>Given an index <code>i</code>, if we treat <code>nums[i]</code> as <code>target</code>, we are concerned with how many elements on the left we can take. In the earlier approaches, we used a sliding window. In this approach, we will directly find the left-most index of these elements using binary search.</p>
<p>Let's say that <code>best</code> is the index of the furthest element to the left that we could increment to <code>target = nums[i]</code>. Note that here, <code>best</code> is analogous to what <code>left</code> was after the while loop finished in the first approach. How do we find <code>best</code>?</p>
<p>The value of <code>best</code> must be in the range <code>[0, i]</code>. We will perform a binary search on this range. For a given index <code>mid</code>:</p>
<ul>
<li>The number of elements in the window would be <code>count = i - mid + 1</code>.</li>
<li>Thus, the final sum after making every element in the window equal to <code>target</code> would be <code>finalSum = count * target</code>.</li>
<li>The original sum of the elements is the sum of the elements from index <code>mid</code> to index <code>i</code>. We can use a prefix sum to find this <code>originalSum</code>.</li>
<li>Thus, the number of operations we need is <code>operationsRequired = finalSum - originalSum</code>.</li>
<li>If <code>operationsRequired &gt; k</code>, it's impossible to include the index <code>mid</code>. We update <code>left = mid + 1</code>.</li>
<li>Otherwise, the task is possible and we should look for a better index. We update <code>best = mid</code> and <code>right = mid - 1</code>.</li>
</ul>
<p>Essentially, we are binary searching the left bound from the first approach for a given right bound <code>i</code>. If we pre-process a prefix sum, then for each <code>mid</code>, we have all the necessary information to find <code>operationsRequired</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>check(i)</code>:
<ul>
<li>Initialize the following integers:
<ul>
<li><code>target = nums[i]</code>, the current target.</li>
<li><code>left = 0</code>, the left bound of the binary search.</li>
<li><code>right = i</code>, the right bound of the binary search.</li>
<li><code>best = i</code>, the best (furthest left) index that we can increment to <code>target</code>.</li>
</ul>
</li>
<li>While <code>left &lt;= right</code>
<ul>
<li>Calculate <code>mid = (left + right) / 2</code>.</li>
<li>Calculate <code>count = i - mid + 1</code>.</li>
<li>Calculate <code>finalSum = count * target</code>.</li>
<li>Calculate <code>originalSum = prefix[i] - prefix[mid] + nums[mid]</code>.</li>
<li>Calculate <code>operationsRequired = finalSum - originalSum</code>.</li>
<li>If <code>operationsRequired &gt; k</code>, move <code>left = mid + 1</code>.</li>
<li>Otherwise, update <code>best = mid</code> and <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Return <code>i - best + 1</code>.</li>
</ul>
</li>
<li>Sort <code>nums</code>.</li>
<li>Create a <code>prefix</code> sum of <code>nums</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>Update <code>ans</code> with <code>check(i)</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Be careful! Given the constraints, we may run into integer overflow. Use <code>long</code> accordingly in Java and C++ (Python doesn't have overflow).</p>
</blockquote>
<p><a href="https://leetcode.com/playground/RszUgWwH/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>First, we sort <code>nums</code> which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
<p>Next, we iterate over the indices of <code>nums</code>. For each of the <span class="math inline">\(O(n)\)</span> indices, we call <code>check</code>, which costs up to <span class="math inline">\(O(\log{}n)\)</span> as its a binary search over the array's elements. The total cost is <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>prefix</code> array uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/friends-of-appropriate-ages/description" target="_blank" rel="noopener noreferrer">Friends Of Appropriate Ages</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> persons on a social media website. You are given an integer array <code>ages</code> where <code>ages[i]</code> is the age of the <code>i<sup>th</sup></code> person.</p>

<p>A Person <code>x</code> will not send a friend request to a person <code>y</code> (<code>x != y</code>) if any of the following conditions is true:</p>

<ul>
	<li><code>age[y] &lt;= 0.5 * age[x] + 7</code></li>
	<li><code>age[y] &gt; age[x]</code></li>
	<li><code>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100</code></li>
</ul>

<p>Otherwise, <code>x</code> will send a friend request to <code>y</code>.</p>

<p>Note that if <code>x</code> sends a request to <code>y</code>, <code>y</code> will not necessarily send a request to <code>x</code>. Also, a person will not send a friend request to themself.</p>

<p>Return <em>the total number of friend requests made</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ages = [16,16]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 2 people friend request each other.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ages = [16,17,18]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Friend requests are made 17 -&gt; 16, 18 -&gt; 17.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> ages = [20,30,100,110,120]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == ages.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= ages[i] &lt;= 120</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/frog-jump-ii/description" target="_blank" rel="noopener noreferrer">Frog Jump II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>stones</code> sorted in <strong>strictly increasing order</strong> representing the positions of stones in a river.</p>

<p>A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone <strong>at most once</strong>.</p>

<p>The <strong>length</strong> of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.</p>

<ul>
	<li>More formally, if the frog is at <code>stones[i]</code> and is jumping to <code>stones[j]</code>, the length of the jump is <code>|stones[i] - stones[j]|</code>.</li>
</ul>

<p>The <strong>cost</strong> of a path is the <strong>maximum length of a jump</strong> among all jumps in the path.</p>

<p>Return <em>the <strong>minimum</strong> cost of a path for the frog</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/14/example-1.png" style="width: 600px; height: 219px;" />
<pre>
<strong>Input:</strong> stones = [0,2,5,6,7]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The above figure represents one of the optimal paths the frog can take.
The cost of this path is 5, which is the maximum length of a jump.
Since it is not possible to achieve a cost of less than 5, we return it.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/14/example-2.png" style="width: 500px; height: 171px;" />
<pre>
<strong>Input:</strong> stones = [0,3,9]
<strong>Output:</strong> 9
<strong>Explanation:</strong> 
The frog can jump directly to the last stone and come back to the first stone. 
In this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.
It can be shown that this is the minimum achievable cost.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= stones[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>stones[0] == 0</code></li>
	<li><code>stones</code> is sorted in a strictly increasing order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/fruits-into-baskets-ii/description" target="_blank" rel="noopener noreferrer">Fruits Into Baskets II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays of integers, <code>fruits</code> and <code>baskets</code>, each of length <code>n</code>, where <code>fruits[i]</code> represents the <strong>quantity</strong> of the <code>i<sup>th</sup></code> type of fruit, and <code>baskets[j]</code> represents the <strong>capacity</strong> of the <code>j<sup>th</sup></code> basket.</p>

<p>From left to right, place the fruits according to these rules:</p>

<ul>
	<li>Each fruit type must be placed in the <strong>leftmost available basket</strong> with a capacity <strong>greater than or equal</strong> to the quantity of that fruit type.</li>
	<li>Each basket can hold <b>only one</b> type of fruit.</li>
	<li>If a fruit type <b>cannot be placed</b> in any basket, it remains <b>unplaced</b>.</li>
</ul>

<p>Return the number of fruit types that remain unplaced after all possible allocations are made.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">fruits = [4,2,5], baskets = [3,5,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>fruits[0] = 4</code> is placed in <code>baskets[1] = 5</code>.</li>
	<li><code>fruits[1] = 2</code> is placed in <code>baskets[0] = 3</code>.</li>
	<li><code>fruits[2] = 5</code> cannot be placed in <code>baskets[2] = 4</code>.</li>
</ul>

<p>Since one fruit type remains unplaced, we return 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">fruits = [3,6,1], baskets = [6,4,7]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>fruits[0] = 3</code> is placed in <code>baskets[0] = 6</code>.</li>
	<li><code>fruits[1] = 6</code> cannot be placed in <code>baskets[1] = 4</code> (insufficient capacity) but can be placed in the next available basket, <code>baskets[2] = 7</code>.</li>
	<li><code>fruits[2] = 1</code> is placed in <code>baskets[1] = 4</code>.</li>
</ul>

<p>Since all fruits are successfully placed, we return 0.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == fruits.length == baskets.length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= fruits[i], baskets[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-simulation">Approach: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the input size is small, we can simulate the process directly. We iterate over each fruit from left to right and try to find a basket that can hold it. A fruit can only be placed in a basket if the basket’s capacity is greater than or equal to the fruit's requirement. Once a fruit is placed in a basket, that basket is marked as used and cannot be used again.</p>
<p>There are two possibilities for each fruit:</p>
<ol>
<li>If a basket with enough capacity is found, we use that basket and mark it as unavailable by setting its capacity to <code>0</code>.</li>
<li>If no such basket is found, we increment the counter <code>count</code> to indicate this fruit couldn't be placed.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/aYf8vso2/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{fruits}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>Every time a fruit is encountered, the basket array needs to be traversed.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>Only a few additional variables were used.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/fruits-into-baskets-iii/description" target="_blank" rel="noopener noreferrer">Fruits Into Baskets III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays of integers, <code>fruits</code> and <code>baskets</code>, each of length <code>n</code>, where <code>fruits[i]</code> represents the <strong>quantity</strong> of the <code>i<sup>th</sup></code> type of fruit, and <code>baskets[j]</code> represents the <strong>capacity</strong> of the <code>j<sup>th</sup></code> basket.</p>

<p>From left to right, place the fruits according to these rules:</p>

<ul>
	<li>Each fruit type must be placed in the <strong>leftmost available basket</strong> with a capacity <strong>greater than or equal</strong> to the quantity of that fruit type.</li>
	<li>Each basket can hold <b>only one</b> type of fruit.</li>
	<li>If a fruit type <b>cannot be placed</b> in any basket, it remains <b>unplaced</b>.</li>
</ul>

<p>Return the number of fruit types that remain unplaced after all possible allocations are made.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">fruits = [4,2,5], baskets = [3,5,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>fruits[0] = 4</code> is placed in <code>baskets[1] = 5</code>.</li>
	<li><code>fruits[1] = 2</code> is placed in <code>baskets[0] = 3</code>.</li>
	<li><code>fruits[2] = 5</code> cannot be placed in <code>baskets[2] = 4</code>.</li>
</ul>

<p>Since one fruit type remains unplaced, we return 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">fruits = [3,6,1], baskets = [6,4,7]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>fruits[0] = 3</code> is placed in <code>baskets[0] = 6</code>.</li>
	<li><code>fruits[1] = 6</code> cannot be placed in <code>baskets[1] = 4</code> (insufficient capacity) but can be placed in the next available basket, <code>baskets[2] = 7</code>.</li>
	<li><code>fruits[2] = 1</code> is placed in <code>baskets[1] = 4</code>.</li>
</ul>

<p>Since all fruits are successfully placed, we return 0.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == fruits.length == baskets.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= fruits[i], baskets[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-square-root-decomposition">Approach 1: Square Root Decomposition</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem is similar to <a href="https://leetcode.com/problems/fruits-into-baskets-ii/description/">3479. Fruits Into Baskets II</a>, but the difference lies in the <strong>larger input size</strong>, making a direct simulation inefficient.</p>
<p>To optimize, we apply a <strong>square root decomposition</strong> approach.</p>
<p>We divide the <code>baskets</code> array into <span class="math inline">\(\sqrt{n}\)</span> blocks, each of size <span class="math inline">\(m = \sqrt{n}\)</span> (approximately). For each block, we maintain the <strong>maximum value</strong> in that block in an auxiliary array <code>maxV</code>.</p>
<p>For each fruit, we scan these blocks <strong>block by block</strong>. There are two possibilities for a given block:</p>
<ol>
<li>If the maximum basket capacity in the current block is <strong>less than</strong> the fruit’s quantity, we <strong>skip</strong> this block entirely.</li>
<li>If the block contains a basket that can hold the fruit (<code>maxV[sec] &gt;= fruit</code>), we scan that block to find the <strong>leftmost</strong> basket that can hold the fruit, place it (set it to 0), and update the block’s maximum value.</li>
</ol>
<p>If no such basket is found after scanning all blocks, we increment the count of <strong>unplaced fruits</strong>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cpGNUNn7/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{baskets}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times \sqrt{n}) = O(n^{\frac32})\)</span>.</p>
<p>Enumerating the fruits in <span class="math inline">\(\textit{fruits}\)</span> requires <span class="math inline">\(O(n)\)</span> time, and traversing each block takes <span class="math inline">\(O(\sqrt{n})\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sqrt{n})\)</span>.</p>
<p>We need to maintain the maximum capacity of the baskets in each block.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-segment-tree--binary-search">Approach 2: Segment Tree + Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This is a template problem for a segment tree, where we can use a segment tree to maintain the maximum value of the <span class="math inline">\(\textit{baskets}\)</span> array over intervals, and then use binary search to find the first basket that meets the condition. The specific method is as follows:</p>
<ol>
<li>First, establish a tree where the content maintained at initialization is the maximum value of each interval.</li>
<li>Then, enumerate the fruits in <span class="math inline">\(\textit{fruits}\)</span>, and use the segment tree to find the maximum value in the interval during the binary search process to locate the first basket that meets the condition. If such a basket is found, use the segment tree to perform a single-point update on that basket, setting its value to <span class="math inline">\(0\)</span>. Otherwise, increment the counter <span class="math inline">\(\textit{count}\)</span>.</li>
<li>The process of binary search is as follows: If the maximum value in the left interval is greater than the current number of fruits, continue the binary search in the left interval. If the maximum value in the left interval is less than the current number of fruits and the maximum value in the right interval is greater than or equal to the current number of fruits, continue the binary search in the right interval. Otherwise, there is no interval that meets the condition in the current range.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/j6P3ESsL/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{baskets}\)</span>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n \log^2 n)\)</span><br />
Constructing the segment tree takes <span class="math inline">\(O(n)\)</span> time. Enumerating the fruits in <span class="math inline">\(\textit{fruits}\)</span> requires <span class="math inline">\(O(n)\)</span> time. For each fruit, we perform a binary search over the index range, which takes <span class="math inline">\(O(\log n)\)</span> iterations. Each binary-search iteration calls a segment-tree range query, which costs <span class="math inline">\(O(\log n)\)</span>. Therefore, the binary search contributes <span class="math inline">\(O(\log n) \cdot O(\log n) = O(\log^2 n)\)</span> per fruit. We also perform one segment-tree update per fruit, costing <span class="math inline">\(O(\log n)\)</span>, but this does not change the overall bound. Over <span class="math inline">\(n\)</span> fruits, the total time is <span class="math inline">\(O(n \log^2 n)\)</span>.</li>
</ul>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>It requires <span class="math inline">\(O(n)\)</span> space to store the segment tree.</p>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> In order to reduce the complexity to <span class="math inline">\(O(n \log n)\)</span>, we can modify the query operation so that it directly returns the position of the first element with a value greater than or equal to a given threshold, removing the need for binary search entirely. Alternatively, we can sort <span class="math inline">\(\textit{baskets}\)</span> by value while keeping their original positions, then build a minimum segment tree on those original positions. With this setup, a single <code>lower_bound</code> operation can find the start of the interval of baskets with greater or equal capacity, and we can then call the query just once.</p>
</blockquote>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/get-equal-substrings-within-budget/description" target="_blank" rel="noopener noreferrer">Get Equal Substrings Within Budget</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code> of the same length and an integer <code>maxCost</code>.</p>

<p>You want to change <code>s</code> to <code>t</code>. Changing the <code>i<sup>th</sup></code> character of <code>s</code> to <code>i<sup>th</sup></code> character of <code>t</code> costs <code>|s[i] - t[i]|</code> (i.e., the absolute difference between the ASCII values of the characters).</p>

<p>Return <em>the maximum length of a substring of </em><code>s</code><em> that can be changed to be the same as the corresponding substring of </em><code>t</code><em> with a cost less than or equal to </em><code>maxCost</code>. If there is no substring from <code>s</code> that can be changed to its corresponding substring from <code>t</code>, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> &quot;abc&quot; of s can change to &quot;bcd&quot;.
That costs 3, so the maximum length is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> Each character in s costs 2 to change to character in t,  so the maximum length is 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0
<strong>Output:</strong> 1
<strong>Explanation:</strong> You cannot make any change, so the maximum length is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>t.length == s.length</code></li>
	<li><code>0 &lt;= maxCost &lt;= 10<sup>6</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-sliding-window">Approach: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given two strings, <code>s</code> and <code>t</code>, of the same length, <code>N</code>. In one operation, we can choose an index <code>i</code> and convert the character <code>s[i]</code> to <code>t[i]</code>; the cost of this operation will be <code>|s[i] - t[i]|</code>. We can perform as many operations as we want as long as the total cost of all operations is less than or equal to <code>maxCost</code>. We need to return the maximum length of a substring in <code>s</code> that can be converted to the corresponding substring in <code>t</code>.</p>
<p>The naive way to solve this problem is to generate all substrings of <code>s</code> and their corresponding substring in <code>t</code>. Then, find the cost of converting each substring from <code>s</code> to <code>t</code>. If the cost is less than <code>maxCost</code>, then we can update the maximum length with the current substring length. However, this approach is inefficient as we would need to use nested loops to generate each substring and find the cost, leading to a time complexity of <span class="math inline">\(O(N^3)\)</span>.</p>
<p>The key observation here is that we can only apply one operation at a given index of strings <code>s</code> and <code>t</code>; i.e., we can only convert the character <code>s[i]</code> to <code>t[i]</code> and not any other index of <code>t</code>. If we create a new costs array with the value at the <code>ith</code> index as <code>s[i] - t[i]</code>, then the problem transforms to finding the maximum subarray with a sum less than or equal to <code>maxCost</code>. This is because each index in this new array is the cost of converting the <code>ith</code> character in <code>s</code> to <code>t</code>. Thus, the sum of the subarray is the total cost of converting the substring in <code>s</code> to <code>t</code>.</p>
<p>This is somewhat similar to the problem <a href="https://leetcode.com/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a> that can be solved using a sliding window. The sliding window pattern is applicable when the problem involves achieving a goal using subarrays or substrings, and individual elements cannot be independently selected. The concept behind the sliding window pattern is to maintain a window that meets the condition by continuously expanding from the right. If the condition ceases to be met, we adjust the window by shrinking it from the left until the condition is met again.</p>
<p>To save space, we can apply the sliding window pattern to track the cost of the substrings instead of creating a separate cost array. We use the variable <code>start</code> to track the left end of the window and <code>i</code> to track the right end. The condition is when the cost of the current window is less than or equal to the <code>maxCost</code>.</p>
<p>We can process <code>s</code> using a sliding window. We will keep adding the element on the right to the current cost, <code>currCost</code>. If the <code>currCost</code> becomes more than the <code>maxCost</code>, we will remove the elements from the left end. Then, we can compare the length of the current substring (from the left end <code>start</code> to the current index <code>i</code>) with the maximum length we have found so far and update the variable <code>maxLen</code> accordingly.</p>
<p>!?!../Documents/1208-re/1208_Get_Equal_Substrings_Within_Budget.json:960,720!?! <br></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize the variables:</p>
<ul>
<li><code>maxLen</code> to <code>0</code>'; this will be the maximum length of a substring with a cost less than or equal to <code>maxCost</code> we have seen so far.</li>
<li><code>start</code> to <code>0</code>; this is the left end of the current substring.</li>
<li><code>currCost</code> to <code>0</code>; this will be the cost of converting the current window substring in <code>s</code> to <code>t</code>.</li>
</ul>
</li>
<li>
<p>Iterate over the indices from <code>0</code> to <code>N - 1</code> and for each index <code>i</code>:</p>
<ul>
<li>Add the cost to convert <code>s[i]</code> to <code>t[i]</code> to the variable <code>currCost</code></li>
<li>Keep removing the elements from the left end by decrementing the cost required for the character at index <code>start</code> until <code>currCost</code> becomes less than or equal to <code>maxCost</code>.</li>
<li>Compare the length of the current window <code>i - start + 1</code> with the <code>maxLen</code> and update it accordingly.</li>
</ul>
</li>
<li>
<p>Return <code>maxLen</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VT832uwv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the length of the strings <code>s</code> and <code>t</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We will process each index of <code>s</code> and <code>t</code> at most twice. This is because we iterate over the character while extending the window from the right side, and again while contracting the window from the left end. Therefore, the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We do not need any extra space apart from some variables, and hence, the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/guess-number-higher-or-lower/description" target="_blank" rel="noopener noreferrer">Guess Number Higher or Lower</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">interactive</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are playing the Guess Game. The game is as follows:</p>

<p>I pick a number from <code>1</code> to <code>n</code>. You have to guess which number I picked.</p>

<p>Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.</p>

<p>You call a pre-defined API <code>int guess(int num)</code>, which returns three possible results:</p>

<ul>
	<li><code>-1</code>: Your guess is higher than the number I picked (i.e. <code>num &gt; pick</code>).</li>
	<li><code>1</code>: Your guess is lower than the number I picked (i.e. <code>num &lt; pick</code>).</li>
	<li><code>0</code>: your guess is equal to the number I picked (i.e. <code>num == pick</code>).</li>
</ul>

<p>Return <em>the number that I picked</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 10, pick = 6
<strong>Output:</strong> 6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1, pick = 1
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 2, pick = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>1 &lt;= pick &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/heaters/description" target="_blank" rel="noopener noreferrer">Heaters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.</p>

<p>Every house can be warmed, as long as the house is within the heater&#39;s warm radius range.&nbsp;</p>

<p>Given the positions of <code>houses</code> and <code>heaters</code> on a horizontal line, return <em>the minimum radius standard of heaters&nbsp;so that those heaters could cover all houses.</em></p>

<p><strong>Notice</strong> that&nbsp;all the <code>heaters</code> follow your radius standard, and the warm radius will be the same.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> houses = [1,2,3], heaters = [2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> houses = [1,2,3,4], heaters = [1,4]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> houses = [1,5], heaters = [2]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= houses.length, heaters.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= houses[i], heaters[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/h-index-ii/description" target="_blank" rel="noopener noreferrer">H-Index II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper and <code>citations</code> is sorted in <strong>non-descending order</strong>, return <em>the researcher&#39;s h-index</em>.</p>

<p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>

<p>You must write an algorithm that runs in logarithmic time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> citations = [0,1,3,5,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> citations = [1,2,100]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == citations.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>
	<li><code>citations</code> is sorted in <strong>ascending order</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/house-robber-iv/description" target="_blank" rel="noopener noreferrer">House Robber IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he <strong>refuses to steal from adjacent homes</strong>.</p>

<p>The <strong>capability</strong> of the robber is the maximum amount of money he steals from one house of all the houses he robbed.</p>

<p>You are given an integer array <code>nums</code> representing how much money is stashed in each house. More formally, the <code>i<sup>th</sup></code> house from the left has <code>nums[i]</code> dollars.</p>

<p>You are also given an integer <code>k</code>, representing the <strong>minimum</strong> number of houses the robber will steal from. It is always possible to steal at least <code>k</code> houses.</p>

<p>Return <em>the <strong>minimum</strong> capability of the robber out of all the possible ways to steal at least </em><code>k</code><em> houses</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,5,9], k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
There are three ways to rob at least 2 houses:
- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.
- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.
- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.
Therefore, we return min(5, 9, 9) = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,7,9,3,1], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>This is yet another problem based on the <strong>House Robber</strong> series! This article will assume some prior knowledge of the <a href="https://leetcode.com/problems/house-robber/">original version</a>, so you may want to solve that before this one. So before diving in, let's quickly recall the core idea behind the original problem.</p>
<p>In the classic House Robber problem, the goal is to maximize the total amount stolen from a row of houses while following one key restriction: the robber cannot rob two consecutive houses. This forces the robber into a branched decision making process that at each house, they must choose whether to rob it or skip it. If they robs it, they must add its value to the best amount stolen from two houses before. If they skips it, they simply takes the best amount stolen from the previous house. This naturally leads to a recursive relationship:</p>
<p><code>maxAmount(houseNumber) = max(maxAmount(houseNumber - 1), maxAmount(houseNumber - 2) + amount(houseNumber))</code></p>
<p>Using dynamic programming, we can store these values and efficiently compute the maximum amount the robber can steal.</p>
<p>In this current problem, the robber still has to follow the restraint that they cannot steal from two consecutive houses. However, this time, instead of maximizing the total reward, they want to <strong>minimize the maximum amount stolen from any single house</strong> while ensuring that at least <code>k</code> houses are robbed.</p>
<p>Similar to the original problem, we can think of a recursive relation to solve this. Again, we have two choices:</p>
<ol>
<li>Rob the current house (but then we must skip the next house).</li>
<li>Skip the current house and move forward.</li>
</ol>
<p>However, unlike the original problem, we need an additional condition—ensuring that we rob at least <code>k</code> houses. The dynamic programming solution involves a state <code>dp[houseIndex][numberOfHousesRobbed]</code>. Since we iterate over <code>n</code> houses and track up to <code>k</code> robbed houses, the problem becomes more complex, and solving it with dynamic programming takes <span class="math inline">\(O(n \cdot k)\)</span> time.</p>
<p>Problems that require <strong>minimizing the maximum</strong> or <strong>maximizing the minimum</strong> often suggest a binary search approach. Instead of searching through indices or subsets directly, we can binary search on the <strong>capability</strong> (i.e., something like the maximum amount stolen from any single house). By determining whether a given capability is achievable, we can efficiently narrow down the possible solutions. If you're unfamiliar with this technique, you can refer to <a href="https://leetcode.com/explore/learn/card/binary-search/">this guide</a> to learn more about binary search.</p>
<hr />
<h3 id="approach-binary-search">Approach: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Instead of focusing on maximizing a total sum, we need to guarantee that the <strong>maximum amount stolen from any robbed house</strong> is as <strong>small</strong> as possible while still robbing at least <code>k</code> houses. A brute force approach would involve checking every possible way to rob <code>k</code> houses while obeying the adjacency constraint, but this would be too slow for large inputs.</p>
<p>A more efficient way to approach this problem is to recognize that we are trying to minimize the maximum stolen amount while ensuring that at least <code>k</code> houses are robbed. This naturally leads to using binary search on the maximum reward that the robber can steal from any single house.</p>
<p>We define the search space based on the possible values for this <strong>maximum</strong> reward. The smallest possible value for this maximum reward is <code>min(nums)</code> (the lowest value in the house list), and the largest possible value is <code>max(nums)</code> (the highest value in the house list). This gives us a range of <code>[minReward, maxReward]</code>, where <code>minReward = min(nums)</code> or more specifically <code>1</code> and <code>maxReward = max(nums)</code>.</p>
<p>We use binary search to determine the <strong>minimum possible capability</strong> that still allows robbing at least <code>k</code> houses. At each step, we take the middle value in our range (<code>midReward = (minReward + maxReward) / 2</code>) and check whether it's possible to rob at least <code>k</code> houses while ensuring that no single robbed house has a value greater than <code>midReward</code>.</p>
<p>To determine whether a particular <code>midReward</code> is feasible, we use a greedy approach. We iterate through the list of house values and greedily select houses that have at most <code>midReward</code>. Since we cannot rob consecutive houses, we skip the next house each time we choose one. We keep a count of how many houses have been robbed, and if we reach at least <code>k</code> houses, it means the current <code>midReward</code> is achievable.</p>
<ul>
<li>If it is <strong>possible</strong> to rob at least <code>k</code> houses while keeping the &quot;maximum stolen amount ≤ midReward&quot;, then we try lowering it by moving the binary search range to the left (<code>maxReward = midReward</code>).</li>
<li>If it is <strong>not possible</strong>, it means <code>midReward</code> is too low, so we increase it by moving the search range to the right (<code>minReward = midReward + 1</code>).</li>
</ul>
<p>By continuously adjusting our search range, we eventually find the <strong>smallest possible maximum stolen amount</strong> that still allows robbing at least <code>k</code> houses.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize Search Bounds:</p>
<ul>
<li>Set <code>left = 1</code> (minimum possible reward).</li>
<li>Set <code>right = maximum value in nums</code>.</li>
<li>Determine the total number of houses, <code>numHouses = houseRewards.size()</code>.</li>
</ul>
</li>
<li>
<p>Perform Binary Search on Maximum Allowed Reward:</p>
<ul>
<li>While <code>left &lt; right</code>:
<ul>
<li>Compute <code>mid = (left + right) / 2</code>, representing the maximum reward a robber can take from a house.</li>
<li>Initialize <code>housesRobbed = 0</code> to count how many houses can be robbed under this constraint.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Simulate Robbery Under the Current Constraint (<code>mid</code>):</p>
<ul>
<li>Iterate through the <code>houseRewards</code> array:
<ul>
<li>If <code>houseRewards[i] &lt;= mid</code>:
<ul>
<li>Rob the house and increment <code>housesRobbed</code>.</li>
<li>Skip the next house (<code>i++</code>) since consecutive houses cannot be robbed.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Adjust Search Range:</p>
<ul>
<li>If <code>housesRobbed &gt;= housesToRob</code>, reduce the reward constraint (<code>right = mid</code>).</li>
<li>Otherwise, increase it (<code>left = mid + 1</code>).</li>
</ul>
</li>
<li>
<p>Return the Minimum Maximum Reward:</p>
<ul>
<li>Once <code>left == right</code>, return <code>left</code>, which represents the smallest possible maximum reward that still allows robbing at least <code>housesToRob</code> houses.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/37TMAAMU/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>nums</code> array and <span class="math inline">\(m\)</span> denote the size of range of elements in <code>nums</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \log m)\)</span></p>
<p>The algorithm uses a binary search approach to determine the minimum reward required to rob at least <code>k</code> houses while following the given constraints. The search space for the reward lies between <span class="math inline">\(1\)</span> and <span class="math inline">\(m\)</span>, and the binary search reduces this range logarithmically in <span class="math inline">\(O(\log m)\)</span> iterations.</p>
<p>Within each iteration, a greedy approach is applied to traverse the array and count the number of houses that can be robbed without selecting adjacent ones. This traversal takes <span class="math inline">\(O(n)\)</span> time. Since binary search runs for <span class="math inline">\(O(\log m)\)</span> iterations, the overall time complexity is <span class="math inline">\(O(n \log m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses only a few integer variables (<code>left</code>, <code>right</code>, <code>mid</code>, <code>take</code>, <code>n</code>) to perform binary search and track the number of houses robbed. Since no additional data structures proportional to the input size are used, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/implement-router/description" target="_blank" rel="noopener noreferrer">Implement Router</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure that can efficiently manage data packets in a network router. Each data packet consists of the following attributes:</p>

<ul>
	<li><code>source</code>: A unique identifier for the machine that generated the packet.</li>
	<li><code>destination</code>: A unique identifier for the target machine.</li>
	<li><code>timestamp</code>: The time at which the packet arrived at the router.</li>
</ul>

<p>Implement the <code>Router</code> class:</p>

<p><code>Router(int memoryLimit)</code>: Initializes the Router object with a fixed memory limit.</p>

<ul>
	<li><code>memoryLimit</code> is the <strong>maximum</strong> number of packets the router can store at any given time.</li>
	<li>If adding a new packet would exceed this limit, the <strong>oldest</strong> packet must be removed to free up space.</li>
</ul>

<p><code>bool addPacket(int source, int destination, int timestamp)</code>: Adds a packet with the given attributes to the router.</p>

<ul>
	<li>A packet is considered a duplicate if another packet with the same <code>source</code>, <code>destination</code>, and <code>timestamp</code> already exists in the router.</li>
	<li>Return <code>true</code> if the packet is successfully added (i.e., it is not a duplicate); otherwise return <code>false</code>.</li>
</ul>

<p><code>int[] forwardPacket()</code>: Forwards the next packet in FIFO (First In First Out) order.</p>

<ul>
	<li>Remove the packet from storage.</li>
	<li>Return the packet as an array <code>[source, destination, timestamp]</code>.</li>
	<li>If there are no packets to forward, return an empty array.</li>
</ul>

<p><code>int getCount(int destination, int startTime, int endTime)</code>:</p>

<ul>
	<li>Returns the number of packets currently stored in the router (i.e., not yet forwarded) that have the specified destination and have timestamps in the inclusive range <code>[startTime, endTime]</code>.</li>
</ul>

<p><strong>Note</strong> that queries for <code>addPacket</code> will be made in increasing order of <code>timestamp</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;Router&quot;, &quot;addPacket&quot;, &quot;addPacket&quot;, &quot;addPacket&quot;, &quot;addPacket&quot;, &quot;addPacket&quot;, &quot;forwardPacket&quot;, &quot;addPacket&quot;, &quot;getCount&quot;]<br />
[[3], [1, 4, 90], [2, 5, 90], [1, 4, 90], [3, 5, 95], [4, 5, 105], [], [5, 2, 110], [5, 100, 110]]</span></p>

<p><strong>Output:</strong><br />
<span class="example-io">[null, true, true, false, true, true, [2, 5, 90], true, 1] </span></p>

<p><strong>Explanation</strong></p>
Router router = new Router(3); // Initialize Router with memoryLimit of 3.<br />
router.addPacket(1, 4, 90); // Packet is added. Return True.<br />
router.addPacket(2, 5, 90); // Packet is added. Return True.<br />
router.addPacket(1, 4, 90); // This is a duplicate packet. Return False.<br />
router.addPacket(3, 5, 95); // Packet is added. Return True<br />
router.addPacket(4, 5, 105); // Packet is added, <code>[1, 4, 90]</code> is removed as number of packets exceeds memoryLimit. Return True.<br />
router.forwardPacket(); // Return <code>[2, 5, 90]</code> and remove it from router.<br />
router.addPacket(5, 2, 110); // Packet is added. Return True.<br />
router.getCount(5, 100, 110); // The only packet with destination 5 and timestamp in the inclusive range <code>[100, 110]</code> is <code>[4, 5, 105]</code>. Return 1.</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;Router&quot;, &quot;addPacket&quot;, &quot;forwardPacket&quot;, &quot;forwardPacket&quot;]<br />
[[2], [7, 4, 90], [], []]</span></p>

<p><strong>Output:</strong><br />
<span class="example-io">[null, true, [7, 4, 90], []] </span></p>

<p><strong>Explanation</strong></p>
Router router = new Router(2); // Initialize <code>Router</code> with <code>memoryLimit</code> of 2.<br />
router.addPacket(7, 4, 90); // Return True.<br />
router.forwardPacket(); // Return <code>[7, 4, 90]</code>.<br />
router.forwardPacket(); // There are no packets left, return <code>[]</code>.</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= memoryLimit &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= source, destination &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= timestamp &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= startTime &lt;= endTime &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>10<sup>5</sup></code> calls will be made to <code>addPacket</code>, <code>forwardPacket</code>, and <code>getCount</code> methods altogether.</li>
	<li>queries for <code>addPacket</code> will be made in increasing order of <code>timestamp</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intersection-of-two-arrays/description" target="_blank" rel="noopener noreferrer">Intersection of Two Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their <span data-keyword="array-intersection">intersection</span></em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]
<strong>Output:</strong> [2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]
<strong>Output:</strong> [9,4]
<strong>Explanation:</strong> [4,9] is also accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting-and-two-pointers">Approach 1: Sorting and Two Pointers</h3>
<h4 id="intuition">Intuition</h4>
<p>If <code>nums1</code> and <code>nums2</code> are sorted, we can use a two pointers approach to find elements that appear in both arrays. Initialize one pointer for each array that starts at the smallest element.</p>
<p>If the numbers at both pointers are the same, add the number to a set that stores integers that appear in both arrays. Then, increase both pointers by <span class="math inline">\(1\)</span>, since this element is already processed.</p>
<p>Otherwise, if the numbers at both pointers are not equal, the smaller of the two values cannot appear in the other array because both arrays are sorted. Therefore, we can increase the pointer of the smaller value.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Sort <code>nums1</code> and <code>nums2</code> arrays.</li>
<li>Create a pointer for each array, initially set to <span class="math inline">\(0\)</span>.</li>
<li>Initialize an empty set that stores intersecting integers.</li>
<li>If the integers at both pointers equal the same value, add this value to the intersecting set and increment both pointers.</li>
<li>Otherwise, increment the pointer that points to the smaller integer value.</li>
<li>Repeat steps 4 and 5 until a pointer is out of bounds.</li>
<li>Convert the intersection set into an array.</li>
<li>Return the resulting array.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/esWGp92Z/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + m \log m)\)</span>, where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the arrays' lengths. This dominating term comes from the need to sort both input arrays at the beginning of the solution.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\min(m, n))\)</span> in the worst case when all elements in the smaller array are unique and present in the larger array. This space is necessary to store elements in the set <code>intersection</code>.</p>
<ul>
<li>The space used to store the result array is counted in the space complexity, making the worst case <span class="math inline">\(O(\min(m, n))\)</span>.</li>
<li>Some extra space is used when sorting the arrays in place, and the space complexity depends on the programming language:
<ul>
<li>In Python, the <code>sort()</code> method uses the Timsort algorithm, which requires O(n) additional space in the worst case.</li>
<li>In Java, <code>Arrays.sort()</code> for primitive types uses a Dual-Pivot QuickSort, which has a worst-case space complexity of O(\log n) due to recursion.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-built-in-set-intersection">Approach 2: Built-in Set Intersection</h3>
<h4 id="intuition-1">Intuition</h4>
<p>There are built-in intersection facilities, which provide <span class="math inline">\(O(n + m)\)</span> time complexity in the average case and <span class="math inline">\(O(n \times m)\)</span> time complexity in the worst case.</p>
<blockquote>
<p>In Python it's the <a href="https://wiki.python.org/moin/TimeComplexity#set">intersection operator</a>, and in Java it's the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html#retainAll-java.util.Collection-">retainAll() function</a>.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a set <code>set1</code> and add all elements of <code>nums1</code> to it.</li>
<li>Initialize a set <code>set2</code> and add all elements of <code>nums2</code> to it.</li>
<li>Call the built-in set intersection method (either <code>retainAll()</code> in Java, or <code>&amp;</code> operator in Python).</li>
<li>Transform the resulting set into an array and return this result.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/C2TF5Yk6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span>, where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the arrays' lengths in the average case and <span class="math inline">\(O(n \times m)\)</span> <a href="https://wiki.python.org/moin/TimeComplexity#set">in the worst case when the load factor is high enough</a>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span> because in the worst case, when all elements in the arrays are unique, <span class="math inline">\(n\)</span> space is used to store <code>set1</code> and <span class="math inline">\(m\)</span> space is used to store <code>set2</code>. The space used to store the result is not counted in the space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-sets">Approach 3: Two Sets</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The naive approach would be to iterate through the values in the first array, <code>nums1</code>, and check whether each one is in <code>nums2</code>. If yes, add the value to the output. Such an approach would result in a less efficient solution.</p>
<blockquote>
<p>To solve the problem in linear time, let's use the data structure <code>set</code>, which provides <code>in/contains</code> operations in <span class="math inline">\(O(1)\)</span> time in the average case.</p>
</blockquote>
<p>The idea is to convert both arrays into sets and then iterate over the smallest set while checking the presence of each element in the larger set.</p>
<p>!?!../Documents/349_LIS.json:1000,352!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize a set <code>set1</code> and add all elements of <code>nums1</code> to it.</li>
<li>Initialize a set <code>set2</code> and add all elements of <code>nums2</code> to it.</li>
<li>If <code>set1</code> has more elements than <code>set2</code>, swap them.</li>
<li>For each element in <code>set1</code>, add it to the result array if it also appears in <code>set2</code>.</li>
<li>Result the result array.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RAoCNPwG/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span>, where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the arrays' lengths. <span class="math inline">\(O(n)\)</span> time is used to convert <code>nums1</code> into a set, <span class="math inline">\(O(m)\)</span> time is used to convert <code>nums2</code>, and <code>contains/in</code> operations are <span class="math inline">\(O(1)\)</span> in the average case.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span> because in the worst case, when all elements in the arrays are unique, <span class="math inline">\(n\)</span> space is used to store <code>set1</code> and <span class="math inline">\(m\)</span> space is used to store <code>set2</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-one-dictionary">Approach 4: One Dictionary</h3>
<h4 id="intuition-3">Intuition</h4>
<p>This approach uses only one additional data structure and one pass through each of <code>nums1</code> and <code>nums2</code>. The idea is to use a dictionary/map rather than a set to store information about values that appear in each array.</p>
<p>Define this dictionary as <code>seen</code>, where the key is an element that exists in one or both input arrays, and the value stores either <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>. A number <code>x</code> appears as a key in this dictionary, indicating it is present in at least one array, and the value of the key indicates if <code>x</code> has been observed in both arrays and added to the <code>result</code> array.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Initialize a dictionary/map <code>seen</code> and the <code>result</code> array.</li>
<li>For each <code>x</code> in <code>nums1</code>, set <code>seen[x]</code> to <span class="math inline">\(1\)</span>.</li>
<li>For each <code>x</code> in <code>nums2</code>, add <code>x</code> to <code>result</code> if <code>seen[x]</code> equals <span class="math inline">\(1\)</span>. Then, set <code>seen[x]</code> to <span class="math inline">\(0\)</span>, as this element has already been included in the result.</li>
<li>Result the result array.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/6m6gWp2U/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums1</code> and <span class="math inline">\(m\)</span> be the length of <code>nums2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span> in the average case and <span class="math inline">\(O(n \times m)\)</span> <a href="https://wiki.python.org/moin/TimeComplexity#set">in the worst case when the load factor is high enough</a>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> because we use a map of size <span class="math inline">\(n\)</span> store the elements from <code>nums1</code>. The <code>result</code> array is just used to store the result, so it is not counted in the space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intersection-of-two-arrays-ii/description" target="_blank" rel="noopener noreferrer">Intersection of Two Arrays II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]
<strong>Output:</strong> [2,2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]
<strong>Output:</strong> [4,9]
<strong>Explanation:</strong> [9,4] is also accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
	<li>What if <code>nums1</code>&#39;s size is small compared to <code>nums2</code>&#39;s size? Which algorithm is better?</li>
	<li>What if elements of <code>nums2</code> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-diff-pairs-in-an-array/description" target="_blank" rel="noopener noreferrer">K-diff Pairs in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of <b>unique</b> k-diff pairs in the array</em>.</p>

<p>A <strong>k-diff</strong> pair is an integer pair <code>(nums[i], nums[j])</code>, where the following are true:</p>

<ul>
	<li><code>0 &lt;= i, j &lt; nums.length</code></li>
	<li><code>i != j</code></li>
	<li><code>|nums[i] - nums[j]| == k</code></li>
</ul>

<p><strong>Notice</strong> that <code>|val|</code> denotes the absolute value of <code>val</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,4,1,5], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of <strong>unique</strong> pairs.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5], k = 1
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1,5,4], k = 0
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is one 0-diff pair in the array, (1, 1).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/koko-eating-bananas/description" target="_blank" rel="noopener noreferrer">Koko Eating Bananas</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Koko loves to eat bananas. There are <code>n</code> piles of bananas, the <code>i<sup>th</sup></code> pile has <code>piles[i]</code> bananas. The guards have gone and will come back in <code>h</code> hours.</p>

<p>Koko can decide her bananas-per-hour eating speed of <code>k</code>. Each hour, she chooses some pile of bananas and eats <code>k</code> bananas from that pile. If the pile has less than <code>k</code> bananas, she eats all of them instead and will not eat any more bananas during this hour.</p>

<p>Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.</p>

<p>Return <em>the minimum integer</em> <code>k</code> <em>such that she can eat all the bananas within</em> <code>h</code> <em>hours</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> piles = [3,6,7,11], h = 8
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> piles = [30,11,23,4,20], h = 5
<strong>Output:</strong> 30
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> piles = [30,11,23,4,20], h = 6
<strong>Output:</strong> 23
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= piles.length &lt;= 10<sup>4</sup></code></li>
	<li><code>piles.length &lt;= h &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= piles[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-ancestor-of-a-tree-node/description" target="_blank" rel="noopener noreferrer">Kth Ancestor of a Tree Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a tree with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> in the form of a parent array <code>parent</code> where <code>parent[i]</code> is the parent of <code>i<sup>th</sup></code> node. The root of the tree is node <code>0</code>. Find the <code>k<sup>th</sup></code> ancestor of a given node.</p>

<p>The <code>k<sup>th</sup></code> ancestor of a tree node is the <code>k<sup>th</sup></code> node in the path from that node to the root node.</p>

<p>Implement the <code>TreeAncestor</code> class:</p>

<ul>
	<li><code>TreeAncestor(int n, int[] parent)</code> Initializes the object with the number of nodes in the tree and the parent array.</li>
	<li><code>int getKthAncestor(int node, int k)</code> return the <code>k<sup>th</sup></code> ancestor of the given node <code>node</code>. If there is no such ancestor, return <code>-1</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/28/1528_ex1.png" style="width: 396px; height: 262px;" />
<pre>
<strong>Input</strong>
[&quot;TreeAncestor&quot;, &quot;getKthAncestor&quot;, &quot;getKthAncestor&quot;, &quot;getKthAncestor&quot;]
[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]
<strong>Output</strong>
[null, 1, 0, -1]

<strong>Explanation</strong>
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);
treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3
treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5
treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>parent.length == n</code></li>
	<li><code>parent[0] == -1</code></li>
	<li><code>0 &lt;= parent[i] &lt; n</code> for all <code>0 &lt; i &lt; n</code></li>
	<li><code>0 &lt;= node &lt; n</code></li>
	<li>There will be at most <code>5 * 10<sup>4</sup></code> queries.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-missing-positive-number/description" target="_blank" rel="noopener noreferrer">Kth Missing Positive Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>arr</code> of positive integers sorted in a <strong>strictly increasing order</strong>, and an integer <code>k</code>.</p>

<p>Return <em>the</em> <code>k<sup>th</sup></code> <em><strong>positive</strong> integer that is <strong>missing</strong> from this array.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,3,4,7,11], k = 5
<strong>Output:</strong> 9
<strong>Explanation: </strong>The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5<sup>th</sup>&nbsp;missing positive integer is 9.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4], k = 2
<strong>Output:</strong> 6
<strong>Explanation: </strong>The missing positive integers are [5,6,7,...]. The 2<sup>nd</sup> missing positive integer is 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 1000</code></li>
	<li><code>arr[i] &lt; arr[j]</code> for <code>1 &lt;= i &lt; j &lt;= arr.length</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<p>Could you solve this problem in less than O(n) complexity?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-smallest-amount-with-single-denomination-combination/description" target="_blank" rel="noopener noreferrer">Kth Smallest Amount With Single Denomination Combination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>k</code>.</p>

<p>You have an infinite number of coins of each denomination. However, you are <strong>not allowed</strong> to combine coins of different denominations.</p>

<p>Return the <code>k<sup>th</sup></code> <strong>smallest</strong> amount that can be made using these coins.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">coins = [3,6,9], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
"> 9</span></p>

<p><strong>Explanation:</strong> The given coins can make the following amounts:<br />
Coin 3 produces multiples of 3: 3, 6, 9, 12, 15, etc.<br />
Coin 6 produces multiples of 6: 6, 12, 18, 24, etc.<br />
Coin 9 produces multiples of 9: 9, 18, 27, 36, etc.<br />
All of the coins combined produce: 3, 6, <u><strong>9</strong></u>, 12, 15, etc.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong><span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
"> coins = [5,2], k = 7</span></p>

<p><strong>Output:</strong><span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
"> 12 </span></p>

<p><strong>Explanation:</strong> The given coins can make the following amounts:<br />
Coin 5 produces multiples of 5: 5, 10, 15, 20, etc.<br />
Coin 2 produces multiples of 2: 2, 4, 6, 8, 10, 12, etc.<br />
All of the coins combined produce: 2, 4, 5, 6, 8, 10, <u><strong>12</strong></u>, 14, 15, etc.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= coins.length &lt;= 15</code></li>
	<li><code>1 &lt;= coins[i] &lt;= 25</code></li>
	<li><code>1 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>
	<li><code>coins</code> contains pairwise distinct integers.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/kth-element-in-matrix/1" target="_blank" rel="noopener noreferrer">Kth smallest element in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">heap</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;">Given a matrix&nbsp;<strong>mat[][]</strong>&nbsp;of size <strong>n*n</strong>, where each row and column is sorted in&nbsp;<strong>non-decreasing</strong>&nbsp;order. Find the&nbsp;<strong>kth</strong>&nbsp;smallest element in the matrix.</span></span></p>
<div><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Examples:</strong></span></span></div>
<pre><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Input: </strong>mat[][] = [[16, 28, 60, 64], k = 3<br />                [22, 41, 63, 91],<br />                [27, 50, 87, 93],<br />                [36, 78, 87, 94]]
<strong>Output: </strong>27
<strong>Explanation: </strong>27 is the 3<sup>rd</sup> smallest element.</span></span></pre>
<pre><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Input: </strong>mat[][] = [[10, 20, 30, 40], k = 7<br />                [15, 25, 35, 45],<br />                [24, 29, 37, 48],<br />                [32, 33, 39, 50]] 
<strong>Output: </strong>30
<strong>Explanation: </strong>30 is the 7<sup>th</sup> smallest element.</span></span></pre>
<p><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Constraints:</strong><br />1 &le; n &le; 500<br />1 &le; mat[i][j] &le; 10<sup>4</sup></span></span><br /><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;">1 &le; k &le; n*n</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description" target="_blank" rel="noopener noreferrer">Kth Smallest Element in a Sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest element in the matrix</em>.</p>

<p>Note that it is the <code>k<sup>th</sup></code> smallest element <strong>in the sorted order</strong>, not the <code>k<sup>th</sup></code> <strong>distinct</strong> element.</p>

<p>You must find a solution with a memory complexity better than <code>O(n<sup>2</sup>)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
<strong>Output:</strong> 13
<strong>Explanation:</strong> The elements in the matrix are [1,5,9,10,11,12,13,<u><strong>13</strong></u>,15], and the 8<sup>th</sup> smallest number is 13
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[-5]], k = 1
<strong>Output:</strong> -5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 300</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>
	<li>All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.</li>
	<li><code>1 &lt;= k &lt;= n<sup>2</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Could you solve the problem with a constant memory (i.e., <code>O(1)</code> memory complexity)?</li>
	<li>Could you solve the problem in <code>O(n)</code> time complexity? The solution may be too advanced for an interview but you may find reading <a href="http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf" target="_blank">this paper</a> fun.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-smallest-number-in-multiplication-table/description" target="_blank" rel="noopener noreferrer">Kth Smallest Number in Multiplication Table</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Nearly everyone has used the <a href="https://en.wikipedia.org/wiki/Multiplication_table" target="_blank">Multiplication Table</a>. The multiplication table of size <code>m x n</code> is an integer matrix <code>mat</code> where <code>mat[i][j] == i * j</code> (<strong>1-indexed</strong>).</p>

<p>Given three integers <code>m</code>, <code>n</code>, and <code>k</code>, return <em>the </em><code>k<sup>th</sup></code><em> smallest element in the </em><code>m x n</code><em> multiplication table</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg" style="width: 500px; height: 254px;" />
<pre>
<strong>Input:</strong> m = 3, n = 3, k = 5
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 5<sup>th</sup> smallest number is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg" style="width: 493px; height: 293px;" />
<pre>
<strong>Input:</strong> m = 2, n = 3, k = 6
<strong>Output:</strong> 6
<strong>Explanation:</strong> The 6<sup>th</sup> smallest number is 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-memory-limit-exceeded">Approach #1: Brute Force [Memory Limit Exceeded]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Create the multiplication table and sort it, then take the <span class="math inline">\(k^{th}\)</span> element.</p>
<p><a href="https://leetcode.com/playground/JNTnTCLa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m*n)\)</span> to create the table, and <span class="math inline">\(O(m*n\log(m*n))\)</span> to sort it.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(m*n)\)</span> to store the table.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-next-heap-time-limit-exceeded">Approach #2: Next Heap [Time Limit Exceeded]</h3>
<p><strong>Intuition</strong></p>
<p>Maintain a heap of the smallest unused element of each row. Then, finding the next element is a pop operation on the heap.</p>
<p><strong>Algorithm</strong></p>
<p>Our <code>heap</code> is going to consist of elements <span class="math inline">\(\text{(val, root)}\)</span>, where <span class="math inline">\(\text{val}\)</span> is the next unused value of that row, and <span class="math inline">\(\text{root}\)</span> was the starting value of that row.</p>
<p>We will repeatedly find the next lowest element in the table. To do this, we pop from the heap. Then, if there's a next lowest element in that row, we'll put that element back on the heap.</p>
<p><a href="https://leetcode.com/playground/Evrh9ssK/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(k * m \log m) = O(m^2 n \log m)\)</span>.  Our initial heapify operation is <span class="math inline">\(O(m)\)</span>.  Afterwards, each pop and push is <span class="math inline">\(O(m \log m)\)</span>, and our outer loop is <span class="math inline">\(O(k) = O(m*n)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m)\)</span>. Our heap is implemented as an array with <span class="math inline">\(m\)</span> elements.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-binary-search-accepted">Approach #3: Binary Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>As <span class="math inline">\(\text{k}\)</span> and <span class="math inline">\(\text{m*n}\)</span> are up to <span class="math inline">\(9 * 10^8\)</span>, linear solutions will not work. This motivates solutions with <span class="math inline">\(\log\)</span> complexity, such as binary search.</p>
<p><strong>Algorithm</strong></p>
<p>Let's do the binary search for the answer <span class="math inline">\(\text{A}\)</span>.</p>
<p>Say <code>enough(x)</code> is true if and only if there are <span class="math inline">\(\text{k}\)</span> or more values in the multiplication table that are less than or equal to <span class="math inline">\(\text{x}\)</span>.  Colloquially, <code>enough</code> describes whether <span class="math inline">\(\text{x}\)</span> is large enough to be the <span class="math inline">\(k^{th}\)</span> value in the multiplication table.</p>
<p>Then (for our answer <span class="math inline">\(\text{A}\)</span>), whenever <span class="math inline">\(\text{x}\)</span> ≥ <span class="math inline">\(\text{A}\)</span>, <code>enough(x)</code> is <code>True</code>; and whenever <span class="math inline">\(\text{x < A}\)</span>, <code>enough(x)</code> is <code>False</code>.</p>
<p>In our binary search, our loop invariant is <code>enough(hi) = True</code>. In the beginning, <code>enough(m*n) = True</code>, and whenever <code>hi</code> is set, it is set to a value that is &quot;enough&quot; (<code>enough(mi) = True</code>). That means <code>hi</code> will be the lowest such value at the end of our binary search.</p>
<p>This leaves us with the task of counting how many values are less than or equal to <span class="math inline">\(\text{x}\)</span>. For each of <span class="math inline">\(\text{m}\)</span> rows, the <span class="math inline">\(i^{th}\)</span> row looks like <span class="math inline">\(\text{[i, 2*i, 3*i, ..., n*i]}\)</span>. The largest possible <span class="math inline">\(\text{k*i &leq; x}\)</span> that could appear is <span class="math inline">\(\text{k = x // i}\)</span>. However, if <span class="math inline">\(\text{x}\)</span> is really big, then perhaps <span class="math inline">\(\text{k > n}\)</span>, so in total there are <span class="math inline">\(\text{min(k, n) = min(x // i, n)}\)</span> values in that row that are less than or equal to <span class="math inline">\(\text{x}\)</span>.</p>
<p>After we have the count of how many values in the table are less than or equal to <span class="math inline">\(\text{x}\)</span>, by the definition of <code>enough(x)</code>, we want to know if that count is greater than or equal to <span class="math inline">\(\text{k}\)</span>.</p>
<p><a href="https://leetcode.com/playground/4ankdsg9/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m * \log (m*n))\)</span>. Our binary search divides the interval <span class="math inline">\(\text{[lo, hi]}\)</span> into half at each step. At each step, we call <code>enough</code> which requires <span class="math inline">\(O(m)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>. We only keep integers in memory during our intermediate calculations.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-th-smallest-prime-fraction/description" target="_blank" rel="noopener noreferrer">K-th Smallest Prime Fraction</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a sorted integer array <code>arr</code> containing <code>1</code> and <strong>prime</strong> numbers, where all the integers of <code>arr</code> are unique. You are also given an integer <code>k</code>.</p>

<p>For every <code>i</code> and <code>j</code> where <code>0 &lt;= i &lt; j &lt; arr.length</code>, we consider the fraction <code>arr[i] / arr[j]</code>.</p>

<p>Return <em>the</em> <code>k<sup>th</sup></code> <em>smallest fraction considered</em>. Return your answer as an array of integers of size <code>2</code>, where <code>answer[0] == arr[i]</code> and <code>answer[1] == arr[j]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,5], k = 3
<strong>Output:</strong> [2,5]
<strong>Explanation:</strong> The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
The third fraction is 2/5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,7], k = 1
<strong>Output:</strong> [1,7]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= arr.length &lt;= 1000</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>arr[0] == 1</code></li>
	<li><code>arr[i]</code> is a <strong>prime</strong> number for <code>i &gt; 0</code>.</li>
	<li>All the numbers of <code>arr</code> are <strong>unique</strong> and sorted in <strong>strictly increasing</strong> order.</li>
	<li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you solve the problem with better than <code>O(n<sup>2</sup>)</code> complexity?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find the <code class="">k<sup>th</sup></code> smallest fraction formed by dividing elements at different indices of a sorted array containing only <code>1</code> and prime numbers. The task is to return an array of two elements representing the numerator and denominator of the <code class="">k<sup>th</sup></code> smallest fraction.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>To count the number of fractions smaller than a given fraction, we can iterate through the array and consider all possible pairs of indices <code>(i, j)</code> where <code>i &lt; j</code>. For each pair, we check if the fraction formed by <code>arr[i] / arr[j]</code> is smaller than the given fraction. If it is, we increment the count.</p>
<p>Since the array is sorted, we notice that if <code>arr[i] / arr[j]</code> is smaller than the given fraction, then all subsequent fractions formed by <code>arr[i] / arr[k]</code> where <code>k &gt; j</code> will also be smaller than the given fraction.</p>
<p>If we apply the above strategy, the fractions formed by dividing elements at different indices in the sorted array will maintain their sorted order. This enables us to efficiently solve the problem using binary search.</p>
<p>Now, the key question arises: How can we determine how many fractions are smaller than a given value? Since the array is sorted, we can count fractions by comparing their values against a reference value.</p>
<p>This reference value can be any fraction between <code>0</code> and <code>1</code>. As the array contains only <code>1</code> and prime numbers, we know that all the fractions will be between <code>0</code> and <code>1</code>. Therefore, we can set the initial search range to <code>[0, 1)</code>. We initialize two pointers, <code>left</code> and <code>right</code>, representing the lower and upper bounds of the possible fractions.</p>
<p>We use binary search to iteratively narrow down the search space for the <code class="">k<sup>th</sup></code> smallest fraction. At each step, we calculate the midpoint of the range (<code>mid</code>). Using a two-pointer approach, we compare each element of the array to <code>mid</code> and keep a count of how many fractions are smaller than or equal to it. This count helps in evaluating whether to adjust the left or right bounds of our search range and also ensures that we methodically pinpoint the precise <code class="">k<sup>th</sup></code> fraction by reducing the interval based on the number of smaller fractions found.</p>
<p>However, while iterating through the array, we're also exploring the set of possible fractions, gradually revealing the smallest fractions first. During this exploration, we maintain a record of the maximum fraction encountered so far within the current search range.</p>
<p>Now, why is this maximum fraction significant? In a sorted array of unique numbers, the fractions increase gradually as we move left to right. If we've encountered <code>k</code> or more fractions smaller than or equal to this maximum fraction, then this maximum fraction is the <code class="">k<sup>th</sup></code> smallest fraction.</p>
<p>Finally, we adjust the search range based on the count of smaller fractions. If the count equals <code>k</code>, we return the current maximum fraction as the <code class="">k<sup>th</sup></code> smallest fraction. If the count is greater than <code>k</code>, we move the right pointer to <code>mid</code>. Else, we move the left pointer to <code>mid</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize the variable <code>n</code> to store the size of the input array <code>arr</code>. Set <code>left</code> to 0 and <code>right</code> to 1.0 to establish the initial range for binary search.</li>
<li>Enter a binary search loop while the left boundary (<code>left</code>) is less than the right boundary (<code>right</code>).
<ul>
<li>Calculate the midpoint of the current range, denoted as <code>mid</code>, by averaging <code>left</code> and <code>right</code>.</li>
<li>Create variables to keep track of key metrics: <code>maxFraction</code> to store the maximum fraction encountered, <code>totalSmallerFractions</code> to count the number of fractions smaller than <code>mid</code>, and <code>numeratorIdx</code> and <code>denominatorIdx</code> to record the indices of the numerator and denominator of the maximum fraction.</li>
<li>Initialize <code>j</code> to 1, representing the index for the denominator in the array.</li>
<li>Iterate through the array <code>arr</code> to identify fractions smaller than <code>mid</code>.
<ul>
<li>Increment <code>j</code> until the fraction (<code>arr[i] / arr[j]</code>) is less than or equal to <code>mid</code>, effectively finding the right boundary for the current numerator.</li>
<li>Increment <code>totalSmallerFractions</code> by the count of elements between <code>j</code> and <code>n</code>.</li>
<li>Exit the loop if <code>j</code> reaches the end of the array <code>arr</code>.</li>
<li>Calculate the fraction <code>arr[i] / arr[j]</code> and update <code>maxFraction</code>, <code>numeratorIdx</code>, and <code>denominatorIdx</code> if the calculated fraction exceeds the current maximum fraction.</li>
</ul>
</li>
<li>Check if <code>totalSmallerFractions</code> equals <code>k</code>. If it does, return the fraction with the numerator at index <code>numeratorIdx</code> and the denominator at index <code>denominatorIdx</code>.</li>
<li>If <code>totalSmallerFractions</code> exceeds <code>k</code>, update the right boundary of the search range (<code>right</code>) to <code>mid</code> to focus on the left portion of the range.</li>
<li>If <code>totalSmallerFractions</code> is less than <code>k</code>, update the left boundary of the search range (<code>left</code>) to <code>mid</code> to focus on the right portion of the range.</li>
</ul>
</li>
<li>If the loop concludes without finding the <code class="">k<sup>th</sup></code> smallest prime fraction, return an empty array.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NesZhUEz/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array and <span class="math inline">\(m\)</span> be the maximum value in the array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot log(m))\)</span></p>
<p>The algorithm uses binary search. Within each iteration of the binary search, we perform a linear scan through the array to count the number of fractions smaller than the current <code>mid</code> value. Since the array is sorted, this linear scan takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Binary search takes <span class="math inline">\(O(\log x )\)</span> where <span class="math inline">\(x\)</span> is the number of elements in the search space because each iteration reduces the size of the search space by half. We will stop generating fractions and terminate the search when the total number of smaller fractions equals <code>k</code>. This will happen when the size of the search space becomes smaller than the smallest possible difference between two fractions, which is <span class="math inline">\(\frac{1}{m^2}\)</span>.</p>
<p>This means the size of the search space can be up to <span class="math inline">\({m^2}\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot log(m^2))\)</span>, which simplifies to <span class="math inline">\(O(n \cdot log(m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses constant space becuase we only use a constant amount of extra space for storing variables regardless of the input size. We don't use any additional data structures whose size depends on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The binary search approach involves iterating through the array for each fraction being tested, which can be time-consuming, especially for large arrays.</p>
<p>To optimize this process, we can leverage the property that the smallest fractions will be formed by dividing each element by the largest element in the array. This observation leads us to the idea of using a priority queue data structure, which can efficiently maintain and update the smallest fractions as we explore the search space.</p>
<p>Consider an input array <span class="math inline">\([n_1, n_2, n_3, n_4, n_5]\)</span>, where <span class="math inline">\(n_1 < n_2 < n_3 < n_4 < n_5\)</span>. The possible fractions that can be formed from different indices of the input are:</p>
<p><span class="math inline">\(\begin{array}{cccccc} \Large{\frac{n_1}{n_5}} & \Large{\frac{n_1}{n_4}} & \Large{\frac{n_1}{n_3}} & \Large{\frac{n_1}{n_2}} \\ \\ \Large{\frac{n_2}{n_5}} & \Large{\frac{n_2}{n_4}} & \Large{\frac{n_2}{n_3}} \\ \\ \Large{\frac{n_3}{n_5}} & \Large{\frac{n_3}{n_4}} \\ \\ \Large{\frac{n_4}{n_5}} \\ \\ \\ \end{array}\)</span></p>
<p>We can observe that for each numerator, the smallest fraction will be formed by dividing by the largest element (<span class="math inline">\(n_5\)</span>).</p>
<p>The first step is to initialize a priority queue that stores pairs in the form <code>{-fraction, {numerator_index, denominator_index}}</code>. The negative sign is used to make the priority queue sort the fractions in ascending order (smallest fraction first).</p>
<p>After that, we can start by pushing all possible fractions formed by dividing each element by the last element of the array into the priority queue. This is because the last element of the sorted array is the largest.</p>
<p>After populating the priority queue, we observe that the top element of the queue will be the smallest fraction among all fractions formed by dividing each element by the last element.</p>
<p>Now, to find the <code class="">k<sup>th</sup></code> smallest fraction, we can iteratively remove the top element from the priority queue and replace it with a new fraction formed by dividing the same numerator by the next smaller denominator. This is done by decrementing the denominator index and pushing the new fraction into the priority queue.</p>
<p>The reason we decrement the denominator is that, suppose we have an array <code>[1, 2, 3, 4, 5]</code>. If we start with the largest denominator (<code>5</code>) and keep the numerator fixed (<code>1</code>), then decrement the denominator in each iteration, we will explore fractions in ascending order:</p>
<p><span class="math inline">\(\frac{1}{5}, \frac{1}{4}, \frac{1}{3}, \frac{1}{2} \)</span></p>
<p>If we were to keep the denominator fixed and increment the numerator instead, we would explore fractions in descending order:</p>
<p><span class="math inline">\( \frac{4}{5}, \frac{3}{5}, \frac{2}{5}, \frac{1}{5}\)</span></p>
<p>While both ways eventually cover all fractions formed by dividing each element by the largest element, the priority queue requires fractions to be explored in ascending order to ensure that the <code class="">k<sup>th</sup></code> smallest fraction is found efficiently.</p>
<p>By decrementing the denominator, we maintain the property that the top element of the priority queue always represents the smallest fraction among those formed by dividing each element by the largest element. This helps us identify the <code class="">k<sup>th</sup></code> smallest fraction more effectively, as the priority queue naturally orders fractions from smallest to largest</p>
<p>Essentially, we replace the smallest fraction with the next smallest fraction having the same numerator. Repeating this <code>k - 1</code> times leaves the <code class="">k<sup>th</sup></code> smallest fraction at the top of the priority queue. In a nutshell, it's about finding the <code>k</code> smallest elements in <code>n</code> sorted linked lists.</p>
<p>The following is an illustration demonstrating the priority queue approach:</p>
<p>!?!../Documents/786/pq.json:978,439!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an empty priority queue <code>pq</code> to store pairs of fractions and their corresponding indices.</li>
<li>Iterate through the input array <code>arr</code> using a loop variable <code>i</code>.
<ul>
<li>For each element <code>arr[i]</code>, calculate the fraction formed by dividing it by the largest element in the array (<code>arr[arr.size() - 1]</code>).</li>
<li>Push a pair consisting of the negative fraction value (<code>-1.0 * arr[i] / arr[arr.size() - 1]</code>) and the corresponding indices (<code>i</code> for the numerator and <code>arr.size() - 1</code> for the denominator) into the priority queue <code>pq</code>.</li>
</ul>
</li>
<li>The priority queue <code>pq</code> now contains all the fractions formed by dividing each element by the largest element in the array, sorted in ascending order based on the fraction values.</li>
<li>Repeat the following steps <code>k - 1</code> times:
<ul>
<li>Remove the top element (smallest fraction) from the priority queue <code>pq</code> and store its indices in the <code>cur</code> variable.</li>
<li>Decrement the denominator index (<code>cur[1]--</code>).</li>
<li>Calculate the new fraction formed by dividing the numerator at <code>cur[0]</code> by the decremented denominator (<code>arr[cur[1]]</code>).</li>
<li>Push the new fraction value (<code>-1.0 * arr[cur[0]] / arr[cur[1]]</code>) and its corresponding indices (<code>cur[0]</code> for the numerator and <code>cur[1]</code> for the denominator) into the priority queue <code>pq</code>.</li>
</ul>
</li>
<li>After <code>k - 1</code> iterations, the top element of the priority queue <code>pq</code> will be the <code class="">k<sup>th</sup></code> smallest fraction.</li>
<li>Extract the numerator and denominator indices from the top element of the priority queue and store them in <code>result</code>.</li>
<li>Return a array containing the numerator (<code>arr[result[0]]</code>) and denominator (<code>arr[result[1]]</code>) values corresponding to the <code class="">k<sup>th</sup></code> smallest fraction.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/M8yvD79e/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array and <span class="math inline">\(k\)</span> be the integer <code>k</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((n + k) \cdot \log n)\)</span></p>
<p>Pushing the initial fractions into the priority queue takes <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Iteratively removing and replacing fractions takes <span class="math inline">\(O(k \log n)\)</span> and retrieving the <code class="">k<sup>th</sup></code> smallest fraction takes <span class="math inline">\(O(\log n)\)</span>.</p>
<p>Thus the overall time complexity of the algorithm is <span class="math inline">\(O(n \log n + k \log n)\)</span>, which can write as <span class="math inline">\(O((n + k) \cdot \log n)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space required by the priority queue to store fractions is <span class="math inline">\(O(n)\)</span> since it can potentially hold all fractions formed by dividing each element by the largest element.</p>
<p>The additional space used by other variables like <code>cur</code>, <code>numeratorIndex</code>, <code>denominatorIndex</code>, etc., is constant and doesn't depend on the size of the input array.</p>
<p>Thus the overall space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/description" target="_blank" rel="noopener noreferrer">Kth Smallest Product of Two Sorted Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given two <strong>sorted 0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code> as well as an integer <code>k</code>, return <em>the </em><code>k<sup>th</sup></code><em> (<strong>1-based</strong>) smallest product of </em><code>nums1[i] * nums2[j]</code><em> where </em><code>0 &lt;= i &lt; nums1.length</code><em> and </em><code>0 &lt;= j &lt; nums2.length</code>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,5], nums2 = [3,4], k = 2
<strong>Output:</strong> 8
<strong>Explanation:</strong> The 2 smallest products are:
- nums1[0] * nums2[0] = 2 * 3 = 6
- nums1[0] * nums2[1] = 2 * 4 = 8
The 2<sup>nd</sup> smallest product is 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6
<strong>Output:</strong> 0
<strong>Explanation:</strong> The 6 smallest products are:
- nums1[0] * nums2[1] = (-4) * 4 = -16
- nums1[0] * nums2[0] = (-4) * 2 = -8
- nums1[1] * nums2[1] = (-2) * 4 = -8
- nums1[1] * nums2[0] = (-2) * 2 = -4
- nums1[2] * nums2[0] = 0 * 2 = 0
- nums1[2] * nums2[1] = 0 * 4 = 0
The 6<sup>th</sup> smallest product is 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3
<strong>Output:</strong> -6
<strong>Explanation:</strong> The 3 smallest products are:
- nums1[0] * nums2[4] = (-2) * 5 = -10
- nums1[0] * nums2[3] = (-2) * 4 = -8
- nums1[4] * nums2[0] = 2 * (-3) = -6
The 3<sup>rd</sup> smallest product is -6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= nums1.length * nums2.length</code></li>
	<li><code>nums1</code> and <code>nums2</code> are sorted.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-binary-search--binary-search">Approach 1: Binary Search + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem's constraints, the value range of <span class="math inline">\(\textit{nums}_1[i] \times \textit{nums}_2[j]\)</span> is <span class="math inline">\([-10^{10}, 10^{10}]\)</span>. We perform a binary search over this product range to find the <span class="math inline">\(k\)</span>-th smallest product. Let the current binary search value be <span class="math inline">\(v\)</span>. We need to compute the number of products less than or equal to <span class="math inline">\(v\)</span>, denoted as <span class="math inline">\(\textit{count}\)</span>. If <span class="math inline">\(\textit{count} \lt k\)</span>, then <span class="math inline">\(v\)</span> is too small; otherwise, it is too large or just right.</p>
<p>To calculate the number of products less than or equal to <span class="math inline">\(v\)</span>, we use another binary search. For each element <span class="math inline">\(x_1\)</span> in <span class="math inline">\(\textit{nums}_1\)</span>, we proceed as follows:</p>
<ul>
<li>
<p>If <span class="math inline">\(x_1 \ge 0\)</span>, then <span class="math inline">\(\textit{nums}_2[j] \times x_1\)</span> forms a non-decreasing sequence. We use binary search to count how many products are <span class="math inline">\(\le v\)</span>.</p>
</li>
<li>
<p>If <span class="math inline">\(x_1 \lt 0\)</span>, then <span class="math inline">\(\textit{nums}_2[j] \times x_1\)</span> forms a non-increasing sequence. In this case, we use binary search to find how many products are greater than <span class="math inline">\(v\)</span>, denoted as <span class="math inline">\(t\)</span>. Then, the number of products <span class="math inline">\(\le v\)</span> is <span class="math inline">\(n_2 - t\)</span>, where <span class="math inline">\(n_2\)</span> is the length of <span class="math inline">\(\textit{nums}_2\)</span>.</p>
</li>
</ul>
<p>Summing these counts for all elements in <span class="math inline">\(\textit{nums}_1\)</span> gives the total number of products less than or equal to <span class="math inline">\(v\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dNprwCon/shared">code</a></p>
<h4 id="complexity-analysis">Complexity analysis</h4>
<p>Let <span class="math inline">\(n_1\)</span> be the length of the array <span class="math inline">\(\textit{nums}_1\)</span>, and <span class="math inline">\(n_2\)</span> be the length of the array <span class="math inline">\(\textit{nums}_2\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n_1 \log n_2 \log C)\)</span>.</p>
<p><span class="math inline">\(C = 2 \times 10^{10} + 1\)</span> is the size of the range of the product of the two array elements required by the problem.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-binary-search--divide-and-conquer">Approach 2: Binary Search + Divide and Conquer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Similar to Approach 1, we want to compute the number of products less than or equal to a given value <span class="math inline">\(v\)</span>, but here we use a divide and conquer method. Let the lengths of <span class="math inline">\(\textit{nums}_1\)</span> and <span class="math inline">\(\textit{nums}_2\)</span> be <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_2\)</span>, respectively. We divide <span class="math inline">\(\textit{nums}_1\)</span> into two segments: <span class="math inline">\([0, \textit{pos}_1)\)</span> for values less than <span class="math inline">\(0\)</span>, and <span class="math inline">\([\textit{pos}_1, n_1)\)</span> for values greater than or equal to <span class="math inline">\(0\)</span>. Likewise, we divide <span class="math inline">\(\textit{nums}_2\)</span> into <span class="math inline">\([0, \textit{pos}_2)\)</span> for values less than <span class="math inline">\(0\)</span>, and <span class="math inline">\([\textit{pos}_2, n_2)\)</span> for values greater than or equal to <span class="math inline">\(0\)</span>. This results in four combinations of subarrays whose element-wise products we need to consider.</p>
<p>For example, take the product of the interval <span class="math inline">\([0, \textit{pos}_1)\)</span> from <span class="math inline">\(\textit{nums}_1\)</span> and the interval <span class="math inline">\([0, \textit{pos}_2)\)</span> from <span class="math inline">\(\textit{nums}_2\)</span>, and count how many resulting products are less than or equal to <span class="math inline">\(v\)</span>. Repeat this process for the other three combinations.</p>
<p>Each product combination forms a two-dimensional matrix where each cell is defined as <span class="math inline">\(q(i, j) = \textit{nums}_1[i] \times \textit{nums}_2[j]\)</span>. In this matrix, <span class="math inline">\(q(i, j)\)</span> is non-increasing as either <span class="math inline">\(i\)</span> or <span class="math inline">\(j\)</span> increases (since both sequences are sorted). To efficiently count the number of elements in the matrix that are <span class="math inline">\(\le v\)</span>, we traverse from the upper-right corner of the matrix. We initialize pointers <span class="math inline">\(i_1 = 0\)</span> and <span class="math inline">\(i_2 = \textit{pos}_2 - 1\)</span>, and we stop when either index goes out of bounds:</p>
<ul>
<li>
<p>If <span class="math inline">\(q(i_1, i_2) > v\)</span>, then all elements in the current row to the left of <span class="math inline">\((i_1, i_2)\)</span> are also greater than <span class="math inline">\(v\)</span>, so we move down to the next row by setting <span class="math inline">\(i_1 = i_1 + 1\)</span>.</p>
</li>
<li>
<p>If <span class="math inline">\(q(i_1, i_2) \le v\)</span>, then all elements in the current column above <span class="math inline">\((i_1, i_2)\)</span> are also <span class="math inline">\(\le v\)</span>. There are <span class="math inline">\(\textit{pos}_1 - i_1\)</span> such elements, so we add that count and move left by setting <span class="math inline">\(i_2 = i_2 - 1\)</span>.</p>
</li>
</ul>
<p>We repeat this process and sum all such counts. This gives the total number of products less than or equal to <span class="math inline">\(v\)</span> for the given combination of subarrays.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/CueD8RNL/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity analysis</h4>
<p>Let <span class="math inline">\(n_1\)</span> be the length of the array <span class="math inline">\(\textit{nums}_1\)</span>, and <span class="math inline">\(n_2\)</span> be the length of the array <span class="math inline">\(\textit{nums}_2\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((n_1 + n_2)\log C)\)</span></p>
<p><span class="math inline">\(C = 2 \times 10^{10} + 1\)</span> is the size of the range of the product of the two array elements required by the problem.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/last-day-where-you-can-still-cross/description" target="_blank" rel="noopener noreferrer">Last Day Where You Can Still Cross</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>1-based</strong> binary matrix where <code>0</code> represents land and <code>1</code> represents water. You are given integers <code>row</code> and <code>col</code> representing the number of rows and columns in the matrix, respectively.</p>

<p>Initially on day <code>0</code>, the <strong>entire</strong> matrix is <strong>land</strong>. However, each day a new cell becomes flooded with <strong>water</strong>. You are given a <strong>1-based</strong> 2D array <code>cells</code>, where <code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> represents that on the <code>i<sup>th</sup></code> day, the cell on the <code>r<sub>i</sub><sup>th</sup></code> row and <code>c<sub>i</sub><sup>th</sup></code> column (<strong>1-based</strong> coordinates) will be covered with <strong>water</strong> (i.e., changed to <code>1</code>).</p>

<p>You want to find the <strong>last</strong> day that it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells. You can start from <strong>any</strong> cell in the top row and end at <strong>any</strong> cell in the bottom row. You can only travel in the<strong> four</strong> cardinal directions (left, right, up, and down).</p>

<p>Return <em>the <strong>last</strong> day where it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/1.png" style="width: 624px; height: 162px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/2.png" style="width: 504px; height: 178px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/3.png" style="width: 666px; height: 167px;" />
<pre>
<strong>Input:</strong> row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>cells.length == row * col</code></li>
	<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>
	<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>
	<li>All the values of <code>cells</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/length-of-the-longest-increasing-path/description" target="_blank" rel="noopener noreferrer">Length of the Longest Increasing Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D array of integers <code>coordinates</code> of length <code>n</code> and an integer <code>k</code>, where <code>0 &lt;= k &lt; n</code>.</p>

<p><code>coordinates[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> indicates the point <code>(x<sub>i</sub>, y<sub>i</sub>)</code> in a 2D plane.</p>

<p>An <strong>increasing path</strong> of length <code>m</code> is defined as a list of points <code>(x<sub>1</sub>, y<sub>1</sub>)</code>, <code>(x<sub>2</sub>, y<sub>2</sub>)</code>, <code>(x<sub>3</sub>, y<sub>3</sub>)</code>, ..., <code>(x<sub>m</sub>, y<sub>m</sub>)</code> such that:</p>

<ul>
	<li><code>x<sub>i</sub> &lt; x<sub>i + 1</sub></code> and <code>y<sub>i</sub> &lt; y<sub>i + 1</sub></code> for all <code>i</code> where <code>1 &lt;= i &lt; m</code>.</li>
	<li><code>(x<sub>i</sub>, y<sub>i</sub>)</code> is in the given coordinates for all <code>i</code> where <code>1 &lt;= i &lt;= m</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> length of an <strong>increasing path</strong> that contains <code>coordinates[k]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coordinates = [[3,1],[2,2],[4,1],[0,0],[5,3]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><code>(0, 0)</code>, <code>(2, 2)</code>, <code>(5, 3)</code><!-- notionvc: 082cee9e-4ce5-4ede-a09d-57001a72141d --> is the longest increasing path that contains <code>(2, 2)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coordinates = [[2,1],[7,0],[5,6]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><code>(2, 1)</code>, <code>(5, 6)</code> is the longest increasing path that contains <code>(5, 6)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == coordinates.length &lt;= 10<sup>5</sup></code></li>
	<li><code>coordinates[i].length == 2</code></li>
	<li><code>0 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10<sup>9</sup></code></li>
	<li>All elements in <code>coordinates</code> are <strong>distinct</strong>.<!-- notionvc: 6e412fc2-f9dd-4ba2-b796-5e802a2b305a --><!-- notionvc: c2cf5618-fe99-4909-9b4c-e6b068be22a6 --></li>
	<li><code>0 &lt;= k &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-arithmetic-subsequence/description" target="_blank" rel="noopener noreferrer">Longest Arithmetic Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> of integers, return <em>the length of the longest arithmetic subsequence in</em> <code>nums</code>.</p>

<p><strong>Note</strong> that:</p>

<ul>
	<li>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</li>
	<li>A sequence <code>seq</code> is arithmetic if <code>seq[i + 1] - seq[i]</code> are all the same value (for <code>0 &lt;= i &lt; seq.length - 1</code>).</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,6,9,12]
<strong>Output:</strong> 4
<strong>Explanation: </strong> The whole array is an arithmetic sequence with steps of length = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,4,7,2,10]
<strong>Output:</strong> 3
<strong>Explanation: </strong> The longest arithmetic subsequence is [4,7,10].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [20,1,15,3,10,5,8]
<strong>Output:</strong> 4
<strong>Explanation: </strong> The longest arithmetic subsequence is [20,15,10,5].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 500</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-common-subpath/description" target="_blank" rel="noopener noreferrer">Longest Common Subpath</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">suffix array</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a country of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code>. In this country, there is a road connecting <b>every pair</b> of cities.</p>

<p>There are <code>m</code> friends numbered from <code>0</code> to <code>m - 1</code> who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city <strong>more than once</strong>, but the same city will not be listed consecutively.</p>

<p>Given an integer <code>n</code> and a 2D integer array <code>paths</code> where <code>paths[i]</code> is an integer array representing the path of the <code>i<sup>th</sup></code> friend, return <em>the length of the <strong>longest common subpath</strong> that is shared by <strong>every</strong> friend&#39;s path, or </em><code>0</code><em> if there is no common subpath at all</em>.</p>

<p>A <strong>subpath</strong> of a path is a contiguous sequence of cities within that path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5, paths = [[0,1,<u>2,3</u>,4],
                       [<u>2,3</u>,4],
                       [4,0,1,<u>2,3</u>]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest common subpath is [2,3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, paths = [[0],[1],[2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no common subpath shared by the three paths.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, paths = [[<u>0</u>,1,2,3,4],
                       [4,3,2,1,<u>0</u>]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>m == paths.length</code></li>
	<li><code>2 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>sum(paths[i].length) &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= paths[i][j] &lt; n</code></li>
	<li>The same city is not listed multiple times consecutively in <code>paths[i]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-duplicate-substring/description" target="_blank" rel="noopener noreferrer">Longest Duplicate Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span> <span class="topic-badge">suffix array</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, consider all <em>duplicated substrings</em>: (contiguous) substrings of s that occur 2 or more times.&nbsp;The occurrences&nbsp;may overlap.</p>

<p>Return <strong>any</strong> duplicated&nbsp;substring that has the longest possible length.&nbsp;If <code>s</code> does not have a duplicated substring, the answer is <code>&quot;&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "banana"
<strong>Output:</strong> "ana"
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "abcd"
<strong>Output:</strong> ""
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-increasing-subsequence/description" target="_blank" rel="noopener noreferrer">Longest Increasing Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>strictly increasing </strong></em><span data-keyword="subsequence-array"><em><strong>subsequence</strong></em></span>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,0,3,2,3]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,7,7,7,7,7,7]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><b>Follow up:</b>&nbsp;Can you come up with an algorithm that runs in&nbsp;<code>O(n log(n))</code> time complexity?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-square-streak-in-an-array/description" target="_blank" rel="noopener noreferrer">Longest Square Streak in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. A subsequence of <code>nums</code> is called a <strong>square streak</strong> if:</p>

<ul>
	<li>The length of the subsequence is at least <code>2</code>, and</li>
	<li><strong>after</strong> sorting the subsequence, each element (except the first element) is the <strong>square</strong> of the previous number.</li>
</ul>

<p>Return<em> the length of the <strong>longest square streak</strong> in </em><code>nums</code><em>, or return </em><code>-1</code><em> if there is no <strong>square streak</strong>.</em></p>

<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,6,16,8,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].
- 4 = 2 * 2.
- 16 = 4 * 4.
Therefore, [4,16,2] is a square streak.
It can be shown that every subsequence of length 4 is not a square streak.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,5,6,7]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no square streak in nums so return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Our task is to form a progression where each number is the square of the previous one. A basic but inefficient method would be to loop through the array and, for each number, search for its square in the rest of the array. The longest chain of such squares would represent our desired square streak.</p>
<p>However, a linear search across the entire array is too slow. To optimize, we can use binary search to find the square of a given number.</p>
<p>To apply binary search, we first sort the array. Then, we attempt to form a streak for each number by repeatedly finding its square using binary search. The number of successful squares found determines the length of the streak, and we keep track of the longest streak.</p>
<p>Further optimization is possible. Once a number has been part of a streak, it doesn’t need to be considered again as a starting point for another streak, as any new streak starting from that number would be shorter. To handle this, we can use a set to track numbers already processed as part of a streak, excluding them from being reconsidered.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Sort <code>nums</code> in ascending order.</li>
<li>Initialize a variable <code>longestStreak</code> to 0 to store the length of the longest square streak.</li>
<li>Create a set <code>processedNumbers</code> to keep track of numbers already processed.</li>
<li>Iterate through each number <code>current</code> in the sorted array:
<ul>
<li>If <code>current</code> is in <code>processedNumbers</code>, skip to the next iteration.</li>
<li>Initialize <code>streak</code> to <code>current</code> and <code>streakLength</code> to 1.</li>
<li>Enter a loop:
<ul>
<li>If the square of <code>streak</code> is greater than <span class="math inline">\(10^5\)</span>, break the loop.</li>
<li>If the square of <code>streak</code> exists in the array (using binary search):
<ul>
<li>Update <code>streak</code> to its square.</li>
<li>Add <code>streak</code> to <code>processedNumbers</code>.</li>
<li>Increment <code>streakLength</code>.</li>
</ul>
</li>
<li>Else, break the loop.</li>
</ul>
</li>
<li>Update <code>longestStreak</code> to the maximum of <code>longestStreak</code> and <code>streakLength</code>.</li>
</ul>
</li>
<li>Return -1 if <code>longestStreak</code> is less than 2, otherwise return <code>longestStreak</code>.</li>
</ul>
<p>Implement a binary search helper function:</p>
<ul>
<li>If the target is negative, return false.</li>
<li>Initialize <code>left</code> to 0 and <code>right</code> to the last index of the array.</li>
<li>While <code>left</code> is less than or equal to <code>right</code>:
<ul>
<li>Calculate the middle index <code>mid</code>.
<ul>
<li>If the element at <code>mid</code> equals the target, return true.</li>
<li>If the element at <code>mid</code> is greater than the target, update <code>right</code> to <code>mid - 1</code>.</li>
<li>Otherwise, update <code>left</code> to <code>mid + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If the target is not found, return false.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dsYGLBVb/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The first step is sorting the input array, which takes <span class="math inline">\(O(n \cdot \log n)\)</span> time. Then, for each element, it performs a series of binary searches. The number of binary searches for each element is limited by the double logarithm of the maximum possible value (<span class="math inline">\(10^5\)</span> in this case), as each step squares the current number. Each binary search takes <span class="math inline">\(O(\log n)\)</span> time. Thus, the time complexity for processing each element is <span class="math inline">\(O(\log n \cdot \log \log (10^5))\)</span>, which simplifies to <span class="math inline">\(O(\log n)\)</span> since <span class="math inline">\(\log 10^5\)</span> is a constant.</p>
<p>Considering all steps, the overall time complexity is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
<blockquote>
<p>Note: For a number x, the series of squares would be <span class="math inline">\(x\)</span>, <span class="math inline">\(x^2\)</span>, <span class="math inline">\(x^4\)</span>, <span class="math inline">\(x^8\)</span>, and so on. The length of this sequence for each number would be <span class="math inline">\(\log(\log(M))\)</span> where <span class="math inline">\(M\)</span> is the maximum possible value that can be reached. Since M here is constant, the Big-O complexity of this value is <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a set to store processed numbers, which in the worst case could contain all unique elements from the input array, leading to <span class="math inline">\(O(n)\)</span> space.</p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>Thus, the space complexity is <span class="math inline">\(O(n + S) = O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-set">Approach 2: Set</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of using binary search to check if a number exists in the array, we can leverage a set. This approach eliminates the need for sorting and allows us to check for a number in constant time rather than logarithmic time.</p>
<p>We start by initializing a set <code>uniqueNumbers</code> to store all the numbers from the array. As before, we loop through the array and treat each number as the starting point of a streak. Inside this loop, we continue searching for the square of the previous number in the sequence using the set. The longest streak we find by counting how many times the inner loop runs gives us the desired result.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a variable <code>longestStreak</code> to 0 to store the length of the longest square streak.</li>
<li>Create a set <code>uniqueNumbers</code> to store all unique numbers from the input array.</li>
<li>Iterate through each number in the input array, adding it to <code>uniqueNumbers</code>.</li>
<li>Iterate through each number <code>startNumber</code> in the input array:
<ul>
<li>Initialize :
<ul>
<li><code>currentStreak</code> to 0 to track the length of the current streak.</li>
<li><code>current</code> as a long integer with the value of <code>startNumber</code>.</li>
<li>Enter a loop that continues while <code>current</code> exists in <code>uniqueNumbers</code>:
<ul>
<li>Increment <code>currentStreak</code>.</li>
<li>If the square of <code>current</code> is greater than <span class="math inline">\(10^5\)</span>, break the loop.</li>
<li>Update <code>current</code> to its square.</li>
</ul>
</li>
</ul>
</li>
<li>Update <code>longestStreak</code> to the maximum of <code>longestStreak</code> and <code>currentStreak</code>.</li>
</ul>
</li>
<li>Return -1 if <code>longestStreak</code> is less than 2, otherwise return <code>longestStreak</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ghYhGPdZ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The algorithm iterates through each element in <code>nums</code> to fill <code>uniqueNumbers</code>, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>For each number in <code>nums</code>, the algorithm checks a sequence of squares until the square exceeds the value of the element or is not found in the set.</p>
<p>Given that we are considering values up to the largest element in <code>nums</code> (bounded by <span class="math inline">\(n\)</span> in this analysis, as <span class="math inline">\(n \leq 10^5\)</span>), each check involves up to <span class="math inline">\(O(\log n)\)</span> operations, as each number may involve verifying a logarithmic number of squares.</p>
<p>Consequently, the time complexity for processing each element becomes <span class="math inline">\(O(\log n)\)</span>, resulting in an overall complexity of <span class="math inline">\(O(n) + O(n \cdot \log n) = O(n \log n)\)</span> for the entire algorithm.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The hash set can store <span class="math inline">\(n\)</span> elements in the worst case, where all elements are unique. This takes <span class="math inline">\(O(n)\)</span> space. No other significant extra space is used that scales with the input size.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-map">Approach 3: Map</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To track the length of a streak, we only need two key pieces of information: the last number in the current streak and the streak's length. When we find the square of the last number, we update both: the square becomes the new last number, and the streak length is incremented by one.</p>
<p>We can store this relationship using a map, where the key is the last number and the value is the streak length. For each number in the array, our first step is to check if it's a perfect square. This can be done by taking the square root of the number and squaring it again. If the result matches the original number, it's a perfect square. If not, it means the square root was decimal, and rounding down results in a smaller value when squared.</p>
<p>Once we find a perfect square, we check if its square root exists in the map. If it does, we can extend the existing sequence by updating the map with the current number as the new key and increasing the streak length by one.</p>
<p>Finally, we iterate over all the values in the map and return the largest one as our answer.</p>
<p>The algorithm is visualized in the slideshow below:</p>
<p>!?!../Documents/2501/slideshow.json:954,742!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a map <code>streakLengths</code> to store the length of a square streak for each number.</li>
<li>Sort the input array in ascending order.</li>
<li>Iterate through each <code>number</code> in the sorted array:
<ul>
<li>Calculate the integer square root of <code>number</code> and store it in <code>root</code>.</li>
<li>Check if <code>number</code> is a perfect square and its square root exists in <code>streakLengths</code>:
<ul>
<li>If true, extend the streak by setting the streak length for <code>number</code> to the streak length of its root plus one.</li>
<li>If false, start a new streak by setting the streak length for <code>number</code> to 1.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>longestStreak</code> to 0 to store the maximum streak length.</li>
<li>Iterate through all streak lengths in <code>streakLengths</code>:
<ul>
<li>Update <code>longestStreak</code> to the maximum of itself and the current streak length.</li>
</ul>
</li>
<li>Return -1 if <code>longestStreak</code> is 1 (no valid streak), otherwise return <code>longestStreak</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/5Ybhr6ux/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The algorithm begins by sorting <code>nums</code>, which takes <span class="math inline">\(O(n \cdot \log n)\)</span>. It then iterates through each number in the sorted array once, taking linear time. For each number, it performs constant time operations: calculating the square root, checking if it's a perfect square, and either extending or starting a new streak in the map.</p>
<p>Finally, the algorithm iterates through the values in the <code>streakLengths</code> map to find the maximum streak length. In the worst case, this could be another <span class="math inline">\(O(n)\)</span> operation if all numbers in the input array are unique.</p>
<p>Thus, the time complexity is dominated by the <span class="math inline">\(O(n \cdot \log n)\)</span> sorting step.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a map <code>streakLengths</code> to store the streak length for each number. In the worst case, if all numbers in the input array are unique, this map could contain all <span class="math inline">\(n\)</span> elements, leading to <span class="math inline">\(O(n)\)</span> space.</p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) can be <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span> depending on the language of implementation.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n + S) = O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-subsequence-with-limited-sum/description" target="_blank" rel="noopener noreferrer">Longest Subsequence With Limited Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code>, and an integer array <code>queries</code> of length <code>m</code>.</p>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>m</code><em> where </em><code>answer[i]</code><em> is the <strong>maximum</strong> size of a <strong>subsequence</strong> that you can take from </em><code>nums</code><em> such that the <strong>sum</strong> of its elements is less than or equal to </em><code>queries[i]</code>.</p>

<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,2,1], queries = [3,10,21]
<strong>Output:</strong> [2,3,4]
<strong>Explanation:</strong> We answer the queries as follows:
- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.
- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.
- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,4,5], queries = [1]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-uploaded-prefix/description" target="_blank" rel="noopener noreferrer">Longest Uploaded Prefix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a stream of <code>n</code> videos, each represented by a <strong>distinct</strong> number from <code>1</code> to <code>n</code> that you need to &quot;upload&quot; to a server. You need to implement a data structure that calculates the length of the <strong>longest uploaded prefix</strong> at various points in the upload process.</p>

<p>We consider <code>i</code> to be an uploaded prefix if all videos in the range <code>1</code> to <code>i</code> (<strong>inclusive</strong>) have been uploaded to the server. The longest uploaded prefix is the <strong>maximum </strong>value of <code>i</code> that satisfies this definition.<br />
<br />
Implement the <code>LUPrefix </code>class:</p>

<ul>
	<li><code>LUPrefix(int n)</code> Initializes the object for a stream of <code>n</code> videos.</li>
	<li><code>void upload(int video)</code> Uploads <code>video</code> to the server.</li>
	<li><code>int longest()</code> Returns the length of the <strong>longest uploaded prefix</strong> defined above.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LUPrefix&quot;, &quot;upload&quot;, &quot;longest&quot;, &quot;upload&quot;, &quot;longest&quot;, &quot;upload&quot;, &quot;longest&quot;]
[[4], [3], [], [1], [], [2], []]
<strong>Output</strong>
[null, null, 0, null, 1, null, 3]

<strong>Explanation</strong>
LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos.
server.upload(3);                    // Upload video 3.
server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.
                                     // So, we return 0.
server.upload(1);                    // Upload video 1.
server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1.
server.upload(2);                    // Upload video 2.
server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= video &lt;= n</code></li>
	<li>All values of <code>video</code> are <strong>distinct</strong>.</li>
	<li>At most <code>2 * 10<sup>5</sup></code> calls <strong>in total</strong> will be made to <code>upload</code> and <code>longest</code>.</li>
	<li>At least one call will be made to <code>longest</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/magnetic-force-between-two-balls/description" target="_blank" rel="noopener noreferrer">Magnetic Force Between Two Balls</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has <code>n</code> empty baskets, the <code>i<sup>th</sup></code> basket is at <code>position[i]</code>, Morty has <code>m</code> balls and needs to distribute the balls into the baskets such that the <strong>minimum magnetic force</strong> between any two balls is <strong>maximum</strong>.</p>

<p>Rick stated that magnetic force between two different balls at positions <code>x</code> and <code>y</code> is <code>|x - y|</code>.</p>

<p>Given the integer array <code>position</code> and the integer <code>m</code>. Return <em>the required force</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/11/q3v1.jpg" style="width: 562px; height: 195px;" />
<pre>
<strong>Input:</strong> position = [1,2,3,4,7], m = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> position = [5,4,3,2,1,1000000000], m = 2
<strong>Output:</strong> 999999999
<strong>Explanation:</strong> We can use baskets 1 and 1000000000.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == position.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= position[i] &lt;= 10<sup>9</sup></code></li>
	<li>All integers in <code>position</code> are <strong>distinct</strong>.</li>
	<li><code>2 &lt;= m &lt;= position.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem, our goal is to place <span class="math inline">\(m\)</span> balls in <span class="math inline">\(n\)</span> positions to maximize the minimum magnetic force between any two balls.</p>
<p>The magnetic force between two balls is calculated as <span class="math inline">\(| x - y |\)</span>, where <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are the positions of the two balls. Essentially, this means the magnetic force is the gap between the two respective balls.</p>
<p>What does it mean to maximize the minimum magnetic force between any two balls?<br />
Consider the following three configurations for placing 3 balls:</p>
<p><img src="../Figures/1552/Slide1.png" alt="config_1" /></p>
<p><img src="../Figures/1552/Slide2.png" alt="config_2_3" /></p>
<p>The minimum magnetic forces for each configuration are <span class="math inline">\(1\)</span>, <span class="math inline">\(3\)</span>, and <span class="math inline">\(2\)</span>, respectively. The optimal configuration, which maximizes the minimum magnetic force, is the second (ii) configuration.</p>
<p>We will start with a naive approach and progressively optimize it.</p>
<blockquote>
<p><strong>Note:</strong> This article assumes you understand how binary search in sorted arrays works. If not we recommend you read our <a href="https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/710/binary-search/">explore card (click here)</a> and try out some similar problems.</p>
</blockquote>
<hr />
<h3 id="approach-binary-search">Approach: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>If we place all the balls with at least a gap of <span class="math inline">\(x\)</span> between any two consecutive balls, <span class="math inline">\(x\)</span> will be the minimum magnetic force.</p>
<p>To find the maximum possible value of <span class="math inline">\(x\)</span>, we can start with the smallest possible value and attempt to place all the balls with at least this gap. If successful, we increase <span class="math inline">\(x\)</span> by <span class="math inline">\(1\)</span> and try again. This process continues until we reach a point where it is no longer possible to place all the balls with the current gap <span class="math inline">\(x\)</span>. At this stage, it won't be feasible to place the balls with any larger gap than <span class="math inline">\(x\)</span> (we recommend you try to reason out it before reading the explanation provided later).</p>
<p><img src="../Figures/1552/Slide3.png" alt="linear_search" /></p>
<p>This method can be further optimized. When we try a given gap <span class="math inline">\(x\)</span>, two outcomes are possible: (i) we can successfully place all the balls with at least a gap of <span class="math inline">\(x\)</span> between them, or (ii) we cannot place all the balls.</p>
<p>i) If we can place all the balls with at least a gap of <span class="math inline">\(x\)</span> between them, then trying smaller gaps is unnecessary, as it will always be possible to place the balls with a smaller gap.</p>
<p><img src="../Figures/1552/Slide4.png" alt="small_gap" /></p>
<p>ii) If we cannot place all the balls with at least a gap of <span class="math inline">\(x\)</span> between them, then trying gaps larger than <span class="math inline">\(x\)</span> is futile, as it would also be impossible to place the balls with a larger gap.</p>
<p><img src="../Figures/1552/Slide5.png" alt="large_gap" /></p>
<p>This suggests we can use a binary search-like algorithm, we can take the decision of discarding some part of the search space at each step.</p>
<p>Our search space for the gap values starts with <span class="math inline">\(low = 1\)</span>, since there will be at least a gap of <span class="math inline">\(1\)</span> between any two adjacent balls, and extends to <span class="math inline">\(high = \lceil \frac{maxPosition}{m - 1} \rceil\)</span>, the maximum gap between <span class="math inline">\(m\)</span> balls if all positions from <span class="math inline">\(1\)</span> to <span class="math inline">\(position[n - 1]\)</span> are available.</p>
<p>To determine if we can place the balls with a given gap <span class="math inline">\(x = mid\)</span> we will use another function <code>canPlaceBalls(x, positions, m)</code>, where <span class="math inline">\(mid = low + \frac{(high - low)}{2}\)</span>.<br />
If placing the balls is possible with this gap, we discard all gaps smaller than <span class="math inline">\(mid\)</span> from our search space. Conversely, if we cannot place the balls, we discard all gaps greater than <span class="math inline">\(mid\)</span>. We repeat this process in the reduced search space until we find the maximum gap value.</p>
<p>In <code>canPlaceBalls(x, positions, m)</code> function, we check if we can place <span class="math inline">\(m\)</span> balls in the given <span class="math inline">\(position\)</span> array with at least <span class="math inline">\(x\)</span> gap between them. We iterate through the <span class="math inline">\(position\)</span> array, checking if each position is suitable for placing a ball by maintaining a gap of at least <span class="math inline">\(x\)</span>from the previous ball's position. If the current position meets the requirement, we place the ball there and move to the next position. We stop once we either run out of positions or successfully place all <span class="math inline">\(m\)</span> balls.</p>
<p>Here's an example to illustrate ball placement:</p>
<p><img src="../Figures/1552/Slide13.png" alt="placing_example" /></p>
<p>It's important to note that for this approach to work, the <span class="math inline">\(position\)</span> array must be sorted. Thus, we will sort the array in the beginning.</p>
<br />
<p>To better understand how the binary search works in this context, refer to the following slideshow.</p>
<p>!?!../Documents/1552/slideshow.json:1360,960!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a helper function called <code>canPlaceBalls</code> which takes in the gap <code>x</code>, positions array <code>position</code>, and the number of balls <code>m</code> as parameters.
<ul>
<li>Initialize, <code>prevBallPos</code> to <code>position[0]</code>, <code>ballsPlaced</code> count to <code>1</code>.</li>
<li>Iterate on all positions from index <code>i = 0</code> till <code>position.size() - 1</code> or if we placed all <code>m</code> balls:
<ul>
<li>Place the ball at the current position <code>position[i]</code> if it maintains a gap of <code>x</code> with the previous ball.</li>
<li>Update <code>prevBallPos</code> to <code>position[i]</code>.</li>
<li>Increment <code>ballsPlaced</code> count by <code>1</code>.</li>
</ul>
</li>
<li>Return if <code>ballsPlaced</code> is equal to <code>m</code>.</li>
</ul>
</li>
<li>Initialize <code>answer</code> to <code>0</code>, denoting maximum minimum magnetic force, and <code>n</code> to <code>position</code> array's size.</li>
<li>Sort the <code>position</code> array.</li>
<li>Initilize the initial search space for the gap:
<ul>
<li><code>low</code> to <code>1</code>.</li>
<li><code>high</code> to <code>ceil(position[n - 1] / (m - 1))</code>.</li>
</ul>
</li>
<li>Start a while loop until the search space is exhausted, i.e. till <code>low &lt;= high</code>, at each iteration:
<ul>
<li>Calculate the <code>mid = low + (high - low) / 2</code>.</li>
<li>If we can place all the balls at a gap of <code>mid</code>, then update <code>answer = mid</code>, and discard the left half search space, <code>left = mid + 1</code>.</li>
<li>Otherwise, discard the right half search space, <code>right = mid - 1</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/UCAGenJ9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of elements, and <span class="math inline">\(k\)</span> is the maximum position value in the <code>position</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log \frac{n * k}{m})\)</span></p>
<p>Sorting the <code>position</code> array takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Checking if we can place the balls in the position array takes <span class="math inline">\(O(n)\)</span> time. This operation is repeated until we reduce our search space to one element. The search space is halved in each step until only one element remains, resulting in <span class="math inline">\(O(\log \frac{k}{m})\)</span> steps.<br />
<span class="math inline">\(a \rarr a/2 \rarr a/4 \rarr ... \rarr 1 \space (\text{b steps})\)</span><br />
<span class="math inline">\(a / 2^{(b - 1)} = 1 \implies b \approx \log a\)</span></p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n \log \frac{n * k}{m})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O( \log n )\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>Apart from sorting, we do not use any additional space.</p>
<p>The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-array-empty/description" target="_blank" rel="noopener noreferrer">Make Array Empty</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> containing <strong>distinct</strong> numbers, and you can perform the following operations <strong>until the array is empty</strong>:</p>

<ul>
	<li>If the first element has the <strong>smallest</strong> value, remove it</li>
	<li>Otherwise, put the first element at the <strong>end</strong> of the array.</li>
</ul>

<p>Return <em>an integer denoting the number of operations it takes to make </em><code>nums</code><em> empty.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,-1]
<strong>Output:</strong> 5
</pre>

<table style="border: 2px solid black; border-collapse: collapse;">
	<thead>
		<tr>
			<th style="border: 2px solid black; padding: 5px;">Operation</th>
			<th style="border: 2px solid black; padding: 5px;">Array</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">1</td>
			<td style="border: 2px solid black; padding: 5px;">[4, -1, 3]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">2</td>
			<td style="border: 2px solid black; padding: 5px;">[-1, 3, 4]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">3</td>
			<td style="border: 2px solid black; padding: 5px;">[3, 4]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">4</td>
			<td style="border: 2px solid black; padding: 5px;">[4]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">5</td>
			<td style="border: 2px solid black; padding: 5px;">[]</td>
		</tr>
	</tbody>
</table>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,4,3]
<strong>Output:</strong> 5
</pre>

<table style="border: 2px solid black; border-collapse: collapse;">
	<thead>
		<tr>
			<th style="border: 2px solid black; padding: 5px;">Operation</th>
			<th style="border: 2px solid black; padding: 5px;">Array</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">1</td>
			<td style="border: 2px solid black; padding: 5px;">[2, 4, 3]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">2</td>
			<td style="border: 2px solid black; padding: 5px;">[4, 3]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">3</td>
			<td style="border: 2px solid black; padding: 5px;">[3, 4]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">4</td>
			<td style="border: 2px solid black; padding: 5px;">[4]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">5</td>
			<td style="border: 2px solid black; padding: 5px;">[]</td>
		</tr>
	</tbody>
</table>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 3
</pre>

<table style="border: 2px solid black; border-collapse: collapse;">
	<thead>
		<tr>
			<th style="border: 2px solid black; padding: 5px;">Operation</th>
			<th style="border: 2px solid black; padding: 5px;">Array</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">1</td>
			<td style="border: 2px solid black; padding: 5px;">[2, 3]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">2</td>
			<td style="border: 2px solid black; padding: 5px;">[3]</td>
		</tr>
		<tr>
			<td style="border: 2px solid black; padding: 5px;">3</td>
			<td style="border: 2px solid black; padding: 5px;">[]</td>
		</tr>
	</tbody>
</table>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9&nbsp;</sup>&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li>All values in <code>nums</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-array-strictly-increasing/description" target="_blank" rel="noopener noreferrer">Make Array Strictly Increasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays&nbsp;<code>arr1</code> and <code>arr2</code>, return the minimum number of operations (possibly zero) needed&nbsp;to make <code>arr1</code> strictly increasing.</p>

<p>In one operation, you can choose two indices&nbsp;<code>0 &lt;=&nbsp;i &lt; arr1.length</code>&nbsp;and&nbsp;<code>0 &lt;= j &lt; arr2.length</code>&nbsp;and do the assignment&nbsp;<code>arr1[i] = arr2[j]</code>.</p>

<p>If there is no way to make&nbsp;<code>arr1</code>&nbsp;strictly increasing,&nbsp;return&nbsp;<code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Replace <code>5</code> with <code>2</code>, then <code>arr1 = [1, 2, 3, 6, 7]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,5,3,6,7], arr2 = [4,3,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Replace <code>5</code> with <code>3</code> and then replace <code>3</code> with <code>4</code>. <code>arr1 = [1, 3, 4, 6, 7]</code>.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> You can&#39;t make <code>arr1</code> strictly increasing.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>
	<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>
</ul>

<p>&nbsp;</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We will iterate over <code>arr1</code> and at each index <code>i</code>, we aim to make the prefix <code>arr1[0 ~ i]</code> sorted. In case <code>arr1[i]</code> requires replacement with a value from <code>arr2</code>, the smallest element in <code>arr2</code> that will maintain increasing order is always preferred. Hence, by sorting <code>arr2</code>, we can efficiently identify the smallest element that meets this criterion using binary search, which takes logarithmic time. If <code>arr2</code> is not sorted, we would have to search the entire array to find the smallest element that meets this requirement, leading to a linear time complexity for each operation.</p>
<p><img src="../Figures/1187/1.png" alt="img" /></p>
<p>Therefore, all subsequent solutions are based on the sorted <code>arr2</code>.</p>
<hr />
<h3 id="approach-1-top-down-dynamic-programming">Approach 1: Top-down Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with dynamic programming, please refer to our explore cards <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>As we update <code>arr1</code> from left to right, each element <code>arr1[i]</code> can be subjected to several potential operations:</p>
<ul>
<li>If <code>arr1[i]</code> is less than or equal to <code>arr1[i - 1]</code>, we <strong>must</strong> replace <code>arr1[i]</code> with the smallest value in <code>arr2</code>that is greater than <code>arr1[i - 1]</code>,  which we can identify using binary search. Otherwise, we can't make <code>arr1</code> sorted.</li>
</ul>
<p><img src="../Figures/1187/2.png" alt="img" /></p>
<ul>
<li>
<p>If <code>arr1[i]</code> is greater than <code>arr1[i - 1]</code>, we have two possible options:</p>
<ul>
<li>Leave it unchanged and continue with the next index. No changes need to be made as <code>arr1[i]</code> is already greater than <code>arr1[i - 1]</code>.</li>
<li>Replace it with a smaller value (as doing so may make it easier to ensure that subsequent numbers are greater than <code>arr1[i]</code>). We will use binary search to locate the smallest value greater than <code>arr1[i - 1]</code> in <code>arr2</code>.</li>
</ul>
</li>
</ul>
<p><img src="../Figures/1187/3.png" alt="img" /></p>
<p>In summary:</p>
<p><img src="../Figures/1187/4.png" alt="img" /></p>
<br>
<p>We utilize a recursive approach named <code>dfs(i)</code> to determine the minimum number of operations needed to make the subarray <code>arr1[i:]</code> sorted. Given that we modify <code>arr1[i]</code> based on the value of <code>arr[i - 1]</code>, <code>dfs</code> requires an additional parameter called <code>prev</code>, which represents the value of <code>arr1[i - 1]</code>. Hence, the complete function is defined as <code>dfs(i, prev)</code>.</p>
<p>Since there is no preceding element for the first element of <code>arr1</code>, we can assign an imaginary value of <code>-1</code> before <code>arr1[0]</code>. This allows <code>dfs</code> to operate on the first element with <code>prev = -1</code>.</p>
<p>Consider the following figure, which illustrates the recursive steps of <code>dfs(i = 0, prev = -1)</code>:</p>
<p><img src="../Figures/1187/5.png" alt="img" /></p>
<p>Starting from the first element of <code>arr1</code>, we compare <code>arr1[0]</code> to <code>prev = -1</code>. Since <code>arr1[0]</code> is greater than <code>prev</code>, we do not need to make any changes and call <code>dfs</code> recursively on the next index by passing the current value <code>1</code> as <code>prev</code>, which is <code>dfs(0, -1)</code> = <code>dfs(1, 1)</code>.</p>
<p><img src="../Figures/1187/6.png" alt="img" /></p>
<p>Moving on to the next element <code>arr1[1]</code>, we compare it to <code>prev = 1</code> (which is the value of the previous element <code>arr1[0]</code>).</p>
<p><img src="../Figures/1187/7.png" alt="img" /></p>
<p>As <code>arr1[1] = 5</code> is larger than <code>prev = 1</code>, there are two options in <code>dfs(1, 1)</code>:</p>
<ul>
<li>Leave <code>arr1[1]</code> unchanged and continue with the next index, requiring no operation: <code>dfs(1, 1) = dfs(2, 5)</code>.</li>
<li>Find the smallest value in <code>arr2</code> that is greater than <code>prev</code> by binary search (which is <code>2</code>), since <code>2</code> is smaller than <code>arr[1]</code>, we can replace <code>arr1[1]</code> with <code>2</code>, and recursively call <code>dfs</code> on the next index, which is <code>dfs(1, 1) = 1 + dfs(2, 2)</code>.</li>
</ul>
<p><img src="../Figures/1187/8.png" alt="img" /></p>
<p>Therefore, <code>dfs(1, 1)</code> can be obtained by taking the minimum value between <code>dfs(1, 1) = min(dfs(2, 5), 1 + dfs(2, 2))</code>.</p>
<br>
<p>If <code>arr1[i]</code> cannot be replaced with any valid value in <code>arr2</code> when it needs to be changed, <code>dfs</code> returns a large number such as <code>inf</code> to indicate that it is impossible to make <code>arr1</code> sorted.</p>
<p>We use memoization to store the minimum number of operations to reach each state <code>(i, prev)</code>, which improves the efficiency of the algorithm. This helps us avoid re-solving the same subproblems multiple times and significantly reduces the time complexity.</p>
<p>Finally, we call <code>dfs(0, -1)</code> and examine the value it returns. If the value is reasonable and smaller than the large one we assigned to impossible moves, we return the result of <code>dfs(0, -1)</code>. Otherwise, we return <code>-1</code>.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Sort <code>arr2</code>.</p>
</li>
<li>
<p>Initialize a hash map <code>dp</code> as memory.</p>
</li>
<li>
<p>Define a function <code>dfs(i, prev)</code> as the minimum number of operations to make <code>arr[i:]</code> sorted when <code>arr[i - 1] = prev</code>.</p>
<ul>
<li>
<p>Check if <code>(i, prev)</code> exists in <code>dp</code>, and if so, return <code>dp[(i, prev)]</code></p>
</li>
<li>
<p>Initialize <code>cost</code> to <code>float('inf')</code></p>
</li>
<li>
<p>If <code>arr1[i] &gt; prev</code>, set <code>cost</code> to <code>dfs(i+1, arr1[i])</code></p>
</li>
<li>
<p>Find the index <code>idx</code> of the smallest value in <code>arr2</code> that is greater than <code>prev</code> using binary search. If <code>idx &lt; len(arr2)</code>, set <code>cost</code> to <code>min(cost, 1 + dfs(i+1, arr2[idx]))</code></p>
</li>
<li>
<p>Update <code>dp[(i, prev)]</code> as <code>cost</code></p>
</li>
<li>
<p>Return <code>cost</code></p>
</li>
</ul>
</li>
<li>
<p>Return the value of <code>dfs(0, -1)</code> if it is not equal to <code>float('inf')</code>, otherwise, return <code>-1</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6LSQDWuq/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m, n\)</span> be the length of <code>arr1</code> and <code>arr2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot\log n)\)</span></p>
<ul>
<li>Sorting <code>arr2</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>To improve the efficiency of the algorithm, we use memoization and store the minimum number of operations to reach each state <code>(i, prev)</code> in a hash map <code>dp</code>. There are <span class="math inline">\(m\)</span> indices and at most <span class="math inline">\(n + 1\)</span> possible <code>prev</code> as we might replace <code>arr[i]</code> with any value in <code>arr2</code>. Each state is computed with a binary search over <code>arr2</code>, which takes <span class="math inline">\(O(\log n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>The maximum number of distinct states in <code>dp</code> is <span class="math inline">\(m \cdot n\)</span>.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-bottom-up-dynamic-programming">Approach 2: Bottom-up Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of using recursion, we can also solve this problem iteratively. We start by initializing a hash map <code>dp</code> that stores each state we can reach for index <code>i</code>. Each state is represented as <code>{prev: count}</code>, where <code>prev</code> is the previous value and <code>count</code> is the minimum number of operations needed to reach this state.</p>
<p>Similar to the recursive solution, we set an imaginary value <code>-1</code> before <code>arr1[0]</code> and add an initial key-value pair of <code>{-1: 0}</code> to <code>dp</code>, indicating that reaching <code>prev = -1</code> takes no operations.</p>
<p><img src="../Figures/1187/9.png" alt="img" /></p>
<p>We then iterate over <code>arr1</code> and for each index <code>i</code>, we initialize an empty dictionary <code>new_dp</code> to store the states we can reach for index <code>i</code>.</p>
<p>Loop through all the states in <code>dp</code> and for each state <code>{prev: count}</code>:</p>
<ul>
<li>
<p>If <code>arr1[i]</code> is less than or equal to <code>prev</code>, we <strong>must</strong> replace <code>arr1[i]</code> with the smallest value <code>arr2[index]</code> in <code>arr2</code> that is greater than <code>prev</code>, which we can identify using binary search.</p>
<ul>
<li>Create a new state <code>{arr2[index]: count + 1}</code>.</li>
<li>Otherwise, we can't update this state at <code>i</code>.</li>
</ul>
</li>
<li>
<p>If <code>arr1[i]</code> is greater than <code>prev</code>, there are two possible options:</p>
<ul>
<li>Leave it unchanged by creating state <code>{arr1[i]: count}</code> in <code>new_dp</code>.</li>
<li>Replace <code>arr[i]</code> with a smaller value in <code>arr2</code> that is larger than <code>prev</code>. Once again, we will use binary search to locate the smallest value <code>arr2[index]</code> that is greater than <code>arr1[i - 1]</code> in <code>arr2</code>, create a state <code>{arr2[index]: count + 1}</code>.</li>
</ul>
</li>
</ul>
<p><img src="../Figures/1187/13.png" alt="img" /></p>
<p>After looping through all the keys in <code>dp</code>, we set <code>dp</code> to <code>new_dp</code> so it represents all reachable states at index <code>i</code>.</p>
<br>
<p>Please refer to the following example:</p>
<p>For <code>i = 0</code>, <code>dp</code> has one state: <code>{-1: 0}</code>, since <code>arr[0] &gt; prev</code>, we can leave <code>arr[0]</code> unchanged, thus we can reach a new state of <code>{1: 0}</code>, store it in <code>new_dp</code>.</p>
<p><img src="../Figures/1187/10.png" alt="img" /></p>
<p>Continue with <code>i = 1</code> by setting <code>dp</code> as <code>new_dp</code> and resetting <code>new_dp</code>. <code>dp</code> has one state <code>{1: 0}</code>, since <code>arr[1] &gt; prev</code>, we can either:</p>
<ul>
<li>Leave <code>arr[1]</code> unchanged and reach a new state <code>{5: 0}</code>.</li>
<li>Replace it with <code>arr2[1] = 2</code> with 1 operation, and reach another new state <code>{2: 1}</code>.</li>
</ul>
<p>Therefore, we have created two states <code>new_dp = {2: 1, 5: 0}</code> for index <code>1</code>.</p>
<p><img src="../Figures/1187/11.png" alt="img" /></p>
<p>During each iteration, <code>new_dp</code> stores the <strong>minimum</strong> number of operations needed to reach each state from the previous index. We can achieve this by initializing the value of each key in <code>new_dp</code> to a large number like <code>inf</code> and updating it as the minimum value we encounter.</p>
<p>After iterating over <code>arr1</code>, we return the smallest value in <code>dp</code> as the minimum number of operations required to reach the last index and make the entire <code>arr1</code> sorted. If the value is <code>inf</code>, it indicates that there is no way to reach any states at the last index, and we return <code>-1</code>.</p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Sort <code>arr2</code>.</p>
</li>
<li>
<p>Create a hash map <code>dp</code> with an initial key-value pair of <code>{-1: 0}</code>.</p>
</li>
<li>
<p>Iterate over <code>arr1</code>, for each index <code>i</code>, create a new hash map <code>new_dp</code> with default value of <code>float('inf')</code> and do the following:</p>
</li>
<li>
<p>Iterate over each key <code>prev</code> in <code>dp</code>:</p>
<ul>
<li>If <code>arr1[i]</code> is greater than <code>prev</code>, update <code>new_dp[arr1[i]]</code> as <code>min(new_dp[arr1[i]], dp[prev])</code>.</li>
<li>Otherwise, find the index <code>idx</code> of the smallest value in <code>arr2</code> that is greater than <code>prev</code>. If such a value exists, update <code>new_dp[arr2[idx]]</code> as <code>min(new_dp[arr2[idx]], 1 + dp[prev])</code>.</li>
</ul>
</li>
</ol>
<p>Let <code>dp = new_dp</code>, and repeat from step 3.</p>
<ol start="5">
<li>When the iteration is complete, return the minimum value in <code>dp</code> if it is less than <code>float('inf')</code>, otherwise return <code>-1</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/2FUmTJ4p/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m, n\)</span> be the length of <code>arr1</code> and <code>arr2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot\log n)\)</span></p>
<ul>
<li>Sorting <code>arr2</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>We update <code>dp</code> by <span class="math inline">\(m\)</span> rounds. In each round at index <code>i</code>, there are at most <span class="math inline">\(n + 1\)</span> possible <code>prev</code> as we might replace <code>arr[i]</code> with any of the <span class="math inline">\(n\)</span> values in <code>arr2</code> or leave it unchanged. Each state is computed with a binary search over all start times, which takes <span class="math inline">\(O(\log n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We keep track of all states <code>(i, prev)</code> of two latest indices in <code>dp</code> and <code>new_dp</code>, respectively. At each index, the number of possible distinct states is at most <span class="math inline">\(n + 1\)</span>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-consecutive-ones-iii/description" target="_blank" rel="noopener noreferrer">Max Consecutive Ones III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary array <code>nums</code> and an integer <code>k</code>, return <em>the maximum number of consecutive </em><code>1</code><em>&#39;s in the array if you can flip at most</em> <code>k</code> <code>0</code>&#39;s.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
<strong>Output:</strong> 6
<strong>Explanation:</strong> [1,1,1,0,0,<u><strong>1</strong>,1,1,1,1,<strong>1</strong></u>]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
<strong>Output:</strong> 10
<strong>Explanation:</strong> [0,0,<u>1,1,<strong>1</strong>,<strong>1</strong>,1,1,1,<strong>1</strong>,1,1</u>,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>0 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-active-section-with-trade-ii/description" target="_blank" rel="noopener noreferrer">Maximize Active Section with Trade II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary string <code>s</code> of length <code>n</code>, where:</p>

<ul>
	<li><code>&#39;1&#39;</code> represents an <strong>active</strong> section.</li>
	<li><code>&#39;0&#39;</code> represents an <strong>inactive</strong> section.</li>
</ul>

<p>You can perform <strong>at most one trade</strong> to maximize the number of active sections in <code>s</code>. In a trade, you:</p>

<ul>
	<li>Convert a contiguous block of <code>&#39;1&#39;</code>s that is surrounded by <code>&#39;0&#39;</code>s to all <code>&#39;0&#39;</code>s.</li>
	<li>Afterward, convert a contiguous block of <code>&#39;0&#39;</code>s that is surrounded by <code>&#39;1&#39;</code>s to all <code>&#39;1&#39;</code>s.</li>
</ul>

<p>Additionally, you are given a <strong>2D array</strong> <code>queries</code>, where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> represents a <span data-keyword="substring-nonempty">substring</span> <code>s[l<sub>i</sub>...r<sub>i</sub>]</code>.</p>

<p>For each query, determine the <strong>maximum</strong> possible number of active sections in <code>s</code> after making the optimal trade on the substring <code>s[l<sub>i</sub>...r<sub>i</sub>]</code>.</p>

<p>Return an array <code>answer</code>, where <code>answer[i]</code> is the result for <code>queries[i]</code>.</p>

<p><strong>Note</strong></p>

<ul>
	<li>For each query, treat <code>s[l<sub>i</sub>...r<sub>i</sub>]</code> as if it is <strong>augmented</strong> with a <code>&#39;1&#39;</code> at both ends, forming <code>t = &#39;1&#39; + s[l<sub>i</sub>...r<sub>i</sub>] + &#39;1&#39;</code>. The augmented <code>&#39;1&#39;</code>s <strong>do not</strong> contribute to the final count.</li>
	<li>The queries are independent of each other.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;01&quot;, queries = [[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>

<p><strong>Explanation:</strong></p>

<p>Because there is no block of <code>&#39;1&#39;</code>s surrounded by <code>&#39;0&#39;</code>s, no valid trade is possible. The maximum number of active sections is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;0100&quot;, queries = [[0,3],[0,2],[1,3],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,3,1,1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>
	<p>Query <code>[0, 3]</code> &rarr; Substring <code>&quot;0100&quot;</code> &rarr; Augmented to <code>&quot;101001&quot;</code><br />
	Choose <code>&quot;0100&quot;</code>, convert <code>&quot;0100&quot;</code> &rarr; <code>&quot;0000&quot;</code> &rarr; <code>&quot;1111&quot;</code>.<br />
	The final string without augmentation is <code>&quot;1111&quot;</code>. The maximum number of active sections is 4.</p>
	</li>
	<li>
	<p>Query <code>[0, 2]</code> &rarr; Substring <code>&quot;010&quot;</code> &rarr; Augmented to <code>&quot;10101&quot;</code><br />
	Choose <code>&quot;010&quot;</code>, convert <code>&quot;010&quot;</code> &rarr; <code>&quot;000&quot;</code> &rarr; <code>&quot;111&quot;</code>.<br />
	The final string without augmentation is <code>&quot;1110&quot;</code>. The maximum number of active sections is 3.</p>
	</li>
	<li>
	<p>Query <code>[1, 3]</code> &rarr; Substring <code>&quot;100&quot;</code> &rarr; Augmented to <code>&quot;11001&quot;</code><br />
	Because there is no block of <code>&#39;1&#39;</code>s surrounded by <code>&#39;0&#39;</code>s, no valid trade is possible. The maximum number of active sections is 1.</p>
	</li>
	<li>
	<p>Query <code>[2, 3]</code> &rarr; Substring <code>&quot;00&quot;</code> &rarr; Augmented to <code>&quot;1001&quot;</code><br />
	Because there is no block of <code>&#39;1&#39;</code>s surrounded by <code>&#39;0&#39;</code>s, no valid trade is possible. The maximum number of active sections is 1.</p>
	</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;1000100&quot;, queries = [[1,5],[0,6],[0,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[6,7,2]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li data-end="383" data-start="217">
	<p data-end="383" data-start="219">Query <code>[1, 5]</code> &rarr; Substring <code data-end="255" data-start="246">&quot;00010&quot;</code> &rarr; Augmented to <code data-end="282" data-start="271">&quot;1000101&quot;</code><br data-end="285" data-start="282" />
	Choose <code data-end="303" data-start="294">&quot;00010&quot;</code>, convert <code data-end="322" data-start="313">&quot;00010&quot;</code> &rarr; <code data-end="322" data-start="313">&quot;00000&quot;</code> &rarr; <code data-end="334" data-start="325">&quot;11111&quot;</code>.<br />
	The final string without augmentation is <code data-end="404" data-start="396">&quot;1111110&quot;</code>. The maximum number of active sections is 6.</p>
	</li>
	<li data-end="561" data-start="385">
	<p data-end="561" data-start="387">Query <code>[0, 6]</code> &rarr; Substring <code data-end="425" data-start="414">&quot;1000100&quot;</code> &rarr; Augmented to <code data-end="454" data-start="441">&quot;110001001&quot;</code><br data-end="457" data-start="454" />
	Choose <code data-end="477" data-start="466">&quot;000100&quot;</code>, convert <code data-end="498" data-start="487">&quot;000100&quot;</code> &rarr; <code data-end="498" data-start="487">&quot;000000&quot;</code> &rarr; <code data-end="512" data-start="501">&quot;111111&quot;</code>.<br />
	The final string without augmentation is <code data-end="404" data-start="396">&quot;1111111&quot;</code>. The maximum number of active sections is 7.</p>
	</li>
	<li data-end="741" data-start="563">
	<p data-end="741" data-start="565">Query <code>[0, 4]</code> &rarr; Substring <code data-end="601" data-start="592">&quot;10001&quot;</code> &rarr; Augmented to <code data-end="627" data-start="617">&quot;1100011&quot;</code><br data-end="630" data-start="627" />
	Because there is no block of <code>&#39;1&#39;</code>s surrounded by <code>&#39;0&#39;</code>s, no valid trade is possible. The maximum number of active sections is 2.</p>
	</li>
</ul>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;01010&quot;, queries = [[0,3],[1,4],[1,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,4,2]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>
	<p>Query <code>[0, 3]</code> &rarr; Substring <code>&quot;0101&quot;</code> &rarr; Augmented to <code>&quot;101011&quot;</code><br />
	Choose <code>&quot;010&quot;</code>, convert <code>&quot;010&quot;</code> &rarr; <code>&quot;000&quot;</code> &rarr; <code>&quot;111&quot;</code>.<br />
	The final string without augmentation is <code>&quot;11110&quot;</code>. The maximum number of active sections is 4.</p>
	</li>
	<li>
	<p>Query <code>[1, 4]</code> &rarr; Substring <code>&quot;1010&quot;</code> &rarr; Augmented to <code>&quot;110101&quot;</code><br />
	Choose <code>&quot;010&quot;</code>, convert <code>&quot;010&quot;</code> &rarr; <code>&quot;000&quot;</code> &rarr; <code>&quot;111&quot;</code>.<br />
	The final string without augmentation is <code>&quot;01111&quot;</code>. The maximum number of active sections is 4.</p>
	</li>
	<li>
	<p>Query <code>[1, 3]</code> &rarr; Substring <code>&quot;101&quot;</code> &rarr; Augmented to <code>&quot;11011&quot;</code><br />
	Because there is no block of <code>&#39;1&#39;</code>s surrounded by <code>&#39;0&#39;</code>s, no valid trade is possible. The maximum number of active sections is 2.</p>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-score-of-numbers-in-ranges/description" target="_blank" rel="noopener noreferrer">Maximize Score of Numbers in Ranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>start</code> and an integer <code>d</code>, representing <code>n</code> intervals <code>[start[i], start[i] + d]</code>.</p>

<p>You are asked to choose <code>n</code> integers where the <code>i<sup>th</sup></code> integer must belong to the <code>i<sup>th</sup></code> interval. The <strong>score</strong> of the chosen integers is defined as the <strong>minimum</strong> absolute difference between any two integers that have been chosen.</p>

<p>Return the <strong>maximum</strong> <em>possible score</em> of the chosen integers.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [6,0,3], d = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible score can be obtained by choosing integers: 8, 0, and 4. The score of these chosen integers is <code>min(|8 - 0|, |8 - 4|, |0 - 4|)</code> which equals 4.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [2,6,13,13], d = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible score can be obtained by choosing integers: 2, 7, 13, and 18. The score of these chosen integers is <code>min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)</code> which equals 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= start.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= start[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= d &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-spanning-tree-stability-with-upgrades/description" target="_blank" rel="noopener noreferrer">Maximize Spanning Tree Stability with Upgrades</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, representing <code>n</code> nodes numbered from 0 to <code>n - 1</code> and a list of <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, s<sub>i</sub>, must<sub>i</sub>]</code>:</p>

<ul>
	<li><code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> indicates an undirected edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</li>
	<li><code>s<sub>i</sub></code> is the strength of the edge.</li>
	<li><code>must<sub>i</sub></code> is an integer (0 or 1). If <code>must<sub>i</sub> == 1</code>, the edge <strong>must</strong> be included in the<strong> </strong><strong>spanning tree</strong>. These edges <strong>cannot</strong> be <strong>upgraded</strong>.</li>
</ul>

<p>You are also given an integer <code>k</code>, the <strong>maximum</strong> number of upgrades you can perform. Each upgrade <strong>doubles</strong> the strength of an edge, and each eligible edge (with <code>must<sub>i</sub> == 0</code>) can be upgraded <strong>at most</strong> once.</p>

<p>The <strong>stability</strong> of a spanning tree is defined as the <strong>minimum</strong> strength score among all edges included in it.</p>

<p>Return the <strong>maximum</strong> possible stability of any valid spanning tree. If it is impossible to connect all nodes, return <code>-1</code>.</p>

<p><strong>Note</strong>: A <strong>spanning tree</strong> of a graph with <code>n</code> nodes is a subset of the edges that connects all nodes together (i.e. the graph is <strong>connected</strong>) <em>without</em> forming any cycles, and uses <strong>exactly</strong> <code>n - 1</code> edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2,1],[1,2,3,0]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Edge <code>[0,1]</code> with strength = 2 must be included in the spanning tree.</li>
	<li>Edge <code>[1,2]</code> is optional and can be upgraded from 3 to 6 using one upgrade.</li>
	<li>The resulting spanning tree includes these two edges with strengths 2 and 6.</li>
	<li>The minimum strength in the spanning tree is 2, which is the maximum possible stability.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,4,0],[1,2,3,0],[0,2,1,0]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Since all edges are optional and up to <code>k = 2</code> upgrades are allowed.</li>
	<li>Upgrade edges <code>[0,1]</code> from 4 to 8 and <code>[1,2]</code> from 3 to 6.</li>
	<li>The resulting spanning tree includes these two edges with strengths 8 and 6.</li>
	<li>The minimum strength in the tree is 6, which is the maximum possible stability.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,1,1],[1,2,1,1],[2,0,1,1]], k = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>All edges are mandatory and form a cycle, which violates the spanning tree property of acyclicity. Thus, the answer is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, s<sub>i</sub>, must<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= s<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>must<sub>i</sub></code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>0 &lt;= k &lt;= n</code></li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-confusion-of-an-exam/description" target="_blank" rel="noopener noreferrer">Maximize the Confusion of an Exam</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A teacher is writing a test with <code>n</code> true/false questions, with <code>&#39;T&#39;</code> denoting true and <code>&#39;F&#39;</code> denoting false. He wants to confuse the students by <strong>maximizing</strong> the number of <strong>consecutive</strong> questions with the <strong>same</strong> answer (multiple trues or multiple falses in a row).</p>

<p>You are given a string <code>answerKey</code>, where <code>answerKey[i]</code> is the original answer to the <code>i<sup>th</sup></code> question. In addition, you are given an integer <code>k</code>, the maximum number of times you may perform the following operation:</p>

<ul>
	<li>Change the answer key for any question to <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code> (i.e., set <code>answerKey[i]</code> to <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code>).</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of consecutive</em> <code>&#39;T&#39;</code>s or <code>&#39;F&#39;</code>s <em>in the answer key after performing the operation at most</em> <code>k</code> <em>times</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TTFF&quot;, k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can replace both the &#39;F&#39;s with &#39;T&#39;s to make answerKey = &quot;<u>TTTT</u>&quot;.
There are four consecutive &#39;T&#39;s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TFFT&quot;, k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can replace the first &#39;T&#39; with an &#39;F&#39; to make answerKey = &quot;<u>FFF</u>T&quot;.
Alternatively, we can replace the second &#39;T&#39; with an &#39;F&#39; to make answerKey = &quot;T<u>FFF</u>&quot;.
In both cases, there are three consecutive &#39;F&#39;s.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TTFTTFTT&quot;, k = 1
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can replace the first &#39;F&#39; to make answerKey = &quot;<u>TTTTT</u>FTT&quot;
Alternatively, we can replace the second &#39;F&#39; to make answerKey = &quot;TTF<u>TTTTT</u>&quot;. 
In both cases, there are five consecutive &#39;T&#39;s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == answerKey.length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>answerKey[i]</code> is either <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-distance-between-points-on-a-square/description" target="_blank" rel="noopener noreferrer">Maximize the Distance Between Points on a Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code><font face="monospace">side</font></code>, representing the edge length of a square with corners at <code>(0, 0)</code>, <code>(0, side)</code>, <code>(side, 0)</code>, and <code>(side, side)</code> on a Cartesian plane.</p>

<p>You are also given a <strong>positive</strong> integer <code>k</code> and a 2D integer array <code>points</code>, where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the coordinate of a point lying on the <strong>boundary</strong> of the square.</p>

<p>You need to select <code>k</code> elements among <code>points</code> such that the <strong>minimum</strong> Manhattan distance between any two points is <strong>maximized</strong>.</p>

<p>Return the <strong>maximum</strong> possible <strong>minimum</strong> Manhattan distance between the selected <code>k</code> points.</p>

<p>The Manhattan Distance between two cells <code>(x<sub>i</sub>, y<sub>i</sub>)</code> and <code>(x<sub>j</sub>, y<sub>j</sub>)</code> is <code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">side = 2, points = [[0,2],[2,0],[2,2],[0,0]], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/28/4080_example0_revised.png" style="width: 200px; height: 200px;" /></p>

<p>Select all four points.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">side = 2, points = [[0,0],[1,2],[2,0],[2,2],[2,1]], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/28/4080_example1_revised.png" style="width: 211px; height: 200px;" /></p>

<p>Select the points <code>(0, 0)</code>, <code>(2, 0)</code>, <code>(2, 2)</code>, and <code>(2, 1)</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">side = 2, points = [[0,0],[0,1],[0,2],[1,2],[2,0],[2,2],[2,1]], k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/28/4080_example2_revised.png" style="width: 200px; height: 200px;" /></p>

<p>Select the points <code>(0, 0)</code>, <code>(0, 1)</code>, <code>(0, 2)</code>, <code>(1, 2)</code>, and <code>(2, 2)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= side &lt;= 10<sup>9</sup></code></li>
	<li><code>4 &lt;= points.length &lt;= min(4 * side, 15 * 10<sup>3</sup>)</code></li>
	<li><code>points[i] == [xi, yi]</code></li>
	<li>The input is generated such that:
	<ul>
		<li><code>points[i]</code> lies on the boundary of the square.</li>
		<li>All <code>points[i]</code> are <strong>unique</strong>.</li>
	</ul>
	</li>
	<li><code>4 &lt;= k &lt;= min(25, points.length)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximize-the-minimum-difference-between-k-elements/1" target="_blank" rel="noopener noreferrer">Maximize the minimum difference between k elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong> of integers and an integer <strong>k</strong>, select k elements from the array such that the <strong>minimum</strong> <strong>absolute difference</strong> between any two of the selected elements is <strong>maximized</strong>. Return this <strong>maximum</strong> possible <strong>minimum</strong> difference.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [2, 6, 2, 5], k = 3</span><br /><span style="font-size: 14pt;"><strong>Output: </strong>1</span><br /><span style="font-size: 14pt;"><strong>Explanation: </strong>3 elements out of 4 elements are to be selected with a minimum difference as large as possible. Selecting 2, 2, 5 will result in minimum difference as 0. Selecting 2, 5, 6 will result in minimum difference as 6 - 5 = 1.</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input:</strong><span style="font-size: 14pt;"> arr[] = [1, 4, 9, 0, 2, 13, 3], k = 4</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> 4</span><br /><span style="font-size: 18.6667px;"><strong>Explanation:</strong> Selecting 0, 4, 9, 13 will result in minimum difference of 4, which is the largest minimum difference possible.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong><span style="color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px; background-color: #ffffff;">1 &le; </span>arr.size()<strong>&nbsp;</strong></span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&le; 10<sup>5</sup><br /></span><span style="color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px; background-color: #ffffff;">0 &le; </span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">arr[i]&nbsp;</span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&le; 10<sup>6</sup><br />2 &le; k&nbsp;</span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&le; arr.size()</span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&nbsp;</span></p>
<p>&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-minimum-game-score/description" target="_blank" rel="noopener noreferrer">Maximize the Minimum Game Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>points</code> of size <code>n</code> and an integer <code>m</code>. There is another array <code>gameScore</code> of size <code>n</code>, where <code>gameScore[i]</code> represents the score achieved at the <code>i<sup>th</sup></code> game. Initially, <code>gameScore[i] == 0</code> for all <code>i</code>.</p>

<p>You start at index -1, which is outside the array (before the first position at index 0). You can make <strong>at most</strong> <code>m</code> moves. In each move, you can either:</p>

<ul>
	<li>Increase the index by 1 and add <code>points[i]</code> to <code>gameScore[i]</code>.</li>
	<li>Decrease the index by 1 and add <code>points[i]</code> to <code>gameScore[i]</code>.</li>
</ul>

<p><strong>Note</strong> that the index must always remain within the bounds of the array after the first move.</p>

<p>Return the <strong>maximum possible minimum</strong> value in <code>gameScore</code> after <strong>at most</strong> <code>m</code> moves.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">points = [2,4], m = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>Initially, index <code>i = -1</code> and <code>gameScore = [0, 0]</code>.</p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Move</th>
			<th style="border: 1px solid black;">Index</th>
			<th style="border: 1px solid black;">gameScore</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">Increase <code>i</code></td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>[2, 0]</code></td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Increase <code>i</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>[2, 4]</code></td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Decrease <code>i</code></td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>[4, 4]</code></td>
		</tr>
	</tbody>
</table>

<p>The minimum value in <code>gameScore</code> is 4, and this is the maximum possible minimum among all configurations. Hence, 4 is the output.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">points = [1,2,3], m = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Initially, index <code>i = -1</code> and <code>gameScore = [0, 0, 0]</code>.</p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Move</th>
			<th style="border: 1px solid black;">Index</th>
			<th style="border: 1px solid black;">gameScore</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">Increase <code>i</code></td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>[1, 0, 0]</code></td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Increase <code>i</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>[1, 2, 0]</code></td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Decrease <code>i</code></td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>[2, 2, 0]</code></td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Increase <code>i</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>[2, 4, 0]</code></td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Increase <code>i</code></td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;"><code>[2, 4, 3]</code></td>
		</tr>
	</tbody>
</table>

<p>The minimum value in <code>gameScore</code> is 2, and this is the maximum possible minimum among all configurations. Hence, 2 is the output.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == points.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= points[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-minimum-powered-city/description" target="_blank" rel="noopener noreferrer">Maximize the Minimum Powered City</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>stations</code> of length <code>n</code>, where <code>stations[i]</code> represents the number of power stations in the <code>i<sup>th</sup></code> city.</p>

<p>Each power station can provide power to every city in a fixed <strong>range</strong>. In other words, if the range is denoted by <code>r</code>, then a power station at city <code>i</code> can provide power to all cities <code>j</code> such that <code>|i - j| &lt;= r</code> and <code>0 &lt;= i, j &lt;= n - 1</code>.</p>

<ul>
	<li>Note that <code>|x|</code> denotes <strong>absolute</strong> value. For example, <code>|7 - 5| = 2</code> and <code>|3 - 10| = 7</code>.</li>
</ul>

<p>The <strong>power</strong> of a city is the total number of power stations it is being provided power from.</p>

<p>The government has sanctioned building <code>k</code> more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.</p>

<p>Given the two integers <code>r</code> and <code>k</code>, return <em>the <strong>maximum possible minimum power</strong> of a city, if the additional power stations are built optimally.</em></p>

<p><strong>Note</strong> that you can build the <code>k</code> power stations in multiple cities.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stations = [1,2,4,5,0], r = 1, k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
One of the optimal ways is to install both the power stations at city 1. 
So stations will become [1,4,4,5,0].
- City 0 is provided by 1 + 4 = 5 power stations.
- City 1 is provided by 1 + 4 + 4 = 9 power stations.
- City 2 is provided by 4 + 4 + 5 = 13 power stations.
- City 3 is provided by 5 + 4 = 9 power stations.
- City 4 is provided by 5 + 0 = 5 power stations.
So the minimum power of a city is 5.
Since it is not possible to obtain a larger power, we return 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stations = [4,4,4,4], r = 0, k = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
It can be proved that we cannot make the minimum power of a city greater than 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stations.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= stations[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= r&nbsp;&lt;= n - 1</code></li>
	<li><code>0 &lt;= k&nbsp;&lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-profit-as-the-salesman/description" target="_blank" rel="noopener noreferrer">Maximize the Profit as the Salesman</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of houses on a number line, numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>Additionally, you are given a 2D integer array <code>offers</code> where <code>offers[i] = [start<sub>i</sub>, end<sub>i</sub>, gold<sub>i</sub>]</code>, indicating that <code>i<sup>th</sup></code> buyer wants to buy all the houses from <code>start<sub>i</sub></code> to <code>end<sub>i</sub></code> for <code>gold<sub>i</sub></code> amount of gold.</p>

<p>As a salesman, your goal is to <strong>maximize</strong> your earnings by strategically selecting and selling houses to buyers.</p>

<p>Return <em>the maximum amount of gold you can earn</em>.</p>

<p><strong>Note</strong> that different buyers can&#39;t buy the same house, and some houses may remain unsold.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,0] to 1<sup>st</sup> buyer for 1 gold and houses in the range [1,3] to 3<sup>rd</sup> buyer for 2 golds.
It can be proven that 3 is the maximum amount of gold we can achieve.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]
<strong>Output:</strong> 10
<strong>Explanation:</strong> There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,2] to 2<sup>nd</sup> buyer for 10 golds.
It can be proven that 10 is the maximum amount of gold we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= offers.length &lt;= 10<sup>5</sup></code></li>
	<li><code>offers[i].length == 3</code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>1 &lt;= gold<sub>i</sub> &lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-win-from-two-segments/description" target="_blank" rel="noopener noreferrer">Maximize Win From Two Segments</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are some prizes on the <strong>X-axis</strong>. You are given an integer array <code>prizePositions</code> that is <strong>sorted in non-decreasing order</strong>, where <code>prizePositions[i]</code> is the position of the <code>i<sup>th</sup></code> prize. There could be different prizes at the same position on the line. You are also given an integer <code>k</code>.</p>

<p>You are allowed to select two segments with integer endpoints. The length of each segment must be <code>k</code>. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.</p>

<ul>
	<li>For example if <code>k = 2</code>, you can choose segments <code>[1, 3]</code> and <code>[2, 4]</code>, and you will win any prize <font face="monospace">i</font> that satisfies <code>1 &lt;= prizePositions[i] &lt;= 3</code> or <code>2 &lt;= prizePositions[i] &lt;= 4</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of prizes you can win if you choose the two segments optimally</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> prizePositions = [1,1,2,2,3,3,5], k = 2
<strong>Output:</strong> 7
<strong>Explanation:</strong> In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> prizePositions = [1,2,3,4], k = 0
<strong>Output:</strong> 2
<strong>Explanation:</strong> For this example, <strong>one choice</strong> for the segments is <code>[3, 3]</code> and <code>[4, 4],</code> and you will be able to get <code>2</code> prizes. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= prizePositions.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= prizePositions[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>9</sup> </code></li>
	<li><code>prizePositions</code> is sorted in non-decreasing order.</li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-balanced-subsequence-sum/description" target="_blank" rel="noopener noreferrer">Maximum Balanced Subsequence Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>A <strong>subsequence</strong> of <code>nums</code> having length <code>k</code> and consisting of <strong>indices</strong> <code>i<sub>0</sub>&nbsp;&lt;&nbsp;i<sub>1</sub> &lt;&nbsp;... &lt; i<sub>k-1</sub></code> is <strong>balanced</strong> if the following holds:</p>

<ul>
	<li><code>nums[i<sub>j</sub>] - nums[i<sub>j-1</sub>] &gt;= i<sub>j</sub> - i<sub>j-1</sub></code>, for every <code>j</code> in the range <code>[1, k - 1]</code>.</li>
</ul>

<p>A <strong>subsequence</strong> of <code>nums</code> having length <code>1</code> is considered balanced.</p>

<p>Return <em>an integer denoting the <strong>maximum</strong> possible <strong>sum of elements</strong> in a <strong>balanced</strong> subsequence of </em><code>nums</code>.</p>

<p>A <strong>subsequence</strong> of an array is a new <strong>non-empty</strong> array that is formed from the original array by deleting some (<strong>possibly none</strong>) of the elements without disturbing the relative positions of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3,5,6]
<strong>Output:</strong> 14
<strong>Explanation:</strong> In this example, the subsequence [3,5,6] consisting of indices 0, 2, and 3 can be selected.
nums[2] - nums[0] &gt;= 2 - 0.
nums[3] - nums[2] &gt;= 3 - 2.
Hence, it is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums.
The subsequence consisting of indices 1, 2, and 3 is also valid.
It can be shown that it is not possible to get a balanced subsequence with a sum greater than 14.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,-1,-3,8]
<strong>Output:</strong> 13
<strong>Explanation:</strong> In this example, the subsequence [5,8] consisting of indices 0 and 3 can be selected.
nums[3] - nums[0] &gt;= 3 - 0.
Hence, it is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums.
It can be shown that it is not possible to get a balanced subsequence with a sum greater than 13.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,-1]
<strong>Output:</strong> -1
<strong>Explanation:</strong> In this example, the subsequence [-1] can be selected.
It is a balanced subsequence, and its sum is the maximum among the balanced subsequences of nums.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/description" target="_blank" rel="noopener noreferrer">Maximum Beauty of an Array After Applying Operation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> and a <strong>non-negative</strong> integer <code>k</code>.</p>

<p>In one operation, you can do the following:</p>

<ul>
	<li>Choose an index <code>i</code> that <strong>hasn&#39;t been chosen before</strong> from the range <code>[0, nums.length - 1]</code>.</li>
	<li>Replace <code>nums[i]</code> with any integer from the range <code>[nums[i] - k, nums[i] + k]</code>.</li>
</ul>

<p>The <strong>beauty</strong> of the array is the length of the longest subsequence consisting of equal elements.</p>

<p>Return <em>the <strong>maximum</strong> possible beauty of the array </em><code>nums</code><em> after applying the operation any number of times.</em></p>

<p><strong>Note</strong> that you can apply the operation to each index <strong>only once</strong>.</p>

<p>A&nbsp;<strong>subsequence</strong> of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,6,1,2], k = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we apply the following operations:
- Choose index 1, replace it with 4 (from range [4,8]), nums = [4,4,1,2].
- Choose index 3, replace it with 4 (from range [0,4]), nums = [4,4,1,4].
After the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).
It can be proven that 3 is the maximum possible length we can achieve.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1], k = 10
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example we don&#39;t have to apply any operations.
The beauty of the array nums is 4 (whole array).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Consider an element <span class="math inline">\(x\)</span>. Using the given operation, <span class="math inline">\(x\)</span> can be transformed into any integer within the range <span class="math inline">\([x - k, x + k]\)</span>. To find the longest subsequence where all elements are identical, our objective is to apply the operation to each element in a manner that maximizes the number of equal elements.</p>
<p>Let's consider each number in the array as a range of possible values it can become. We'll illustrate this concept using Example 1 from the problem description.</p>
<p><img src="../Figures/2779/ranges.png" alt="" /></p>
<p>Notice that we can make two elements equal if their possible value ranges overlap. For instance, when <code>k = 2</code> and we have the numbers 1 and 4, we can change them both to 3. This is possible because 1 can become any number from -1 to 3, and 4 can become any number from 2 to 6. Since these ranges overlap, we can select a number from that overlapping section.</p>
<p>Thus, we can conclude that in our collection of ranges, all those that overlap can be changed to have equal values. Therefore, the highest number of equal values will be equal to the largest collection of overlapping ranges.</p>
<p>To efficiently count overlapping ranges, consider two numbers <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, where <span class="math inline">\(x \leq y\)</span>. Now, <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> can be converted to the same number as long as the maximum possible value of the changed <span class="math inline">\(x\)</span> is greater than or equal to the minimum possible value of the changed <span class="math inline">\(y\)</span>, i.e.:</p>
<p><span class="math display">\[\begin{aligned}
 &x + k \geq y - k  \\ 
\implies& y - x \leq 2 \cdot k \\
\implies& y \leq x + 2 \cdot k 
\end{aligned}
\]</span></p>
<p>In simpler terms, for any number <span class="math inline">\(x\)</span>, it can form a subsequence with all numbers that fall within the range from <span class="math inline">\(x\)</span> to <span class="math inline">\(x + 2k\)</span>. To efficiently find these numbers, we can use <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search 🔗</a>, but first, we need to sort the array.</p>
<p>After sorting, we use binary search for each number in the array to identify the largest value that does not exceed <span class="math inline">\(x + 2k\)</span>. If we find such a value at index <span class="math inline">\(j\)</span>, and our current number is at index <span class="math inline">\(i\)</span>, then <span class="math inline">\(j - i + 1\)</span> represents the length of the possible subsequence. The maximum length found among all numbers in the array is our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<blockquote>
<p>Note: While most programming languages provide built-in methods for finding the upper bound in a sorted list, we have implemented our own method here for clarity and completeness.</p>
</blockquote>
<ul>
<li>Initialize a variable <code>maxBeauty</code> to <code>0</code> to track the maximum beauty possible.</li>
<li>Sort the input array <code>nums</code> in ascending order to enable efficient range-based searching.</li>
<li>For each index <code>i</code> from 0 to the length of <code>nums</code>:
<ul>
<li>Calculate the target value as <code>nums[i] + 2*k</code>, which represents the maximum possible equal value achievable for any element in the range.</li>
<li>Find the <code>upperBound</code> index where <code>nums[upperBound]</code> is the largest element less than or equal to the target value.</li>
<li>Update <code>maxBeauty</code> to be the maximum of current <code>maxBeauty</code> and <code>(upperBound - i + 1)</code>.</li>
</ul>
</li>
<li>Return <code>maxBeauty</code> as the final answer.</li>
</ul>
<p>In the <code>findUpperBound(arr, val)</code> helper function:</p>
<ul>
<li>Initialize variables <code>low</code> to 0 and <code>high</code> to the length of the array minus 1.</li>
<li>Initialize a <code>result</code> variable to 0 to store the latest valid index.</li>
<li>While <code>low</code> is less than or equal to <code>high</code>:
<ul>
<li>Calculate <code>mid</code> as the average of <code>low</code> and <code>high</code>.</li>
<li>If the element at the <code>mid</code> index is less than or equal to the target <code>val</code>:
<ul>
<li>Update <code>result</code> to <code>mid</code>.</li>
<li>Update <code>low</code> to <code>mid + 1</code> to search in the right half.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Update <code>high</code> to <code>mid - 1</code> to search in the left half.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final <code>result</code> index.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/SxYkPenx/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The time complexity is dominated by two major operations. First, sorting the input array takes <span class="math inline">\(O(n \cdot \log n)\)</span> time. Second, for each element in the array, we perform a binary search, which takes <span class="math inline">\(O(\log n)\)</span> time. Since this binary search is performed <span class="math inline">\(n\)</span> times, the total time complexity is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(2 \cdot O(n \cdot \log n) = O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(S)\)</span></p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>All other variables used by the algorithm take constant space. Thus, the space complexity is <span class="math inline">\(O(S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sliding-window">Approach 2: Sliding Window</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When we look for the longest subsequence each number can form, we're essentially looking for a window of consecutive numbers. Instead of repeatedly searching for where each window ends, we can be more efficient by using a technique called the sliding window approach.</p>
<p>This involves maintaining a range with a left and a right boundary that dynamically adjusts as we move through the sorted array. Starting with both boundaries at the beginning of the array, we extend the right boundary to include as many numbers as possible while ensuring the condition holds — specifically, that the difference between the largest and smallest numbers in the range does not exceed <span class="math inline">\(2 \cdot k\)</span>. If the condition is violated, we adjust the left boundary to restore the range. The maximum length of this range across all positions gives us the desired result.</p>
<blockquote>
<p>For a more comprehensive understanding of the sliding window technique, check out the <a href="https://leetcode.com/explore/learn/card/array-and-string/204/sliding-window/">Sliding Window Explore Card 🔗</a>. This resource provides an in-depth look at the sliding window approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a variable <code>maxBeauty</code> to <code>0</code> to track the maximum beauty possible.</li>
<li>Sort the input array <code>nums</code> in ascending order.</li>
<li>Initialize a variable <code>right</code> to <code>0</code> to serve as the right pointer of our window.</li>
<li>For each index <code>left</code> from <code>0</code> to length of <code>nums</code>:
<ul>
<li>While <code>right</code> is less than the length of <code>nums</code> and the difference between elements at <code>right</code> and <code>left</code> indices is <span class="math inline">\(\leq\)</span> <code>2*k</code>:
<ul>
<li>Increment <code>right</code> pointer by 1.</li>
</ul>
</li>
<li>Update <code>maxBeauty</code> to be the maximum of current <code>maxBeauty</code> and <code>(right - left)</code>.</li>
</ul>
</li>
<li>Return <code>maxBeauty</code> as our answer.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/E8N6kKk9/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The time complexity is dominated by the initial sorting operation which takes <span class="math inline">\(O(n \cdot \log n)\)</span> time. The subsequent two-pointer traversal, while appearing to be nested loops, actually has linear complexity because the right pointer never resets - it only moves forward. This means each element is visited at most twice (once by the <code>left</code> pointer and once by the <code>right</code> pointer), contributing <span class="math inline">\(O(n)\)</span> to the time complexity.</p>
<p>Thus, the overall time complexity remains <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(S)\)</span></p>
<p>The space complexity of the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>The algorithm does not use any additional space aside from that used by the sorting.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-line-sweep">Approach 3: Line Sweep</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We need to find the maximum overlap across all ranges defined by the numbers. Visualize this as laying pieces of cloth on a number line to represent the range of values each number can span. When ranges overlap, the cloths stack on top of each other. Our objective is to identify the point with the most layers of cloth and count those layers.</p>
<p>To implement this concept, we'll create an array <code>count</code> to represent the entire possible range of values (our number line). This array will have a size of <code>maxValue + 1</code> to accommodate the maximum possible range. We'll then iterate over the <code>nums</code> array, marking the ranges in <code>count</code> by incrementing the indices within each range by 1. The highest value in <code>count</code> will indicate the point of maximum overlap, which is our answer.</p>
<p><img src="../Figures/2779/count.png" alt="" /></p>
<p>However, repeatedly looping over the ranges to populate <code>count</code> is inefficient. Instead, we'll mark the start and end positions of each range with <code>+1</code> and <code>-1</code>, respectively. This allows us to fill the ranges later by calculating the prefix sum of the array. When we encounter the start of a range, our running total increases by 1, and it remains elevated until we reach the end of that range, where it decreases by 1.</p>
<p>We'll maintain a variable <code>maxBeauty</code> to track the maximum value encountered while filling the <code>count</code> array. This value, stored in <code>maxBeauty</code>, will be returned as the maximum beauty of the array.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a variable <code>maxBeauty</code> to <code>0</code> to track the maximum subsequence length.</li>
<li>If array length is 1, return <code>1</code> as the answer since a single element forms a subsequence of length 1.</li>
<li>Find the maximum element in the array and store it in a variable <code>maxValue</code>.</li>
<li>Create a <code>count</code> array of size <code>maxValue + 1</code> initialized with zeros to track range overlaps.</li>
<li>For each number <code>num</code> in the input array:
<ul>
<li>At index <code>max(num - k, 0)</code>, increment count by 1 to mark the start of the range.</li>
<li>At index <code>min(num + k + 1, maxValue)</code>, decrement count by 1 to mark the end of the range.</li>
</ul>
</li>
<li>Initialize <code>currentSum</code> to <code>0</code> to track the running sum of overlapping ranges.</li>
<li>Iterate through the <code>count</code> array:
<ul>
<li>Add current <code>count</code> value to <code>currentSum</code>.</li>
<li>Update <code>maxBeauty</code> to the maximum of the current <code>maxBeauty</code> and <code>currentSum</code>.</li>
</ul>
</li>
<li>Return <code>maxBeauty</code> as the final answer.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZdVC9FDw/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code> and <span class="math inline">\(\text{maxValue}\)</span> be the maximum value in the array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + \text{maxValue})\)</span></p>
<p>The time complexity has multiple components. First, finding the maximum value requires one pass through <code>nums</code> taking <span class="math inline">\(O(n)\)</span> time. Then, we make another pass through the array to update the <code>count</code> array, taking <span class="math inline">\(O(n)\)</span> time. Finally, we iterate through the <code>count</code> array of size <span class="math inline">\((\text{maxValue}+1)\)</span> taking <span class="math inline">\(O(\text{maxValue})\)</span> time.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(2 \cdot O(n) + O(\text{maxValue}) = O(n + \text{maxValue})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\text{maxValue})\)</span></p>
<p>The space complexity is dominated by the <code>count</code> array which has a size of <span class="math inline">\(\text{maxValue}+1\)</span>. We only use a constant number of additional variables, so they don't affect the asymptotic space complexity. So, the overall space complexity is <span class="math inline">\(O(\text{maxValue})\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-candies-allocated-to-k-children/description" target="_blank" rel="noopener noreferrer">Maximum Candies Allocated to K Children</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>candies</code>. Each element in the array denotes a pile of candies of size <code>candies[i]</code>. You can divide each pile into any number of <strong>sub piles</strong>, but you <strong>cannot</strong> merge two piles together.</p>

<p>You are also given an integer <code>k</code>. You should allocate piles of candies to <code>k</code> children such that each child gets the <strong>same</strong> number of candies. Each child can be allocated candies from <strong>only one</strong> pile of candies and some piles of candies may go unused.</p>

<p>Return <em>the <strong>maximum number of candies</strong> each child can get.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> candies = [5,8,6], k = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> candies = [2,5], k = 11
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= candies.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= candies[i] &lt;= 10<sup>7</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>12</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array called <code>candies</code>, where each element <code>candies[i]</code> represents the number of candies in the <code>i-th</code> pile. We also have an integer <code>k</code>, which denotes the number of children we must give candies to. Our goal is to find the greatest number of candies each child can get, following these rules:</p>
<ul>
<li>Each child must get the same number of candies.</li>
<li>Each child's candies must come from just one pile. We can divide candies from a pile among multiple children, but we cannot combine candies from different piles for one child.</li>
</ul>
<p>Note that we do not have to use all the candies from any given pile—some candies from a pile or even entire piles may remain unused.</p>
<p>To better understand the task, let's go through an example. Suppose we have <code>candies = [5, 2, 6, 2]</code> and <code>k = 3</code>.</p>
<p>First, since each child's candies must come from a single pile, the greatest number of candies each child can get is at most equal to the largest element in the array — in this case, <code>6</code>. If we tried to give, for example, <code>7</code> candies to each child, we would need to combine candies from multiple piles, which is not allowed.</p>
<p>After determining the upper bound, we can start from <code>6</code> and go down to <code>0</code> until we find the first number for which an allocation is valid. Let's denote the number of candies each child receives with <code>x</code>.</p>
<ul>
<li>For <code>x = 6</code>, no valid distribution exists, as the total number of candies is less than <code>3 * 6 = 18</code>.</li>
<li>For <code>x = 5</code>, the first child can get candies from the first pile and the second child can get candies from the third pile. However, it is impossible to give <code>5</code> candies to the last child without combining the remaining piles.</li>
<li>Similarly, for <code>x = 4</code>, giving candies to the last child would require merging piles, which is not allowed.</li>
<li>For <code>x = 3</code>, we can give <code>3</code> candies from the first pile to the first child, <code>3</code> candies from the third pile to the second child, and the remaining <code>3</code> candies from the third pile to the third child.</li>
</ul>
<p>Since <code>3</code> is the largest number of candies that satisfies all conditions, it is our final result.</p>
<p><img src="../Figures/2226/2226_overview.png" alt="Visual Illustration of the Example" /></p>
<h3 id="approach-binary-search-on-the-answer">Approach: Binary Search on The Answer</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's first try to answer a slightly different question: given a target number of candies <code>x</code> per child, can we distribute the candies so that each child gets exactly <code>x</code>?</p>
<p>To check this, we calculate how many children each pile can serve. For example, with <code>candies = [5, 2, 6, 2]</code> and <code>x = 4</code>, the first and third piles can serve one child each, with some leftover, while the second and fourth piles can't be used because they contain fewer than <code>x</code> candies. In total, the piles can serve at most <code>2</code> children.</p>
<p>Generally, each pile can serve up to <span class="math inline">\(\lfloor \frac{\text{candies[i]}}{x} \rfloor\)</span> children, possibly with some leftover candies. By summing the number of children each pile can serve, we can easily determine if an allocation is possible by comparing the total to the number of children (<code>k</code>) we must distribute candies to.</p>
<p>Additionally, note that if a valid distribution exists for a given number <code>x</code>, then a distribution is also possible for any number smaller than or equal to <code>x</code>. Conversely, if we cannot allocate the candies such that each child receives <code>x</code> candies, then it's impossible to distribute them in a way that gives each child more than <code>x</code> candies. This monotonic property allows us to use a binary search approach, where we check if a distribution is possible for the middle value of our search range. Based on that, we either move to the upper half of the range if a distribution is possible, or to the lower half if it's not.</p>
<p><img src="../Figures/2226/2226_approach1.png" alt="Execution of the Binary Search Algorithm" /></p>
<blockquote>
<p>For a more comprehensive understanding of binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card 🔗</a>. This resource offers an in-depth look at binary search, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern. Additionally, for extra practice, consider taking a look at the classic binary search problem <a href="https://leetcode.com/problems/koko-eating-bananas/description/">Koko Eating Bananas</a>.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define a function <code>canAllocateCandies(candies, k, numOfCandies)</code>:</p>
<ul>
<li>Initialize <code>maxNumOfChildren</code> to <code>0</code>, denoting the maximum number of children that can be served.</li>
<li>Iterate over <code>candies</code>, with <code>pileIndex</code> from <code>0</code> to <code>candies.size - 1</code>, to find the greatest number of children each pile can serve:
<ul>
<li>Add <code>candies[pileIndex] / numOfCandies</code> to <code>maxNumOfChildren</code>.</li>
</ul>
</li>
<li>If the number of children that can be served is at least <code>k</code>, return <code>true</code>. Otherwise, return <code>false</code>.</li>
</ul>
</li>
<li>
<p>In the main <code>maximumCandies</code> function:</p>
<ul>
<li>Iterate over <code>candies</code> to find the maximum element and store it as <code>maxCandiesInPile</code>.</li>
<li>Initialize the boundaries of the binary search: <code>left = 0</code> and <code>right = maxCandiesInPile</code>.</li>
<li>While <code>left &lt; right</code>:
<ul>
<li>Find <code>middle</code> as <code>(left + right + 1) / 2</code>.</li>
<li>Check if an allocation where each child receives <code>middle</code> candies is possible, using the <code>canAllocateCandies</code> function. If so, move to the upper half of the range to search for greater values, by setting <code>left = middle</code>.</li>
<li>Otherwise, move to the lower half, by setting <code>right = middle - 1</code>.</li>
</ul>
</li>
<li>When exiting the loop, <code>left = right</code>, so return <code>left</code>, which corresponds to the maximum number of candies each child can get.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Wqg9c2Qi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>candies</code> array and <span class="math inline">\(m\)</span> be the greatest value in it.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log m)\)</span></p>
<p>The <code>canAllocateCandies</code> function iterates through the <span class="math inline">\(n\)</span> candy piles, executing constant-time (arithmetic) operations, during each iteration. As a result, its time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>The main function, <code>maximumCandies</code>, performs a binary search over the range <span class="math inline">\([0, m]\)</span>, calling in each iteration the <code>canAllocateCandies</code> function. Since the binary search runs in <span class="math inline">\(O(\log m)\)</span> time, the overall time complexity of the <code>maximumCandies</code> function is <span class="math inline">\(O(n \log m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use a fixed number of integer variables (<code>left</code>, <code>right</code>, <code>maxNumberOfChildren</code>), which do not increase with input size.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-coins-from-k-consecutive-bags/description" target="_blank" rel="noopener noreferrer">Maximum Coins From K Consecutive Bags</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are an infinite amount of bags on a number line, one bag for each coordinate. Some of these bags contain coins.</p>

<p>You are given a 2D array <code>coins</code>, where <code>coins[i] = [l<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub>]</code> denotes that every bag from <code>l<sub>i</sub></code> to <code>r<sub>i</sub></code> contains <code>c<sub>i</sub></code> coins.</p>

<p>The segments that <code>coins</code> contain are non-overlapping.</p>

<p>You are also given an integer <code>k</code>.</p>

<p>Return the <strong>maximum</strong> amount of coins you can obtain by collecting <code>k</code> consecutive bags.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coins = [[8,10,1],[1,3,2],[5,6,4]], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">10</span></p>

<p><strong>Explanation:</strong></p>

<p>Selecting bags at positions <code>[3, 4, 5, 6]</code> gives the maximum number of coins:&nbsp;<code>2 + 0 + 4 + 4 = 10</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coins = [[1,10,3]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>Selecting bags at positions <code>[1, 2]</code> gives the maximum number of coins:&nbsp;<code>3 + 3 = 6</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= coins.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
	<li><code>coins[i] == [l<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub>]</code></li>
	<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= c<sub>i</sub> &lt;= 1000</code></li>
	<li>The given segments are non-overlapping.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description" target="_blank" rel="noopener noreferrer">Maximum Count of Positive Integer and Negative Integer</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>the maximum between the number of positive integers and the number of negative integers.</em></p>

<ul>
	<li>In other words, if the number of positive integers in <code>nums</code> is <code>pos</code> and the number of negative integers is <code>neg</code>, then return the maximum of <code>pos</code> and <code>neg</code>.</li>
</ul>

<p><strong>Note</strong> that <code>0</code> is neither positive nor negative.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,-1,-1,1,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 positive integers and 3 negative integers. The maximum count among them is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-3,-2,-1,0,0,1,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 2 positive integers and 3 negative integers. The maximum count among them is 3.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,20,66,1314]
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 positive integers and 0 negative integers. The maximum count among them is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>-2000 &lt;= nums[i] &lt;= 2000</code></li>
	<li><code>nums</code> is sorted in a <strong>non-decreasing order</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve the problem in <code>O(log(n))</code> time complexity?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of <span class="math inline">\(N\)</span> integers, which may contain positive, negative, or zero values. The array is sorted in non-decreasing order. The task is to count the number of positive and negative integers, and then return the greater of the two counts. Note that zero is considered neither a positive nor a negative integer.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>This is the brute-force approach, where we count the number of positive and negative integers by iterating through each element of the array. During the iteration, we increment <code>positiveCount</code> for each integer greater than zero and <code>negativeCount</code> for each integer less than zero.</p>
<p>Finally, we return the greater of the two variables, <code>positiveCount</code> and <code>negativeCount</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize the variables <code>positiveCount</code> and <code>negativeCount</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over the array <code>nums</code> and for each integer <code>num</code> do the following:</p>
<ul>
<li>Increment the variable <code>positiveCount</code> if <code>num</code> is greater than <code>0</code>.</li>
<li>Increment the variable <code>negativeCount</code> if <code>num</code> is less than <code>0</code>.</li>
</ul>
</li>
<li>
<p>Return the max of the two variables <code>positiveCount</code> and <code>negativeCount</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/YoJSNJpW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of integers in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need to iterate over each integer in the array <code>nums</code> and hence the time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No extra space is required apart from the two variables, <code>positiveCount</code> and <code>negativeCount</code>, and hence the total space complexity is constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search">Approach 2: Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we did not utilize an important property of the problem: the array is sorted in non-decreasing order. One of the typical algorithms that leverages a sorted array is binary search. Let's explore how we can apply binary search to solve this problem.</p>
<p>The array contains negative, positive, and zero integers, and because it is ordered, the zeros will be positioned in the middle, separating the negative and positive integers. To count the number of negative and positive integers, observe that all the integers before the first zero are negative, and all the integers after the last zero are positive. This observation is key: if we can find the indices of the first and last zeros in the array, we can easily determine the counts of positive and negative integers.</p>
<p>If the first zero is located at index <code>x</code>, then there are <code>x</code> negative integers (from index <code>0</code> to <code>x - 1</code>). Similarly, if the last zero is at index <code>y</code>, there are <code>N - y - 1</code> positive integers (from index <code>y + 1</code> to <code>N - 1</code>).</p>
<p>In languages like C++, we have built-in functions such as <code>lower_bound()</code> and <code>upper_bound()</code> that can be used to find these indices directly. To improve readability, we will implement these functions ourselves. The <code>lowerBound()</code> function will return the first index in the array where the value is greater than or equal to zero, and the <code>upperBound()</code> function will return the first index where the value is strictly greater than zero.</p>
<p>The number of positive integers, <code>positiveCount,</code> will be equal to <code>N - upperBound()</code>, since <code>upperBound()</code> returns the first index where the value is greater than zero. Similarly, the number of negative integers, <code>negativeCount</code>, will be equal to <code>lowerBound()</code>, as <code>lowerBound()</code> returns the first index where the value is greater than or equal to zero.</p>
<p>The implementations of <code>lowerBound(nums)</code> and <code>upperBound(nums)</code> are similar. For <code>lowerBound(nums)</code>, we perform a binary search with <code>start = 0</code> and <code>end = nums.size - 1</code>. In each iteration, we calculate the <code>mid</code> index as <code>(start + end) / 2</code>:</p>
<ul>
<li>If <code>nums[mid]</code> is less than <code>0</code>, the first non-negative value must be to the right, so we update <code>start</code> to <code>mid + 1</code> to search the higher range.</li>
<li>If <code>nums[mid]</code> is greater than or equal to <code>0</code>, <code>mid</code> could be the index we are looking for, so we store it as a candidate answer in <code>index</code>. Then, we continue searching to the left by updating <code>end</code> to <code>mid - 1</code> to check whether there is another non-negative value before <code>nums[mid]</code>.</li>
</ul>
<p>This process continues until the search space is exhausted. If you want to learn more details, please read the <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card</a>.</p>
<p>Once we have determined the counts of positive and negative integers using binary search, we can return the greater of the two counts, as we did in the previous approach.</p>
<p><img src="../Figures/2529/2529A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Define <code>lowerBound(nums)</code> function to find the first index where the value is equal to or greater than zero.</p>
<ul>
<li>Initialize <code>start = 0</code>, <code>end = nums.size - 1,</code> and <code>index = nums.size</code>.</li>
<li>Perform a binary search:
<ul>
<li>If the middle element (<code>nums[mid]</code>) is negative, move <code>start </code>to <code>mid + 1</code> to search for non-negative integers in the higher range.</li>
<li>Otherwise, the middle element (<code>nums[mid]</code>) is non-negative:
<ul>
<li>Move <code>end</code> to <code>mid - 1</code> to search for the <strong>first</strong> non-negative element in the lower range.</li>
<li>Update <code>index</code> to <code>mid</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>index</code>, which represents the first index where a non-negative value appears.</li>
</ul>
</li>
<li>
<p>Define <code>upperBound(nums)</code> function to find the first index where the value is strictly greater than zero.</p>
<ul>
<li>Initialize <code>start = 0</code>, <code>end = nums.size - 1</code>, and <code>index = nums.size</code>.</li>
<li>Perform a binary search:
<ul>
<li>If the middle element (<code>nums[mid]</code>) is less than or equal to zero, move <code>start</code> to <code>mid + 1</code> to search for positive values in the higher range.</li>
<li>Otherwise, the middle element (<code>nums[mid]</code>) is greater than zero:
<ul>
<li>Move <code>end</code> to <code>mid - 1</code>, to search for the <strong>first</strong> positive value in the lower range.</li>
<li>Update <code>index</code> to <code>mid</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>index</code>, which represents the first index where a positive value appears.</li>
</ul>
</li>
<li>
<p>Subtract the result of <code>upperBound(nums)</code> from the total array size to get the number of positive integers (<code>positiveCount</code>).</p>
</li>
<li>
<p>Call <code>lowerBound(nums)</code>, which directly gives the count of negative integers (<code>negativeCount</code>).</p>
</li>
<li>
<p>Return the maximum of <code>positiveCount</code> and <code>negativeCount</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/KZiv6zMc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of integers in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log N)\)</span></p>
<p>We perform binary search twice to find the lower and upper bounds for <code>0</code>. At each step of the binary search, we discard half of the array, narrowing down the search range for the index we are looking for. Hence, the total time complexity is  <span class="math inline">\(O(\log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No extra space is required apart from a few variables and hence the total space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-distance-between-a-pair-of-values/description" target="_blank" rel="noopener noreferrer">Maximum Distance Between a Pair of Values</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>non-increasing 0-indexed </strong>integer arrays <code>nums1</code>​​​​​​ and <code>nums2</code>​​​​​​.</p>

<p>A pair of indices <code>(i, j)</code>, where <code>0 &lt;= i &lt; nums1.length</code> and <code>0 &lt;= j &lt; nums2.length</code>, is <strong>valid</strong> if both <code>i &lt;= j</code> and <code>nums1[i] &lt;= nums2[j]</code>. The <strong>distance</strong> of the pair is <code>j - i</code>​​​​.</p>

<p>Return <em>the <strong>maximum distance</strong> of any <strong>valid</strong> pair </em><code>(i, j)</code><em>. If there are no valid pairs, return </em><code>0</code>.</p>

<p>An array <code>arr</code> is <strong>non-increasing</strong> if <code>arr[i-1] &gt;= arr[i]</code> for every <code>1 &lt;= i &lt; arr.length</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).
The maximum distance is 2 with pair (2,4).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,2,2], nums2 = [10,10,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The valid pairs are (0,0), (0,1), and (1,1).
The maximum distance is 1 with pair (0,1).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).
The maximum distance is 2 with pair (2,4).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>
	<li>Both <code>nums1</code> and <code>nums2</code> are <strong>non-increasing</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-earnings-from-taxi/description" target="_blank" rel="noopener noreferrer">Maximum Earnings From Taxi</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> points on a road you are driving your taxi on. The <code>n</code> points on the road are labeled from <code>1</code> to <code>n</code> in the direction you are going, and you want to drive from point <code>1</code> to point <code>n</code> to make money by picking up passengers. You cannot change the direction of the taxi.</p>

<p>The passengers are represented by a <strong>0-indexed</strong> 2D integer array <code>rides</code>, where <code>rides[i] = [start<sub>i</sub>, end<sub>i</sub>, tip<sub>i</sub>]</code> denotes the <code>i<sup>th</sup></code> passenger requesting a ride from point <code>start<sub>i</sub></code> to point <code>end<sub>i</sub></code> who is willing to give a <code>tip<sub>i</sub></code> dollar tip.</p>

<p>For<strong> each </strong>passenger <code>i</code> you pick up, you <strong>earn</strong> <code>end<sub>i</sub> - start<sub>i</sub> + tip<sub>i</sub></code> dollars. You may only drive <b>at most one </b>passenger at a time.</p>

<p>Given <code>n</code> and <code>rides</code>, return <em>the <strong>maximum</strong> number of dollars you can earn by picking up the passengers optimally.</em></p>

<p><strong>Note:</strong> You may drop off a passenger and pick up a different passenger at the same point.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5, rides = [<u>[2,5,4]</u>,[1,5,1]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 20, rides = [[1,6,1],<u>[3,10,2]</u>,<u>[10,12,3]</u>,[11,12,2],[12,15,2],<u>[13,18,1]</u>]
<strong>Output:</strong> 20
<strong>Explanation:</strong> We will pick up the following passengers:
- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.
- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.
- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.
We earn 9 + 5 + 6 = 20 dollars in total.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= rides.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>rides[i].length == 3</code></li>
	<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= n</code></li>
	<li><code>1 &lt;= tip<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/description" target="_blank" rel="noopener noreferrer">Maximum Frequency of an Element After Performing Operations I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and two integers <code>k</code> and <code>numOperations</code>.</p>

<p>You must perform an <strong>operation</strong> <code>numOperations</code> times on <code>nums</code>, where in each operation you:</p>

<ul>
	<li>Select an index <code>i</code> that was <strong>not</strong> selected in any previous operations.</li>
	<li>Add an integer in the range <code>[-k, k]</code> to <code>nums[i]</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> possible <span data-keyword="frequency-array">frequency</span> of any element in <code>nums</code> after performing the <strong>operations</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,5], k = 1, numOperations = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>. <code>nums</code> becomes <code>[1, 4, 5]</code>.</li>
	<li>Adding -1 to <code>nums[2]</code>. <code>nums</code> becomes <code>[1, 4, 4]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,11,20,20], k = 5, numOperations = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= numOperations &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description" target="_blank" rel="noopener noreferrer">Maximum Frequency of an Element After Performing Operations II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and two integers <code>k</code> and <code>numOperations</code>.</p>

<p>You must perform an <strong>operation</strong> <code>numOperations</code> times on <code>nums</code>, where in each operation you:</p>

<ul>
	<li>Select an index <code>i</code> that was <strong>not</strong> selected in any previous operations.</li>
	<li>Add an integer in the range <code>[-k, k]</code> to <code>nums[i]</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> possible <span data-keyword="frequency-array">frequency</span> of any element in <code>nums</code> after performing the <strong>operations</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,5], k = 1, numOperations = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>, after which <code>nums</code> becomes <code>[1, 4, 5]</code>.</li>
	<li>Adding -1 to <code>nums[2]</code>, after which <code>nums</code> becomes <code>[1, 4, 4]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,11,20,20], k = 5, numOperations = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= numOperations &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/description" target="_blank" rel="noopener noreferrer">Maximum Fruits Harvested After at Most K Steps</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array <code>fruits</code> where <code>fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>]</code> depicts <code>amount<sub>i</sub></code> fruits at the position <code>position<sub>i</sub></code>. <code>fruits</code> is already <strong>sorted</strong> by <code>position<sub>i</sub></code> in <strong>ascending order</strong>, and each <code>position<sub>i</sub></code> is <strong>unique</strong>.</p>

<p>You are also given an integer <code>startPos</code> and an integer <code>k</code>. Initially, you are at the position <code>startPos</code>. From any position, you can either walk to the <strong>left or right</strong>. It takes <strong>one step</strong> to move <strong>one unit</strong> on the x-axis, and you can walk <strong>at most</strong> <code>k</code> steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.</p>

<p>Return <em>the <strong>maximum total number</strong> of fruits you can harvest</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/1.png" style="width: 472px; height: 115px;" />
<pre>
<strong>Input:</strong> fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
<strong>Output:</strong> 9
<strong>Explanation:</strong> 
The optimal way is to:
- Move right to position 6 and harvest 3 fruits
- Move right to position 8 and harvest 6 fruits
You moved 3 steps and harvested 3 + 6 = 9 fruits in total.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/2.png" style="width: 512px; height: 129px;" />
<pre>
<strong>Input:</strong> fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
<strong>Output:</strong> 14
<strong>Explanation:</strong> 
You can move at most k = 4 steps, so you cannot reach position 0 nor 10.
The optimal way is to:
- Harvest the 7 fruits at the starting position 5
- Move left to position 4 and harvest 1 fruit
- Move right to position 6 and harvest 2 fruits
- Move right to position 7 and harvest 4 fruits
You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/3.png" style="width: 476px; height: 100px;" />
<pre>
<strong>Input:</strong> fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong>
You can move at most k = 2 steps and cannot reach any position with fruits.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>
	<li><code>fruits[i].length == 2</code></li>
	<li><code>0 &lt;= startPos, position<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>position<sub>i-1</sub> &lt; position<sub>i</sub></code> for any <code>i &gt; 0</code>&nbsp;(<strong>0-indexed</strong>)</li>
	<li><code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= k &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the fruit positions are already sorted in ascending order, we can efficiently determine how many fruits fall within any interval on the x-axis using binary search. The main challenge is to find the interval of positions that can be reached from <code>startPos</code> using at most <span class="math inline">\(k\)</span> steps, such that the total number of fruits collected is maximized.</p>
<p>We follow a greedy strategy, moving in one direction first and then turning around. This works because fruits can only be picked once, and covering a wider range increases the chance of collecting more fruits.</p>
<p>There are two main movement patterns:</p>
<ul>
<li>Move <span class="math inline">\(x\)</span> steps in one direction, then <span class="math inline">\(k - x\)</span> steps in the opposite direction.</li>
<li>When <span class="math inline">\(x = 0\)</span>, we simply move in one direction for <span class="math inline">\(k\)</span> steps.</li>
</ul>
<p>For each <span class="math inline">\(x\)</span> in the range <span class="math inline">\([0, \left\lfloor \frac{k}{2} \right\rfloor]\)</span>, we consider:</p>
<ol>
<li>Left-first movement: move left <span class="math inline">\(x\)</span> steps, then right <span class="math inline">\((k - x)\)</span> steps. This covers the interval <span class="math inline">\([\textit{startPos} - x, \textit{startPos} + k - 2x]\)</span>.</li>
<li>Right-first movement: move right <span class="math inline">\(x\)</span> steps, then left <span class="math inline">\((k - x)\)</span> steps. This covers the interval <span class="math inline">\([\textit{startPos} - (k - 2x), \textit{startPos} + x]\)</span>.</li>
</ol>
<p>For each of these intervals, we compute the number of fruits using prefix sums and binary search in <span class="math inline">\(O(\log n)\)</span> time. The maximum value across all such intervals gives the answer.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/RVS3qU6Q/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{fruits}\)</span>, and let <span class="math inline">\(k\)</span> be the given integer.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + k \log n)\)</span>.</p>
<p>The time complexity for calculating the prefix sum of the array is <span class="math inline">\(O(n)\)</span>, and the time required for each query to find the number of fruits in a range is <span class="math inline">\(O(\log n)\)</span>. Since there are a total of <span class="math inline">\(k\)</span> queries, the overall time complexity is <span class="math inline">\(O(n + k \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We calculate and store the prefix sum of the array, which requires <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sliding-window">Approach 2: Sliding Window</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can approach the problem from a new perspective. Suppose we fix an interval <span class="math inline">\([ \textit{left}, \textit{right} ]\)</span> (where <code>left</code> and <code>right</code> are <strong>indices</strong> in the <code>fruits</code> array). From the given starting position <code>startPos</code>, how many steps are required to visit all fruit positions within this interval?</p>
<p>There are three cases to consider:</p>
<ul>
<li>
<p><strong>Case 1:</strong> <code>startPos &gt; fruits[right][0]</code><br />
The interval lies entirely to the left of <code>startPos</code>. We need to move left to reach <code>fruits[left][0]</code>.<br />
Steps needed:</p>
<p><span class="math display">\[\textit{startPos} - \textit{fruits[left][0]}
\]</span></p>
</li>
<li>
<p><strong>Case 2:</strong> <code>startPos &lt; fruits[left][0]</code><br />
The interval lies entirely to the right of <code>startPos</code>. We need to move right to reach <code>fruits[right][0]</code>.<br />
Steps needed:</p>
<p><span class="math display">\[\textit{fruits[right][0]} - \textit{startPos}
\]</span></p>
</li>
<li>
<p><strong>Case 3:</strong> <code>startPos</code> is within the interval<br />
There are two ways to visit both ends:</p>
<ul>
<li>
<p>Go left first to <code>fruits[left][0]</code>, then right to <code>fruits[right][0]</code><br />
Steps:</p>
<p><span class="math display">\[\textit{startPos} - \textit{fruits[left][0]} + \textit{fruits[right][0]} - \textit{fruits[left][0]}
\]</span></p>
<ul>
<li>Go right first to <code>fruits[right][0]</code>, then left to <code>fruits[left][0]</code><br />
Steps:</li>
</ul>
<p><span class="math display">\[\textit{fruits[right][0]} - \textit{startPos} + \textit{fruits[right][0]} - \textit{fruits[left][0]}
\]</span></p>
</li>
</ul>
</li>
</ul>
<p>So, in general, the minimum number of steps required to traverse the interval <span class="math inline">\([ \textit{fruits[left][0]}, \textit{fruits[right][0]} ]\)</span> is:</p>
<p><span class="math display">\[\text{step}(left, right) = \textit{fruits[right][0]} - \textit{fruits[left][0]} + \min\left( |\textit{startPos} - \textit{fruits[left][0]}|,\ |\textit{startPos} - \textit{fruits[right][0]}| \right)
\]</span></p>
<p>This expression ensures that we count both the total distance and the shorter leg from <code>startPos</code> to either end.</p>
<p>Now, if we fix <code>right</code> and slide <code>left</code>, we observe:</p>
<ul>
<li>If <code>fruits[left][0] &lt; startPos</code>, decreasing <code>left</code> can decrease the <code>step</code> value.</li>
<li>If <code>fruits[left][0] ≥ startPos</code>, decreasing <code>left</code> no longer helps and <code>step</code> stays the same or increases.</li>
</ul>
<p>Thus, for fixed <code>right</code>, the <code>step(left, right)</code> function is non-increasing as long as <code>fruits[left][0] &lt; startPos</code>, and non-decreasing afterward.</p>
<p>Thus, we use a sliding window where both <code>left</code> and <code>right</code> are pointers to intervals in the <code>fruits</code> array. As we move <code>right</code> forward to include more fruits, we check whether the number of steps needed to reach the interval exceeds <code>k</code>. If it does, we increment <code>left</code> to shrink the window until the constraint is satisfied. At each step, we track the sum of fruits in the valid window and update the maximum found so far.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/LtqkxpT2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{fruits}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>Each time, we move the right endpoint of the fixed window and then try to move the left endpoint. The right endpoint can move at most <span class="math inline">\(n\)</span> times, and the left endpoint can also move at most <span class="math inline">\(n\)</span> times. Therefore, the time complexity is <span class="math inline">\(O(2n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-length-of-repeated-subarray/description" target="_blank" rel="noopener noreferrer">Maximum Length of Repeated Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The repeated subarray with maximum length is [3,2,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The repeated subarray with maximum length is [0,0,0,0,0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-brute-force-with-initial-character-map-time-limit-exceeded">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>In a typical brute force, for all starting indices <code>i</code> of <code>A</code> and <code>j</code> of <code>B</code>, we will check for the longest matching subarray <code>A[i: i+k] == B[j: j+k]</code> of length <code>k</code>. This would look roughly like the following pseudocode:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> [<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">..</span> A<span style="color:#000;font-weight:bold">.</span>length <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>]:
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> [<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">..</span> B<span style="color:#000;font-weight:bold">.</span>length <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>]:
</span></span><span style="display:flex;"><span>        k <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> (A[i <span style="color:#000;font-weight:bold">+</span> k] <span style="color:#000;font-weight:bold">==</span> B[j <span style="color:#000;font-weight:bold">+</span> k]): k <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span> <span style="color:#998;font-style:italic">#and i + k &lt; A.length etc.</span>
</span></span><span style="display:flex;"><span>        ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">max</span>(ans, k)
</span></span></code></pre><p>Our insight is that in typical cases, most of the time <code>A[i] != B[j]</code>.  We could instead keep a hashmap <code>Bstarts[A[i]] = all j such that B[j] == A[i]</code>, and only loop through those in our <code>j</code> loop.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">findLength</span>(<span style="color:#999">self</span>, A, B):
</span></span><span style="display:flex;"><span>        ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>        Bstarts <span style="color:#000;font-weight:bold">=</span> collections<span style="color:#000;font-weight:bold">.</span>defaultdict(<span style="color:#0086b3">list</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> j, y <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(B):
</span></span><span style="display:flex;"><span>            Bstarts[y]<span style="color:#000;font-weight:bold">.</span>append(j)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i, x <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(A):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> Bstarts[x]:
</span></span><span style="display:flex;"><span>                k <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">while</span> i <span style="color:#000;font-weight:bold">+</span> k <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">and</span> j <span style="color:#000;font-weight:bold">+</span> k <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">and</span> A[i <span style="color:#000;font-weight:bold">+</span> k] <span style="color:#000;font-weight:bold">==</span> B[j <span style="color:#000;font-weight:bold">+</span> k]:
</span></span><span style="display:flex;"><span>                    k <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">max</span>(ans, k)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">findLength</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        Map<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">,</span> ArrayList<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> Bstarts <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashMap<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> j <span style="color:#000;font-weight:bold">&lt;</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> j<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            Bstarts<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">computeIfAbsent</span><span style="color:#000;font-weight:bold">(</span>B<span style="color:#000;font-weight:bold">[</span>j<span style="color:#000;font-weight:bold">],</span> x <span style="color:#000;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">new</span> ArrayList<span style="color:#000;font-weight:bold">()).</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>j<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&lt;</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> i<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>Bstarts<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">containsKey</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j<span style="color:#000;font-weight:bold">:</span> Bstarts<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> k <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">+</span>k <span style="color:#000;font-weight:bold">&lt;</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> j<span style="color:#000;font-weight:bold">+</span>k <span style="color:#000;font-weight:bold">&lt;</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">+</span>k<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> B<span style="color:#000;font-weight:bold">[</span>j<span style="color:#000;font-weight:bold">+</span>k<span style="color:#000;font-weight:bold">])</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    k<span style="color:#000;font-weight:bold">++;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#000;font-weight:bold">=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">max</span><span style="color:#000;font-weight:bold">(</span>ans<span style="color:#000;font-weight:bold">,</span> k<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M*N*\min(M, N))\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>A, B</code>. The worst case is when all the elements are equal.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the space used by <code>Bstarts</code> (Of course, we could amend our algorithm to make this <span class="math inline">\(O(\min(M, N))\)</span>).</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search-with-naive-check-time-limit-exceeded">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</h3>
<p><strong>Intuition</strong></p>
<p>If there is a length <code>k</code> subarray common to <code>A</code> and <code>B</code>, then there is a length <code>j &lt;= k</code> subarray as well.</p>
<p>Let <code>check(length)</code> be the answer to the question &quot;Is there a subarray with <code>length</code> length, common to <code>A</code> and <code>B</code>?&quot;  This is a function with a range that must take the form <code>[True, True, ..., True, False, False, ..., False]</code> with at least one <code>True</code>.  We can binary search on this function.</p>
<p><strong>Algorithm</strong></p>
<p>Focusing on the binary search, our invariant is that <code>check(hi)</code> will always be <code>False</code>. We'll start with <code>hi = min(len(A), len(B)) + 1</code>, clearly <code>check(hi) is False</code>.</p>
<p>Now we perform our check in the midpoint <code>mi</code> of <code>lo</code> and <code>hi</code>. When it is possible, then <code>lo = mi + 1</code>, and when it isn't, <code>hi = mi</code>. This maintains the invariant. At the end of our binary search, <code>hi == lo</code> and <code>lo</code> is the lowest value such that <code>check(lo) is False</code>, so we want <code>lo - 1</code>.</p>
<p>As for the check itself, we can naively check whether any <code>A[i:i+k] == B[j:j+k]</code> using set structures.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">findLength</span>(<span style="color:#999">self</span>, A, B):
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">check</span>(length):
</span></span><span style="display:flex;"><span>            seen <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">set</span>(<span style="color:#0086b3">tuple</span>(A[i:i<span style="color:#000;font-weight:bold">+</span>length]) 
</span></span><span style="display:flex;"><span>                       <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">-</span> length <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">any</span>(<span style="color:#0086b3">tuple</span>(B[j:j<span style="color:#000;font-weight:bold">+</span>length]) <span style="color:#000;font-weight:bold">in</span> seen 
</span></span><span style="display:flex;"><span>                       <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">-</span> length <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        lo, hi <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>, <span style="color:#0086b3">min</span>(<span style="color:#0086b3">len</span>(A), <span style="color:#0086b3">len</span>(B)) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> lo <span style="color:#000;font-weight:bold">&lt;</span> hi:
</span></span><span style="display:flex;"><span>            mi <span style="color:#000;font-weight:bold">=</span> (lo <span style="color:#000;font-weight:bold">+</span> hi) <span style="color:#000;font-weight:bold">//</span> <span style="color:#099">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> check(mi):
</span></span><span style="display:flex;"><span>                lo <span style="color:#000;font-weight:bold">=</span> mi <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>                hi <span style="color:#000;font-weight:bold">=</span> mi
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> lo <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">boolean</span> <span style="color:#900;font-weight:bold">check</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> length<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        Set<span style="color:#000;font-weight:bold">&lt;</span>String<span style="color:#000;font-weight:bold">&gt;</span> seen <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashSet<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">+</span> length <span style="color:#000;font-weight:bold">&lt;=</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            seen<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">toString</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">copyOfRange</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">,</span> i<span style="color:#000;font-weight:bold">,</span> i<span style="color:#000;font-weight:bold">+</span>length<span style="color:#000;font-weight:bold">)));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> j <span style="color:#000;font-weight:bold">+</span> length <span style="color:#000;font-weight:bold">&lt;=</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>j<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>seen<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">contains</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">toString</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">copyOfRange</span><span style="color:#000;font-weight:bold">(</span>B<span style="color:#000;font-weight:bold">,</span> j<span style="color:#000;font-weight:bold">,</span> j<span style="color:#000;font-weight:bold">+</span>length<span style="color:#000;font-weight:bold">))))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">findLength</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> lo <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> hi <span style="color:#000;font-weight:bold">=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">min</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">,</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span>lo <span style="color:#000;font-weight:bold">&lt;</span> hi<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> mi <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">(</span>lo <span style="color:#000;font-weight:bold">+</span> hi<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">/</span> 2<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>check<span style="color:#000;font-weight:bold">(</span>mi<span style="color:#000;font-weight:bold">,</span> A<span style="color:#000;font-weight:bold">,</span> B<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                lo <span style="color:#000;font-weight:bold">=</span> mi <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">else</span> hi <span style="color:#000;font-weight:bold">=</span> mi<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> lo <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((M + N) * \min(M, N) * \log{(\min(M, N))})\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>A, B</code>. The log factor comes from the binary search. The complexity of our naive check of a given <span class="math inline">\(\text{length}\)</span> is <span class="math inline">\(O((M+N) * \text{length})\)</span>, as we will create the <code>seen</code> strings with complexity <span class="math inline">\(O(M * \text{length})\)</span>, then search for them with complexity <span class="math inline">\(O(N * \text{length})\)</span>, and our total complexity when performing our <code>check</code> is the addition of these two.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M^2)\)</span>, the space used by <code>seen</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming-accepted">Approach #3: Dynamic Programming [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Since a common subarray of <code>A</code> and <code>B</code> must start at some <code>A[i]</code> and <code>B[j]</code>, let <code>dp[i][j]</code> be the longest common prefix of <code>A[i:]</code> and <code>B[j:]</code>. Whenever <code>A[i] == B[j]</code>, we know <code>dp[i][j] = dp[i+1][j+1] + 1</code>.  Also, the answer is <code>max(dp[i][j])</code> over all <code>i, j</code>.</p>
<p>We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in <code>dp</code> for any larger <code>i, j</code>.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">findLength</span>(<span style="color:#999">self</span>, A, B):
</span></span><span style="display:flex;"><span>        memo <span style="color:#000;font-weight:bold">=</span> [[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">*</span> (<span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">for</span> _ <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>)]
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> A[i] <span style="color:#000;font-weight:bold">==</span> B[j]:
</span></span><span style="display:flex;"><span>                    memo[i][j] <span style="color:#000;font-weight:bold">=</span> memo[i <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>][j <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">max</span>(<span style="color:#0086b3">max</span>(row) <span style="color:#000;font-weight:bold">for</span> row <span style="color:#000;font-weight:bold">in</span> memo)
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">findLength</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[][]</span> memo <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[</span>A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">][</span>B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&gt;=</span> 0<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">--</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j <span style="color:#000;font-weight:bold">=</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">;</span> j <span style="color:#000;font-weight:bold">&gt;=</span> 0<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">--</span>j<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> B<span style="color:#000;font-weight:bold">[</span>j<span style="color:#000;font-weight:bold">])</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>ans <span style="color:#000;font-weight:bold">&lt;</span> memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">])</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                        ans <span style="color:#000;font-weight:bold">=</span> memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M*N)\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>A, B</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M*N)\)</span>, the space used by <code>dp</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-binary-search-with-rolling-hash-accepted">Approach #4: Binary Search with Rolling Hash [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>As in <em>Approach #2</em>, we will binary search for the answer.  However, we will use a <em>rolling hash</em> (Rabin-Karp algorithm) to store hashes in our set structure.</p>
<p><strong>Algorithm</strong></p>
<p>For some prime <span class="math inline">\(p\)</span>, consider the following function modulo some prime modulus <span class="math inline">\(\mathcal{M}\)</span>:</p>
<p><span class="math display">\[
Notably, $$\text{hash}(S[1:] + x) = \frac{(\text{hash}(S) - S[0])}{p} + p^{n-1} x$$. This shows we can get the hash of all $$A[i:i+\text{guess}]$$ in linear time.  We will also use the fact that $$p^{-1} = p^{\mathcal{M}-2} \mod \mathcal{M}$$.

For every `i >= length - 1`, we will want to record the hash of `A[i-length+1], A[i-length+2], ..., A[i]`. After, we will truncate the first element by `h = (h - A[i - (length - 1)]) * Pinv % MOD` to get ready to add the next element.

To make our algorithm airtight, we also make a naive check when our work with rolling hashes says that we have found a match.

```python
class Solution(object):
    def findLength(self, A, B):
        P, MOD = 113, 10**9 + 7
        Pinv = pow(P, MOD - 2, MOD)
        def check(guess):
            def rolling(A, length):
                if length == 0:
                    yield 0, 0
                    return

                h, power = 0, 1
                for i, x in enumerate(A):
                    h = (h + x * power) % MOD
                    if i < length - 1:
                        power = (power * P) % MOD
                    else:
                        yield h, i - (length - 1)
                        h = (h - A[i - (length - 1)]) * Pinv % MOD

            hashes = collections.defaultdict(list)
            for ha, start in rolling(A, guess):
                hashes[ha].append(start)
            for ha, start in rolling(B, guess):
                iarr = hashes.get(ha, [])
                if any(A[i: i + guess] == B[start: start + guess] for i in iarr):
                    return True
            return False

        lo, hi = 0, min(len(A), len(B)) + 1
        while lo < hi:
            mi = (lo + hi) // 2
            if check(mi):
                lo = mi + 1
            else:
                hi = mi
        return lo - 1
```

**Java**
```java
import java.math.BigInteger;

class Solution {
    int P = 113;
    int MOD = 1_000_000_007;
    int Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();

    private int[] rolling(int[] source, int length) {
        int[] ans = new int[source.length - length + 1];
        long h = 0, power = 1;
        if (length == 0) {
            return and;
        }
        for (int i = 0; i < source.length; ++i) {
            h = (h + source[i] * power) % MOD;
            if (i < length - 1) {
                power = (power * P) % MOD;
            } else {
                ans[i - (length - 1)] = (int) h;
                h = (h - source[i - (length - 1)]) * Pinv % MOD;
                if (h < 0) h += MOD;
            }
        }
        return ans;
    }

    private boolean check(int guess, int[] A, int[] B) {
        Map<Integer, List<Integer>> hashes = new HashMap();
        int k = 0;
        for (int x: rolling(A, guess)) {
            hashes.computeIfAbsent(x, z -> new ArrayList()).add(k++);
        }
        int j = 0;
        for (int x: rolling(B, guess)) {
            for (int i: hashes.getOrDefault(x, new ArrayList<Integer>()))
                if (Arrays.equals(Arrays.copyOfRange(A, i, i+guess),
                                  Arrays.copyOfRange(B, j, j+guess))) {
                    return true;
                }
            j++;
        }
        return false;
    }

    public int findLength(int[] A, int[] B) {
        int lo = 0, hi = Math.min(A.length, B.length) + 1;
        while (lo < hi) {
            int mi = (lo + hi) / 2;
            if (check(mi, A, B)) {
                lo = mi + 1;
            }
            else hi = mi;
        }
        return lo - 1;
    }
}
```

**Complexity Analysis**

* Time Complexity: $$O((M+N) * \log{(\min(M, N))})$$, where $$M, N$$ are the lengths of `A, B`. The log factor contributed by the binary search while creating the rolling hashes is $$O(M + N)$$. The checks for duplicate hashes are $$O(1)$$. If we perform a naive check to make sure our answer is correct, it adds a factor of $$O(\min(M, N))$$ to our cost of `check`, which keeps the complexity the same.

* Space Complexity: $$O(M)$$, the space used to store `hashes` and the subarrays in our final naive check.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-alloys/description" target="_blank" rel="noopener noreferrer">Maximum Number of Alloys</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are the owner of a company that creates alloys using various types of metals. There are <code>n</code> different types of metals available, and you have access to <code>k</code> machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy.</p>

<p>For the <code>i<sup>th</sup></code> machine to create an alloy, it needs <code>composition[i][j]</code> units of metal of type <code>j</code>. Initially, you have <code>stock[i]</code> units of metal type <code>i</code>, and purchasing one unit of metal type <code>i</code> costs <code>cost[i]</code> coins.</p>

<p>Given integers <code>n</code>, <code>k</code>, <code>budget</code>, a <strong>1-indexed</strong> 2D array <code>composition</code>, and <strong>1-indexed</strong> arrays <code>stock</code> and <code>cost</code>, your goal is to <strong>maximize</strong> the number of alloys the company can create while staying within the budget of <code>budget</code> coins.</p>

<p><strong>All alloys must be created with the same machine.</strong></p>

<p>Return <em>the maximum number of alloys that the company can create</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> It is optimal to use the 1<sup>st</sup> machine to create alloys.
To create 2 alloys we need to buy the:
- 2 units of metal of the 1<sup>st</sup> type.
- 2 units of metal of the 2<sup>nd</sup> type.
- 2 units of metal of the 3<sup>rd</sup> type.
In total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is smaller than or equal to budget = 15.
Notice that we have 0 units of metal of each type and we have to buy all the required units of metal.
It can be proven that we can create at most 2 alloys.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]
<strong>Output:</strong> 5
<strong>Explanation:</strong> It is optimal to use the 2<sup>nd</sup> machine to create alloys.
To create 5 alloys we need to buy:
- 5 units of metal of the 1<sup>st</sup> type.
- 5 units of metal of the 2<sup>nd</sup> type.
- 0 units of metal of the 3<sup>rd</sup> type.
In total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is smaller than or equal to budget = 15.
It can be proven that we can create at most 5 alloys.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> It is optimal to use the 3<sup>rd</sup> machine to create alloys.
To create 2 alloys we need to buy the:
- 1 unit of metal of the 1<sup>st</sup> type.
- 1 unit of metal of the 2<sup>nd</sup> type.
In total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller than or equal to budget = 10.
It can be proven that we can create at most 2 alloys.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, k &lt;= 100</code></li>
	<li><code>0 &lt;= budget &lt;= 10<sup>8</sup></code></li>
	<li><code>composition.length == k</code></li>
	<li><code>composition[i].length == n</code></li>
	<li><code>1 &lt;= composition[i][j] &lt;= 100</code></li>
	<li><code>stock.length == cost.length == n</code></li>
	<li><code>0 &lt;= stock[i] &lt;= 10<sup>8</sup></code></li>
	<li><code>1 &lt;= cost[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/description" target="_blank" rel="noopener noreferrer">Maximum Number of Events That Can Be Attended II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <code>events</code> where <code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>, value<sub>i</sub>]</code>. The <code>i<sup>th</sup></code> event starts at <code>startDay<sub>i</sub></code><sub> </sub>and ends at <code>endDay<sub>i</sub></code>, and if you attend this event, you will receive a value of <code>value<sub>i</sub></code>. You are also given an integer <code>k</code> which represents the maximum number of events you can attend.</p>

<p>You can only attend one event at a time. If you choose to attend an event, you must attend the <strong>entire</strong> event. Note that the end day is <strong>inclusive</strong>: that is, you cannot attend two events where one of them starts and the other ends on the same day.</p>

<p>Return <em>the <strong>maximum sum</strong> of values that you can receive by attending events.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60048-pm.png" style="width: 400px; height: 103px;" /></p>

<pre>
<strong>Input:</strong> events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
<strong>Output:</strong> 7
<strong>Explanation: </strong>Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60150-pm.png" style="width: 400px; height: 103px;" /></p>

<pre>
<strong>Input:</strong> events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
<strong>Output:</strong> 10
<strong>Explanation:</strong> Choose event 2 for a total value of 10.
Notice that you cannot attend any other event as they overlap, and that you do <strong>not</strong> have to attend k events.</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60703-pm.png" style="width: 400px; height: 126px;" /></strong></p>

<pre>
<strong>Input:</strong> events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
<strong>Output:</strong> 9
<strong>Explanation:</strong> Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= events.length</code></li>
	<li><code>1 &lt;= k * events.length &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= startDay<sub>i</sub> &lt;= endDay<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= value<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We can only attend an event if the start day of it is greater than the end day of the previously attended event. This implies that we should sort events by their start time. As shown in the following figure, we sort <code>events = [[1,2,4],[3,4,3],[2,3,1],[4,6,5],[2,4,8]]</code> according to the start time of each event.</p>
<p><img src="../Figures/1751/b1.png" alt="img" /></p>
<p>All subsequent solutions are based on the sorted <code>events</code>.</p>
<hr />
<h3 id="approach-1-top-down-dynamic-programming--binary-search">Approach 1: Top-down Dynamic Programming + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with dynamic programming, please refer to our explore cards <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>Let <code>dfs(cur_index)</code> represent the maximum value obtained by attending events optimally in the range <code>events[cur_index ~ n - 1]</code></p>
<p>For event <code>cur_index</code>, we have two options:</p>
<ul>
<li>
<p>attend the current event and gain a value of <code>events[cur_index][2]</code>. Then we need to find the nearest event that we can attend after event <code>cur_index</code>. Recall that we have sorted <code>events</code> by start time. We can apply binary search to find the index where we should insert the end time of the current event <code>cur_index</code> in the sorted list of start times. Let's say the nearest one is event <code>next_index</code>. Thus <code>dfs(cur_index)</code> is the larger value between the two options:</p>
</li>
<li>
<p>attend the current event and obtain a value of <code>events[cur_index][2] + dfs(next_index)</code>.</p>
</li>
<li>
<p>skip the current event, move on to the next event, and gain a value of <code>dfs(cur_index + 1)</code>.</p>
</li>
</ul>
<p>which is denoted as <code>dfs(cur_index) = max(dfs(cur_index + 1), dfs(next_index) + events[cur_index][2])</code>.</p>
<br>
<p>As shown in the picture below, we find the insertion index is <code>3</code>, which indicates that the nearest available event after event 0 is event 3.</p>
<p><img src="../Figures/1751/b2.png" alt="img" /></p>
<p>Therefore, we can update <code>dfs(0)</code> as the larger value obtained by attending or skipping event 0.</p>
<ul>
<li>attend event 0 and get a value of <code>events[0][2] + dfs(3)</code>.</li>
<li>skip event 0 and get a value of <code>dfs(1)</code>.</li>
</ul>
<p><img src="../Figures/1751/b3.png" alt="img" /></p>
<p>Given the restriction that we can attend a maximum of <code>k</code> events, we also need to keep track of <code>count</code>, the number of events we have attended so far. Therefore, we will redefine this function as <code>dfs(cur_index, count)</code>.</p>
<p>Additionally, we use memoization to store the maximum value obtained by each state <code>(cur_index, count)</code>. This helps us avoid re-solving the same subproblems multiple times and significantly reduces the time complexity of the algorithm.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Sort <code>events</code> by start time.</p>
</li>
<li>
<p>Build a 2D array <code>dp</code> of size <span class="math inline">\((k + 1) \times n\)</span> as memory.</p>
</li>
<li>
<p>Define <code>dfs(cur_index, count)</code> as the maximum value obtained by attending a maximum of <code>count</code> events in the range <code>events[cur_index ~ n - 1]</code>.</p>
<ul>
<li>
<p>If <code>(count, cur_index)</code> is already stored in <code>dp</code>, return <code>dp[count][cur_index]</code>.</p>
</li>
<li>
<p>Return 0 if <code>count = 0</code> or <code>cur_index = n</code>.</p>
</li>
<li>
<p>Skip this event and get the value of <code>dfs(cur_index + 1, count)</code>.</p>
</li>
<li>
<p>Find the index of the nearest available event <code>next_index</code> after the current event <code>cur_index</code> with binary search.</p>
</li>
<li>
<p>Attend this event and get the value of <code>dfs(next_index, count - 1)</code> plus the value of this event <code>events[cur_index][2]</code>.</p>
</li>
<li>
<p>Store the larger one of the two values above in <code>dp[count][cur_index]</code> and return <code>dp[count][cur_index]</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>dfs(0, k)</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4j5UJQEv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot k \cdot\log n)\)</span></p>
<ul>
<li>Sorting <code>events</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>We build <code>dp</code>, a 2D array of size <span class="math inline">\(O(n \times k)\)</span> as memory, equal to the number of possible states. Each state is computed with a binary search over all start times, which takes <span class="math inline">\(O(\log n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot k)\)</span></p>
<ul>
<li>We build a 2D array of size <span class="math inline">\(O(n \times k)\)</span> as memory.</li>
<li>In the Python solution, we also create an array with length <code>n</code>, which takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The space complexity of a recursive call depends on the maximum depth of the recursive call stack, which is <span class="math inline">\(n + k\)</span>. As each recursive call either increments <code>cur_index</code> by 1 and/or decrements <code>count</code> by 1. Therefore, at most <span class="math inline">\(O(n + k)\)</span> levels of recursion will be created, and each level consumes a constant amount of space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-bottom-up-dynamic-programming--binary-search">Approach 2: Bottom-up Dynamic Programming + Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we start with the original problem <code>dfs(0, k)</code> and recursively break it down into smaller subproblems. We can also use bottom-up DP that starts with the smallest subproblems and works its way up to the original problem.</p>
<p>We can build a 2D array <code>dp</code> and let <code>dp[count][cur_index]</code> represent the maximum value we obtain by attending at most <code>count</code> events in the range <code>events[cur_index ~ n - 1]</code> (equivalent to <code>dfs(cur_index, count)</code> in the previous approach). We first solve the smallest subproblems, then use their solutions to solve slightly larger subproblems, and so on until we solve the original problem <code>dp[0][k]</code>.</p>
<p>For the current state <code>dp[count][cur_index]</code>, we have two options:</p>
<ul>
<li>
<p>attend event <code>cur_index</code> and gain a value of <code>events[cur_index][2]</code>. Then we need to find the nearest events that we can attend after this event. Recall that we have sorted <code>events</code> according to the start times, so we can apply a binary search to find <code>next_index</code>, the inserting index of <code>events[cur_index][1]</code>, the end time of this event, on the sorted start times. Thus the value we obtain is <code>events[cur_index][2] + dp[count - 1][next_index]</code>.</p>
</li>
<li>
<p>skip the event <code>cur_index</code> and move on to the next event, thus the value is equal to <code>dp[count][cur_index + 1]</code>.</p>
</li>
</ul>
<p>Therefore, we have the recurrence relation as <code>dp[count][cur_index] = max(dp[count][cur_index + 1], dp[count - 1][next_index] + events[cur_index][2])</code>.</p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Sort <code>events</code> by start time.</p>
</li>
<li>
<p>Define a dynamic programming table <code>dp</code> of size <span class="math inline">\((k + 1) \cdot (n + 1)\)</span>.</p>
</li>
<li>
<p>Iterate starting from the base cases. Iterate over <code>events</code> backward from <code>n - 1</code> to <code>0</code>. For each event, iterate over the number of events that can be attended from <code>1</code> to <code>k</code>.</p>
</li>
<li>
<p>Locate <code>nextIndex</code>, the index of the first event whose starting time is greater than the end time of the current event <code>curIndex</code> using binary search.</p>
</li>
<li>
<p>Update <code>dp[count][curIndex]</code> as <code>max(dp[count][curIndex + 1], dp[count + 1][nextIndex] + events[curIndex][2])</code>.</p>
</li>
<li>
<p>Return <code>dp[k][0]</code> when the iteration is complete.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/i8tmNFhq/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot k \cdot\log n)\)</span></p>
<ul>
<li>Sorting <code>events</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>We build a 2D array of size <span class="math inline">\(O(n \times k)\)</span> as memory, equal to the number of possible states. Each state is computed with a binary search over all start times, which takes <span class="math inline">\(O(\log n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot k)\)</span></p>
<ul>
<li><code>dp</code> takes <span class="math inline">\(O(n \times k)\)</span> space.</li>
<li>In the Python solution, we create a array <code>starts</code> with length <code>n</code> which takes <span class="math inline">\(O(n)\)</span> space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-top-down-dynamic-programming--cached-binary-search">Approach 3: Top-down Dynamic Programming + Cached Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approaches, we perform the binary search in each of the <span class="math inline">\(O(n \cdot k)\)</span> states.</p>
<p>However, we observed that the same binary search was being repeated. In fact, there are at most <code>n</code> different results. Therefore, we can precompute the results of all possible binary searches of <code>events[cur_index][0]</code> over the array of start times <code>starts</code>, and store the results in an array called <code>next_indices</code>. As shown in the figure below:.</p>
<p><img src="../Figures/1751/b4.png" alt="img" /></p>
<p>In the following recursion, we can obtain the insertion index of <code>events[cur_index][1]</code> as <code>next_indices[cur_index]</code>.</p>
<br>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Sort <code>events</code> by start time.</p>
</li>
<li>
<p>Build a 2D array <code>dp</code> of size <span class="math inline">\((k + 1) \times n\)</span> as memory.</p>
</li>
<li>
<p>Create an array <code>next_indices</code> to collect the nearest available event <code>nextIndex</code> for every event <code>curIndex</code>.</p>
</li>
<li>
<p>Define <code>dfs(cur_index, count)</code> as the maximum value obtained by attending a maximum of <code>count</code> events in the range <code>events[cur_index ~ n - 1]</code>.</p>
<ul>
<li>
<p>If <code>(count, cur_index)</code> is already stored in <code>dp</code>, return <code>dp[count][cur_index]</code>.</p>
</li>
<li>
<p>Return 0 if <code>count = 0</code> or <code>cur_index = n</code>.</p>
</li>
<li>
<p>Skip this event and get the value of <code>dfs(cur_index + 1, count)</code>.</p>
</li>
<li>
<p>Get the index of the nearest available event <code>next_index</code> after the current event <code>cur_index</code> as <code>next_indices[cur_index]</code>.</p>
</li>
<li>
<p>Attend this event and get the value of <code>dfs(next_index, count - 1)</code> plus the value of this event <code>events[cur_index][2]</code>.</p>
</li>
<li>
<p>Assign the larger value between the two options mentioned above <code>dp[count][cur_index]</code> and return <code>dp[count][cur_index]</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>dfs(0, k)</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/miFTMHR3/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>events</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot (k + \log n))\)</span></p>
<ul>
<li>Sorting <code>events</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>We build a 2D array of size <span class="math inline">\(O(n \times k)\)</span> as memory. Each value is computed in <span class="math inline">\(O(1)\)</span> time.</li>
<li>The pre-computed table <code>next_indices</code> requires <span class="math inline">\(n\)</span> binary search over the start time in <code>events</code>, each binary search takes <span class="math inline">\(O(\log n)\)</span> time. Therefore the total time it requires is <span class="math inline">\(O(n \cdot\log n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot k)\)</span></p>
<ul>
<li><code>dp</code> takes <span class="math inline">\(O(n \times k)\)</span> space.</li>
<li><code>next_indices</code> takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>In the Python solution, we create an array with length <code>n</code> which takes <span class="math inline">\(O(n)\)</span> space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-4-bottom-up-dynamic-programming--optimized-binary-search">Approach 4: Bottom-up Dynamic Programming + Optimized Binary Search</h3>
<h4 id="intuition-3">Intuition</h4>
<p>We can also minimize the number of binary searches in approach 2. As all the binary searches in the inner loop search for the same insertion index of event <code>cur_index</code>, we can perform this binary search beforehand, before executing the inner loop.</p>
<br>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Sort <code>events</code> by their start time.</p>
</li>
<li>
<p>Define a dynamic programming table <code>dp</code> of size <span class="math inline">\((k + 1) \cdot (n + 1)\)</span>.</p>
</li>
<li>
<p>Iterate from the base cases. Iterate over <code>events</code> backward from <code>n - 1</code> to <code>0</code>. For each event, find <code>next_index</code>, the index of the nearest event whose start time is greater the end time of the current event <code>cur_index</code> using binary search.</p>
</li>
<li>
<p>Iterate over the number of events that can be attended from <code>1</code> to <code>k</code>.</p>
</li>
<li>
<p>Update <code>dp[count][cur_index]</code> as <code>max(dp[count][cur_index + 1], dp[count + 1][next_index] + events[cur_index][2])</code>.</p>
</li>
<li>
<p>Return <code>dp[k][0]</code> when the iteration is complete.</p>
</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/UdWh3htP/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>events</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot (k + \log n))\)</span></p>
<ul>
<li>Sorting <code>events</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>The nested iterations takes <span class="math inline">\(n \cdot k\)</span> steps, each step requires <span class="math inline">\(O(1)\)</span> time.</li>
<li>Instead of applying binary search in each step, we only have <span class="math inline">\(n\)</span> binary searches, which take <span class="math inline">\(n \cdot\log n\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot k)\)</span></p>
<ul>
<li><code>dp</code> takes <span class="math inline">\(O(n \times k)\)</span> space.</li>
<li>In the Python solution, we create a array <code>starts</code> with length <code>n</code>, which takes <span class="math inline">\(O(n)\)</span> space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-5-top-down-dynamic-programming-without-binary-search-time-limit-exceed">Approach 5: Top-down Dynamic Programming Without Binary Search (Time Limit Exceed)</h3>
<h4 id="intuition-4">Intuition</h4>
<p>The reason for using binary search in previous approaches, such as approach 1, is to ensure that the current <code>dfs(cur_index, count)</code> is always valid by finding the nearest event <code>next_index</code> and ensuring that the start time of this following event is strictly greater than the end time of the current event. This is done by finding the insertion position of <code>events[cur_index][1]</code> using binary search. We could avoid using binary search, but we would need to modify the function.</p>
<p>Let's start with the original <code>dfs(cur_index = 0, count = 0)</code>, as shown in the figure, we have two options for event 0:</p>
<ul>
<li>attend it and gain a value of <code>events[0][2]</code>. As we are not using binary search to locate the nearest available event, we would attempt attending the next event and gain a value of <code>dfs(1, 1)</code>. Therefore, the total value gained would be <code>events[0][2] + dfs(1, 1)</code>.</li>
<li>skip it and gain a value of <code>dfs(1, 0)</code></li>
</ul>
<p><img src="../Figures/1751/1.png" alt="img" /></p>
<p>However, <code>dfs(0, 0) = max(events[0][2] + dfs(1, 1), dfs(1, 0))</code> creates a problem, as we mentioned earlier: the start time of event 1 is not greater than the end time of event 0, so we cannot attend event 1 after attending event 0. However, the algorithm does not verify this condition and will continue to recursively calculate <code>dfs(1, 1)</code>, <code>dfs(2, 2)</code>, and so on, leading to incorrect answers.</p>
<p><img src="../Figures/1751/2.png" alt="img" /></p>
<p>Therefore, we need to modify the <code>dfs(cur_index, count)</code> function by adding an extra parameter called <code>prev_ending_time</code>, which represents the end time of the previous event we attended.</p>
<p><img src="../Figures/1751/3.png" alt="img" /></p>
<p>With the added parameter <code>prev_ending_time</code>, the function <code>dfs(cur_index = 1, count, prev_ending_time = 2)</code> ensures that we only consider valid events that can be attended after the previous event ends. This is accomplished by checking if <code>prev_ending_time</code> is smaller than the start time of the next event. If it is not, we skip the calculation of <code>dfs(cur_index + 1, count + 1, events[cur_index][1])</code> and only consider the option of skipping the current event.</p>
<p><img src="../Figures/1751/4.png" alt="img" /></p>
<blockquote>
<p>Let's define the complete function <code>dfs(cur_index, count, prev_ending_time)</code> as the maximum value obtained by attending a maximum of <code>count</code> events in the range <code>events[cur_index ~ n - 1]</code>, where the previously attended event ends at <code>prev_ending_time</code>.</p>
</blockquote>
<p>Additionally, We use memoization to store the maximum value obtained by each state <code>(cur_index, count)</code> to avoid re-solving the same subproblems multiple times, which significantly reduces the time complexity.</p>
<p><img src="../Figures/1751/5.png" alt="img" /></p>
<br>
<h4 id="algorithm-4">Algorithm</h4>
<ol>
<li>
<p>Sort <code>events</code> by the start time.</p>
</li>
<li>
<p>Build a 2D array <code>dp</code> of size <span class="math inline">\((k + 1) \times n\)</span> as memory.</p>
</li>
<li>
<p>Define <code>dfs(cur_index, count, prev_ending_time)</code> as the maximum value obtained by attending <code>count</code> events in the range <code>events[cur_index ~ n - 1]</code>, if the previous attending meeting ends at <code>prev_ending_time</code>.</p>
<ul>
<li>Return 0 if <code>count = 0</code> or <code>cur_index = n</code>.</li>
<li>If <code>events[cur_index][0] &lt;= pre_ending_time</code>, we must skip this event and get a value of <code>dfs(cur_index + 1, count, prev_ending_time)</code>.</li>
<li>If <code>(count, cur_index)</code> is already stored in <code>dp</code>, return <code>dp[count][cur_index]</code>.</li>
<li>Otherwise, we can also attend this event and get a value of <code>dfs(cur_index + 1, count - 1, events[cur_index][2])</code> plus a value of this event <code>events[cur_index][2]</code>.</li>
<li>Assign the larger value between the two options mentioned above to <code>dp[count][cur_index]</code> and return <code>dp[count][cur_index]</code>.</li>
</ul>
</li>
<li>
<p>Return <code>dfs(0, k, -1)</code>.</p>
</li>
</ol>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/ieNUNXmb/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>events</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot (n\cdot k + \log n))\)</span></p>
<ul>
<li>Sorting the array <code>events</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>We build a 2D array <code>dp</code> of size <span class="math inline">\(O(n \times k)\)</span> as memory. The extra parameter <code>prev_ending_time</code> creates many more states, the value of each state in the <code>dp</code> array is computed once but is visited at most <span class="math inline">\(O(n)\)</span> times.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot k)\)</span></p>
<ul>
<li><code>dp</code> takes <span class="math inline">\(O(n \times k)\)</span> space.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-groups-entering-a-competition/description" target="_blank" rel="noopener noreferrer">Maximum Number of Groups Entering a Competition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer array <code>grades</code> which represents the grades of students in a university. You would like to enter <strong>all</strong> these students into a competition in <strong>ordered</strong> non-empty groups, such that the ordering meets the following conditions:</p>

<ul>
	<li>The sum of the grades of students in the <code>i<sup>th</sup></code> group is <strong>less than</strong> the sum of the grades of students in the <code>(i + 1)<sup>th</sup></code> group, for all groups (except the last).</li>
	<li>The total number of students in the <code>i<sup>th</sup></code> group is <strong>less than</strong> the total number of students in the <code>(i + 1)<sup>th</sup></code> group, for all groups (except the last).</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of groups that can be formed</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grades = [10,6,12,7,3,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The following is a possible way to form 3 groups of students:
- 1<sup>st</sup> group has the students with grades = [12]. Sum of grades: 12. Student count: 1
- 2<sup>nd</sup> group has the students with grades = [6,7]. Sum of grades: 6 + 7 = 13. Student count: 2
- 3<sup>rd</sup> group has the students with grades = [10,3,5]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3
It can be shown that it is not possible to form more than 3 groups.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grades = [8,8]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grades.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grades[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-groups-with-increasing-length/description" target="_blank" rel="noopener noreferrer">Maximum Number of Groups With Increasing Length</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>usageLimits</code> of length <code>n</code>.</p>

<p>Your task is to create <strong>groups</strong> using numbers from <code>0</code> to <code>n - 1</code>, ensuring that each number, <code>i</code>, is used no more than <code>usageLimits[i]</code> times in total <strong>across all groups</strong>. You must also satisfy the following conditions:</p>

<ul>
	<li>Each group must consist of <strong>distinct </strong>numbers, meaning that no duplicate numbers are allowed within a single group.</li>
	<li>Each group (except the first one) must have a length <strong>strictly greater</strong> than the previous group.</li>
</ul>

<p>Return <em>an integer denoting the <strong>maximum</strong> number of groups you can create while satisfying these conditions.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> <code>usageLimits</code> = [1,2,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we can use 0 at most once, 1 at most twice, and 2 at most five times.
One way of creating the maximum number of groups while satisfying the conditions is: 
Group 1 contains the number [2].
Group 2 contains the numbers [1,2].
Group 3 contains the numbers [0,1,2]. 
It can be shown that the maximum number of groups is 3. 
So, the output is 3. </pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> <code>usageLimits</code> = [2,1,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, we can use 0 at most twice, 1 at most once, and 2 at most twice.
One way of creating the maximum number of groups while satisfying the conditions is:
Group 1 contains the number [0].
Group 2 contains the numbers [1,2].
It can be shown that the maximum number of groups is 2.
So, the output is 2. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> <code>usageLimits</code> = [1,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, we can use both 0 and 1 at most once.
One way of creating the maximum number of groups while satisfying the conditions is:
Group 1 contains the number [0].
It can be shown that the maximum number of groups is 1.
So, the output is 1. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= usageLimits.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= usageLimits[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/description" target="_blank" rel="noopener noreferrer">Maximum Number of Integers to Choose From a Range I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>banned</code> and two integers <code>n</code> and <code>maxSum</code>. You are choosing some number of integers following the below rules:</p>

<ul>
	<li>The chosen integers have to be in the range <code>[1, n]</code>.</li>
	<li>Each integer can be chosen <strong>at most once</strong>.</li>
	<li>The chosen integers should not be in the array <code>banned</code>.</li>
	<li>The sum of the chosen integers should not exceed <code>maxSum</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of integers you can choose following the mentioned rules</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> banned = [1,6,5], n = 5, maxSum = 6
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can choose the integers 2 and 4.
2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> You cannot choose any integer while following the mentioned conditions.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> banned = [11], n = 7, maxSum = 50
<strong>Output:</strong> 7
<strong>Explanation:</strong> You can choose the integers 1, 2, 3, 4, 5, 6, and 7.
They are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= banned.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= banned[i], n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= maxSum &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our goal is to select the largest possible set of positive integers whose sum doesn't exceed <code>maxSum</code>. The selection must follow these constraints: we cannot use any numbers present in the <code>banned</code> array, each number in the selection must be unique, and we can only choose numbers between <code>1</code> and <code>n</code>.</p>
<p>Let's look at an example to understand this better. Say we have:</p>
<ul>
<li><code>n = 10</code></li>
<li><code>maxSum = 16</code></li>
<li>banned: <code>[1, 2, 3, 6, 10]</code></li>
</ul>
<p>Some valid answers would be:</p>
<ol>
<li>4, 8</li>
<li>4, 5, 7</li>
<li>9</li>
</ol>
<p>All of these options have integers less than <code>n</code> and avoid numbers that are part of the <code>banned</code> array. Among these, we get the maximum number of integers with the set <code>(4, 5, 7)</code>. No matter what other combinations we try, we cannot select more than 3 numbers that satisfy all our conditions. So, our answer is 3.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Say we have a budget of <code>maxSum</code> and we want to buy as many items as possible from a list of numbers ranging from <code>1</code> to <code>n</code>. However, some items on this list are banned and can't be purchased. How do we maximize the number of items we can buy without exceeding our budget?</p>
<p>A straightforward approach would be to start with the smallest numbers first. By starting with the smallest numbers, we are ensuring that we are fitting as many items as possible into the budget. If we were to start with larger numbers, we would quickly exhaust our budget and be able to purchase fewer items. Starting with the smallest numbers maximizes the number of items we can include before reaching our budget limit.</p>
<p>To implement this, we would check each number from <code>1</code> to <code>n</code> in order and add it to our shopping list if it's not banned. For each number, we would need to scan through the <code>banned</code> array to verify if it's available. However, this method is slow because we have to check the entire <code>banned</code> array for each number we consider.</p>
<p>The most time-consuming part of this algorithm is the repeated checking of the <code>banned</code> array. To make this process faster, we need a more efficient search method. One such method is <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary search 🔗</a>.</p>
<p>Before we can use binary search, we need to sort the <code>banned</code> array. Then, for each number, we perform a binary search: we initialize two pointers, <code>left</code> and <code>right</code>, to the start and end of the <code>banned</code> array, respectively. We repeatedly calculate the midpoint <code>mid</code> and compare the number with the midpoint value. If the number is found (equal to the midpoint value), it is banned and we skip it. If the number is less than the midpoint value, we move the <code>right</code> pointer to <code>mid - 1</code>; if greater, we move the <code>left</code> pointer to <code>mid + 1</code>.</p>
<p>This process continues until <code>left</code> exceeds <code>right</code>, indicating the number is not banned. If not banned, we subtract the number from <code>maxSum</code> and count it as included. If subtracting a number causes <code>maxSum</code> to drop to <code>0</code> or below, we return the count of included numbers as our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<blockquote>
<p>Note: Most programming languages already have binary search built into their standard libraries, which you can easily use. However, we've written our own binary search method here for the sake of clarity and completeness.</p>
</blockquote>
<ul>
<li>Sort the <code>banned</code> array in ascending order to enable binary search on it.</li>
<li>Initialize a variable <code>count</code> to <code>0</code> to keep track of how many numbers we select.</li>
<li>Iterate through each number from <code>1</code> to <code>n</code>:
<ul>
<li>For each number, check if it exists in <code>banned</code> using binary search.</li>
<li>If the number exists, skip to the next iteration.</li>
<li>If the number is not banned, subtract it from <code>maxSum</code>.</li>
<li>If <code>maxSum</code> becomes negative, break the loop as we cannot add more numbers.</li>
<li>If <code>maxSum</code> is still non-negative, increment <code>count</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return the final <code>count</code> as our answer.</li>
</ul>
<p>Helper method <code>customBinarySearch(arr, target)</code>:</p>
<ul>
<li>Initialize two pointers <code>left</code> and <code>right</code> pointing to the start and end of <code>arr</code> respectively.</li>
<li>While the <code>left</code> pointer is less than or equal to the <code>right</code> pointer:
<ul>
<li>Calculate <code>mid</code> as the midpoint between <code>left</code> and <code>right</code>.</li>
<li>If <code>mid</code> equals target, return <code>true</code>.</li>
<li>If <code>mid</code> is greater than <code>target</code>, move <code>right</code> to <code>mid - 1</code>.</li>
<li>If <code>mid</code> is less than <code>target</code>, move <code>left</code> to <code>mid + 1</code>.</li>
</ul>
</li>
<li>If the loop completes without finding <code>target</code>, return <code>false</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/W5FuaE98/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of the <code>banned</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m + n) \cdot \log m)\)</span></p>
<p>The algorithm iterates through numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>, and for each number, performs a binary search on the <code>banned</code> array. The binary search takes <span class="math inline">\(O(\log m)\)</span> time, and we do this <span class="math inline">\(n\)</span> times. The initial sorting of <code>banned</code> takes <span class="math inline">\(O(m \cdot \log m)\)</span> time.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n \cdot \log m) + O(m \cdot \log m) = O((m + n) \cdot \log m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(S)\)</span></p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log m)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log m)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(m)\)</span>.</li>
</ul>
<p>The few other variables used only take constant space. Thus, the space complexity is <span class="math inline">\(O(S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sweep">Approach 2: Sweep</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To optimize our solution, we can use the relationship between the numbers being checked and the <code>banned</code> array. Since we iterate through numbers from <code>1</code> to <code>n</code> in ascending order and the <code>banned</code> array is also sorted, we can take advantage of this ordering to streamline the process.</p>
<p>As we iterate through the numbers from <code>1</code> to <code>n</code>, we can maintain a pointer (let's call it <code>bannedIdx</code>) that tracks our current position in the <code>banned</code> array. This pointer allows us to efficiently determine whether the current number is banned by comparing it with the next unprocessed banned number, rather than scanning the entire <code>banned</code> array for each number.</p>
<p>Similar to the previous approach, we'll loop from <code>1</code> to <code>n</code> and progressively add integers to our series. For each number, we first check if it is banned by comparing it with the value at the current <code>bannedIdx</code>. If it is banned, we move to the next integer and also advance <code>bannedIdx</code> to the next value in <code>banned</code>. Otherwise, we subtract the current value from <code>maxSum</code> and increment our counter. If this reduction causes <code>maxSum</code> to drop below or equal to <code>0</code>, we have found the maximum number of integers, and we return the current count as our answer.</p>
<p>The slideshow below visualizes the algorithm:</p>
<p>!?!../Documents/2554/slideshow.json:702,642!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Sort the <code>banned</code> array in ascending order.</li>
<li>Initialize:
<ul>
<li><code>bannedIdx</code> to <code>0</code> to track the current position in the <code>banned</code> array.</li>
<li><code>count</code> to <code>0</code> to track the number of valid integers chosen.</li>
</ul>
</li>
<li>Iterate through each number from <code>1</code> to <code>n</code> while <code>maxSum</code> remains non-negative:
<ul>
<li>For each number, check if it matches the current banned number (using <code>bannedIdx</code>).
<ul>
<li>If the current number is banned:
<ul>
<li>Skip all duplicate occurrences of this banned number by incrementing <code>bannedIdx</code>.</li>
</ul>
</li>
<li>If the current number is not banned:
<ul>
<li>Subtract the current number from <code>maxSum</code>.</li>
</ul>
</li>
<li>If <code>maxSum</code> remains non-negative:
<ul>
<li>Increment <code>count</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the final <code>count</code> as the answer.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/aVxc8Mxh/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of the <code>banned</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \cdot \log m)\)</span></p>
<p>The algorithm first sorts the <code>banned</code> array which takes <span class="math inline">\(O(m \cdot \log m)\)</span> time. Then it performs a single pass through numbers <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> and skips over banned numbers. Since each banned number is processed at most once and we only move forward in both sequences, the iteration part takes <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The total time complexity is therefore <span class="math inline">\(O(m \cdot \log m + n + m)\)</span> which simplifies to <span class="math inline">\(O(n + m \cdot \log m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(S)\)</span></p>
<p>The space complexity of the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log m)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log m)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(m)\)</span>.</li>
</ul>
<p>The few other variables used by the algorithm take constant space. Thus, the space complexity is <span class="math inline">\(O(S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-hash-set">Approach 3: Hash Set</h3>
<h4 id="intuition-2">Intuition</h4>
<p>At each step of the loop, we are essentially checking whether a number exists in the <code>banned</code> array or not. A suitable data structure for efficiently performing the &quot;find&quot; operation is a hash set. Hash sets allow us to determine whether a number is in the collection in constant time.</p>
<p>First, we populate a hash set called <code>bannedSet</code> with the elements from the <code>banned</code> array. Then, we iterate from <code>1</code> to <code>n</code>. For each number, we check if it is present in <code>bannedSet</code>. If it is, we skip that number. Otherwise, we add the number to our series and update <code>maxSum</code> and our counter accordingly. If <code>maxSum</code> ever drops below <code>0</code>, we return the current count as the answer.</p>
<blockquote>
<p>For a more comprehensive understanding of hash set, explore the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Set Explore Card 🔗</a>. This resource provides an in-depth look at hash sets, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Create an empty hash set <code>bannedSet</code> to store banned numbers.</li>
<li>Iterate through the <code>banned</code> array, adding each number to <code>bannedSet</code>.</li>
<li>Initialize a variable <code>count</code> to <code>0</code> to track the number of valid integers chosen.</li>
<li>Iterate through each number from <code>1</code> to <code>n</code>:
<ul>
<li>Check if the current number is in <code>bannedSet</code>.</li>
<li>If it is, skip to the next iteration.</li>
<li>If subtracting the current number from <code>maxSum</code> would make it negative:
<ul>
<li>Return the current <code>count</code> immediately.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Subtract the current number from <code>maxSum</code>.</li>
<li>Increment <code>count</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final <code>count</code> as the answer.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/m7jZtYFf/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of the <code>banned</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm makes a single pass through the <code>banned</code> array to populate the hash set, taking <span class="math inline">\(O(m)\)</span> time. Then it iterates through numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>, where for each number, we perform a constant time <span class="math inline">\(O(1)\)</span> lookup in the hash set. Therefore, the iteration takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m) + O(n) = O(m + n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The algorithm uses a hash set to store all banned numbers. In the worst case, all numbers in the <code>banned</code> array are unique and within the valid range, requiring <span class="math inline">\(O(m)\)</span> space. Besides the hash set, only a constant amount of extra space is used for variables like <code>count</code> and <code>maxSum</code>.</p>
<p>Thus, the total space complexity is <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-removable-characters/description" target="_blank" rel="noopener noreferrer">Maximum Number of Removable Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>p</code> where <code>p</code> is a <strong>subsequence </strong>of <code>s</code>. You are also given a <strong>distinct 0-indexed </strong>integer array <code>removable</code> containing a subset of indices of <code>s</code> (<code>s</code> is also <strong>0-indexed</strong>).</p>

<p>You want to choose an integer <code>k</code> (<code>0 &lt;= k &lt;= removable.length</code>) such that, after removing <code>k</code> characters from <code>s</code> using the <strong>first</strong> <code>k</code> indices in <code>removable</code>, <code>p</code> is still a <strong>subsequence</strong> of <code>s</code>. More formally, you will mark the character at <code>s[removable[i]]</code> for each <code>0 &lt;= i &lt; k</code>, then remove all marked characters and check if <code>p</code> is still a subsequence.</p>

<p>Return <em>the <strong>maximum</strong> </em><code>k</code><em> you can choose such that </em><code>p</code><em> is still a <strong>subsequence</strong> of </em><code>s</code><em> after the removals</em>.</p>

<p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcacb&quot;, p = &quot;ab&quot;, removable = [3,1,0]
<strong>Output:</strong> 2
<strong>Explanation</strong>: After removing the characters at indices 3 and 1, &quot;a<s><strong>b</strong></s>c<s><strong>a</strong></s>cb&quot; becomes &quot;accb&quot;.
&quot;ab&quot; is a subsequence of &quot;<strong><u>a</u></strong>cc<strong><u>b</u></strong>&quot;.
If we remove the characters at indices 3, 1, and 0, &quot;<s><strong>ab</strong></s>c<s><strong>a</strong></s>cb&quot; becomes &quot;ccb&quot;, and &quot;ab&quot; is no longer a subsequence.
Hence, the maximum k is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcbddddd&quot;, p = &quot;abcd&quot;, removable = [3,2,1,4,5,6]
<strong>Output:</strong> 1
<strong>Explanation</strong>: After removing the character at index 3, &quot;abc<s><strong>b</strong></s>ddddd&quot; becomes &quot;abcddddd&quot;.
&quot;abcd&quot; is a subsequence of &quot;<u><strong>abcd</strong></u>dddd&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcab&quot;, p = &quot;abc&quot;, removable = [0,1,2,3,4]
<strong>Output:</strong> 0
<strong>Explanation</strong>: If you remove the first index in the array removable, &quot;abc&quot; is no longer a subsequence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= p.length &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= removable.length &lt; s.length</code></li>
	<li><code>0 &lt;= removable[i] &lt; s.length</code></li>
	<li><code>p</code> is a <strong>subsequence</strong> of <code>s</code>.</li>
	<li><code>s</code> and <code>p</code> both consist of lowercase English letters.</li>
	<li>The elements in <code>removable</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-robots-within-budget/description" target="_blank" rel="noopener noreferrer">Maximum Number of Robots Within Budget</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> robots. You are given two <strong>0-indexed</strong> integer arrays, <code>chargeTimes</code> and <code>runningCosts</code>, both of length <code>n</code>. The <code>i<sup>th</sup></code> robot costs <code>chargeTimes[i]</code> units to charge and costs <code>runningCosts[i]</code> units to run. You are also given an integer <code>budget</code>.</p>

<p>The <strong>total cost</strong> of running <code>k</code> chosen robots is equal to <code>max(chargeTimes) + k * sum(runningCosts)</code>, where <code>max(chargeTimes)</code> is the largest charge cost among the <code>k</code> robots and <code>sum(runningCosts)</code> is the sum of running costs among the <code>k</code> robots.</p>

<p>Return<em> the <strong>maximum</strong> number of <strong>consecutive</strong> robots you can run such that the total cost <strong>does not</strong> exceed </em><code>budget</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
It is possible to run all individual and consecutive pairs of robots within budget.
To obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25.
It can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19
<strong>Output:</strong> 0
<strong>Explanation:</strong> No robot can be run that does not exceed the budget, so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>chargeTimes.length == runningCosts.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= budget &lt;= 10<sup>15</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description" target="_blank" rel="noopener noreferrer">Maximum Number of Tasks You Can Assign</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">queue</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> tasks and <code>m</code> workers. Each task has a strength requirement stored in a <strong>0-indexed</strong> integer array <code>tasks</code>, with the <code>i<sup>th</sup></code> task requiring <code>tasks[i]</code> strength to complete. The strength of each worker is stored in a <strong>0-indexed</strong> integer array <code>workers</code>, with the <code>j<sup>th</sup></code> worker having <code>workers[j]</code> strength. Each worker can only be assigned to a <strong>single</strong> task and must have a strength <strong>greater than or equal</strong> to the task&#39;s strength requirement (i.e., <code>workers[j] &gt;= tasks[i]</code>).</p>

<p>Additionally, you have <code>pills</code> magical pills that will <strong>increase a worker&#39;s strength</strong> by <code>strength</code>. You can decide which workers receive the magical pills, however, you may only give each worker <strong>at most one</strong> magical pill.</p>

<p>Given the <strong>0-indexed </strong>integer arrays <code>tasks</code> and <code>workers</code> and the integers <code>pills</code> and <code>strength</code>, return <em>the <strong>maximum</strong> number of tasks that can be completed.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [<u><strong>3</strong></u>,<u><strong>2</strong></u>,<u><strong>1</strong></u>], workers = [<u><strong>0</strong></u>,<u><strong>3</strong></u>,<u><strong>3</strong></u>], pills = 1, strength = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong>
We can assign the magical pill and tasks as follows:
- Give the magical pill to worker 0.
- Assign worker 0 to task 2 (0 + 1 &gt;= 1)
- Assign worker 1 to task 1 (3 &gt;= 2)
- Assign worker 2 to task 0 (3 &gt;= 3)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [<u><strong>5</strong></u>,4], workers = [<u><strong>0</strong></u>,0,0], pills = 1, strength = 5
<strong>Output:</strong> 1
<strong>Explanation:</strong>
We can assign the magical pill and tasks as follows:
- Give the magical pill to worker 0.
- Assign worker 0 to task 0 (0 + 5 &gt;= 5)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tasks = [<u><strong>10</strong></u>,<u><strong>15</strong></u>,30], workers = [<u><strong>0</strong></u>,<u><strong>10</strong></u>,10,10,10], pills = 3, strength = 10
<strong>Output:</strong> 2
<strong>Explanation:</strong>
We can assign the magical pills and tasks as follows:
- Give the magical pill to worker 0 and worker 1.
- Assign worker 0 to task 0 (0 + 10 &gt;= 10)
- Assign worker 1 to task 1 (10 + 10 &gt;= 15)
The last pill is not given because it will not make any worker strong enough for the last task.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == tasks.length</code></li>
	<li><code>m == workers.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= pills &lt;= m</code></li>
	<li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-binary-search--greedy-worker-selection">Approach: Binary Search + Greedy Worker Selection</h3>
<h4 id="hint-1">Hint 1</h4>
<p>If we already know that it’s possible to complete exactly <span class="math inline">\(k\)</span> tasks, then:</p>
<ul>
<li>We should select the <span class="math inline">\(k\)</span> lowest-valued tasks from the <code>tasks</code> array.</li>
<li>We should select the <span class="math inline">\(k\)</span> highest-valued workers from the <code>workers</code> array.</li>
</ul>
<h4 id="hint-2">Hint 2</h4>
<p>If it’s possible to complete <span class="math inline">\(k\)</span> tasks while satisfying Hint 1, then it’s also possible to complete <span class="math inline">\(k - 1\)</span> tasks using the <span class="math inline">\(k - 1\)</span> lowest-valued tasks and the <span class="math inline">\(k - 1\)</span> highest-valued workers, which also satisfies Hint 1.</p>
<h4 id="intuition">Intuition</h4>
<p>Based on Hint 2, we can use binary search to find the largest value <span class="math inline">\(k'\)</span> such that we can complete <span class="math inline">\(k'\)</span> tasks, but not <span class="math inline">\(k' + 1\)</span>. This value <span class="math inline">\(k'\)</span> is our final answer.</p>
<p>During each step of binary search, after selecting the <span class="math inline">\(k\)</span> lowest-valued tasks and the <span class="math inline">\(k\)</span> highest-valued workers, we need to determine whether it’s possible to assign the tasks to the workers.</p>
<p>To do this, we process the selected tasks in decreasing order of value. For each task, we consider the following two cases:</p>
<ul>
<li>
<p><strong>Case 1</strong>: The worker with the highest available value is greater than or equal to the task value.<br />
In this case, we do not need to use a pill. We assign this worker (with the maximum value) to this task and remove them from the pool.</p>
<blockquote>
<p>Why this is optimal: Since this is the most difficult (i.e., highest-valued) task, any worker who can complete it can also complete the easier ones. If we assign a weaker worker instead (even with a pill), and later assign the stronger worker to an easier task, we could have swapped the assignments to make a better match. So it’s always optimal to assign the strongest available worker to the hardest task that doesn't need a pill.</p>
</blockquote>
</li>
<li>
<p><strong>Case 2</strong>: No worker can complete the task without a pill.<br />
In this case, we must use a pill. We look for the weakest worker who can complete the task with the pill (i.e., a worker with value ≥ <span class="math inline">\(t - \textit{strength}\)</span>) and remove them from the pool.</p>
<blockquote>
<p>Why this is optimal: Again, since we're processing the hardest task first, any worker who can complete it using a pill can also complete easier tasks using a pill. So, it is always safe (and best) to use the weakest such worker for this hardest task.</p>
</blockquote>
</li>
</ul>
<p>Therefore, we can iterate through the tasks in decreasing order of difficulty and maintain an ordered set of available workers. For each task value <span class="math inline">\(t\)</span>:</p>
<ul>
<li>If the maximum value in the set is ≥ <span class="math inline">\(t\)</span>, we remove that maximum worker (no pill needed).</li>
<li>If not, we look for the minimum worker with value ≥ <span class="math inline">\(t - \textit{strength}\)</span>. If such a worker exists and we still have pills remaining, we use a pill and remove that worker.<br />
Otherwise, it's not possible to complete all tasks with the current value of <span class="math inline">\(k\)</span>.</li>
</ul>
<p>Using this process, we can find whether a given value of <span class="math inline">\(k\)</span> is feasible.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZDR4QtLx/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + m \log m + \min(m, n) \log^2 \min(m, n))\)</span></p>
<ul>
<li>
<p>Sorting the <code>tasks</code> array requires <span class="math inline">\(O(n \log n)\)</span> time.</p>
</li>
<li>
<p>Sorting the <code>workers</code> array requires <span class="math inline">\(O(m \log m)\)</span> time.</p>
</li>
<li>
<p>The lower bound of binary search is 1, and the upper bound is the smaller value between <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, so the number of binary search iterations is <span class="math inline">\(\log \min(m, n)\)</span>. Each iteration involves enumerating <span class="math inline">\(\min(m, n)\)</span> tasks. During this enumeration, deletion operations are performed on the ordered set of workers, with the time complexity of a single operation being <span class="math inline">\(\log \min(m, n)\)</span>. Therefore, the total time complexity of binary search is <span class="math inline">\(O(\min(m, n) \log^2 \min(m, n))\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log n + \log m + \min(m, n))\)</span></p>
<ul>
<li>
<p>Sorting the <code>tasks</code> array requires <span class="math inline">\(O(\log n)\)</span> stack space.</p>
</li>
<li>
<p>Sorting the <code>workers</code> array requires <span class="math inline">\(O(\log m)\)</span> stack space.</p>
</li>
<li>
<p>The ordered set used in binary search requires <span class="math inline">\(O(\min(m, n))\)</span> space.</p>
</li>
</ul>
</li>
</ul>
<h4 id="expansion">Expansion:</h4>
<p>It can be observed that when we enumerate each task from highest to lowest value, and maintain all workers who can complete the task (with the help of pills), then:</p>
<ul>
<li>
<p>If there is a worker who can complete the task without using a pill, we select (and remove) the worker with the highest value.</p>
</li>
<li>
<p>If all available workers need to use a pill to complete the task, we select (and remove) the worker with the lowest value.</p>
</li>
</ul>
<p>As the task value decreases, the number of workers who can complete it increases or remains the same, but never decreases. Therefore, we can use a deque to maintain all workers who can complete the task (with the use of pills). At this point, we either select (and remove) the worker at the front of the deque or the worker at the back. This reduces the time complexity of a single deletion operation from <span class="math inline">\(O(\log \min(m, n))\)</span> to <span class="math inline">\(O(1)\)</span>, and the total time complexity becomes:</p>
<p><span class="math display">\[O(n \log n + m \log m + \min(m, n) \log \min(m, n)) = O(n \log n + m \log m)
\]</span></p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3C6y8buD/shared">code</a></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/description" target="_blank" rel="noopener noreferrer">Maximum Number That Sum of the Prices Is Less Than or Equal to K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>k</code> and an integer <code>x</code>. The price of a number&nbsp;<code>num</code> is calculated by the count of <span data-keyword="set-bit">set bits</span> at positions <code>x</code>, <code>2x</code>, <code>3x</code>, etc., in its binary representation, starting from the least significant bit. The following table contains examples of how price is calculated.</p>

<table border="1">
	<tbody>
		<tr>
			<th>x</th>
			<th>num</th>
			<th>Binary Representation</th>
			<th>Price</th>
		</tr>
		<tr>
			<td>1</td>
			<td>13</td>
			<td><u>0</u><u>0</u><u>0</u><u>0</u><u>0</u><strong><u>1</u></strong><strong><u>1</u></strong><u>0</u><strong><u>1</u></strong></td>
			<td>3</td>
		</tr>
		<tr>
			<td>2</td>
			<td>13</td>
			<td>0<u>0</u>0<u>0</u>0<strong><u>1</u></strong>1<u>0</u>1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>2</td>
			<td>233</td>
			<td>0<strong><u>1</u></strong>1<strong><u>1</u></strong>0<strong><u>1</u></strong>0<u>0</u>1</td>
			<td>3</td>
		</tr>
		<tr>
			<td>3</td>
			<td>13</td>
			<td><u>0</u>00<u>0</u>01<strong><u>1</u></strong>01</td>
			<td>1</td>
		</tr>
		<tr>
			<td>3</td>
			<td>362</td>
			<td><strong><u>1</u></strong>01<strong><u>1</u></strong>01<u>0</u>10</td>
			<td>2</td>
		</tr>
	</tbody>
</table>

<p>The&nbsp;<strong>accumulated price</strong>&nbsp;of&nbsp;<code>num</code>&nbsp;is the <b>total</b>&nbsp;price of&nbsp;numbers from <code>1</code> to <code>num</code>. <code>num</code>&nbsp;is considered&nbsp;<strong>cheap</strong>&nbsp;if its accumulated price&nbsp;is less than or equal to <code>k</code>.</p>

<p>Return the <b>greatest</b>&nbsp;cheap number.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">k = 9, x = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>As shown in the table below, <code>6</code> is the greatest cheap number.</p>

<table border="1">
	<tbody>
		<tr>
			<th>x</th>
			<th>num</th>
			<th>Binary Representation</th>
			<th>Price</th>
			<th>Accumulated Price</th>
		</tr>
		<tr>
			<td>1</td>
			<td>1</td>
			<td><u>0</u><u>0</u><strong><u>1</u></strong></td>
			<td>1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>1</td>
			<td>2</td>
			<td><u>0</u><strong><u>1</u></strong><u>0</u></td>
			<td>1</td>
			<td>2</td>
		</tr>
		<tr>
			<td>1</td>
			<td>3</td>
			<td><u>0</u><strong><u>1</u></strong><strong><u>1</u></strong></td>
			<td>2</td>
			<td>4</td>
		</tr>
		<tr>
			<td>1</td>
			<td>4</td>
			<td><strong><u>1</u></strong><u>0</u><u>0</u></td>
			<td>1</td>
			<td>5</td>
		</tr>
		<tr>
			<td>1</td>
			<td>5</td>
			<td><strong><u>1</u></strong><u>0</u><strong><u>1</u></strong></td>
			<td>2</td>
			<td>7</td>
		</tr>
		<tr>
			<td>1</td>
			<td>6</td>
			<td><strong><u>1</u></strong><strong><u>1</u></strong><u>0</u></td>
			<td>2</td>
			<td>9</td>
		</tr>
		<tr>
			<td>1</td>
			<td>7</td>
			<td><strong><u>1</u></strong><strong><u>1</u></strong><strong><u>1</u></strong></td>
			<td>3</td>
			<td>12</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">k = 7, x = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong></p>

<p>As shown in the table below, <code>9</code> is the greatest cheap number.</p>

<table border="1">
	<tbody>
		<tr>
			<th>x</th>
			<th>num</th>
			<th>Binary Representation</th>
			<th>Price</th>
			<th>Accumulated Price</th>
		</tr>
		<tr>
			<td>2</td>
			<td>1</td>
			<td><u>0</u>0<u>0</u>1</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>2</td>
			<td>2</td>
			<td><u>0</u>0<strong><u>1</u></strong>0</td>
			<td>1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>2</td>
			<td>3</td>
			<td><u>0</u>0<strong><u>1</u></strong>1</td>
			<td>1</td>
			<td>2</td>
		</tr>
		<tr>
			<td>2</td>
			<td>4</td>
			<td><u>0</u>1<u>0</u>0</td>
			<td>0</td>
			<td>2</td>
		</tr>
		<tr>
			<td>2</td>
			<td>5</td>
			<td><u>0</u>1<u>0</u>1</td>
			<td>0</td>
			<td>2</td>
		</tr>
		<tr>
			<td>2</td>
			<td>6</td>
			<td><u>0</u>1<strong><u>1</u></strong>0</td>
			<td>1</td>
			<td>3</td>
		</tr>
		<tr>
			<td>2</td>
			<td>7</td>
			<td><u>0</u>1<strong><u>1</u></strong>1</td>
			<td>1</td>
			<td>4</td>
		</tr>
		<tr>
			<td>2</td>
			<td>8</td>
			<td><strong><u>1</u></strong>0<u>0</u>0</td>
			<td>1</td>
			<td>5</td>
		</tr>
		<tr>
			<td>2</td>
			<td>9</td>
			<td><strong><u>1</u></strong>0<u>0</u>1</td>
			<td>1</td>
			<td>6</td>
		</tr>
		<tr>
			<td>2</td>
			<td>10</td>
			<td><strong><u>1</u></strong>0<strong><u>1</u></strong>0</td>
			<td>2</td>
			<td>8</td>
		</tr>
	</tbody>
</table>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>
	<li><code>1 &lt;= x &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-points-inside-the-square/description" target="_blank" rel="noopener noreferrer">Maximum Points Inside the Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D<strong> </strong>array <code>points</code> and a string <code>s</code> where, <code>points[i]</code> represents the coordinates of point <code>i</code>, and <code>s[i]</code> represents the <strong>tag</strong> of point <code>i</code>.</p>

<p>A <strong>valid</strong> square is a square centered at the origin <code>(0, 0)</code>, has edges parallel to the axes, and <strong>does not</strong> contain two points with the same tag.</p>

<p>Return the <strong>maximum</strong> number of points contained in a <strong>valid</strong> square.</p>

<p>Note:</p>

<ul>
	<li>A point is considered to be inside the square if it lies on or within the square&#39;s boundaries.</li>
	<li>The side length of the square can be zero.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/29/3708-tc1.png" style="width: 303px; height: 303px;" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = &quot;abdca&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The square of side length 4 covers two points <code>points[0]</code> and <code>points[1]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/29/3708-tc2.png" style="width: 302px; height: 302px;" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">points = [[1,1],[-2,-2],[-2,2]], s = &quot;abb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The square of side length 2 covers one point, which is <code>points[0]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">points = [[1,1],[-1,-1],[2,-2]], s = &quot;ccd&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>It&#39;s impossible to make any valid squares centered at the origin such that it covers only one point among <code>points[0]</code> and <code>points[1]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, points.length &lt;= 10<sup>5</sup></code></li>
	<li><code>points[i].length == 2</code></li>
	<li><code>-10<sup>9</sup> &lt;= points[i][0], points[i][1] &lt;= 10<sup>9</sup></code></li>
	<li><code>s.length == points.length</code></li>
	<li><code>points</code> consists of distinct coordinates.</li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-150">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-profit-in-job-scheduling/description" target="_blank" rel="noopener noreferrer">Maximum Profit in Job Scheduling</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We have <code>n</code> jobs, where every job is scheduled to be done from <code>startTime[i]</code> to <code>endTime[i]</code>, obtaining a profit of <code>profit[i]</code>.</p>

<p>You&#39;re given the <code>startTime</code>, <code>endTime</code> and <code>profit</code> arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.</p>

<p>If you choose a job that ends at time <code>X</code> you will be able to start another job that starts at time <code>X</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png" style="width: 380px; height: 154px;" /></strong></p>

<pre>
<strong>Input:</strong> startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
<strong>Output:</strong> 120
<strong>Explanation:</strong> The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png" style="width: 600px; height: 112px;" /> </strong></p>

<pre>
<strong>Input:</strong> startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
<strong>Output:</strong> 150
<strong>Explanation:</strong> The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png" style="width: 400px; height: 112px;" /></strong></p>

<pre>
<strong>Input:</strong> startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
<strong>Output:</strong> 6
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= profit[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-151">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-running-time-of-n-computers/description" target="_blank" rel="noopener noreferrer">Maximum Running Time of N Computers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> computers. You are given the integer <code>n</code> and a <strong>0-indexed</strong> integer array <code>batteries</code> where the <code>i<sup>th</sup></code> battery can <strong>run</strong> a computer for <code>batteries[i]</code> minutes. You are interested in running <strong>all</strong> <code>n</code> computers <strong>simultaneously</strong> using the given batteries.</p>

<p>Initially, you can insert <strong>at most one battery</strong> into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery <strong>any number of times</strong>. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.</p>

<p>Note that the batteries cannot be recharged.</p>

<p>Return <em>the <strong>maximum</strong> number of minutes you can run all the </em><code>n</code><em> computers simultaneously.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png" style="width: 762px; height: 150px;" />
<pre>
<strong>Input:</strong> n = 2, batteries = [3,3,3]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
Initially, insert battery 0 into the first computer and battery 1 into the second computer.
After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.
At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.
By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.
We can run the two computers simultaneously for at most 4 minutes, so we return 4.

</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/01/06/example2.png" style="width: 629px; height: 150px;" />
<pre>
<strong>Input:</strong> n = 2, batteries = [1,1,1,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
Initially, insert battery 0 into the first computer and battery 2 into the second computer. 
After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. 
After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.
We can run the two computers simultaneously for at most 2 minutes, so we return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= batteries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= batteries[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>From the first example, let's try another distribution plan first. Suppose we let 2 batteries support 2 computers continuously, we will end up with 2 empty batteries and 1 full battery. Then the running time is fixed at <code>3</code> since we can't use the only battery left to support 2 computers simultaneously.</p>
<p><img src="../Figures/2141/intro.png" alt="img" /></p>
<p>It implies that there is a strategy to distribute the batteries properly. Let's move on to finding the best patterns.</p>
<hr />
<h3 id="approach-1-sorting-and-prefix-sum">Approach 1: Sorting and Prefix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>First, we simplify the original problem a little bit:</p>
<p><strong>Suppose we have 4 computers (named A, B, C and D) and have to pick exactly 4 batteries. What is the maximum running time?</strong></p>
<p>This is quite straightforward. We just pick the largest 4 batteries and let them support these 4 computers separately (let's call the list that contains these 4 batteries <code>live</code>), and the running time is determined by the smallest battery picked.</p>
<p><img src="../Figures/2141/n4.png" alt="img" /></p>
<p><strong>What if we are allowed to pick a 5th battery?</strong></p>
<p>Let's pick the largest battery that isn't in use. Clearly, the smallest of these 4 batteries will be the bottleneck, so we use the power in the 5th battery to increase the running time of computer A that has the smallest battery.</p>
<p><img src="../Figures/2141/n5.png" alt="img" /></p>
<p><strong>What if we are allowed to pick more batteries?</strong></p>
<p>We can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and &quot;transfer&quot; it to the batteries in <code>live</code>. Let <code>extra</code> be the sum of all the extra power.</p>
<p>Let's say live is sorted. We try using some of our extra power to increase live[0] running time to live[1]. In the process, <code>extra -= live[1] - live[0]</code>.</p>
<p><img src="../Figures/2141/n6.png" alt="img" /></p>
<p>Now, <code>live[0] = live[1]</code>. Can we continue? We try increasing the running time to <code>live[2]</code>. However, not only would we need to increase <code>live[1]</code> to <code>live[2]</code>, we also need to increase <code>live[0]</code> to <code>live[2]</code> so it doesn't bottleneck the running time. We already spent some power to increase <code>live[0]</code> to <code>live[1]</code>, so we just need to spend twice as much power as the difference <code>live[2] - live[1]</code>.</p>
<p><img src="../Figures/2141/n70.png" alt="img" /></p>
<p>Now we have <code>live[0] = live[1] = live[2]</code>. If we want to increase the running time to <code>live[3]</code>, we need to spend three times as much power as the difference <code>(live[3] - live[2])</code>.</p>
<br>
<p><img src="../Figures/2141/n71.png" alt="img" /></p>
<p>Oops, seems we are running out of <code>extra</code> power before reaching <code>live[3]</code>, so the bottleneck is decided by <code>live[2]</code>. We have some extra power remaining, so we do our best to increase the running time by evenly splitting the remaining power to the computers  (<code>extra / 3</code>).</p>
<br>
<p>What if we have an example where <code>extra</code> is large enough to support all batteries in <code>live</code> becoming equal to <code>live[n - 1]</code>. Any remaining power in <code>extra</code> should similarly be evenly split across all the computers to increase the final running time. The final running time is determined by <code>live[n - 1]</code> plus the extra running time we can make using <code>extra</code> power, which is <code>extra / n</code>.</p>
<p><img src="../Figures/2141/n8.png" alt="img" /></p>
<p>To generalize, at each battery <code>live[i]</code>, if we want to increase the running time to <code>live[i + 1]</code>, we need to spend <code>(i + 1)</code> times as much power as <code>(live[i + 1] - live[i])</code>. With this formula, we don't actually need to update the values of <code>live</code>. Since after each iteration, we already know that <code>live[0] = live[1] = ... = live[i]</code>.</p>
<p>We iterate through <code>live</code> until we either cannot afford to increase to <code>live[i + 1]</code> anymore, or we manage to iterate through the entire array. In both cases, we do our best to evenly allocate the remaining extra power.</p>
<br>
<p>You may be thinking that in the case below, since there is some unused power in the larger batteries (like the largest battery on the right), can we further increase the total running time using this unused power? The answer is NO.</p>
<p><img src="../Figures/2141/n7.png" alt="img" /></p>
<p>As shown in the following picture, suppose we do allocate the power &quot;equally&quot; by using the excess power of the largest battery (colored in red) on other computers. It means that there are times when the red battery is used on other computers, but the same battery also supports the computer D <strong>all the time</strong>. This contradicts the rule that <em>one battery can't support more than one computer at the same time</em>.</p>
<p><img src="../Figures/2141/7.png" alt="img" /></p>
<p>Therefore, we observe the pattern that:</p>
<blockquote>
<p>If a battery <code>batteries[i]</code> has more power than the total running time, there is no way we can use its excess power to further increase the running time. Therefore, once we have picked the largest <code>n</code> batteries and assign them to <code>n</code> computers, these batteries are tied to their computer and swapping them does not bring any longer running time.</p>
</blockquote>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Sort <code>batteries</code>.</p>
</li>
<li>
<p>Find the largest <code>n</code> batteries and assign them to <code>n</code> computers, these <code>n</code> batteries are exclusively used by each computer and cannot be shared with other computers. Create an array <code>live</code> that contains the largest <code>n</code> batteries in sorted order, which represents the <code>n</code> computers.</p>
</li>
<li>
<p>Sum up the power of the remaining batteries as <code>extra</code>.</p>
</li>
<li>
<p>Iterate over <code>live</code> from <code>0</code> to <code>n - 2</code>, for each index <code>i</code>:</p>
<ul>
<li>If <code>extra</code> power can increase the running time of the first <code>i</code> computers from <code>live[i]</code> to <code>live[i + 1]</code>, then we subtract the required power from <code>extra</code> and move on to the next index.</li>
<li>Otherwise, we have to stop at this point and return <code>live[i] + extra / (i + 1)</code>.</li>
</ul>
</li>
<li>
<p>If there is still power left after the iteration, it means we can further increase the total running time of <code>n</code> computers from <code>live[n - 1]</code> by <code>extra / n</code>. Therefore, return <code>live[n - 1] + extra / n</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ju4XcHbQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of the input array <code>batteries</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot\log m)\)</span></p>
<ul>
<li>
<p>We sort <span class="math inline">\(\text{batteries}\)</span> in place, it takes <span class="math inline">\(O(m \cdot\log m)\)</span> time.</p>
</li>
<li>
<p>Picking the largest n-th batteries from a sorted array takes <span class="math inline">\(O(n)\)</span> time. Note that since <span class="math inline">\(n < m\)</span>, this term will be dominated.</p>
</li>
<li>
<p>Then we iterate over the remaining part of the <code>batteries</code>, the computation at each step takes constant time. Thus it takes <span class="math inline">\(O(m)\)</span> time to finish the iteration.</p>
</li>
<li>
<p>To sum up, the overall time complexity is <span class="math inline">\(O(m \cdot\log m)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<ul>
<li>Some extra space is used when we sort <span class="math inline">\(\text{batteries}\)</span> in place. The space complexity of the sorting algorithm depends on the programming language.
<ul>
<li>In python, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(m)\)</span> additional space.</li>
<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log m)\)</span>.</li>
</ul>
</li>
<li>We create an array of size <span class="math inline">\(O(n)\)</span> to record the power (running time) of each computer.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(m)\)</span>.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-binary-search">Approach 2: Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we began by selecting the largest <code>n</code> batteries (one for each computer) and then assigning the remaining power <code>extra</code> to these computers using a greedy approach until we reach the longest running time.</p>
<p>Alternatively, we can first set a target running time, <code>target</code>, then try to reach this running time using all batteries.</p>
<p><img src="../Figures/2141/b1.png" alt="img" /></p>
<p>Here we still take advantage of the conclusion we reached at the end of the previous approach (Please refer to the previous approach):</p>
<ul>
<li>If the power of a battery is smaller than <code>target</code>, we can use all of its power.</li>
<li>If the power of a battery is larger than <code>target</code>, we can only use <code>target</code> power from it.</li>
</ul>
<p><img src="../Figures/2141/b2.png" alt="img" /></p>
<p>Therefore, we can traverse through <code>batteries</code> and collect all the power that can be used. If the sum of collected power is larger than or equal to <code>target * n</code>, all computers can run for <code>target</code> time.</p>
<p>As shown in the picture above, suppose we set a running time <code>target</code>, then we collect power from all batteries (colored in green). Finally, we check if the sum of the collected power is larger than or equals to <code>target * 2</code>.</p>
<p><strong>How to find the largest running time?</strong></p>
<p>Instead of trying every <code>target</code> from <code>1</code> until finding the largest possible running time, we can take advantage of binary search to locate the largest <code>target</code> faster than linear search.</p>
<p><img src="../Figures/2141/b3.png" alt="img" /></p>
<p>Initially, we set the left boundary as <code>1</code> as the minimum possible running time. Assuming we can use all the power perfectly, the maximum running time is <code>sum(batteries) / n</code>, so we set the right boundary as <code>sum(batteries) / n</code>. As a result, the largest <code>target</code> is limited to the inclusive range <code>[left, right]</code>, and we can apply binary search in this range to find it.</p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize the boundaries of the search space as <code>left = 1</code>, and <code>right = sum(batteries) / n</code>.</p>
</li>
<li>
<p>While <code>left &lt; right</code>:</p>
<ul>
<li>Find the middle value <code>target = right - (right - left) / 2</code>.</li>
<li>Check if batteries can support <code>n</code> computers run <code>target</code> time. Iterate over <code>batteries</code> and record <code>extra</code>, the accumulative sum of <code>min(batteries[i], target)</code>.</li>
</ul>
</li>
<li>
<p>Check if <code>extra &gt;= n * target</code>:</p>
<ul>
<li>If so, set <code>left = target</code> and repeat step 2.</li>
<li>Otherwise, set <code>right = target - 1</code> and repeat step 2.</li>
</ul>
</li>
<li>
<p>Once the binary search ends, return <code>left</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/MhesBzu2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of the input array <code>batteries</code> and <span class="math inline">\(k\)</span> be the maximum power of one battery.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot\log k)\)</span></p>
<ul>
<li>Initially, we set <code>1</code> as the left boundary and <code>sum(batteries) / n</code> as the right boundary. Thus it takes <span class="math inline">\(O(\log (\frac{m\cdot k}{n}))\)</span> steps to locate the maximum running time in the worst-case scenario.</li>
<li>At each step, we need to iterate over <code>batteries</code> to add up the power that can be used, which takes <span class="math inline">\(O(m)\)</span> time.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot\log (\frac{m\cdot k}{n})) = O(m\cdot \log k)\)</span></li>
</ul>
<p><span class="math display">\[



\]</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>During the binary search, we only need to record the boundaries of the searching space and the power <code>extra</code>, and the accumulative sum of <code>extra</code>, which only takes constant space.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-152">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-of-a-good-subarray/description" target="_blank" rel="noopener noreferrer">Maximum Score of a Good Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> <strong>(0-indexed)</strong> and an integer <code>k</code>.</p>

<p>The <strong>score</strong> of a subarray <code>(i, j)</code> is defined as <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>. A <strong>good</strong> subarray is a subarray where <code>i &lt;= k &lt;= j</code>.</p>

<p>Return <em>the maximum possible <strong>score</strong> of a <strong>good</strong> subarray.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,3,7,4,5], k = 3
<strong>Output:</strong> 15
<strong>Explanation:</strong> The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,4,5,4,1,1,1], k = 0
<strong>Output:</strong> 20
<strong>Explanation:</strong> The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= k &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>The score of a subarray is its length multiplied by its minimum element. In this problem, we must find the maximum score of all subarrays that contain <code>nums[k]</code>.</p>
<p>How can we improve our score? When we take more elements we increase the length of the subarray, which helps the score. However, we may find new minimums, which would decrease our score.</p>
<p>We can start by separating the array - numbers to the left of <code>k</code> and numbers to the right of <code>k</code> (and including <code>k</code>).</p>
<p><img src="../Figures/1793/1.png" alt="img" /><br />
<br></p>
<p>Notice that <code>k</code> is the meeting point of these sections. If we want to take elements in the left section, we start from the end of the left section and move toward the beginning. If we want to take elements in the right section, we start from the beginning and move toward the end.</p>
<p>Of course, each element we take will increase our length by <code>1</code>. But how will it affect our minimum? To compute this quickly, we can create new arrays for each section. These arrays will represent the minimum element we have seen in the section if we started from <code>k</code>.</p>
<p><img src="../Figures/1793/2.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we took two elements from the left section. We can quickly see that the minimum element from the left section is <code>3</code> using these arrays. Similarly, if we took all elements from the right section, we could quickly see that the minimum element from the right section is <code>4</code>.</p>
<blockquote>
<p>We will call these arrays that allow us to find the minimums <code>left</code> and <code>right</code>.</p>
</blockquote>
<p>Now that we have these arrays, how can we solve the problem? Because <code>nums[k]</code> is in the right section, we will iterate over the entire right section and try to take each element. Let's say we take some number of elements from the right section, and the minimum is <code>x</code>. How many elements can we take from the left section without changing <code>x</code> as the minimum? We must only take elements from the left that are greater than or equal to <code>x</code>.</p>
<p>Let's switch to another example. For a given array, assuming we have already built the <code>left</code> and <code>right</code> arrays using the previous method.</p>
<p><img src="../Figures/1793/3.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we take four elements from the right section. The minimum is <code>5</code>. How many elements can we take from the left section without changing the minimum? Two. This gives us a total size of <code>4 + 2 = 6</code>, and a total score of <code>6 * 5 = 30</code>.</p>
<p>How do we quickly find the number of elements we can take from the left section? Note that when we are building the array <code>left</code> from right to left, each time we go left we encounter a new number that is only likely to lower the minimum value, and the further to the left we go, the smaller the minimum value becomes, i.e., <code>left</code> is already sorted from smallest to largest. Therefore, we can perform a binary search to identify how many elements we can take.</p>
<p>This brings us to our solution. We iterate with <code>j</code> over each index of <code>right</code> and assign <code>currMin = right[j]</code>, which represents the minimum of our subarray. We then perform a binary search to find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code>. Once we have <code>i</code>, we can calculate the size of our subarray, and thus the score. We take the maximum of all scores.</p>
<p>How do we calculate the size of our subarray given <code>i</code> and <code>j</code>?</p>
<p><img src="../Figures/1793/4.png" alt="img" /><br />
<br></p>
<p>Because the right section starts at index <code>k</code>, its indices are offset by <code>k</code> from the real indices. Thus, in the original array, <code>right[j]</code> points to index <code>k + j</code>. The left section is not offset at all, so <code>i</code> is correctly positioned. The size of a subarray bounded by <code>[left, right]</code> is <code>right - left + 1</code>. Thus, the size of our subarray <code>[i, k + j]</code> is <code>(k + j) - i + 1</code>. We can multiply this by <code>right[j]</code> to calculate our score.</p>
<p>You may have noticed: this algorithm assumes that in the optimal subarray, the minimum value is in the right section. But what if this assumption is wrong, and its actually in the left section? We can check the left section by simply reversing the array and then applying the same algorithm to it. Note that when we reverse the array, <code>k</code> will change. After reversal, the original <code>k</code> will be at <code>nums.length - k - 1</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>solve(nums, k)</code> that runs our algorithm:
<ul>
<li>Set <code>n = nums.length</code>, <code>left</code> to an array of length <code>k</code>, and <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k - 1</code> until <code>0</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and set <code>left[i] = currMin</code>.</li>
<li>Initialize an empty array <code>right</code> and reset <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k</code> until <code>n - 1</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and push <code>currMin</code> to <code>right</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>j</code> over the indices of <code>right</code>:
<ul>
<li>Set <code>currMin = right[j]</code>.</li>
<li>Find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code> using binary search.</li>
<li>Calculate <code>size = (k + j) - i - 1</code>.</li>
<li>Update <code>ans</code> with <code>currMin * size</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = solve(nums, k)</code>.</li>
<li>Reverse <code>nums</code>.</li>
<li>Return the larger of <code>ans, solve(nums, nums.length - k - 1)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/AePxSPjG/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> time to create <code>left</code> and <code>right</code>. Then, we iterate over the indices of <code>right</code>, which is not more than <span class="math inline">\(O(n)\)</span> iterations. At each iteration, we perform a binary search over <code>left</code>, which does not cost more than <span class="math inline">\(O(\log{}n)\)</span>. Thus, <code>solve</code> costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>, and we call it twice.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code> and <code>right</code> have a combined length of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<p><strong>Intuition</strong></p>
<p>In this approach, we will use a similar idea as in the previous approach. For a given index <code>i</code>, if we treat <code>nums[i]</code> as the minimum element, we need to know how many elements we can take on the left and right such that we do not take any elements less than <code>nums[i]</code>.</p>
<blockquote>
<p>You might be thinking: what if <code>nums[k]</code> is not included? We will get to that after presenting the full idea of the approach.</p>
</blockquote>
<p>Essentially, we need to know how far away the next lesser element is on both sides. If we have this information for all indices, we can quickly calculate the maximum score possible by treating every <code>nums[i]</code> as the minimum, since in the optimal solution, one of the indices must be the minimum.</p>
<p>There is a very similar problem called <a href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element</a>. The logic is identical, except that we are looking for the next smaller element. We can accomplish this using a monotonic stack.</p>
<details><summary><b>If you aren't familiar with monotonic stacks, click here.</b></summary>
<p>A monotonic stack is a stack whose elements are always sorted. In our case, we want a monotonic <strong>increasing</strong> stack, i.e. the elements in the stack are always sorted in ascending order.</p>
<p>To maintain this monotonic stack, we need to make sure that whenever we push a new element, it is the largest value in the stack. Before we push an element <code>num</code>, we check the top of the stack. If the top of the stack is greater than <code>num</code>, we pop from it. Since there may be multiple elements greater than <code>num</code> in the stack, we need to use a while loop to &quot;clean&quot; the stack before pushing <code>num</code>.</p>
<p>Only once there are no elements in the stack greater than <code>num</code> will we push <code>num</code>.</p>
</details>
<br>
<p>We will create an array <code>left</code>, where <code>left[i]</code> has the index of the first element to the left of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>Similarly, we will create an array <code>right</code> where <code>right[i]</code> has the index of the first element to the right of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>So how do we calculate <code>right</code>? Let's say that we are iterating over <code>nums</code> from the left and we have a chain of increasing numbers:</p>
<p><img src="../Figures/1793/5.png" alt="img" /><br />
<br></p>
<p>As you can see in the example, we have 6 increasing numbers, and then a <code>1</code> that is less than all of them. This <code>1</code> (at index 6) should be the value of <code>right</code> for all the indices of the increasing numbers. If we maintain a monotonic increasing stack, then this <code>1</code> will cause all those numbers to be popped out.</p>
<p>With a monotonic increasing stack, whenever we see an element that is smaller than the top of the stack, it is guaranteed to be the first smaller element for the element at the top of the stack. This is exactly what we are looking for.</p>
<p>To calculate <code>left</code>, we use the exact same process, except we iterate backward starting from the end of <code>nums</code>.</p>
<p>Note that because we need to remember what indices to update when we pop from the stack, we will store indices on the stack instead of the elements themselves. We can easily find the values by referencing <code>nums</code>.</p>
<p>We will initialize the values of <code>left</code> to <code>-1</code> and the values of <code>right</code> to <code>n</code>. This way, the math will still work out later if there are elements that do not have any lower values to the left or right.</p>
<p>Once we have <code>left</code> and <code>right</code>, we can iterate over all indices <code>i</code> and try to find a maximum score. Remember that the subarray must contain index <code>k</code>. Thus, we can only use an index <code>i</code> as the minimum if <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>.</p>
<p>When we treat an index <code>i</code> as the minimum, what score can we achieve? Our window starts one index after <code>left[i]</code> because including <code>left[i]</code> would create a new minimum. Similarly, our window ends one index before <code>right[i]</code>. Thus, we need to subtract <code>2</code> from the normal subarray size formula. This gives us a subarray size of <code>right[i] - left[i] - 1</code>. We multiply this size by <code>nums[i]</code> to get our score.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left</code> as an array of length <code>n</code> with values of <code>-1</code>, and an empty <code>stack</code>.</li>
<li>Iterate <code>i</code> from <code>n - 1</code> until <code>0</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>left[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>right</code> as an array of length <code>n</code> with values of <code>n</code> and reset <code>stack</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>right[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>If <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>, update <code>ans</code> with <code>nums[i] * (right[i] - left[i] - 1)</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/N4kEkyfF/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>It costs <span class="math inline">\(O(n)\)</span> to calculate <code>left</code> and <code>right</code>. We iterate over each index once and perform amortized <span class="math inline">\(O(1)\)</span> work at each iteration. The reason it amortizes to <span class="math inline">\(O(1)\)</span>, despite the while loop, is because the while loop can run a maximum of <span class="math inline">\(n\)</span> times across all iterations, and each index can only be pushed onto and popped from the stack once.</p>
<p>To calculate <code>ans</code>, we iterate over the indices once and perform <span class="math inline">\(O(1)\)</span> work at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code>, <code>right</code>, and <code>stack</code> all require <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-greedy">Approach 3: Greedy</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes the simplest approach is the best! The optimal subarray must contain index <code>k</code>, so it makes sense to consider the subarray with only <code>nums[k]</code> as a starting point.</p>
<p>From here, how do we expand the subarray? We can either add an element to the left or an element to the right. Let's say we have two pointers, <code>left</code> and <code>right</code> that represent our subarray. Which direction should we go?</p>
<p>If we move left, it's equivalent to adding <code>nums[left - 1]</code> to our subarray. If we move right, it's equivalent to adding <code>nums[right + 1]</code> to our subarray. We should move in the direction of the greater element.</p>
<p>At each step, we update <code>currMin</code> which is initially set to <code>nums[k]</code>, and try to update <code>ans</code> which is also initially set to <code>nums[k]</code>. We can update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is larger.</p>
<p>This greedy process is very similar to the one used to solve <a href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water</a>. But why does it work? We will use a proof by contradiction to demonstrate that not doing it this way wouldn't result in a higher value either.</p>
<p>At each step, we choose between having our subarray as <code>[left - 1, right]</code> or <code>[left, right + 1]</code>. Let's assume that <code>nums[left - 1] &gt; nums[right + 1]</code> and the optimal subarray has not been found yet. The optimal subarray must include <code>nums[left - 1]</code>. If it doesn't, then it must include <code>nums[right + 1]</code>, since we could only move right to &quot;avoid&quot; <code>nums[left - 1]</code>. However, any subarray that includes <code>nums[right + 1]</code> could also include <code>nums[left - 1]</code> without affecting the minimum, while also increasing the length of the subarray and thus the score. Thus, it is impossible for the optimal subarray to include <code>nums[right + 1]</code> and not <code>nums[left - 1]</code>, and in general the optimal subarray must include <code>nums[left - 1]</code>.</p>
<p><strong>Algorithm</strong></p>
<p>To implement the while loop, we will iterate until we have exhausted the array. If one of the pointers is out of bounds, we will consider the element it points to as <code>0</code>.</p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left = k</code>, <code>right = k</code>, <code>ans = nums[k]</code>, and <code>currMin = nums[k]</code>.</li>
<li>While <code>left &gt; 0</code> or <code>right &lt; n - 1</code>:
<ul>
<li>Compare <code>nums[left - 1]</code> with <code>nums[right + 1]</code>:
<ul>
<li>If <code>nums[right + 1]</code> is greater, increment <code>right</code> and update <code>currMin</code> with <code>nums[right]</code> if it is lower.</li>
<li>Otherwise, decrement <code>left</code> and update <code>currMin</code> with <code>nums[left]</code> if it is lower.</li>
</ul>
</li>
<li>Update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is greater.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/ayvayDq2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>At each iteration, our <code>left</code> or <code>right</code> pointers move closer to the edges of the array by <code>1</code>. Thus, we perform <span class="math inline">\(O(n)\)</span> iterations. Each iteration costs <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We aren't using any extra space other than a few integers.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-153">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-of-non-overlapping-intervals/description" target="_blank" rel="noopener noreferrer">Maximum Score of Non-overlapping Intervals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>intervals</code>, where <code>intervals[i] = [l<sub>i</sub>, r<sub>i</sub>, weight<sub>i</sub>]</code>. Interval <code>i</code> starts at position <code>l<sub>i</sub></code> and ends at <code>r<sub>i</sub></code>, and has a weight of <code>weight<sub>i</sub></code>. You can choose <em>up to</em> 4 <strong>non-overlapping</strong> intervals. The <strong>score</strong> of the chosen intervals is defined as the total sum of their weights.</p>

<p>Return the <span data-keyword="lexicographically-smaller-array">lexicographically smallest</span> array of at most 4 indices from <code>intervals</code> with <strong>maximum</strong> score, representing your choice of non-overlapping intervals.</p>

<p>Two intervals are said to be <strong>non-overlapping</strong> if they do not share any points. In particular, intervals sharing a left or right boundary are considered overlapping.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">intervals = [[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p>You can choose the intervals with indices 2, and 3 with respective weights of 5, and 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">intervals = [[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,5,6]</span></p>

<p><strong>Explanation:</strong></p>

<p>You can choose the intervals with indices 1, 3, 5, and 6 with respective weights of 7, 6, 3, and 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= intevals.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>intervals[i].length == 3</code></li>
	<li><code>intervals[i] = [l<sub>i</sub>, r<sub>i</sub>, weight<sub>i</sub>]</code></li>
	<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= weight<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-154">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description" target="_blank" rel="noopener noreferrer">Maximum Side Length of a Square with Sum Less than or Equal to Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> matrix <code>mat</code> and an integer <code>threshold</code>, return <em>the maximum side-length of a square with a sum less than or equal to </em><code>threshold</code><em> or return </em><code>0</code><em> if there is no such square</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/05/e1.png" style="width: 335px; height: 186px;" />
<pre>
<strong>Input:</strong> mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The maximum side length of square with sum less than 4 is 2 as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>0 &lt;= mat[i][j] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= threshold &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-155">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Maximum Strictly Increasing Cells in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>1-indexed</strong>&nbsp;<code>m x n</code> integer matrix <code>mat</code>, you can select any cell in the matrix as your <strong>starting cell</strong>.</p>

<p>From the starting cell, you can move to any other cell <strong>in the</strong> <strong>same row or column</strong>, but only if the value of the destination cell is <strong>strictly greater</strong> than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p>

<p>Your task is to find the <strong>maximum number of cells</strong> that you can visit in the matrix by starting from some cell.</p>

<p>Return <em>an integer denoting the maximum number of cells that can be visited.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png" style="width: 200px; height: 176px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1],[3,4]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png" style="width: 200px; height: 176px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[1,1],[1,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Since the cells must be strictly increasing, we can only visit one cell in this example. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png" style="width: 350px; height: 250px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1,6],[-9,5,7]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length&nbsp;</code></li>
	<li><code>n == mat[i].length&nbsp;</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup>&nbsp;&lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-156">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-queries/description" target="_blank" rel="noopener noreferrer">Maximum Sum Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, each of length <code>n</code>, and a <strong>1-indexed 2D array</strong> <code>queries</code> where <code>queries[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p>

<p>For the <code>i<sup>th</sup></code> query, find the <strong>maximum value</strong> of <code>nums1[j] + nums2[j]</code> among all indices <code>j</code> <code>(0 &lt;= j &lt; n)</code>, where <code>nums1[j] &gt;= x<sub>i</sub></code> and <code>nums2[j] &gt;= y<sub>i</sub></code>, or <strong>-1</strong> if there is no <code>j</code> satisfying the constraints.</p>

<p>Return <em>an array </em><code>answer</code><em> where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]
<strong>Output:</strong> [6,10,7]
<strong>Explanation:</strong> 
For the 1st query <code node="[object Object]">x<sub>i</sub> = 4</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 1</code>, we can select index&nbsp;<code node="[object Object]">j = 0</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 4</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 1</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 6, and we can show that 6 is the maximum we can obtain.

For the 2nd query <code node="[object Object]">x<sub>i</sub> = 1</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 3</code>, we can select index&nbsp;<code node="[object Object]">j = 2</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 1</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 3</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 10, and we can show that 10 is the maximum we can obtain. 

For the 3rd query <code node="[object Object]">x<sub>i</sub> = 2</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 5</code>, we can select index&nbsp;<code node="[object Object]">j = 3</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 2</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 5</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 7, and we can show that 7 is the maximum we can obtain.

Therefore, we return&nbsp;<code node="[object Object]">[6,10,7]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]
<strong>Output:</strong> [9,9,9]
<strong>Explanation:</strong> For this example, we can use index&nbsp;<code node="[object Object]">j = 2</code>&nbsp;for all the queries since it satisfies the constraints for each query.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]
<strong>Output:</strong> [-1]
<strong>Explanation:</strong> There is one query in this example with <code node="[object Object]">x<sub>i</sub></code> = 3 and <code node="[object Object]">y<sub>i</sub></code> = 3. For every index, j, either nums1[j] &lt; <code node="[object Object]">x<sub>i</sub></code> or nums2[j] &lt; <code node="[object Object]">y<sub>i</sub></code>. Hence, there is no solution. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>nums1.length == nums2.length</code>&nbsp;</li>
	<li><code>n ==&nbsp;nums1.length&nbsp;</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup>&nbsp;</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length ==&nbsp;2</code></li>
	<li><code>x<sub>i</sub>&nbsp;== queries[i][1]</code></li>
	<li><code>y<sub>i</sub> == queries[i][2]</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-157">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-tastiness-of-candy-basket/description" target="_blank" rel="noopener noreferrer">Maximum Tastiness of Candy Basket</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of positive integers <code>price</code> where <code>price[i]</code> denotes the price of the <code>i<sup>th</sup></code> candy and a positive integer <code>k</code>.</p>

<p>The store sells baskets of <code>k</code> <strong>distinct</strong> candies. The <strong>tastiness</strong> of a candy basket is the smallest absolute difference of the <strong>prices</strong> of any two candies in the basket.</p>

<p>Return <em>the <strong>maximum</strong> tastiness of a candy basket.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> price = [13,5,1,8,21,2], k = 3
<strong>Output:</strong> 8
<strong>Explanation:</strong> Choose the candies with the prices [13,5,21].
The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.
It can be proven that 8 is the maximum tastiness that can be achieved.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> price = [1,3,1], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Choose the candies with the prices [1,3].
The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.
It can be proven that 2 is the maximum tastiness that can be achieved.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> price = [7,7,7,7], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> Choosing any two distinct candies from the candies we have will result in a tastiness of 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= k &lt;= price.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= price[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-158">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-beauty-of-the-gardens/description" target="_blank" rel="noopener noreferrer">Maximum Total Beauty of the Gardens</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice is a caretaker of <code>n</code> gardens and she wants to plant flowers to maximize the total beauty of all her gardens.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>flowers</code> of size <code>n</code>, where <code>flowers[i]</code> is the number of flowers already planted in the <code>i<sup>th</sup></code> garden. Flowers that are already planted <strong>cannot</strong> be removed. You are then given another integer <code>newFlowers</code>, which is the <strong>maximum</strong> number of flowers that Alice can additionally plant. You are also given the integers <code>target</code>, <code>full</code>, and <code>partial</code>.</p>

<p>A garden is considered <strong>complete</strong> if it has <strong>at least</strong> <code>target</code> flowers. The <strong>total beauty</strong> of the gardens is then determined as the <strong>sum</strong> of the following:</p>

<ul>
	<li>The number of <strong>complete</strong> gardens multiplied by <code>full</code>.</li>
	<li>The <strong>minimum</strong> number of flowers in any of the <strong>incomplete</strong> gardens multiplied by <code>partial</code>. If there are no incomplete gardens, then this value will be <code>0</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> total beauty that Alice can obtain after planting at most </em><code>newFlowers</code><em> flowers.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
<strong>Output:</strong> 14
<strong>Explanation:</strong> Alice can plant
- 2 flowers in the 0<sup>th</sup> garden
- 3 flowers in the 1<sup>st</sup> garden
- 1 flower in the 2<sup>nd</sup> garden
- 1 flower in the 3<sup>rd</sup> garden
The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.
There is 1 garden that is complete.
The minimum number of flowers in the incomplete gardens is 2.
Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.
No other way of planting flowers can obtain a total beauty higher than 14.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
<strong>Output:</strong> 30
<strong>Explanation:</strong> Alice can plant
- 3 flowers in the 0<sup>th</sup> garden
- 0 flowers in the 1<sup>st</sup> garden
- 0 flowers in the 2<sup>nd</sup> garden
- 2 flowers in the 3<sup>rd</sup> garden
The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.
There are 3 gardens that are complete.
The minimum number of flowers in the incomplete gardens is 4.
Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.
No other way of planting flowers can obtain a total beauty higher than 30.
Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>
	<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-159">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-damage-with-spell-casting/description" target="_blank" rel="noopener noreferrer">Maximum Total Damage With Spell Casting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A magician has various spells.</p>

<p>You are given an array <code>power</code>, where each element represents the damage of a spell. Multiple spells can have the same damage value.</p>

<p>It is a known fact that if a magician decides to cast a spell with a damage of <code>power[i]</code>, they <strong>cannot</strong> cast any spell with a damage of <code>power[i] - 2</code>, <code>power[i] - 1</code>, <code>power[i] + 1</code>, or <code>power[i] + 2</code>.</p>

<p>Each spell can be cast <strong>only once</strong>.</p>

<p>Return the <strong>maximum</strong> possible <em>total damage</em> that a magician can cast.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">power = [1,1,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">power = [7,1,6,6]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= power.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= power[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-160">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description" target="_blank" rel="noopener noreferrer">Maximum Value at a Given Index in a Bounded Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three positive integers:&nbsp;<code>n</code>, <code>index</code>, and <code>maxSum</code>. You want to construct an array <code>nums</code> (<strong>0-indexed</strong>)<strong> </strong>that satisfies the following conditions:</p>

<ul>
	<li><code>nums.length == n</code></li>
	<li><code>nums[i]</code> is a <strong>positive</strong> integer where <code>0 &lt;= i &lt; n</code>.</li>
	<li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> where <code>0 &lt;= i &lt; n-1</code>.</li>
	<li>The sum of all the elements of <code>nums</code> does not exceed <code>maxSum</code>.</li>
	<li><code>nums[index]</code> is <strong>maximized</strong>.</li>
</ul>

<p>Return <code>nums[index]</code><em> of the constructed array</em>.</p>

<p>Note that <code>abs(x)</code> equals <code>x</code> if <code>x &gt;= 0</code>, and <code>-x</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, index = 2,  maxSum = 6
<strong>Output:</strong> 2
<strong>Explanation:</strong> nums = [1,2,<u><strong>2</strong></u>,1] is one array that satisfies all the conditions.
There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 6, index = 1,  maxSum = 10
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= maxSum &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= index &lt; n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>As usual, let's start with the example given in the problem statement. Referring to the figure below, there are several ways to make <code>nums[2]</code> the maximum, as shown in the first two examples. However, once we want a larger <code>nums[2]</code> as <code>3</code>, the sum of the array will certainly be greater than <code>maxSum</code>.</p>
<p><img src="../Figures/1802/intro.png" alt="img" /></p>
<hr />
<h3 id="approach-greedy--binary-search">Approach: Greedy + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The objective is to maximize <code>nums[index]</code> while ensuring the sum the array does not exceed <code>maxSum</code>, so we can try using a greedy algorithm. In order to maximize <code>nums[index]</code>, we need to ensure that all other values are <strong>as small as possible</strong>.</p>
<p>However, we cannot take the other values to be arbitrarily small. Referring to the two rules given in the problem:</p>
<blockquote>
<ul>
<li>The difference between adjacent numbers cannot be greater than <code>1</code>.</li>
<li><code>nums[i]</code> must be positive.</li>
</ul>
</blockquote>
<p>Therefore, the last two examples in the figure below are not valid. In the example in the middle, the difference between adjacent numbers (<code>nums[3]</code> and <code>nums[4]</code>) is greater than <code>1</code>. In the example on the right, the first number is equal to <code>0</code>, which is not allowed.</p>
<p>Hence, we need to ensure that <code>nums[i]</code> satisfies these conditions as well.</p>
<p><img src="../Figures/1802/1.png" alt="img" /></p>
<p>Therefore, the straightforward approach is after setting a value for <code>nums[index]</code>, let the numbers to its left decrease one by one from right to left until they reach <code>1</code>. Similarly, the numbers to its right decrease one by one from left to right until they reach <code>1</code>. This way, we can ensure that the total sum of the array is minimized without violating the rules.</p>
<p>Next, we need to calculate the sum of the array, which is a purely mathematical problem. Let's take the numbers to the left of <code>nums[index]</code> as an example. There will be an arithmetic sequence to its left, and (possibly) a consecutive sequence of <code>1</code>s if <code>nums[index]</code> is less than the number of elements to the left. We need to determine the length of the arithmetic sequence based on the relative sizes of <code>index</code> and <code>value</code>.</p>
<p>Once we have determined the length of the arithmetic sequence, we can calculate the sum of the sequence using the arithmetic sequence formula:</p>
<p><span class="math display">\[
 
where `A[1]` and `A[n]` are the first and last terms of the sequence respectively, and `n` is the length of the sequence. 
 
Take the following figure as an example:

![img](../Figures/1802/2.png)

- If `value <= index`, it means in addition to the arithmetic sequence from value to `1`, there will also be a continuous sequence of `1`s with length `index - value + 1`. The sum of all elements on `index`'s left (including `nums[index]`) is made up by two parts:
    - The sum of arithmetic sequence `[1, 2, 3, ..., value - 1, value]`, which is `(value + 1) * value / 2`.
    - The sum of sequence of length `index - value + 1` consisting of all `1`s, which is `index - value + 1`.

- Otherwise, it means there is only one arithmetic sequence on the left side of index, with the first item being `value` and the last item being `value - index`, so the sum of all elements on `index`'s left (including `nums[index]`) is:
    - The sum of arithmetic sequence `[value - index, ..., value - 1, value]`, which is `(value + value - index) * (index + 1) / 2`.


<br>

Similarly, the right side of `nums[index]` is exactly the same. We need to determine the length of the arithmetic sequence and the length of the continuous subarray of `1` based on the relative sizes of `n - index` and `value`.


![img](../Figures/1802/3.png)

- If `value` is less than or equal to `n - index`, it means there is a subarray of length `n - index - value` consisting of all `1`s in addition to the arithmetic sequence from `value` to `1`. The sum of all elements on `index`'s right (including `nums[index]`) is made up by two parts:
    - The sum of arithmetic sequence `[value, value - 1, ..., 2, 1]`, which is `(value + 1) * value / 2`.
    - The sum of sequence of length `index - value + 1` consisting of all `1`s, which is `n - index - value`

- Otherwise, there is only an arithmetic sequence on the right side of index with the first term being `value` and the last term being `value - n + 1 + index`, so the sum of all elements on `index`'s right (including `nums[index]`) is:
    - The sum of arithmetic sequence `[value, value - 1, ..., value - n + 1 + index]`, which is `(value + value - n + 1 + index) * (n - index) / 2`.

<br>

Don't forget that we have added the actual `value` at `index` twice, so we need to subtract the final sum by `value`.


<br>

Now that we know how to calculate the array sum given a specific `nums[index] = value`, the question is how do we maximize `value`?

We can use binary search to find the maximum `value` that meets the criteria. First, we define a search range `[left, right]` that ensures the maximum `value` falls within this range. Next, we perform a binary search within this range. For each boundary value `mid` that divides the current search space in half, we try whether `nums[index] = mid` is a feasible value that ensures the sum of the array does not exceed `maxSum`. If it is valid, we continue searching for a larger `mid` in the right half of the interval. If it is not feasible, it means that `mid` is too large, and we need to search for a smaller value in the left half of the interval. In this way, we can halve the search interval at each step, and find the maximum `mid` that meets the criteria in logarithmic time.
<br>

<details>

<summary>There are many other interesting problems that can be solved by performing a binary search to find the optimal value. You can practice using the binary search approach on the following problems! (click to show)</summary>

<br>

- [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/) 
- [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/) 
- [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) 
- [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/) 
- [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/)

</details>



#### Algorithm

1) We first need to define a function `getSum(index, value)` to calculate the minimum sum of the array given `nums[index] = value`.
2) Initialize the search space `[left, right]`, set `left = 1` as it is the minimum possible value, set `right = maxSum` for it is the maximum possible value.
3) While `left < right`, get the middle index of the search space as `mid = (left + right + 1) / 2`, and check if `getSum(index, mid) <= maxSum`:
    - If so, it means that `nums[index] = mid` is a valid value, we can go for the right half by setting `left = mid`.
    - Otherwise, it means that `mid` is too large for `nums[index]`, we shall go for the left half of the searching space by setting `right = mid - 1`.
4) Return `left` once the binary search ends.

#### Implementation

[code](https://leetcode.com/playground/b56MT7KE/shared)


#### Complexity Analysis


* Time complexity: $$O(\log (\text{maxSum}))$$


    - We set the searching space as `[1, maxSum]`, thus it takes $$O(\log (\text{maxSum}))$$ steps to finish the binary search. 

    - At each step, we made some calculations that take $$O(1)$$ time.

* Space complexity: $$O(1)$$

    - Both the binary search and the `getSum` function take $$O(1)$$ space.


<br/>\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-161">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/description" target="_blank" rel="noopener noreferrer">Maximum White Tiles Covered by a Carpet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>tiles</code> where <code>tiles[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> represents that every tile <code>j</code> in the range <code>l<sub>i</sub> &lt;= j &lt;= r<sub>i</sub></code> is colored white.</p>

<p>You are also given an integer <code>carpetLen</code>, the length of a single carpet that can be placed <strong>anywhere</strong>.</p>

<p>Return <em>the <strong>maximum</strong> number of white tiles that can be covered by the carpet</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png" style="width: 644px; height: 158px;" />
<pre>
<strong>Input:</strong> tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
<strong>Output:</strong> 9
<strong>Explanation:</strong> Place the carpet starting on tile 10. 
It covers 9 white tiles, so we return 9.
Note that there may be other places where the carpet covers 9 white tiles.
It can be shown that the carpet cannot cover more than 9 white tiles.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png" style="width: 231px; height: 168px;" />
<pre>
<strong>Input:</strong> tiles = [[10,11],[1,1]], carpetLen = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Place the carpet starting on tile 10. 
It covers 2 white tiles, so we return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tiles.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>tiles[i].length == 2</code></li>
	<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= carpetLen &lt;= 10<sup>9</sup></code></li>
	<li>The <code>tiles</code> are <strong>non-overlapping</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-162">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/max-level-sum-in-binary-tree--170647/1" target="_blank" rel="noopener noreferrer">Max Level Sum in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a Binary Tree having positive and negative nodes. Find the maximum sum of a level in the given Binary Tree.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input :               </strong>
             4
          /    \
         2     -5
        / \    / \
      -1   3  -2  6</span>

<span style="font-size:18px"><strong>Output:</strong> 6</span>

<span style="font-size:18px"><strong>Explanation :</strong>
Sum of all nodes of 0&#39;th level is 4
Sum of all nodes of 1&#39;th level is -3
Sum of all nodes of 2&#39;th level is 6
Hence maximum sum is 6</span></pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input :          </strong>
            1
          /   \
         2     3
        / \     \
       4   5     8
                / \
               6   7  </span>

<span style="font-size:18px"><strong>Output : </strong> 17</span>

<span style="font-size:18px"><strong>Explanation: </strong>Maximum sum is at level 2.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task: &nbsp;</strong><br />
You dont need to read input or print anything. Complete the function <strong>maxLevelSum()</strong> which takes root node as input parameter and returns the maximum sum of any horizontal level in the given Binary Tree.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)</span>, <span style="font-size:18px">where N is no of node.</span><br />
<span style="font-size:18px"><strong>Expected Auxiliary Space:</strong> O(W), Where W is the max width of the tree.</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<sup>4</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-163">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/description" target="_blank" rel="noopener noreferrer">Max Sum of Rectangle No Larger Than K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> matrix <code>matrix</code> and an integer <code>k</code>, return <em>the max sum of a rectangle in the matrix such that its sum is no larger than</em> <code>k</code>.</p>

<p>It is <strong>guaranteed</strong> that there will be a rectangle with a sum no larger than <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" style="width: 255px; height: 176px;" />
<pre>
<strong>Input:</strong> matrix = [[1,0,1],[0,-2,3]], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[2,2,-1]], k = 3
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
	<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> What if the number of rows is much larger than the number of columns?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-164">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/median-in-a-row-wise-sorted-matrix1527/1" target="_blank" rel="noopener noreferrer">Median in a row-wise sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>row-wise sorted</strong> matrix&nbsp;</span><strong style="font-size: 18.6667px;">mat[][]</strong><span style="font-size: 14pt;"> of size n*m, where the number of rows and columns is always </span><strong style="font-size: 14pt;">odd</strong><span style="font-size: 14pt;">.&nbsp;Return the <strong>median</strong> of the matrix.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 3, 5], <br />                [2, 6, 9], <br />                [3, 6, 9]]
<strong>Output:</strong>&nbsp;5
<strong>Explanation</strong>: Sorting matrix elements gives us [1, 2, 3, 3, 5, 6, 6, 9, 9]. Hence, 5 is median.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[2, 4, 9],
                [3, 6, 7],
                [4, 7, 10]]
<strong>Output: </strong>6
<strong>Explanation</strong>: Sorting matrix elements gives us [2, 3, 4, 4, 6, 7, 7, 9, 10]. Hence, 6 is median.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat = [[3], [4], [8]]
<strong>Output: </strong>4
<strong>Explanation</strong>: Sorting matrix elements gives us [3, 4, 8]. Hence, 4 is median.<br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, m &le; 400<br />1 &le; mat[i][j] &le; 2000</span></p></div>
			</div>
			
			
		</div>



<div class="question-card" id="question-166">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-bsts-to-create-single-bst/description" target="_blank" rel="noopener noreferrer">Merge BSTs to Create Single BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>n</code> <strong>BST (binary search tree) root nodes</strong> for <code>n</code> separate BSTs stored in an array <code>trees</code> (<strong>0-indexed</strong>). Each BST in <code>trees</code> has <strong>at most 3 nodes</strong>, and no two roots have the same value. In one operation, you can:</p>

<ul>
	<li>Select two <strong>distinct</strong> indices <code>i</code> and <code>j</code> such that the value stored at one of the <strong>leaves </strong>of <code>trees[i]</code> is equal to the <strong>root value</strong> of <code>trees[j]</code>.</li>
	<li>Replace the leaf node in <code>trees[i]</code> with <code>trees[j]</code>.</li>
	<li>Remove <code>trees[j]</code> from <code>trees</code>.</li>
</ul>

<p>Return<em> the <strong>root</strong> of the resulting BST if it is possible to form a valid BST after performing </em><code>n - 1</code><em> operations, or</em><em> </em><code>null</code> <i>if it is impossible to create a valid BST</i>.</p>

<p>A BST (binary search tree) is a binary tree where each node satisfies the following property:</p>

<ul>
	<li>Every node in the node&#39;s left subtree has a value&nbsp;<strong>strictly less</strong>&nbsp;than the node&#39;s value.</li>
	<li>Every node in the node&#39;s right subtree has a value&nbsp;<strong>strictly greater</strong>&nbsp;than the node&#39;s value.</li>
</ul>

<p>A leaf is a node that has no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d1.png" style="width: 450px; height: 163px;" />
<pre>
<strong>Input:</strong> trees = [[2,1],[3,2,5],[5,4]]
<strong>Output:</strong> [3,2,5,1,null,4]
<strong>Explanation:</strong>
In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].
Delete trees[0], so trees = [[3,2,5,1],[5,4]].
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram.png" style="width: 450px; height: 181px;" />
In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].
Delete trees[1], so trees = [[3,2,5,1,null,4]].
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png" style="width: 220px; height: 165px;" />
The resulting tree, shown above, is a valid BST, so return its root.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d2.png" style="width: 450px; height: 171px;" />
<pre>
<strong>Input:</strong> trees = [[5,3,8],[3,2,6]]
<strong>Output:</strong> []
<strong>Explanation:</strong>
Pick i=0 and j=1 and merge trees[1] into trees[0].
Delete trees[1], so trees = [[5,3,8,2,6]].
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png" style="width: 240px; height: 196px;" />
The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d3.png" style="width: 430px; height: 168px;" />
<pre>
<strong>Input:</strong> trees = [[5,4],[3]]
<strong>Output:</strong> []
<strong>Explanation:</strong> It is impossible to perform any operations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == trees.length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The number of nodes in each tree is in the range <code>[1, 3]</code>.</li>
	<li>Each node in the input may have children but no grandchildren.</li>
	<li>No two roots of <code>trees</code> have the same value.</li>
	<li>All the trees in the input are <strong>valid BSTs</strong>.</li>
	<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-167">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description" target="_blank" rel="noopener noreferrer">Minimized Maximum of Products Distributed to Any Store</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> indicating there are <code>n</code> specialty retail stores. There are <code>m</code> product types of varying amounts, which are given as a <strong>0-indexed</strong> integer array <code>quantities</code>, where <code>quantities[i]</code> represents the number of products of the <code>i<sup>th</sup></code> product type.</p>

<p>You need to distribute <strong>all products</strong> to the retail stores following these rules:</p>

<ul>
	<li>A store can only be given <strong>at most one product type</strong> but can be given <strong>any</strong> amount of it.</li>
	<li>After distribution, each store will have been given some number of products (possibly <code>0</code>). Let <code>x</code> represent the maximum number of products given to any store. You want <code>x</code> to be as small as possible, i.e., you want to <strong>minimize</strong> the <strong>maximum</strong> number of products that are given to any store.</li>
</ul>

<p>Return <em>the minimum possible</em> <code>x</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 6, quantities = [11,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One optimal way is:
- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3
- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3
The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 7, quantities = [15,10,10]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One optimal way is:
- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5
- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5
- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5
The maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 1, quantities = [100000]
<strong>Output:</strong> 100000
<strong>Explanation:</strong> The only optimal way is:
- The 100000 products of type 0 are distributed to the only store.
The maximum number of products given to any store is max(100000) = 100000.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == quantities.length</code></li>
	<li><code>1 &lt;= m &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= quantities[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>quantities</code> of length <code>m</code>, where <code>quantities[i]</code> represents the number of products of the <code>i-th</code> type, and an integer <code>n</code> denotes the number of stores. Our task is to distribute the products among the stores such that each store only receives products of a single type, and we minimize the maximum number of products received by any store.</p>
<p>For example, consider <code>n = 6</code> and <code>quantities = [4, 3, 6, 2]</code>. A simple distribution might assign each product type to a separate store, as shown in the following picture:</p>
<p><img src="../Figures/2064/2064_wrong_distribution.png" alt="Wrong Distribution of Products" /></p>
<p>However, this leaves two stores unused, missing the opportunity to balance the load more effectively. A better strategy would be to distribute the products more evenly across all available stores as shown in the next picture, reducing the maximum number of products any store receives.</p>
<p><img src="../Figures/2064/2064_correct_distribution.png" alt="Correct Distribution of Products" /></p>
<hr />
<h3 id="approach-1-binary-search-on-the-answer">Approach 1: Binary Search on The Answer</h3>
<h4 id="intuition">Intuition</h4>
<p>To approach this problem, let’s first consider a slightly different question:</p>
<p>Given the parameters (<code>n</code> and <code>quantities</code>) and an additional integer <span class="math inline">\(x\)</span>, can we determine if it's possible to distribute the products such that no store receives more than <span class="math inline">\(x\)</span> products?</p>
<p>A natural approach is to assign products to stores while avoiding overloading any single store. As we allocate products, we keep track of how many products of each type remain and how many stores are still available. If we can distribute all products without exceeding the limit at any store, we confirm that distribution is possible; otherwise, it is not.</p>
<p>Now, how does this help with our original problem?</p>
<p>We want to find the smallest <span class="math inline">\(x\)</span> for which such a valid distribution exists, ensuring no store gets more than <span class="math inline">\(x\)</span> products. Notice that for any <span class="math inline">\(x \geq \max(\text{quantities}[i])\)</span>, the answer is trivially true because each store could handle just one type of product. A naive approach would be to linearly search for the smallest <span class="math inline">\(x\)</span> in the range <span class="math inline">\([0, \max(\text{quantities}[i])]\)</span> where the distribution is valid. However, this would result in a time limit exceeded (TLE) error for larger inputs.</p>
<p>To optimize, we leverage the problem's monotonic property: if a distribution is possible for a certain <span class="math inline">\(x\)</span>, it will be possible for any <span class="math inline">\(x' > x\)</span>. Conversely, if it’s not possible for <span class="math inline">\(x\)</span>, it won’t be for any <span class="math inline">\(x' < x\)</span>. This allows us to apply Binary Search to efficiently find the smallest valid <span class="math inline">\(x\)</span>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a function <code>canDistribute</code>, which takes an integer <code>x</code>, the <code>quantities</code> array, and <code>n</code> as parameters and returns a boolean, indicating whether it’s possible to distribute the products such that no store receives more than <code>x</code> products.
<ul>
<li>Initialize a pointer to track the first product type that has not been fully distributed: <code>j = 0</code></li>
<li>Initialize <code>remaining</code> to the quantity of the first product type.</li>
<li>Loop through each store with <code>i</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Check if you can fully distribute to this store the remaining quantity of the <code>jth</code> product (<code>remaining</code> <span class="math inline">\(\leq\)</span> <code>x</code>):
<ul>
<li>If so:
<ul>
<li>Increment <code>j</code> to the next product type.</li>
<li>Check if all products have been distributed (<code>j == m</code>):
<ul>
<li>If so, return <code>true</code>.</li>
<li>Else, set <code>remaining = quantities[j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Otherwise, distribute the maximum possible to the store, which is <code>x</code>, and reduce the remaining quantity of the <code>jth</code> type.</li>
</ul>
</li>
</ul>
</li>
<li>If the loop ends without having distributed all products, return <code>false</code>.</li>
</ul>
</li>
<li>In the <code>minimizedMaximum</code> main function:
<ul>
<li>Initialize the boundaries of the binary search: <code>left = 0</code> and <code>right = max(quantities[i])</code>.</li>
<li>While <code>left &lt; right</code>:
<ul>
<li>Set <code>middle = (left + right) / 2</code>.</li>
<li>Check whether products can be distributed with no store receiving more than <code>middle</code> products, using the <code>canDistribute</code> function.
<ul>
<li>If this condition is <code>true</code>, set <code>right = middle</code>.</li>
<li>Otherwise, set <code>left = middle + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>When the loop ends, <code>left == right</code>, so return <code>left</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/SFny3423/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(k\)</span> be the maximum value in the <code>quantities</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(nlogk)\)</span></p>
<p>The <code>canDistribute</code> function iterates through the <code>n</code> stores, executing constant-time operations during each iteration. As a result, its time complexity is <span class="math inline">\(O(n)\)</span>.<br />
The main function, <code>minimizedMaximum</code>, performs a binary search over the range <span class="math inline">\((0, k)\)</span>, calling in each iteration the <code>canDistribute</code> function. Since the binary search runs in <span class="math inline">\(O(logk)\)</span> time, the overall time complexity of the <code>minimizedMaximum</code> function is <span class="math inline">\(O(nlogk)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use a fixed number of integer variables, which doesn't depend on the input size.</p>
<h6 id="comments-on-space-efficiency-and-in-place-algorithms">Comments on space efficiency and in-place algorithms</h6>
<p>This problem illustrates why modifying input directly inside a helper function is not always appropriate. If we had altered the quantities array itself by decrementing the remaining quantity of each product type, rather than using the <code>remaining</code> variable, the algorithm would fail. This is because the binary search relies on the quantities array remaining unchanged throughout its execution.<br />
<br> One solution would be to pass the quantities array by <strong>value</strong> — essentially creating a copy of the array every time the <code>canDistribute</code> function is called. This could be done manually or by leveraging language-specific features. However, this approach would increase the overall space complexity to <span class="math inline">\(O(n)\)</span>, due to the repeated copying of the array.<br />
<br>Instead, we avoid this overhead by recognizing that, in each iteration of the <code>canDistribute</code> function, we only need access to one element of the quantities array: the first product type that hasn’t been fully distributed yet. By storing this value in the <code>remaining</code> variable, we maintain constant space complexity, while ensuring that the algorithm works correctly without altering the original input.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-greedy-approach-using-a-heap">Approach 2: Greedy Approach Using a Heap</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The key idea of this approach is to assign stores to product types in an optimal way, rather than assigning products to stores. Initially, each product type is assigned one store, which is guaranteed by the constraint <span class="math inline">\(m \leq n\)</span>. After this, we focus on which product types should receive additional stores. The algorithm greedily selects the product type <code>i</code> with the highest ratio of <code>quantity[i]</code> to <code>assigned_stores[i]</code>, assigning the next available store to that product type.</p>
<p>Since we need to repeatedly access the product type with the highest ratio and update the ratios as stores are assigned, a priority queue (max-heap) is useful for efficiently managing these operations.</p>
<h6 id="proof-of-correctness">Proof of Correctness</h6>
<p>Consider an arbitrary distribution of stores to products, represented as <span class="math inline">\([s_0, s_1, s_2, \dots, s_{m-1}]\)</span>, where <span class="math inline">\(s_i\)</span> denotes the number of stores assigned to the <span class="math inline">\(i\)</span>-th product type. The specific indices of stores assigned or the order of assignment don’t affect the result.</p>
<p>To minimize the load on any single store, the products of type <span class="math inline">\(i\)</span> should be distributed as evenly as possible across its <span class="math inline">\(s_i\)</span> assigned stores. This ensures that each store handling products of type <span class="math inline">\(i\)</span> will have no more than <span class="math inline">\(\left\lceil \frac{\text{quantities}\_i}{s_i} \right\rceil\)</span> products.</p>
<p>Thus, our objective is to minimize the maximum number of products any store receives. The function should return:</p>
<p><span class="math display">\[\begin{aligned}
    f(i) &= \max_{i \in [0, m-1]} \left\lceil \frac{\text{quantities}_i}{s_i} \right\rceil
\end{aligned}
\]</span></p>
<p>Now, consider the greedy approach: If at any point in the algorithm, we fail to assign the next available store to the product type with the highest ratio <code>quantity[i]</code> to <code>assigned_stores[i]</code>, that ratio will remain the largest, leading to a non-optimal distribution. This would cause the highest ratio to dominate, violating our goal of minimizing the maximum number of products per store.</p>
<p>To gain a better understanding of the algorithm, let’s revisit our initial example with <code>n = 6</code> and <code>quantities = [4, 3, 6, 2]</code>.</p>
<p>!?!../Documents/2064/2064_Approach2.json:960,540!?!</p>
<br/>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Create an array of pairs, <code>typeStorePairsArray</code>, to store pairs of integers, where each pair represents the total quantity of a product type and the number of stores currently assigned to it. This array will help us initialize efficiently the priority queue.</p>
</li>
<li>
<p>Initialize a priority queue (max-heap) named <code>typeStorePairs</code>, using <code>typeStorePairsArray</code>, that sorts its elements by the ratio of their first to their second value.</p>
</li>
<li>
<p>Loop with <code>i</code> ranging from <code>0</code> to <code>n - m - 1</code>:</p>
<ul>
<li>Pop the element with the highest ratio from the priority queue, denoted as <code>pairWithMaxRatio = [totalQuantityOfType, storesAssignedToType]</code>.</li>
<li>Push the element back into the heap, now assigning it an additional store: push <code>[totalQuantityOfType, storesAssignedToType + 1]</code>.</li>
</ul>
</li>
<li>
<p>After the loop, pop the element with the highest ratio again, denoted as <code>pairWithMaxRatio = [totalQuantityOfType, storesAssignedToType]</code>.</p>
</li>
<li>
<p>Finally, return <code>ceil(totalQuantityOfType / storesAssignedToType)</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/fsNCGucz/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + (n - m)logm)\)</span></p>
<p>We first iterate over the <code>quantities</code> array, pushing each value as the first element of a pair into the helper array. This operation takes <span class="math inline">\(O(m)\)</span> time.</p>
<p>We then initialize a priority queue (heap) using the elements from the array. Building the heap takes <span class="math inline">\(O(m)\)</span> time because heapify is performed in linear time.</p>
<p>After that, we enter a second loop that runs <span class="math inline">\(n - m\)</span> times. In each iteration, we perform one pop and one push operation on the priority queue. Both operations take <span class="math inline">\(O(\log m)\)</span> time, so this loop has a total time complexity of <span class="math inline">\(O((n - m) \log m)\)</span>.</p>
<p>Combining the time complexities of the initialization, heap construction, and store allocation, the overall time complexity of the algorithm is: <span class="math inline">\(O(m + (n - m)logm)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The priority queue has a size of <code>m</code> since each value of the <code>quantities</code> array is inserted as the first element of exactly one <code>typeSortPair</code>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-168">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-maximum-component-cost/description" target="_blank" rel="noopener noreferrer">Minimize Maximum Component Cost</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="331" data-start="85">You are given an undirected connected graph with <code data-end="137" data-start="134">n</code> nodes labeled from 0 to <code data-end="171" data-start="164">n - 1</code> and a 2D integer array <code data-end="202" data-start="195">edges</code> where <code data-end="234" data-start="209">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> denotes an undirected edge between node <code data-end="279" data-start="275">u<sub>i</sub></code> and node <code data-end="293" data-start="289">v<sub>i</sub></code> with weight <code data-end="310" data-start="306">w<sub>i</sub></code>, and an integer <code data-end="330" data-start="327">k</code>.</p>

<p data-end="461" data-start="333">You are allowed to remove any number of edges from the graph such that the resulting graph has <strong>at most</strong> <code data-end="439" data-start="436">k</code> connected components.</p>

<p data-end="589" data-start="463">The <strong>cost</strong> of a component is defined as the <strong>maximum</strong> edge weight in that component. If a component has no edges, its cost is 0.</p>

<p data-end="760" data-start="661">Return the <strong>minimum</strong> possible value of the <strong>maximum</strong> cost among all components <strong data-end="759" data-start="736">after such removals</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minimizemaximumm.jpg" style="width: 535px; height: 225px;" /></p>

<ul>
	<li data-end="1070" data-start="1021">Remove the edge between nodes 3 and 4 (weight 6).</li>
	<li data-end="1141" data-start="1073">The resulting components have costs of 0 and 4, so the overall maximum cost is 4.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minmax2.jpg" style="width: 315px; height: 55px;" /></p>

<ul>
	<li data-end="1315" data-start="1251">No edge can be removed, since allowing only one component (<code>k = 1</code>) requires the graph to stay fully connected.</li>
	<li data-end="1389" data-start="1318">That single component&rsquo;s cost equals its largest edge weight, which is 5.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li>The input graph is connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-169">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-maximum-of-array/description" target="_blank" rel="noopener noreferrer">Minimize Maximum of Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> comprising of <code>n</code> non-negative integers.</p>

<p>In one operation, you must:</p>

<ul>
	<li>Choose an integer <code>i</code> such that <code>1 &lt;= i &lt; n</code> and <code>nums[i] &gt; 0</code>.</li>
	<li>Decrease <code>nums[i]</code> by 1.</li>
	<li>Increase <code>nums[i - 1]</code> by 1.</li>
</ul>

<p>Return<em> the <strong>minimum</strong> possible value of the <strong>maximum</strong> integer of </em><code>nums</code><em> after performing <strong>any</strong> number of operations</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,7,1,6]
<strong>Output:</strong> 5
<strong>Explanation:</strong>
One set of optimal operations is as follows:
1. Choose i = 1, and nums becomes [4,6,1,6].
2. Choose i = 3, and nums becomes [4,6,2,5].
3. Choose i = 1, and nums becomes [5,5,2,5].
The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.
Therefore, we return 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,1]
<strong>Output:</strong> 10
<strong>Explanation:</strong>
It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-170">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-maximum-adjacent-element-difference/description" target="_blank" rel="noopener noreferrer">Minimize the Maximum Adjacent Element Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code>. Some values in <code>nums</code> are <strong>missing</strong> and are denoted by -1.</p>

<p>You must choose a pair of <strong>positive</strong> integers <code>(x, y)</code> <strong>exactly once</strong> and replace each <strong>missing</strong> element with <em>either</em> <code>x</code> or <code>y</code>.</p>

<p>You need to <strong>minimize</strong><strong> </strong>the<strong> maximum</strong> <strong>absolute difference</strong> between <em>adjacent</em> elements of <code>nums</code> after replacements.</p>

<p>Return the <strong>minimum</strong> possible difference.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,-1,10,8]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>By choosing the pair as <code>(6, 7)</code>, nums can be changed to <code>[1, 2, 6, 10, 8]</code>.</p>

<p>The absolute differences between adjacent elements are:</p>

<ul>
	<li><code>|1 - 2| == 1</code></li>
	<li><code>|2 - 6| == 4</code></li>
	<li><code>|6 - 10| == 4</code></li>
	<li><code>|10 - 8| == 2</code></li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-1,-1,-1]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>By choosing the pair as <code>(4, 4)</code>, nums can be changed to <code>[4, 4, 4]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-1,10,-1,8]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>By choosing the pair as <code>(11, 9)</code>, nums can be changed to <code>[11, 10, 9, 8]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> is either -1 or in the range <code>[1, 10<sup>9</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-171">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description" target="_blank" rel="noopener noreferrer">Minimize the Maximum Difference of Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>p</code>. Find <code>p</code> pairs of indices of <code>nums</code> such that the <strong>maximum</strong> difference amongst all the pairs is <strong>minimized</strong>. Also, ensure no index appears more than once amongst the <code>p</code> pairs.</p>

<p>Note that for a pair of elements at the index <code>i</code> and <code>j</code>, the difference of this pair is <code>|nums[i] - nums[j]|</code>, where <code>|x|</code> represents the <strong>absolute</strong> <strong>value</strong> of <code>x</code>.</p>

<p>Return <em>the <strong>minimum</strong> <strong>maximum</strong> difference among all </em><code>p</code> <em>pairs.</em> We define the maximum of an empty set to be zero.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,1,2,7,1,3], p = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,1,2], p = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Since this problem involves minimizing the &quot;maximum difference,&quot; it is necessary to sort the array beforehand. This way, we can narrow down the selection of pairs to only adjacent numbers, and avoid wasting time on incorrect choices.</p>
<p><img src="../Figures/2616/1.png" alt="img" /></p>
<p>As shown in the diagram below, without sorting, we might inadvertently select pairs with larger differences. By sorting the array, we eliminate such scenarios.</p>
<p><img src="../Figures/2616/2.png" alt="img" /></p>
<hr />
<h3 id="approach-greedy--binary-search">Approach: Greedy + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with binary search, please refer to our explore cards <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>Since we are looking to <strong>minimize</strong> the maximum difference, one brute force approach is to start from a <strong>threshold</strong> (a maximum difference) of <code>0</code> and incrementally try all possible thresholds:</p>
<ul>
<li>
<p>try to find <code>p</code> pairs with a difference less than or equal to <code>0</code>.</p>
</li>
<li>
<p>if not possible, try to find <code>p</code> pairs with a difference less than or equal to <code>1</code>.</p>
</li>
<li>
<p>and so on, until we find a threshold that succeeds.</p>
</li>
</ul>
<p><img src="../Figures/2616/5.png" alt="img" /></p>
<p>However, as you may have noticed, this approach requires trying a linear number of thresholds, which is inefficient.</p>
<p>We observe that:</p>
<ul>
<li>
<p>If we can find <code>p</code> pairs with a threshold of <code>x</code>, then we can certainly find <code>p</code> pairs with a threshold of <code>x + 1</code>. A trivial example would be to just use the exact same <code>p</code> pairs. As their differences are less than <code>x</code>, they must also be less than <code>x + 1</code>.</p>
</li>
<li>
<p>If we cannot find <code>p</code> pairs with a threshold of <code>x</code>, then we certainly cannot find <code>p</code> pairs with a threshold of <code>x - 1</code>.</p>
</li>
</ul>
<p>This splits the number line into two sections: one section where the task is possible, and one where the task is impossible. Therefore, we can use binary search to quickly narrow down the search space until we find the dividing point, which is the minimum threshold.</p>
<br>
<p>Now let's address the second question: given <code>threshold</code>, how do we determine if there exist at least <code>p</code> valid pairs?</p>
<p>We can solve this using a greedy approach, by iterating through the sorted <code>nums</code> and checking the difference between <code>nums[i]</code> and <code>nums[i + 1]</code>. If the difference is less than or equal to the threshold, it means that <code>nums[i]</code> and <code>nums[i + 1]</code> form a valid pair, and we can directly move to <code>i + 2</code> to find the next pair.</p>
<p>However, you might wonder why the greedy approach works. Is there a possibility that the greedy approach fails while another approach succeeds?</p>
<p><img src="../Figures/2616/3.png" alt="img" /></p>
<p><strong>The answer is No! Greedy approach always brings the most number of valid pairs.</strong></p>
<p>Here we provide a brief explanation: Recall that in the greedy approach, we traverse the array in ascending order. Suppose there is another alternative approach that yields more valid pairs compared to the greedy approach. We can align the arrays of these two approaches side by side and traverse them together in ascending order until the first point of divergence.</p>
<p>Since the greedy approach always selects the &quot;leftmost&quot; pair, when a divergence occurs, the pair from the alternative approach must be &quot;to the right.&quot; Let's assume these pairs as <code>(i - 1, i)</code> and <code>(i, i + 1)</code> respectively. As shown in the picture above.</p>
<p>So far, both approaches have selected an equal number of valid pairs in subarrays <code>nums[0 ~ i]</code> and <code>nums[0 ~ i + 1]</code>, respectively. However, the remaining subarray of the greedy approach (<code>nums[i+1 ~ n-1]</code>) is longer, providing more choices. Thus the valid pairs (if exist) selected from this remaining subarray are guaranteed to be greater than or equal to the pairs from the remaining portion of the alternative approach (<code>nums[i+2 ~ n-1]</code>).</p>
<p><img src="../Figures/2616/4.png" alt="img" /></p>
<p>This implies that even if we do not use the greedy approach, the number of valid pairs we can select will not exceed the number of pairs selected using the greedy approach. <strong>The greedy approach will always yield the maximum number of valid pairs.</strong></p>
<br>
<h4 id="algorithm">Algorithm</h4>
<blockquote>
<p>Note: the typical way to calculate mid is (left + right) / 2. However, a safer way is left + (right - left) / 2. The two equations are equivalent, but the second one is safer because it guarantees no number larger than right is ever stored. In the first equation, if left + right is huge, then it could end up overflowing.</p>
</blockquote>
<ol>
<li>
<p>Define <code>countValidPairs(threshold)</code> to find the number of pairs having a threshold of <code>threshold</code> in <code>nums</code>. Let <code>n</code> be the size of <code>nums</code>.</p>
<ul>
<li>Set <code>count = 0</code>.</li>
<li>Iterate over <code>nums</code> from <code>index = 0</code> to <code>index = n - 2</code>. If <code>nums[index + 1] - nums[index] &lt;= threshold</code>, increment <code>count</code> by <code>1</code>, and skip both indices. Otherwise, skip the current index.</li>
<li>Return <code>count</code>.</li>
</ul>
</li>
<li>
<p>Sort <code>nums</code>.</p>
</li>
<li>
<p>Initialize the searching space as <code>left = 0</code> and <code>right = nums[n - 1] - nums[0]</code>, the maximum difference in the array.</p>
</li>
<li>
<p>While <code>left &lt; right</code>, do the following:</p>
</li>
<li>
<p>Get the middle value as <code>mid = left + (right - left) // 2</code>.</p>
</li>
<li>
<p>Calculate the number of valid pairs with a threshold of <code>mid</code> using <code>countValidPairs(mid)</code>.</p>
</li>
<li>
<p>If <code>countValidPairs(mid) &gt;= p</code>, continue with the left half by setting <code>right = mid</code>. Otherwise, continue with the right half by setting <code>left = mid - 1</code>. Repeat from step 4.</p>
</li>
<li>
<p>Return <code>left</code> when the binary search is complete.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/J7Y3jEWR/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>nums</code> and <code>V</code> be the maximum value in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot\log V + n \cdot\log n)\)</span></p>
<ul>
<li>Sorting <code>nums</code> takes <span class="math inline">\(O(n \cdot\log n)\)</span> time.</li>
<li>The right boundary of the searching space is defined as <code>nums[n - 1] - nums[0]</code>, the maximum value minus the minimum value, which is <span class="math inline">\(O(V)\)</span>. Thus the binary search takes <span class="math inline">\(O(\log V)\)</span> steps.</li>
<li>At each step, we need to iterate over <code>nums</code> to determine if there are at least <code>p</code> pairs, which takes <span class="math inline">\(O(n)\)</span> time. Therefore the binary search takes <span class="math inline">\(O(n \cdot\log V)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We only need to update several parameters, <code>left</code>, <code>right</code>, <code>index</code>, and <code>count</code>, which takes <span class="math inline">\(O(1)\)</span> space.</li>
<li>Some extra space is used when we sort <span class="math inline">\(\text{nums}\)</span> in place. The space complexity of the sorting algorithm depends on the programming language.
<ul>
<li>In python, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
</ul>
</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n)\)</span> for Python and <span class="math inline">\(O(\log n)\)</span> for C++ and Java.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-172">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/description" target="_blank" rel="noopener noreferrer">Minimize the Maximum Edge Weight of Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers, <code>n</code> and <code>threshold</code>, as well as a <strong>directed</strong> weighted graph of <code>n</code> nodes numbered from 0 to <code>n - 1</code>. The graph is represented by a <strong>2D</strong> integer array <code>edges</code>, where <code>edges[i] = [A<sub>i</sub>, B<sub>i</sub>, W<sub>i</sub>]</code> indicates that there is an edge going from node <code>A<sub>i</sub></code> to node <code>B<sub>i</sub></code> with weight <code>W<sub>i</sub></code>.</p>

<p>You have to remove some edges from this graph (possibly <strong>none</strong>), so that it satisfies the following conditions:</p>

<ul>
	<li>Node 0 must be reachable from all other nodes.</li>
	<li>The <strong>maximum</strong> edge weight in the resulting graph is <strong>minimized</strong>.</li>
	<li>Each node has <strong>at most</strong> <code>threshold</code> outgoing edges.</li>
</ul>

<p>Return the <strong>minimum</strong> possible value of the <strong>maximum</strong> edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s-1.png" style="width: 300px; height: 233px;" /></p>

<p>Remove the edge <code>2 -&gt; 0</code>. The maximum weight among the remaining edges is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>It is impossible to reach node 0 from node 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s2-1.png" style="width: 300px; height: 267px;" /></p>

<p>Remove the edges <code>1 -&gt; 3</code> and <code>1 -&gt; 4</code>. The maximum weight among the remaining edges is 2.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= threshold &lt;= n - 1</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2).</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= A<sub>i</sub>, B<sub>i</sub> &lt; n</code></li>
	<li><code>A<sub>i</sub> != B<sub>i</sub></code></li>
	<li><code>1 &lt;= W<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>There <strong>may be</strong> multiple edges between a pair of nodes, but they must have unique weights.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-173">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-maximum-of-two-arrays/description" target="_blank" rel="noopener noreferrer">Minimize the Maximum of Two Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We have two arrays <code>arr1</code> and <code>arr2</code> which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:</p>

<ul>
	<li><code>arr1</code> contains <code>uniqueCnt1</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code>divisor1</code>.</li>
	<li><code>arr2</code> contains <code>uniqueCnt2</code> <strong>distinct</strong> positive integers, each of which is <strong>not divisible</strong> by <code>divisor2</code>.</li>
	<li><strong>No</strong> integer is present in both <code>arr1</code> and <code>arr2</code>.</li>
</ul>

<p>Given <code>divisor1</code>, <code>divisor2</code>, <code>uniqueCnt1</code>, and <code>uniqueCnt2</code>, return <em>the <strong>minimum possible maximum</strong> integer that can be present in either array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
We can distribute the first 4 natural numbers into arr1 and arr2.
arr1 = [1] and arr2 = [2,3,4].
We can see that both arrays satisfy all the conditions.
Since the maximum value is 4, we return it.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
Since the maximum value is 3, we return it.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
<strong>Output:</strong> 15
<strong>Explanation:</strong> 
Here, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].
It can be shown that it is not possible to obtain a lower maximum satisfying all conditions. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= divisor1, divisor2 &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= uniqueCnt1, uniqueCnt2 &lt; 10<sup>9</sup></code></li>
	<li><code>2 &lt;= uniqueCnt1 + uniqueCnt2 &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-174">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-absolute-difference-between-elements-with-constraint/description" target="_blank" rel="noopener noreferrer">Minimum Absolute Difference Between Elements With Constraint</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">ordered set</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>x</code>.</p>

<p>Find the <strong>minimum absolute difference</strong> between two elements in the array that are at least <code>x</code> indices apart.</p>

<p>In other words, find two indices <code>i</code> and <code>j</code> such that <code>abs(i - j) &gt;= x</code> and <code>abs(nums[i] - nums[j])</code> is minimized.</p>

<p>Return<em> an integer denoting the <strong>minimum</strong> absolute difference between two elements that are at least</em> <code>x</code> <em>indices apart</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,4], x = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> We can select nums[0] = 4 and nums[3] = 4. 
They are at least 2 indices apart, and their absolute difference is the minimum, 0. 
It can be shown that 0 is the optimal answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,2,10,15], x = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can select nums[1] = 3 and nums[2] = 2.
They are at least 1 index apart, and their absolute difference is the minimum, 1.
It can be shown that 1 is the optimal answer.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], x = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can select nums[0] = 1 and nums[3] = 4.
They are at least 3 indices apart, and their absolute difference is the minimum, 3.
It can be shown that 3 is the optimal answer.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= x &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-175">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-absolute-sum-difference/description" target="_blank" rel="noopener noreferrer">Minimum Absolute Sum Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integer arrays <code>nums1</code> and <code>nums2</code>, both of length <code>n</code>.</p>

<p>The <strong>absolute sum difference</strong> of arrays <code>nums1</code> and <code>nums2</code> is defined as the <strong>sum</strong> of <code>|nums1[i] - nums2[i]|</code> for each <code>0 &lt;= i &lt; n</code> (<strong>0-indexed</strong>).</p>

<p>You can replace <strong>at most one</strong> element of <code>nums1</code> with <strong>any</strong> other element in <code>nums1</code> to <strong>minimize</strong> the absolute sum difference.</p>

<p>Return the <em>minimum absolute sum difference <strong>after</strong> replacing at most one<strong> </strong>element in the array <code>nums1</code>.</em> Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p><code>|x|</code> is defined as:</p>

<ul>
	<li><code>x</code> if <code>x &gt;= 0</code>, or</li>
	<li><code>-x</code> if <code>x &lt; 0</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,7,5], nums2 = [2,3,5]
<strong>Output:</strong> 3
<strong>Explanation: </strong>There are two possible optimal solutions:
- Replace the second element with the first: [1,<u><strong>7</strong></u>,5] =&gt; [1,<u><strong>1</strong></u>,5], or
- Replace the second element with the third: [1,<u><strong>7</strong></u>,5] =&gt; [1,<u><strong>5</strong></u>,5].
Both will yield an absolute sum difference of <code>|1-2| + (|1-3| or |5-3|) + |5-5| = </code>3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
<strong>Output:</strong> 0
<strong>Explanation: </strong>nums1 is equal to nums2 so no replacement is needed. This will result in an 
absolute sum difference of 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
<strong>Output:</strong> 20
<strong>Explanation: </strong>Replace the first element with the second: [<u><strong>1</strong></u>,10,4,4,2,7] =&gt; [<u><strong>10</strong></u>,10,4,4,2,7].
This yields an absolute sum difference of <code>|10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20</code>
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length</code></li>
	<li><code>n == nums2.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-176">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-array-length-after-pair-removals/description" target="_blank" rel="noopener noreferrer">Minimum Array Length After Pair Removals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>num</code> sorted in non-decreasing order.</p>

<p>You can perform the following operation any number of times:</p>

<ul>
	<li>Choose <strong>two</strong> indices, <code>i</code> and <code>j</code>, where <code>nums[i] &lt; nums[j]</code>.</li>
	<li>Then, remove the elements at indices <code>i</code> and <code>j</code> from <code>nums</code>. The remaining elements retain their original order, and the array is re-indexed.</li>
</ul>

<p>Return the <strong>minimum</strong> length of <code>nums</code> after applying the operation zero or more times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/18/tcase1.gif" style="width: 160px; height: 70px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2,2,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/tcase2.gif" style="width: 240px; height: 70px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1000000000,1000000000]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Since both numbers are equal, they cannot be removed.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4,4,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/tcase3.gif" style="width: 210px; height: 70px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-177">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-common-value/description" target="_blank" rel="noopener noreferrer">Minimum Common Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in non-decreasing order, return <em>the <strong>minimum integer common</strong> to both arrays</em>. If there is no common integer amongst <code>nums1</code> and <code>nums2</code>, return <code>-1</code>.</p>

<p>Note that an integer is said to be <strong>common</strong> to <code>nums1</code> and <code>nums2</code> if both arrays have <strong>at least one</strong> occurrence of that integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3], nums2 = [2,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The smallest element common to both arrays is 2, so we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,6], nums2 = [2,3,4,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>
	<li>Both <code>nums1</code> and <code>nums2</code> are sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given the arrays <code>nums1</code> and <code>nums2</code>, we aim to find the minimum integer common to both arrays. <code>nums1</code> and <code>nums2</code> are both sorted in increasing order. If there is no common integer, return <code>-1</code>.</p>
<p>A common value between two arrays appears in both arrays at least once.</p>
<hr />
<h3 id="approach-1-hash-set">Approach 1: Hash Set</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force approach to solving this problem would be to use nested loops to iterate through each number in each array, searching for common values, and then calculate the minimum of the common values. Nested loops are inefficient. It would be helpful if, instead of searching through an array to find a value, we could look up an element in constant time. Hash tables are a data structure that facilitate constant time lookups.</p>
<p>There are two main kinds of hash tables: hash maps, which store (key, value) pairs, and hash sets, which store unique values. For this problem, we chose a hash set because we are concerned with whether an element exists, not the number of times it occurs. A hashmap could alternatively be used to solve this problem, where the element is the key and the frequency is the value. Check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">hash table explore card</a> to learn more about hash tables.</p>
<p>We can add the elements in <code>nums1</code> to a hash set <code>set1</code>, where the element is the key.</p>
<p>Then, we can loop through <code>nums2</code>, and check whether each element is in <code>set1</code>. Since <code>nums2</code> is in sorted order, the first common element we find is the minimum common element.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a set <code>set1</code> and add the elements from <code>nums1</code>.</li>
<li>For each <code>num</code> in <code>nums2</code>:
<ul>
<li>If <code>num</code> is in <code>set1</code>, return <code>num</code>. We found a common element. Since <code>nums2</code> is sorted in ascending order, the first common element is the minimum common element.</li>
</ul>
</li>
<li>Return <code>-1</code> if there are no common elements.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/gEWsehHy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums1</code> and <span class="math inline">\(m\)</span> be the length of <code>nums2.</code></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Creating <code>set1</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>We search for each element of <code>nums2</code> in <code>set1</code>. Searching for an element in a hash set takes <span class="math inline">\(O(1)\)</span> on average, so the time complexity of this step is <span class="math inline">\(O(m)\)</span>.</p>
<p>The total time complexity will be <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We initialize the set <code>set1</code>, which is size <span class="math inline">\(O(e)\)</span> where <span class="math inline">\(e\)</span> is the number of distinct elements in <code>nums1</code>. At worst, there can be <span class="math inline">\(n\)</span> distinct elements, so the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<h5 id="set-intersection">Set Intersection</h5>
<p>Note that given two sets, their intersection is all of their common elements. Another approach to solving this problem would be to create sets out of <code>nums1</code> and <code>nums2</code>, then find the minimum value of the intersection. Below is the Python3 code for this approach. This approach is less straightforward for languages that do not have built-in set functions and requires more space than the other approaches without an improvement in time complexity, so it is not discussed in depth.</p>
<p><a href="https://leetcode.com/playground/SLacCfPL/shared">code</a></p>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our objective is to find the minimum common value between two arrays. As discussed previously, the brute force approach would be to iterate through both arrays, searching for common values. This approach would be inefficient, with a time complexity of <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>Can we develop a more efficient approach without using extra space?</p>
<p>Let's look at some examples to develop a strategy.</p>
<h5 id="example-1">Example 1:</h5>
<blockquote>
<p><strong>Input:</strong> nums1 = [1, 2, 3, 4, 5], nums2 = [1, 3, 5]</p>
<p><strong>Output:</strong> 1</p>
<p><strong>Explanation:</strong> There are three common elements in the arrays, 1, 3, and 5, out of which 1 is the smallest, so 1 is returned.</p>
</blockquote>
<h5 id="example-2">Example 2:</h5>
<blockquote>
<p><strong>Input:</strong> nums1 = [2, 4, 6, 8, 10], nums2 = [1, 2, 3, 4, 5]</p>
<p><strong>Output:</strong> 2</p>
<p><strong>Explanation:</strong> There are two common elements in the arrays, 2, and 4, out of which 2 is the smallest, so 2 is returned.</p>
</blockquote>
<p>What patterns can we deduce from examining these examples?</p>
<p>Notice that since the arrays are sorted, and our objective is to find the minimum common value, the first common value we find when traversing both arrays left to right is the minimum common value.</p>
<p>We can leverage this fact to develop an efficient solution.</p>
<p>We can use two pointers to traverse both arrays simultaneously without a nested loop.</p>
<p><code>first</code> will indicate the position in <code>nums1</code>, and <code>second</code> will indicate the position in <code>nums2</code>.</p>
<p>During each iteration, we compare the values of <code>nums1[first]</code> and <code>nums2[second]</code>. There are three possibilities.</p>
<ol>
<li>
<p>The elements are equal. We have found a common value, and we return it.</p>
</li>
<li>
<p><code>nums1[first] &lt; nums2[second]</code>. Because <code>nums2</code> is sorted, every element after <code>second</code> will also be greater than <code>nums1[first]</code>. However, there is a chance that an element in <code>nums1</code> after <code>first</code> will be equal to <code>nums2[second]</code>. Thus, we should increment <code>first</code>.</p>
</li>
<li>
<p><code>nums1[first] &gt; nums2[second]</code>. The logic works the other way visa versa. We should increment <code>second</code>.</p>
</li>
</ol>
<p>By traversing the arrays in this manner, we will find the first common value, if it exists.</p>
<blockquote>
<p>How do we know this approach will consistently provide the correct solution?</p>
<p>We always increment the pointer which points to the lower value. This means we will process all the elements from both arrays in ascending order.</p>
<p>Our algorithm stops in three cases:</p>
<ol>
<li>
<p>A common element is found: it must be the minimum common value because elements are processed in order.</p>
</li>
<li>
<p>Both pointers reach the end of their array: all elements were checked, and there were no common values.</p>
</li>
<li>
<p>One pointer reaches the end of its array, and the element it points to is less than the current element in the other array: all remaining elements in the other array are larger than this element, so there are no common elements.</p>
</li>
</ol>
</blockquote>
<p>Below is a visualization of this algorithm:</p>
<p>!?!../Documents/2540/2540_slideshow.json:960,540!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize two variables: <code>first</code>, which will store the position in <code>nums1</code>, and <code>second</code>, which will store the position in <code>nums2</code> to <code>0</code>, the starting index.</li>
<li>Iterate through <code>nums1</code> and <code>nums2</code> while <code>first</code> is less than the size of <code>nums1</code> and <code>second</code> is less than the size of <code>nums2</code>:
<ul>
<li>If <code>nums1[first]</code> is less than <code>nums2[second]</code>, increment <code>first</code> by <code>1</code> because we need a larger value from <code>nums1</code> to match the value at <code>nums2[second]</code>.</li>
<li>If <code>nums1[first]</code> is greater than <code>nums2[second]</code>, increment <code>second</code> by <code>1</code> because we need a larger value from <code>nums2</code> to match the value at <code>nums1[first]</code>.</li>
<li>Otherwise, <code>nums1[first]</code> must equal <code>nums2[second]</code>, so return the value of <code>nums1[first]</code>. We have found the minimum common value.</li>
</ul>
</li>
<li>Return <code>-1</code> if the loop completes without returning an answer. This means there is no common value between <code>nums1</code> and <code>nums2</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/L8ASNvpL/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums1</code> and <span class="math inline">\(m\)</span> be the length of <code>nums2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We iterate through <code>nums1</code> and <code>nums2</code> using two pointers. On each iteration of the loop, one of the pointers is incremented, but not both. Each pointer can be incremented as many times as <span class="math inline">\(n\)</span> or <span class="math inline">\(m\)</span>, respectively, meaning we will iterate at most <span class="math inline">\(n + m\)</span> times. With each iteration, we performed <span class="math inline">\(O(1)\)</span> work. Therefore, the time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a couple of variables and no additional data structures that grow with input size, so the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<h3 id="approach-3-binary-search">Approach 3: Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To solve this problem, we need to search for common values between two arrays. The arrays are sorted, which means we can utilize binary search.</p>
<blockquote>
<p>Binary search is a search algorithm that finds the position of a target value within a sorted array.</p>
</blockquote>
<p>If you are unfamiliar with binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search explore card</a>.</p>
<p>Binary search uses three pointers. We can call them <code>left</code>, <code>mid</code>, and <code>right</code>.</p>
<p>Initially, <code>left</code> points to the first index of the array and <code>right</code> points to the last. At each step, we calculate <code>mid</code> as the middle element between <code>left</code> and <code>right</code>.</p>
<p>Binary search compares the target value with the middle element at each iteration.</p>
<ul>
<li>
<p>If the target value is equal to the middle element, the target has been found.</p>
</li>
<li>
<p>If the target value is less than the middle element, continue to search in the left half.</p>
</li>
<li>
<p>If the target value is greater than the middle element, continue to search in the right half.</p>
</li>
</ul>
<p>With every iteration, the search window is divided in half, and the search is continued in either the right or the left side until either the target is found or <code>left</code> becomes greater than <code>right</code>.</p>
<p>We can solve the problem by iterating through each element in <code>nums1</code>, and using binary search to find that element in <code>nums2</code>. We want to perform binary search on the longer array, which will make the algorithm more efficient, so if <code>nums1</code> is longer, we swap the arrays.</p>
<p>Below is a visualization of this algorithm:</p>
<p>!?!../Documents/2540/2540_slideshow2.json:960,540!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<h5 id="implementation-note">Implementation Note:</h5>
<p><code>mid</code>, the middle of the subarray, is set to the index in the middle of the array. The basic midpoint formula is <code>(left + right) / 2</code>.<br />
You'll notice that the below implementations instead use <code>left + (right - left) / 2</code>. This is because if <code>left + right</code> is greater than the maximum integer value, <span class="math inline">\(2^{31} - 1\)</span>, it overflows and causes errors.</p>
<p><code>left + (right - left) / 2</code> is an equivalent formula, and never stores a value larger than <code>left</code> or <code>right</code>. Thus, if <code>left</code> and <code>right</code> are within the integer limits, we will never overflow.</p>
<ol>
<li>Declare a function <code>binarySearch</code> that takes an array <code>nums</code> and a target value as parameters and returns <code>true</code> if the target is in the array.
<ul>
<li>Initialize <code>left</code> pointer to <code>0</code> and <code>right</code> pointer to <code>nums.length -1</code>. These represent the first and last indices of the array.</li>
<li>While <code>left</code> is less than or equal to <code>right</code>, iteratively perform a binary search:
<ul>
<li>Set <code>mid</code> to <code>left + (right - left) / 2</code>, which is the middle of this section of <code>nums</code>. We will compare <code>nums[mid]</code> to <code>target</code>.</li>
<li>If <code>nums[mid]</code> is greater than <code>target</code>, set <code>right</code> to <code>mid - 1</code>, we will continue to search in the left half <code>nums</code>.</li>
<li>If <code>nums[mid]</code> is less than <code>target</code>, set <code>left</code> to <code>mid + 1</code>, we will continue to search in the right half <code>nums</code>.</li>
<li>Otherwise, <code>nums[mid]</code> equals <code>target</code>, return <code>true</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>nums1</code> is longer than <code>nums2</code>, call getCommon with the arrays swapped.</li>
<li>Iterate through each <code>num</code> in <code>nums1</code>, using binary search to determine whether that element is in <code>nums2</code>:
<ul>
<li>If <code>num</code> is found in <code>nums2</code>, we can return <code>num</code>. This is guaranteed to be the minimum common value, because both arrays are sorted.</li>
</ul>
</li>
<li>If we did not find any common elements, return <code>-1</code>. There is no common value.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/TxxqXwHU/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the shorter array and <span class="math inline">\(m\)</span> be the length of the longer array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log m)\)</span></p>
<p>We iterate through the shorter array, using binary search to look for each element in the longer array. Binary Search takes <span class="math inline">\(O( \log m)\)</span> time to search through <span class="math inline">\(m\)</span> elements, so the overall time complexity is <span class="math inline">\(O(n \log m)\)</span>.</p>
<p>If one of the arrays is very large relative to the other, this approach will be more efficient than the previous two.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a couple of variables and no additional data structures that grow with input size, so the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-178">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-make-array-equal/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Make Array Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> arrays <code>nums</code> and <code>cost</code> consisting each of <code>n</code> <strong>positive</strong> integers.</p>

<p>You can do the following operation <strong>any</strong> number of times:</p>

<ul>
	<li>Increase or decrease <strong>any</strong> element of the array <code>nums</code> by <code>1</code>.</li>
</ul>

<p>The cost of doing one operation on the <code>i<sup>th</sup></code> element is <code>cost[i]</code>.</p>

<p>Return <em>the <strong>minimum</strong> total cost such that all the elements of the array </em><code>nums</code><em> become <strong>equal</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,2], cost = [2,3,1,14]
<strong>Output:</strong> 8
<strong>Explanation:</strong> We can make all the elements equal to 2 in the following way:
- Increase the 0<sup>th</sup> element one time. The cost is 2.
- Decrease the 1<sup><span style="font-size: 10.8333px;">st</span></sup> element one time. The cost is 3.
- Decrease the 2<sup>nd</sup> element three times. The cost is 1 + 1 + 1 = 3.
The total cost is 2 + 3 + 3 = 8.
It can be shown that we cannot make the array equal with a smaller cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2,2,2], cost = [4,2,8,1,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All the elements are already equal, so no operations are needed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length == cost.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], cost[i] &lt;= 10<sup>6</sup></code></li>
	<li>Test cases are generated in a way that the output doesn&#39;t exceed&nbsp;2<sup>53</sup>-1</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-179">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-make-array-equalindromic/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Make Array Equalindromic</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> having length <code>n</code>.</p>

<p>You are allowed to perform a special move <strong>any</strong> number of times (<strong>including zero</strong>) on <code>nums</code>. In one <strong>special</strong> <strong>move</strong> you perform the following steps <strong>in order</strong>:</p>

<ul>
	<li>Choose an index <code>i</code> in the range <code>[0, n - 1]</code>, and a <strong>positive</strong> integer <code>x</code>.</li>
	<li>Add <code>|nums[i] - x|</code> to the total cost.</li>
	<li>Change the value of <code>nums[i]</code> to <code>x</code>.</li>
</ul>

<p>A <strong>palindromic number</strong> is a positive integer that remains the same when its digits are reversed. For example, <code>121</code>, <code>2552</code> and <code>65756</code> are palindromic numbers whereas <code>24</code>, <code>46</code>, <code>235</code> are not palindromic numbers.</p>

<p>An array is considered <strong>equalindromic</strong> if all the elements in the array are equal to an integer <code>y</code>, where <code>y</code> is a <strong>palindromic number</strong> less than <code>10<sup>9</sup></code>.</p>

<p>Return <em>an integer denoting the <strong>minimum</strong> possible total cost to make </em><code>nums</code><em> <strong>equalindromic</strong> by performing any number of special moves.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> 6
<strong>Explanation:</strong> We can make the array equalindromic by changing all elements to 3 which is a palindromic number. The cost of changing the array to [3,3,3,3,3] using 4 special moves is given by |1 - 3| + |2 - 3| + |4 - 3| + |5 - 3| = 6.
It can be shown that changing all elements to any palindromic number other than 3 cannot be achieved at a lower cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,12,13,14,15]
<strong>Output:</strong> 11
<strong>Explanation:</strong> We can make the array equalindromic by changing all elements to 11 which is a palindromic number. The cost of changing the array to [11,11,11,11,11] using 5 special moves is given by |10 - 11| + |12 - 11| + |13 - 11| + |14 - 11| + |15 - 11| = 11.
It can be shown that changing all elements to any palindromic number other than 11 cannot be achieved at a lower cost.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [22,33,22,33,22]
<strong>Output:</strong> 22
<strong>Explanation:</strong> We can make the array equalindromic by changing all elements to 22 which is a palindromic number. The cost of changing the array to [22,22,22,22,22] using 2 special moves is given by |33 - 22| + |33 - 22| = 22.
It can be shown that changing all elements to any palindromic number other than 22 cannot be achieved at a lower cost.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-180">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/description" target="_blank" rel="noopener noreferrer">Minimum Garden Perimeter to Collect Enough Apples</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a garden represented as an infinite 2D grid, there is an apple tree planted at <strong>every</strong> integer coordinate. The apple tree planted at an integer coordinate <code>(i, j)</code> has <code>|i| + |j|</code> apples growing on it.</p>

<p>You will buy an axis-aligned <strong>square plot</strong> of land that is centered at <code>(0, 0)</code>.</p>

<p>Given an integer <code>neededApples</code>, return <em>the <strong>minimum perimeter</strong> of a plot such that <strong>at least</strong></em><strong> </strong><code>neededApples</code> <em>apples are <strong>inside or on</strong> the perimeter of that plot</em>.</p>

<p>The value of <code>|x|</code> is defined as:</p>

<ul>
	<li><code>x</code> if <code>x &gt;= 0</code></li>
	<li><code>-x</code> if <code>x &lt; 0</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/30/1527_example_1_2.png" style="width: 442px; height: 449px;" />
<pre>
<strong>Input:</strong> neededApples = 1
<strong>Output:</strong> 8
<strong>Explanation:</strong> A square plot of side length 1 does not contain any apples.
However, a square plot of side length 2 has 12 apples inside (as depicted in the image above).
The perimeter is 2 * 4 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> neededApples = 13
<strong>Output:</strong> 16
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> neededApples = 1000000000
<strong>Output:</strong> 5040
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= neededApples &lt;= 10<sup>15</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-181">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-interval-to-include-each-query/description" target="_blank" rel="noopener noreferrer">Minimum Interval to Include Each Query</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">line sweep</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>intervals</code>, where <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> interval starting at <code>left<sub>i</sub></code> and ending at <code>right<sub>i</sub></code> <strong>(inclusive)</strong>. The <strong>size</strong> of an interval is defined as the number of integers it contains, or more formally <code>right<sub>i</sub> - left<sub>i</sub> + 1</code>.</p>

<p>You are also given an integer array <code>queries</code>. The answer to the <code>j<sup>th</sup></code> query is the <strong>size of the smallest interval</strong> <code>i</code> such that <code>left<sub>i</sub> &lt;= queries[j] &lt;= right<sub>i</sub></code>. If no such interval exists, the answer is <code>-1</code>.</p>

<p>Return <em>an array containing the answers to the queries</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
<strong>Output:</strong> [3,3,1,4]
<strong>Explanation:</strong> The queries are processed as follows:
- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.
- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.
- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.
- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
<strong>Output:</strong> [2,-1,4,6]
<strong>Explanation:</strong> The queries are processed as follows:
- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.
- Query = 19: None of the intervals contain 19. The answer is -1.
- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.
- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>7</sup></code></li>
	<li><code>1 &lt;= queries[j] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-182">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description" target="_blank" rel="noopener noreferrer">Minimum Limit of Balls in a Bag</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> where the <code>i<sup>th</sup></code> bag contains <code>nums[i]</code> balls. You are also given an integer <code>maxOperations</code>.</p>

<p>You can perform the following operation at most <code>maxOperations</code> times:</p>

<ul>
	<li>Take any bag of balls and divide it into two new bags with a <strong>positive </strong>number of balls.

	<ul>
		<li>For example, a bag of <code>5</code> balls can become two new bags of <code>1</code> and <code>4</code> balls, or two new bags of <code>2</code> and <code>3</code> balls.</li>
	</ul>
	</li>
</ul>

<p>Your penalty is the <strong>maximum</strong> number of balls in a bag. You want to <strong>minimize</strong> your penalty after the operations.</p>

<p>Return <em>the minimum possible penalty after performing the operations</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [9], maxOperations = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
- Divide the bag with 9 balls into two bags of sizes 6 and 3. [<strong><u>9</u></strong>] -&gt; [6,3].
- Divide the bag with 6 balls into two bags of sizes 3 and 3. [<strong><u>6</u></strong>,3] -&gt; [3,3,3].
The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,8,2], maxOperations = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong>
- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,<strong><u>8</u></strong>,2] -&gt; [2,4,4,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,<strong><u>4</u></strong>,4,4,2] -&gt; [2,2,2,4,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,<strong><u>4</u></strong>,4,2] -&gt; [2,2,2,2,2,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,<strong><u>4</u></strong>,2] -&gt; [2,2,2,2,2,2,2,2].
The bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= maxOperations, nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>nums</code> representing a collection of bags that contain different numbers of balls. We are allowed to perform the following operation on any bag of our choosing up to <code>maxOperations</code> times:</p>
<ol>
<li>Choose a bag from the array.</li>
<li>Split the balls in the chosen bag into two new bags (the total number of balls remains the same).</li>
<li>Add these two new bags to the array, replacing the original bag.</li>
</ol>
<p>After applying the allowed operations, we receive a penalty equal to the highest number of balls in any single bag. Our goal is to choose how to split the bags in such a way that we receive the lowest penalty possible, and return that number.</p>
<p>An intuitive but incorrect strategy would be to use all <code>maxOperations</code> operations to split the balls as much as possible. This would result in a final array of length <span class="math inline">\(n + maxOperations\)</span> since each operation adds one additional bag to the array.</p>
<p>According to this strategy, we would attempt to evenly distribute all balls across the <span class="math inline">\(n + maxOperations\)</span> available bags. Therefore, the expected result would be:</p>
<p><span class="math display">\[\begin{aligned}
    \frac{\text{Total balls}}{n  + \text{maxOperations}}.
\end{aligned}
\]</span></p>
<p>However, this approach fails because we are only permitted to split an existing bag into two new bags. We are not permitted to distribute balls into other existing bags.</p>
<p><img src="../Figures/1760/1760_wrong_approach.png" alt="Wrong Approach" /></p>
<h3 id="approach-binary-search-on-the-answer">Approach: Binary Search on The Answer</h3>
<h4 id="intuition">Intuition</h4>
<p>Let’s make some simple observations: the largest possible penalty can’t be less than 1 or more than the largest value in <code>nums</code>. We need to find our answer within that range. We can also observe that:</p>
<ul>
<li>if it’s not possible to achieve a certain penalty with the allowed number of operations, we won’t be able to achieve a lower penalty than that.</li>
<li>if it’s possible to achieve a certain penalty with less than the allowed number of operations, we can ultimately achieve an unknown lower penalty.</li>
</ul>
<p>This understanding reveals a monotonic relationship between the number of operations we are allowed to perform and the size of the penalty.</p>
<p>Now, one inefficient way to solve this problem would be to check each possible value from least to greatest until we find the lowest achievable value given the number of allowed operations. Is there a way we can more efficiently pick which values to test?</p>
<p>Whenever we see a phrase like &quot;maximize the minimum&quot; or &quot;minimize the maximum&quot;, the natural approach to solve the problem is binary search on the answer. Aditionally binary search works best when you can formulate the problem as a &quot;yes/no&quot; decision and when there’s a clear order to the possible answers. In this case, the question becomes: &quot;Can we split the bags so that no bag contains more than <code>maxBallsInBag</code> balls, performing at most <code>maxOperations</code> operations?&quot;</p>
<p>This monotonic property allows us to leverage binary search to efficiently narrow down the range of possible penalties. By checking the middle value in our current range, we can determine whether a given penalty is achievable. If it is, then any larger penalty will also be achievable, and if it is not, smaller penalties will not be achievable either.</p>
<blockquote>
<p>For a more comprehensive understanding of binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card 🔗</a>. This resource provides an in-depth look at binary search, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>By repeatedly halving the search space based on whether the current penalty is achievable or not, we can quickly converge to the smallest penalty that can be achieved within the allowed operations. This allows us to find the optimal penalty in logarithmic time relative to the size of the range, making the solution much more efficient than testing each possibility one by one.</p>
<p>Now, how will we determine whether a particular target is achievable?</p>
<ol>
<li>
<p>Reducing the number of balls in a bag: We can split a bag with <code>nums[i]</code> balls into smaller bags. After <span class="math inline">\(operations_i\)</span> splits, the original bag is replaced with <span class="math inline">\(operations_i + 1\)</span> smaller bags.</p>
</li>
<li>
<p>Checking if the target is achievable: After all operations have been applied, all bags must have a number of balls less than or equal to the target we are testing. Mathematically:</p>
<p><span class="math display">\[\begin{aligned}
    \text{nums}[i] \leq (\text{operations}_i + 1) \cdot \text{maxBallsInBag}
\end{aligned}
\]</span></p>
</li>
<li>
<p>Calculating the number of splits (<code>operations_i</code>) required to achieve the target: Solving for <span class="math inline">\(operations_i\)</span>, we get:</p>
<p><span class="math display">\[\begin{aligned}
    \text{operations}_i = \lceil \frac{\text{nums}[i]}{\text{maxBallsInBag}} \rceil - 1
\end{aligned}
\]</span></p>
<p>This tells us the minimum splits needed to ensure no smaller bag exceeds <code>maxBallsInBag</code>.</p>
</li>
<li>
<p>Checking if the plan works: If the total operations (i.e., the sum of <span class="math inline">\(operations_i\)</span> for all <code>i</code>) is less than <code>maxOperations</code>, a split is possible. Otherwise, it isn't.</p>
</li>
</ol>
<p>The example below illustrates the monotonic relationship between the number of operations we are allowed to perform and the minimum maximum number of balls in any bag. The answer (<code>result</code>) is found by performing a binary search on the values of the horizontal axis.</p>
<p><img src="../Figures/1760/1760_monotonic_graph.png" alt="Monotonic Graph" /></p>
<h5 id="why-the-heap-approach-doesnt-work-">Why the Heap Approach Doesn’t Work ?</h5>
<p>One might consider a priority queue (or max-heap) approach where we repeatedly split the largest bag to minimize the maximum size. While this approach works for many greedy problems, it doesn’t work here as it doesn’t guarantee an optimal distribution of the balls.</p>
<p>With some changes, it is possible to use a heap if we write a custom comparison function. Specifically, we can represent each element in the heap as a pair: the first value is the number of balls in a bag, and the second value is the number of divisions we have made. The heap can then prioritize the division ratio by comparing the number of balls each bag will have after further division.</p>
<p>However, this approach fails under the problem’s constraints. If we attempt to perform operations like dividing the largest element and updating the heap, the constraints (with <code>nums</code> potentially containing up to <span class="math inline">\(10^5\)</span> elements and values up to <span class="math inline">\(10^9\)</span>) would cause a Time Limit Exceeded (TLE) error.</p>
<p>If the constraints were reversed — say, if we had larger elements (<span class="math inline">\(10^9\)</span>) but fewer values (<span class="math inline">\(10^5\)</span>) — the heap approach would be the perfect approach. So with the current constraints, binary search remains the most efficient solution.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a function <code>isPossible</code>, which takes an integer <code>maxBallsInBag</code>, the <code>nums</code> array, and <code>maxOperations</code> as parameters and returns a boolean, indicating whether it’s possible to split the balls such that no bag contains more than <code>maxBallsinBag</code> balls.
<ul>
<li>Initialize an integer <code>totalOperations</code> to <code>0</code>.</li>
<li>Loop through each bag with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Calculate the operations needed for the <code>i</code>-th bag: <code>operations = ceil(nums[i] / maxBallsInBag) - 1</code>.</li>
<li>Add <code>operations</code> to <code>totalOperations</code>.</li>
<li>Check if <code>totalOperations &gt; maxOperations</code>. If so, a distribution is impossible; return <code>false</code>.</li>
</ul>
</li>
<li>If the loop ends without returning <code>false</code>, the balls can be split satisfying the constraint, so return <code>true</code>.</li>
</ul>
</li>
<li>In the <code>minimumSize</code> main function:
<ul>
<li>Initialize the boundaries of the binary search: <code>left = 1</code> and <code>right = max(nums[i])</code>.</li>
<li>While <code>left &lt; right</code>:
<ul>
<li>Set <code>middle = (left + right) / 2</code>.</li>
<li>Check whether balls can be split with no bag finally containing more than <code>middle</code> products, using the <code>isPossible</code> function.
<ul>
<li>If this condition is <code>true</code>, set <code>right = middle</code>.</li>
<li>Otherwise, set <code>left = middle + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>When the loop ends, <code>left == right</code>, so return <code>left</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/XLWxAKon/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(k\)</span> be the maximum value in the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log k)\)</span></p>
<p>The <code>isPossible</code> function iterates through the <code>n</code> bags, executing constant-time operations during each iteration. As a result, its time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>The main function, <code>minimumSize</code>, performs a binary search over the range <span class="math inline">\((1, k)\)</span>, calling in each iteration the <code>canDistribute</code> function. Since the binary search runs in <span class="math inline">\(O(\log k)\)</span> time, the overall time complexity of the <code>minimumSize</code> function is <span class="math inline">\(O(n \log k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use a fixed number of integer variables, which doesn't depend on the input size.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-183">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description" target="_blank" rel="noopener noreferrer">Minimum Number of Days to Make m Bouquets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>bloomDay</code>, an integer <code>m</code> and an integer <code>k</code>.</p>

<p>You want to make <code>m</code> bouquets. To make a bouquet, you need to use <code>k</code> <strong>adjacent flowers</strong> from the garden.</p>

<p>The garden consists of <code>n</code> flowers, the <code>i<sup>th</sup></code> flower will bloom in the <code>bloomDay[i]</code> and then can be used in <strong>exactly one</strong> bouquet.</p>

<p>Return <em>the minimum number of days you need to wait to be able to make </em><code>m</code><em> bouquets from the garden</em>. If it is impossible to make m bouquets return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> bloomDay = [1,10,3,10,2], m = 3, k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.
We need 3 bouquets each should contain 1 flower.
After day 1: [x, _, _, _, _]   // we can only make one bouquet.
After day 2: [x, _, _, _, x]   // we can only make two bouquets.
After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> bloomDay = [1,10,3,10,2], m = 3, k = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
<strong>Output:</strong> 12
<strong>Explanation:</strong> We need 2 bouquets each should have 3 flowers.
Here is the garden after the 7 and 12 days:
After day 7: [x, x, x, x, _, x, x]
We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
After day 12: [x, x, x, x, x, x, x]
It is obvious that we can make two bouquets in different ways.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>bloomDay.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= bloomDay[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-binary-search">Approach: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>In this problem, we need to return the number of days required to make a certain number of bouquets, or return -1 if it's not possible to make that many. The flowers for a bouquet must be consecutive in the garden and fully bloomed.</p>
<p>The naive approach would be to iterate through each day, starting from day 1, and check if we can make <code>m</code> bouquets on that day. This method is inefficient since it requires iterating over all possible days and all <code>N</code> flowers for each day.</p>
<p>To optimize the solution, we observe a crucial property: once a flower blooms, it remains bloomed. This means that the number of bloomed flowers stays the same or increases as the days progress. The same goes for the number of bouquets that can possibly be made.</p>
<p>This observation leads us to consider using a binary search algorithm. One clue that binary search can be applied is that we are searching for a specific value that satisfies a condition (the earliest day). Another clue is that the condition exhibits an &quot;ordered property&quot; – if the condition is satisfied on a particular day, it will also be satisfied on all of the following days.</p>
<p>The observation that the number of bloomed flowers stays the same or increases as the days progress allows us to define a search space between 1 and the maximum value in the <code>bloomDay</code> array. For each midpoint day in the search space, we calculate the number of bouquets that can be made on that day by counting the consecutive bloomed flowers.</p>
<p>If the number of bouquets we can make on the midpoint day is greater than or equal to the number required by the problem (<code>m</code>), then we can potentially find an earlier day that satisfies the requirement. Since we want to return the minimum number of days we need to wait, we update the search space to the left half to see if we can reduce our wait time. Conversely, if the number of bouquets is less than <code>m</code>, we update the search space to the right half to continue our search for a day that we can make the required number of bouquets.</p>
<p>By repeatedly narrowing down the search space through binary search, we can determine whether or not we can make the required number of bouquets.</p>
<p><img src="../Figures/1482/1482A.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize <code>start</code> to <code>0</code> and <code>end</code> to the highest value in the array <code>bloomDay</code>.</p>
</li>
<li>
<p>Do the following while the search space (<code>start</code> to <code>end</code>) doesn't become empty:</p>
<ul>
<li>
<p>Initialize <code>mid</code> to <code>start + end / 2</code>.</p>
</li>
<li>
<p>Find the number of bouquets possible on day <code>mid</code> using a helper function <code>getNumOfBouquets</code> as follows:</p>
<ul>
<li>
<p>Initialize the variable <code>numOfBouquets</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over the array <code>bloomDay</code> and for each index <code>i</code></p>
<ul>
<li>If the value <code>bloomDay[i]</code> is less than or equal to <code>mid</code>, increment the <code>count</code>; else, reset it to <code>0</code>.</li>
<li>If the value of <code>count</code> is equal to <code>k</code>, make a bouquet by incrementing <code>numOfBouquets</code> and reset <code>count</code> to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Return <code>numOfBouquets</code>.</p>
</li>
</ul>
</li>
<li>
<p>If <code>numOfBouquets</code> is more than or equal to <code>m</code> store <code>mid</code> as an answer in <code>ans</code>. Shift to the left of the search space by setting <code>end</code> to <code>mid - 1</code>.</p>
</li>
<li>
<p>Otherwise, shift to the right of the search space by setting <code>start</code> to <code>mid + 1</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4N9EyLkP/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of flowers and <span class="math inline">\(D\)</span> is the highest value in the array <code>bloomDay</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log D)\)</span>.</p>
<p>The search space is from <span class="math inline">\(1\)</span> to <span class="math inline">\(D\)</span> and for each of the chosen values of <code>mid</code> in the binary search we will iterate over the <span class="math inline">\(N\)</span> flowers. Therefore the time complexity is equal to <span class="math inline">\(O(N \log D)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No extra space is required apart from a few variables and hence the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-184">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Make Array Continuous</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. In one operation, you can replace <strong>any</strong> element in <code>nums</code> with <strong>any</strong> integer.</p>

<p><code>nums</code> is considered <strong>continuous</strong> if both of the following conditions are fulfilled:</p>

<ul>
	<li>All elements in <code>nums</code> are <strong>unique</strong>.</li>
	<li>The difference between the <strong>maximum</strong> element and the <strong>minimum</strong> element in <code>nums</code> equals <code>nums.length - 1</code>.</li>
</ul>

<p>For example, <code>nums = [4, 2, 5, 3]</code> is <strong>continuous</strong>, but <code>nums = [1, 2, 3, 5, 6]</code> is <strong>not continuous</strong>.</p>

<p>Return <em>the <strong>minimum</strong> number of operations to make </em><code>nums</code><em> </em><strong><em>continuous</em></strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,5,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong>&nbsp;nums is already continuous.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,5,6]
<strong>Output:</strong> 1
<strong>Explanation:</strong>&nbsp;One possible solution is to change the last element to 4.
The resulting array is [1,2,3,5,4], which is continuous.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,10,100,1000]
<strong>Output:</strong> 3
<strong>Explanation:</strong>&nbsp;One possible solution is to:
- Change the second element to 2.
- Change the third element to 3.
- Change the fourth element to 4.
The resulting array is [1,2,3,4], which is continuous.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>The problem description gives some rules for what a continuous array is, but we can simplify it to help us better understand the problem. A continuous array covers all the elements in a range of size <code>n</code>. Essentially, if we sort a continuous array, it will continuously count up by <code>1</code>.</p>
<p>We can define a continuous array by giving its bounds - <code>left</code> and <code>right</code>. For example, in the following continuous array:</p>
<p><code>[6, 3, 5, 4]</code></p>
<p>The bounds are <code>left = 3</code> and <code>right = 6</code>. As you can see, the array fully covers all elements in the range <code>[3, 6]</code>. If we were to sort it, we would get <code>[3, 4, 5, 6]</code>, which starts at <code>left</code> and counts up by <code>1</code> until we reach <code>right</code>.</p>
<p>To solve this problem, we will iterate over the array and treat each element as <code>left</code>. We can then calculate <code>right = left + n - 1</code>. We now want to convert the array into a continuous array that covers all elements in the range <code>[left, right]</code>. How many operations do we need to accomplish this?</p>
<p>We need to find how many elements in the array are already in the range <code>[left, right]</code>. We can leave these elements unchanged and fill in the rest of the range using operations. Note that if there are duplicate elements in the input, this strategy will not work properly. For example, let's say we had the following input:</p>
<p><code>6, 3, 3, 5, 4</code></p>
<p>If we had <code>left = 3</code>, we would have <code>right = 7</code>. Every element in the input is in the range <code>[3, 7]</code>, so it appears that we don't need any operations. However, the number <code>7</code> is missing because we have <code>3</code> twice. Thus, we should first convert <code>nums</code> into a set to get rid of duplicate numbers.</p>
<p>Now that we have gotten rid of the duplicates, how can we quickly find how many elements in the array are in a given range <code>[left, right]</code>? If the array is sorted, then we can binary search to efficiently find how many elements are less than or equal to <code>right</code>. We already know how many elements are less than <code>left</code> because we treat <code>left = nums[i]</code> during iteration.</p>
<p>Let's summarize the algorithm with an example.</p>
<p><img src="../Figures/2009/1.png" alt="example" /><br />
<br></p>
<p>First, we remove duplicates from the array, then sort it. Note the original length before removing duplicates as <code>n = 8</code>.</p>
<p><img src="../Figures/2009/2.png" alt="example" /><br />
<br></p>
<p>Now, we iterate over the array. For each index <code>i</code>, we treat <code>left = nums[i]</code>.</p>
<p><img src="../Figures/2009/3.png" alt="example" /><br />
<br></p>
<p>If we were to create a continuous array with <code>left = 2</code> as the minimum, we would need a maximum of <code>right = left + n - 1 = 9</code>.</p>
<p><img src="../Figures/2009/4.png" alt="example" /><br />
<br></p>
<p>How many operations do we need? We start by finding how many elements in the array are already in the desired range <code>[left, right]</code>. Binary search to find the insertion index of <code>right</code>. Note that the binary search here is finding the index <strong>after</strong> the greatest element less than or equal to <code>right</code>.</p>
<p><img src="../Figures/2009/5.png" alt="example" /><br />
<br></p>
<p>Let's call this index <code>j</code>. We have <code>j</code> as the index of the first element that falls outside our range due to it being too large. We also have <code>i</code> as the index of the first element in our range. Thus, we can calculate the number of elements already in our range as <code>j - i</code>.</p>
<p><img src="../Figures/2009/6.png" alt="example" /><br />
<br></p>
<p>As you can see, we have <code>4</code> elements already in the range <code>[left, right]</code>. Thus, these elements do not need to be changed. As we must construct an array of length <code>8</code>, we require <code>8 - 4 = 4</code> operations (one for each other element) to create a continuous array if we treat <code>2</code> as the minimum.</p>
<p><img src="../Figures/2009/7.png" alt="example" /><br />
<br></p>
<p>We can repeat this process for every index in the sorted, duplicate-free array. For example, if we treat <code>nums[3] = 7</code> as the minimum, then our range is <code>[7, 14]</code>. We can binary search to find <code>j</code> and then calculate <code>j - i = 2</code> as the number of elements already in our range. Thus, we need to perform <code>8 - 2 = 6</code> operations if we treat <code>7</code> as the minimum.</p>
<p><img src="../Figures/2009/8.png" alt="example" /><br />
<br></p>
<p>As we iterate over all indices and perform the above process, we keep track of the minimum operations needed.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Set <code>n = nums.length</code> and the answer <code>ans = n</code>.</li>
<li>Remove duplicates from <code>nums</code> and then sort it. We will call this new array <code>newNums</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>newNums</code>:
<ul>
<li>Set <code>left = newNums[i]</code>.</li>
<li>Calculate <code>right = left + n - 1</code>.</li>
<li>Calculate <code>j</code>, the insertion index of <code>right</code> in <code>newNums</code> using binary search.</li>
<li>Calculate <code>count = j - i</code>, the number of elements already in our range.</li>
<li>Update <code>ans</code> with <code>n - count</code> if it is smaller.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/9gC6h4T4/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>To remove duplicates and sort <code>nums</code>, we require <span class="math inline">\(O(n \cdot \log{}n)\)</span> time.</p>
<p>Then, we iterate over <span class="math inline">\(n\)</span> indices and perform a <span class="math inline">\(O(\log{}n)\)</span> binary search at each index.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create a new array <code>newNums</code> of size <span class="math inline">\(O(n)\)</span>. Note that even if you were to modify the input directly, we still use <span class="math inline">\(O(n)\)</span> space creating a hash set to remove duplicates. Also, it is considered a bad practice to modify the input, and many people will argue that modifying the input makes it part of the space complexity anyway.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-sliding-window">Approach 2: Sliding Window</h3>
<p><strong>Intuition</strong></p>
<p>In the previous approach, we locked in an element <code>newNums[i]</code> as <code>left</code>, calculated <code>right</code>, then found the insertion index of <code>right</code> as <code>j</code>. We used an <span class="math inline">\(O(\log{}n)\)</span> binary search to find <code>j</code>, but we can do better using a sliding window.</p>
<p>Because <code>newNums</code> is sorted:</p>
<ul>
<li>As <code>i</code> increases, so does <code>left = newNums[i]</code>.</li>
<li>An increase in the lower bound <code>left</code> means an increase in the upper bound <code>right</code> as well.</li>
<li>As <code>right</code> increases, <code>j</code> either remains the same or increases.</li>
</ul>
<p>Thus, as <code>i</code> increases, <code>j</code> will stay the same or increase.</p>
<p>We initialize <code>j = 0</code> and follow the same process as in the last approach. Iterate <code>i</code> over the indices of <code>newNums</code> and treat each <code>left = newNums[i]</code> as the minimum element. This gives us <code>right = newNums[i] + n - 1</code> as our maximum element.</p>
<p>How do we update <code>j</code>? Similar to the last approach, we have <code>j</code> as the index of the first element out of our range. Thus, we increment <code>j</code> until it points to an element out of our range. The condition for this is:</p>
<p><code>while (newNums[j] &lt; newNums[i] + n)</code></p>
<p>Once this condition is broken, <code>newNums[j]</code> is out of our range <code>[left, right]</code> and correctly positioned. We can calculate the number of elements already in our range as <code>j - i</code> just like in the previous approach.</p>
<p>Because <code>j</code> starts at <code>0</code> and cannot exceed the length of <code>newNums</code>, it will only be incremented at most <span class="math inline">\(n\)</span> times across the entire algorithm. This means it costs <span class="math inline">\(O(1)\)</span> amortized to calculate <code>j</code>, an improvement from the <span class="math inline">\(O(\log{}n)\)</span> binary search.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Set <code>n = nums.length</code> and the answer <code>ans = n</code>.</li>
<li>Remove duplicates from <code>nums</code> and then sort it. We will call this new array <code>newNums</code>.</li>
<li>Initialize <code>j = 0</code> and iterate <code>i</code> over the indices of <code>newNums</code>:
<ul>
<li>While <code>newNums[j]</code> is within our range (less than <code>newNums[i] + n</code>), increment <code>j</code>.</li>
<li>Calculate <code>count = j - i</code>, the number of elements already in our range.</li>
<li>Update <code>ans</code> with <code>n - count</code> if it is smaller.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/Ru5uG3D4/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>To remove duplicates and sort <code>nums</code>, we require <span class="math inline">\(O(n \cdot \log{}n)\)</span> time.</p>
<p>Then, we iterate over <span class="math inline">\(n\)</span> indices and perform <span class="math inline">\(O(1)\)</span> amortized work at each iteration. The while loop inside the for loop can only iterate at most <span class="math inline">\(n\)</span> times total across all iterations of the for loop. Each element in <code>newNums</code> can only be iterated over once by this while loop.</p>
<p>Despite this approach having the same time complexity as the previous approach (due to the sort), it is a slight practical improvement as the sliding window portion is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create a new array <code>newNums</code> of size <span class="math inline">\(O(n)\)</span>. Note that even if you were to modify the input directly, we still use <span class="math inline">\(O(n)\)</span> space creating a hash set to remove duplicates. Also, it is considered a bad practice to modify the input, and many people will argue that modifying the input makes it part of the space complexity anyway.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-185">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/description" target="_blank" rel="noopener noreferrer">Minimum Number of Removals to Make Mountain Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You may recall that an array <code>arr</code> is a <strong>mountain array</strong> if and only if:</p>

<ul>
	<li><code>arr.length &gt;= 3</code></li>
	<li>There exists some index <code>i</code> (<strong>0-indexed</strong>) with <code>0 &lt; i &lt; arr.length - 1</code> such that:
	<ul>
		<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
		<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>
	</ul>
	</li>
</ul>

<p>Given an integer array <code>nums</code>​​​, return <em>the <strong>minimum</strong> number of elements to remove to make </em><code>nums<em>​​​</em></code><em> </em><em>a <strong>mountain array</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The array itself is a mountain array so we do not need to remove any elements.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,1,5,6,2,3,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li>It is guaranteed that you can make a mountain array out of <code>nums</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In the problem, we are given an array <code>nums</code> of length <code>N</code>, and the task is to determine the minimum number of elements to remove in order to transform it into a mountain array. A mountain array is defined as one that first strictly increases to a peak element at an index say <code>i</code>, then strictly decreases after that. Visually, this forms a &quot;mountain&quot; shape when plotted as shown below:</p>
<p><img src="../Figures/1671/1671A.png" alt="fig" /></p>
<p>To solve this, we must choose a peak element at index <code>i</code> such that the left subarray <code>(nums[0...i])</code> forms a strictly increasing sequence, and the right subarray <code>(nums[i...N - 1])</code> forms a strictly decreasing sequence.</p>
<p>For each candidate index <code>i</code> (potential peak element):</p>
<ul>
<li>The subarray <code>nums[0...i]</code> should be strictly increasing.</li>
<li>The subarray <code>nums[i...N - 1]</code> should be strictly decreasing.</li>
</ul>
<p>Let <code>L1</code> be the length of the longest strictly increasing subsequence (LIS) that ends at index <code>i</code>, and <code>L2</code> be the length of the longest strictly decreasing subsequence (LDS) that starts at index <code>i</code>.</p>
<p>To calculate the number of elements to remove:</p>
<ul>
<li>On the left side of the peak, there are <code>i + 1</code> elements from <code>nums[0] to nums[i]</code>. Therefore, the number of elements to remove on the left side is <code>i + 1 - L1</code>.</li>
<li>On the right side, there are <code>N - i</code> elements from <code>nums[i] to nums[N - 1]</code>. The number of elements to remove on the right side is <code>N - i - L2</code>.</li>
</ul>
<p>Thus, the total number of elements to remove for a given peak at index <code>i</code> is:</p>
<blockquote>
<p><span class="math inline">\(\text{removals} = \text{(i + 1 − L1) + (N − i − L2) = N + 1 − L1 − L2}\)</span></p>
</blockquote>
<p>This formula calculates the total removals required if <code> i</code> is chosen as the peak element.</p>
<p>Therefore, the solution boils down to evaluating each index in the array as a potential peak element and determining the lengths of the ordered subsequences on both sides of it to calculate the number of required removals. We will discuss two approaches to find the lengths of these ordered subsequences: one using dynamic programming and the other utilizing binary search.</p>
<hr />
<h3 id="approach-1-lis-using-dynamic-programming">Approach 1: LIS Using Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>The discussion above focuses on finding the lengths of ordered subsequences for each index in the given array. One approach is to compute these lengths on the fly while iterating over the indices to identify the optimal peak element. However, this method introduces redundant operations and is therefore inefficient. Instead, we can precompute the lengths of the ordered subsequences for each index in the array. This allows us to directly use these values to calculate the required removals for each index, ultimately yielding the minimum number of removals across all indices.</p>
<p>To find these lengths, we use dynamic programming, similar to the approach in <a href="https://leetcode.com/problems/longest-increasing-subsequence/solution/">300. Longest Increasing Subsequence</a>. First, we pass through the array from left to right to compute the longest increasing subsequence for each index <code>i</code>. For each element <code>nums[i]</code>, we compare it with all previous elements <code>nums[j]</code> where <code>j &lt; i</code>. If <code>nums[i] &gt; nums[j]</code>, we update the subsequence length at <code>i</code> with:</p>
<blockquote>
<p><span class="math inline">\(\text{lisLength[i] = max(lisLength[i], lisLength[j] + 1)}\)</span></p>
</blockquote>
<p>Next, we perform a right-to-left pass to calculate the longest decreasing subsequence starting at each index <code>i</code>. For each element <code>nums[i]</code>, we compare it with all subsequent elements <code>nums[j]</code> where <code>j &gt; i</code>. If <code>nums[i] &gt; nums[j]</code>, we update with:</p>
<blockquote>
<p><span class="math inline">\(\text{ldsLength[i] = max(ldsLength[i], ldsLength[j] + 1)}\)</span></p>
</blockquote>
<p>After precomputing the lengths of the ordered subsequences for all indices, we iterate through the <code>nums</code> array, considering each index <code>i</code> as a potential peak element. We calculate the number of elements that need to be removed using the expression:</p>
<blockquote>
<p><span class="math inline">\(\text{removals = N + 1 − lisLength[i] − ldsLength[i]}\)</span></p>
</blockquote>
<p>Before calculating the removals, it is essential to verify that the current index can serve as a valid peak by ensuring that both <span class="math inline">\(\text{lisLength}[i]\)</span> and <span class="math inline">\(\text{ldsLength}[i]\)</span> are greater than <code>1</code>. This condition is necessary because if either value is <code>0</code>, the peak would be positioned at the start or end of the array, which does not satisfy the criteria for a valid mountain array.</p>
<p>In the end, we can return the minimum value among the calculated removals as the result, representing the minimum number of elements that must be removed to form a valid mountain array.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize LIS and LDS arrays:
<ul>
<li>Create two arrays <code>lisLength</code> and <code>ldsLength</code> of size <code>N</code> initialized to <code>1</code>, representing the lengths of the longest increasing and decreasing subsequences, respectively.</li>
</ul>
</li>
<li>Calculate LIS (Longest Increasing Subsequence):
<ul>
<li>For each index <code>i</code>, iterate through all indices <code>j</code> before <code>i</code>.</li>
<li>If <code>nums[i] &gt; nums[j]</code>, update <code>lisLength[i]</code> as <code>max(lisLength[i], lisLength[j] + 1)</code>.</li>
</ul>
</li>
<li>Calculate LDS (Longest Decreasing Subsequence):
<ul>
<li>For each index <code>i</code>, iterate through all indices <code>j</code> after <code>i</code>.</li>
<li>If <code>nums[i] &gt; nums[j]</code>, update <code>ldsLength[i]</code> as <code>max(ldsLength[i], ldsLength[j] + 1)</code>.</li>
</ul>
</li>
<li>Determine minimum removals:
<ul>
<li>For each index <code>i</code>, if both <code>lisLength[i] &gt; 1</code> and <code>ldsLength[i] &gt; 1</code> (i.e., it's a valid mountain peak), calculate the minimum removals required as <code>N - (lisLength[i] + ldsLength[i] - 1)</code>.</li>
</ul>
</li>
<li>Return <code>minRemovals</code></li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/2YdRPu7S/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The process of determining the lengths of the increasing and decreasing subsequences using dynamic programming requires <span class="math inline">\(O(N^2)\)</span> time. Afterward, we iterate over the nums array to calculate the number of removals needed, which takes  <span class="math inline">\(O(N)\)</span> time. Therefore, the overall time complexity is  <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We utilize two arrays, <code>lisLen</code> and <code>ldsLen</code>, each of size <span class="math inline">\(N\)</span> to store the lengths of the ordered subsequences. Consequently, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-lis-using-binary-search">Approach 2: LIS Using Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This approach shares the same high-level concept as the previous one: we will precompute the lengths of the longest increasing subsequence (LIS) and the longest decreasing subsequence (LDS) for each index. We then use these lengths to determine the number of elements that need to be removed for each index to serve as the peak of the mountain array.</p>
<p>The key difference lies in how we compute the lengths of the ordered subsequences. This method employs binary search, as discussed in the third approach of <a href="https://leetcode.com/problems/longest-increasing-subsequence/solution/">300. Longest Increasing Subsequence</a>.</p>
<p>To find the length of the longest increasing subsequence using binary search, we maintain a separate array that holds the longest increasing subsequence encountered so far. The strategy is to ensure that the length of this subsequence remains the same or increases with the addition of new elements. As we iterate through each element in the array nums, we use binary search to find the index of the first element in our subsequence that is greater than or equal to the current element. If this index is equal to the size of the subsequence, it indicates that the current element is greater than the last element in the subsequence. Therefore, we add it to the subsequence, which increases its length. If the binary search yields an index within the existing subsequence, we replace the element at that index with the current element. This is done because the current element is either equal to or smaller than the existing element, and this allows for potentially more elements to be added to the subsequence in the future.</p>
<p>Similarly, we determine the length of the decreasing subsequence by iterating from the right end of the array. To reuse the same logic, we can reverse the nums array and apply the same method to find the increasing subsequence, which is equivalent to the decreasing subsequence of the original array. This approach allows us to define a single method that computes the length of the longest increasing subsequence for both the left and right sides of the peak element.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Define the function<code>getLongestIncreasingSubsequenceLength</code> that takes vector <code>v</code>
<ul>
<li>Initialize a list <code>lisLen</code> to store the current the length of the longest increasing sequence for each index.</li>
<li>Initialize a list <code>lis</code> to store the current LIS sequence.</li>
<li>For each element in the input array from index <code>1</code>, use a binary search (lowerBound) to find its position <code>index</code> in <code>lis</code>.
<ul>
<li>If the element <code>v[i]</code> is larger than all elements in <code>lis</code>, append it.</li>
<li>Otherwise, replace the element in <code>lis</code> at <code>index</code> with <code>v[i]</code>.</li>
<li>Update the <code>lisLen[i]</code> to the size of <code>lis</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Calculate LIS for left to right using the above function and store it in the list <code>lisLength</code></li>
<li>Calculate LDS (longest decreasing subsequence) for left to right using the above function and store it in the list <code>ldsLength</code>
<ul>
<li>Reverse the input array <code>nums</code> and and use the function <code>getLongestIncreasingSubsequenceLength</code></li>
<li>Reverse the resulting <code>ldsLen</code> to map back to the original array indices.</li>
</ul>
</li>
<li>Determine minimum removals:
<ul>
<li>For each index <code>i</code>, if both <code>lisLength[i] &gt; 1</code> and <code>ldsLength[i] &gt; 1</code> (i.e., it's a valid mountain peak), calculate the minimum removals required as <code>N - (lisLength[i] + ldsLength[i] - 1)</code>.</li>
</ul>
</li>
<li>Return <code>minRemovals</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GTcjY4o5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> represents the number of elements in the array nums.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>The computation of the lengths of the increasing and decreasing subsequences using binary search takes <span class="math inline">\(O(N \log N)\)</span>, as we perform a binary search, which has a complexity of <span class="math inline">\(O(\ log N)\)</span>, for each of the <span class="math inline">\(N\)</span> elements. After this, we iterate through the nums array to calculate the number of removals needed, which requires <span class="math inline">\(O(N)\)</span> time. Thus, the overall time complexity is <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need two arrays, <code>lisLen and ldsLen</code>, each of size <span class="math inline">\(N\)</span>, to store the lengths of the ordered subsequences. Additionally, we require an array to store the actual subsequence, <code>lis</code>, which can be as long as the original array. Consequently, the total space complexity is <span class="math inline">\(O(N)\)</span></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-186">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-seconds-to-make-mountain-height-zero/description" target="_blank" rel="noopener noreferrer">Minimum Number of Seconds to Make Mountain Height Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>mountainHeight</code> denoting the height of a mountain.</p>

<p>You are also given an integer array <code>workerTimes</code> representing the work time of workers in <strong>seconds</strong>.</p>

<p>The workers work <strong>simultaneously</strong> to <strong>reduce</strong> the height of the mountain. For worker <code>i</code>:</p>

<ul>
	<li>To decrease the mountain&#39;s height by <code>x</code>, it takes <code>workerTimes[i] + workerTimes[i] * 2 + ... + workerTimes[i] * x</code> seconds. For example:

	<ul>
		<li>To reduce the height of the mountain by 1, it takes <code>workerTimes[i]</code> seconds.</li>
		<li>To reduce the height of the mountain by 2, it takes <code>workerTimes[i] + workerTimes[i] * 2</code> seconds, and so on.</li>
	</ul>
	</li>
</ul>

<p>Return an integer representing the <strong>minimum</strong> number of seconds required for the workers to make the height of the mountain 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">mountainHeight = 4, workerTimes = [2,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>One way the height of the mountain can be reduced to 0 is:</p>

<ul>
	<li>Worker 0 reduces the height by 1, taking <code>workerTimes[0] = 2</code> seconds.</li>
	<li>Worker 1 reduces the height by 2, taking <code>workerTimes[1] + workerTimes[1] * 2 = 3</code> seconds.</li>
	<li>Worker 2 reduces the height by 1, taking <code>workerTimes[2] = 1</code> second.</li>
</ul>

<p>Since they work simultaneously, the minimum time needed is <code>max(2, 3, 1) = 3</code> seconds.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">mountainHeight = 10, workerTimes = [3,2,2,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Worker 0 reduces the height by 2, taking <code>workerTimes[0] + workerTimes[0] * 2 = 9</code> seconds.</li>
	<li>Worker 1 reduces the height by 3, taking <code>workerTimes[1] + workerTimes[1] * 2 + workerTimes[1] * 3 = 12</code> seconds.</li>
	<li>Worker 2 reduces the height by 3, taking <code>workerTimes[2] + workerTimes[2] * 2 + workerTimes[2] * 3 = 12</code> seconds.</li>
	<li>Worker 3 reduces the height by 2, taking <code>workerTimes[3] + workerTimes[3] * 2 = 12</code> seconds.</li>
</ul>

<p>The number of seconds needed is <code>max(9, 12, 12, 12) = 12</code> seconds.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">mountainHeight = 5, workerTimes = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">15</span></p>

<p><strong>Explanation:</strong></p>

<p>There is only one worker in this example, so the answer is <code>workerTimes[0] + workerTimes[0] * 2 + workerTimes[0] * 3 + workerTimes[0] * 4 + workerTimes[0] * 5 = 15</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= mountainHeight &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= workerTimes.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= workerTimes[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-187">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-i/description" target="_blank" rel="noopener noreferrer">Minimum Number of Valid Strings to Form Target I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>target</code>.</p>

<p>A string <code>x</code> is called <strong>valid</strong> if <code>x</code> is a <span data-keyword="string-prefix">prefix</span> of <strong>any</strong> string in <code>words</code>.</p>

<p>Return the <strong>minimum</strong> number of <strong>valid</strong> strings that can be <em>concatenated</em> to form <code>target</code>. If it is <strong>not</strong> possible to form <code>target</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abc&quot;,&quot;aaaaa&quot;,&quot;bcdef&quot;], target = &quot;aabcdabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 2 of <code>words[1]</code>, i.e. <code>&quot;aa&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[2]</code>, i.e. <code>&quot;bcd&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[0]</code>, i.e. <code>&quot;abc&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abababab&quot;,&quot;ab&quot;], target = &quot;ababaababa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abcdef&quot;], target = &quot;xyz&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>3</sup></code></li>
	<li>The input is generated such that <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>3</sup></code></li>
	<li><code>target</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-188">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-ii/description" target="_blank" rel="noopener noreferrer">Minimum Number of Valid Strings to Form Target II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>target</code>.</p>

<p>A string <code>x</code> is called <strong>valid</strong> if <code>x</code> is a <span data-keyword="string-prefix">prefix</span> of <strong>any</strong> string in <code>words</code>.</p>

<p>Return the <strong>minimum</strong> number of <strong>valid</strong> strings that can be <em>concatenated</em> to form <code>target</code>. If it is <strong>not</strong> possible to form <code>target</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abc&quot;,&quot;aaaaa&quot;,&quot;bcdef&quot;], target = &quot;aabcdabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 2 of <code>words[1]</code>, i.e. <code>&quot;aa&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[2]</code>, i.e. <code>&quot;bcd&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[0]</code>, i.e. <code>&quot;abc&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abababab&quot;,&quot;ab&quot;], target = &quot;ababaababa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abcdef&quot;], target = &quot;xyz&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The input is generated such that <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>target</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-189">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make All Array Elements Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> consisting of positive integers.</p>

<p>You are also given an integer array <code>queries</code> of size <code>m</code>. For the <code>i<sup>th</sup></code> query, you want to make all of the elements of <code>nums</code> equal to<code> queries[i]</code>. You can perform the following operation on the array <strong>any</strong> number of times:</p>

<ul>
	<li><strong>Increase</strong> or <strong>decrease</strong> an element of the array by <code>1</code>.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>m</code><em> where </em><code>answer[i]</code><em> is the <strong>minimum</strong> number of operations to make all elements of </em><code>nums</code><em> equal to </em><code>queries[i]</code>.</p>

<p><strong>Note</strong> that after each query the array is reset to its original state.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,6,8], queries = [1,5]
<strong>Output:</strong> [14,10]
<strong>Explanation:</strong> For the first query we can do the following operations:
- Decrease nums[0] 2 times, so that nums = [1,1,6,8].
- Decrease nums[2] 5 times, so that nums = [1,1,1,8].
- Decrease nums[3] 7 times, so that nums = [1,1,1,1].
So the total number of operations for the first query is 2 + 5 + 7 = 14.
For the second query we can do the following operations:
- Increase nums[0] 2 times, so that nums = [5,1,6,8].
- Increase nums[1] 4 times, so that nums = [5,5,6,8].
- Decrease nums[2] 1 time, so that nums = [5,5,5,8].
- Decrease nums[3] 3 times, so that nums = [5,5,5,5].
So the total number of operations for the second query is 2 + 4 + 1 + 3 = 10.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,9,6,3], queries = [10]
<strong>Output:</strong> [20]
<strong>Explanation:</strong> We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-190">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-a-subsequence/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make a Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>target</code> that consists of <strong>distinct</strong> integers and another integer array <code>arr</code> that <strong>can</strong> have duplicates.</p>

<p>In one operation, you can insert any integer at any position in <code>arr</code>. For example, if <code>arr = [1,4,1,2]</code>, you can add <code>3</code> in the middle and make it <code>[1,4,<u>3</u>,1,2]</code>. Note that you can insert the integer at the very beginning or end of the array.</p>

<p>Return <em>the <strong>minimum</strong> number of operations needed to make </em><code>target</code><em> a <strong>subsequence</strong> of </em><code>arr</code><em>.</em></p>

<p>A <strong>subsequence</strong> of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order. For example, <code>[2,7,4]</code> is a subsequence of <code>[4,<u>2</u>,3,<u>7</u>,2,1,<u>4</u>]</code> (the underlined elements), while <code>[2,4,2]</code> is not.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = [5,1,3], <code>arr</code> = [9,4,2,3,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can add 5 and 1 in such a way that makes <code>arr</code> = [<u>5</u>,9,4,<u>1</u>,2,3,4], then target will be a subsequence of <code>arr</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = [6,4,8,1,3,2], <code>arr</code> = [4,7,6,2,3,8,6,1]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= target.length, arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= target[i], arr[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>target</code> contains no duplicates.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-191">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make the Array K-Increasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>arr</code> consisting of <code>n</code> positive integers, and a positive integer <code>k</code>.</p>

<p>The array <code>arr</code> is called <strong>K-increasing</strong> if <code>arr[i-k] &lt;= arr[i]</code> holds for every index <code>i</code>, where <code>k &lt;= i &lt;= n-1</code>.</p>

<ul>
	<li>For example, <code>arr = [4, 1, 5, 2, 6, 2]</code> is K-increasing for <code>k = 2</code> because:

	<ul>
		<li><code>arr[0] &lt;= arr[2] (4 &lt;= 5)</code></li>
		<li><code>arr[1] &lt;= arr[3] (1 &lt;= 2)</code></li>
		<li><code>arr[2] &lt;= arr[4] (5 &lt;= 6)</code></li>
		<li><code>arr[3] &lt;= arr[5] (2 &lt;= 2)</code></li>
	</ul>
	</li>
	<li>However, the same <code>arr</code> is not K-increasing for <code>k = 1</code> (because <code>arr[0] &gt; arr[1]</code>) or <code>k = 3</code> (because <code>arr[0] &gt; arr[3]</code>).</li>
</ul>

<p>In one <strong>operation</strong>, you can choose an index <code>i</code> and <strong>change</strong> <code>arr[i]</code> into <strong>any</strong> positive integer.</p>

<p>Return <em>the <strong>minimum number of operations</strong> required to make the array K-increasing for the given </em><code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,4,3,2,1], k = 1
<strong>Output:</strong> 4
<strong>Explanation:
</strong>For k = 1, the resultant array has to be non-decreasing.
Some of the K-increasing arrays that can be formed are [5,<u><strong>6</strong></u>,<u><strong>7</strong></u>,<u><strong>8</strong></u>,<u><strong>9</strong></u>], [<u><strong>1</strong></u>,<u><strong>1</strong></u>,<u><strong>1</strong></u>,<u><strong>1</strong></u>,1], [<u><strong>2</strong></u>,<u><strong>2</strong></u>,3,<u><strong>4</strong></u>,<u><strong>4</strong></u>]. All of them require 4 operations.
It is suboptimal to change the array to, for example, [<u><strong>6</strong></u>,<u><strong>7</strong></u>,<u><strong>8</strong></u>,<u><strong>9</strong></u>,<u><strong>10</strong></u>] because it would take 5 operations.
It can be shown that we cannot make the array K-increasing in less than 4 operations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,1,5,2,6,2], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong>
This is the same example as the one in the problem description.
Here, for every index i where 2 &lt;= i &lt;= 5, arr[i-2] &lt;=<b> </b>arr[i].
Since the given array is already K-increasing, we do not need to perform any operations.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,1,5,2,6,2], k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong>
Indices 3 and 5 are the only ones not satisfying arr[i-3] &lt;= arr[i] for 3 &lt;= i &lt;= 5.
One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5.
The array will now be [4,1,5,<u><strong>4</strong></u>,6,<u><strong>5</strong></u>].
Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i], k &lt;= arr.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-192">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Reduce X to Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>

<p>Return <em>the <strong>minimum number</strong> of operations to reduce </em><code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it is possible</em><em>, otherwise, return </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,4,2,3], x = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> The optimal solution is to remove the last two elements to reduce x to zero.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,6,7,8,9], x = 4
<strong>Output:</strong> -1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,20,1,1,3], x = 10
<strong>Output:</strong> 5
<strong>Explanation:</strong> The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= x &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-193">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-platforms-1587115620/1" target="_blank" rel="noopener noreferrer">Minimum Platforms</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given the arrival times <strong>arr[]</strong> and departure times <strong>dep[]</strong> of all trains that arrive at a railway station on the same day. Your task is to determine the minimum number of platforms required at the station to ensure that no train is kept waiting.</span></p>
<p><span style="font-size: 14pt;">At any given time, the same platform cannot be used for both the arrival of one train and the departure of another. Therefore, when two trains arrive at the same time, or when one arrives before another departs, additional platforms are required to accommodate both trains.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [900, 940, 950, 1100, 1500, 1800], dep[] = [910, 1200, 1120, 1130, 1900, 2000]
<strong>Output</strong>: 3
<strong>Explanation</strong>: There are three trains during the time 9:40 to 12:00. So we need a minimum of 3 platforms.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [900, 1235, 1100], dep[] = [1000, 1240, 1200]
<strong>Output</strong>: 1
<strong>Explanation</strong>: All train times are mutually exclusive. So we need only one platform
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [1000, 935, 1100], dep[] = [1200, 1240, 1130]
<strong>Output</strong>: 3
<strong>Explanation</strong>: All 3 trains have to be there from 11:00 to 11:30</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1&le; number of trains &le; 50000<br />0000 &le; arr[i] &le; dep[i] &le; 2359<br /><strong>Note:</strong>&nbsp;Time intervals are in the 24-hour format(<strong>HHMM) ,</strong> where the first two characters represent hour (between 00 to 23 ) and the last two characters represent minutes (this will be &lt;= 59 and &gt;= 0).</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-194">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-size-subarray-sum/description" target="_blank" rel="noopener noreferrer">Minimum Size Subarray Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a </em><span data-keyword="subarray-nonempty"><em>subarray</em></span><em> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = 4, nums = [1,4,4]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>.</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, our task is to return the minimal length of a subarray whose sum is greater than or equal to <code>target</code>. If there is no such subarray, we have to return <code>0</code>.</p>
<hr />
<h3 id="approach-sliding-window">Approach: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>An intuitive technique is to go through all the subarrays one by one and check the sum of each one. If the total of the subarray under consideration is larger than or equal to <code>target</code>, we attempt to update our answer variable by using the minimum of the current answer and the length of this subarray. To get all the subarrays, we can run two loops: the outer loop selects a starting point and the inner loop selects an ending point. This solution, however, will take <span class="math inline">\(O(n^2)\)</span> time, resulting in a time limit exceeded (TLE).</p>
<p>Let's think whether we really need to iterate over all the subarrays.</p>
<p>Given that we only have positive integers, there is no purpose in adding further elements to a subarray if its sum exceeds or equals <code>target</code>. Adding more elements to such a subarray will result in the construction of longer subarrays, which is useless because we have already found a smaller subarray that meets our requirements.</p>
<p>Only if the sum of the current subarray under consideration is smaller than <code>target</code>, we should append elements to the subarray. When the sum of the subarrays exceeds or equals <code>target</code>, we will attempt to update our answer with the length of the current subarray.</p>
<p>We now try to remove the elements from the start and see if we can form a smaller subarray that meets our requirements. We remove the first element from the subarray and check if we still have the total higher than or equal to <code>target</code>. If the total exceeds or equals <code>target</code>, we have a smaller subarray that meets our requirement. As a result, we again try to update our answer with the length of the current subarray and repeat the process of eliminating the first element from the current subarray until the sum no longer exceeds or equals <code>target</code>.</p>
<p>Now after removing elements, if the sum of the subarray is less than <code>target</code>, we have to append more elements to it until the sum becomes larger than or equal to <code>target</code>. We append elements until the sum equals or exceeds <code>target</code>, then try to update our answer variable and repeat the process of eliminating the first element.</p>
<p>The above approach can be efficiently solved using the <strong>sliding window approach</strong>.</p>
<p>If you are not familiar with sliding window, please refer to our explore cards <a href="https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/">Sliding Window Explore Card</a>.</p>
<p>A sliding window is achieved by using two pointers <code>left</code> and <code>right</code>, which point to the starting and ending indices of the subarray. We set them to a value of <code>0</code>.</p>
<p>To &quot;add&quot; elements to the window, we loop over the array by incrementing <code>right</code>. In this problem, if the sum of the window exceeds or equals <code>target</code>, we try to update our answer and then &quot;remove&quot; elements from the window by incrementing <code>left</code> until the sum is less than <code>target</code> again.</p>
<p>Here's a visual representation of how the approach works:</p>
<p>!?!../Documents/209/209-slides.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create three integer variables <code>left</code>, <code>right</code> and <code>sumOfCurrentWindow</code>. The variables <code>left</code> and <code>right</code> form a subarray by pointing to the starting and ending indices of the current subarray (or window), and <code>sumOfCurrentWindow</code> stores the sum of this window. Initialize all of them with <code>0</code>.</li>
<li>Create another variable <code>res</code> to store the answer to the problem. We initialize it to a large integer value.</li>
<li>We iterate over <code>nums</code> using <code>right</code> starting from <code>right = 0</code> till <code>nums.length - 1</code> incrementing <code>right</code> by <code>1</code> after each iteration. We perform the following inside this iteration:
<ul>
<li>Add element at index <code>right</code> to the current window, incrementing <code>sumOfCurrentWindow</code> by <code>nums[right]</code>.</li>
<li>We check if <code>sumOfCurrentWindow &gt;= target</code>. If so, we have a subarray that satisfies our condition. As a result, we attempt to update our answer variable with the length of this subarray. We perform <code>res = min(res, right - left + 1)</code>. We then remove the first element from this window by reducing <code>sumOfCurrentWindow</code> by <code>nums[left]</code> and incrementing <code>left</code> by <code>1</code>. This step is repeated in an inner loop as long as <code>sumOfCurrentWindow &gt;= target</code>.</li>
<li>The current window's sum is now smaller than <code>target</code>. We need to add more elements to it. As a result, <code>right</code> is incremented by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>res</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AX72e7bN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the length of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>You may be thinking: there is an inner while loop inside another for loop, isn't the time complexity <span class="math inline">\(O(n^2)\)</span>? The reason it is still <span class="math inline">\(O(n)\)</span> is because the right pointer <code>right</code> can move <span class="math inline">\(n\)</span> times and the left pointer <code>left</code> can move also <span class="math inline">\(n\)</span> times in total. The inner loop is not running <span class="math inline">\(n\)</span> times for each iteration of the outer loop. A sliding window guarantees a maximum of <span class="math inline">\(2n\)</span> window iterations. This is what is referred to as <a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized analysis</a> - even though the worst case for an iteration inside the for loop is <span class="math inline">\(O(n)\)</span>, it averages out to <span class="math inline">\(O(1)\)</span> when you consider the entire runtime of the algorithm.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>We are not using any extra space other than a few integer variables:<code>left</code>, <code>right</code>, <code>sumOfCurrentWindow</code>, and <code>res</code>, which takes up constant space each.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-195">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-space-wasted-from-packaging/description" target="_blank" rel="noopener noreferrer">Minimum Space Wasted From Packaging</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> packages that you are trying to place in boxes, <strong>one package in each box</strong>. There are <code>m</code> suppliers that each produce boxes of <strong>different sizes</strong> (with infinite supply). A package can be placed in a box if the size of the package is <strong>less than or equal to</strong> the size of the box.</p>

<p>The package sizes are given as an integer array <code>packages</code>, where <code>packages[i]</code> is the <strong>size</strong> of the <code>i<sup>th</sup></code> package. The suppliers are given as a 2D integer array <code>boxes</code>, where <code>boxes[j]</code> is an array of <strong>box sizes</strong> that the <code>j<sup>th</sup></code> supplier produces.</p>

<p>You want to choose a <strong>single supplier</strong> and use boxes from them such that the <strong>total wasted space </strong>is <strong>minimized</strong>. For each package in a box, we define the space <strong>wasted</strong> to be <code>size of the box - size of the package</code>. The <strong>total wasted space</strong> is the sum of the space wasted in <strong>all</strong> the boxes.</p>

<ul>
	<li>For example, if you have to fit packages with sizes <code>[2,3,5]</code> and the supplier offers boxes of sizes <code>[4,8]</code>, you can fit the packages of size-<code>2</code> and size-<code>3</code> into two boxes of size-<code>4</code> and the package with size-<code>5</code> into a box of size-<code>8</code>. This would result in a waste of <code>(4-2) + (4-3) + (8-5) = 6</code>.</li>
</ul>

<p>Return <em>the <strong>minimum total wasted space</strong> by choosing the box supplier <strong>optimally</strong>, or </em><code>-1</code> <i>if it is <strong>impossible</strong> to fit all the packages inside boxes. </i>Since the answer may be <strong>large</strong>, return it <strong>modulo </strong><code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> packages = [2,3,5], boxes = [[4,8],[2,8]]
<strong>Output:</strong> 6
<strong>Explanation</strong>: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.
The total waste is (4-2) + (4-3) + (8-5) = 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no box that the package of size 5 can fit in.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
<strong>Output:</strong> 9
<strong>Explanation:</strong> It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.
The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == packages.length</code></li>
	<li><code>m == boxes.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= packages[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= boxes[j].length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= boxes[j][k] &lt;= 10<sup>5</sup></code></li>
	<li><code>sum(boxes[j].length) &lt;= 10<sup>5</sup></code></li>
	<li>The elements in <code>boxes[j]</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-196">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-speed-to-arrive-on-time/description" target="_blank" rel="noopener noreferrer">Minimum Speed to Arrive on Time</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a floating-point number <code>hour</code>, representing the amount of time you have to reach the office. To commute to the office, you must take <code>n</code> trains in sequential order. You are also given an integer array <code>dist</code> of length <code>n</code>, where <code>dist[i]</code> describes the distance (in kilometers) of the <code>i<sup>th</sup></code> train ride.</p>

<p>Each train can only depart at an integer hour, so you may need to wait in between each train ride.</p>

<ul>
	<li>For example, if the <code>1<sup>st</sup></code> train ride takes <code>1.5</code> hours, you must wait for an additional <code>0.5</code> hours before you can depart on the <code>2<sup>nd</sup></code> train ride at the 2 hour mark.</li>
</ul>

<p>Return <em>the <strong>minimum positive integer</strong> speed <strong>(in kilometers per hour)</strong> that all the trains must travel at for you to reach the office on time, or </em><code>-1</code><em> if it is impossible to be on time</em>.</p>

<p>Tests are generated such that the answer will not exceed <code>10<sup>7</sup></code> and <code>hour</code> will have <strong>at most two digits after the decimal point</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> dist = [1,3,2], hour = 6
<strong>Output:</strong> 1
<strong>Explanation: </strong>At speed 1:
- The first train ride takes 1/1 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
- You will arrive at exactly the 6 hour mark.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> dist = [1,3,2], hour = 2.7
<strong>Output:</strong> 3
<strong>Explanation: </strong>At speed 3:
- The first train ride takes 1/3 = 0.33333 hours.
- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
- You will arrive at the 2.66667 hour mark.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> dist = [1,3,2], hour = 1.9
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible because the earliest the third train can depart is at the 2 hour mark.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == dist.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= dist[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= hour &lt;= 10<sup>9</sup></code></li>
	<li>There will be at most two digits after the decimal point in <code>hour</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-197">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-stability-factor-of-array/description" target="_blank" rel="noopener noreferrer">Minimum Stability Factor of Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>maxC</code>.</p>

<p>A <strong><span data-keyword="subarray">subarray</span></strong> is called <strong>stable</strong> if the <em>highest common factor (HCF)</em> of all its elements is <strong>greater than or equal to</strong> 2.</p>

<p>The <strong>stability factor</strong> of an array is defined as the length of its <strong>longest</strong> stable subarray.</p>

<p>You may modify <strong>at most</strong> <code>maxC</code> elements of the array to any integer.</p>

<p>Return the <strong>minimum</strong> possible stability factor of the array after at most <code>maxC</code> modifications. If no stable subarray remains, return 0.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>The <strong>highest common factor (HCF)</strong> of an array is the largest integer that evenly divides all the array elements.</li>
	<li>A <strong>subarray</strong> of length 1 is stable if its only element is greater than or equal to 2, since <code>HCF([x]) = x</code>.</li>
</ul>

<div class="notranslate" style="all: initial;"> </div>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,5,10], maxC = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The stable subarray <code>[5, 10]</code> has <code>HCF = 5</code>, which has a stability factor of 2.</li>
	<li>Since <code>maxC = 1</code>, one optimal strategy is to change <code>nums[1]</code> to <code>7</code>, resulting in <code>nums = [3, 7, 10]</code>.</li>
	<li>Now, no subarray of length greater than 1 has <code>HCF &gt;= 2</code>. Thus, the minimum possible stability factor is 1.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,6,8], maxC = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The subarray <code>[2, 6, 8]</code> has <code>HCF = 2</code>, which has a stability factor of 3.</li>
	<li>Since <code>maxC = 2</code>, one optimal strategy is to change <code>nums[1]</code> to 3 and <code>nums[2]</code> to 5, resulting in <code>nums = [2, 3, 5]</code>.</li>
	<li>Now, no subarray of length greater than 1 has <code>HCF &gt;= 2</code>. Thus, the minimum possible stability factor is 1.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,4,9,6], maxC = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The stable subarrays are:
	<ul>
		<li><code>[2, 4]</code> with <code>HCF = 2</code> and stability factor of 2.</li>
		<li><code>[9, 6]</code> with <code>HCF = 3</code> and stability factor of 2.</li>
	</ul>
	</li>
	<li>Since <code>maxC = 1</code>, the stability factor of 2 cannot be reduced due to two separate stable subarrays. Thus, the minimum possible stability factor is 2.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= maxC &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-198">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-sum4058/1" target="_blank" rel="noopener noreferrer">Minimum sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[ ]</strong> consisting of digits, your task is to form <strong data-start="485" data-end="500">two numbers</strong> using all the digits such that their sum is<strong data-start="542" data-end="562"> minimized</strong>. Return the minimum possible sum as a <strong data-start="601" data-end="611">string</strong> with <strong data-start="617" data-end="638">no leading zeroes</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [6, 8, 4, 5, 2, 3]
<strong>Output:</strong> "604"
<strong>Explanation:</strong> The minimum sum is formed by numbers 358 and 246.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [5, 3, 0, 7, 4]
<strong>Output:</strong> "82"
<strong>Explanation:</strong> The minimum sum is formed by numbers 35 and 047.<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [9, 4]
<strong>Output:</strong> "13"
<strong>Explanation:</strong> The minimum sum is formed by numbers 9 and 4.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />0 &le; arr[i] &le; 9</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-199">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-sum-of-squared-difference/description" target="_blank" rel="noopener noreferrer">Minimum Sum of Squared Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, both of length <code>n</code>.</p>

<p>The <strong>sum of squared difference</strong> of arrays <code>nums1</code> and <code>nums2</code> is defined as the <strong>sum</strong> of <code>(nums1[i] - nums2[i])<sup>2</sup></code> for each <code>0 &lt;= i &lt; n</code>.</p>

<p>You are also given two positive integers <code>k1</code> and <code>k2</code>. You can modify any of the elements of <code>nums1</code> by <code>+1</code> or <code>-1</code> at most <code>k1</code> times. Similarly, you can modify any of the elements of <code>nums2</code> by <code>+1</code> or <code>-1</code> at most <code>k2</code> times.</p>

<p>Return <em>the minimum <strong>sum of squared difference</strong> after modifying array </em><code>nums1</code><em> at most </em><code>k1</code><em> times and modifying array </em><code>nums2</code><em> at most </em><code>k2</code><em> times</em>.</p>

<p><strong>Note</strong>: You are allowed to modify the array elements to become <strong>negative</strong> integers.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
<strong>Output:</strong> 579
<strong>Explanation:</strong> The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. 
The sum of square difference will be: (1 - 2)<sup>2 </sup>+ (2 - 10)<sup>2 </sup>+ (3 - 20)<sup>2 </sup>+ (4 - 19)<sup>2</sup>&nbsp;= 579.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
<strong>Output:</strong> 43
<strong>Explanation:</strong> One way to obtain the minimum sum of square difference is: 
- Increase nums1[0] once.
- Increase nums2[2] once.
The minimum of the sum of square difference will be: 
(2 - 5)<sup>2 </sup>+ (4 - 8)<sup>2 </sup>+ (10 - 7)<sup>2 </sup>+ (12 - 9)<sup>2</sup>&nbsp;= 43.
Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length == nums2.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= k1, k2 &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-200">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-sum-of-values-by-dividing-array/description" target="_blank" rel="noopener noreferrer">Minimum Sum of Values by Dividing Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">queue</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays <code>nums</code> and <code>andValues</code> of length <code>n</code> and <code>m</code> respectively.</p>

<p>The <strong>value</strong> of an array is equal to the <strong>last</strong> element of that array.</p>

<p>You have to divide <code>nums</code> into <code>m</code> <strong>disjoint contiguous</strong> <span data-keyword="subarray-nonempty">subarrays</span> such that for the <code>i<sup>th</sup></code> subarray <code>[l<sub>i</sub>, r<sub>i</sub>]</code>, the bitwise <code>AND</code> of the subarray elements is equal to <code>andValues[i]</code>, in other words, <code>nums[l<sub>i</sub>] &amp; nums[l<sub>i</sub> + 1] &amp; ... &amp; nums[r<sub>i</sub>] == andValues[i]</code> for all <code>1 &lt;= i &lt;= m</code>, where <code>&amp;</code> represents the bitwise <code>AND</code> operator.</p>

<p>Return <em>the <strong>minimum</strong> possible sum of the <strong>values</strong> of the </em><code>m</code><em> subarrays </em><code>nums</code><em> is divided into</em>. <em>If it is not possible to divide </em><code>nums</code><em> into </em><code>m</code><em> subarrays satisfying these conditions, return</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,3,3,2], andValues = [0,3,3,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<p>The only possible way to divide <code>nums</code> is:</p>

<ol>
	<li><code>[1,4]</code> as <code>1 &amp; 4 == 0</code>.</li>
	<li><code>[3]</code> as the bitwise <code>AND</code> of a single element subarray is that element itself.</li>
	<li><code>[3]</code> as the bitwise <code>AND</code> of a single element subarray is that element itself.</li>
	<li><code>[2]</code> as the bitwise <code>AND</code> of a single element subarray is that element itself.</li>
</ol>

<p>The sum of the values for these subarrays is <code>4 + 3 + 3 + 2 = 12</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,5,7,7,7,5], andValues = [0,7,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">17</span></p>

<p><strong>Explanation:</strong></p>

<p>There are three ways to divide <code>nums</code>:</p>

<ol>
	<li><code>[[2,3,5],[7,7,7],[5]]</code> with the sum of the values <code>5 + 7 + 5 == 17</code>.</li>
	<li><code>[[2,3,5,7],[7,7],[5]]</code> with the sum of the values <code>7 + 7 + 5 == 19</code>.</li>
	<li><code>[[2,3,5,7,7],[7],[5]]</code> with the sum of the values <code>7 + 7 + 5 == 19</code>.</li>
</ol>

<p>The minimum possible sum of the values is <code>17</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4], andValues = [2]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>The bitwise <code>AND</code> of the entire array <code>nums</code> is <code>0</code>. As there is no possible way to divide <code>nums</code> into a single subarray to have the bitwise <code>AND</code> of elements <code>2</code>, return <code>-1</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= m == andValues.length &lt;= min(n, 10)</code></li>
	<li><code>1 &lt;= nums[i] &lt; 10<sup>5</sup></code></li>
	<li><code>0 &lt;= andValues[j] &lt; 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-201">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-for-k-connected-components/description" target="_blank" rel="noopener noreferrer">Minimum Time for K Connected Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an undirected graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code> indicates an undirected edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> that can be removed at <code>time<sub>i</sub></code>.</p>

<p>You are also given an integer <code>k</code>.</p>

<p>Initially, the graph may be connected or disconnected. Your task is to find the <strong>minimum</strong> time <code>t</code> such that after removing all edges with <code>time &lt;= t</code>, the graph contains <strong>at least</strong> <code>k</code> connected components.</p>

<p>Return the <strong>minimum</strong> time <code>t</code>.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1,3]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022724.png" style="width: 230px; height: 85px;" /></p>

<ul>
	<li>Initially, there is one connected component <code>{0, 1}</code>.</li>
	<li>At <code>time = 1</code> or <code>2</code>, the graph remains unchanged.</li>
	<li>At <code>time = 3</code>, edge <code>[0, 1]</code> is removed, resulting in <code>k = 2</code> connected components <code>{0}</code>, <code>{1}</code>. Thus, the answer is 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[1,2,4]], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022812.png" style="width: 180px; height: 164px;" /></p>

<ul>
	<li>Initially, there is one connected component <code>{0, 1, 2}</code>.</li>
	<li>At <code>time = 2</code>, edge <code>[0, 1]</code> is removed, resulting in two connected components <code>{0}</code>, <code>{1, 2}</code>.</li>
	<li>At <code>time = 4</code>, edge <code>[1, 2]</code> is removed, resulting in <code>k = 3</code> connected components <code>{0}</code>, <code>{1}</code>, <code>{2}</code>. Thus, the answer is 4.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,2,5]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022930.png" style="width: 180px; height: 155px;" /></p>

<ul>
	<li>Since there are already <code>k = 2</code> disconnected components <code>{1}</code>, <code>{0, 2}</code>, no edge removal is needed. Thus, the answer is 0.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-202">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-activate-string/description" target="_blank" rel="noopener noreferrer">Minimum Time to Activate String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of length <code>n</code> and an integer array <code>order</code>, where <code>order</code> is a <strong><span data-keyword="permutation">permutation</span></strong> of the numbers in the range <code>[0, n - 1]</code>.</p>

<p>Starting from time <code>t = 0</code>, replace the character at index <code>order[t]</code> in <code>s</code> with <code>&#39;*&#39;</code> at each time step.</p>

<p>A <strong><span data-keyword="substring-nonempty">substring</span></strong> is <strong>valid</strong> if it contains <strong>at least</strong> one <code>&#39;*&#39;</code>.</p>

<p>A string is <strong>active</strong> if the total number of <strong>valid</strong> substrings is greater than or equal to <code>k</code>.</p>

<p>Return the <strong>minimum</strong> time <code>t</code> at which the string <code>s</code> becomes <strong>active</strong>. If it is impossible, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abc&quot;, order = [1,0,2], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;"><code>t</code></th>
			<th style="border: 1px solid black;"><code>order[t]</code></th>
			<th style="border: 1px solid black;">Modified <code>s</code></th>
			<th style="border: 1px solid black;">Valid Substrings</th>
			<th style="border: 1px solid black;">Count</th>
			<th style="border: 1px solid black;">Active<br />
			(Count &gt;= k)</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>&quot;a*c&quot;</code></td>
			<td style="border: 1px solid black;"><code>&quot;*&quot;</code>, <code>&quot;a*&quot;</code>, <code>&quot;*c&quot;</code>, <code>&quot;a*c&quot;</code></td>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">Yes</td>
		</tr>
	</tbody>
</table>

<p>The string <code>s</code> becomes active at <code>t = 0</code>. Thus, the answer is 0.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;cat&quot;, order = [0,2,1], k = 6</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;"><code>t</code></th>
			<th style="border: 1px solid black;"><code>order[t]</code></th>
			<th style="border: 1px solid black;">Modified <code>s</code></th>
			<th style="border: 1px solid black;">Valid Substrings</th>
			<th style="border: 1px solid black;">Count</th>
			<th style="border: 1px solid black;">Active<br />
			(Count &gt;= k)</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>&quot;*at&quot;</code></td>
			<td style="border: 1px solid black;"><code>&quot;*&quot;</code>, <code>&quot;*a&quot;</code>, <code>&quot;*at&quot;</code></td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">No</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;"><code>&quot;*a*&quot;</code></td>
			<td style="border: 1px solid black;"><code>&quot;*&quot;</code>, <code>&quot;*a&quot;</code>, <code>&quot;<code inline="">*a*&quot;</code></code>, <code>&quot;<code inline="">a*&quot;</code></code>, <code>&quot;*&quot;</code></td>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">No</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>&quot;***&quot;</code></td>
			<td style="border: 1px solid black;">All substrings (contain <code>&#39;*&#39;</code>)</td>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">Yes</td>
		</tr>
	</tbody>
</table>

<p>The string <code>s</code> becomes active at <code>t = 2</code>. Thus, the answer is 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;xy&quot;, order = [0,1], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>Even after all replacements, it is impossible to obtain <code>k = 4</code> valid substrings. Thus, the answer is -1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>order.length == n</code></li>
	<li><code>0 &lt;= order[i] &lt;= n - 1</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>order</code> is a permutation of integers from 0 to <code>n - 1</code>.</li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-203">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-complete-all-tasks/description" target="_blank" rel="noopener noreferrer">Minimum Time to Complete All Tasks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a computer that can run an unlimited number of tasks <strong>at the same time</strong>. You are given a 2D integer array <code>tasks</code> where <code>tasks[i] = [start<sub>i</sub>, end<sub>i</sub>, duration<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> task should run for a total of <code>duration<sub>i</sub></code> seconds (not necessarily continuous) within the <strong>inclusive</strong> time range <code>[start<sub>i</sub>, end<sub>i</sub>]</code>.</p>

<p>You may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.</p>

<p>Return <em>the minimum time during which the computer should be turned on to complete all tasks</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [[2,3,1],[4,5,1],[1,5,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- The first task can be run in the inclusive time range [2, 2].
- The second task can be run in the inclusive time range [5, 5].
- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].
The computer will be on for a total of 2 seconds.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [[1,3,2],[2,5,3],[5,6,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
- The first task can be run in the inclusive time range [2, 3].
- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].
- The third task can be run in the two inclusive time range [5, 6].
The computer will be on for a total of 4 seconds.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>
	<li><code>tasks[i].length == 3</code></li>
	<li><code>1 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 2000</code></li>
	<li><code>1 &lt;= duration<sub>i</sub> &lt;= end<sub>i</sub> - start<sub>i</sub> + 1 </code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-204">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-complete-trips/description" target="_blank" rel="noopener noreferrer">Minimum Time to Complete Trips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>time</code> where <code>time[i]</code> denotes the time taken by the <code>i<sup>th</sup></code> bus to complete <strong>one trip</strong>.</p>

<p>Each bus can make multiple trips <strong>successively</strong>; that is, the next trip can start <strong>immediately after</strong> completing the current trip. Also, each bus operates <strong>independently</strong>; that is, the trips of one bus do not influence the trips of any other bus.</p>

<p>You are also given an integer <code>totalTrips</code>, which denotes the number of trips all buses should make <strong>in total</strong>. Return <em>the <strong>minimum time</strong> required for all buses to complete <strong>at least</strong> </em><code>totalTrips</code><em> trips</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> time = [1,2,3], totalTrips = 5
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- At time t = 1, the number of trips completed by each bus are [1,0,0]. 
  The total number of trips completed is 1 + 0 + 0 = 1.
- At time t = 2, the number of trips completed by each bus are [2,1,0]. 
  The total number of trips completed is 2 + 1 + 0 = 3.
- At time t = 3, the number of trips completed by each bus are [3,1,1]. 
  The total number of trips completed is 3 + 1 + 1 = 5.
So the minimum time needed for all buses to complete at least 5 trips is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> time = [2], totalTrips = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong>
There is only one bus, and it will complete its first trip at t = 2.
So the minimum time needed to complete 1 trip is 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= time.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= time[i], totalTrips &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-205">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-repair-cars/description" target="_blank" rel="noopener noreferrer">Minimum Time to Repair Cars</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>ranks</code> representing the <strong>ranks</strong> of some mechanics. <font face="monospace">ranks<sub>i</sub></font> is the rank of the <font face="monospace">i<sup>th</sup></font> mechanic<font face="monospace">.</font> A mechanic with a rank <code>r</code> can repair <font face="monospace">n</font> cars in <code>r * n<sup>2</sup></code> minutes.</p>

<p>You are also given an integer <code>cars</code> representing the total number of cars waiting in the garage to be repaired.</p>

<p>Return <em>the <strong>minimum</strong> time taken to repair all the cars.</em></p>

<p><strong>Note:</strong> All the mechanics can repair the cars simultaneously.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ranks = [4,2,3,1], cars = 10
<strong>Output:</strong> 16
<strong>Explanation:</strong> 
- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.
- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.
- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.
- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ranks = [5,1,8], cars = 6
<strong>Output:</strong> 16
<strong>Explanation:</strong> 
- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.
- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= ranks.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= ranks[i] &lt;= 100</code></li>
	<li><code>1 &lt;= cars &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>ranks</code>, where <code>ranks[i]</code> represents the efficiency of the <code>i</code>-th mechanic. A mechanic with a rank <code>r</code> repairs <code>n</code> cars in <code>r * n^2</code> minutes, meaning the time required increases quadratically as more cars are assigned to a single mechanic. We also have an integer <code>cars</code>, representing the total number of cars that need to be repaired. The goal is to determine the minimum possible time required to repair all cars if all mechanics work simultaneously.</p>
<p>To understand the problem, consider the example where <code>ranks = [4,2,3,1]</code> and <code>cars = 10</code>. The optimal allocation would be:</p>
<ul>
<li>The first mechanic (rank <code>4</code>) repairs <code>2</code> cars, taking <span class="math inline">\(4 * 2^2 = 16\)</span> minutes.</li>
<li>The second mechanic (rank <code>2</code>) repairs <code>2</code> cars, taking <span class="math inline">\(2 * 2^2 = 8\)</span> minutes.</li>
<li>The third mechanic (rank <code>3</code>) repairs <code>2</code> cars, taking <span class="math inline">\(3 * 2^2 = 12\)</span> minutes.</li>
<li>The fourth mechanic (rank <code>1</code>) repairs <code>4</code> cars, taking <span class="math inline">\(1 * 4^2 = 16\)</span> minutes.</li>
</ul>
<p>Since all mechanics work in parallel, the total time required is determined by the slowest mechanic in the optimal assignment, which is <code>16</code> minutes.</p>
<p>The problem essentially boils down to distributing the cars optimally among the mechanics so that the maximum repair time (the slowest mechanic) is minimized. Another way to say this is that a mechanic with a lower rank (higher skill) can repair cars faster than one with a higher rank. A brute force approach of checking every possible distribution would be highly inefficient, so we need a smarter strategy.</p>
<p>A common mistake is misunderstanding how parallel execution works. Instead of focusing on the slowest mechanic, some mistakenly add up all the repair times, as if the tasks were done sequentially. This misinterpretation leads to incorrect conclusions about the total time required.</p>
<p>Another mistake is assuming dynamic programming (DP) is always the right approach for optimization problems. When faced with minimization or maximization, our first instinct might be to reach for DP. However, before committing to it, we need to check the constraints. If the problem lacks overlapping subproblems or an optimal substructure, DP may not be a suitable choice.</p>
<p>In this problem, we are given:</p>
<ul>
<li><code>ranks.length</code> can be up to <span class="math inline">\(10^5\)</span></li>
<li><code>cars</code> can be up to <span class="math inline">\(10^6\)</span></li>
</ul>
<p>A typical DP solution would require a state representation like <code>dp[mechanic][car]</code>. The time complexity would then be <span class="math inline">\(O(n \cdot cars)\)</span>, which in the worst case is <span class="math inline">\(10^5 × 10^6 = 10^{11}\)</span> operations. This is far too large to be computationally feasible.</p>
<p>A good approach here can be to use binary search, as it provides a more natural way to minimize the maximum time while still efficiently distributing cars. We will talk about it more in <a href="#approach-1-binary-search-on-time">approach one</a>.</p>
<blockquote>
<p>Takeaway Tip: When deciding on an approach, always check the constraints first. If <code>n</code> and <code>cars</code> are large (in the range of <span class="math inline">\(10^5\)</span> to <span class="math inline">\(10^6\)</span>), DP is usually not feasible. Instead, binary search, greedy, or two pointers are more likely to work in such cases.</p>
</blockquote>
<hr />
<h3 id="approach-1-binary-search-on-time">Approach 1: Binary Search on Time</h3>
<h4 id="intuition">Intuition</h4>
<p>Given the relationship that a mechanic with a lower rank (higher skill) can repair cars faster than one with a higher rank, the key observation is that if we fix a certain amount of time <code>t</code>, we can determine how many cars can be repaired within <code>t</code> by all available mechanics. Since we want the minimum possible time to repair all cars, we can apply binary search on the time.</p>
<p>More technically, given a fixed time <code>t</code>, we can determine how many cars can be repaired within that time using a simple formula. But how do we actually find the smallest <code>t</code> that allows all cars to be repaired?</p>
<p>We observe that if a given time <code>t</code> is sufficient to repair all cars, then any time greater than <code>t</code> will also be sufficient. Conversely, if <code>t</code> is not enough, then any time smaller than <code>t</code> will also fail.</p>
<p>This forms a monotonic relationship:</p>
<ul>
<li>If <code>t</code> is too small, increasing <code>t</code> will eventually make it work.</li>
<li>If <code>t</code> is large enough, decreasing <code>t</code> will still work until we hit the minimum threshold.</li>
</ul>
<p>This kind of &quot;yes/no&quot; behavior, where a function transitions from failure to success at a specific boundary, is exactly when binary search is useful. Instead of checking every possible value of <code>t</code> from <code>1</code> to <code>minRank * cars^2</code>, we can narrow down the search space logarithmically.</p>
<p>We define our search space based on the slowest possible case. The minimum possible time is <code>1</code>, and the maximum time is when the slowest mechanic (one with the lowest rank) repairs all cars alone. This worst-case scenario takes <code>minRank * cars^2</code> time.</p>
<p>We perform <strong>binary search</strong> over this time range. For each candidate time <span class="math inline">\(\text{mid}\)</span>, we check how many cars can be repaired within <span class="math inline">\(\text{mid}\)</span>.</p>
<p>Since the time required by a mechanic with rank <code>r</code> to repair <code>n</code> cars follows the formula:</p>
<p><span class="math inline">\(T = r \cdot n^2\)</span></p>
<p>We need to determine the maximum number of cars a mechanic can repair within <span class="math inline">\(\text{mid}\)</span>, which means solving:</p>
<p><span class="math inline">\(r \cdot n^2 \leq \text{mid}\)</span></p>
<p>Solving for <code>n</code>:</p>
<p><span class="math inline">\(n \leq \sqrt{\frac{\text{mid}}{r}}\)</span></p>
<p>Thus, for each mechanic with rank <code>r</code>, the maximum number of cars they can repair within <span class="math inline">\(\text{mid}\)</span> is:</p>
<p><span class="math inline">\(\lfloor \sqrt{\frac{\text{mid}}{r}} \rfloor\)</span></p>
<p>We sum up the number of cars each mechanic can repair and compare it with the required number of cars. If the total is at least the required number, we adjust our binary search range accordingly.</p>
<p>If the total number of repaired cars is at least the required number of cars, it means we might be able to complete all repairs in a smaller time, so we move left in the binary search by setting <code>high = mid</code>. Otherwise, if the number of repaired cars is too low, we need more time, so we move right by setting <code>low = mid + 1</code>.</p>
<p>To implement, we first determine the smallest rank among all mechanics since it defines our upper bound (<code>minRank * cars^2</code>). Then, we maintain a frequency array <code>freq</code> to count how many mechanics have each rank, which allows us to efficiently compute the total number of repaired cars at any given time.</p>
<p>We initialize <code>low = 1</code> and <code>high = minRank * cars^2</code>, then apply binary search. For each <code>mid</code> value, we iterate over all possible ranks (from <code>1</code> to <code>maxRank</code>) and compute how many cars can be repaired by mechanics of that rank using <code>sqrt(mid / r)</code>. If the total repaired cars meet or exceed the requirement, we shrink the search space (<code>high = mid</code>). Otherwise, we expand it (<code>low = mid + 1</code>).</p>
<p>Once the binary search terminates, <code>low</code> contains the minimum time required to repair all cars.</p>
<p>The algorithm is visualized below:</p>
<p><img src="../Figures/2594/Binary_approach1.png" alt="Binary_approach1" /></p>
<blockquote>
<p>For a more comprehensive understanding of binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card 🔗</a>. This resource provides an in-depth look at binary search, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>minRank</code> to track the minimum rank in <code>ranks</code>.</p>
</li>
<li>
<p>Initialize <code>freq</code> array of size <code>101</code> to count the number of mechanics with each rank.</p>
</li>
<li>
<p>Iterate through <code>ranks</code>:</p>
<ul>
<li>Update <code>minRank</code> with the smallest rank encountered.</li>
<li>Increment <code>freq</code> at index <code>rank</code> to track the count of mechanics with that rank.</li>
</ul>
</li>
<li>
<p>Set <code>low</code> to <code>1</code> (minimum possible repair time).</p>
</li>
<li>
<p>Set <code>high</code> to <code>minRank * cars * cars</code> (worst-case longest repair time).</p>
</li>
<li>
<p>Perform binary search while <code>low &lt; high</code>:</p>
<ul>
<li>
<p>Compute <code>mid</code> as the middle value between <code>low</code> and <code>high</code>.</p>
</li>
<li>
<p>Initialize <code>carsRepaired</code> to count total cars repaired in <code>mid</code> time.</p>
</li>
<li>
<p>Iterate through possible ranks from <code>1</code> to <code>maxRank + 1</code>:</p>
<ul>
<li>Calculate the number of cars repaired by mechanics of each rank.</li>
<li>Use <code>freq[rank] * sqrt(mid / rank)</code> to compute repairs.</li>
</ul>
</li>
<li>
<p>If <code>carsRepaired</code> is at least <code>cars</code>, update <code>high = mid</code> to find a smaller valid time.</p>
</li>
<li>
<p>Else, update <code>low = mid + 1</code> since more time is needed.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>low</code>, the minimum time required to repair all cars.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p><strong>Fun Tip:</strong> The maximum possible <code>maxRank</code> is 100, so we can also hardcode the frequency array size to 101 instead of dynamically allocating it as <code>maxRank + 1</code>.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/PG5i8Xjo/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>ranks</code> array, <span class="math inline">\(m\)</span> be the number of cars (<code>cars</code>).</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n + \text{max\_rank} \log (m \cdot \text{max\_rank}))\)</span></p>
<p>The algorithm starts by iterating through the <code>ranks</code> array to compute the minimum rank and build a frequency array. This step takes <span class="math inline">\(O(n)\)</span> time, as it involves a single pass over the array. Next, the algorithm performs a binary search over the possible time range, which spans from 1 to <span class="math inline">\(1L \cdot \text{minRank} \cdot m \cdot m\)</span>. The binary search runs in <span class="math inline">\(O(\log (m \cdot \text{max\_rank}))\)</span> iterations, where <span class="math inline">\(\text{max\_rank}\)</span> is the maximum rank in the <code>ranks</code> array.</p>
<p>For each iteration of the binary search, the algorithm calculates the total number of cars that can be repaired in <code>mid</code> time. This involves iterating over the frequency array which has a fixed size of <span class="math inline">\(\text{max\_rank}\)</span> and computing the square root of the ratio of <code>mid</code> to the rank for each entry. This computation takes <span class="math inline">\(O(\text{max\_rank})\)</span> time per iteration. Combining these steps, the overall time complexity is <span class="math inline">\(O(n + \text{max\_rank} \log (m \cdot \text{max\_rank}))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\text{max\_rank})\)</span></p>
<p>The algorithm uses a frequency array of size <span class="math inline">\(\text{max\_rank}\)</span> to store the count of mechanics for each rank. This array occupies <span class="math inline">\(O(\text{max\_rank})\)</span> space. Additionally, a few variables are used for the binary search (<code>low</code>, <code>high</code>, <code>mid</code>, <code>carsRepaired</code>) and for storing the minimum rank, all of which require constant space, <span class="math inline">\(O(1)\)</span>. Thus, the overall space complexity is <span class="math inline">\(O(\text{max\_rank})\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-space-optimized-binary-search">Approach 2: Space Optimized Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we precomputed the smallest rank and used a frequency array to count how many mechanics had each rank. The idea behind this was to speed up the calculation of how many cars could be repaired in a given time. However, this extra bookkeeping can be removed if we want to space optimize it because we can determine the number of cars repaired directly by iterating over the <code>ranks</code> array.</p>
<p>More specifically, instead of grouping mechanics by rank and iterating over a fixed range of possible ranks (from <code>1</code> to <code>100</code>), we can simply iterate over the given ranks and compute the number of cars each mechanic can repair on the fly. This removes the processing and makes the solution more straightforward while maintaining the same logic.</p>
<p>With this optimization in mind, we keep the core idea of binary search on time. The search space remains the same: the lower bound is <code>1</code>, representing the smallest unit of time, while the upper bound is <code>ranks[0] * cars^2</code>, representing the worst-case scenario where the slowest mechanic repairs all cars alone.</p>
<p>For a given <code>mid</code> time, we compute how many cars can be repaired by summing up contributions from all mechanics. The number of cars a mechanic with rank <code>r</code> can repair within <code>mid</code> time is given by <code>n ≤ sqrt(mid / r)</code>, since repairing <code>n</code> cars requires <code>r * n^2</code> time. By iterating over the <code>ranks</code> array and applying this formula to each mechanic, we calculate the total number of repaired cars and compare it with the required amount.</p>
<p>If the total number of repaired cars is less than the required amount, it means <code>mid</code> is too small, so we increase <code>low</code> (<code>low = mid + 1</code>). Otherwise, if the total is at least the required amount, we try to minimize the repair time by decreasing <code>high</code> (<code>high = mid</code>).</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Set <code>low</code> to <code>1</code>, the minimum possible repair time.</p>
</li>
<li>
<p>Set <code>high</code> to <code>ranks[0] * cars * cars</code>, the worst-case maximum repair time.</p>
</li>
<li>
<p>Perform binary search while <code>low &lt; high</code>:</p>
<ul>
<li>
<p>Compute <code>mid</code> as the middle value between <code>low</code> and <code>high</code>.</p>
</li>
<li>
<p>Initialize <code>carsRepaired</code> to count total cars repaired in <code>mid</code> time.</p>
</li>
<li>
<p>Iterate through <code>ranks</code>:</p>
<ul>
<li>Calculate the number of cars repaired by each mechanic using <code>sqrt(mid / rank)</code>.</li>
<li>Accumulate the total <code>carsRepaired</code>.</li>
</ul>
</li>
<li>
<p>If <code>carsRepaired</code> is less than <code>cars</code>, update <code>low = mid + 1</code> since more time is needed.</p>
</li>
<li>
<p>Else, update <code>high = mid</code> to search for a smaller valid time.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>low</code>, the minimum time required to repair all cars.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/PSqauVuG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>ranks</code> array, <span class="math inline">\(m\)</span> be the number of cars (<code>cars</code>), and <span class="math inline">\(k\)</span> be the maximum possible rank (<code>100</code> in this case).</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot \log (m \cdot \text{max\_rank}))\)</span></p>
<p>The algorithm performs a binary search over the possible time range, which takes <span class="math inline">\(O(\log (m \cdot \text{max\_rank}))\)</span> iterations. For each iteration, it calculates the number of cars that can be repaired in <span class="math inline">\(O(n)\)</span> time by iterating over the <code>ranks</code> array. The overall time complexity is <span class="math inline">\(O(n \cdot \log (m \cdot \text{max\_rank}))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses only a constant amount of extra space for variables, resulting in <span class="math inline">\(O(1)\)</span> space complexity. No additional data structures are used.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-heap">Approach 3: Using Heap</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of using binary search, we can directly simulate the car repair process using a min-heap to always prioritize the mechanic who can complete the next repair in the shortest possible time. Since each mechanic follows the formula <code>time = rank * n^2</code> to determine how long it takes to repair their <code>k</code>-th car, we can predict the sequence of repair times for each mechanic. The first car takes <code>rank * 1^2 = rank</code> time, the second car takes <code>rank * 4</code> time, the third car takes <code>rank * 9</code> time, and so on.</p>
<p>Given this pattern, at any moment, the mechanic who will finish the next repair the fastest should be chosen to repair the next car. The most efficient way to track the next available repair time for all mechanics is to use a min-heap, where each entry stores the next repair time for a mechanic, their rank (to calculate future repair times), the number of cars they have already repaired, and the count of mechanics with that rank (since multiple mechanics can have the same rank).</p>
<p>We begin by initializing the heap with the first repair time for each unique rank. If multiple mechanics share the same rank, we keep track of how many exist. Then, we repeatedly extract the mechanic with the earliest repair time and assign them the next car to repair. Once a mechanic repairs a car, we compute their next available repair time using the formula <code>time = rank * (n + 1)^2</code>, then push this new time back into the heap. This process continues until all cars are repaired.</p>
<p>By always selecting the fastest available repair, we ensure that the total time remains minimal while efficiently distributing the workload among mechanics. Since each mechanic’s repair time follows a monotonically increasing pattern, the heap naturally maintains the correct ordering.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Count the frequency of each rank to determine how many mechanics have each rank.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) with elements <code>[time, rank, n, count[rank]]</code>:</p>
<ul>
<li><code>time</code>: time needed for the next repair (initially <code>rank * 1^2 = rank</code>).</li>
<li><code>rank</code>: the mechanic's rank.</li>
<li><code>n</code>: the number of cars repaired so far by this mechanic (initially 1).</li>
<li><code>count</code>: the number of mechanics with this rank.</li>
</ul>
</li>
<li>
<p>Convert <code>minHeap</code> into a valid heap to ensure the smallest repair time is at the root.</p>
</li>
<li>
<p>While there are cars left to repair:</p>
<ul>
<li>Pop the mechanic with the smallest current repair time from <code>minHeap</code>.</li>
<li>Deduct the number of cars repaired by this mechanic group from <code>cars</code>.</li>
<li>Increment the number of cars repaired by this mechanic (<code>n += 1</code>).</li>
<li>Calculate the next repair time using the formula <code>rank * n^2</code>.</li>
<li>Push the updated mechanic's info back into the heap to continue tracking their repair time.</li>
</ul>
</li>
<li>
<p>Return the time of the last repair, which is the minimum time needed to repair all cars.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RgUokLRJ/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>ranks</code> array, <span class="math inline">\(m\)</span> be the number of cars (<code>cars</code>), and <span class="math inline">\(k\)</span> be the maximum possible rank (<code>100</code> in this case).</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n + m \log k)\)</span></p>
<p>The algorithm begins by counting the frequency of each rank using a <code>Counter</code>. This step takes <span class="math inline">\(O(n)\)</span> time, as it involves iterating through the <code>rank</code> array once. Next, a min-heap is initialized with the unique ranks and their frequencies. The heap initially contains at most <span class="math inline">\(k\)</span> elements, and building the heap takes <span class="math inline">\(O(k)\)</span> time using <code>heapify</code>.</p>
<p>The main loop processes the cars one by one until all <span class="math inline">\(m\)</span> cars are repaired. In each iteration, the mechanic with the smallest current repair time is popped from the heap. This operation takes <span class="math inline">\(O(\log k)\)</span> time. The number of cars repaired by this mechanic group is deducted, and the repair time for the next car is calculated as <span class="math inline">\(\text{rank} \cdot n^2\)</span>, where <span class="math inline">\(n\)</span> is the number of cars already repaired by this mechanic. The updated repair time is then pushed back into the heap, which also takes <span class="math inline">\(O(\log k)\)</span> time. Since this loop runs for <span class="math inline">\(m\)</span> iterations, the total time complexity for the loop is <span class="math inline">\(O(m \log k)\)</span>.</p>
<p>Combining these steps, the overall time complexity is <span class="math inline">\(O(n + m \log k)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(k)\)</span></p>
<p>The algorithm stores the frequency of each rank, which occupies <span class="math inline">\(O(k)\)</span> space. Additionally, the min-heap stores at most <span class="math inline">\(k\)</span> elements at any point, as it only keeps track of unique ranks and their repair times. This results in an overall space complexity of <span class="math inline">\(O(k)\)</span>. The heap operations themselves use <span class="math inline">\(O(\log k)\)</span> space per element, but the total space for the heap is <span class="math inline">\(O(k)\)</span>.</p>
</li>
</ul>
<hr />
<p>Here are some problems that use concepts similar to the binary search technique we covered in this editorial. Practicing them will help you get more comfortable applying it to different situations.</p>
<ul>
<li><a href="https://leetcode.com/problems/house-robber-iv/">2560. House Robber IV</a></li>
<li><a href="https://leetcode.com/problems/koko-eating-bananas/">875. Koko Eating Bananas</a></li>
<li><a href="https://leetcode.com/problems/divide-chocolate/">1231. Divide Chocolate</a></li>
<li><a href="https://leetcode.com/problems/capacity-to-ship-packages-in-n-days/">1011. Capacity To Ship Packages In N Days</a></li>
<li><a href="https://leetcode.com/problems/minimum-time-to-repair-cars/">2587. Minimum Time to Repair Cars</a></li>
<li><a href="https://leetcode.com/problems/kth-missing-positive-number/">1539. Kth Missing Positive Number</a></li>
<li><a href="https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/">2064. Minimized Maximum of Products Distributed to Any Store</a></li>
<li><a href="https://leetcode.com/problems/maximum-candies-allocated-to-k-children/">2226. Maximum Candies Allocated to K Children</a></li>
<li><a href="https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">1802. Maximum Value at a Given Index in a Bounded Array</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. Minimum Number of Days to Make m Bouquets</a></li>
<li><a href="https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/">1283. Find the Smallest Divisor Given a Threshold</a></li>
<li><a href="https://leetcode.com/problems/minimize-max-distance-to-gas-station/">774. Minimize Max Distance to Gas Station</a></li>
<li><a href="https://leetcode.com/problems/split-array-largest-sum/">410. Split Array Largest Sum</a></li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-206">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/missing-number/description" target="_blank" rel="noopener noreferrer">Missing Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,0,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><code>n = 3</code> since there are 3 numbers, so all numbers are in the range <code>[0,3]</code>. 2 is the missing number in the range since it does not appear in <code>nums</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><code>n = 2</code> since there are 2 numbers, so all numbers are in the range <code>[0,2]</code>. 2 is the missing number in the range since it does not appear in <code>nums</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [9,6,4,2,3,5,7,0,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><code>n = 9</code> since there are 9 numbers, so all numbers are in the range <code>[0,9]</code>. 8 is the missing number in the range since it does not appear in <code>nums</code>.</p>
</div>

<div class="simple-translate-system-theme" id="simple-translate">
<div>
<div class="simple-translate-button isShow" style="background-image: url(&quot;moz-extension://8a9ffb6b-7e69-4e93-aae1-436a1448eff6/icons/512.png&quot;); height: 22px; width: 22px; top: 318px; left: 36px;">&nbsp;</div>

<div class="simple-translate-panel " style="width: 300px; height: 200px; top: 0px; left: 0px; font-size: 13px;">
<div class="simple-translate-result-wrapper" style="overflow: hidden;">
<div class="simple-translate-move" draggable="true">&nbsp;</div>

<div class="simple-translate-result-contents">
<p class="simple-translate-result" dir="auto">&nbsp;</p>

<p class="simple-translate-candidate" dir="auto">&nbsp;</p>
</div>
</div>
</div>
</div>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= n</code></li>
	<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-207">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-beautiful-item-for-each-query/description" target="_blank" rel="noopener noreferrer">Most Beautiful Item for Each Query</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>items</code> where <code>items[i] = [price<sub>i</sub>, beauty<sub>i</sub>]</code> denotes the <strong>price</strong> and <strong>beauty</strong> of an item respectively.</p>

<p>You are also given a <strong>0-indexed</strong> integer array <code>queries</code>. For each <code>queries[j]</code>, you want to determine the <strong>maximum beauty</strong> of an item whose <strong>price</strong> is <strong>less than or equal</strong> to <code>queries[j]</code>. If no such item exists, then the answer to this query is <code>0</code>.</p>

<p>Return <em>an array </em><code>answer</code><em> of the same length as </em><code>queries</code><em> where </em><code>answer[j]</code><em> is the answer to the </em><code>j<sup>th</sup></code><em> query</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]
<strong>Output:</strong> [2,4,5,5,6,6]
<strong>Explanation:</strong>
- For queries[0]=1, [1,2] is the only item which has price &lt;= 1. Hence, the answer for this query is 2.
- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. 
  The maximum beauty among them is 4.
- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].
  The maximum beauty among them is 5.
- For queries[4]=5 and queries[5]=6, all items can be considered.
  Hence, the answer for them is the maximum beauty of all items, i.e., 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]
<strong>Output:</strong> [4]
<strong>Explanation:</strong> 
The price of every item is equal to 1, so we choose the item with the maximum beauty 4. 
Note that multiple items can have the same price and/or beauty.  
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> items = [[10,1000]], queries = [5]
<strong>Output:</strong> [0]
<strong>Explanation:</strong>
No item has a price less than or equal to 5, so no item can be chosen.
Hence, the answer to the query is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= items.length, queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>items[i].length == 2</code></li>
	<li><code>1 &lt;= price<sub>i</sub>, beauty<sub>i</sub>, queries[j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem, <code>queries</code> gives us an array of prices while <code>items</code> gives us a 2D array of the price and corresponding beauty of some items. We have to answer each query by finding the maximum possible beauty of an item in <code>items</code> with a price less than or equal to the price given by <code>queries[i]</code>. In other words, we would like to find the highest &quot;beauty&quot; score without going over the price given by <code>queries[i]</code>.</p>
<h3 id="approach-1-sorting-items--binary-search">Approach 1: Sorting Items + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We observe that the the maximum beauty for a given price <code>p</code> in <code>items</code> will be the maximum beauty of all items in <code>items</code> with a price less than or equal to <code>p</code>. To do this for each query, we can scan through <code>items</code> and keep track of the maximum beauty amongst all qualified items (items with a price less than or equal to the query price). This would require us to traverse through the entirety of <code>items</code> for each query. However, we can calculate this maximum beauty more efficiently if we do some preprocessing with <code>items</code>. Specifically, we can:</p>
<ol>
<li>Sort the items in <code>items</code> in ascending order by price.</li>
<li>Traverse through <code>items</code> and keep track of the maximum beauty <code>maxBeauty</code> seen so far. We can overwrite each <code>item</code>'s beauty with its maximum possible beauty given its price: <code>item[1] = maxBeauty</code>.</li>
</ol>
<p>Here, the overwriting done in step 2 gives us <span class="math inline">\(O(1)\)</span> access to the maximum beauty for a given item's price. Thus, for a given query price, if we know the index of the item in <code>items</code> with the highest price that doesn't exceed the query price, we also know the maximum beauty for the query price.</p>
<p>Because <code>items</code> is now sorted, we can efficiently find this index using <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search</a>. In our binary search, we will continuously halve our search space at each iteration to find the index of the highest priced item <code>item</code> whose price doesn't exceed <code>queries[i]</code>. Then, we know <code>item[1]</code> would yield the maximum beauty possible for that query. Note that this binary search for each query only takes <span class="math inline">\(O(\log M)\)</span> time, which takes significantly less time than traversing through the entirety of <code>items</code> using an <span class="math inline">\(O(M)\)</span> linear scan.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize <code>ans</code> array to store answers for <code>queries[i]</code></li>
<li>Sort <code>items</code> by increasing order of price</li>
<li>Store the maximum beauty for each item:
<ul>
<li>Initialize initial max beauty <code>max = items[0][1]</code></li>
<li>For each <code>item</code> in <code>items</code>:
<ul>
<li>Update the max beauty seen so far: <code>max = maximum(max, item[1])</code></li>
<li>Overwrite the item's beauty with its max beauty: <code>item[1] = max</code></li>
</ul>
</li>
</ul>
</li>
<li>Answer each query. From <code>i = 0</code> to <code>i = queries.length - 1</code>:
<ul>
<li><code>ans[i] = binarySearch(items, queries[i])</code></li>
</ul>
</li>
<li>Define helper function <code>binarySearch(items, targetPrice)</code>:
<ul>
<li>Establish our left and right boundaries in binary search: <code>l = 0</code>, <code>r = items.length - 1</code></li>
<li>Initialize <code>maxBeauty</code> to 0</li>
<li>While <code>l &lt; r</code>, we still have a search space to search:
<ul>
<li>Calculate mid point: <code>mid = (l + r) / 2</code></li>
<li>If given <code>targetPrice</code> is less than <code>items[mid][0]</code>,
<ul>
<li>Move to the left half of search space. Update <code>r = mid - 1</code></li>
</ul>
</li>
<li>Otherwise, <code>targetPrice</code> is greater than or equal to current price:
<ul>
<li>This is a viable price, so update <code>maxBeauty = maximum(maxBeauty, items[mid][1])</code>.</li>
<li>Keep moving to the right half. Update <code>l = mid + 1</code></li>
</ul>
</li>
</ul>
</li>
<li>At this point, we have exhausted our search space, and <code>maxBeauty</code> contains the answer. Return <code>maxBeauty</code></li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Jx9zRqif/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>items</code> and let <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((M + N) \cdot \log M)\)</span></p>
<p>Sorting <code>items</code> in ascending order of price takes <span class="math inline">\(O(M \cdot \log M)\)</span> time. Then, going through all queries will take <span class="math inline">\(O(N)\)</span> time, where answering each query involves a binary search that takes <span class="math inline">\(O(\log M)\)</span> time. Thus, the total time complexity is <span class="math inline">\(O((M + N) \cdot \log M)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(S_M)\)</span></p>
<p>The space complexity is determined by the space needed by our sorting algorithm to sort <code>items</code>. This space complexity (<span class="math inline">\(S\)</span>) depends on the language of implementation. Given input size <span class="math inline">\(M\)</span>:</p>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log M)\)</span>.<br />
In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.<br />
In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting-items--sorting-queries">Approach 2: Sorting Items + Sorting Queries</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In Approach 1, we start by sorting the <code>items</code> array and calculating the maximum beauty for each item. This allows us to efficiently answer each query using binary search. Essentially, for each query, we look for the most beautiful item that meets the specified criteria based on price.</p>
<p>For our second approach, we also begin by sorting the <code>items</code> and calculating their maximum beauty. However, instead of using binary search for each query, we take a different route. We sort the <code>queries</code> in ascending order of price, just like we did with <code>items</code>. This way, we can perform a linear scan through both the <code>items</code> and <code>queries</code> simultaneously. As we go through them, we can easily find the maximum beauty for all the queries in one pass, making the process more efficient.</p>
<p>Specifically, for each query <code>queries[i]</code>, we can maintain a pointer to iterate through all the items in <code>items</code> with prices that don't exceed <code>queries[i]</code>. While we iterate through all these valid items for the given query, we can maintain the maximum beauty seen so far. Then, the maximum beauty seen will answer the current query. We can then continue this process for all other queries. Note that because the queries are increasing in price, we do not have to worry about moving our pointer back to consider cheaper items. This allows us to answer all queries with only one pass through <code>queries</code> and <code>items</code>.</p>
<p>One thing to note is that sorting <code>queries</code> directly will cause us to lose its original indexing, which would stop us from storing our answers in the answers result in the intended order. As a result, we can create an intermediate 2D array <code>queriesWithIndices</code> that will store the original queries in <code>queries</code> along with its original index. Thus, we can iterate through the queries via <code>queriesWithIndices</code> in which <code>queriesWithIndices[i][1]</code> will yield us the original index for query <code>i</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize <code>ans</code> array to store answers for <code>queries[i]</code></li>
<li>Sort <code>items</code> by increasing order of price</li>
<li>Initialize a new 2D array <code>queriesWithIndex</code> that contains each element in <code>queries</code> as well as its index</li>
<li>Sort <code>queriesWithIndex</code> by increasing order of price/query.</li>
<li>Initialize our pointer to iterate through <code>items</code>: <code>itemIndex = 0</code></li>
<li>Initialize a variable to maintain the maximum beauty seen so far: <code>maxBeauty = 0</code></li>
<li>From <code>i = 0</code> to <code>i = queries.length - 1</code>:
<ul>
<li>Get the current query price: <code>query = queriesWithIndices[i][0]</code></li>
<li>Get the current original query index: <code>originalIndex = queriesWithIndices[i][1]</code></li>
<li>While <code>itemIndex &lt; items.length</code> and <code>items[itemIndex][0] &lt;= query</code>:
<ul>
<li>Update our <code>maxBeauty</code> if we found a valid item with a higher beauty: <code>maxBeauty = max(maxBeauty, items[itemIndex][1])</code></li>
<li>Advance our pointer: <code>itemIndex++</code></li>
</ul>
</li>
<li>Fill the answer for the query: <code>ans[originalIndex] = maxBeauty</code></li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9ifnSMuk/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>items</code> and let <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M \cdot \log M + N \cdot \log N)\)</span></p>
<p>Sorting <code>items</code> in ascending order of price takes <span class="math inline">\(O(M \cdot \log M)\)</span> time. Similarly, sorting <code>queries</code> in ascending order of price takes <span class="math inline">\(O(N \cdot \log N)\)</span> time. Then iterating through both takes <span class="math inline">\(O(M + N)\)</span> time. Thus, the total time complexity is <span class="math inline">\(O(M \cdot \log M + N \cdot \log N)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(S_M + S_N + N)\)</span></p>
<p>The space complexity is determined by the space needed by our sorting algorithm to sort both <code>items</code> and <code>queries</code>. This space complexity (<span class="math inline">\(S\)</span>) depends on the language of implementation. Given input size <span class="math inline">\(M\)</span>:</p>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log M)\)</span>.<br />
In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.<br />
In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(M)\)</span>.</p>
<p>Since this algorithm is applied to both <code>items</code> and <code>queries</code>, the overall space complexity is <span class="math inline">\(O(S_M + S_N)\)</span>, along with an extra <span class="math inline">\(O(N)\)</span> space for the array used to store query indices.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-208">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-profit-assigning-work/description" target="_blank" rel="noopener noreferrer">Most Profit Assigning Work</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> jobs and <code>m</code> workers. You are given three arrays: <code>difficulty</code>, <code>profit</code>, and <code>worker</code> where:</p>

<ul>
	<li><code>difficulty[i]</code> and <code>profit[i]</code> are the difficulty and the profit of the <code>i<sup>th</sup></code> job, and</li>
	<li><code>worker[j]</code> is the ability of <code>j<sup>th</sup></code> worker (i.e., the <code>j<sup>th</sup></code> worker can only complete a job with difficulty at most <code>worker[j]</code>).</li>
</ul>

<p>Every worker can be assigned <strong>at most one job</strong>, but one job can be <strong>completed multiple times</strong>.</p>

<ul>
	<li>For example, if three workers attempt the same job that pays <code>$1</code>, then the total profit will be <code>$3</code>. If a worker cannot complete any job, their profit is <code>$0</code>.</li>
</ul>

<p>Return the maximum profit we can achieve after assigning the workers to the jobs.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
<strong>Output:</strong> 100
<strong>Explanation:</strong> Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == difficulty.length</code></li>
	<li><code>n == profit.length</code></li>
	<li><code>m == worker.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given some jobs that each have a difficulty level and an amount of profit that can be made from performing the job. We also have some workers.</p>
<p>You can think of these jobs as roles within a company. Each worker can have only one role, and the role must not be too difficult for them. However, just like in the real world, the assigned role can be easier than what the worker is capable of handling. Our goal is to assign roles to workers in a way that maximizes the company's profit.</p>
<p>Constraints on <code>n</code> and <code>m</code> are <code>1 &lt;= n</code> &amp; <code>m &lt;= 10000</code>, respectively. Therefore, we need to consider an approach with linear or log-linear time complexity.</p>
<hr />
<h3 id="approach-1-binary-search-and-greedy-sort-by-job-difficulty">Approach 1: Binary Search and Greedy (Sort by Job Difficulty)</h3>
<h4 id="intuition">Intuition</h4>
<p>When assigning a job to any worker, we disregard any jobs that are too difficult and then select the job with the highest profit. An example is shown below:</p>
<p><img src="../Figures/826/Slide1.PNG" alt="figA" /></p>
<p>If we need to choose the most optimal job for the worker algorithmically, we could use a linear search to find the maximum profit among all jobs. However, this approach would result in a Time Limit Exceeded (TLE) verdict since each job assignment would take <span class="math inline">\(O(n)\)</span> time, where <code>n</code> is the size of the job list.</p>
<p>Another approach is to use a binary search for every worker. We can sort the <code>difficulty</code> array in increasing order to apply binary search and rearrange the <code>profits</code> array in the same order.</p>
<p>For each worker, we will find the index where the difficulty value is just less than or equal to the worker's ability. The worker can perform all jobs up to this index. Consequently, the worker will choose the job with the highest profit up to this index. To do this, we can preprocess the array to store the maximum profit values up to each index.</p>
<p>During the binary search process, we will add the value of the preprocessed maximum profit of the calculated job for each worker. This sum will give us the total profit. Since the profit for each worker is maximized, the total profit will also be maximized.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array of pairs <code>jobProfile</code> with <code>{0, 0}</code>.</li>
<li>For <code>i</code> from <code>0</code> to <code>n</code> (where <code>n</code> is the size of the <code>difficulty</code> and <code>profit</code> arrays):
<ul>
<li>Append <code>{difficulty[i], profit[i]}</code> to <code>jobProfile</code>.</li>
</ul>
</li>
<li>Sort <code>jobProfile</code> by <code>difficulty</code> in ascending order.</li>
<li>For <code>i</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Update <code>jobProfile[i].profit</code> to be the maximum of its current value and the previous profit value.</li>
</ul>
</li>
<li>Initialize <code>netProfit</code> to <code>0</code>.</li>
<li>For each <code>ability</code> in the <code>worker</code> array:
<ul>
<li>Set binary search parameters: <code>l = 0</code>, <code>r = n-1</code>, <code>jobProfit = 0</code>.</li>
<li>While <code>l</code> &lt;= <code>r</code>:
<ul>
<li>Calculate <code>mid = (l + r) / 2</code>.</li>
<li>If <code>jobProfile[mid].difficulty</code> &lt;= <code>ability</code>:
<ul>
<li>Update <code>jobProfit</code> to the maximum of <code>jobProfit</code> and <code>jobProfile[mid].profit</code>.</li>
<li>Set <code>l = mid + 1</code>.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Set <code>r = mid - 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add <code>jobProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.<br />
 </li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kGBK3vMr/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays, and <code>m</code> be the size of the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span></p>
<p>The time complexity for sorting the <code>jobProfile</code> array is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
<p>While iterating the <code>worker</code> array of size <code>m</code>, we perform a binary search with search space size <code>n</code>. The time complexity is given by <span class="math inline">\(O(m \cdot \log n)\)</span>.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create an additional <code>jobProfile</code> array of size <span class="math inline">\(2 \cdot n\)</span>. Apart from this, some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>Therefore, space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search-and-greedy-sort-by-profit">Approach 2: Binary Search and Greedy (Sort by profit)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Is it possible to use binary search on the <code>profit</code> array to maximize the profit for a worker?</p>
<p>Suppose we sort the <code>profit</code> array in decreasing order while rearranging the <code>difficulty</code> array to preserve the original ordering of indices. For each worker, we will find the first index where the value of difficulty is less than or equal to the worker's ability. This index will store the maximum profit possible for that worker's ability. To efficiently apply binary search, we can preprocess the array to store the minimum difficulty up to the current index.</p>
<p>Similar to the previous approach, we will return the sum of all individual job profits as the maximum total profit.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an array of pairs <code>jobProfile</code> with <code>{0, 0}</code>.</li>
<li>For <code>i</code> from <code>0</code> to <code>n</code> (where <code>n</code> is the size of the <code>difficulty</code> and <code>profit</code> arrays):
<ul>
<li>Append <code>{difficulty[i], profit[i]}</code> to <code>jobProfile</code>.</li>
</ul>
</li>
<li>Sort <code>jobProfile</code> by <code>profit</code> in descending order.</li>
<li>For <code>i</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Update <code>jobProfile[i].difficulty</code> to be the minimum of its current value and the previous difficulty value.</li>
</ul>
</li>
<li>Initialize <code>netProfit</code> to <code>0</code>.</li>
<li>For each <code>ability</code> in the <code>worker</code> array:
<ul>
<li>Set binary search parameters: <code>l = 0</code>, <code>r = n-1</code>, <code>jobProfit = 0</code>.</li>
<li>While <code>l</code> &lt;= <code>r</code>:
<ul>
<li>Calculate <code>mid = (l + r) / 2</code>.</li>
<li>If <code>jobProfile[mid].difficulty</code> &lt;= <code>ability</code>:
<ul>
<li>Update <code>jobProfit</code> to the maximum of <code>jobProfit</code> and <code>jobProfile[mid].profit</code>.</li>
<li>Set <code>r = mid - 1</code>.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Set <code>l = mid + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add <code>jobProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.<br />
 </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/SqTPfTzF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays and <code>m</code> be the size of the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span></p>
<p>The time complexity for sorting the difficulty array is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
<p>While iterating the <code>worker</code> array of size <code>m</code>, we perform a binary search with search space size <code>n</code>. The time complexity for is given by <span class="math inline">\(O(m \cdot \log n)\)</span>.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create an additional <code>jobProfile</code> array of size <span class="math inline">\(2 \cdot n\)</span>. Apart from this, some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>Therefore, space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-greedy-and-two-pointers">Approach 3: Greedy and Two-Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the first approach, we sorted the <code>jobProfile</code> array by difficulty values. Now, let's also sort the <code>worker</code> array in increasing order.</p>
<p>Once we've assigned the optimal job to a worker, then all the workers ahead of that worker (in ability) will receive a job with difficulty greater than or equal to the assigned job. Therefore, after assigning a job, we don't need the jobs present before it.</p>
<p>So, we can use two pointers to find the most optimal job while iterating through the sorted job profile and sorted worker arrays.</p>
<p>Start with the first worker and iterate through the list maintaining a maxima of profits until you find the last assignable job with maximum difficulty. The maximum profit up to this index will give us the profit of the first worker.</p>
<p>Since the worker array is sorted, the ability of the next worker will be greater than all previous workers. So, continue iterating the job profile until you find the last assignable job. Repeat the process for all workers and store the total profit as the sum of the maximum profit.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize an array of pairs <code>jobProfile</code>.</li>
<li>For <code>i</code> from <code>0</code> to <code>n</code> (where <code>n</code> is the size of the <code>difficulty</code> and <code>profit</code> arrays):
<ul>
<li>Append <code>{difficulty[i], profit[i]}</code> to <code>jobProfile</code>.</li>
</ul>
</li>
<li>Sort <code>jobProfile</code> by <code>difficulty</code> in ascending order.</li>
<li>Sort <code>worker</code> in ascending order by their abilities.</li>
<li>Initialize <code>netProfit</code>, <code>maxProfit</code>, and <code>index</code> to <code>0</code>.</li>
<li>For each <code>ability</code> in the <code>worker</code> array:
<ul>
<li>While <code>index</code> is within bounds and the worker's ability is greater than or equal to <code>jobProfile[index].difficulty</code>:
<ul>
<li>Update <code>maxProfit</code> to the maximum of <code>maxProfit</code> and <code>jobProfile[index].profit</code>.</li>
<li>Increment <code>index</code> by <code>1</code>.</li>
</ul>
</li>
<li>Add <code>maxProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.</li>
</ol>
<p>!?!../Documents/826/slideshow1.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/cYrBiVNB/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays and <code>m</code> be the size of the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n + m \cdot \log(m))\)</span></p>
<p>The time taken for sorting the <code>difficulty</code> array is <span class="math inline">\(O(n \cdot \log n)\)</span> and sorting the <code>worker</code> array is <span class="math inline">\(O(m \cdot \log(m))\)</span>.</p>
<p>In the two pointers, while iterating through the <code>worker</code> array we iterate the <code>jobProfile</code> array exactly once. Time complexity is given by <span class="math inline">\(O(n + m)\)</span></p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log n + m \cdot \log(m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create an additional <code>jobProfile</code> array of size <span class="math inline">\(2 \cdot n\)</span>. Apart from this, some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>Therefore, space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-memoization">Approach 4: Memoization</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Given the constraints on the maximum values of the <code>difficulty</code> and <code>ability</code> arrays, we can create an array of this size to store the maximum profit for every possible ability.</p>
<p>We don't need the profit of jobs with a difficulty level higher than what the worker can handle. Therefore, we can create an array sized to the maximum ability to store the results.</p>
<p>Store the profit in this array with the difficulty of each job as the index. If multiple jobs share the same difficulty (same index), store the maximum profit among them.</p>
<p>Now, what if there exists a job with difficulty lower than another job but provides a higher profit? To find the maximum profit at each index, we must determine the highest value occurrence in all indices up to the current index. To do this, we need to store the maxima of all previous profit values in this array while iterating through the abilities.</p>
<p>Therefore, the maximum total profit is given by the sum of values in this array with worker abilities as the indices.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Initialize <code>maxAbility</code> as the maximum ability in the <code>worker</code> array.</li>
<li>Initialize an array <code>jobs</code> of size <code>maxAbility</code>.</li>
<li>Iterate a variable <code>i</code> from 0 to <code>difficulty.size - 1</code>:
<ul>
<li>If the <code>difficulty</code> at the current index <code>i</code> is less than or equal to the worker's ability:
<ul>
<li>Store the <code>profit</code> at index <code>i</code> at the <code>difficulty[i]</code> index of <code>jobs</code> array. If a value already exists, take the maximum of both values.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate through all values in <code>jobs</code>:
<ul>
<li>Store the maximum of current and previous <code>jobs</code> values in the current <code>jobs</code> index.</li>
</ul>
</li>
<li>Iterate through all abilities in the <code>worker</code> array:
<ul>
<li>Store <code>maxProfit</code> as <code>jobs[ability]</code> where <code>ability</code> denotes the ability of the current worker.</li>
<li>Increment <code>maxProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.</li>
</ol>
<p>!?!../Documents/826/slideshow2.json:960,540!?!</p>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/PGosiv2m/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays and <code>m</code> be the size of the <code>worker</code> array. Also, let <code>maxAbility</code> be the maximum value in the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + maxAbility)\)</span></p>
<p>In this approach, we iterate through the <code>difficulty</code>, <code>worker</code> and <code>jobs</code> arrays exactly once.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n + m + maxAbility)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(maxAbility)\)</span></p>
<p>We create an additional <code>jobs</code> array of size <span class="math inline">\(maxAbility\)</span>. Apart from this, no additional space is used.</p>
<p>Therefore, space complexity is given by <span class="math inline">\(O(maxAbility)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-209">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/my-calendar-i/description" target="_blank" rel="noopener noreferrer">My Calendar I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a <strong>double booking</strong>.</p>

<p>A <strong>double booking</strong> happens when two events have some non-empty intersection (i.e., some moment is common to both events.).</p>

<p>The event can be represented as a pair of integers <code>startTime</code> and <code>endTime</code> that represents a booking on the half-open interval <code>[startTime, endTime)</code>, the range of real numbers <code>x</code> such that <code>startTime &lt;= x &lt; endTime</code>.</p>

<p>Implement the <code>MyCalendar</code> class:</p>

<ul>
	<li><code>MyCalendar()</code> Initializes the calendar object.</li>
	<li><code>boolean book(int startTime, int endTime)</code> Returns <code>true</code> if the event can be added to the calendar successfully without causing a <strong>double booking</strong>. Otherwise, return <code>false</code> and do not add the event to the calendar.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyCalendar&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]
[[], [10, 20], [15, 25], [20, 30]]
<strong>Output</strong>
[null, true, false, true]

<strong>Explanation</strong>
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>1000</code> calls will be made to <code>book</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="overview">Overview</h3>
<p>The primary challenge in this problem is to find a proper data structure and an efficient algorithm to maintain all valid events, including <strong>querying</strong> potentially conflicting existing events and <strong>inserting</strong> new valid events.</p>
<p>In this solution article, we first start with a straightforward idea of brute force to warm up, then one step forward, we improve the naive approach to keep all existing events in sorted order and reduce the time complexity.</p>
<h3 id="approach-1-brute-force">Approach #1: Brute Force</h3>
<p><strong>Intuition</strong></p>
<p>When booking a new event <code>[start, end)</code>, check if every current event conflicts with the new event. If none of them do, we can book the event.</p>
<p><strong>Algorithm</strong></p>
<p>We will maintain a list of interval <em>events</em> (not necessarily sorted). Evidently, two events <code>[s1, e1)</code> and <code>[s2, e2)</code> do <em>not</em> conflict if and only if one of them starts after the other one ends: either <code>e1 &lt;= s2</code> OR <code>e2 &lt;= s1</code>. By De Morgan's laws, this means the events conflict when <code>s1 &lt; e2</code> AND <code>s2 &lt; e1</code>.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/KWP7poit/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of events booked.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N^2)\)</span>. For each new event, we process every previous event to decide whether the new event can be booked. This leads to <span class="math inline">\(\sum_k^N O(k) = O(N^2)\)</span> complexity.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the <code>calendar</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorted-list--binary-search">Approach #2: Sorted List + Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>If we maintained our events in <em>sorted</em> order, we could check whether an event could be booked in <span class="math inline">\(O(\log N)\)</span> time (where <span class="math inline">\(N\)</span> is the number of events already booked) by binary searching for where the event should be placed. We would also have to insert the event in our sorted structure.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize with an empty sorted list data structure <code>calendar</code>.</li>
<li>For every new interval<code>[start, end)</code> in <code>book()</code> invokation, we check if there is a conflict on each side with neighboring intervals.
<ol>
<li>Lookup the first index <code>idx</code>, which maps to an element <code>[s1,e1)</code> in <code>calendar</code> and <code>s &gt; start</code>, and this step can be conducted by binary search (see <a href="https://leetcode.com/explore/learn/card/binary-search/">this explore card</a>) as we keep <code>calendar</code> in sorted order by starting points of intervals. (Notice that there may not be such an <code>idx</code> because <code>start</code> &gt;= all kept intervals. In this case, we don't need to check the following step)</li>
<li>Check if <code>end &gt; s1</code>. If yes, <code>[start, end)</code> and <code>[s1,e1)</code> must be overlapped, <code>[start, end)</code> is illegal, and we should return false for the invokation now.</li>
<li>Roll back to the index <code>idx-1</code>, which maps to an element <code>[s2,e2)</code> in <code>calendar</code> and <code>s1</code> is the largest staring points that satisfy <code>s1 &lt;= start</code>. (Similarly, notice that there may be no element at <code>idx-1</code> because <code>idx</code> is the 0-th index. In this case, we don't need to check the following step either)</li>
<li>Check if <code>e2 &gt; start</code>. If yes, <code>[s2,e2)</code> and <code>[start, end)</code> must be overlapped, <code>[start, end)</code> is illegal, and we should return false for the invokation now.</li>
<li>If <code>[start, end)</code> passes all checkings above, we insert this valid interval at <code>idx</code> in <code>calendar</code>.</li>
</ol>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p>We need a data structure that keeps elements sorted and supports fast insertion.</p>
<ul>
<li>In Java, a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html"><code>TreeMap</code></a> is the perfect candidate.</li>
<li>In C++, we can use <code>set</code> container and <a href="https://cplusplus.com/reference/set/set/lower_bound/"><code>lower_bound</code> method</a>.</li>
<li>In Python, we can keep a <a href="https://grantjenks.com/docs/sortedcontainers/sortedlist.html"><code>SortedList</code></a>.</li>
</ul>
<p><a href="https://leetcode.com/playground/c2gTvDNC/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Like Approach 1, let <span class="math inline">\(N\)</span> be the number of events booked.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \log N)\)</span>. For each new event, we search that the event is legal in <span class="math inline">\(O(\log N)\)</span> time, then insert it in <span class="math inline">\(O(\log N)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the data structures used.</p>
</li>
</ul>
<blockquote>
<p>Note: In practice, for Python, if you use <code>bisect.insort()</code> or <code>list.insert()</code> to add new events to a built-in list as <code>calendar</code>, it will result in a time complexity as <span class="math inline">\(O(N)\)</span> instead of <span class="math inline">\(O(\log N)\)</span> for each insertion operation (see <a href="https://docs.python.org/3/library/bisect.html#bisect.insort">the docs</a>). However, due to the built-in instruction optimization in <code>list.insert()</code> and the constraint of <span class="math inline">\(N \le 1000\)</span> in this problem, this <span class="math inline">\(O(N^2)\)</span> solution may somehow show a better performance in runtime. But we won't provide this solution code here because the time complexity matters.</p>
</blockquote>
</div>
				</div>
		</div>

<div class="question-card" id="question-210">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/my-calendar-ii/description" target="_blank" rel="noopener noreferrer">My Calendar II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a <strong>triple booking</strong>.</p>

<p>A <strong>triple booking</strong> happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).</p>

<p>The event can be represented as a pair of integers <code>startTime</code> and <code>endTime</code> that represents a booking on the half-open interval <code>[startTime, endTime)</code>, the range of real numbers <code>x</code> such that <code>startTime &lt;= x &lt; endTime</code>.</p>

<p>Implement the <code>MyCalendarTwo</code> class:</p>

<ul>
	<li><code>MyCalendarTwo()</code> Initializes the calendar object.</li>
	<li><code>boolean book(int startTime, int endTime)</code> Returns <code>true</code> if the event can be added to the calendar successfully without causing a <strong>triple booking</strong>. Otherwise, return <code>false</code> and do not add the event to the calendar.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyCalendarTwo&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
<strong>Output</strong>
[null, true, true, true, false, true, true]

<strong>Explanation</strong>
MyCalendarTwo myCalendarTwo = new MyCalendarTwo();
myCalendarTwo.book(10, 20); // return True, The event can be booked. 
myCalendarTwo.book(50, 60); // return True, The event can be booked. 
myCalendarTwo.book(10, 40); // return True, The event can be double booked. 
myCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.
myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.
myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>1000</code> calls will be made to <code>book</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-overlapped-intervals">Approach 1: Using Overlapped Intervals</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a set of bookings in the form <code>[start, end)</code>, where <code>start</code> is included, but <code>end</code> is excluded, meaning the booking spans from <code>start</code> to <code>end - 1</code>. The function <code>book(start, end)</code> returns <code>true</code> if the booking can be added without causing a triple booking, and <code>false</code> otherwise. A triple booking occurs when three bookings overlap, such as <code>[[1, 5], [2, 4], [3, 4]]</code>, which all intersect between <code>[3, 4]</code>. The booking is only added if the function returns <code>true</code>.</p>
<p>The key problem is preventing a new booking from overlapping with two existing overlapping bookings, which would create a triple booking. For example, in the list <code>[[3, 10], [4, 8], [10, 15], [20, 25]]</code>, no triple booking occurs despite overlaps. However, adding <code>[5, 7]</code> would overlap with both <code>[[3, 10], [4, 8]]</code>, leading to a triple booking.</p>
<p>To handle this, we track double-overlapping bookings. When <code>book(start, end)</code> is called, we check if the new booking overlaps with any double-overlapped bookings. If it does, we return <code>false</code>; otherwise, we return <code>true</code>, add the booking, and update the double-overlapped list if necessary.</p>
<p>Checking for overlap between two bookings <code>(start1, end1)</code> and <code>(start2, end2)</code> is done by verifying if <code>max(start1, start2) &lt; min(end1, end2)</code>. This condition excludes endpoint overlaps, as the intervals are half-open. If they overlap, the overlap interval is <code>(max(start1, start2), min(end1, end2))</code>, also half-open. This can also be observed in the below figure:</p>
<p><img src="../Figures/731/731_overlapped_intervals.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Class <code>MyCalendarTwo</code> will have two data members, <code>bookings</code> which is the list of all bookings we will get, and <code>overlapBookings</code> a list of double overlapping bookings in the previous list. Initialize both as an empty list.</p>
</li>
<li>
<p>Define the function <code>doesOverlap(start1, end1, start2, end2)</code> which will return <code>true</code> if bookings <code>(start1, end1)</code> and <code>(start2, end2)</code> have an overlap.</p>
</li>
<li>
<p>Define the function <code>getOverlapped(start1, end1, start2, end2)</code> which will return the overlapping part of the bookings <code>(start1, end1)</code> and <code>(start2, end2)</code>.</p>
</li>
<li>
<p>Implement the function <code>book(start, end)</code> as follows:</p>
<ul>
<li>Check if the bookings <code>(start, end)</code> overlap with any booking in the list <code>overlapBookings</code>, if yes we can return <code>false</code> from here.</li>
<li>Iterate over the list <code>bookings</code> and check if <code>(start, end)</code> overlaps with any booking in it. If yes, add the overlapped part in the list <code>overlapBookings</code>.</li>
<li>Add the booking <code>(start, end)</code> to the list <code>booking</code>.</li>
<li>If we reach here, we can return <code>true</code> as no triple booking happened.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EgFDqNK4/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the size of the list of <code>bookings</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The time complexity for the <code>book(start, end)</code> function is <span class="math inline">\(O(N)\)</span> because we iterate through the <code>bookings</code> list to check for overlaps and possibly add a new booking. Additionally, we check the <code>overlapBookings</code> list, which tracks overlaps. Since the size of <code>overlapBookings</code> is always smaller than or equal to the size of <code>bookings</code>, the overall time complexity remains <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We maintain two lists: <code>bookings</code> for all the bookings and <code>overlapBookings</code> for the overlapping intervals. The size of <code>overlapBookings</code> can never exceed the size of <code>bookings</code>, so the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-line-sweep">Approach 2: Line Sweep</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The previous approach works well for the given problem, where we need to avoid triple bookings. However, if the requirements change such as checking for four overlapping bookings, the method becomes less flexible. We'd need to introduce additional lists, for example, to track triple bookings, making the solution harder to maintain and extend.</p>
<p>To address this, we can use a more flexible and standard solution: the <strong>Line Sweep</strong> algorithm. This approach is common for interval-related problems and can easily handle changes, such as checking for four or more overlapping bookings.</p>
<p>The Line Sweep algorithm works by marking when bookings start and end. For each booking <code>(start, end)</code>, we mark the <code>start</code> point by increasing its count by <code>1</code> (indicating a booking begins), and we mark the <code>end</code> point by decreasing its count by <code>1</code> (indicating a booking ends). These marks are stored in a map, which keeps track of the number of bookings starting or ending at each point.</p>
<p>Once all bookings are processed, we compute the prefix sum over the map. The prefix sum at any point tells us how many active bookings overlap at that moment. If the sum at any point exceeds <code>2</code>, it means we have a triple booking. At this point, the function should return <code>false</code> to prevent adding a new booking. If no triple booking is found, the function returns <code>true</code>, and the booking is allowed.</p>
<p>This approach is easily extendible. If we wanted to check for four or more bookings instead of three, we would simply adjust the threshold from <code>2</code> to <code>3</code> when calculating the prefix sum. This flexibility makes the Line Sweep method a more robust solution for variations of the problem.</p>
<p><img src="../Figures/731/731_line_sweep.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Class <code>MyCalendarTwo</code> will have two data members, <code>maxOverlappedBooking</code> which is the maximum number of concurrent bookings possible at a time, and <code>bookingCount</code> which is a map from integer to integer with the time point as the key and number of bookings as the value.</p>
</li>
<li>
<p>Initialize <code>maxOverlappedBooking</code> as <code>2</code>, as we need to check for triple booking.</p>
</li>
<li>
<p>Define the function <code>book(start, end)</code> as:</p>
<ul>
<li>Increase the number of bookings for the time <code>start</code> and decrease the number of bookings for <code>end</code> by <code>1</code> in the map <code>bookingCount</code>.</li>
<li>Iterate over each key-value pair in the map in ascending order of keys to find the prefix sum. Add the value in the map to the count <code>overlappedBooking</code>.</li>
<li>If <code>overlappedBooking</code> is more than two, it implies that this is triple booking. Hence, we should return false. Also, we need to revert the changes in the map as this booking shouldn't be added.</li>
<li>If we reach here, it implies no triple booking and hence returns <code>true</code>.</li>
</ul>
</li>
</ol>
<blockquote>
<p>Note: In the provided CPP solution, numbers are erased from a map after insertion if they are deemed unnecessary. However, instead of using <code>iterator erase(iterator first, iterator last)</code>, which operates in <span class="math inline">\(O(1)\)</span> time, we opt for <code>size_type erase(const Key&amp; key)</code>, resulting in <span class="math inline">\(O(log n)\)</span> complexity. A micro optimization would be to obtain iterator positions from the insertion, allowing for direct erasure in constant time.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/MGcDSKpz/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the size of the list of <code>bookings</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The time complexity for the <code>book(start, end)</code> function is <span class="math inline">\(O(N)\)</span>. This is because, we iterate over the bookings entries in the map and find the prefix sum. The number of entries would be <span class="math inline">\(O(N)\)</span> and for each of these we can have <span class="math inline">\(3\)</span> operations with <span class="math inline">\(O(\log N)\)</span> complexity. Because once we find out the triple booking, we return from there and hence no more iteration is required. Hence the time complexity for the function <code>book(start, end)</code> becomes <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(N)\)</span> because we store the start and end points of each booking in the map. Each booking requires two entries in the map, so for <span class="math inline">\(N\)</span> bookings, we store <span class="math inline">\(2N\)</span> entries. Therefore, the space complexity is proportional to <span class="math inline">\(N\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-211">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/my-calendar-iii/description" target="_blank" rel="noopener noreferrer">My Calendar III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <code>k</code>-booking happens when <code>k</code> events have some non-empty intersection (i.e., there is some time that is common to all <code>k</code> events.)</p>

<p>You are given some events <code>[startTime, endTime)</code>, after each given event, return an integer <code>k</code> representing the maximum <code>k</code>-booking between all the previous events.</p>

<p>Implement the <code>MyCalendarThree</code> class:</p>

<ul>
	<li><code>MyCalendarThree()</code> Initializes the object.</li>
	<li><code>int book(int startTime, int endTime)</code> Returns an integer <code>k</code> representing the largest integer such that there exists a <code>k</code>-booking in the calendar.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyCalendarThree&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
<strong>Output</strong>
[null, 1, 1, 2, 3, 3, 3]

<strong>Explanation</strong>
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // return 1
myCalendarThree.book(50, 60); // return 1
myCalendarThree.book(10, 40); // return 2
myCalendarThree.book(5, 15); // return 3
myCalendarThree.book(5, 10); // return 3
myCalendarThree.book(25, 55); // return 3

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= startTime &lt; endTime &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>400</code> calls will be made to <code>book</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-212">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/network-recovery-pathways/description" target="_blank" rel="noopener noreferrer">Network Recovery Pathways</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="502" data-start="75">You are given a directed acyclic graph of <code>n</code> nodes numbered from 0 to <code>n &minus; 1</code>. This is represented by a 2D array <code data-end="201" data-start="194">edges</code> of length<font face="monospace"> <code>m</code></font>, where <code data-end="255" data-start="227">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code> indicates a one‑way communication from node <code data-end="304" data-start="300">u<sub>i</sub></code> to node <code data-end="317" data-start="313">v<sub>i</sub></code> with a recovery cost of <code data-end="349" data-start="342">cost<sub>i</sub></code>.</p>

<p data-end="502" data-start="75">Some nodes may be offline. You are given a boolean array <code data-end="416" data-start="408">online</code> where <code data-end="441" data-start="423">online[i] = true</code> means node <code data-end="456" data-start="453">i</code> is online. Nodes 0 and <code>n &minus; 1</code> are always online.</p>

<p data-end="547" data-start="504">A path from 0 to <code>n &minus; 1</code> is <strong data-end="541" data-start="532">valid</strong> if:</p>

<ul>
	<li>All intermediate nodes on the path are online.</li>
	<li data-end="676" data-start="605">The total recovery cost of all edges on the path does not exceed <code>k</code>.</li>
</ul>

<p data-end="771" data-start="653">For each valid path, define its <strong data-end="694" data-start="685">score</strong> as the minimum edge‑cost along that path.</p>

<p data-end="913" data-start="847">Return the <strong>maximum</strong> path score (i.e., the largest <strong>minimum</strong>-edge cost) among all valid paths. If no valid path exists, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,5],[1,3,10],[0,2,3],[2,3,4]], online = [true,true,true,true], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-10.png" style="width: 239px; height: 267px;" /></p>

<ul data-end="551" data-start="146">
	<li data-end="462" data-start="146">
	<p data-end="206" data-start="148">The graph has two possible routes from node 0 to node 3:</p>

	<ol data-end="462" data-start="209">
		<li data-end="315" data-start="209">
		<p data-end="228" data-start="212">Path <code>0 &rarr; 1 &rarr; 3</code></p>

		<ul data-end="315" data-start="234">
			<li data-end="315" data-start="234">
			<p data-end="315" data-start="236">Total cost = <code>5 + 10 = 15</code>, which exceeds k (<code>15 &gt; 10</code>), so this path is invalid.</p>
			</li>
		</ul>
		</li>
		<li data-end="462" data-start="318">
		<p data-end="337" data-start="321">Path <code>0 &rarr; 2 &rarr; 3</code></p>

		<ul data-end="462" data-start="343">
			<li data-end="397" data-start="343">
			<p data-end="397" data-start="345">Total cost = <code>3 + 4 = 7 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="462" data-start="403">
			<p data-end="462" data-start="405">The minimum edge‐cost along this path is <code>min(3, 4) = 3</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="551" data-start="463">
	<p data-end="551" data-start="465">There are no other valid paths. Hence, the maximum among all valid path‐scores is 3.</p>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,7],[1,4,5],[0,2,6],[2,3,6],[3,4,2],[2,4,6]], online = [true,true,true,false,true], k = 12</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-11.png" style="width: 343px; height: 194px;" /></p>

<ul>
	<li data-end="790" data-start="726">
	<p data-end="790" data-start="728">Node 3 is offline, so any path passing through 3 is invalid.</p>
	</li>
	<li data-end="1231" data-start="791">
	<p data-end="837" data-start="793">Consider the remaining routes from 0 to 4:</p>

	<ol data-end="1231" data-start="840">
		<li data-end="985" data-start="840">
		<p data-end="859" data-start="843">Path <code>0 &rarr; 1 &rarr; 4</code></p>

		<ul data-end="985" data-start="865">
			<li data-end="920" data-start="865">
			<p data-end="920" data-start="867">Total cost = <code>7 + 5 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="985" data-start="926">
			<p data-end="985" data-start="928">The minimum edge‐cost along this path is <code>min(7, 5) = 5</code>.</p>
			</li>
		</ul>
		</li>
		<li data-end="1083" data-start="988">
		<p data-end="1011" data-start="991">Path <code>0 &rarr; 2 &rarr; 3 &rarr; 4</code></p>

		<ul data-end="1083" data-start="1017">
			<li data-end="1083" data-start="1017">
			<p data-end="1083" data-start="1019">Node 3 is offline, so this path is invalid regardless of cost.</p>
			</li>
		</ul>
		</li>
		<li data-end="1231" data-start="1086">
		<p data-end="1105" data-start="1089">Path <code>0 &rarr; 2 &rarr; 4</code></p>

		<ul data-end="1231" data-start="1111">
			<li data-end="1166" data-start="1111">
			<p data-end="1166" data-start="1113">Total cost = <code>6 + 6 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="1231" data-start="1172">
			<p data-end="1231" data-start="1174">The minimum edge‐cost along this path is <code>min(6, 6) = 6</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="1314" data-is-last-node="" data-start="1232">
	<p data-end="1314" data-is-last-node="" data-start="1234">Among the two valid paths, their scores are 5 and 6. Therefore, the answer is 6.</p>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="42" data-start="20"><code data-end="40" data-start="20">n == online.length</code></li>
	<li data-end="63" data-start="45"><code data-end="61" data-start="45">2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="102" data-start="66"><code data-end="100" data-start="66">0 &lt;= m == edges.length &lt;= </code><code>min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>
	<li data-end="102" data-start="66"><code data-end="127" data-start="105">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code></li>
	<li data-end="151" data-start="132"><code data-end="149" data-start="132">0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li data-end="166" data-start="154"><code data-end="164" data-start="154">u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="191" data-start="169"><code data-end="189" data-start="169">0 &lt;= cost<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li data-end="213" data-start="194"><code data-end="211" data-start="194">0 &lt;= k &lt;= 5 * 10<sup>13</sup></code></li>
	<li data-end="309" data-start="216"><code data-end="227" data-start="216">online[i]</code> is either <code data-end="244" data-is-only-node="" data-start="238">true</code> or <code data-end="255" data-start="248">false</code>, and both <code data-end="277" data-start="266">online[0]</code> and <code data-end="295" data-start="282">online[n &minus; 1]</code> are <code data-end="306" data-start="300">true</code>.</li>
	<li data-end="362" data-is-last-node="" data-start="312">The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-213">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-iv/description" target="_blank" rel="noopener noreferrer">Next Greater Element IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of non-negative integers <code>nums</code>. For each integer in <code>nums</code>, you must find its respective <strong>second greater</strong> integer.</p>

<p>The <strong>second greater</strong> integer of <code>nums[i]</code> is <code>nums[j]</code> such that:</p>

<ul>
	<li><code>j &gt; i</code></li>
	<li><code>nums[j] &gt; nums[i]</code></li>
	<li>There exists <strong>exactly one</strong> index <code>k</code> such that <code>nums[k] &gt; nums[i]</code> and <code>i &lt; k &lt; j</code>.</li>
</ul>

<p>If there is no such <code>nums[j]</code>, the second greater integer is considered to be <code>-1</code>.</p>

<ul>
	<li>For example, in the array <code>[1, 2, 4, 3]</code>, the second greater integer of <code>1</code> is <code>4</code>, <code>2</code> is <code>3</code>,&nbsp;and that of <code>3</code> and <code>4</code> is <code>-1</code>.</li>
</ul>

<p>Return<em> an integer array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the second greater integer of </em><code>nums[i]</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,0,9,6]
<strong>Output:</strong> [9,6,6,-1,-1]
<strong>Explanation:</strong>
0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.
1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.
2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.
3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.
4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.
Thus, we return [9,6,6,-1,-1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3]
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong>
We return [-1,-1] since neither integer has any integer greater than it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-214">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/nth-digit/description" target="_blank" rel="noopener noreferrer">Nth Digit</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return the <code>n<sup>th</sup></code> digit of the infinite integer sequence <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 11
<strong>Output:</strong> 0
<strong>Explanation:</strong> The 11<sup>th</sup> digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-215">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/nth-magical-number/description" target="_blank" rel="noopener noreferrer">Nth Magical Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A positive integer is <em>magical</em> if it is divisible by either <code>a</code> or <code>b</code>.</p>

<p>Given the three integers <code>n</code>, <code>a</code>, and <code>b</code>, return the <code>n<sup>th</sup></code> magical number. Since the answer may be very large, <strong>return it modulo </strong><code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1, a = 2, b = 3
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, a = 2, b = 3
<strong>Output:</strong> 6
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
	<li><code>2 &lt;= a, b &lt;= 4 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-216">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-excellent-pairs/description" target="_blank" rel="noopener noreferrer">Number of Excellent Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> positive integer array <code>nums</code> and a positive integer <code>k</code>.</p>

<p>A pair of numbers <code>(num1, num2)</code> is called <strong>excellent</strong> if the following conditions are satisfied:</p>

<ul>
	<li><strong>Both</strong> the numbers <code>num1</code> and <code>num2</code> exist in the array <code>nums</code>.</li>
	<li>The sum of the number of set bits in <code>num1 OR num2</code> and <code>num1 AND num2</code> is greater than or equal to <code>k</code>, where <code>OR</code> is the bitwise <strong>OR</strong> operation and <code>AND</code> is the bitwise <strong>AND</strong> operation.</li>
</ul>

<p>Return <em>the number of <strong>distinct</strong> excellent pairs</em>.</p>

<p>Two pairs <code>(a, b)</code> and <code>(c, d)</code> are considered distinct if either <code>a != c</code> or <code>b != d</code>. For example, <code>(1, 2)</code> and <code>(2, 1)</code> are distinct.</p>

<p><strong>Note</strong> that a pair <code>(num1, num2)</code> such that <code>num1 == num2</code> can also be excellent if you have at least <strong>one</strong> occurrence of <code>num1</code> in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,1], k = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> The excellent pairs are the following:
- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.
- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
So the number of excellent pairs is 5.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,1,1], k = 10
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no excellent pairs for this array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 60</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-217">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-flowers-in-full-bloom/description" target="_blank" rel="noopener noreferrer">Number of Flowers in Full Bloom</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>flowers</code>, where <code>flowers[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> means the <code>i<sup>th</sup></code> flower will be in <strong>full bloom</strong> from <code>start<sub>i</sub></code> to <code>end<sub>i</sub></code> (<strong>inclusive</strong>). You are also given a <strong>0-indexed</strong> integer array <code>people</code> of size <code>n</code>, where <code>people[i]</code> is the time that the <code>i<sup>th</sup></code> person will arrive to see the flowers.</p>

<p>Return <em>an integer array </em><code>answer</code><em> of size </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the <strong>number</strong> of flowers that are in full bloom when the </em><code>i<sup>th</sup></code><em> person arrives.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg" style="width: 550px; height: 216px;" />
<pre>
<strong>Input:</strong> flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]
<strong>Output:</strong> [1,2,2,2]
<strong>Explanation: </strong>The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg" style="width: 450px; height: 195px;" />
<pre>
<strong>Input:</strong> flowers = [[1,10],[3,3]], people = [3,3,2]
<strong>Output:</strong> [2,2,1]
<strong>Explanation:</strong> The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= flowers.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>flowers[i].length == 2</code></li>
	<li><code>1 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= people[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-heappriority-queue">Approach 1: Heap/Priority Queue</h3>
<p><strong>Intuition</strong></p>
<p>For each <code>person</code> in <code>people</code>, we need to find how many flower ranges <code>[start, end]</code> contain <code>person</code>. An intuitive first step is to sort both input arrays so that we can process both <code>flowers</code> and <code>people</code> in chronological order.</p>
<p>For the first <code>person</code> (in terms of arrival time), we can find all the flowers that have <code>start</code> less than <code>person</code> - these are the flowers that have started blooming before <code>person</code> arrived, and thus <code>person</code> might have a chance of seeing them. Of those flowers, we remove the ones that have <code>end</code> less than <code>person</code> as well, as these are the flowers that have finished blooming, and <code>person</code> missed them. The number of remaining flowers is the answer for the first <code>person</code>. Note that because we sorted <code>people</code>, the flowers we remove here are guaranteed never to be seen again and therefore will not affect anyone else after <code>person</code>.</p>
<p>Let's move to the second <code>person</code>. Once again, we find all the flowers that have <code>start</code> less than <code>person</code>. But do we need to start from scratch? No! Because we are processing both the <code>flowers</code> and <code>people</code> in order, we can start from where we left off with the previous person. More specifically, because the second person's arrival time is greater than or equal to the previous person's, the flowers that bloom before the previous person must also bloom before the second person, so there's no need for us to handle this portion of flowers again. Therefore, we will add all the flowers that have <code>start</code> less than the second <code>person</code>, starting after the last flower we took.</p>
<p>Similarly, the flowers that the previous person missed are definitely also missed by the second person, so there's no need for us to handle this portion of removed flowers again. Once we have taken all the flowers with <code>start</code> less than <code>person</code>, we can simply remove all the flowers that have <code>end</code> less than <code>person</code>. The number of remaining flowers is the answer for the second <code>person</code>.</p>
<p>We can continue this process for each <code>person</code>. To find the flowers with <code>start</code> less than a given <code>person</code>, we can use a pointer <code>i</code> that starts at <code>0</code>. We will move <code>i</code> along the <code>flowers</code> array and never decrement or reset it. This allows us to pick up where we left off for each successive <code>person</code>.</p>
<p>How can we remove the flowers that have <code>end</code> less than a given <code>person</code>? This one is trickier because we can only sort <code>flowers</code> by one dimension. To use the pointer technique we just described, we must sort by the <code>start</code> times. Thus, the <code>end</code> times are not necessarily in order. For example, you could have <code>flowers</code> like this:</p>
<p><code>[2, 9], [3, 6]</code></p>
<p>In this case, using another pointer like <code>j</code> for the end times would not work since <code>9</code> is greater than <code>6</code> but comes earlier in the input.</p>
<p>As we are concerned with the flowers that have earlier end times, we can use a heap/priority queue to keep track of which flowers finish blooming. We will maintain a min <code>heap</code> and push <code>end</code> times of flowers onto this <code>heap</code>. Once we have added all flowers with <code>start</code> less than <code>person</code>, we will pop from the <code>heap</code> as long as the top of it is less than <code>person</code>.</p>
<p>After popping from <code>heap</code>, it will hold the end times of all flowers that <code>person</code> can see. Thus, the answer for <code>person</code> is simply the size of the heap.</p>
<blockquote>
<p>To summarize, we use a pointer <code>i</code> to iterate along <code>flowers</code>. For a given <code>person</code>, we find all the flowers that started blooming before <code>person</code> arrives. We push the <code>end</code> time of these flowers onto a <code>heap</code>. We can then remove all the flowers that finished blooming by popping from the <code>heap</code>, since a min <code>heap</code> efficiently gives us the minimum (earliest) times.</p>
<p>As we sort both input arrays, flowers that we pop from <code>heap</code> will never be seen again by future people.</p>
</blockquote>
<p>A note on implementation: here, we are sorting <code>people</code>, but the problem description asks us for the answer according to the original order. We will use a hash map that maps a <code>person</code> to the number of flowers they see. We will also keep the original order of <code>people</code> by creating a copy of it to sort. Once we have calculated the answer for everyone in the sorted order, we can iterate through the original <code>people</code> and refer to the hash map to build the final answer by restoring their original order.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort <code>flowers</code>. Create a sorted version of <code>people</code> called <code>sortedPeople</code>.</li>
<li>Initialize a hash map <code>dic</code>, a min <code>heap</code>, and an integer <code>i = 0</code>.</li>
<li>Iterate over <code>sortedPeople</code>. For each <code>person</code>:
<ul>
<li>While <code>flowers[i][0] &lt; person</code> (the flower at <code>i</code> already started blooming), push <code>flowers[i][1]</code> (when the flower finishes blooming) to <code>heap</code> and increment <code>i</code>.</li>
<li>While the top of <code>heap</code> (minimum element) is less than <code>person</code>, pop from <code>heap</code>.</li>
<li>Set <code>dic[person]</code> to the size of <code>heap</code>.</li>
</ul>
</li>
<li>Initialize an array <code>ans</code>. Iterate over <code>people</code> and populate <code>ans</code> using <code>dic</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/HZaGN9L3/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>flowers</code> and <span class="math inline">\(m\)</span> as the length of <code>people</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n + m \cdot (\log{}n + \log{}m))\)</span></p>
<p>We start by sorting both <code>flowers</code> and <code>people</code>. This costs <span class="math inline">\(O(n \cdot \log{}n)\)</span> and <span class="math inline">\(O(m \cdot \log{}m)\)</span> respectively. Next, we perform <span class="math inline">\(O(m)\)</span> iterations. At each iteration, we perform some heap operations. The cost of these operations is dependent on the size of the heap. Our heap cannot exceed a size of <span class="math inline">\(n\)</span>, so these operations cost <span class="math inline">\(O(\log{}n)\)</span>.</p>
<p>There are some other linear time operations that don't affect our time complexity. In total, our time complexity is <span class="math inline">\(O(n \cdot \log{}n + m \cdot (\log{}n + \log{}m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We create an array <code>sortedPeople</code> of length <span class="math inline">\(m\)</span>. <code>dic</code> also grows to a length of <span class="math inline">\(m\)</span>, and <code>heap</code> can grow to a size of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-difference-array--binary-search">Approach 2: Difference Array + Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>There is a technique called difference array that can be used to solve many &quot;range&quot; based problems. The technique involves creating an array <code>difference</code> and iterating over all ranges <code>[start, end]</code>. We perform <code>difference[start]++</code> and <code>difference[end + 1]--</code> for each range.</p>
<p>The idea is that each index of <code>difference</code> represents the <strong>change</strong> in the number of flowers we can see when we cross this index (not the actual number of flowers on this index), with each index representing a unit of time. Thus, we could take a <code>prefix</code> sum of this <code>difference</code> array to find how many flowers can be seen at any given time with <code>prefix[time]</code>.</p>
<blockquote>
<p>Some people also call this technique &quot;line sweep&quot;.</p>
</blockquote>
<p>Unfortunately, if we look at the constraints, we find that values of <code>start, end, people</code> can be up to <span class="math inline">\(10^9\)</span>. It would not be feasible to create an array with such a large size. Thus, we need to use a map structure instead. Like in the previous approach, we still want to process everything chronologically. We will use the following data structures:</p>
<ul>
<li>In Java, we will use <code>TreeMap</code>.</li>
<li>In C++, we will use <code>std::map</code>.</li>
<li>In Python, we will use <code>sortedcontainers.SortedDict</code>.</li>
</ul>
<blockquote>
<p>Note that if you were not allowed to use these structures in an interview, you could still implement this approach using a normal hash map. You would just need to sort the elements in the hash map by key values after you populated it.</p>
</blockquote>
<p>Once we have this data structure <code>difference</code>, we will follow the process described above. We iterate over each <code>flower = [start, end]</code> and increment <code>difference[start]</code> while decrementing <code>difference[end + 1]</code>. The idea is that when we reach <code>start</code>, the number of flowers we see increases by one. When we reach <code>end + 1</code>, the number of flowers we see decreases by one.</p>
<p>We then create a <code>prefix</code> sum of the values in <code>difference</code>. We also need to know what time each value is associated with, so we will create an array <code>positions</code> to go along with our <code>prefix</code> array. Here, <code>prefix[i]</code> is the number of flowers available at time <code>positions[i]</code>.</p>
<p>Finally, we can iterate over <code>people</code> and find the answer for each <code>person</code>. How do we do this? We can perform a binary search over <code>positions</code> to find the index <code>i</code> where <code>person</code> fits. <code>prefix[i]</code> is the answer for this <code>person</code>.</p>
<p>Let's summarize the algorithm with an example:</p>
<p><img src="../Figures/2251/1.png" alt="example" /><br />
<br></p>
<p>Our first step is to populate <code>difference</code>. Each <code>key, value</code> pair in <code>difference</code> represents &quot;at time <code>key</code>, we see a change in <code>value</code> new flowers&quot;. For example, the key value pair of <code>6: -2</code> means that at time <code>6</code>, we see two less flowers.</p>
<p><img src="../Figures/2251/2.png" alt="example" /><br />
<br></p>
<p>Next, we create a <code>prefix</code> sum on the values of difference, as well as an array <code>positions</code> to associate each <code>prefix</code> value with a position in time. Notice that <code>positions</code> is just the keys of <code>difference</code>.</p>
<p><img src="../Figures/2251/3.png" alt="example" /><br />
<br></p>
<p>With these arrays, we can now use binary search to identify how many flowers a given <code>person</code> will see. For example, consider <code>person</code> at time <code>7</code>:</p>
<p><img src="../Figures/2251/4.png" alt="example" /><br />
<br></p>
<p>What about <code>person</code> at time <code>11</code>?</p>
<p><img src="../Figures/2251/5.png" alt="example" /><br />
<br></p>
<p>There are a few more things to consider before we start implementation.</p>
<ol>
<li>What happens if there is a <code>person</code> that arrives before any flower blooms? This may confuse our binary search since the minimum value in <code>positions</code> will be greater than <code>person</code>. We will initialize <code>difference</code> with <code>0: 0</code> to represent at time <code>0</code>, we don't see any new flowers.</li>
<li>Regarding the binary search; how should it be configured? Referencing the above example images, inserting <code>11</code> into the given <code>positions</code> array will put it at index <code>6</code>. However, we need index <code>5</code>. Thus, we need the insertion index minus one. What if the value exists in <code>positions</code>, as is the case with <code>person = 7</code>? To offset the minus one, we will binary search for the rightmost insertion index (<code>bisect_right</code> in Python, <code>upper_bound</code> in C++).</li>
</ol>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a sorted-map data structure <code>difference</code> with <code>0: 0</code>.</li>
<li>Iterate over each <code>flower = [start, end]</code> in <code>flowers</code>:
<ul>
<li>Increment <code>difference[start]</code>.</li>
<li>Decrement <code>difference[end + 1]</code>.</li>
</ul>
</li>
<li>Initialize two arrays, <code>positions</code> and <code>prefix</code>. Iterate over the keys of <code>difference</code>:
<ul>
<li><code>positions</code> contains all the keys in the order they are traversed.</li>
<li><code>prefix</code> contains the prefix sum of the corresponding values.</li>
</ul>
</li>
<li>Initialize the answer array <code>ans</code>. Iterate over each <code>person</code> in <code>people</code>:
<ul>
<li>Perform a right-insertion index binary search on <code>positions</code> with <code>person</code>.</li>
<li>Calculate <code>i</code> as the result of this binary search minus one.</li>
<li>Add <code>prefix[i]</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/fPatgqyF/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>flowers</code> and <span class="math inline">\(m\)</span> as the length of <code>people</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((n + m) \cdot \log{n})\)</span></p>
<p>Our first loop sets <code>difference</code>, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
<p>Next, we calculate the prefix sum, which will cost either <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(n \cdot \log{}n)\)</span> depending on your language's implementation. This is because <code>difference</code> will have a size between <span class="math inline">\(n\)</span> and <span class="math inline">\(2n\)</span>.</p>
<p>Finally, we have a loop over <code>people</code>. We perform a binary search that costs <span class="math inline">\(O(\log{}n)\)</span> at each iteration. Thus, we spend <span class="math inline">\(m \cdot \log{}n\)</span> here.</p>
<p>This gives us a final time complexity of <span class="math inline">\(O((n + m) \cdot \log{n})\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>difference</code> has a size of <span class="math inline">\(O(n)\)</span>. <code>prefix</code> and <code>positions</code> have the same size as <code>difference</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-simpler-binary-search">Approach 3: Simpler Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>In the previous approach, we used the concept of a difference array/line sweep to calculate how many flowers are seen at a given time. For each <code>flower = [start, end]</code>, we indicated that at time <code>start</code>, we see one more flower, and at time <code>end + 1</code>, we see one less flower. We identified when a flower started blooming and when it finished blooming.</p>
<p>The idea behind this strategy is that at any given time, <strong>the number of flowers we see is the number of flowers that have already started blooming minus the amount of flowers have finished blooming.</strong></p>
<p>Is there a simpler way to identify at a given time, how many flowers have started blooming, and how many flowers have finished blooming? In the first two approaches, we always associate the <code>start</code> and <code>end</code> of the same flower together for processing, which is more intuitive but can be more complex to handle. What if we separately consider these two sets of times?</p>
<p>We can simply collect all <code>start</code> points in one array <code>starts</code>, sort it, and then perform a binary search. We can do the exact same thing with another array <code>ends</code> for all <code>end</code> points. Take a look at the following example:</p>
<p><img src="../Figures/2251/6.png" alt="example" /><br />
<br></p>
<p>Here, we have collected all <code>start</code> and <code>end</code> times and then sorted them. How many flowers can somebody at time <code>11</code> see?</p>
<p><img src="../Figures/2251/7.png" alt="example" /><br />
<br></p>
<p>As you can see, <code>4</code> flowers have started blooming and <code>2</code> flowers have finished blooming. Thus, <code>4 - 2 = 2</code> flowers can be seen at time <code>11</code>. Because <code>starts</code> and <code>ends</code> is sorted, we can use binary search to quickly identify how many flowers have started and finished blooming for any given time.</p>
<p>Regarding the binary searches: when binary searching on <code>starts</code>, we want to search for the rightmost insertion index. This is because if a <code>person</code> arrives at the same time as a flower starts blooming, we want to include this flower.</p>
<p>Note that a <code>flower = [start, end]</code> stops blooming at <code>end + 1</code>, not <code>end</code>. There are two ways we can handle this. We can either binary search on <code>end</code> for the leftmost insertion index (since we want to include all flowers with <code>end</code> equal to the current time), or we can assemble <code>ends</code> using <code>end + 1</code> for each <code>flower</code>. We will implement the algorithm using the second option in this article.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create two arrays <code>starts</code> and <code>ends</code>.</li>
<li>Iterate over each <code>flower = [start, end]</code> in <code>flowers</code>:
<ul>
<li>Add <code>start</code> to <code>starts</code>.</li>
<li>Add <code>end + 1</code> to <code>ends</code>.</li>
</ul>
</li>
<li>Sort both <code>starts</code> and <code>ends</code>.</li>
<li>Initialize the answer array <code>ans</code> and iterate over each <code>person</code> in <code>people</code>:
<ul>
<li>Perform a binary search on <code>starts</code> for the rightmost insertion index of <code>person</code> to find <code>i</code>.</li>
<li>Perform a binary search on <code>ends</code> for the rightmost insertion index of <code>person</code> to find <code>j</code>.</li>
<li>Add <code>i - j</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/RZab5Q59/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>flowers</code> and <span class="math inline">\(m\)</span> as the length of <code>people</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((n + m) \cdot \log{n})\)</span></p>
<p>We first create two arrays of length <span class="math inline">\(n\)</span>, <code>starts</code> and <code>ends</code>, then sort them. This costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
<p>Next, we iterate over <code>people</code> and perform two binary searches at each iteration. This costs <span class="math inline">\(O(m \cdot \log{}n)\)</span>.</p>
<p>Thus, our time complexity is <span class="math inline">\(O((n + m) \cdot \log{n})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>starts</code> and <code>ends</code> both have a size of <code>n</code>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-218">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-matching-subsequences/description" target="_blank" rel="noopener noreferrer">Number of Matching Subsequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and an array of strings <code>words</code>, return <em>the number of</em> <code>words[i]</code> <em>that is a subsequence of</em> <code>s</code>.</p>

<p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>

<ul>
	<li>For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcde&quot;, words = [&quot;a&quot;,&quot;bb&quot;,&quot;acd&quot;,&quot;ace&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three strings in words that are a subsequence of s: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dsahjpjauf&quot;, words = [&quot;ahjpjau&quot;,&quot;ja&quot;,&quot;ahbwzgqnuk&quot;,&quot;tnmlanowax&quot;]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words.length &lt;= 5000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 50</code></li>
	<li><code>s</code> and <code>words[i]</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-219">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-pairs-satisfying-inequality/description" target="_blank" rel="noopener noreferrer">Number of Pairs Satisfying Inequality</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, each of size <code>n</code>, and an integer <code>diff</code>. Find the number of <strong>pairs</strong> <code>(i, j)</code> such that:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt;= n - 1</code> <strong>and</strong></li>
	<li><code>nums1[i] - nums1[j] &lt;= nums2[i] - nums2[j] + diff</code>.</li>
</ul>

<p>Return<em> the <strong>number of pairs</strong> that satisfy the conditions.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,2,5], nums2 = [2,2,1], diff = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong>
There are 3 pairs that satisfy the conditions:
1. i = 0, j = 1: 3 - 2 &lt;= 2 - 2 + 1. Since i &lt; j and 1 &lt;= 1, this pair satisfies the conditions.
2. i = 0, j = 2: 3 - 5 &lt;= 2 - 1 + 1. Since i &lt; j and -2 &lt;= 2, this pair satisfies the conditions.
3. i = 1, j = 2: 2 - 5 &lt;= 2 - 1 + 1. Since i &lt; j and -3 &lt;= 2, this pair satisfies the conditions.
Therefore, we return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,-1], nums2 = [-2,2], diff = -1
<strong>Output:</strong> 0
<strong>Explanation:</strong>
Since there does not exist any pair that satisfies the conditions, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length == nums2.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= diff &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-220">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subarrays-with-and-value-of-k/description" target="_blank" rel="noopener noreferrer">Number of Subarrays With AND Value of K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return the number of <span data-keyword="subarray-nonempty">subarrays</span> of <code>nums</code> where the bitwise <code>AND</code> of the elements of the subarray equals <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,1], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>All subarrays contain only 1&#39;s.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>Subarrays having an <code>AND</code> value of 1 are: <code>[<u><strong>1</strong></u>,1,2]</code>, <code>[1,<u><strong>1</strong></u>,2]</code>, <code>[<u><strong>1,1</strong></u>,2]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Subarrays having an <code>AND</code> value of 2 are: <code>[1,<b><u>2</u></b>,3]</code>, <code>[1,<u><strong>2,3</strong></u>]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-221">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description" target="_blank" rel="noopener noreferrer">Number of Subsequences That Satisfy the Given Sum Condition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> and an integer <code>target</code>.</p>

<p>Return <em>the number of <strong>non-empty</strong> subsequences of </em><code>nums</code><em> such that the sum of the minimum and maximum element on it is less or equal to </em><code>target</code>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,6,7], target = 9
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 subsequences that satisfy the condition.
[3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9)
[3,5] -&gt; (3 + 5 &lt;= 9)
[3,5,6] -&gt; (3 + 6 &lt;= 9)
[3,6] -&gt; (3 + 6 &lt;= 9)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3,6,8], target = 10
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,3,4,6,7], target = 12
<strong>Output:</strong> 61
<strong>Explanation:</strong> There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= target &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-222">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/numbers-at-most-n-given-digit-set/description" target="_blank" rel="noopener noreferrer">Numbers At Most N Given Digit Set</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of <code>digits</code> which is sorted in <strong>non-decreasing</strong> order. You can write numbers using each <code>digits[i]</code> as many times as we want. For example, if <code>digits = [&#39;1&#39;,&#39;3&#39;,&#39;5&#39;]</code>, we may write numbers such as <code>&#39;13&#39;</code>, <code>&#39;551&#39;</code>, and <code>&#39;1351315&#39;</code>.</p>

<p>Return <em>the number of positive integers that can be generated </em>that are less than or equal to a given integer <code>n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> digits = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], n = 100
<strong>Output:</strong> 20
<strong>Explanation: </strong>
The 20 numbers that can be written are:
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> digits = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], n = 1000000000
<strong>Output:</strong> 29523
<strong>Explanation: </strong>
We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,
81 four digit numbers, 243 five digit numbers, 729 six digit numbers,
2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.
In total, this is 29523 integers that can be written using the digits array.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> digits = [&quot;7&quot;], n = 8
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= digits.length &lt;= 9</code></li>
	<li><code>digits[i].length == 1</code></li>
	<li><code>digits[i]</code> is a digit from&nbsp;<code>&#39;1&#39;</code>&nbsp;to <code>&#39;9&#39;</code>.</li>
	<li>All the values in&nbsp;<code>digits</code> are <strong>unique</strong>.</li>
	<li><code>digits</code> is sorted in&nbsp;<strong>non-decreasing</strong> order.</li>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dynamic-programming--counting">Approach 1: Dynamic Programming + Counting</h3>
<p><strong>Intuition</strong></p>
<p>First, call a positive integer <code>X</code> <em>valid</em> if <code>X &lt;= N</code> and <code>X</code> only consists of digits from <code>D</code>.  Our goal is to find the number of valid integers.</p>
<p>Say <code>N</code> has <code>K</code> digits.  If we write a valid number with <code>k</code> digits (<code>k &lt; K</code>), then there are <span class="math inline">\((D\text{.length})^k\)</span> possible numbers we could write, since all of them will definitely be less than <code>N</code>.</p>
<p>Now, say we are to write a valid <code>K</code> digit number from left to right.  For example, <code>N = 2345</code>, <code>K = 4</code>, and <code>D = '1', '2', ..., '9'</code>.  Let's consider what happens when we write the first digit.</p>
<ul>
<li>
<p>If the first digit we write is less than the first digit of <code>N</code>, then we could write any numbers after, for a total of <span class="math inline">\((D\text{.length})^{K-1}\)</span> valid numbers from this one-digit prefix.  In our example, if we start with <code>1</code>, we could write any of the numbers <code>1111</code> to <code>1999</code> from this prefix.</p>
</li>
<li>
<p>If the first digit we write is the same, then we require that the next digit we write is equal to or lower than the next digit in <code>N</code>.  In our example (with <code>N = 2345</code>), if we start with <code>2</code>, the next digit we write must be <code>3</code> or less.</p>
</li>
<li>
<p>We can't write a larger digit, because if we started with eg. <code>3</code>, then even a number of <code>3000</code> is definitely larger than <code>N</code>.</p>
</li>
</ul>
<p><strong>Algorithm</strong></p>
<p>Let <code>dp[i]</code> be the number of ways to write a valid number if <code>N</code> became <code>N[i], N[i+1], ...</code>.  For example, if <code>N = 2345</code>, then <code>dp[0]</code> would be the number of valid numbers at most <code>2345</code>, <code>dp[1]</code> would be the ones at most <code>345</code>, <code>dp[2]</code> would be the ones at most <code>45</code>, and <code>dp[3]</code> would be the ones at most <code>5</code>.</p>
<p>Then, by our reasoning above, <code>dp[i] = (number of d in D with d &lt; S[i]) * ((D.length) ** (K-i-1))</code>, plus <code>dp[i+1]</code> if <code>S[i]</code> is in <code>D</code>.</p>
<p><a href="https://leetcode.com/playground/7GhVBz5s/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(\log N)\)</span>, and assuming <span class="math inline">\(D\text{.length}\)</span> is constant.  (We could make this better by pre-calculating the number of <code>d &lt; S[i]</code> for all possible digits <code>S[i]</code>, but this isn't necessary.)</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(\log N)\)</span>, the space used by <code>S</code> and <code>dp</code>.  (Actually, we could store only the last 2 entries of <code>dp</code>, but this isn't necessary.)<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-mathematical">Approach 2: Mathematical</h3>
<p><strong>Intuition</strong></p>
<p>As in <em>Approach #1</em>, call a positive integer <code>X</code> <em>valid</em> if <code>X &lt;= N</code> and <code>X</code> only consists of digits from <code>D</code>.</p>
<p>Now let <code>B = D.length</code>.  There is a bijection between valid integers and so called &quot;bijective-base-<code>B</code>&quot; numbers.  For example, if <code>D = ['1', '3', '5', '7']</code>, then we could write the numbers <code>'1', '3', '5', '7', '11', '13', '15', '17', '31', ...</code> as (bijective-base-<code>B</code>) numbers <code>'1', '2', '3', '4', '11', '12', '13', '14', '21', ...</code>.</p>
<p>It is clear that both of these sequences are increasing, which means that the first sequence is a contiguous block of valid numbers, followed by invalid numbers.</p>
<p>Our approach is to find the largest valid integer, and convert it into bijective-base-<code>B</code> from which it is easy to find its rank (position in the sequence.)  Because of the bijection, the rank of this element must be the number of valid integers.</p>
<p>Continuing our example, if <code>N = 64</code>, then the valid numbers are <code>'1', '3', ..., '55', '57'</code>, which can be written as bijective-base-4 numbers <code>'1', '2', ..., '33', '34'</code>.  Converting this last entry <code>'34'</code> to decimal, the answer is <code>16</code> (3 * 4 + 4).</p>
<p><strong>Algorithm</strong></p>
<p>Let's convert <code>N</code> into the largest possible valid integer <code>X</code>, convert <code>X</code> to bijective-base-B, then convert that result to a decimal answer.  The last two conversions are relatively straightforward, so let's focus on the first part of the task.</p>
<p>Let's try to write <code>X</code> one digit at a time.  Let's walk through an example where <code>D = ['2', '4', '6', '8']</code>.  There are some cases:</p>
<ul>
<li>
<p>If the first digit of <code>N</code> is in <code>D</code>, we write that digit and continue.  For example, if <code>N = 25123</code>, then we will write <code>2</code> and continue.</p>
</li>
<li>
<p>If the first digit of <code>N</code> is larger than <code>min(D)</code>, then we write the largest possible number from <code>D</code> less than that digit, and the rest of the numbers will be big.  For example, if <code>N = 5123</code>, then we will write <code>4888</code> (<code>4</code> then <code>888</code>).</p>
</li>
<li>
<p>If the first digit of <code>N</code> is smaller than <code>min(D)</code>, then we must &quot;subtract 1&quot; (in terms of <code>X</code>'s bijective-base-B representation), and the rest of the numbers will be big.</p>
<p>For example, if  <code>N = 123</code>, we will write <code>88</code>.  If <code>N = 4123</code>, we will write <code>2888</code>.  And if <code>N = 22123</code>, we will write <code>8888</code>.  This is because &quot;subtracting 1&quot; from <code>'', '4', '22'</code> yields <code>'', '2', '8'</code> (can't go below 0).</p>
</li>
</ul>
<p>Actually, in our solution, it is easier to write in bijective-base-B, so instead of writing digits of <code>D</code>, we'll write the index of those digits (1-indexed).  For example, <code>X = 24888</code> will be <code>A = [1, 2, 4, 4, 4]</code>.  Afterwards, we convert this to decimal.</p>
<p><a href="https://leetcode.com/playground/ctcgU9Fs/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(\log N)\)</span>, and assuming <span class="math inline">\(D\text{.length}\)</span> is constant.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(\log N)\)</span>, the space used by <code>A</code>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-223">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/online-election/description" target="_blank" rel="noopener noreferrer">Online Election</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>persons</code> and <code>times</code>. In an election, the <code>i<sup>th</sup></code> vote was cast for <code>persons[i]</code> at time <code>times[i]</code>.</p>

<p>For each query at a time <code>t</code>, find the person that was leading the election at time <code>t</code>. Votes cast at time <code>t</code> will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.</p>

<p>Implement the <code>TopVotedCandidate</code> class:</p>

<ul>
	<li><code>TopVotedCandidate(int[] persons, int[] times)</code> Initializes the object with the <code>persons</code> and <code>times</code> arrays.</li>
	<li><code>int q(int t)</code> Returns the number of the person that was leading the election at time <code>t</code> according to the mentioned rules.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;TopVotedCandidate&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;]
[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]
<strong>Output</strong>
[null, 0, 1, 1, 0, 0, 1]

<strong>Explanation</strong>
TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);
topVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.
topVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.
topVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)
topVotedCandidate.q(15); // return 0
topVotedCandidate.q(24); // return 0
topVotedCandidate.q(8); // return 1

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= persons.length &lt;= 5000</code></li>
	<li><code>times.length == persons.length</code></li>
	<li><code>0 &lt;= persons[i] &lt; persons.length</code></li>
	<li><code>0 &lt;= times[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>times</code> is sorted in a strictly increasing order.</li>
	<li><code>times[0] &lt;= t &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>q</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-224">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/online-majority-element-in-subarray/description" target="_blank" rel="noopener noreferrer">Online Majority Element In Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure that efficiently finds the <strong>majority element</strong> of a given subarray.</p>

<p>The <strong>majority element</strong> of a subarray is an element that occurs <code>threshold</code> times or more in the subarray.</p>

<p>Implementing the <code>MajorityChecker</code> class:</p>

<ul>
	<li><code>MajorityChecker(int[] arr)</code> Initializes the instance of the class with the given array <code>arr</code>.</li>
	<li><code>int query(int left, int right, int threshold)</code> returns the element in the subarray <code>arr[left...right]</code> that occurs at least <code>threshold</code> times, or <code>-1</code> if no such element exists.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MajorityChecker&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;]
[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]
<strong>Output</strong>
[null, 1, -1, 2]

<strong>Explanation</strong>
MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]);
majorityChecker.query(0, 5, 4); // return 1
majorityChecker.query(0, 3, 3); // return -1
majorityChecker.query(2, 3, 2); // return 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>
	<li><code>threshold &lt;= right - left + 1</code></li>
	<li><code>2 * threshold &gt; right - left + 1</code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>query</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-225">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/description" target="_blank" rel="noopener noreferrer">Partition Array Into Two Arrays to Minimize Sum Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of <code>2 * n</code> integers. You need to partition <code>nums</code> into <strong>two</strong> arrays of length <code>n</code> to <strong>minimize the absolute difference</strong> of the <strong>sums</strong> of the arrays. To partition <code>nums</code>, put each element of <code>nums</code> into <strong>one</strong> of the two arrays.</p>

<p>Return <em>the <strong>minimum</strong> possible absolute difference</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example-1" src="https://assets.leetcode.com/uploads/2021/10/02/ex1.png" style="width: 240px; height: 106px;" />
<pre>
<strong>Input:</strong> nums = [3,9,7,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> One optimal partition is: [3,9] and [7,3].
The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-36,36]
<strong>Output:</strong> 72
<strong>Explanation:</strong> One optimal partition is: [-36] and [36].
The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="example-3" src="https://assets.leetcode.com/uploads/2021/10/02/ex3.png" style="width: 316px; height: 106px;" />
<pre>
<strong>Input:</strong> nums = [2,-1,0,4,-2,-9]
<strong>Output:</strong> 0
<strong>Explanation:</strong> One optimal partition is: [2,4,-9] and [-1,0,-2].
The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 15</code></li>
	<li><code>nums.length == 2 * n</code></li>
	<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-226">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-existence-queries-in-a-graph-i/description" target="_blank" rel="noopener noreferrer">Path Existence Queries in a Graph I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of nodes in a graph, labeled from 0 to <code>n - 1</code>.</p>

<p>You are also given an integer array <code>nums</code> of length <code>n</code> sorted in <strong>non-decreasing</strong> order, and an integer <code>maxDiff</code>.</p>

<p>An <strong>undirected </strong>edge exists between nodes <code>i</code> and <code>j</code> if the <strong>absolute</strong> difference between <code>nums[i]</code> and <code>nums[j]</code> is <strong>at most</strong> <code>maxDiff</code> (i.e., <code>|nums[i] - nums[j]| &lt;= maxDiff</code>).</p>

<p>You are also given a 2D integer array <code>queries</code>. For each <code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>, determine whether there exists a path between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>Return a boolean array <code>answer</code>, where <code>answer[i]</code> is <code>true</code> if there exists a path between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the <code>i<sup>th</sup></code> query and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, nums = [1,3], maxDiff = 1, queries = [[0,0],[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,false]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Query <code>[0,0]</code>: Node 0 has a trivial path to itself.</li>
	<li>Query <code>[0,1]</code>: There is no edge between Node 0 and Node 1 because <code>|nums[0] - nums[1]| = |1 - 3| = 2</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Thus, the final answer after processing all the queries is <code>[true, false]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, nums = [2,5,6,8], maxDiff = 2, queries = [[0,1],[0,2],[1,3],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false,false,true,true]</span></p>

<p><strong>Explanation:</strong></p>

<p>The resulting graph is:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/25/screenshot-2025-03-26-at-122249.png" style="width: 300px; height: 170px;" /></p>

<ul>
	<li>Query <code>[0,1]</code>: There is no edge between Node 0 and Node 1 because <code>|nums[0] - nums[1]| = |2 - 5| = 3</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Query <code>[0,2]</code>: There is no edge between Node 0 and Node 2 because <code>|nums[0] - nums[2]| = |2 - 6| = 4</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Query <code>[1,3]</code>: There is a path between Node 1 and Node 3 through Node 2 since <code>|nums[1] - nums[2]| = |5 - 6| = 1</code> and <code>|nums[2] - nums[3]| = |6 - 8| = 2</code>, both of which are within <code>maxDiff</code>.</li>
	<li>Query <code>[2,3]</code>: There is an edge between Node 2 and Node 3 because <code>|nums[2] - nums[3]| = |6 - 8| = 2</code>, which is equal to <code>maxDiff</code>.</li>
	<li>Thus, the final answer after processing all the queries is <code>[false, false, true, true]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
	<li><code>0 &lt;= maxDiff &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i] == [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-227">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-existence-queries-in-a-graph-ii/description" target="_blank" rel="noopener noreferrer">Path Existence Queries in a Graph II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of nodes in a graph, labeled from 0 to <code>n - 1</code>.</p>

<p>You are also given an integer array <code>nums</code> of length <code>n</code> and an integer <code>maxDiff</code>.</p>

<p>An <strong>undirected </strong>edge exists between nodes <code>i</code> and <code>j</code> if the <strong>absolute</strong> difference between <code>nums[i]</code> and <code>nums[j]</code> is <strong>at most</strong> <code>maxDiff</code> (i.e., <code>|nums[i] - nums[j]| &lt;= maxDiff</code>).</p>

<p>You are also given a 2D integer array <code>queries</code>. For each <code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>, find the <strong>minimum</strong> distance between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code><sub>.</sub> If no path exists between the two nodes, return -1 for that query.</p>

<p>Return an array <code>answer</code>, where <code>answer[i]</code> is the result of the <code>i<sup>th</sup></code> query.</p>

<p><strong>Note:</strong> The edges between the nodes are unweighted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, nums = [1,8,3,4,2], maxDiff = 3, queries = [[0,3],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p>The resulting graph is:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/25/4149example1drawio.png" style="width: 281px; height: 161px;" /></p>

<table>
	<tbody>
		<tr>
			<th>Query</th>
			<th>Shortest Path</th>
			<th>Minimum Distance</th>
		</tr>
		<tr>
			<td>[0, 3]</td>
			<td>0 &rarr; 3</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[2, 4]</td>
			<td>2 &rarr; 4</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>Thus, the output is <code>[1, 1]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, nums = [5,3,1,9,10], maxDiff = 2, queries = [[0,1],[0,2],[2,3],[4,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,-1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p>The resulting graph is:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/25/4149example2drawio.png" style="width: 281px; height: 121px;" /></p>
</div>

<table>
	<tbody>
		<tr>
			<th>Query</th>
			<th>Shortest Path</th>
			<th>Minimum Distance</th>
		</tr>
		<tr>
			<td>[0, 1]</td>
			<td>0 &rarr; 1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[0, 2]</td>
			<td>0 &rarr; 1 &rarr; 2</td>
			<td>2</td>
		</tr>
		<tr>
			<td>[2, 3]</td>
			<td>None</td>
			<td>-1</td>
		</tr>
		<tr>
			<td>[4, 3]</td>
			<td>3 &rarr; 4</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>Thus, the output is <code>[1, 2, -1, 1]</code>.</p>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, nums = [3,6,1], maxDiff = 1, queries = [[0,0],[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1,-1]</span></p>

<p><strong>Explanation:</strong></p>

<p>There are no edges between any two nodes because:</p>

<ul>
	<li>Nodes 0 and 1: <code>|nums[0] - nums[1]| = |3 - 6| = 3 &gt; 1</code></li>
	<li>Nodes 0 and 2: <code>|nums[0] - nums[2]| = |3 - 1| = 2 &gt; 1</code></li>
	<li>Nodes 1 and 2: <code>|nums[1] - nums[2]| = |6 - 1| = 5 &gt; 1</code></li>
</ul>

<p>Thus, no node can reach any other node, and the output is <code>[0, -1, -1]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= maxDiff &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i] == [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-228">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-minimum-effort/description" target="_blank" rel="noopener noreferrer">Path With Minimum Effort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are a hiker preparing for an upcoming hike. You are given <code>heights</code>, a 2D array of size <code>rows x columns</code>, where <code>heights[row][col]</code> represents the height of cell <code>(row, col)</code>. You are situated in the top-left cell, <code>(0, 0)</code>, and you hope to travel to the bottom-right cell, <code>(rows-1, columns-1)</code> (i.e.,&nbsp;<strong>0-indexed</strong>). You can move <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>, and you wish to find a route that requires the minimum <strong>effort</strong>.</p>

<p>A route&#39;s <strong>effort</strong> is the <strong>maximum absolute difference</strong><strong> </strong>in heights between two consecutive cells of the route.</p>

<p>Return <em>the minimum <strong>effort</strong> required to travel from the top-left cell to the bottom-right cell.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex1.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,2],[3,8,2],[5,3,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex2.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,3],[3,8,4],[5,3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex3.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> This route does not require any effort.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == heights.length</code></li>
	<li><code>columns == heights[i].length</code></li>
	<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
	<li><code>1 &lt;= heights[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-229">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/peak-index-in-a-mountain-array/description" target="_blank" rel="noopener noreferrer">Peak Index in a Mountain Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <strong>mountain</strong> array <code>arr</code> of length <code>n</code> where the values increase to a <strong>peak element</strong> and then decrease.</p>

<p>Return the index of the peak element.</p>

<p>Your task is to solve it in <code>O(log(n))</code> time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">arr = [0,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">arr = [0,2,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">arr = [0,10,5,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>arr</code> is <strong>guaranteed</strong> to be a mountain array.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given a mountain array <code>arr</code>, our task is to return the index <code>i</code> such that <code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code>. In simpler terms, all elements to the left are sorted ascending and all elements to the right are sorted descending.</p>
<hr />
<h3 id="approach-1-linear-scan">Approach 1: Linear Scan</h3>
<h4 id="intuition">Intuition</h4>
<p>We are guaranteed to have an array of the form <code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code>. As our task is to find the index <code>i</code> (called the peak index of the mountain array), we can iterate over the array starting from the first element.</p>
<p>We can create a pointer <code>i</code> and set it to <code>0</code> to point to the first element. We compare the current element at index <code>i</code> with the next element at index <code>i + 1</code>. If <code>arr[i] &lt; arr[i + 1]</code>, it means we haven't got the peak of the mountain yet. As a result, we increment <code>i</code> by <code>1</code> in this case to move to the next element. Otherwise, the first time we see <code>arr[i] &gt; arr[i + 1]</code>, we return <code>i</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>i</code> and initialize it to <code>0</code>.</li>
<li>Using a while loop check if the current element pointed by <code>i</code> is smaller than the next element at index <code>i + 1</code>. If <code>arr[i] &lt; arr[i + 1]</code>, increment <code>i</code> by <code>1</code>. Otherwise, if <code>arr[i] &gt; arr[i + 1]</code>, we return <code>i</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/mPBmvUp6/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the length of <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We are doing a linear scan and comparing adjacent elements until we get the peak of the mountain over the <code>arr</code> array. In the worst-case situation, the peak of the mountain could correspond to the second last element of <code>arr</code>, in which case we would take <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>We are not using any extra space other than an integer <code>i</code>, which takes up constant space.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search">Approach 2: Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In a mountain array with peak index <code>i</code>, any element at <code>index</code> with <code>index</code> less than <code>i</code> would obey <code>arr[index] &lt; arr[index + 1]</code>. Furthermore, any <code>index</code> greater than or equal to <code>i</code> would follow the rule <code>arr[index] &gt; arr[index + 1]</code> (and not obey <code>arr[index] &lt; arr[index + 1]</code>).</p>
<p>A scenario like this where our task is to search for an element <code>i</code> from a given range <code>(l, r)</code> where all values smaller than <code>i</code> satisfy a certain condition and all values greater than or equal to <code>i</code> do not satisfy it (or vice-versa) can be solved optimally with a binary search algorithm. In binary search, we repeatedly divide the solution space where the answer could be in half until the range contains just one element.</p>
<p>Following the above discussion, we use binary search to solve this problem. We create an integer <code>l</code> and initialize it to the starting index <code>0</code>. We also create another integer variable <code>r</code> and set it to the last index of <code>arr</code>, i.e., <code>arr.length - 1</code>.</p>
<p>We get the middle of the range <code>mid = (l + r) / 2</code> and compare <code>arr[mid]</code> with the next element. If <code>arr[mid] &lt; arr[mid + 1]</code>, we move to the upper half of the range by setting <code>l = mid + 1</code> as our peak index is definitely greater than <code>mid</code>. Otherwise, if <code>arr[mid] &gt; arr[mid + 1]</code>, we move to the lower half of the range by setting <code>r = mid</code> as the peak index is either <code>mid</code> or some index smaller than <code>mid</code>.</p>
<p>The answer would be within the range <code>(l, r)</code> at any point. All the indices smaller than <code>l</code> are indices smaller than the peak index and all indices greater than <code>r</code> are indices greater than the peak index. We continue the search as long as <code>l &lt; r</code>.</p>
<p>When <code>l == r</code>, <code>l</code> (or <code>r</code>) denotes the required peak index.</p>
<p>Here is a visual representation of an example to illustrate how it works:</p>
<p><img src="../Figures/852/852-1.png" alt="img" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create two integer variables <code>l</code> and <code>r</code> to store the solution space of the problem. We initialize <code>l</code> with <code>0</code> and <code>r</code> to <code>arr.length - 1</code>.</li>
<li>While <code>l &lt; r</code>:
<ul>
<li>Get the index of the middle element using <code>mid = (l + r) / 2</code>.</li>
<li>If <code>arr[mid] &lt; arr[mid + 1]</code>, it indicates peak index is greater than <code>mid</code>. As a result, we move to upper half of the range by setting <code>l = mid + 1</code>.</li>
<li>Else, if <code>arr[mid] &gt;= arr[mid + 1]</code>, it indicates that the peak index is either <code>mid</code> or some index smaller than <code>mid</code>. As a result, we move to the lower half of the range by setting <code>r = mid</code>.</li>
</ul>
</li>
<li>Return <code>l</code> (or <code>r</code> as both are equal now).</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/SvZVBTbd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the length of <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log n)\)</span>.</p>
<ul>
<li>We perform <span class="math inline">\(O(\log n)\)</span> iterations using the binary search algorithm as the problem set is divided into half in each iteration.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>Except for a few variables <code>l</code>, <code>r</code>, and <code>mid</code> which take constant space each, we do not consume any other space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-230">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/plates-between-candles/description" target="_blank" rel="noopener noreferrer">Plates Between Candles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a long table with a line of plates and candles arranged on top of it. You are given a <strong>0-indexed</strong> string <code>s</code> consisting of characters <code>&#39;*&#39;</code> and <code>&#39;|&#39;</code> only, where a <code>&#39;*&#39;</code> represents a <strong>plate</strong> and a <code>&#39;|&#39;</code> represents a <strong>candle</strong>.</p>

<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>queries</code> where <code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> denotes the <strong>substring</strong> <code>s[left<sub>i</sub>...right<sub>i</sub>]</code> (<strong>inclusive</strong>). For each query, you need to find the <strong>number</strong> of plates <strong>between candles</strong> that are <strong>in the substring</strong>. A plate is considered <strong>between candles</strong> if there is at least one candle to its left <strong>and</strong> at least one candle to its right <strong>in the substring</strong>.</p>

<ul>
	<li>For example, <code>s = &quot;||**||**|*&quot;</code>, and a query <code>[3, 8]</code> denotes the substring <code>&quot;*||<strong><u>**</u></strong>|&quot;</code>. The number of plates between candles in this substring is <code>2</code>, as each of the two plates has at least one candle <strong>in the substring</strong> to its left <strong>and</strong> right.</li>
</ul>

<p>Return <em>an integer array</em> <code>answer</code> <em>where</em> <code>answer[i]</code> <em>is the answer to the</em> <code>i<sup>th</sup></code> <em>query</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="ex-1" src="https://assets.leetcode.com/uploads/2021/10/04/ex-1.png" style="width: 400px; height: 134px;" />
<pre>
<strong>Input:</strong> s = &quot;**|**|***|&quot;, queries = [[2,5],[5,9]]
<strong>Output:</strong> [2,3]
<strong>Explanation:</strong>
- queries[0] has two plates between candles.
- queries[1] has three plates between candles.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="ex-2" src="https://assets.leetcode.com/uploads/2021/10/04/ex-2.png" style="width: 600px; height: 193px;" />
<pre>
<strong>Input:</strong> s = &quot;***|**|*****|**||**|*&quot;, queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
<strong>Output:</strong> [9,0,0,0,0]
<strong>Explanation:</strong>
- queries[0] has nine plates between candles.
- The other queries have zero plates between candles.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of <code>&#39;*&#39;</code> and <code>&#39;|&#39;</code> characters.</li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; s.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-231">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/preimage-size-of-factorial-zeroes-function/description" target="_blank" rel="noopener noreferrer">Preimage Size of Factorial Zeroes Function</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Let <code>f(x)</code> be the number of zeroes at the end of <code>x!</code>. Recall that <code>x! = 1 * 2 * 3 * ... * x</code> and by convention, <code>0! = 1</code>.</p>

<ul>
	<li>For example, <code>f(3) = 0</code> because <code>3! = 6</code> has no zeroes at the end, while <code>f(11) = 2</code> because <code>11! = 39916800</code> has two zeroes at the end.</li>
</ul>

<p>Given an integer <code>k</code>, return the number of non-negative integers <code>x</code> have the property that <code>f(x) = k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> k = 0
<strong>Output:</strong> 5
<strong>Explanation:</strong> 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> k = 5
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no x such that x! ends in k = 5 zeroes.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> k = 3
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-232">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/prime-subtraction-operation/description" target="_blank" rel="noopener noreferrer">Prime Subtraction Operation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>

<p>You can perform the following operation as many times as you want:</p>

<ul>
	<li>Pick an index <code>i</code> that you haven&rsquo;t picked before, and pick a prime <code>p</code> <strong>strictly less than</strong> <code>nums[i]</code>, then subtract <code>p</code> from <code>nums[i]</code>.</li>
</ul>

<p>Return <em>true if you can make <code>nums</code> a strictly increasing array using the above operation and false otherwise.</em></p>

<p>A <strong>strictly increasing array</strong> is an array whose each element is strictly greater than its preceding element.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,9,6,10]
<strong>Output:</strong> true
<strong>Explanation:</strong> In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].
In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].
After the second operation, nums is sorted in strictly increasing order, so the answer is true.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,8,11,12]
<strong>Output:</strong> true
<strong>Explanation: </strong>Initially nums is sorted in strictly increasing order, so we don&#39;t need to make any operations.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,8,3]
<strong>Output:</strong> false
<strong>Explanation:</strong> It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code><font face="monospace">nums.length == n</font></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>nums</code>. For each element in <code>nums</code>, we can subtract any prime number strictly less than the current element at most once, with the goal of making the array strictly increasing by performing operations on any number of elements.</p>
<p>For example, consider <code>nums = [5, 5, 4]</code>. For the first element, we have two options:</p>
<ol>
<li>
<p><strong>Make a minimal adjustment</strong> by subtracting a small prime, like <code>2</code>, from <code>5</code>, resulting in <code>[3, 5, 4]</code>. While <code>3</code> is less than <code>5</code>, we still need to adjust the second <code>5</code> to make it smaller than <code>4</code>. Subtracting <code>2</code> from the second <code>5</code> gives <code>[3, 3, 4]</code>, which isn’t strictly increasing.</p>
</li>
<li>
<p><strong>Make a maximal adjustment</strong> by subtracting the largest possible prime under <code>5</code>, which is <code>3</code>. This results in <code>[2, 5, 4]</code>. Now, for the second element, we again subtract the largest prime that keeps it greater than the previous element, resulting in <code>[2, 3, 4]</code>—a strictly increasing sequence.</p>
</li>
</ol>
<p>Following this approach, we prioritize subtracting the largest possible prime from each element while ensuring each adjusted element is still greater than the one before it. This allows us to minimize each value as much as possible, providing the most flexibility for later adjustments.</p>
<p>We’ll explore three approaches based on this greedy strategy. The main difference between them is the method used to find the largest prime to subtract for each element. In the first approach, we use a brute-force method, while in the latter approach, we use the Sieve of Eratosthenes for efficiency. You can refer to these links to learn more about the <a href="https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/709/greedy/">Greedy Algorithm</a> and <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's think through a basic approach to solve the problem. We want to make sure that each number in the array stays just a bit larger than the one before it. To do this, we’ll be subtracting the largest possible prime number from each element, but we have to be careful: the prime we subtract should leave the current element just slightly above the previous one.</p>
<p>In other words, for each element <code>nums[i]</code>, we need to find the biggest prime <code>p</code> so that after subtracting <code>p</code>, the new value of <code>nums[i]</code> is still greater than <code>nums[i-1]</code>. Mathematically, that’s <code>nums[i] - p &gt; nums[i-1]</code>. So, <code>p</code> has to be the largest prime that’s smaller than the difference <code>nums[i] - nums[i-1]</code>.</p>
<p>To make this work, we’ll loop through each element in <code>nums</code>. For each one, we’ll look at the difference between it and the previous number. If this difference is zero or negative, it’s impossible to make the sequence strictly increasing, so we can just return <code>false</code> right away. But if the difference is positive, we need to find the largest prime within this range.</p>
<p>Now, remember a prime number only has two divisors: 1 and itself. To check if a number is prime, we don’t have to test all the way up to that number, we just need to check up to its square root. If we don’t find any divisors up to that point, then the number is prime.</p>
<p>Once we find this largest prime <code>p</code>, we subtract it from <code>nums[i]</code> and move on to the next element. If we manage to go through the whole array without any issues, we know the sequence is strictly increasing, so we return <code>true</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main Function - <code>primeSubOperation(nums)</code></p>
<ol>
<li>Iterate over each element in <code>nums</code> by looping through indices <code>i</code> ranging from 0 to the size of <code>nums</code> minus 1.
<ul>
<li>For the first element (<code>i</code> = 0), set bound to <code>nums[0]</code>. For subsequent elements, set <code>bound</code> to <code>nums[i] - nums[i - 1]</code>.</li>
<li>If <code>bound</code> is less than or equal to 0, return false, as it is impossible to create a strictly increasing sequence.</li>
<li>Initialize <code>largestPrime</code> as 0.</li>
<li>Starting from <code>bound - 1</code>, iterate downwards until 2 to find the largest prime number less than <code>bound</code>.
<ul>
<li>If a prime number is found (using <code>checkPrime</code>), store it in <code>largestPrime</code> and stop the search.</li>
</ul>
</li>
<li>Subtract <code>largestPrime</code> from <code>nums[i]</code>.</li>
</ul>
</li>
<li>If the loop completes, return <code>true</code>.</li>
</ol>
<p>Helper Function - <code>checkPrime(x)</code></p>
<ol>
<li>Loop from 2 to the square root of <code>x</code>:
<ul>
<li>If any number divides <code>x</code> evenly, return false (indicating <code>x</code> is not prime).</li>
</ul>
</li>
<li>If no divisors are found, return <code>true</code>, indicating `x`` is prime.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3NCGBoee/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>n</code> be the length of the <code>nums</code> array, and <code>m</code> denotes the maximum value in the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m \cdot \sqrt(m))\)</span></p>
<p>The algorithm iterates through the <code>nums</code> array, which takes <span class="math inline">\(O(n)\)</span> time for the outer loop. For each element in the array, the algorithm may check each number from <code>bound - 1</code> down to <code>2</code> to find the largest prime.</p>
<p>The primality check is done using the <code>checkPrime</code> function, which has a time complexity of <span class="math inline">\(O(sqrt(m))\)</span>, where <code>m</code> is the current number being checked.</p>
<p>In the worst case, this results in an overall time complexity of <span class="math inline">\(O(n \cdot m \cdot \sqrt(m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is determined by a few integer variables and does not depend on the size of the input. Hence, the overall space complexity is constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-storing-the-primes">Approach 2: Storing the primes</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In our previous method, we checked if each number below a certain difference was prime, which could get repetitive and slow. To make this faster, we can create an array, <code>previousPrime</code>, to store the largest prime number less than each number up to our limit. This lets us quickly look up the nearest prime without recalculating it every time.</p>
<p>Since all values in <code>nums</code> are between 1 and 1000, we only need to find primes within this range. First, we identify which numbers are prime. For each prime number <code>p</code>, we set <code>previousPrime[p] = p</code>. Then, for numbers in between (where no prime has been assigned), we just carry forward the most recent prime we found. For example, if we find <code>previousPrime[3] = 3</code> and <code>previousPrime[5] = 5</code>, but <code>previousPrime[4]</code> is empty, we fill in <code>3</code> for it.</p>
<p>This way, it lets us find the nearest prime for any number in constant time and avoids recalculating primes repeatedly.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main Function - <code>primeSubOperation(nums)</code></p>
<ul>
<li>Calculate <code>maxElement</code> as the maximum value in the <code>nums</code> array.</li>
<li>Create an array <code>previousPrime</code> of size <code>maxElement + 1</code>, where each index will store the largest prime number less than or equal to that index.</li>
<li>Loop from 2 to <code>maxElement</code>:
<ul>
<li>If the number is prime (using <code>checkPrime</code>), set <code>previousPrime[i]</code> to <code>i</code>.</li>
<li>If it’s not prime, set <code>previousPrime[i]</code> to <code>previousPrime[i - 1]</code>.</li>
</ul>
</li>
<li>Loop Through Each Element in <code>nums</code>:</li>
<li>For each element in <code>nums</code>, iterate the index <code>i</code> from 0 to <code>nums.size() - 1</code>:
<ul>
<li>For the first element (i = 0), set <code>bound</code> to <code>nums[0]</code>.</li>
<li>For subsequent elements, set <code>bound</code> to <code>nums[i] - nums[i - 1]</code>.</li>
<li>If <code>bound</code> is less than or equal to 0, return <code>false</code>, as it’s impossible to create a strictly increasing sequence.</li>
<li>Retrieve <code>largestPrime</code> as the value of <code>previousPrime[bound - 1]</code>, representing the largest prime number less than <code>bound</code>.</li>
<li>Subtract <code>largestPrime</code> from <code>nums[i]</code>.</li>
</ul>
</li>
<li>If the loop completes successfully, return <code>true</code>.</li>
</ul>
<p>Helper Function - <code>checkPrime(x)</code></p>
<ul>
<li>Loop from 2 to the square root of <code>x</code>:
<ul>
<li>If any number divides <code>x</code> evenly, return false (indicating <code>x</code> is not prime).</li>
</ul>
</li>
<li>If no divisors are found, return <code>true</code> (indicating <code>x</code> is prime).</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Rf95tfvk/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> be the length of the <code>nums</code> array, and <code>m</code> denotes the maximum value in the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \cdot \sqrt(m))\)</span></p>
<p>We first populate the <code>previousPrime</code> array for all integers from 2 to the maximum element. This involves checking the primality of numbers up to <code>m</code>, which takes <span class="math inline">\(O(m \cdot \sqrt(m))\)</span> time due to the <code>checkPrime</code> function.</p>
<p>Finally, the algorithm iterates through the <code>nums</code> array to apply the prime subtraction operation, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>In the worst case, this results in an overall time complexity of <span class="math inline">\(O(n + m \cdot \sqrt(m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The space complexity is determined by the <code>previousPrime</code> array, which is of size <code>m</code>. This requires <span class="math inline">\(O(m)\)</span> space, where <code>m</code> is the maximum value in the input array.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sieve-of-eratosthenes--two-pointers">Approach 3: Sieve of Eratosthenes + Two Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> is a classic and efficient way to find all the prime numbers up to a certain limit, like 100. Essentially, we’re going to go through a list of numbers and cross off anything that’s not prime.</p>
<ol>
<li>
<p>Create a List: We start with a list of numbers from 2 to 100. Notice we skip 1 since it’s not considered a prime.</p>
</li>
<li>
<p>Mark Multiples of Each Prime:</p>
<ul>
<li>Starting with the smallest prime, 2, we know it’s prime because it hasn’t been marked yet. So, we keep it.</li>
<li>Now, we cross out all multiples of 2 (like 4, 6, 8, etc.) because they’re definitely not prime.</li>
</ul>
</li>
<li>
<p>Move to the Next Unmarked Number:</p>
<ul>
<li>The next number that isn’t crossed out is 3, so we mark it as a prime.</li>
<li>Then, we cross out all multiples of 3 (like 6, 9, 12, etc.).</li>
</ul>
</li>
<li>
<p>Repeat the Process:</p>
<ul>
<li>We keep going, finding the next unmarked number (which will be 5), and marking all of its multiples. We do this for 7 as well and continue until we’ve processed all numbers up to the limit.</li>
</ul>
</li>
</ol>
<p>The beauty of the Sieve of Eratosthenes is that it saves a lot of time by marking off composites in bulk, rather than testing each number individually to see if it’s prime. By the end, any number that’s still unmarked is a prime.</p>
<p>As we proceed, we can store each prime in an array by setting <code>sieve[prime] = 1</code>. For any marked (non-prime) number, we could also keep track of the specific prime that marked it, though, for basic prime-finding, it’s sufficient to identify which numbers are prime.</p>
<p>Since all values lie between 1 and 1000, we can iterate through the array and check the minimum value that can be assigned to the current index. The array should be strictly increasing, so the next value assigned would be greater than the current value. Therefore, we can iterate through the indices and the values simultaneously using two pointers.</p>
<p>We’ll have one pointer, <code>i</code>, which represents the current index in the array, and another variable, <code>currValue</code>, which keeps track of the current value we want to assign to that index. The key here is that <code>nums[i]</code> should equal <code>currValue</code> after we subtract a prime number from it, meaning we need to ensure that the difference between <code>nums[i]</code> and <code>currValue</code> is a prime number.</p>
<p>As we iterate through the array, for each element, we will check if the difference <code>nums[i] - currValue</code> is a prime number. We can use the sieve table for this check. If the difference is prime (i.e. <code>sieve[difference] = 1</code>), we assign <code>currValue</code> to <code>nums[i]</code> and move on by incrementing both <code>i</code> and <code>currValue</code>. However, if the difference isn't prime, we increment <code>currValue</code> and check again to see if we can assign it to the same index <code>i</code>.</p>
<p>If at any point the difference becomes negative, it means that <code>nums[i]</code> is already less than <code>currValue</code>, and in that case, we can conclude that it’s impossible to assign the values correctly and return <code>false</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Calculate <code>maxElement</code> as the maximum value in the <code>nums</code> array.</li>
<li>Create a <code>sieve</code> array of size <code>maxElement + 1</code> where each index initially has a value of 1 (indicating prime), except <code>sieve[1]</code>, which is set to 0 (indicating non-prime).</li>
<li>Loop through each number from <code>2</code> to the square root of <code>maxElement + 1</code>:
<ul>
<li>For each prime number <code>i</code>, mark all multiples of <code>i</code> as non-prime by setting <code>sieve[j]</code> to 0 for each multiple <code>j</code>.</li>
</ul>
</li>
<li>Initialize <code>currValue</code> to 1 and start with index <code>i</code> = 0 in <code>nums</code>:</li>
<li>While <code>i</code> is less than the size of <code>nums</code>:<br />
- Calculate difference as <code>nums[i] - currValue</code>.<br />
- If difference is less than 0, return <code>false</code>, as <code>nums[i]</code> is already less than <code>currValue</code>.<br />
- If difference is either prime (<code>sieve[difference]</code> equals 1) or <code>0</code>, move to the next element by incrementing <code>i</code> and <code>currValue</code>.<br />
- Otherwise, increment <code>currValue</code> and try again.</li>
<li>If the loop completes successfully, return <code>true</code>.</li>
</ol>
<p>!?!../Documents/2601/slideshow1.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/cSsTp4jG/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <code>n</code> be the length of the <code>nums</code> array, and <code>m</code> denotes the maximum value in the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \log \log (m))\)</span></p>
<p>We first construct the sieve array to identify prime numbers up to <code>maxElement</code>. The Sieve of Eratosthenes runs in <span class="math inline">\(O(m \log \log (m))\)</span> time, where <code>m</code> is the maximum element.</p>
<p>Finally, the algorithm iterates through the <code>nums</code> array to apply the prime subtraction operation, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>In the worst case, this results in an overall time complexity of <span class="math inline">\(O(n + m \log \log (m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The space complexity is determined by the <code>sieve</code> array, which is of size <code>m</code>. This requires <span class="math inline">\(O(m)\)</span> space, where <code>m</code> is the maximum value in the input array.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-233">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/random-pick-with-blacklist/description" target="_blank" rel="noopener noreferrer">Random Pick with Blacklist</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">randomized</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an array of <strong>unique</strong> integers <code>blacklist</code>. Design an algorithm to pick a random integer in the range <code>[0, n - 1]</code> that is <strong>not</strong> in <code>blacklist</code>. Any integer that is in the mentioned range and not in <code>blacklist</code> should be <strong>equally likely</strong> to be returned.</p>

<p>Optimize your algorithm such that it minimizes the number of calls to the <strong>built-in</strong> random function of your language.</p>

<p>Implement the <code>Solution</code> class:</p>

<ul>
	<li><code>Solution(int n, int[] blacklist)</code> Initializes the object with the integer <code>n</code> and the blacklisted integers <code>blacklist</code>.</li>
	<li><code>int pick()</code> Returns a random integer in the range <code>[0, n - 1]</code> and not in <code>blacklist</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
<strong>Output</strong>
[null, 0, 4, 1, 6, 1, 0, 4]

<strong>Explanation</strong>
Solution solution = new Solution(7, [2, 3, 5]);
solution.pick(); // return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick,
                 // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4).
solution.pick(); // return 4
solution.pick(); // return 1
solution.pick(); // return 6
solution.pick(); // return 1
solution.pick(); // return 0
solution.pick(); // return 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= blacklist.length &lt;= min(10<sup>5</sup>, n - 1)</code></li>
	<li><code>0 &lt;= blacklist[i] &lt; n</code></li>
	<li>All the values of <code>blacklist</code> are <strong>unique</strong>.</li>
	<li>At most <code>2 * 10<sup>4</sup></code> calls will be made to <code>pick</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-234">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/random-pick-with-weight/description" target="_blank" rel="noopener noreferrer">Random Pick with Weight</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">randomized</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of positive integers <code>w</code> where <code>w[i]</code> describes the <strong>weight</strong> of the <code>i<sup>th</sup></code> index.</p>

<p>You need to implement the function <code>pickIndex()</code>, which <strong>randomly</strong> picks an index in the range <code>[0, w.length - 1]</code> (<strong>inclusive</strong>) and returns it. The <strong>probability</strong> of picking an index <code>i</code> is <code>w[i] / sum(w)</code>.</p>

<ul>
	<li>For example, if <code>w = [1, 3]</code>, the probability of picking index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e., <code>25%</code>), and the probability of picking index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e., <code>75%</code>).</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Solution&quot;,&quot;pickIndex&quot;]
[[[1]],[]]
<strong>Output</strong>
[null,0]

<strong>Explanation</strong>
Solution solution = new Solution([1]);
solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]
[[[1,3]],[],[],[],[],[]]
<strong>Output</strong>
[null,1,1,1,1,0]

<strong>Explanation</strong>
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.

Since this is a randomization problem, multiple answers are allowed.
All of the following outputs can be considered correct:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
and so on.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>pickIndex</code> will be called at most <code>10<sup>4</sup></code> times.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-235">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/random-point-in-non-overlapping-rectangles/description" target="_blank" rel="noopener noreferrer">Random Point in Non-overlapping Rectangles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">randomized</span> <span class="topic-badge">reservoir-sampling</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of non-overlapping axis-aligned rectangles <code>rects</code> where <code>rects[i] = [a<sub>i</sub>, b<sub>i</sub>, x<sub>i</sub>, y<sub>i</sub>]</code> indicates that <code>(a<sub>i</sub>, b<sub>i</sub>)</code> is the bottom-left corner point of the <code>i<sup>th</sup></code> rectangle and <code>(x<sub>i</sub>, y<sub>i</sub>)</code> is the top-right corner point of the <code>i<sup>th</sup></code> rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.</p>

<p>Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned.</p>

<p><strong>Note</strong> that an integer point is a point that has integer coordinates.</p>

<p>Implement the <code>Solution</code> class:</p>

<ul>
	<li><code>Solution(int[][] rects)</code> Initializes the object with the given rectangles <code>rects</code>.</li>
	<li><code>int[] pick()</code> Returns a random integer point <code>[u, v]</code> inside the space covered by one of the given rectangles.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg" style="width: 419px; height: 539px;" />
<pre>
<strong>Input</strong>
[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]
[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]
<strong>Output</strong>
[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]

<strong>Explanation</strong>
Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
solution.pick(); // return [1, -2]
solution.pick(); // return [1, -1]
solution.pick(); // return [-1, -2]
solution.pick(); // return [-2, -2]
solution.pick(); // return [0, 0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rects.length &lt;= 100</code></li>
	<li><code>rects[i].length == 4</code></li>
	<li><code>-10<sup>9</sup> &lt;= a<sub>i</sub> &lt; x<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= b<sub>i</sub> &lt; y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>x<sub>i</sub> - a<sub>i</sub> &lt;= 2000</code></li>
	<li><code>y<sub>i</sub> - b<sub>i</sub> &lt;= 2000</code></li>
	<li>All the rectangles do not overlap.</li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>pick</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-236">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-frequency-queries/description" target="_blank" rel="noopener noreferrer">Range Frequency Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure to find the <strong>frequency</strong> of a given value in a given subarray.</p>

<p>The <strong>frequency</strong> of a value in a subarray is the number of occurrences of that value in the subarray.</p>

<p>Implement the <code>RangeFreqQuery</code> class:</p>

<ul>
	<li><code>RangeFreqQuery(int[] arr)</code> Constructs an instance of the class with the given <strong>0-indexed</strong> integer array <code>arr</code>.</li>
	<li><code>int query(int left, int right, int value)</code> Returns the <strong>frequency</strong> of <code>value</code> in the subarray <code>arr[left...right]</code>.</li>
</ul>

<p>A <strong>subarray</strong> is a contiguous sequence of elements within an array. <code>arr[left...right]</code> denotes the subarray that contains the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> (<strong>inclusive</strong>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]
[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
<strong>Output</strong>
[null, 1, 2]

<strong>Explanation</strong>
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4]
rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i], value &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>
	<li>At most <code>10<sup>5</sup></code> calls will be made to <code>query</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-237">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-of-sorted-subarray-sums/description" target="_blank" rel="noopener noreferrer">Range Sum of Sorted Subarray Sums</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the array <code>nums</code> consisting of <code>n</code> positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of <code>n * (n + 1) / 2</code> numbers.</p>

<p><em>Return the sum of the numbers from index </em><code>left</code><em> to index </em><code>right</code> (<strong>indexed from 1</strong>)<em>, inclusive, in the new array. </em>Since the answer can be a huge number return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 1, right = 5
<strong>Output:</strong> 13 
<strong>Explanation:</strong> All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 3, right = 4
<strong>Output:</strong> 6
<strong>Explanation:</strong> The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 1, right = 10
<strong>Output:</strong> 50
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>1 &lt;= left &lt;= right &lt;= n * (n + 1) / 2</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem requires us to calculate all subarray sums of the given array, store the totals in a new array, sort this new array in non-decreasing order, and then sum the elements between the given <code>left</code> and <code>right</code> indices.</p>
<p>To achieve this, we'll create a new array called <code>storeSubarray</code> to store the sums of each subarray. Once we've iterated through the entire given array to calculate the subarray sums, we'll sort <code>storeSubarray</code> to be in non-decreasing order. Finally, we'll calculate and return the sum of the elements between the given <code>left</code> and <code>right</code> indices of <code>storeSubarray</code>, inclusive.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array given by <code>storeSubarray</code> to store all the subarray sums.</li>
<li>Iterate <code>i</code> through <code>nums</code>:</li>
</ol>
<ul>
<li>Initialize an integer <code>sum</code> with 0, to store the subarray sums starting at <code>i</code>.</li>
<li>Iterate <code>j</code> from <code>i</code> to the end of <code>nums</code>:
<ul>
<li>Increment <code>sum</code> with <code>nums[j]</code>.</li>
<li>Append <code>sum</code> to the <code>storeSubarray</code> array.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Sort <code>storeSubarray</code> in non-decreasing order.</li>
<li>Initialize <code>rangeSum</code> with 0 and mod with 1000000009.</li>
<li>Iterate all elements in <code>storeSubarray</code> between <code>left-1</code> and <code>right-1</code>:</li>
</ol>
<ul>
<li>Add the current value of <code>storeSubarray</code> to rangeSum and take its modulo with <code>mod</code>.</li>
</ul>
<ol start="6">
<li>Return <code>rangeSum</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ekg42VMR/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span></p>
<p>We iterate through <code>nums</code> twice to store all the subarray sums. This operation takes <span class="math inline">\(O(n^2)\)</span> time. Then, we sort this array storing all the subarray sums. The time complexity for this operation is <span class="math inline">\(O(n^2\cdot \log n)\)</span>. Iterating all indices between <code>left</code> and <code>right</code> also takes <span class="math inline">\(O(n^2)\)</span> time in the worst case.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We create a <code>storeSubarray</code> array with size proportional to <span class="math inline">\(O(n^2)\)</span>. Apart from this, no additional memory is used.</p>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can maintain the sorted order of subarray sums using a priority queue, which stores elements in a sorted order using a heap data structure. By inserting all the subarray sums into the priority queue, we ensure that the smallest sums are always easily accessible.</p>
<p>Inserting all subarray sums into the priority queue results in the same time and space complexity as the previous approach, but it's possible to refine this strategy to optimize space complexity.</p>
<p>In our first approach, we created an array to store all possible subarray sums. In this approach, we'll use the priority queue to store pairs. The first element of each pair will represent the sum of the current subarray and the second element will represent the end index of that subarray. We'll initialize the priority queue with pairs representing all one-sized subarrays.</p>
<p>As we process the queue, we repeatedly pop the smallest element, which represents the smallest subarray sum. However, this subarray could be part of a larger subarray. To account for this, we expand the subarray by one element (incrementing the end index), update its sum, and push the updated pair back into the priority queue.</p>
<p>Once we have performed exactly <code>left</code> pop operations, we start accumulating the subarray sums. The process continues until we reach the <code>right</code> pop operation, at which point we return the accumulated sum.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a priority queue <code>pq</code> of pairs, where each pair contains:</p>
<ul>
<li>The value of the current sum of subarray.</li>
<li>The ending index of that subarray.</li>
</ul>
</li>
<li>
<p>The priority queue is ordered by the smallest sums first.</p>
</li>
<li>
<p>Populate the priority queue with the initial values:</p>
<ul>
<li>Iterate through the first <code>n</code> elements of <code>nums</code> and push pairs of each element and its index into the priority queue.</li>
</ul>
</li>
<li>
<p>Initialize <code>ans</code> to 0 to store the result and <code>mod</code> to (10^9 + 7) for the modulo operation.</p>
</li>
<li>
<p>Iterate from <code>1</code> to <code>right</code>:</p>
<ul>
<li>Extract the smallest sum from the priority queue (top of the queue).</li>
<li>If the current index <code>i</code> is greater than or equal to <code>left</code>, add the value of the current pair to <code>ans</code>, taking modulo <code>mod</code> to avoid overflow.</li>
<li>If the index of the extracted pair is less than the last index (<code>n-1</code>):
<ul>
<li>Increment the index.</li>
<li>Update the pair's value by adding the next element to the array <code>nums</code>.</li>
<li>Push the updated pair back into the priority queue.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>ans</code> as a result.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/deXYG3zj/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span></p>
<p>We iterate through <code>nums</code> once to store all the one-sized subarray sums. This operation takes <span class="math inline">\(O(n)\)</span> time. Then, we iterate all indices between <code>left</code> and <code>right</code>, performing pop operation in each iteration, which takes <span class="math inline">\(O(n^2 \cdot \log n)\)</span> time total in the worst case.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n^2\cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The size of <code>pq</code> never exceeds <code>n</code>. Apart from this, no additional memory is used.</p>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-binary-search-and-sliding-window">Approach 3: Binary Search and Sliding Window</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Can we use binary search to solve this problem? We can apply binary search if the search space is sorted. Here, our search space can be defined as the sum of the first <code>k</code> smallest subarray sums. To find the sum of all subarrays in this range, we calculate the difference between this sum at <code>right</code> and <code>left-1</code>.</p>
<p>We will create a binary search function that calculates the sum of the first <code>k</code> smallest subarray sums. The minimum and maximum possible values for this search space are the minimum array value and the total sum of the array, respectively. In our binary search function, for a particular <code>mid</code> value, we calculate the number of subarrays with a sum less than or equal to <code>mid</code>. If this count is greater than <code>k</code>, we need to search in the left part of the search space. Conversely, if it is less than <code>k</code>, we move to the right side.</p>
<p>To find the number of subarrays with a sum less than or equal to <code>mid</code>, we use the sliding window approach. We initialize two pointers, <code>left</code> and <code>right</code>, representing the ends of the window. If the sum of the window exceeds <code>mid</code>, we decrease the size of the window from the left side. We increment the count of windows for every valid <code>left</code> and <code>right</code> pair.</p>
<p>While counting subarrays, we also need to calculate their sum. To do this, we can determine the number of windows an element is part of by calculating <code>right - left + 1</code>. We then multiply the current element by this number and add it to a sum variable. This sum is maintained along with the count in the binary search process.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p><strong>Main function - <code>rangeSum(nums,n,left,right)</code></strong></p>
<ol>
<li>Calculate <code>result</code> as the difference of <code>sumOfFirstK(nums,n,right) - sumOfFirstK(nums,n,left-1)</code>. Return this <code>result</code> after taking modulo with <code>mod</code>.</li>
</ol>
<p><strong><code>sumOfFirstK(nums,n,k)</code></strong></p>
<ol>
<li>Initialize <code>minSum</code> and <code>maxSum</code> with minimum element value in <code>nums</code> and the total sum of <code>nums</code>, respectively.</li>
<li>Initialize <code>left</code> with <code>minSum</code> and <code>right</code> with <code>maxSum</code>.</li>
<li>Iterate while <code>left &lt;= right</code>:
<ul>
<li>Initialize <code>mid</code> as the mean of <code>left</code> and <code>right</code>.</li>
<li>If <code>countAndSum(nums,n,mid)</code>'s count value is greater than or equal to <code>k</code>:
<ul>
<li>Set <code>right</code> as <code>mid - 1</code>.</li>
</ul>
</li>
<li>Otherwise, set <code>left</code> as <code>mid + 1</code>.</li>
</ul>
</li>
<li>Return the difference of <code>sum</code> and <code>left * (count - k)</code>, where <code>count</code> is the calculated count value.</li>
</ol>
<p><strong><code>countAndSum(nums,n,target)</code></strong></p>
<ol>
<li>Initialize <code>count = 0</code>, <code>currentSum = 0</code>, <code>totalSum = 0</code> and <code>windowSum = 0</code>.</li>
<li>Iterate through <code>nums</code> while <code>j &lt; n</code> and initialize <code>j</code> and <code>i</code> with 0:
<ul>
<li>Add <code>nums[j]</code> to <code>currentSum</code>.</li>
<li>Add <code>nums[j]*(j-i+1)</code> to <code>windowSum</code>.</li>
<li>While <code>currentSum</code> &gt; <code>target</code>:
<ul>
<li>Decrement <code>currentSum</code> from <code>windowSum</code>.</li>
<li>Decrement <code>nums[i]</code> from <code>currentSum</code> and increment <code>i</code>.</li>
</ul>
</li>
<li>Add <code>j-i+1</code> to <code>count</code>.</li>
<li>Add <code>windowSum</code> to <code>totalCount</code>.</li>
</ul>
</li>
<li>Return <code>{count,totalSum}</code>.</li>
</ol>
<p>!?!../Documents/1508/slideshow1.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/SER6g6tf/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size and <code>sum</code> be the total sum of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log sum)\)</span></p>
<p>The total size of the search space is <span class="math inline">\(O(sum)\)</span>. Therefore, time complexity for binary search is <span class="math inline">\(O(\log sum)\)</span>. Inside each binary search operation, the <code>countAndSum</code> function takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log sum)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Apart from some constant sized variables, no additional memory is used. Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-238">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reach-a-number/description" target="_blank" rel="noopener noreferrer">Reach a Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are standing at position <code>0</code> on an infinite number line. There is a destination at position <code>target</code>.</p>

<p>You can make some number of moves <code>numMoves</code> so that:</p>

<ul>
	<li>On each move, you can either go left or right.</li>
	<li>During the <code>i<sup>th</sup></code> move (starting from <code>i == 1</code> to <code>i == numMoves</code>), you take <code>i</code> steps in the chosen direction.</li>
</ul>

<p>Given the integer <code>target</code>, return <em>the <strong>minimum</strong> number of moves required (i.e., the minimum </em><code>numMoves</code><em>) to reach the destination</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong>
On the 1<sup>st</sup> move, we step from 0 to 1 (1 step).
On the 2<sup>nd</sup> move, we step from 1 to -1 (2 steps).
On the 3<sup>rd</sup> move, we step from -1 to 2 (3 steps).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong>
On the 1<sup>st</sup> move, we step from 0 to 1 (1 step).
On the 2<sup>nd</sup> move, we step from 1 to 3 (2 steps).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
	<li><code>target != 0</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-mathematical-accepted">Approach #1: Mathematical [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>The crux of the problem is to put <code>+</code> and <code>-</code> signs on the numbers <code>1, 2, 3, ..., k</code> so that the sum is <code>target</code>.</p>
<p>When <code>target &lt; 0</code> and we made a sum of <code>target</code>, we could switch the signs of all the numbers so that it equals <code>Math.abs(target)</code>.  Thus, the answer for <code>target</code> is the same as <code>Math.abs(target)</code>, and so without loss of generality, we can consider only <code>target &gt; 0</code>.</p>
<p>Now let's say <code>k</code> is the smallest number with <code>S = 1 + 2 + ... + k &gt;= target</code>.  If <code>S == target</code>, the answer is clearly <code>k</code>.</p>
<p>If <code>S &gt; target</code>, we need to change some number signs.  If <code>delta = S - target</code> is even, then we can always find a subset of <code>{1, 2, ..., k}</code> equal to <code>delta / 2</code> and switch the signs, so the answer is <code>k</code>.  (This depends on <code>T = delta / 2</code> being at most <code>S</code>.)  [The proof is simple: either <code>T &lt;= k</code> and we choose it, or we choose <code>k</code> in our subset and try to solve the same instance of the problem for <code>T -= k</code> and the set <code>{1, 2, ..., k-1}</code>.]</p>
<p>Otherwise, if <code>delta</code> is odd, we can't do it, as every sign change from positive to negative changes the sum by an even number.  So let's consider a candidate answer of <code>k+1</code>, which changes <code>delta</code> by <code>k+1</code>.  If this is odd, then <code>delta</code> will be even and we can have an answer of <code>k+1</code>.  Otherwise, <code>delta</code> will be odd, and we will have an answer of <code>k+2</code>.</p>
<p>For concrete examples of the above four cases, consider the following:</p>
<ul>
<li>If <code>target = 3</code>, then <code>k = 2, delta = 0</code> and the answer is <code>k = 2</code>.</li>
<li>If <code>target = 4</code>, then <code>k = 3, delta = 2</code>, delta is even and the answer is <code>k = 3</code>.</li>
<li>If <code>target = 7</code>, then <code>k = 4, delta = 3</code>, delta is odd and adding <code>k+1</code> makes delta even.  The answer is <code>k+1 = 5</code>.</li>
<li>If <code>target = 5</code>, then <code>k = 3, delta = 1</code>, delta is odd and adding <code>k+1</code> keeps delta odd.  The answer is <code>k+2 = 5</code>.</li>
</ul>
<p><strong>Algorithm</strong></p>
<p>Subtract <code>++k</code> from <code>target</code> until it goes non-positive.  Then <code>k</code> will be as described, and <code>target</code> will be <code>delta</code> as described.  We can output the four cases above: if <code>delta</code> is even then the answer is <code>k</code>, if <code>delta</code> is odd then the answer is <code>k+1</code> or <code>k+2</code> depending on the parity of <code>k</code>.</p>
<p><a href="https://leetcode.com/playground/nU7Cno4m/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(\sqrt{\text{target}})\)</span>.  Our while loop needs this many steps, as <span class="math inline">\(1 + 2 + \dots + k = \frac{k(k+1)}{2}\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-239">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-pairs/description" target="_blank" rel="noopener noreferrer">Reverse Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>the number of <strong>reverse pairs</strong> in the array</em>.</p>

<p>A <strong>reverse pair</strong> is a pair <code>(i, j)</code> where:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; nums.length</code> and</li>
	<li><code>nums[i] &gt; 2 * nums[j]</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,2,3,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The reverse pairs are:
(1, 4) --&gt; nums[1] = 3, nums[4] = 1, 3 &gt; 2 * 1
(3, 4) --&gt; nums[3] = 3, nums[4] = 1, 3 &gt; 2 * 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,3,5,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The reverse pairs are:
(1, 4) --&gt; nums[1] = 4, nums[4] = 1, 4 &gt; 2 * 1
(2, 4) --&gt; nums[2] = 3, nums[4] = 1, 3 &gt; 2 * 1
(3, 4) --&gt; nums[3] = 5, nums[4] = 1, 5 &gt; 2 * 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-240">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/row-with-max-1s--162208/1" target="_blank" rel="noopener noreferrer">Row with Max 1s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a 2D&nbsp;</span><span style="font-size: 18px;">binary matrix</span><strong style="font-size: 18px;">&nbsp;mat[][] </strong><span style="font-size: 18px;"><span style="font-size: 18px;">of size n x m,&nbsp;where each row contains only 0s and 1s, and each row is sorted in </span><strong style="font-size: 18px;">non-decreasing</strong><span style="font-size: 18px;"> order (all the 0s come before any 1s).</span><br /><span style="font-size: 18px;">Find the <strong>index </strong>of the <strong>row </strong>that contains the highest number of <strong>1s</strong>.</span></span></p>
<p><strong style="font-size: 18px;">Note:&nbsp;</strong><span style="font-size: 18px;">If multiple rows have the same maximum count of 1s, return the row with the smallest index.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[0, 0, 1, 1],<br />                [0, 1, 1, 1],<br />                [0, 0, 0, 1]]
<strong>Output: </strong>1
<strong>Explanation: </strong>Row at index 1 has three 1s, which is the highest among all rows.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[1, 1, 1],<br />                [0, 1, 1],<br />                [1, 1, 1]]
<strong>Output: </strong>0
<strong>Explanation: </strong>The first row (index 0) and the last row (index 2) both contain three 1s, which is the maximum among all rows. Since we return the smallest index in case of a tie, the answer is 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 1000<br /></span><span style="font-size: 18px;">0 &le; mat[i][j] &le; 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-241">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/russian-doll-envelopes/description" target="_blank" rel="noopener noreferrer">Russian Doll Envelopes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D array of integers <code>envelopes</code> where <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> represents the width and the height of an envelope.</p>

<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&#39;s width and height.</p>

<p>Return <em>the maximum number of envelopes you can Russian doll (i.e., put one inside the other)</em>.</p>

<p><strong>Note:</strong> You cannot rotate an envelope.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> envelopes = [[5,4],[6,4],[6,7],[2,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> envelopes = [[1,1],[1,1],[1,1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= envelopes.length &lt;= 10<sup>5</sup></code></li>
	<li><code>envelopes[i].length == 2</code></li>
	<li><code>1 &lt;= w<sub>i</sub>, h<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-242">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-a-2d-matrix/description" target="_blank" rel="noopener noreferrer">Search a 2D Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>

<ul>
	<li>Each row is sorted in non-decreasing order.</li>
	<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>

<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>

<p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-243">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-a-2d-matrix-ii/description" target="_blank" rel="noopener noreferrer">Search a 2D Matrix II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>

<ul>
	<li>Integers in each row are sorted in ascending from left to right.</li>
	<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 300</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>
	<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>
	<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>
	<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-244">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-an-almost-sorted-array/1" target="_blank" rel="noopener noreferrer">Search in an almost Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a sorted integer array&nbsp;<strong>arr[] </strong>consisting of <strong>distinct </strong>elements, where some elements of the array are moved to either of the adjacent positions, i.e. <strong>arr[i] </strong>may be present at <strong>arr[i-1] </strong>or <strong>arr[i+1]</strong>.<br />Given an integer&nbsp;<strong>target. &nbsp;</strong>You have to <strong>return</strong> the <strong>index </strong>( 0-based ) of the target in the array. If target is not present return <strong>-1.</strong><br /></span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [10, 3, 40, 20, 50, 80, 70], target = 40<br /><strong>Output: </strong>2<br /><strong>Explanation: </strong>Index of 40 in the given array is 2.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr[] = [10, 3, 40, 20, 50, 80, 70], target = 90<br /><strong>Output: </strong>-1<br /><strong>Explanation: </strong>90 is not present in the array.<br /></span></pre>
<pre><strong><span style="font-size: 14pt;">Input:</span></strong><span style="font-size: 14pt;"> arr[] = [-20], target = -20<br /><strong>Output: </strong>0<br /><strong>Explanation: </strong>-20 is the only element present in the array.</span></pre>
<p><span style="font-size: 14pt;"><strong><span style="font-size: large;">Constraints:</span><br /></strong><span style="font-size: large;">1 &lt;= arr.size() &lt;= 10</span><sup>5</sup></span><br /><span style="font-size: 14pt;">-10<sup>9</sup> &lt;= arr[i] &lt;= 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-245">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-a-row-wise-sorted-matrix/1" target="_blank" rel="noopener noreferrer">Search in a row-wise sorted matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a row-wise sorted 2D matrix <strong>mat</strong>[][] of size <strong>n x m&nbsp;</strong>and<strong>&nbsp;</strong>an integer <strong>x,</strong> find whether element <strong>x</strong> is present in the matrix.<br />Note: In a row-wise sorted matrix, each row is sorted in itself, i.e. for any i, j within bounds, mat[i][j] &lt;= mat[i][j+1].</span><br style="font-size: 18px;" /><br /><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[3, 4, 9],[2, 5, 6],[9, 25, 27]], x = 9
<strong>Output</strong>: true
<strong>Explanation</strong>: 9 is present in the matrix, so the output is true.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[19, 22, 27, 38, 55, 67]], x = 56<br /><strong>Output</strong>: false
<strong>Explanation</strong>: 56 is not present in the matrix, so the output is false.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 2, 9],[65, 69, 75]], x = 91</span><br /><span style="font-size: 14pt;"><strong>Output</strong>: false
<strong>Explanation</strong>: 91 is not present in the matrix.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &lt;= n, m &lt;= 1000<br />1 &lt;= mat[i][j] &lt;= 10<sup>5</sup><br />1 &lt;= x &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-246">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-fully-rotated-sorted-2d-matrix/1" target="_blank" rel="noopener noreferrer">Search in fully rotated sorted 2D matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p class="MsoNormal"><span style="font-size: 14pt;">You are given a 2D matrix <strong>mat[][] </strong>of size n x m that was initially filled in the following manner:</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<ul style="margin-top: 0cm;" type="disc">
<li class="MsoNormal" style="mso-list: l0 level1 lfo1; tab-stops: list 36.0pt;"><span style="font-size: 14pt;">Each row is sorted in increasing order from left to right.</span></li>
<li class="MsoNormal" style="mso-list: l0 level1 lfo1; tab-stops: list 36.0pt;"><span style="font-size: 14pt;">The first element of every row is greater than the last element of the previous row.</span></li>
</ul>
<p><span style="font-size: 14pt;"> </span></p>
<p class="MsoNormal"><span style="font-size: 14pt;">This implies that if the matrix is flattened row-wise, it forms a strictly sorted 1D array.<br />Later, this sorted 1D array was rotated at some unknown pivot. The rotated array was then written back into the matrix row-wise to form the current matrix.</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<p class="MsoNormal"><span style="font-size: 14pt;">Given such a matrix <strong>mat[][]</strong> and an integer <strong>x</strong>, determine whether x exists in the matrix.</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<p class="MsoNormal"><span style="font-size: 14pt;"><strong><span style="mso-ansi-language: EN-IN;">Examples:<br /></span></strong></span></p>
<pre class="MsoNormal"><span style="font-size: 14pt;"><span style="mso-ansi-language: EN-IN;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">x = 3,</span><strong style="font-size: 14pt;"><br /></strong><span style="font-size: 14pt;">mat[][] = </span><span style="font-size: 18.6667px;">[[7, 8, 9, 10],           
          [11, 12, 13, 1],
          [2, 3, 4, 5]] </span><strong style="font-size: 14pt;"><br />Output: </strong><span style="font-size: 14pt;">true</span><strong style="font-size: 14pt;"><br />Explanation: </strong></span></span><span style="font-size: 18.6667px;">3 is located at the 3rd row and 2nd column.</span></pre>
<pre><span style="font-size: 14pt;"><span style="mso-ansi-language: EN-IN;"><strong style="font-size: 14pt;">Input:</strong><span style="font-size: 14pt;"> x = 10,</span><strong style="font-size: 14pt;"><br /></strong><span style="font-size: 18.6667px;">mat[][] <strong>= </strong>[[6, 7, 8],                         
          [9, 1, 2],
          [3, 4, 5]]</span><strong style="font-size: 14pt;"><br />Output: </strong><span style="font-size: 14pt;">false</span><strong style="font-size: 14pt;"><br />Explanation: </strong></span></span><span style="font-size: 18.6667px;">The value 10 does not exist in the matrix.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Constraint:<br /></span></strong><span style="font-size: 18.6667px;">1 &le; n &times; m &le; 10<sup>5</sup><br /></span><span style="font-size: 18.6667px;">1 &le; mat[i][j], x &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-247">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-in-rotated-sorted-array/description" target="_blank" rel="noopener noreferrer">Search in Rotated Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>

<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly left rotated</strong> at an unknown index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be left rotated by&nbsp;<code>3</code>&nbsp;indices and become <code>[4,5,6,7,0,1,2]</code>.</p>

<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>

<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0
<strong>Output:</strong> 4
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3
<strong>Output:</strong> -1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [1], target = 0
<strong>Output:</strong> -1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li>All values of <code>nums</code> are <strong>unique</strong>.</li>
	<li><code>nums</code> is an ascending array that is possibly rotated.</li>
	<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-248">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-in-rotated-sorted-array-ii/description" target="_blank" rel="noopener noreferrer">Search in Rotated Sorted Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong> values).</p>

<p>Before being passed to your function, <code>nums</code> is <strong>rotated</strong> at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.</p>

<p>Given the array <code>nums</code> <strong>after</strong> the rotation and an integer <code>target</code>, return <code>true</code><em> if </em><code>target</code><em> is in </em><code>nums</code><em>, or </em><code>false</code><em> if it is not in </em><code>nums</code><em>.</em></p>

<p>You must decrease the overall operation steps as much as possible.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 0
<strong>Output:</strong> true
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 3
<strong>Output:</strong> false
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> is guaranteed to be rotated at some pivot.</li>
	<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href="/problems/search-in-rotated-sorted-array/description/" target="_blank">Search in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-249">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-insert-position/description" target="_blank" rel="noopener noreferrer">Search Insert Position</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,6], target = 5
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,6], target = 2
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,6], target = 7
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> contains <strong>distinct</strong> values sorted in <strong>ascending</strong> order.</li>
	<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-250">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-suggestions-system/description" target="_blank" rel="noopener noreferrer">Search Suggestions System</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.</p>

<p>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums products.</p>

<p>Return <em>a list of lists of the suggested products after each character of </em><code>searchWord</code><em> is typed</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;
<strong>Output:</strong> [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]]
<strong>Explanation:</strong> products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;].
After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;].
After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> products = [&quot;havana&quot;], searchWord = &quot;havana&quot;
<strong>Output:</strong> [[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]]
<strong>Explanation:</strong> The only word &quot;havana&quot; will be always suggested while typing the search word.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= products.length &lt;= 1000</code></li>
	<li><code>1 &lt;= products[i].length &lt;= 3000</code></li>
	<li><code>1 &lt;= sum(products[i].length) &lt;= 2 * 10<sup>4</sup></code></li>
	<li>All the strings of <code>products</code> are <strong>unique</strong>.</li>
	<li><code>products[i]</code> consists of lowercase English letters.</li>
	<li><code>1 &lt;= searchWord.length &lt;= 1000</code></li>
	<li><code>searchWord</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>Since the question asks for the result in a sorted order, let's start with sorting <code>products</code>.<br />
An advantage that comes with sorting is <code>Binary Search</code>, we can binary search for the prefix. Once we locate the first match of prefix, all we need to do is to add the next 3 words into the result (if there are any), since we sorted the words beforehand.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort the input <code>products</code>.</li>
<li>Iterate each character of the <code>searchWord</code> adding it to the <code>prefix</code> to search for.</li>
<li>After adding the current character to the <code>prefix</code> binary search for the <code>prefix</code> in the input.</li>
<li>Add next 3 strings from the current binary search <code>start</code> index till the prefix remains same.</li>
<li>Another optimization that can be done is reducing the binary search space to current <code>start</code> index (This is due to the fact that adding more characters to the prefix will make the next search result's index be at least &gt; current search's index).</li>
</ol>
<p><a href="https://leetcode.com/playground/NCPdFYJE/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(nlog(n)) + O(mlog(n))\)</span>. Where <code>n</code> is the length of <code>products</code> and <code>m</code> is the length of the search word. Here we treat string comparison in sorting as  <span class="math inline">\(O(1)\)</span>.  <span class="math inline">\(O(nlog(n))\)</span> comes from the sorting and <span class="math inline">\(O(mlog(n))\)</span> comes from running <code>binary search</code> on products <code>m</code> times.</p>
<ul>
<li>In Java there is an additional complexity of <span class="math inline">\(O(m^2)\)</span> due to Strings being immutable, here <code>m</code> is the length of <code>searchWord</code>.</li>
</ul>
</li>
<li>
<p>Space complexity : Varies between <span class="math inline">\(O(1)\)</span> and <span class="math inline">\(O(n)\)</span> where <code>n</code> is the length of <code>products</code>, as it depends on the implementation used for sorting. We ignore the space required for output as it does not affect the algorithm's space complexity. See <a href="https://www.geeksforgeeks.org/internal-details-of-stdsort-in-c/">Internal details of std::sort</a>.<br />
Space required for output is <span class="math inline">\(O(m)\)</span> where <code>m</code> is the length of the search word.</p>
</li>
</ul>
<br />
<hr />
<h3 id="approach-2-trie--dfs">Approach 2: Trie + DFS</h3>
<p><strong>Intuition</strong></p>
<p>Whenever we come across questions with multiple strings, it is best to think if <a href="https://en.wikipedia.org/wiki/Trie">Trie</a> can help us. What we need here is a way to search for all the words with given prefix, this is a well known problem that trie can solve. The question also asks for a sorted results, if you look closely a trie word is represented by it's preorder traversal. It is also worth noting that a preorder traversal of a trie will always result in a sorted traversal of results, thus all we need to do is limit the word traversal to 3.</p>
<p>Questions using Trie:</p>
<p><a href="https://leetcode.com/problems/word-search">79. Word Search</a></p>
<p><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure">211. Design Add and Search Words Data Structure</a></p>
<p><img src="../Figures/1268/Trie.png" alt="diff" /><br />
<em>Figure 1. A trie made from <code>words</code></em></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a Trie from the given products input.</li>
<li>Iterate each character of the <code>searchWord</code> adding it to the <code>prefix</code> to search for.</li>
<li>After adding the current character to the <code>prefix</code> traverse the <code>trie</code> pointer to the node representing <code>prefix</code>.</li>
<li>Now traverse the tree from <code>curr</code> pointer in a preorder fashion and record whenever we encounter a complete word.</li>
<li>Limit the result to 3 and return <code>dfs</code> once reached this limit.</li>
<li>Add the words to the final result.</li>
</ol>
<p><a href="https://leetcode.com/playground/RSAV9EQc/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(M)\)</span> to build the <code>trie</code> where <code>M</code> is total number of characters in <code>products</code> For each <code>prefix</code> we find its representative node in <span class="math inline">\(O(\text{len(prefix)})\)</span> and dfs to find at most 3 words which is an <code>O(1)</code> operation. Thus the overall complexity is dominated by the time required to build the <code>trie</code>.</p>
<ul>
<li>In Java there is an additional complexity of <span class="math inline">\(O(m^2)\)</span> due to Strings being immutable, here <code>m</code> is the length of <code>searchWord</code>.</li>
</ul>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(26n)=O(n)\)</span>. Here <code>n</code> is the number of nodes in the <code>trie</code>. <code>26</code> is the alphabet size.<br />
Space required for output is <span class="math inline">\(O(m)\)</span> where <code>m</code> is the length of the search word.</p>
</li>
</ul>
</br></div>
				</div>
		</div>

<div class="question-card" id="question-251">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sell-diminishing-valued-colored-balls/description" target="_blank" rel="noopener noreferrer">Sell Diminishing-Valued Colored Balls</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have an <code>inventory</code> of different colored balls, and there is a customer that wants <code>orders</code> balls of <strong>any</strong> color.</p>

<p>The customer weirdly values the colored balls. Each colored ball&#39;s value is the number of balls <strong>of that color&nbsp;</strong>you currently have in your <code>inventory</code>. For example, if you own <code>6</code> yellow balls, the customer would pay <code>6</code> for the first yellow ball. After the transaction, there are only <code>5</code> yellow balls left, so the next yellow ball is then valued at <code>5</code> (i.e., the value of the balls decreases as you sell more to the customer).</p>

<p>You are given an integer array, <code>inventory</code>, where <code>inventory[i]</code> represents the number of balls of the <code>i<sup>th</sup></code> color that you initially own. You are also given an integer <code>orders</code>, which represents the total number of balls that the customer wants. You can sell the balls <strong>in any order</strong>.</p>

<p>Return <em>the <strong>maximum</strong> total value that you can attain after selling </em><code>orders</code><em> colored balls</em>. As the answer may be too large, return it <strong>modulo </strong><code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/jj.gif" style="width: 480px; height: 270px;" />
<pre>
<strong>Input:</strong> inventory = [2,5], orders = 4
<strong>Output:</strong> 14
<strong>Explanation:</strong> Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).
The maximum total value is 2 + 5 + 4 + 3 = 14.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> inventory = [3,5], orders = 6
<strong>Output:</strong> 19
<strong>Explanation: </strong>Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).
The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= inventory.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= inventory[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= orders &lt;= min(sum(inventory[i]), 10<sup>9</sup>)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-252">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/separate-squares-i/description" target="_blank" rel="noopener noreferrer">Separate Squares I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>squares</code>. Each <code>squares[i] = [x<sub>i</sub>, y<sub>i</sub>, l<sub>i</sub>]</code> represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.</p>

<p>Find the <strong>minimum</strong> y-coordinate value of a horizontal line such that the total area of the squares above the line <em>equals</em> the total area of the squares below the line.</p>

<p>Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>

<p><strong>Note</strong>: Squares <strong>may</strong> overlap. Overlapping areas should be counted <strong>multiple times</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">squares = [[0,0,1],[2,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1.00000</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/06/4062example1drawio.png" style="width: 378px; height: 352px;" /></p>

<p>Any horizontal line between <code>y = 1</code> and <code>y = 2</code> will have 1 square unit above it and 1 square unit below it. The lowest option is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">squares = [[0,0,2],[1,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1.16667</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/15/4062example2drawio.png" style="width: 378px; height: 352px;" /></p>

<p>The areas are:</p>

<ul>
	<li>Below the line: <code>7/6 * 2 (Red) + 1/6 (Blue) = 15/6 = 2.5</code>.</li>
	<li>Above the line: <code>5/6 * 2 (Red) + 5/6 (Blue) = 15/6 = 2.5</code>.</li>
</ul>

<p>Since the areas above and below the line are equal, the output is <code>7/6 = 1.16667</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= squares.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>squares[i] = [x<sub>i</sub>, y<sub>i</sub>, l<sub>i</sub>]</code></li>
	<li><code>squares[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= l<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li>The total area of all the squares will not exceed <code>10<sup>12</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-253">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/separate-squares-ii/description" target="_blank" rel="noopener noreferrer">Separate Squares II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">line sweep</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>squares</code>. Each <code>squares[i] = [x<sub>i</sub>, y<sub>i</sub>, l<sub>i</sub>]</code> represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.</p>

<p>Find the <strong>minimum</strong> y-coordinate value of a horizontal line such that the total area covered by squares above the line <em>equals</em> the total area covered by squares below the line.</p>

<p>Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>

<p><strong>Note</strong>: Squares <strong>may</strong> overlap. Overlapping areas should be counted <strong>only once</strong> in this version.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">squares = [[0,0,1],[2,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1.00000</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/15/4065example1drawio.png" style="width: 269px; height: 203px;" /></p>

<p>Any horizontal line between <code>y = 1</code> and <code>y = 2</code> results in an equal split, with 1 square unit above and 1 square unit below. The minimum y-value is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">squares = [[0,0,2],[1,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1.00000</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/15/4065example2drawio.png" style="width: 269px; height: 203px;" /></p>

<p>Since the blue square overlaps with the red square, it will not be counted again. Thus, the line <code>y = 1</code> splits the squares into two equal parts.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= squares.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>squares[i] = [x<sub>i</sub>, y<sub>i</sub>, l<sub>i</sub>]</code></li>
	<li><code>squares[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= l<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li>The total area of all the squares will not exceed <code>10<sup>15</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-254">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-matching-substring/description" target="_blank" rel="noopener noreferrer">Shortest Matching Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a pattern string <code>p</code>, where <code>p</code> contains <strong>exactly two</strong> <code>&#39;*&#39;</code> characters.</p>

<p>The <code>&#39;*&#39;</code> in <code>p</code> matches any sequence of zero or more characters.</p>

<p>Return the length of the <strong>shortest</strong> <span data-keyword="substring">substring</span> in <code>s</code> that matches <code>p</code>. If there is no such substring, return -1.</p>
<strong>Note:</strong> The empty substring is considered valid.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abaacbaecebce&quot;, p = &quot;ba*c*ce&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p>The shortest matching substring of <code>p</code> in <code>s</code> is <code>&quot;<u><strong>ba</strong></u>e<u><strong>c</strong></u>eb<u><strong>ce</strong></u>&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;baccbaadbc&quot;, p = &quot;cc*baa*adb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no matching substring in <code>s</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;a&quot;, p = &quot;**&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The empty substring is the shortest matching substring.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;madlogic&quot;, p = &quot;*adlogi*&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The shortest matching substring of <code>p</code> in <code>s</code> is <code>&quot;<strong><u>adlogi</u></strong>&quot;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= p.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
	<li><code>p</code> contains only lowercase English letters and exactly two <code>&#39;*&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-255">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description" target="_blank" rel="noopener noreferrer">Shortest Subarray to be Removed to Make Array Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>arr</code>, remove a subarray (can be empty) from <code>arr</code> such that the remaining elements in <code>arr</code> are <strong>non-decreasing</strong>.</p>

<p>Return <em>the length of the shortest subarray to remove</em>.</p>

<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,10,4,2,3,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,4,3,2,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The array is already non-decreasing. We do not need to remove any elements.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an array <code>arr</code>, we want to return the size of the smallest possible subarray we can remove to make the remaining elements sorted in non-decreasing order. It's acceptable to return an empty subarray if the elements are already sorted correctly.</p>
<p><img src="../Figures/1574/shortest_subarray_to_be_removed.png" alt="Test cases split into 3 parts" /></p>
<p>We can think of <code>arr</code> as being composed of 3 parts. The first part is a block of numbers in sorted order (blue region in the image above), followed by a block of numbers that breaks the sorted order (yellow region), and then finally another block of numbers in sorted order (green region).</p>
<p>For the nontrivial cases depicted above, we know that the subarray to remove resides somewhere in the middle of the array. Here, there can be multiple possibilities for what the middle elements can be. For the first example in the image, one option is to remove the block <code>[2, 3, 10, 4]</code>, leaving the remaining sorted sequence <code>[1, 2, 3, 5]</code>. Another option is to remove the block <code>[10, 4, 2]</code>, leaving another valid sequence <code>[1, 2, 3, 3, 5]</code>. The question then boils down to how we can find the smallest middle block of numbers to remove.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find the shortest subarray that, if removed, would make the array sorted. To do this, we must understand the problem from a few perspectives and break it down logically.</p>
<h5 id="1-identifying-the-longest-non-decreasing-subarrays">1. Identifying the Longest Non-Decreasing Subarrays</h5>
<p>The first thing to consider is that the array might already be mostly sorted, but just have a small portion that disrupts the order. This means that if we could find the longest part of the array that is already non-decreasing from the left and from the right, we would be left with just a small part in the middle that needs to be removed to make the entire array sorted.</p>
<p>The concept is to iterate through the array, looking for the longest continuous subarray that follows the non-decreasing order. We start from the left and move right, stopping when we hit a decrease. This is the first natural choice because if we can identify the longest subarray from the left, we know the part from the right must complement it or be the part we need to focus on.</p>
<p>Similarly, we do the same thing from the right side. This parallelism helps us understand both ends of the array and figure out where the sorting breaks down. These steps build on each other, showing us the boundaries within which we need to find the subarray to remove.</p>
<h5 id="2-the-case-where-the-array-is-already-sorted">2. The Case Where the Array is Already Sorted</h5>
<p>Now that we know how to find the longest non-decreasing subarrays from both ends, we need to think about the case where the array is already sorted. In this case, there’s no need to remove anything. So, we check if the left and right pointers (or indices) overlap or meet. If they do, the entire array is already sorted, and our work is done. This is an important insight because it helps us immediately return 0 when there’s no need to remove any subarray, avoiding unnecessary work.</p>
<h5 id="3-the-core-problem-what-to-remove">3. The Core Problem: What to Remove?</h5>
<p>If the array is not sorted, we are left with the task of determining the shortest subarray that can be removed to make the array sorted. We could remove just the left part, just the right part, or try merging the two non-decreasing sections.</p>
<p>Now, this might seem a bit tricky at first, but if we look closely, we can use the fact that if a section on the left is non-decreasing and a section on the right is also non-decreasing, there may still be a possibility of merging these sections by removing the middle. The relationship between the two sections plays a critical role. Specifically, we want to find a point where elements in the right section are greater than or equal to elements in the left section after considering the removal of the middle portion.</p>
<h5 id="4-the-final-search">4. The Final Search</h5>
<p>This leads us to the next part on how do we efficiently find where the two sections can merge? A naive approach might involve checking all pairs of elements, but that could be inefficient. Instead, we use binary search to find the smallest index in the right part of the array where the element is greater than or equal to the last element of the left part. By doing this, we can quickly pinpoint where the array can be &quot;joined&quot; back together, minimizing the subarray to remove.</p>
<p>This binary search approach leverages the sorted nature of the two subarrays. Since we know both the left and right subarrays are sorted, binary search allows us to find this boundary in logarithmic time, which is much more efficient than checking each element.</p>
<p>Finally, the solution is to take the minimum length of the subarrays that can be removed, whether that’s the left part, the right part, or the middle part (which we find through binary search).</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of <code>arr</code>, <code>left</code> as 0, and <code>right</code> as <code>n - 1</code>.</p>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the left:</p>
<ul>
<li>While <code>left + 1 &lt; n</code> and <code>arr[left] &lt;= arr[left + 1]</code>, increment <code>left</code> to expand the left subarray.</li>
</ul>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the right:</p>
<ul>
<li>While <code>right - 1 &gt;= 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code> to expand the right subarray.</li>
</ul>
</li>
<li>
<p>If the entire array is already sorted (i.e., <code>left &gt;= right</code>), return <code>0</code> as no subarray removal is needed.</p>
</li>
<li>
<p>Initialize <code>ans</code> to the smaller of removing the left or right part completely:</p>
<ul>
<li><code>ans = min(n - (left + 1), right)</code></li>
</ul>
</li>
<li>
<p>Try to merge the left and right parts:</p>
<ul>
<li>For each index <code>i</code> from 0 to <code>left</code>, use binary search (<code>helperBinarySearch</code>) to find the smallest index <code>j</code> where <code>arr[j] &gt;= arr[i]</code>.</li>
<li>Update <code>ans</code> as the minimum of <code>ans</code> and the difference <code>j - (i + 1)</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>, the length of the shortest subarray that can be removed to make the array sorted.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/haaC2UUS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>The first two <code>while</code> loops each run in <span class="math inline">\(O(N)\)</span> time to find the longest non-decreasing subarrays from the left and right.</p>
<p>After that, the <code>for</code> loop iterates up to <code>N</code> times, where for each iteration, a binary search is performed. Since binary search runs in <span class="math inline">\(O(\log N)\)</span> time, the total time complexity for the loop is <span class="math inline">\(O(N \log N)\)</span>.</p>
<p>Therefore, the overall time complexity is dominated by the <span class="math inline">\(O(N \log N)\)</span> component.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is mainly determined by the space required to store the input array <code>arr</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can optimize the solution further by replacing binary search (<span class="math inline">\(O(N \log N)\)</span>) with a more efficient two-pointer approach, reducing the complexity to <span class="math inline">\(O(N)\)</span>.</p>
<p>A key insight in the diagram below is that the unsorted yellow region must always be part of the removed subarray, as it breaks the sorted order. In other words, the remaining sorted array will always consist of a prefix of the blue subarray (from the first element up to some index), followed by a suffix of the green subarray (from the last element down to some index).</p>
<p><img src="../Figures/1574/two_pointers.png" alt="2 pointers" /></p>
<p>To consider all possibilities, use two pointers, <code>left</code> and <code>right</code>. The pointers represent the prefix blue array <code>arr[0:left]</code> and suffix green array <code>arr[right:]</code> consisting of the remaining sorted array we are considering. Initially, <code>left</code> is set to 0, meaning we’re considering keeping the first element of the blue array. <code>Right</code> is set to the index of the start of the green subarray, meaning we consider keeping the entirety of the green subarray.</p>
<p>Using this two-pointer method, for each position of <code>left</code>, we search for the smallest <code>right</code> where <code>arr[left] &lt;= arr[right]</code>. If this condition holds, then we have found a valid subarray candidate to remove—the subarray between <code>arr[left]</code> and <code>arr[right]</code>, which has a length of <code>right - left - 1</code>. If <code>arr[left] &gt; arr[right]</code>, we increment <code>right</code> to find the next possible match. Once a valid <code>right</code> is found, we advance <code>left</code> to the next element, repeating the process.</p>
<details>
  <summary>Why <code>arr[left] <= arr[right]</code> is Important (Click Here!)</summary>
  </br>
  <p><strong>Sorted Left Portion:</strong> The elements before left (i.e.,  <code>arr[0:left]</code>) are already sorted. Therefore,  <code>arr[left-1]</code> is the largest element in this prefix.</p>
  <p><strong>Sorted Right Portion:</strong> The elements from right onwards (i.e., <code>arr[right:]</code>) are sorted as well. Thus, <code>arr[right]</code> is the smallest element in the suffix.</p>
  <p>For the two sorted sections to form one valid sorted sequence when combined, we need the largest element in the left portion (<code>arr[left-1]</code>) to be less than or equal to the smallest element in the right portion (<code>arr[right]</code>), because:</p>
  <ul>
    <li>If <code>arr[left-1]</code> is greater than <code>arr[right]</code>, it means that after removing the unsorted middle section, the combined array would not be sorted.</li>
    <li>If <code>arr[left-1] <= arr[right]</code>, it guarantees that the largest element from the left side is smaller than or equal to the smallest element from the right side, ensuring the merged sequence is still sorted.</li>
  </ul>
</details>
</br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize our <code>right</code> pointer to the last index of <code>arr</code>.</li>
<li>We want to start our two-pointer process with <code>right</code> pointing to the start of the green sorted subarray. So we want to update <code>right</code> to the right index:
<ul>
<li>While <code>right &gt; 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code></li>
</ul>
</li>
<li>We initialize our <code>ans = right</code>. We note that the biggest subarray that can be removed is the entire subarray preceding <code>right</code>. Thus, the maximum size subarray to be removed is <code>right</code>.</li>
<li>We initialize our <code>left</code> pointer to <code>0</code>, the start of the blue sorted subarray.</li>
<li>While <code>left &lt; right</code> and <code>left</code> is still in the blue region: <code>left == 0 || arr[left - 1] &lt;= arr[left]</code>:
<ul>
<li>Find the right number after arr[left]:
<ul>
<li>While <code>right &lt; arr.length</code> and <code>arr[left] &gt; arr[right]</code>, increment <code>right</code></li>
</ul>
</li>
<li>Save length of the removed subarray: <code>ans = min(ans, right - left - 1)</code></li>
<li>Increment <code>left</code></li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QgsqkvCG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>In the worst case for our two pointer algorithm, <code>left</code> will traverse through the entire blue sorted region once, and <code>right</code> will traverse through the entire <code>green</code> sorted region once. Thus, the time complexity grows linearly with the size of <code>arr</code>: <span class="math inline">\(O(N)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use two pointers to store indices and do not have any auxiliary data structures, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-256">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description" target="_blank" rel="noopener noreferrer">Shortest Subarray with Sum at Least K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the length of the shortest non-empty <strong>subarray</strong> of </em><code>nums</code><em> with a sum of at least </em><code>k</code>. If there is no such <strong>subarray</strong>, return <code>-1</code>.</p>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1], k = 1
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [1,2], k = 4
<strong>Output:</strong> -1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [2,-1,2], k = 3
<strong>Output:</strong> 3
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>nums</code> that contains both positive and negative values, along with an integer <code>k</code>. Our goal is to find the shortest non-empty subarray whose sum is greater than or equal to <code>k</code>.</p>
<p>This problem is very similar to <a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/">209. Minimum Size Subarray Sum</a> with one key difference: we have negative values here. We strongly suggest solving the original problem first, as our solution will build upon that approach.</p>
<p>The original problem was solved using a variable-length sliding window, but that approach will no longer work here. Let's take an example to understand why:</p>
<p>Consider <code>nums = [2, -1, 1, 3]</code> and <code>k = 4</code>.</p>
<p>Let's walk through a naive variable-size sliding window approach step by step:</p>
<ol>
<li>Start with window <code>[2]</code>: sum = 2 (not <span class="math inline">\(\geq\)</span> 4)</li>
<li>Expand to <code>[2, -1]</code>: sum = 1 (not <span class="math inline">\(\geq\)</span> 4)</li>
<li>Expand to <code>[2, -1, 1]</code>: sum = 2 (not <span class="math inline">\(\geq\)</span> 4)</li>
<li>Expand to <code>[2, -1, 1, 3]</code>: sum = 5 (<span class="math inline">\(\geq\)</span> 4)</li>
</ol>
<p>Now, we try to minimize the window size by shrinking the window from the left.</p>
<ol>
<li>Remove the first element. Window: <code>[-1, 1, 3]</code>: sum = 3 (not <span class="math inline">\(\geq\)</span> 4)</li>
</ol>
<p>The sliding window now stops because it assumes reducing the window further would only decrease the sum value. However, if it shrinks once more:</p>
<ol start="2">
<li>Remove the second element. Window: <code>[1, 3]</code>: sum = 4 (<span class="math inline">\(\geq\)</span> 4)</li>
</ol>
<p>We find that our condition is satisfied again, and we find our required answer.</p>
<p>The negative value -1 breaks the monotonic sum property that a standard sliding window relies on, making a simple variable-length sliding window approach unreliable.</p>
<hr />
<h3 id="approach-1-priority-queue">Approach 1: Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force approach would be to loop over all subarrays in <code>nums</code> and check if their sums exceed <code>k</code>. The smallest one among them is our answer. However, this approach is too slow for our constraints.</p>
<p>Let's identify the redundancies in the above approach. One major issue is that we keep recalculating the same subarray sums multiple times. We can solve this by creating a prefix sum array, which lets us quickly find the sum of any subarray. Using this array, we can look at each element and find an earlier prefix sum that, when subtracted from our current sum, gives us a value of at least k.</p>
<p>However, searching for the best prefix sum for each index is still too slow. What we really need is a way to quickly find the &quot;best&quot; prefix sum – one with the lowest value that's also closest to our current position.</p>
<p>This is where a heap (also called a priority queue) becomes useful. We can store pairs of [prefix sum, ending index] in the heap, arranged so that the lowest sum is always at the top. This helps us quickly find the best previous sum to use.</p>
<p>Let's loop over the <code>nums</code> array now, keeping track of the running sum in a variable called <code>cumulativeSum</code>. We'll also keep track of our result in the variable <code>shortestSubarrayLength</code>. If the <code>cumulativeSum</code> meets our constraints, we consider it as a potential result. Otherwise, we'll loop over the top elements of the heap while the difference between <code>cumulativeSum</code> and the sum of the top element is <span class="math inline">\(\geq k\)</span>. For each such element, we check if it is the minimum length subarray we've found till now. After checking an element in the heap, it can be discarded since all further sums in the loop will result in longer subarrays (and can never be the answer). Once we've exhausted all valid previous prefix sums, we can add the current sum and the index to the heap.</p>
<p>After the loop completes, we can return <code>cumulativeSum</code> as the required shortest subarray with a sum of at least <code>k</code>.</p>
<p>The algorithm is visualized in the slideshow below:</p>
<p>!?!../Documents/862/slideshow.json:1202,962!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a variable:
<ul>
<li><code>n</code> to store the length of the input array.</li>
<li><code>shortestSubarrayLength</code> to store the minimum length of a valid subarray, setting it to the maximum possible integer value.</li>
<li><code>cumulativeSum</code> to 0, which will maintain the running sum of elements.</li>
</ul>
</li>
<li>Initialize a min-heap <code>prefixSumHeap</code> to store pairs of cumulative sum and their corresponding indices, with pairs ordered by cumulative sum.</li>
<li>Iterate through each index <code>i</code> from 0 to <code>n-1</code>:
<ul>
<li>Add the current element to <code>cumulativeSum</code>.</li>
<li>If <code>cumulativeSum</code> is greater than or equal to <code>k</code>:
<ul>
<li>Update <code>shortestSubarrayLength</code> with the minimum of itself and <code>i + 1</code>.</li>
</ul>
</li>
<li>While the heap is not empty and the difference between the current <code>cumulativeSum</code> and heap's minimum cumulative sum is greater than or equal to <code>k</code>:
<ul>
<li>Remove the minimum element from the heap and update <code>shortestSubarrayLength</code> with the minimum of itself and (current index - removed element's index)</li>
</ul>
</li>
<li>Add current <code>cumulativeSum</code> and index as a pair to the heap.</li>
</ul>
</li>
<li>Return -1 if <code>shortestSubarrayLength</code> remains unchanged at maximum integer value, otherwise return <code>shortestSubarrayLength</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VkJRKMc9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>For each element in <code>nums</code>, we may perform heap operations (push and poll) which take <span class="math inline">\(O(\log n)\)</span> time. In the worst case, at each index, we might need to poll multiple elements from the heap, but each element can only be pushed and popped once throughout the entire process. So, the total number of heap operations across all iterations is bounded by <span class="math inline">\(O(n)\)</span>, each taking <span class="math inline">\(O(\log n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space for the min-heap (<code>prefixSumHeap</code>) which, in the worst case, might need to store all prefix sums and their indices. As each element in the input array corresponds to at most one entry in the heap, the space required is linear with respect to the input size.</p>
<p>Thus, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-monotonic-stack--binary-search">Approach 2: Monotonic Stack + Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also implement this idea of using the &quot;best&quot; prefix sum efficiently using a binary search approach. Instead of a priority queue, let's maintain a stack-like data structure to hold the prefix sums for each index as we iterate over <code>nums</code>. Each element of the stack will hold a pair [prefix sum, index] where we'll maintain the prefix sum monotonically increasing. The monotonically increasing property works because at each step, all prefix sums which are valid candidates to be used to find the shortest sub-array, have to be less than the current running sum.</p>
<p>To make this work, we start by updating the running total for each number in the array. Then, to keep our structure ordered, we remove any entries from the top that are greater than or equal to the current sum. This approach ensures that both the prefix sums and their indices stay in strict increasing order. Once we have this ordering, we can use binary search to efficiently find the rightmost entry where the sum is at least <code>current_sum - k</code>. The difference between our current position and the index we find gives us the length of a valid sub-array. By keeping track of the shortest length we find, we’ll get our answer.</p>
<blockquote>
<p>Note: It's a bit unusual to perform searches within a stack, as we typically only access the top element in a true stack. So while our data structure isn't a classic stack, it behaves similarly to a monotonic stack in this case.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize:</p>
<ul>
<li>a variable <code>n</code> to store the length of the input array.</li>
<li>a list <code>cumulativeSumStack</code> to store pairs of cumulative sums and their corresponding indices, adding an initial pair (0, -1) to handle subarrays starting from index 0.</li>
<li>a variable <code>runningCumulativeSum</code> to 0 to maintain the running sum of elements.</li>
<li>a variable <code>shortestSubarrayLength</code> to store the minimum length of a valid subarray, setting it to the maximum possible integer value.</li>
</ul>
</li>
<li>
<p>Iterate through each index <code>i</code> from 0 to <code>n-1</code>:</p>
<ul>
<li>Add the current element to <code>runningCumulativeSum</code></li>
<li>While the stack is not empty and the current <code>runningCumulativeSum</code> is less than or equal to the last element's cumulative sum:
<ul>
<li>Remove the last element from the stack.</li>
</ul>
</li>
<li>Add current <code>runningCumulativeSum</code> and index as a pair to the stack.</li>
<li>Find the largest index where the cumulative sum is less than or equal to (<code>runningCumulativeSum - k</code>) using binary search</li>
<li>If a valid index is found, update <code>shortestSubarrayLength</code> with the minimum of itself and (current index - found index's value)</li>
</ul>
</li>
<li>
<p>Return -1 if <code>shortestSubarrayLength</code> remains unchanged at maximum integer value, otherwise return <code>shortestSubarrayLength</code>.</p>
</li>
<li>
<p>The binary search helper function:</p>
<ul>
<li>Initialize a left pointer to 0 and a right pointer to the last index.</li>
<li>While the left pointer is less than or equal to the right pointer:
<ul>
<li>Calculate the middle index.</li>
<li>If the middle element's cumulative sum is less than or equal to the target:
<ul>
<li>Move the left pointer to <code>mid</code> + 1.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Move the right pointer to <code>mid</code> - 1.</li>
</ul>
</li>
</ul>
</li>
<li>Return the right pointer as the found index.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/fExu3Azx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The algorithm processes each element once in the main loop, which takes <span class="math inline">\(O(n)\)</span> time. For each element, we perform two main operations: maintaining the monotonic property of the stack and binary search. While stack maintenance operations (adding and removing elements) take amortized <span class="math inline">\(O(1)\)</span> time per element since each element can be added and removed at most once, the binary search operation takes <span class="math inline">\(O(\log n)\)</span> time for each element as we search through a list that can grow up to size <span class="math inline">\(n\)</span>.</p>
<p>Thus, the overall time complexity becomes <span class="math inline">\(O(n) + O(n \cdot \log n) = O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space primarily for the <code>cumulativeSumStack</code> list, which stores pairs of cumulative sums and their indices. In the worst case, this list could store all indices if the input array is strictly increasing, leading to <span class="math inline">\(O(n)\)</span> space usage.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-deque">Approach 3: Deque</h3>
<h4 id="intuition-2">Intuition</h4>
<p>If we take a look at our previous approaches, we notice a recurring challenge: we need to find both the smallest sum and the largest index before our current position. This brings us to the question—can we use a data structure that helps us track both of these elements at the same time?</p>
<p>The answer lies in using a deque, or double-ended queue. A deque allows us to add or remove items from either end, which is perfect for our needs. In this case, our deque will hold the indices of the prefix sums that might serve as the starting point for our target subarray. We also make sure that these sums form a monotonically increasing sequence. This monotonicity is important because if we encounter an earlier prefix sum that is greater than or equal to a later one, that later index will always give us a shorter subarray with an equal or greater sum for any future ending position.</p>
<p>As we iterate through each position, we start by checking if we can find valid subarrays using the indices stored in our deque. We do this by calculating the difference between the current prefix sum and the prefix sum at the front of the deque. If this difference meets or exceeds our target sum, we’ve found a valid subarray. At this point, we update our <code>shortestSubarrayLength</code> and remove that starting index from the deque, since it won't help us find a shorter subarray with any future ending positions.</p>
<p>Next, we need to maintain the monotonicity of our deque. We remove indices from the back of the deque if their prefix sums are greater than or equal to our current prefix sum. This step is crucial because any removed positions would only yield longer subarrays with the same or smaller sums, making them unnecessary for our purposes.</p>
<p>Finally, we add our current index to the back of the deque because it could potentially be the starting point of a valid subarray in the future.</p>
<p>By the time we finish iterating through the array, the variable <code>shortestSubarrayLength</code> will contain the length of the shortest subarray that meets our criteria.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a variable <code>n</code> to store the length of the input array.</li>
<li>an array <code>prefixSums</code> of size <code>n+1</code> to store cumulative sums, where <code>prefixSums[i]</code> will represent the sum of elements from index 0 to <code>i-1</code>.</li>
</ul>
</li>
<li>Calculate prefix sums by iterating from 1 to <code>n</code>:
<ul>
<li>Set <code>prefixSums[i]</code> as the sum of <code>prefixSums[i-1]</code> and <code>nums[i-1]</code></li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a deque <code>candidateIndices</code> to store indices that could form valid subarrays.</li>
<li>a variable <code>shortestSubarrayLength</code> to store the minimum length of a valid subarray, setting it to the maximum possible integer value.</li>
</ul>
</li>
<li>Iterate through each index <code>i</code> from 0 to <code>n</code>:
<ul>
<li>While the deque is not empty and the difference between <code>prefixSums[i]</code> and <code>prefixSums[first element of deque]</code> is greater than or equal to <code>targetSum</code>:
<ul>
<li>Update <code>shortestSubarrayLength</code> with the minimum of itself and (i - first element of deque).</li>
<li>Remove the first element from the deque.</li>
</ul>
</li>
<li>While deque is not empty and <code>prefixSums[i]</code> is less than or equal to <code>prefixSums[last element of deque]</code>:
<ul>
<li>Remove the last element from the deque.</li>
</ul>
</li>
<li>Add current index <code>i</code> to the end of the deque.</li>
</ul>
</li>
<li>Return -1 if <code>shortestSubarrayLength</code> remains unchanged at maximum integer value, otherwise return <code>shortestSubarrayLength</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/AnYT95ak/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm first calculates prefix sums in <span class="math inline">\(O(n)\)</span> time. Then, it processes each index exactly once in the main loop. Within this loop, each index can be added to the deque once and removed at most once from either end of the deque. Since deque operations take <span class="math inline">\(O(1)\)</span> time, the amortized time complexity for all deque operations is <span class="math inline">\(O(n)\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space for two main data structures. First, the prefix sums array requires <span class="math inline">\(O(n+1)\)</span> space to store cumulative sums. Second, the deque of candidate indices, in the worst case, might need to store <span class="math inline">\(O(n)\)</span> indices.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(n+1) + O(n) = O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-257">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/single-element-in-a-sorted-array/description" target="_blank" rel="noopener noreferrer">Single Element in a Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p>

<p>Return <em>the single element that appears only once</em>.</p>

<p>Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,1,2,3,3,4,4,8,8]
<strong>Output:</strong> 2
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [3,3,7,7,10,11,11]
<strong>Output:</strong> 10
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-258">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-good-base/description" target="_blank" rel="noopener noreferrer">Smallest Good Base</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code> represented as a string, return <em>the smallest <strong>good base</strong> of</em> <code>n</code>.</p>

<p>We call <code>k &gt;= 2</code> a <strong>good base</strong> of <code>n</code>, if all digits of <code>n</code> base <code>k</code> are <code>1</code>&#39;s.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = &quot;13&quot;
<strong>Output:</strong> &quot;3&quot;
<strong>Explanation:</strong> 13 base 3 is 111.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = &quot;4681&quot;
<strong>Output:</strong> &quot;8&quot;
<strong>Explanation:</strong> 4681 base 8 is 11111.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = &quot;1000000000000000000&quot;
<strong>Output:</strong> &quot;999999999999999999&quot;
<strong>Explanation:</strong> 1000000000000000000 base 999999999999999999 is 11.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n</code> is an integer in the range <code>[3, 10<sup>18</sup>]</code>.</li>
	<li><code>n</code> does not contain any leading zeros.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-259">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/description" target="_blank" rel="noopener noreferrer">Smallest Subarrays With Maximum Bitwise OR</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>, consisting of non-negative integers. For each index <code>i</code> from <code>0</code> to <code>n - 1</code>, you must determine the size of the <strong>minimum sized</strong> non-empty subarray of <code>nums</code> starting at <code>i</code> (<strong>inclusive</strong>) that has the <strong>maximum</strong> possible <strong>bitwise OR</strong>.</p>

<ul>
	<li>In other words, let <code>B<sub>ij</sub></code> be the bitwise OR of the subarray <code>nums[i...j]</code>. You need to find the smallest subarray starting at <code>i</code>, such that bitwise OR of this subarray is equal to <code>max(B<sub>ik</sub>)</code> where <code>i &lt;= k &lt;= n - 1</code>.</li>
</ul>

<p>The bitwise OR of an array is the bitwise OR of all the numbers in it.</p>

<p>Return <em>an integer array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the length of the <strong>minimum</strong> sized subarray starting at </em><code>i</code><em> with <strong>maximum</strong> bitwise OR.</em></p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,2,1,3]
<strong>Output:</strong> [3,3,2,2,1]
<strong>Explanation:</strong>
The maximum possible bitwise OR starting at any index is 3. 
- Starting at index 0, the shortest subarray that yields it is [1,0,2].
- Starting at index 1, the shortest subarray that yields the maximum bitwise OR is [0,2,1].
- Starting at index 2, the shortest subarray that yields the maximum bitwise OR is [2,1].
- Starting at index 3, the shortest subarray that yields the maximum bitwise OR is [1,3].
- Starting at index 4, the shortest subarray that yields the maximum bitwise OR is [3].
Therefore, we return [3,3,2,2,1]. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2]
<strong>Output:</strong> [2,1]
<strong>Explanation:
</strong>Starting at index 0, the shortest subarray that yields the maximum bitwise OR is of length 2.
Starting at index 1, the shortest subarray that yields the maximum bitwise OR is of length 1.
Therefore, we return [2,1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-enumeration">Approach: Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>For the elements <span class="math inline">\(\textit{nums}[i]\)</span> in the array, their range is <span class="math inline">\([0, 10^9]\)</span>, and they can contain up to <span class="math inline">\(31\)</span> binary bits.</p>
<p>For the <span class="math inline">\(\textit{bit}\)</span>-th binary digit:</p>
<ul>
<li>
<p>If it is <span class="math inline">\(1\)</span>, then after performing a bitwise OR operation with any number, this binary bit remains <span class="math inline">\(1\)</span>, so it has no effect.</p>
</li>
<li>
<p>If it is <span class="math inline">\(0\)</span>, then we need to find the smallest <span class="math inline">\(j\)</span> such that <span class="math inline">\(j > i\)</span> and the <span class="math inline">\(\textit{bit}\)</span>-th binary digit of <span class="math inline">\(\textit{nums}[j]\)</span> is <span class="math inline">\(1\)</span>. This way, we can achieve the maximum value through bitwise OR operations. Note that such a <span class="math inline">\(j\)</span> may not exist.</p>
</li>
</ul>
<p>Therefore, we can traverse the array <span class="math inline">\(\textit{nums}\)</span> in descending order of index, while using an array <span class="math inline">\(\textit{pos}\)</span> to record the most recent position where each binary bit was set to <span class="math inline">\(1\)</span> (if no such position exists, it is initialized to <span class="math inline">\(-1\)</span>). When we reach <span class="math inline">\(\textit{nums}[i]\)</span>, for its <span class="math inline">\(\textit{bit}\)</span>-th binary digit:</p>
<ul>
<li>
<p>If it is <span class="math inline">\(1\)</span>, we update <span class="math inline">\(\textit{pos}[\textit{bit}]\)</span> to <span class="math inline">\(i\)</span>.</p>
</li>
<li>
<p>If it is <span class="math inline">\(0\)</span> and <span class="math inline">\(\textit{pos}[\textit{bit}]\)</span> is not <span class="math inline">\(-1\)</span>, then to obtain the maximum bitwise OR value with <span class="math inline">\(i\)</span> as the left boundary, the right boundary must be at least <span class="math inline">\(\textit{pos}[\textit{bit}]\)</span>.</p>
</li>
</ul>
<p>In this way, we can sequentially determine the minimum right boundary for each <span class="math inline">\(i\)</span> as the left boundary, and thus obtain the minimum length of the subarray.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MtQ225Fj/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{nums}\)</span>, and let <span class="math inline">\(C\)</span> be the range of elements in the array <span class="math inline">\(\textit{nums}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times \log C)\)</span>.</p>
<p>We enumerate the binary bits of each element, and each element has <span class="math inline">\(\log C\)</span> binary bits.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log C)\)</span></p>
<p>This is the space required for the array <span class="math inline">\(\textit{pos}\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-260">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-substring-with-identical-characters-i/description" target="_blank" rel="noopener noreferrer">Smallest Substring With Identical Characters I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">enumeration</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary string <code>s</code> of length <code>n</code> and an integer <code>numOps</code>.</p>

<p>You are allowed to perform the following operation on <code>s</code> <strong>at most</strong> <code>numOps</code> times:</p>

<ul>
	<li>Select any index <code>i</code> (where <code>0 &lt;= i &lt; n</code>) and <strong>flip</strong> <code>s[i]</code>. If <code>s[i] == &#39;1&#39;</code>, change <code>s[i]</code> to <code>&#39;0&#39;</code> and vice versa.</li>
</ul>

<p>You need to <strong>minimize</strong> the length of the <strong>longest</strong> <span data-keyword="substring-nonempty">substring</span> of <code>s</code> such that all the characters in the substring are <strong>identical</strong>.</p>

<p>Return the <strong>minimum</strong> length after the operations.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;000001&quot;, numOps = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>By changing <code>s[2]</code> to <code>&#39;1&#39;</code>, <code>s</code> becomes <code>&quot;001001&quot;</code>. The longest substrings with identical characters are <code>s[0..1]</code> and <code>s[3..4]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;0000&quot;, numOps = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>By changing <code>s[0]</code> and <code>s[2]</code> to <code>&#39;1&#39;</code>, <code>s</code> becomes <code>&quot;1010&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;0101&quot;, numOps = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == s.length &lt;= 1000</code></li>
	<li><code>s</code> consists only of <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.</li>
	<li><code>0 &lt;= numOps &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-261">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-substring-with-identical-characters-ii/description" target="_blank" rel="noopener noreferrer">Smallest Substring With Identical Characters II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary string <code>s</code> of length <code>n</code> and an integer <code>numOps</code>.</p>

<p>You are allowed to perform the following operation on <code>s</code> <strong>at most</strong> <code>numOps</code> times:</p>

<ul>
	<li>Select any index <code>i</code> (where <code>0 &lt;= i &lt; n</code>) and <strong>flip</strong> <code>s[i]</code>. If <code>s[i] == &#39;1&#39;</code>, change <code>s[i]</code> to <code>&#39;0&#39;</code> and vice versa.</li>
</ul>

<p>You need to <strong>minimize</strong> the length of the <strong>longest</strong> <span data-keyword="substring-nonempty">substring</span> of <code>s</code> such that all the characters in the substring are <strong>identical</strong>.</p>

<p>Return the <strong>minimum</strong> length after the operations.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;000001&quot;, numOps = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>By changing <code>s[2]</code> to <code>&#39;1&#39;</code>, <code>s</code> becomes <code>&quot;001001&quot;</code>. The longest substrings with identical characters are <code>s[0..1]</code> and <code>s[3..4]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;0000&quot;, numOps = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>By changing <code>s[0]</code> and <code>s[2]</code> to <code>&#39;1&#39;</code>, <code>s</code> becomes <code>&quot;1010&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;0101&quot;, numOps = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.</li>
	<li><code>0 &lt;= numOps &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-262">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/snapshot-array/description" target="_blank" rel="noopener noreferrer">Snapshot Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Implement a SnapshotArray that supports the following interface:</p>

<ul>
	<li><code>SnapshotArray(int length)</code> initializes an array-like data structure with the given length. <strong>Initially, each element equals 0</strong>.</li>
	<li><code>void set(index, val)</code> sets the element at the given <code>index</code> to be equal to <code>val</code>.</li>
	<li><code>int snap()</code> takes a snapshot of the array and returns the <code>snap_id</code>: the total number of times we called <code>snap()</code> minus <code>1</code>.</li>
	<li><code>int get(index, snap_id)</code> returns the value at the given <code>index</code>, at the time we took the snapshot with the given <code>snap_id</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]
[[3],[0,5],[],[0,6],[0,0]]
<strong>Output:</strong> [null,null,0,null,5]
<strong>Explanation: </strong>
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= index &lt; length</code></li>
	<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= snap_id &lt; </code>(the total number of times we call <code>snap()</code>)</li>
	<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>set</code>, <code>snap</code>, and <code>get</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The most straightforward approach to this problem is to keep track of every snapshot taken by saving the values of all the elements in the array at that moment. We can then retrieve the values at any given snapshot by indexing into the snapshot list and fetching the element's value.</p>
<p>As shown in the picture below, we save a copy of the entire array <code>nums</code> every time we take a snapshot as <code>snap_0</code>, <code>snap_1</code>, and so on. Then <code>get(index=0, snap_id=2)</code> returns the first element of <code>snap_2</code>.</p>
<p><img src="../Figures/1146/1.png" alt="img" /></p>
<p>While this approach is conceptually simple, it would be inefficient for large arrays or if snapshots are taken frequently. Suppose the maximum number of calls to each function is <span class="math inline">\(O(n)\)</span>, it saves <span class="math inline">\(O(n)\)</span> arrays of size <span class="math inline">\(\text{length}\)</span>, resulting in high memory usage and time complexity.</p>
<hr />
<h3 id="approach-binary-search">Approach: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>One alternative is to focus on the historical record of each element, and record the value of the modified element when <code>set</code> is called. This approach will reduce the memory required to store the history of the array's elements and improve query times for specific snapshots since we save an element <code>nums[i]</code> only when it is modified by <code>set</code>.</p>
<p><img src="../Figures/1146/2.png" alt="img" /></p>
<p>To implement this approach, we can create a list of records for each index <code>i</code>. A record contains the snapshot id and the value of the element in that snapshot, in the format of <code>(snap_id, nums[i])</code>. We can then store the list of records of each element in a dictionary <code>history_records</code>, where the key is <code>i</code>. Take a look at how we update the historical record of <code>nums[0]</code> in <code>history_records[0]</code>.</p>
<p><img src="../Figures/1146/5.png" alt="img" /></p>
<br>
<p>We have collected every record of <code>nums[0]</code> in <code>history_records[0]</code>.</p>
<p><img src="../Figures/1146/3.png" alt="img" /></p>
<p>To retrieve the value of <code>nums[0]</code> with the given snapshot id <code>snap_id = 2</code>, we need to find the insertion position of <code>snap_id</code> in the list of records for <code>nums[0]</code>. It should be noted that <code>snap_id</code> may not be present in the record list. Therefore, we can use binary search to find the record with the highest snapshot ID that is less than or equal to the given <code>snap_id</code>.</p>
<blockquote>
<p>Note that <code>snap_id = 2</code> is not included in the historical record of <code>nums[0]</code>, as <code>set</code> was not called on this element when the snapshot ID was 2. Therefore, the value of <code>nums[0]</code> remains the same as it was when the snapshot ID was 1.</p>
</blockquote>
<p><img src="../Figures/1146/4.png" alt="img" /></p>
<p>Once we have the index of the target ID <code>snap_index</code>, we can retrieve the corresponding value from the record at the position <code>snap_index</code>, which is <code>history_records[0][snap_index][1]</code>.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>For each element <code>nums[i]</code> in the array, create an empty list to store its historical values, in the format of <code>[snap_id, value]</code>. Initialize each list by adding the first record <code>[0, 0]</code>.</p>
</li>
<li>
<p>Implement the <code>set(index, val)</code> method: add the historical record <code>[snap_id, value]</code> to the record list <code>history_records[index]</code>.</p>
</li>
<li>
<p>Implement the <code>snap</code> method: return <code>snap_id</code> and increment it by 1.</p>
</li>
<li>
<p>Implement the <code>get(index, snap_id)</code> method to retrieve the value of <code>nums[index]</code> in the array with snapshot id as <code>snap_id</code>:</p>
<ul>
<li>Use binary search to find the rightmost insertion index of snapshot ID in the given version <code>snap_index</code> (so the target index is <code>snap_index - 1</code>).</li>
<li>Return <code>history_records[index][snap_index - 1][1]</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dcNokMR2/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the maximum number of calls and <code>k = length</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + k)\)</span></p>
<ul>
<li>We initialize <code>historyRecords</code> with size <code>k</code>.</li>
<li>In the worst-case scenario, the number of calls to <code>get</code>, <code>set</code>, and <code>snap</code> are all <span class="math inline">\(O(n)\)</span>.</li>
<li>For each call to <code>get(index, snap_id)</code>, we will perform a binary search over the list of records of <code>nums[index]</code>. Since a list contains at most <span class="math inline">\(O(n)\)</span> records, a binary search takes <span class="math inline">\(O(\log n)\)</span> time on average. Thus it requires <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>Each call to <code>snap</code> takes <span class="math inline">\(O(1)\)</span> time.</li>
<li>Each call to <code>set(index, snap_id)</code> appends a pair to the historical record of <code>nums[index]</code>, which takes <span class="math inline">\(O(1)\)</span> time, or <span class="math inline">\(O(\log n)\)</span> in Java as we are using TreeMap.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + k)\)</span></p>
<ul>
<li>We initialize <code>historyRecords</code> with size <code>k</code>.</li>
<li>We add one pair <code>(snap_id, val)</code> for each call to <code>set</code>, thus there are at most <span class="math inline">\(n\)</span> pairs saved in <code>history_record</code>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-263">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sorted-gcd-pair-queries/description" target="_blank" rel="noopener noreferrer">Sorted GCD Pair Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">counting</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and an integer array <code>queries</code>.</p>

<p>Let <code>gcdPairs</code> denote an array obtained by calculating the <span data-keyword="gcd-function">GCD</span> of all possible pairs <code>(nums[i], nums[j])</code>, where <code>0 &lt;= i &lt; j &lt; n</code>, and then sorting these values in <strong>ascending</strong> order.</p>

<p>For each query <code>queries[i]</code>, you need to find the element at index <code>queries[i]</code> in <code>gcdPairs</code>.</p>

<p>Return an integer array <code>answer</code>, where <code>answer[i]</code> is the value at <code>gcdPairs[queries[i]]</code> for each query.</p>

<p>The term <code>gcd(a, b)</code> denotes the <strong>greatest common divisor</strong> of <code>a</code> and <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4], queries = [0,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs = [gcd(nums[0], nums[1]), gcd(nums[0], nums[2]), gcd(nums[1], nums[2])] = [1, 2, 1]</code>.</p>

<p>After sorting in ascending order, <code>gcdPairs = [1, 1, 2]</code>.</p>

<p>So, the answer is <code>[gcdPairs[queries[0]], gcdPairs[queries[1]], gcdPairs[queries[2]]] = [1, 2, 2]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,4,2,1], queries = [5,3,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,2,1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs</code> sorted in ascending order is <code>[1, 1, 1, 2, 2, 4]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,2], queries = [0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs = [2]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= queries[i] &lt; n * (n - 1) / 2</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-264">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sorting-three-groups/description" target="_blank" rel="noopener noreferrer">Sorting Three Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. Each element in <code>nums</code> is 1, 2 or 3. In each operation, you can remove an element from&nbsp;<code>nums</code>. Return the <strong>minimum</strong> number of operations to make <code>nums</code> <strong>non-decreasing</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,1,3,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>One of the optimal solutions is to remove <code>nums[0]</code>, <code>nums[2]</code> and <code>nums[3]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,3,2,1,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>One of the optimal solutions is to remove <code>nums[1]</code> and <code>nums[2]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,2,2,2,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><code>nums</code> is already non-decreasing.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 3</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow-up:</strong> Can you come up with an algorithm that runs in <code>O(n)</code> time complexity?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-265">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/special-array-ii/description" target="_blank" rel="noopener noreferrer">Special Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An array is considered <strong>special</strong> if every pair of its adjacent elements contains two numbers with different parity.</p>

<p>You are given an array of integer <code>nums</code> and a 2D integer matrix <code>queries</code>, where for <code>queries[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> your task is to check that <span data-keyword="subarray">subarray</span> <code>nums[from<sub>i</sub>..to<sub>i</sub>]</code> is <strong>special</strong> or not.</p>

<p>Return an array of booleans <code>answer</code> such that <code>answer[i]</code> is <code>true</code> if <code>nums[from<sub>i</sub>..to<sub>i</sub>]</code> is special.<!-- notionvc: e5d6f4e2-d20a-4fbd-9c7f-22fbe52ef730 --></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,4,1,2,6], queries = [[0,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false]</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarray is <code>[3,4,1,2,6]</code>. 2 and 6 are both even.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,3,1,6], queries = [[0,2],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false,true]</span></p>

<p><strong>Explanation:</strong></p>

<ol>
	<li>The subarray is <code>[4,3,1]</code>. 3 and 1 are both odd. So the answer to this query is <code>false</code>.</li>
	<li>The subarray is <code>[1,6]</code>. There is only one pair: <code>(1,6)</code> and it contains numbers with different parity. So the answer to this query is <code>true</code>.</li>
</ol>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;= nums.length - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of integers <code>nums</code> and a 2D array of queries <code>queries</code>, where each query <code>queries[i] = [from, to]</code> refers to the subarray <code>nums[from ... to]</code>. Our task is to determine if each subarray <code>nums[from ... to]</code> is special. A subarray is considered special if every pair of adjacent elements has different parity — that is, the subarray alternates between even and odd elements.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute force solution would involve traversing the entire subarray for each query <code>queries[i]</code> and checking if its elements alternate between even and odd parity. However, this approach is inefficient because traversing all subarrays will be very time-consuming, especially if there are many queries or if the subarrays are large. Also, there would be much repeated work if the queries overlap.</p>
<p>Instead, we can perform some precomputations to solve each query faster. If we perform an initial traversal of <code>nums</code>, we can easily identify the indices of elements that break or violate the special array property. Specifically, we can find the indices of elements <code>nums[i]</code> that have the same parity (even or odd) as its previous element: If <code>nums[i] % 2 == nums[i-1] % 2</code> is true, then <code>nums[i]</code> is a violating element.</p>
<p>After finding these violating indices, we know that any subarray containing any of these indices is not a special array. Conversely, if a subarray contains no violating indices, then it is a special array.</p>
<p>The problem now is to find an efficient way to check if each subarray defined by <code>queries[i] = [start, end]</code> contains any violating indices. Since we can perform our initial traversal of <code>nums</code> from left to right, the violating indices are naturally sorted in ascending order. Because they are sorted, we can perform <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search</a> on the violating indices to see if any violating indices fall between the range <code>[start + 1, end]</code>. Note that we start our search at <code>start + 1</code> instead of <code>start</code> because the violating indices are defined relative to the element to their left. Therefore, the first element of our subarray (at index <code>start</code>) is never a violating element, and our search should begin at <code>start + 1</code>.</p>
<p>It is also worth noting that there is usually a single target value we would like to find for traditional binary search problems. However, for this problem, we have a target range of <code>[start + 1, end]</code> instead.</p>
<p>Thus, our precomputation allows us to more efficiently evaluate each subarray, leading to an <span class="math inline">\(O(\logn)\)</span> binary search time for each query rather than a <span class="math inline">\(O(n)\)</span> brute force traversal.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a new boolean <code>ans</code> array to hold our answers for all queries.</li>
<li>Create a new list <code>violatingIndices</code> to store all the indices that violate the special array condition in <code>nums</code>.</li>
<li>Iterate through <code>nums</code> and add all the violating indices found to <code>violatingIndices</code>.</li>
<li>Traverse through <code>queries</code> to answer each <code>queries[i]</code>:
<ul>
<li>Initialize variable <code>start</code> to <code>queries[i][0]</code>.</li>
<li>Initialize variable <code>end</code> to <code>queries[i][1]</code>.</li>
<li>Call helper function <code>binarySearch(start + 1, end, violatingIndices)</code> to search through <code>violatingIndices</code> to see if it contains any indices that fall between <code>start</code> and <code>end</code>. Save result to variable <code>foundViolatingIndex</code>.</li>
<li>If <code>foundViolatingIndex == true</code>, then we know the answer to the current query is false. Otherwise, the answer is true..</li>
<li>Save answer in <code>ans[i]</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
<li>Define helper function <code>binarySearch(start, end, violatingIndices)</code>:
<ul>
<li>We initialize our search space to the entire list of violating indices: <code>left = 0</code> and <code>right = violatingIndices.size() - 1</code></li>
<li>While <code>left &lt;= right</code>:
<ul>
<li>Calculate the midpoint: <code>mid = (left + right) / 2</code>.</li>
<li>Access the violating index at that index: <code>violatingIndex = violatingIndices.get(mid)</code>.</li>
<li>If <code>violatingIndex &lt; start</code>, then we want to look at the right half of our search space, so update <code>left = mid + 1</code>.</li>
<li>If <code>violatingIndex &gt; end</code>, then we want to look at the left half of our search space, so update <code>right = mid - 1</code>.</li>
<li>Otherwise, our violating index falls in between <code>start</code> and <code>end</code>, meaning we found one in the subarray. Thus, we return <code>true</code>.</li>
</ul>
</li>
<li>If we reach this point, then we couldn't find any violating indices in the subarray. We return <code>false</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4xjpYCrJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>nums</code> and <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M + N \cdot \log M)\)</span></p>
<p>Our initial traversal of <code>nums</code> takes <span class="math inline">\(O(M)\)</span> time. Then, the binary search for each query will take <span class="math inline">\(O(\log M)\)</span>. For all <span class="math inline">\(N\)</span> queries, the total time for all searches is <span class="math inline">\(O(N \cdot \log M)\)</span>. Thus, the total time complexity is <span class="math inline">\(O(M + N \cdot \log M)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M)\)</span></p>
<p>We store the violating indices of <code>nums</code>, which will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-sum">Approach 2: Prefix Sum</h3>
<h4 id="intuition-1">Intuition</h4>
<p>For Approach 1, our precomputation involved finding all the violative indices of <code>nums</code>. This allowed us to evaluate each query in logarithmic time.</p>
<p>We will now consider a different precomputation method. We will find the total number of violative indices up to index <code>i</code> in <code>nums</code> for all indices <code>i</code>. In other words, we can create a prefix sum array where <code>prefix[i]</code> contains the total number of violative indices considering <code>nums[0...i]</code>. This can easily be done in linear time by iterating through <code>nums</code> and checking if each element <code>nums[i]</code> has the same parity as the previous element. If it does, then we have found a new violating index <code>i</code>, and our total number of violative indices increases by 1 (<code>prefix[i] = prefix[i - 1] + 1</code>). If it doesn't, then <code>i</code> is not a violating index and we keep our number of violative indices the same as before: <code>prefix[i] = prefix[i - 1]</code></p>
<p>This prefix sum array is convenient because it now allows us to evaluate each query in constant time. Given any query <code>queries[i] = [start, end]</code>, we know that there are no violating indices found in the subarray between indices <code>start</code> and <code>end</code> if <code>prefix[end] - prefix[start] == 0</code>. If this condition is true, then the subarray is considered special. Otherwise, it is not special.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a new boolean <code>ans</code> array to hold our answers for all queries</li>
<li>Initialize a <code>prefix</code> array to contain the prefix sum of the total number of violative indices.</li>
<li>Initialize <code>prefix[0] = 0</code>.</li>
<li>Iterate through <code>nums</code> from <code>i = 1</code> to <code>i = nums.length - 1</code>:
<ul>
<li>If <code>nums[i] % 2 == nums[i - 1] % 2</code> then <code>i</code> is a new violative index, and we can increase the total number by 1: <code>prefix[i] = prefix[i-1] + 1</code></li>
<li>Otherwise, the total stays the same: <code>prefix[i] = prefix[i-1]</code>.</li>
</ul>
</li>
<li>Traverse through <code>queries</code> to answer each <code>queries[i]</code>:
<ul>
<li>Let <code>start = queries[i][0]</code>.</li>
<li>Let <code>end = queries[i][1]</code>.</li>
<li>Fill in <code>ans[i]</code> with <code>prefix[end] - prefix[start] == 0</code>, evaluating if there are no violating indices in the subarray.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/i9Wih4uH/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>nums</code> and <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>Our initial traversal of <code>nums</code> to initialize <code>prefix</code> takes <span class="math inline">\(O(M)\)</span> time. Then, answering each query will took constant time. For all <span class="math inline">\(N\)</span> queries, that will take a total of <span class="math inline">\(O(N)\)</span> time. Thus, the total time complexity is <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M)\)</span></p>
<p>We maintain a prefix sum array for <code>nums</code>, which will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sliding-window">Approach 3: Sliding Window</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To make the process more fluent, we need a way to precompute information that can help us answer each query in constant time. The key idea is that for any index <code>start</code>, the farthest index we can reach while maintaining alternating parity is independent of the queries themselves. Thus, we can calculate this information beforehand.</p>
<p>We define an array <code>maxReach</code>, where <code>maxReach[start]</code> represents the farthest index that can be reached from <code>start</code> while adhering to the parity condition. To compute this, we iterate through the array and use a pointer <code>end</code> to expand the range as far as possible. Starting with <code>end = start</code>, we increment <code>end</code> as long as the parity of adjacent elements (<code>nums[end]</code> and <code>nums[end + 1]</code>) differs. Once this process is complete for a given <code>start</code>, we know that any range <code>[start, end']</code> with <code>end' &lt;= maxReach[start]</code> satisfies the parity condition.</p>
<p>With this precomputed information, answering queries becomes straightforward. For each query <code>[start, end]</code>, we simply check whether <code>end</code> is within the range of <code>maxReach[start]</code>. If it is, the subarray satisfies the condition; otherwise, it does not.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of the array <code>nums</code> and create a array <code>maxReach</code> of size <code>n</code> to store the maximum reachable index for each starting index.</p>
</li>
<li>
<p>Initialize the last element of <code>maxReach</code>:</p>
<ul>
<li>Set <code>maxReach[n-1]</code> to <code>n-1</code> because the last index can only reach itself.</li>
</ul>
</li>
<li>
<p>Iterate over the array <code>nums</code> from the second-to-last index to the first:</p>
<ul>
<li>If the parity (odd/even) of <code>nums[i]</code> is different from <code>nums[i+1]</code>:
<ul>
<li>Set <code>maxReach[i]</code> to <code>maxReach[i+1]</code> to extend the reachable range.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Set <code>maxReach[i]</code> to <code>i</code>, as it can only reach itself.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Create a array <code>ans</code> of size equal to the number of queries to store the results.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
<ul>
<li>Extract <code>start</code> and <code>end</code> from the query.</li>
<li>Check if the range <code>[start, end]</code> lies within the maximum reachable range stored in <code>maxReach[start]</code>.</li>
<li>Store <code>true</code> if <code>end &lt;= maxReach[start]</code>, otherwise store <code>false</code>.</li>
</ul>
</li>
<li>
<p>Return the array <code>ans</code>, which contains the results for all queries.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/5FwEX5pA/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>nums</code> and <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>First, we go through the <code>nums</code> array to create the <code>maxReach</code> array. This process takes <span class="math inline">\(O(M)\)</span> time.</p>
<p>Next, for each query, we can quickly find the answer using the <code>maxReach</code> array. Since each query is answered in constant time, answering all <span class="math inline">\(N\)</span> queries will take <span class="math inline">\(O(N)\)</span> time.</p>
<p>Combining these two steps, the total time complexity is <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M)\)</span></p>
<p>We use an array called <code>maxReach</code> to store the maximum reach for each position in the <code>nums</code> array. This array takes up <span class="math inline">\(O(M)\)</span> space.</p>
<p>The <code>ans</code> array, which stores the results for each query, is not included in the space complexity calculation because it is considered part of the output. Therefore, the overall space complexity is <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-266">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/description" target="_blank" rel="noopener noreferrer">Special Array With X Elements Greater Than or Equal X</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of non-negative integers. <code>nums</code> is considered <strong>special</strong> if there exists a number <code>x</code> such that there are <strong>exactly</strong> <code>x</code> numbers in <code>nums</code> that are <strong>greater than or equal to</strong> <code>x</code>.</p>

<p>Notice that <code>x</code> <strong>does not</strong> have to be an element in <code>nums</code>.</p>

<p>Return <code>x</code> <em>if the array is <strong>special</strong>, otherwise, return </em><code>-1</code>. It can be proven that if <code>nums</code> is special, the value for <code>x</code> is <strong>unique</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 values (3 and 5) that are greater than or equal to 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No numbers fit the criteria for x.
If x = 0, there should be 0 numbers &gt;= x, but there are 2.
If x = 1, there should be 1 number &gt;= x, but there are 0.
If x = 2, there should be 2 numbers &gt;= x, but there are 0.
x cannot be greater since there are only 2 numbers in nums.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,4,3,0,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 values that are greater than or equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting">Approach 1: Sorting</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a non-negative integer array <code>nums</code>. We need to return an integer <code>x</code> such that there are exactly <code>x</code> integers in the array <code>nums</code> that are greater than or equal to <code>x</code>. The value of <code>x</code> will be unique for a given array <code>nums</code> if <code>nums</code> is unique. If no such value <code>x</code> exists, return <code>-1</code>. Note that the integer <code>x</code> doesn't have to be in the array <code>nums</code>.</p>
<p>The first observation is that the value of <code>x</code> cannot be more than the length of the array <code>nums</code>. This is because for an integer to be the answer, there must be at least that number of integers in <code>nums</code>. If we assume <code>x</code> to be <code>nums.length + 1</code>, there must be precisely <code>nums.length + 1</code> integers in the array that are greater than or equal to <code>x</code>, but there are only <code>nums.length</code> integers in <code>nums</code>. Also, the minimum possible value for <code>x</code> is <code>1</code>. This is because if <code>x</code> equals <code>0</code>, the array <code>nums</code> must be empty, but the constraints guarantee that <code>nums</code> has at least <code>1</code> element.</p>
<p>The naive way to solve the problem is to iterate over the integers from <code>1</code> to <code>nums.length</code> and check if each is special. To check this, we can again iterate over the array <code>nums</code> to find the count of integers that are greater or equal to the value. If this count is equal to the value, then return this value; otherwise, move on to the next value. This approach, however, is not efficient as it uses nested loops, so the time complexity will be quadratic.</p>
<p>We can efficiently find the number of integers that are greater than or equal to an element if the array is sorted. We can then use binary search to find the first index where the value is greater than or equal to the element. All elements after that index would also be greater or equal to the element. In each step of the binary search, we will check the mid index in the current range of <code>nums</code>. If this mid element is greater than <code>val</code>, it implies this can be our answer. Thus, we will store the index and move on to the left half of the current range of <code>nums</code> to check if there's a better answer. If the mid element is smaller than <code>val</code> we will move on to the right half.</p>
<blockquote>
<p>Binary search is an algorithm for finding the position of a target value within a sorted array. It searches efficiently by dividing the search space in half with every iteration. If you are unfamiliar with binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search explore card</a>.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Sort the array <code>nums</code>.</p>
</li>
<li>
<p>Iterate over integers from <code>1</code> to <code>nums.length</code> (N) for each value <code>i</code>:</p>
<ul>
<li>
<p>Find the index of the first integer in the array <code>nums</code> that is greater than or equal to <code>i</code> as <code>k</code> using the binary search method <code>getFirstGreaterOrEqual</code>.</p>
<ul>
<li>
<p>The search space for the binary search is <code>0</code> to <code>N - 1</code>; hence, initialize <code>start</code> to <code>0</code> and <code>end</code> to <code>N - 1</code>.</p>
</li>
<li>
<p>Initialize <code>index</code> to <code>N</code>, this is because if all elements are less than <code>i</code> (<code>val</code>), we will return <code>N</code> as the answer.</p>
</li>
<li>
<p>Repeat the following until the range <code>[start, end]</code> is empty:</p>
<ul>
<li>Find the <code>mid</code> as <code>(start + end) / 2</code>.</li>
<li>If <code>nums[mid]</code> is greater than or equal to <code>val</code>, then update <code>index</code> to <code>mid</code> and move to the left half of the current search space.</li>
<li>Else, move to the right half of the current search space.</li>
</ul>
</li>
<li>
<p>Return <code>index</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the number of integers after index <code>k</code> in the array <code>nums</code>, i.e. <code>N - k</code>, is equal to <code>i</code> then return <code>i</code>.</p>
</li>
</ul>
</li>
<li>
<p>If we have iterated over all possible values and still didn't return any value, it implies no special value exists. Return <code>-1</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TGtvDpQn/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of integers in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>Sorting the array <code>nums</code> takes <span class="math inline">\(O(N \log N)\)</span> time. Then we iterate over all values from <code>1</code> to <code>N</code> and, for each value, perform the binary search on <code>nums</code>, which takes <span class="math inline">\(O(\log N)\)</span> time. Thus, this step takes <span class="math inline">\(O(N \log N)\)</span> time. Therefore, the total time complexity equals <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log N)\)</span> or <span class="math inline">\(O(N)\)</span></p>
<p>No extra space is needed apart from a few variables. However, some space is required for sorting. The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, the <code>Arrays.sort()</code> for primitives is implemented as a variant of the quicksort algorithm whose space complexity is <span class="math inline">\(O(\log⁡⁡ N)\)</span>. In C++ <code>sort()</code> function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort and has a worst-case space complexity of <span class="math inline">\(O(\log⁡⁡ N)\)</span>. In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(N)\)</span> additional space. Thus, the inbuilt <code>sort()</code> function might add up to <span class="math inline">\(O(\log⁡⁡ N)\)</span> or <span class="math inline">\(O(N)\)</span> to the space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-counting-sort--prefix-sum">Approach 2: Counting Sort + Prefix Sum</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An efficient strategy to find the number of integers in the array <code>nums</code> that are greater than or equal to all possible values from <code>1</code> to <code>N</code> could reduce the overall time complexity.</p>
<p>If we store the frequency of each <code>nums</code> integer in the array <code>freq</code>, then we can efficiently find the number of integers that are greater than or equal to each integer. We can take the prefix sum from the end of the range of possible values for <code>x</code>, i.e., <code>N</code> to <code>1</code>. We will keep adding the frequencies of integers from the right end of <code>freq</code> to calculate the number of array values larger than the current element.</p>
<p>The prefix sum (or rather suffix, to be precise, as we calculate it from the right end) doesn't have to be a separate array. Instead, we can calculate the running sum and check if the current sum is equal to the current value. If the current sum from the right end is equal to the current value then we can return the current value. Otherwise, we keep iterating. After the loop completes, we return <code>-1</code> if we don't find a valid <code>x</code>.</p>
<p>The below implementation stores the count of all values in <code>nums</code> that are greater than the length of array <code>nums</code> at <code>freq[N]</code> where <code>N</code> is the length of <code>nums</code>. This is because, as we discussed, <code>x</code> cannot be greater than <code>N</code>. This will reduce the space used for the frequency array as instead of having an array with the size of the maximum element in the array <code>nums</code> we can use an array of size <code>N + 1</code>.</p>
<p><img src="../Figures/1608/1608A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize an array <code>freq</code> with size <code>N + 1</code> with all values as <code>0</code>.</p>
</li>
<li>
<p>Iterate over the array <code>nums</code> and store the frequency of each integer in the array <code>freq</code>. If the value <code>nums[i]</code> is greater than <code>N</code> store the frequency at index <code>N</code>.</p>
</li>
<li>
<p>Initialize the variable <code>numGreaterThanOrEqual</code> to <code>0</code>. This is the number of elements that are greater than or equal to the current element.</p>
</li>
<li>
<p>Iterate over the values from <code>N</code> to <code>1</code> and for each value <code>i</code>:</p>
<ul>
<li>Add the value <code>freq[i]</code> to <code>numGreaterThanOrEqual</code>;</li>
<li>If the value <code>i</code> is equal to the <code>numGreaterThanOrEqual</code> then return <code>i</code></li>
</ul>
</li>
<li>
<p>Return <code>-1</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/G9zwaMR6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of integers in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We first iterate over the integers in the array <code>nums</code> to store the frequencies in the array <code>freq</code>, which takes <span class="math inline">\(O(N)\)</span>. We then iterate over the values from <code>N</code> to <code>1</code> to find the possible answers; this is again a <span class="math inline">\(O(N)\)</span> process. Thus, the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The main space required is the array <code>freq</code> of size <code>N + 1</code>. Therefore, the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-267">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-array-largest-sum/description" target="_blank" rel="noopener noreferrer">Split Array Largest Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, split <code>nums</code> into <code>k</code> non-empty subarrays such that the largest sum of any subarray is <strong>minimized</strong>.</p>

<p>Return <em>the minimized largest sum of the split</em>.</p>

<p>A <strong>subarray</strong> is a contiguous part of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,2,5,10,8], k = 2
<strong>Output:</strong> 18
<strong>Explanation:</strong> There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5], k = 2
<strong>Output:</strong> 9
<strong>Explanation:</strong> There are four ways to split nums into two subarrays.
The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= min(50, nums.length)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-268">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-message-based-on-limit/description" target="_blank" rel="noopener noreferrer">Split Message Based on Limit</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string, <code>message</code>, and a positive integer, <code>limit</code>.</p>

<p>You must <strong>split</strong> <code>message</code> into one or more <strong>parts</strong> based on <code>limit</code>. Each resulting part should have the suffix <code>&quot;&lt;a/b&gt;&quot;</code>, where <code>&quot;b&quot;</code> is to be <strong>replaced</strong> with the total number of parts and <code>&quot;a&quot;</code> is to be <strong>replaced</strong> with the index of the part, starting from <code>1</code> and going up to <code>b</code>. Additionally, the length of each resulting part (including its suffix) should be <strong>equal</strong> to <code>limit</code>, except for the last part whose length can be <strong>at most</strong> <code>limit</code>.</p>

<p>The resulting parts should be formed such that when their suffixes are removed and they are all concatenated <strong>in order</strong>, they should be equal to <code>message</code>. Also, the result should contain as few parts as possible.</p>

<p>Return<em> the parts </em><code>message</code><em> would be split into as an array of strings</em>. If it is impossible to split <code>message</code> as required, return<em> an empty array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> message = &quot;this is really a very awesome message&quot;, limit = 9
<strong>Output:</strong> [&quot;thi&lt;1/14&gt;&quot;,&quot;s i&lt;2/14&gt;&quot;,&quot;s r&lt;3/14&gt;&quot;,&quot;eal&lt;4/14&gt;&quot;,&quot;ly &lt;5/14&gt;&quot;,&quot;a v&lt;6/14&gt;&quot;,&quot;ery&lt;7/14&gt;&quot;,&quot; aw&lt;8/14&gt;&quot;,&quot;eso&lt;9/14&gt;&quot;,&quot;me&lt;10/14&gt;&quot;,&quot; m&lt;11/14&gt;&quot;,&quot;es&lt;12/14&gt;&quot;,&quot;sa&lt;13/14&gt;&quot;,&quot;ge&lt;14/14&gt;&quot;]
<strong>Explanation:</strong>
The first 9 parts take 3 characters each from the beginning of message.
The next 5 parts take 2 characters each to finish splitting message. 
In this example, each part, including the last, has length 9. 
It can be shown it is not possible to split message into less than 14 parts.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> message = &quot;short message&quot;, limit = 15
<strong>Output:</strong> [&quot;short mess&lt;1/2&gt;&quot;,&quot;age&lt;2/2&gt;&quot;]
<strong>Explanation:</strong>
Under the given constraints, the string can be split into two parts: 
- The first part comprises of the first 10 characters, and has a length 15.
- The next part comprises of the last 3 characters, and has a length 8.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= message.length &lt;= 10<sup>4</sup></code></li>
	<li><code>message</code> consists only of lowercase English letters and <code>&#39; &#39;</code>.</li>
	<li><code>1 &lt;= limit &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-269">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sqrtx/description" target="_blank" rel="noopener noreferrer">Sqrt(x)</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a non-negative integer <code>x</code>, return <em>the square root of </em><code>x</code><em> rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p>

<p>You <strong>must not use</strong> any built-in exponent function or operator.</p>

<ul>
	<li>For example, do not use <code>pow(x, 0.5)</code> in c++ or <code>x ** 0.5</code> in python.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> x = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The square root of 4 is 2, so we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> x = 8
<strong>Output:</strong> 2
<strong>Explanation:</strong> The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-270">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarray-product-less-than-k/description" target="_blank" rel="noopener noreferrer">Subarray Product Less Than K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than </em><code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,5,2,6], k = 100
<strong>Output:</strong> 8
<strong>Explanation:</strong> The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], k = 0
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of integers <code>nums</code> and an integer <code>k</code>; the task is to count the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than <code>k</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The problem requires counting valid subarrays, not returning the actual subarrays.</li>
<li>The values in the <code>nums</code> array are positive.</li>
</ol>
<hr />
<h3 id="approach-1-using-sliding-window">Approach 1: Using Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force method involves finding all the subarrays and then selecting those whose products are less than <code>k</code>. However, this approach becomes costly in terms of time complexity, reaching <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For a more efficient approach, let's use the sliding window pattern. This pattern is applicable when the problem entails achieving a goal using subarrays, and individual elements cannot be independently selected.</p>
<p>The concept behind the sliding window pattern is to maintain a window that continuously expands from the right by adding elements and computing their product until the condition is met. Once the condition is satisfied, we adjust the window by shrinking it from the left until the condition is met again.</p>
<p>As we slide the window across the array, our objective is to identify all subarrays in the <code>nums</code> array where the product of its elements remains less than <code>k</code>. For each right position, if the product of the window's elements from left to right is less than <code>k</code>, adding the element at the right generates new subarrays with products less than <code>k</code>.</p>
<p>The count of such subarrays is determined by the difference <code>right - left + 1</code>, which represents the number of subarrays that end at <code>right</code> and start at any element between <code>right</code> and <code>left</code>, inclusive. In essence, this count encompasses the subarray consisting solely of the current element itself, as well as all possible subarrays extending back to the left boundary of the window (<code>left</code>).</p>
<p>Consider an example window containing elements 3, 4, and 5. If we include 6 in the window, we need to count all possible subarrays that end with 6. These subarrays can be formed by starting at any element within the current window and extending to 6. Therefore, the subarrays would be:</p>
<ul>
<li><code>[6]</code> (subarray consisting only of 6)</li>
<li><code>[5, 6]</code> (subarray starting from 5 and ending at 6)</li>
<li><code>[4, 5, 6]</code> (subarray starting from 4 and ending at 6)</li>
<li><code>[3, 4, 5, 6]</code> (subarray starting from 3 and ending at 6)</li>
</ul>
<p>By calculating <code>right - left + 1</code>, we enumerate all subarrays that end with the current element of the window (<code>nums[right]</code>). This ensures that we count all possible subarrays as we slide the window across the array. As we can observe, adding element 6 to the window created 4 new subarrays.</p>
<p>The crucial insight is that once the product becomes less than <code>k</code>, all possible subarrays formed by selecting subsets of elements within the current window (from left to right) will also have a product strictly less than <code>k</code>.</p>
<p>Hence, whenever the product is valid, we add the current window size (<code>right - left + 1</code>) to the total count of subarrays.</p>
<p>The following slideshow provides a clearer insight into the underlying approach:</p>
<p>!?!../Documents/713/713_Sliding_Window.json:1020,500!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Check if <code>k</code> is less than or equal to 1. In this case, no subarrays can have a product less than <code>k</code>, so return 0.</li>
<li>Initialize the variables <code>totalCount</code> to 0, to store the final count of subarrays with a product less than <code>k</code>, and <code>product</code> to 1, representing the product of elements within the window (initially empty).</li>
<li>Use two pointers, <code>left</code> and <code>right</code>, to define the sliding window. Iterate through the <code>nums</code> array using a for loop until <code>right</code> reaches the end.
<ul>
<li>Inside the loop, multiply the current <code>product</code> by the element at the right pointer (<code>nums[right]</code>). This effectively includes the new element in the window.</li>
<li>While the current <code>product</code> is greater than or equal to <code>k</code>, the window needs to shrink to exclude elements that make the product exceed or equal to <code>k</code>.
<ul>
<li>Divide the <code>product</code> by the element at the left pointer (<code>nums[left]</code>).</li>
<li>Increment <code>left</code> by 1 to move the window one position to the right, effectively excluding the leftmost element.</li>
</ul>
</li>
<li>Update the <code>totalCount</code> by adding the number of valid subarrays with the current window size, which is <code>right - left + 1</code>.</li>
</ul>
</li>
<li>Return the <code>totalCount</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3bqwMaz3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the input array <code>nums</code> using a single for loop. Inside the loop, there are nested operations for shrinking the window, but since <code>left</code> is incremented a total number of <code>n</code> times during the whole array traversal, each element in the array is visited at most twice.</p>
<p>The nested loop terminates when the product becomes less than <code>k</code>, and this can only happen at most <code>n</code> times total (once for each element). Therefore, the overall time complexity is <span class="math inline">\(2n\)</span>, which we describe as <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space for variables like <code>totalCount</code>, <code>product</code>, <code>left</code>, and <code>right</code>. These variables do not depend on the size of the input array. Therefore, the space complexity is considered constant, denoted as <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<blockquote>
<p><strong>Note:</strong> The below approach is generally not anticipated in an interview setting, as many individuals might not be familiar with logarithmic functions, having either forgotten them or not utilized them extensively. So, it's tough for them to come up with this idea on the spot. Moreover, the sliding window approach remains the optimal solution to this problem.</p>
</blockquote>
<h3 id="approach-2-using-binary-search">Approach 2: Using Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p><a href="https://en.wikipedia.org/wiki/Logarithm">Logarithms</a> have the property that the sum of logarithms is exactly equal to the logarithm of the product: <span class="math inline">\(\log(a) + \log(b) = \log(ab)\)</span>. This property allows us to convert the product of elements in a subarray into the sum of the logarithms of those elements.</p>
<p>The motivation for this is that the product of some arbitrary subarray may be way too large (potentially <span class="math inline">\(1000^{50000}\)</span>).</p>
<p>Integer overflow occurs when the result of an arithmetic operation exceeds the maximum value represented by the data type. This can happen when computing the product of elements in a large subarray, as the result can quickly surpass the integer's capacity, leading to incorrect values due to overflow.</p>
<p>To mitigate this, we can convert the product operation into a summation of logarithms. Logarithms allow the representation of large values within a manageable range, minimizing the risk of overflow while maintaining accuracy.</p>
<p>The first step is to transform the problem from finding products to finding sums. This is done by taking the natural logarithm (log) of each element in the array.</p>
<p>Then a prefix sum array (<code>logsPrefixSum</code>) is calculated, where each element is the sum of the logarithms of all elements up to that point in the original array. This will allow us to quickly determine if a subarray's sum of logarithms is less than a certain value. Because the prefix sum is a monotonically increasing array, we can use binary search to find valid subarrays.</p>
<p>For each element in the array, a binary search is performed to find the number of subarrays starting from that element whose sum of logarithms is less than the sum of the logarithms of the current element and <code>log(K)</code>. This is done by comparing the midpoint of the search space with the sum of the logarithms of the current element and <code>log(K)</code>. If the midpoint is too high, the search space is narrowed to the left; otherwise, it's narrowed to the right. The number of subarrays found is added to the total count.</p>
<p>Logarithmic comparisons have an issue due to the finite precision in floating-point number representation. That is, logarithmic functions can lead to very small differences between numbers that should be equal, especially when dealing with large or small values.</p>
<p>The product rule is <span class="math inline">\(\log(a \cdot b) == \log(a) + \log(b)\)</span>, but these expressions may not be evaluated as equivalent due to floating-point representation in the computer. It may be <span class="math inline">\(\log(a \cdot b) > \log(a) + \log(b)\)</span> or <span class="math inline">\(\log(a \cdot b) < \log(a) + \log(b)\)</span> . When we transform <code>x</code> to <code>log(x)</code>, we introduce a possible bug.</p>
<p>To prevent this from causing an issue, we subtract <code>1e-9</code> (which is a very small number, 0.000000001), in the comparison condition as a precautionary measure to handle potential precision issues that might arise due to the nature of logarithmic values. This helps mitigate the effect of these precision errors by providing a small buffer or tolerance in the comparison. Even though logarithmic values tend to spread out differences across a wider range, there can still be cases where very close values need to be distinguished, and small discrepancies can occur due to finite precision.</p>
<p>In essence, it ensures that if <code>logsPrefixSum[mid]</code> is very close to <code>logsPrefixSum[i] + logK</code>, the former will still be considered less than the latter rather than failing the condition due to slight numerical discrepancies.</p>
<p>This kind of adjustment is common in numerical math computations where precision matters, especially in conditional algorithms where small discrepancies could lead to incorrect results or sometimes infinite loops.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Check if <code>k</code> (target product) is 0. If true, return 0 (no subarrays possible).</li>
<li>Calculate the logarithm of <code>k</code> and store it in <code>logK</code>.</li>
<li>Create a vector <code>logsPrefixSum</code> of size <code>nums.size() + 1</code> to store the prefix sum of logarithms of elements in <code>nums</code>.</li>
<li>Calculate the prefix sum by iterating over <code>nums</code> and adding the logarithm of each element to the previous prefix sum. This creates a running sum of logarithms for efficient product calculation later.</li>
<li>Initialize <code>totalCount</code> to 0, which will keep track of the total number of subarrays with a product less than <code>k</code>.</li>
<li>Iterate through <code>logsPrefixSum</code> using a loop with index <code>currIdx</code>. This loop considers each element (<code>nums[currIdx]</code>) as the starting point of a potential subarray.
<ul>
<li>Inside the loop, initialize two variables, <code>low</code> and <code>high</code>, to <code>currIdx + 1</code> and <code>m (nums.size() + 1)</code>, respectively.</li>
<li>Enter a binary search loop to find the first element in <code>logsPrefixSum</code> where the subarray product (based on logarithms) exceeds <code>k</code>.
<ul>
<li>Calculate the middle index <code>mid</code> between <code>low</code> and <code>high</code>.</li>
<li>Compare the prefix sum at <code>mid</code> with the target prefix sum (<code>logsPrefixSum[currIdx] + logK</code>). Here, a small tolerance (<code>-1e-9</code>) is used to handle floating-point precision issues.</li>
<li>If the prefix sum at <code>mid</code> is less than the target, it means the subarray product ending at <code>mid</code> might still be less than <code>k</code>.
<ul>
<li>Move <code>low</code> to <code>mid + 1</code> to search in the right half of the remaining subarray.</li>
</ul>
</li>
<li>Otherwise, the subarray product ending at <code>mid</code> or elements beyond <code>mid</code> might exceed <code>k</code>.
<ul>
<li>Move <code>high</code> to <code>mid</code> to continue searching in the left half for the first exceeding element.</li>
</ul>
</li>
</ul>
</li>
<li>After the binary search loop, the <code>low</code> index points to the first element in <code>logsPrefixSum</code> where the subarray product (based on logarithms) exceeds <code>k</code>. Increment <code>totalCount</code> by the number of elements between <code>currIdx</code> (inclusive) and <code>low</code> (exclusive). This represents the number of valid subarrays ending at <code>currIdx</code> with a product less than <code>k</code>.</li>
</ul>
</li>
<li>Finally, return <code>totalCount</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ja6nxkvo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log(n))\)</span></p>
<p>The time complexity of the overall algorithm is <span class="math inline">\(O(n \cdot \log(n))\)</span> due to the binary search performed in each iteration of the outer loop.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> due to the list <code>logsPrefixSum</code>, storing logarithmic prefix sums of <code>nums</code>, whose length equals that of <code>nums</code>.</p>
</li>
</ul>
<hr />
<details>
<summary><b>Click Here for Discussion on the Tradeoffs of the Approaches</b></summary>
<ul>
<li>
<p>The sliding window approach is efficient for finding subarrays with a product less than a given value, but it relies on the fact that the integers in the array are positive. This is because when multiplying positive integers, the product will always be positive, and the product of any number of positive integers will also be positive.</p>
</li>
<li>
<p>On the other hand, the binary search approach is more versatile and can handle arrays containing both positive and negative integers with some modifications. This is because it operates on the logarithms of the elements rather than the elements themselves.</p>
</li>
<li>
<p>After transforming the elements into their logarithmic values, the algorithm compares these values to determine the subarrays with a product less than <code>k</code>. However, direct logarithmic values of negative numbers are not defined in the real number scale. Therefore, to handle negative numbers, appropriate shifting of the elements may be necessary to ensure that the logarithmic values used in the algorithm are valid and meaningful.</p>
</li>
</ul>
</details></div>
				</div>
		</div>

<div class="question-card" id="question-271">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subsequence-with-the-minimum-score/description" target="_blank" rel="noopener noreferrer">Subsequence With the Minimum Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code>.</p>

<p>You are allowed to remove any number of characters from the string <code>t</code>.</p>

<p>The score of the string is <code>0</code> if no characters are removed from the string <code>t</code>, otherwise:</p>

<ul>
	<li>Let <code>left</code> be the minimum index among all removed characters.</li>
	<li>Let <code>right</code> be the maximum index among all removed characters.</li>
</ul>

<p>Then the score of the string is <code>right - left + 1</code>.</p>

<p>Return <em>the minimum possible score to make </em><code>t</code><em>&nbsp;a subsequence of </em><code>s</code><em>.</em></p>

<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abacaba&quot;, t = &quot;bzaa&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, we remove the character &quot;z&quot; at index 1 (0-indexed).
The string t becomes &quot;baa&quot; which is a subsequence of the string &quot;abacaba&quot; and the score is 1 - 1 + 1 = 1.
It can be proven that 1 is the minimum score that we can achieve.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cde&quot;, t = &quot;xyz&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we remove characters &quot;x&quot;, &quot;y&quot; and &quot;z&quot; at indices 0, 1, and 2 (0-indexed).
The string t becomes &quot;&quot; which is a subsequence of the string &quot;cde&quot; and the score is 2 - 0 + 1 = 3.
It can be proven that 3 is the minimum score that we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-272">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/successful-pairs-of-spells-and-potions/description" target="_blank" rel="noopener noreferrer">Successful Pairs of Spells and Potions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p>

<p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p>

<p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> spells = [5,1,3], potions = [1,2,3,4,5], success = 7
<strong>Output:</strong> [4,0,3]
<strong>Explanation:</strong>
- 0<sup>th</sup> spell: 5 * [1,2,3,4,5] = [5,<u><strong>10</strong></u>,<u><strong>15</strong></u>,<u><strong>20</strong></u>,<u><strong>25</strong></u>]. 4 pairs are successful.
- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2<sup>nd</sup> spell: 3 * [1,2,3,4,5] = [3,6,<u><strong>9</strong></u>,<u><strong>12</strong></u>,<u><strong>15</strong></u>]. 3 pairs are successful.
Thus, [4,0,3] is returned.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> spells = [3,1,2], potions = [8,5,8], success = 16
<strong>Output:</strong> [2,0,2]
<strong>Explanation:</strong>
- 0<sup>th</sup> spell: 3 * [8,5,8] = [<u><strong>24</strong></u>,15,<u><strong>24</strong></u>]. 2 pairs are successful.
- 1<sup>st</sup> spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2<sup>nd</sup> spell: 2 * [8,5,8] = [<strong><u>16</u></strong>,10,<u><strong>16</strong></u>]. 2 pairs are successful. 
Thus, [2,0,2] is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == spells.length</code></li>
	<li><code>m == potions.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-273">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-floored-pairs/description" target="_blank" rel="noopener noreferrer">Sum of Floored Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return the sum of <code>floor(nums[i] / nums[j])</code> for all pairs of indices <code>0 &lt;= i, j &lt; nums.length</code> in the array. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>The <code>floor()</code> function returns the integer part of the division.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,5,9]
<strong>Output:</strong> 10
<strong>Explanation:</strong>
floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
floor(5 / 2) = 2
floor(9 / 2) = 4
floor(9 / 5) = 1
We calculate the floor of the division for every pair of indices in the array then sum them up.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,7,7,7,7,7,7]
<strong>Output:</strong> 49
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-274">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-mutated-array-closest-to-target/description" target="_blank" rel="noopener noreferrer">Sum of Mutated Array Closest to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>arr</code> and a target value <code>target</code>, return the integer <code>value</code> such that when we change all the integers larger than <code>value</code> in the given array to be equal to <code>value</code>, the sum of the array gets as close as possible (in absolute difference) to <code>target</code>.</p>

<p>In case of a tie, return the minimum such integer.</p>

<p>Notice that the answer is not neccesarilly a number from <code>arr</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,9,3], target = 10
<strong>Output:</strong> 3
<strong>Explanation:</strong> When using 3 arr converts to [3, 3, 3] which sums 9 and that&#39;s the optimal answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,3,5], target = 10
<strong>Output:</strong> 5
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [60864,25176,27249,21296,20204], target = 56803
<strong>Output:</strong> 11361
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= arr[i], target &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-275">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-scores-of-built-strings/description" target="_blank" rel="noopener noreferrer">Sum of Scores of Built Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">suffix array</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are <strong>building</strong> a string <code>s</code> of length <code>n</code> <strong>one</strong> character at a time, <strong>prepending</strong> each new character to the <strong>front</strong> of the string. The strings are labeled from <code>1</code> to <code>n</code>, where the string with length <code>i</code> is labeled <code>s<sub>i</sub></code>.</p>

<ul>
	<li>For example, for <code>s = &quot;abaca&quot;</code>, <code>s<sub>1</sub> == &quot;a&quot;</code>, <code>s<sub>2</sub> == &quot;ca&quot;</code>, <code>s<sub>3</sub> == &quot;aca&quot;</code>, etc.</li>
</ul>

<p>The <strong>score</strong> of <code>s<sub>i</sub></code> is the length of the <strong>longest common prefix</strong> between <code>s<sub>i</sub></code> and <code>s<sub>n</sub></code> (Note that <code>s == s<sub>n</sub></code>).</p>

<p>Given the final string <code>s</code>, return<em> the <strong>sum</strong> of the <strong>score</strong> of every </em><code>s<sub>i</sub></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;babab&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong>
For s<sub>1</sub> == &quot;b&quot;, the longest common prefix is &quot;b&quot; which has a score of 1.
For s<sub>2</sub> == &quot;ab&quot;, there is no common prefix so the score is 0.
For s<sub>3</sub> == &quot;bab&quot;, the longest common prefix is &quot;bab&quot; which has a score of 3.
For s<sub>4</sub> == &quot;abab&quot;, there is no common prefix so the score is 0.
For s<sub>5</sub> == &quot;babab&quot;, the longest common prefix is &quot;babab&quot; which has a score of 5.
The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;azbazbzaz&quot;
<strong>Output:</strong> 14
<strong>Explanation:</strong> 
For s<sub>2</sub> == &quot;az&quot;, the longest common prefix is &quot;az&quot; which has a score of 2.
For s<sub>6</sub> == &quot;azbzaz&quot;, the longest common prefix is &quot;azb&quot; which has a score of 3.
For s<sub>9</sub> == &quot;azbazbzaz&quot;, the longest common prefix is &quot;azbazbzaz&quot; which has a score of 9.
For all other s<sub>i</sub>, the score is 0.
The sum of the scores is 2 + 3 + 9 = 14, so we return 14.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-276">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-square-numbers/description" target="_blank" rel="noopener noreferrer">Sum of Square Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a non-negative integer <code>c</code>, decide whether there&#39;re two integers <code>a</code> and <code>b</code> such that <code>a<sup>2</sup> + b<sup>2</sup> = c</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> c = 5
<strong>Output:</strong> true
<strong>Explanation:</strong> 1 * 1 + 2 * 2 = 5
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> c = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p>The simplest solution would be to consider every possible combination of integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> and check if the sum of their squares equals <span class="math inline">\(c\)</span>. Now, both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> can lie within the range <span class="math inline">\((0,\sqrt{c})\)</span>. Thus, we need to check for the values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in this range only.</p>
<p><a href="https://leetcode.com/playground/bun3d8ez/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(c)\)</span>.</p>
<p>Two loops up to <span class="math inline">\(\sqrt{c}\)</span>. Here, <span class="math inline">\(c\)</span> refers to the given integer (sum of squares).</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant extra space is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force">Approach 2: Better Brute Force</h3>
<p>We can improve the last solution, if we make the following observation. For any particular <span class="math inline">\(a\)</span> chosen, the value of <span class="math inline">\(b\)</span> required to satisfy the equation <span class="math inline">\(a^2 + b^2 = c\)</span> will be such that <span class="math inline">\(b^2 = c - a^2\)</span>. Thus, we need to traverse over the range <span class="math inline">\((0, \sqrt{c})\)</span> only for considering the various values of <span class="math inline">\(a\)</span>. For every current value of <span class="math inline">\(a\)</span> chosen, we can determine the corresponding <span class="math inline">\(b^2\)</span> value and check if it is a perfect square or not. If it happens to be a perfect square, <span class="math inline">\(c\)</span> is a sum of squares of two integers, otherwise not.</p>
<p>Now, to determine, if the number <span class="math inline">\(c - a^2\)</span> is a perfect square or not, we can make use of the following theorem:</p>
<blockquote>
<p>The square of <span class="math inline">\(n^{th}\)</span> positive integer can be represented as a sum of first <span class="math inline">\(n\)</span> odd positive integers.</p>
</blockquote>
<p>Or in mathematical terms:</p>
<p><span class="math display">\[n^2 = 1 + 3 + 5 + ... + (2 \cdot n-1) = \sum_{i=1}^{n} (2 \cdot i - 1)
\]</span></p>
<p>To look at the proof of this statement, look at the L.H.S. of the above statement.</p>
<p><span class="math display">\[\begin{aligned}
&1 + 3 + 5 + \ldots + (2 \cdot n-1) \\
= \; &(2 \cdot 1-1) + (2 \cdot 2-1) + (2 \cdot 3-1) + \ldots + (2 \cdot n-1) \\
= \; &2 \cdot (1+2+3+....+n) - (\underbrace{1+1+ \ldots +1}_{n\text{ times}}) \\
= \; &2 \cdot \frac{n\;(n+1)}{2} - n \\
= \; &n\;(n+1) - n \\
= \; &n^2 + n - n \\
= \; &n^2
\end{aligned}
\]</span></p>
<p>This completes the proof of the above statement.</p>
<p><a href="https://leetcode.com/playground/ZTefZRX8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(c)\)</span>.</p>
<p>The total number of times the <span class="math inline">\(sum\)</span> is updated is: <span class="math inline">\(1 + 2 + 3 + \ldots + \sqrt{c} = \frac{\sqrt{c}\;(\sqrt{c}+1)}{2} = O(c)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant extra space is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-sqrt-function">Approach 3: Using Sqrt Function</h3>
<p><strong>Algorithm</strong></p>
<p>Instead of finding if <span class="math inline">\(c - a^2\)</span> is a perfect square using sum of odd numbers, as done in the last approach, we can make use of the inbuilt <span class="math inline">\(sqrt\)</span> function and check if <span class="math inline">\(\sqrt{c - a^2}\)</span> turns out to be an integer. If it happens for any value of <span class="math inline">\(a\)</span> in the range <span class="math inline">\([0, \sqrt{c}]\)</span>, we can return a True value immediately.</p>
<p><a href="https://leetcode.com/playground/N9KMxCjz/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\big(\sqrt{c}\log c\big)\)</span>.</p>
<p>We iterate over <span class="math inline">\(\sqrt{c}\)</span> values for choosing <span class="math inline">\(a\)</span>. For every <span class="math inline">\(a\)</span> chosen, finding square root of <span class="math inline">\(c - a^2\)</span> takes <span class="math inline">\(O\big(\log c\big)\)</span> time in the worst case.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant extra space is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-binary-search">Approach 4: Binary Search</h3>
<p><strong>Algorithm</strong></p>
<p>Another method to check if <span class="math inline">\(c - a^2\)</span> is a perfect square, is by making use of Binary Search. The method remains same as that of a typical Binary Search to find a number.<br />
The only difference lies in that we need to find an integer, <span class="math inline">\(mid\)</span> in the range <span class="math inline">\([0, c - a^2]\)</span>, such that this number is the square root of <span class="math inline">\(c - a^2\)</span>.<br />
Or in other words, we need to find an integer, <span class="math inline">\(mid\)</span>, in the range <span class="math inline">\([0, c - a^2]\)</span>, such that <span class="math inline">\(mid \times mid = c - a^2\)</span>.</p>
<p>The following animation illustrates the search process for a particular value of <span class="math inline">\(c - a^2 = 36\)</span>.</p>
<p>!?!../Documents/633_Sum_of_Squares.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/6o4MgefR/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\big(\sqrt{c}\log c\big)\)</span>.<br />
Binary search taking <span class="math inline">\(O\big(\log c\big)\)</span> in the worst case is done for <span class="math inline">\(\sqrt{c}\)</span> values of <span class="math inline">\(a\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\log c)\)</span>. Binary Search will take <span class="math inline">\(O(\log c)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-fermat-theorem">Approach 5: Fermat Theorem</h3>
<p><strong>Algorithm</strong></p>
<p>This approach is based on the following statement, which is based on Fermat's Theorem:</p>
<blockquote>
<p>Any positive number <span class="math inline">\(n\)</span> is expressible as a sum of two squares if and only if the prime factorization of <span class="math inline">\(n\)</span>, every prime of the form <span class="math inline">\((4k+3)\)</span> occurs an even number of times.</p>
</blockquote>
<p>By making use of the above theorem, we can directly find out if the given number <span class="math inline">\(c\)</span> can be expressed as a sum of two squares.</p>
<p>To do so we simply find all the prime factors of the given number <span class="math inline">\(c\)</span>, which could range from <span class="math inline">\([2,\sqrt{c}]\)</span> along with the count of those factors, by repeated division.<br />
If at any step, we find out that the number of occurrences of any prime factor of the form <span class="math inline">\((4k+3)\)</span> occurs an odd number of times, we can return a False value.</p>
<p>In case, <span class="math inline">\(c\)</span> itself is a prime number, it won't be divisible by any of the primes in the <span class="math inline">\([2,\sqrt{c}]\)</span>. Thus, we need to check if <span class="math inline">\(c\)</span> can be expressed in the form of<br />
<span class="math inline">\(4k+3\)</span>. If so, we need to return a False value, indicating that this prime occurs an odd number(1) of times.</p>
<p>Otherwise, we can return a True value.</p>
<p>The proof of this theorem includes the knowledge of advanced mathematics and is beyond the scope of this article. However, interested reader can refer to <a href="http://wstein.org/edu/124/lectures/lecture21/lecture21/node2.html">this</a> documentation.</p>
<p><a href="https://leetcode.com/playground/j4TXamHq/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\left(\sqrt{c}\right)\)</span>.</p>
<p>We find the factors of <span class="math inline">\(c\)</span> and their count using repeated division. We check for the factors in the range <span class="math inline">\([0, \sqrt{c}]\)</span>.</p>
<p>However, the number of times a factor can occur is spread over the entire outer loop, so the entire complexity caused by the inner loop is effectively <span class="math inline">\(O(\log c)\)</span>. As a result, the total time complexity is <span class="math inline">\(O(\sqrt{c} + \log c) = O\left(\sqrt{c}\right)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant space is used.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-277">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/super-egg-drop/description" target="_blank" rel="noopener noreferrer">Super Egg Drop</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>k</code> identical eggs and you have access to a building with <code>n</code> floors labeled from <code>1</code> to <code>n</code>.</p>

<p>You know that there exists a floor <code>f</code> where <code>0 &lt;= f &lt;= n</code> such that any egg dropped at a floor <strong>higher</strong> than <code>f</code> will <strong>break</strong>, and any egg dropped <strong>at or below</strong> floor <code>f</code> will <strong>not break</strong>.</p>

<p>Each move, you may take an unbroken egg and drop it from any floor <code>x</code> (where <code>1 &lt;= x &lt;= n</code>). If the egg breaks, you can no longer use it. However, if the egg does not break, you may <strong>reuse</strong> it in future moves.</p>

<p>Return <em>the <strong>minimum number of moves</strong> that you need to determine <strong>with certainty</strong> what the value of </em><code>f</code> is.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> k = 1, n = 2
<strong>Output:</strong> 2
<strong>Explanation: </strong>
Drop the egg from floor 1. If it breaks, we know that f = 0.
Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1.
If it does not break, then we know f = 2.
Hence, we need at minimum 2 moves to determine with certainty what the value of f is.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> k = 2, n = 6
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> k = 3, n = 14
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= 100</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-278">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swim-in-rising-water/description" target="_blank" rel="noopener noreferrer">Swim in Rising Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p>

<p>It starts raining, and water gradually rises over time. At time <code>t</code>, the water level is <code>t</code>, meaning <strong>any</strong> cell with elevation less than equal to <code>t</code> is submerged or reachable.</p>

<p>You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>

<p>Return <em>the minimum time until you can reach the bottom right square </em><code>(n - 1, n - 1)</code><em> if you start at the top left square </em><code>(0, 0)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[0,2],[1,3]]
<strong>Output:</strong> 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg" style="width: 404px; height: 405px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
<strong>Output:</strong> 16
<strong>Explanation:</strong> The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>
	<li>Each value <code>grid[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-279">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-k-weakest-rows-in-a-matrix/description" target="_blank" rel="noopener noreferrer">The K Weakest Rows in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>mat</code> of <code>1</code>&#39;s (representing soldiers) and <code>0</code>&#39;s (representing civilians). The soldiers are positioned <strong>in front</strong> of the civilians. That is, all the <code>1</code>&#39;s will appear to the <strong>left</strong> of all the <code>0</code>&#39;s in each row.</p>

<p>A row <code>i</code> is <strong>weaker</strong> than a row <code>j</code> if one of the following is true:</p>

<ul>
	<li>The number of soldiers in row <code>i</code> is less than the number of soldiers in row <code>j</code>.</li>
	<li>Both rows have the same number of soldiers and <code>i &lt; j</code>.</li>
</ul>

<p>Return <em>the indices of the </em><code>k</code><em> <strong>weakest</strong> rows in the matrix ordered from weakest to strongest</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
<strong>Output:</strong> [2,0,3]
<strong>Explanation:</strong> 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5 
The rows ordered from weakest to strongest are [2,0,3,1,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
<strong>Output:</strong> [0,2]
<strong>Explanation:</strong> 
The number of soldiers in each row is: 
- Row 0: 1 
- Row 1: 4 
- Row 2: 1 
- Row 3: 1 
The rows ordered from weakest to strongest are [0,2,3,1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>2 &lt;= n, m &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= m</code></li>
	<li><code>matrix[i][j]</code> is either 0 or 1.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-280">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-latest-time-to-catch-a-bus/description" target="_blank" rel="noopener noreferrer">The Latest Time to Catch a Bus</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>buses</code> of length <code>n</code>, where <code>buses[i]</code> represents the departure time of the <code>i<sup>th</sup></code> bus. You are also given a <strong>0-indexed</strong> integer array <code>passengers</code> of length <code>m</code>, where <code>passengers[j]</code> represents the arrival time of the <code>j<sup>th</sup></code> passenger. All bus departure times are unique. All passenger arrival times are unique.</p>

<p>You are given an integer <code>capacity</code>, which represents the <strong>maximum</strong> number of passengers that can get on each bus.</p>

<p>When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at <code>x</code> minutes if you arrive at <code>y</code> minutes where <code>y &lt;= x</code>, and the bus is not full. Passengers with the <strong>earliest</strong> arrival times get on the bus first.</p>

<p>More formally when a bus arrives, either:</p>

<ul>
	<li>If <code>capacity</code> or fewer passengers are waiting for a bus, they will <strong>all</strong> get on the bus, or</li>
	<li>The <code>capacity</code> passengers with the <strong>earliest</strong> arrival times will get on the bus.</li>
</ul>

<p>Return <em>the latest time you may arrive at the bus station to catch a bus</em>. You <strong>cannot</strong> arrive at the same time as another passenger.</p>

<p><strong>Note: </strong>The arrays <code>buses</code> and <code>passengers</code> are not necessarily sorted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> buses = [10,20], passengers = [2,17,18,19], capacity = 2
<strong>Output:</strong> 16
<strong>Explanation:</strong> Suppose you arrive at time 16.
At time 10, the first bus departs with the 0<sup>th</sup> passenger. 
At time 20, the second bus departs with you and the 1<sup>st</sup> passenger.
Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1<sup>st</sup> passenger to catch the bus.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
<strong>Output:</strong> 20
<strong>Explanation:</strong> Suppose you arrive at time 20.
At time 10, the first bus departs with the 3<sup>rd</sup> passenger. 
At time 20, the second bus departs with the 5<sup>th</sup> and 1<sup>st</sup> passengers.
At time 30, the third bus departs with the 0<sup>th</sup> passenger and you.
Notice if you had arrived any later, then the 6<sup>th</sup> passenger would have taken your seat on the third bus.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == buses.length</code></li>
	<li><code>m == passengers.length</code></li>
	<li><code>1 &lt;= n, m, capacity &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= buses[i], passengers[i] &lt;= 10<sup>9</sup></code></li>
	<li>Each element in <code>buses</code> is <strong>unique</strong>.</li>
	<li>Each element in <code>passengers</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-281">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/the-problem-of-identical-arrays3229/1" target="_blank" rel="noopener noreferrer">The problem of identical arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Check whether given two arrays <strong>a[]</strong>&nbsp;and <strong>b[] </strong>are identical or not. Two arrays are called identical arrays if they contain the same element with the same count, regardless of the order of elements.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> a[] = [1, 2, 3, 4, 5], b[] = [3, 4, 1, 2, 5]
<strong>Output:</strong> true
<strong>Explanation: </strong>Here we can see array a[] = [1, 2, 3, 4, 5] and b[] = [3, 4, 1, 2, 5]. If we look both the array then we can get that array b[] is the permutation of a[]. So, both array.are identical. </span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> a[] = [1, 2, 4], b[] = [3, 2, 1]
<strong>Output:</strong> false
<strong>Explanation: </strong>Here we can see that, missing 4 in array b and has 3 so they are not identical.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; a.size(), b.size() &le; 10<sup>5<br /></sup>a.size() = b.size()<br />1 &le; a[i], b[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-282">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/three-machines/1" target="_blank" rel="noopener noreferrer">Three machines</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">There are <strong>three </strong>machines in Geekland. You are supposed to execute <strong>N </strong>jobs on them. Before executing any job you need to set the <strong>capacity </strong>of each machines, which once set <strong>cannot be reset</strong>. Capacities of machines need <strong>not </strong>be same. Each machine can work on <strong>many </strong>jobs simultaneously. Each job comes with a value called <strong>units of work</strong>, which is an <strong>integer</strong> value. Time taken by a machine of capacity <strong>c</strong> to execute a job with <strong>w</strong> units of work is <strong>|c-w|</strong>. </span></p>
<p><span style="font-size: 14pt;">You are the machine operator of these machines and you need to decide the capacities of all the three machines such that you complete all the jobs in <strong>minimum time</strong> possible. Capacities of the machines should be <strong>integer </strong>values.</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong><br /></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong><br /></span><span style="font-size: 14pt;">N = 10</span><br /><span style="font-size: 14pt;">jobs = {1,4,16,16,19,20,1,19,12,10}</span><br /><strong><span style="font-size: 14pt;">Output:</span></strong><br /><span style="font-size: 14pt;">2</span><br /><strong><span style="font-size: 14pt;">Explanation:</span></strong><br /><span style="font-size: 14pt;">First machine has capacity of 3 and does jobs with units of work 1,1 and 4. Time take by this machine will be max(|3-1|,|3-1|,|3-4|), which is 2.</span><br /><span style="font-size: 14pt;">Second </span><span style="font-size: 18.6667px;">machine has capacity of 11 and does jobs with units of work 10 and 12. Time take by this machine will be max(|11-10|,|11-12|), which is 1.</span><br /><span style="font-size: 18.6667px;">Third </span><span style="font-size: 18.6667px;">machine has capacity of 18 and does jobs with units of work 16,16,19,19 and 20. Time take by this machine will be max(|18-16|,</span><span style="font-size: 18.6667px;">|18-16|,</span><span style="font-size: 18.6667px;">|18-19|,</span><span style="font-size: 18.6667px;">|18-19|,</span><span style="font-size: 18.6667px;">|18-20|), which is 2.</span><br /><span style="font-size: 18.6667px;">So overall three machines cal complete 10 jobs in minimum 2 units of time. It can be proven than answer smaller than 2 is not possible.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Example 2:</span></strong></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong><br /></span><span style="font-size: 14pt;">N = 4</span><br /><span style="font-size: 14pt;">jobs = {6,6,14,15}</span><br /><strong><span style="font-size: 14pt;">Output:</span></strong><br /><span style="font-size: 14pt;">0</span><br /><strong><span style="font-size: 14pt;">Explanation:</span></strong><br /><span style="font-size: 18.6667px;">The capacities of the machines are 6, 14 and 15. First machine does first two jobs in 0 time. Second machine does third job in 0 time. And third machine completes last job in 0 time. So it takes 0 time to complete all the jobs.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong>&nbsp;&nbsp;<br />You don't need to read input or print anything. Complete the function&nbsp;<strong>minTime()</strong>&nbsp;which takes vector <strong>jobs </strong>and <strong>N</strong> as input and returns minimum number of time to complete all N jobs.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 10<sup>5</sup><br />1 &le; jobs<sub>i</sub> &le; 10<sup>9</sup><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-283">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/threshold-majority-queries/description" target="_blank" rel="noopener noreferrer">Threshold Majority Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and an array <code>queries</code>, where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>, threshold<sub>i</sub>]</code>.</p>

<p>Return an array of integers <code data-end="33" data-start="28">ans</code> where <code data-end="48" data-start="40">ans[i]</code> is equal to the element in the subarray <code data-end="102" data-start="89">nums[l<sub>i</sub>...r<sub>i</sub>]</code> that appears <strong>at least</strong> <code data-end="137" data-start="125">threshold<sub>i</sub></code> times, selecting the element with the <strong>highest</strong> frequency (choosing the <strong>smallest</strong> in case of a tie), or -1 if no such element <em>exists</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2,2,1,1], queries = [[0,5,4],[0,3,3],[2,3,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1,2]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="left" style="border: 1px solid black;">Query</th>
			<th align="left" style="border: 1px solid black;">Sub-array</th>
			<th align="left" style="border: 1px solid black;">Threshold</th>
			<th align="left" style="border: 1px solid black;">Frequency table</th>
			<th align="left" style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 5, 4]</td>
			<td align="left" style="border: 1px solid black;">[1, 1, 2, 2, 1, 1]</td>
			<td align="left" style="border: 1px solid black;">4</td>
			<td align="left" style="border: 1px solid black;">1 &rarr; 4, 2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 3, 3]</td>
			<td align="left" style="border: 1px solid black;">[1, 1, 2, 2]</td>
			<td align="left" style="border: 1px solid black;">3</td>
			<td align="left" style="border: 1px solid black;">1 &rarr; 2, 2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">-1</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[2, 3, 2]</td>
			<td align="left" style="border: 1px solid black;">[2, 2]</td>
			<td align="left" style="border: 1px solid black;">2</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,2,3,2,3,2,3], queries = [[0,6,4],[1,5,2],[2,4,1],[3,3,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,3,2]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="left" style="border: 1px solid black;">Query</th>
			<th align="left" style="border: 1px solid black;">Sub-array</th>
			<th align="left" style="border: 1px solid black;">Threshold</th>
			<th align="left" style="border: 1px solid black;">Frequency table</th>
			<th align="left" style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 6, 4]</td>
			<td align="left" style="border: 1px solid black;">[3, 2, 3, 2, 3, 2, 3]</td>
			<td align="left" style="border: 1px solid black;">4</td>
			<td align="left" style="border: 1px solid black;">3 &rarr; 4, 2 &rarr; 3</td>
			<td align="left" style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[1, 5, 2]</td>
			<td align="left" style="border: 1px solid black;">[2, 3, 2, 3, 2]</td>
			<td align="left" style="border: 1px solid black;">2</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 3, 3 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[2, 4, 1]</td>
			<td align="left" style="border: 1px solid black;">[3, 2, 3]</td>
			<td align="left" style="border: 1px solid black;">1</td>
			<td align="left" style="border: 1px solid black;">3 &rarr; 2, 2 &rarr; 1</td>
			<td align="left" style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[3, 3, 1]</td>
			<td align="left" style="border: 1px solid black;">[2]</td>
			<td align="left" style="border: 1px solid black;">1</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 1</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="51" data-start="19"><code data-end="49" data-start="19">1 &lt;= nums.length == n &lt;= 10<sup>4</sup></code></li>
	<li data-end="82" data-start="54"><code data-end="80" data-start="54">1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li data-end="120" data-start="85"><code data-end="118" data-start="85">1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="195" data-start="123"><code data-end="193" data-is-only-node="" data-start="155">queries[i] = [l<sub>i</sub>, r<sub>i</sub>, threshold<sub>i</sub>]</code></li>
	<li data-end="221" data-start="198"><code data-end="219" data-start="198">0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; n</code></li>
	<li data-end="259" data-is-last-node="" data-start="224"><code data-end="259" data-is-last-node="" data-start="224">1 &lt;= threshold<sub>i</sub> &lt;= r<sub>i</sub> - l<sub>i</sub> + 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-284">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/time-based-key-value-store/description" target="_blank" rel="noopener noreferrer">Time Based Key-Value Store</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&#39;s value at a certain timestamp.</p>

<p>Implement the <code>TimeMap</code> class:</p>

<ul>
	<li><code>TimeMap()</code> Initializes the object of the data structure.</li>
	<li><code>void set(String key, String value, int timestamp)</code> Stores the key <code>key</code> with the value <code>value</code> at the given time <code>timestamp</code>.</li>
	<li><code>String get(String key, int timestamp)</code> Returns a value such that <code>set</code> was called previously, with <code>timestamp_prev &lt;= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code>timestamp_prev</code>. If there are no values, it returns <code>&quot;&quot;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;TimeMap&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;]
[[], [&quot;foo&quot;, &quot;bar&quot;, 1], [&quot;foo&quot;, 1], [&quot;foo&quot;, 3], [&quot;foo&quot;, &quot;bar2&quot;, 4], [&quot;foo&quot;, 4], [&quot;foo&quot;, 5]]
<strong>Output</strong>
[null, null, &quot;bar&quot;, &quot;bar&quot;, null, &quot;bar2&quot;, &quot;bar2&quot;]

<strong>Explanation</strong>
TimeMap timeMap = new TimeMap();
timeMap.set(&quot;foo&quot;, &quot;bar&quot;, 1);  // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1.
timeMap.get(&quot;foo&quot;, 1);         // return &quot;bar&quot;
timeMap.get(&quot;foo&quot;, 3);         // return &quot;bar&quot;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is &quot;bar&quot;.
timeMap.set(&quot;foo&quot;, &quot;bar2&quot;, 4); // store the key &quot;foo&quot; and value &quot;bar2&quot; along with timestamp = 4.
timeMap.get(&quot;foo&quot;, 4);         // return &quot;bar2&quot;
timeMap.get(&quot;foo&quot;, 5);         // return &quot;bar2&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= key.length, value.length &lt;= 100</code></li>
	<li><code>key</code> and <code>value</code> consist of lowercase English letters and digits.</li>
	<li><code>1 &lt;= timestamp &lt;= 10<sup>7</sup></code></li>
	<li>All the timestamps <code>timestamp</code> of <code>set</code> are strictly increasing.</li>
	<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>set</code> and <code>get</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-285">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/tweet-counts-per-frequency/description" target="_blank" rel="noopener noreferrer">Tweet Counts Per Frequency</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller <strong>time chunks</strong> based on a certain frequency (every <strong>minute</strong>, <strong>hour</strong>, or <strong>day</strong>).</p>

<p>For example, the period <code>[10, 10000]</code> (in <strong>seconds</strong>) would be partitioned into the following <strong>time chunks</strong> with these frequencies:</p>

<ul>
	<li>Every <strong>minute</strong> (60-second chunks): <code>[10,69]</code>, <code>[70,129]</code>, <code>[130,189]</code>, <code>...</code>, <code>[9970,10000]</code></li>
	<li>Every <strong>hour</strong> (3600-second chunks): <code>[10,3609]</code>, <code>[3610,7209]</code>, <code>[7210,10000]</code></li>
	<li>Every <strong>day</strong> (86400-second chunks): <code>[10,10000]</code></li>
</ul>

<p>Notice that the last chunk may be shorter than the specified frequency&#39;s chunk size and will always end with the end time of the period (<code>10000</code> in the above example).</p>

<p>Design and implement an API to help the company with their analysis.</p>

<p>Implement the <code>TweetCounts</code> class:</p>

<ul>
	<li><code>TweetCounts()</code> Initializes the <code>TweetCounts</code> object.</li>
	<li><code>void recordTweet(String tweetName, int time)</code> Stores the <code>tweetName</code> at the recorded <code>time</code> (in <strong>seconds</strong>).</li>
	<li><code>List&lt;Integer&gt; getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)</code> Returns a list of integers representing the number of tweets with <code>tweetName</code> in each <strong>time chunk</strong> for the given period of time <code>[startTime, endTime]</code> (in <strong>seconds</strong>) and frequency <code>freq</code>.
	<ul>
		<li><code>freq</code> is one of <code>&quot;minute&quot;</code>, <code>&quot;hour&quot;</code>, or <code>&quot;day&quot;</code> representing a frequency of every <strong>minute</strong>, <strong>hour</strong>, or <strong>day</strong> respectively.</li>
	</ul>
	</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example:</strong></p>

<pre>
<strong>Input</strong>
[&quot;TweetCounts&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;]
[[],[&quot;tweet3&quot;,0],[&quot;tweet3&quot;,60],[&quot;tweet3&quot;,10],[&quot;minute&quot;,&quot;tweet3&quot;,0,59],[&quot;minute&quot;,&quot;tweet3&quot;,0,60],[&quot;tweet3&quot;,120],[&quot;hour&quot;,&quot;tweet3&quot;,0,210]]

<strong>Output</strong>
[null,null,null,null,[2],[2,1],null,[4]]

<strong>Explanation</strong>
TweetCounts tweetCounts = new TweetCounts();
tweetCounts.recordTweet(&quot;tweet3&quot;, 0);                              // New tweet &quot;tweet3&quot; at time 0
tweetCounts.recordTweet(&quot;tweet3&quot;, 60);                             // New tweet &quot;tweet3&quot; at time 60
tweetCounts.recordTweet(&quot;tweet3&quot;, 10);                             // New tweet &quot;tweet3&quot; at time 10
tweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 59); // return [2]; chunk [0,59] had 2 tweets
tweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet
tweetCounts.recordTweet(&quot;tweet3&quot;, 120);                            // New tweet &quot;tweet3&quot; at time 120
tweetCounts.getTweetCountsPerFrequency(&quot;hour&quot;, &quot;tweet3&quot;, 0, 210);  // return [4]; chunk [0,210] had 4 tweets
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= time, startTime, endTime &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= endTime - startTime &lt;= 10<sup>4</sup></code></li>
	<li>There will be at most <code>10<sup>4</sup></code> calls <strong>in total</strong> to <code>recordTweet</code> and <code>getTweetCountsPerFrequency</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-286">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/two-best-non-overlapping-events/description" target="_blank" rel="noopener noreferrer">Two Best Non-Overlapping Events</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array of <code>events</code> where <code>events[i] = [startTime<sub>i</sub>, endTime<sub>i</sub>, value<sub>i</sub>]</code>. The <code>i<sup>th</sup></code> event starts at <code>startTime<sub>i</sub></code><sub> </sub>and ends at <code>endTime<sub>i</sub></code>, and if you attend this event, you will receive a value of <code>value<sub>i</sub></code>. You can choose <strong>at most</strong> <strong>two</strong> <strong>non-overlapping</strong> events to attend such that the sum of their values is <strong>maximized</strong>.</p>

<p>Return <em>this <strong>maximum</strong> sum.</em></p>

<p>Note that the start time and end time is <strong>inclusive</strong>: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time <code>t</code>, the next event must start at or after <code>t + 1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/21/picture5.png" style="width: 400px; height: 75px;" />
<pre>
<strong>Input:</strong> events = [[1,3,2],[4,5,2],[2,4,3]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="Example 1 Diagram" src="https://assets.leetcode.com/uploads/2021/09/21/picture1.png" style="width: 400px; height: 77px;" />
<pre>
<strong>Input:</strong> events = [[1,3,2],[4,5,2],[1,5,5]]
<strong>Output:</strong> 5
<strong>Explanation: </strong>Choose event 2 for a sum of 5.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/21/picture3.png" style="width: 400px; height: 66px;" />
<pre>
<strong>Input:</strong> events = [[1,5,3],[1,5,1],[6,6,5]]
<strong>Output:</strong> 8
<strong>Explanation: </strong>Choose events 0 and 2 for a sum of 3 + 5 = 8.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= events.length &lt;= 10<sup>5</sup></code></li>
	<li><code>events[i].length == 3</code></li>
	<li><code>1 &lt;= startTime<sub>i</sub> &lt;= endTime<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= value<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D integer array of events where each event starts at <code>startTime</code>, ends at <code>endTime</code>, and pays a <code>value</code> if attended. Return the maximum profit possible from picking up to 2 non-overlapping events.</p>
<blockquote>
<p>Note: The start time and end time are inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time.</p>
</blockquote>
<hr />
<h3 id="approach-1-top-down-dynamic-programming">Approach 1: Top-down Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Observe that for each event, we have two choices: attend the event or skip it. Given this binary decision structure at each step, we can use recursion to solve the problem. At each event, we recursively evaluate both options: attend the event and move to the next valid event (skipping overlapping ones), or skip the current event and move to the next. By combining the results of these subproblems, we can determine the maximum value achievable. However, the problem constraints allow us to solve it in linear or log-linear time complexity.</p>
<p>How many independent subproblems or recursive states do we have in this problem? Assuming for an index <code>i</code>, we have <code>3</code> possibilities: 0, 1, or 2 events picked. Therefore, the total number of subproblems remains limited to <span class="math inline">\(n \cdot 3\)</span>. In every recursive iteration, we have three choices. Therefore, for a sequence of <code>n</code> iterations, there are a total of <code>3^n</code> possible choices. This number is significantly greater than the actual number of unique subproblems, as many calculations are redundant. These redundant calculations can be optimized by caching their results.</p>
<p>To achieve this, we can create a <code>memo</code> matrix to store the results of these computations. Specifically, <code>memo[index][k]</code> stores the solution to the subproblem where we are at <code>index</code> and have picked <code>k</code> events so far. This technique is known as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>, and it helps us avoid recalculating repeated subproblems.</p>
<p>Once we select an event, we need to identify non-overlapping events that we can move to next.</p>
<p>One way to handle this is by first sorting the array of events based on their starting times. For the current <code>index</code> in the recursion, we can efficiently find the next valid event (one whose start time is greater than the current event's end time) by using binary search. Since the array is sorted by <code>start</code>, binary search allows us to jump to the next valid event with the smallest starting time just greater than the current event's ending time.</p>
<p>The recursive function should receive the current event index, <code>idx</code>, and a count, <code>cnt</code>, representing the number of events selected so far.</p>
<ul>
<li>If two events have already been selected <code>(cnt == 2)</code> or if all events have been processed (<code>idx</code> is out of bounds), it returns 0, as no further events can be selected.</li>
<li>For each event at index <code>idx</code>, the function computes two possible outcomes: including the current event in the selection or excluding it.
<ul>
<li>If the current event is included, a binary search is performed to find the next event that starts after the current event's end time. The result of including the event is the sum of the event's value and the recursive result of selecting the next event, incrementing the count of selected events.</li>
<li>Otherwise, we exclude the current event and call the recursive function on the next index.<br />
The recurrence chooses the maximum value between including or excluding the current event, which is then stored in the <code>dp</code> table to avoid redundant calculations. The result for a given state <code>(idx, cnt)</code> is thus the maximum of either selecting or skipping the current event, ensuring optimal selection of up to two non-overlapping events.</li>
</ul>
</li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<p>Main Function</p>
<ol>
<li>Determine <code>n</code> as the number of events.</li>
<li>Create a 2D array <code>dp</code> of size <code>n x 3</code>, initialized to -1. <code>dp[idx][k]</code> indicates the maximum value attainable when considering the events starting from index <code>idx</code>, with <code>k</code> events selected so far.</li>
<li>Sort the <code>events</code> array in ascending order by their start times.</li>
<li>Call the function (defined below) with the initial state: <code>findEvents(events, 0, 0, dp)</code></li>
</ol>
<p>Recursive Function - <code>findEvents(events, idx, cnt, dp)</code></p>
<ol>
<li>If <code>cnt</code> equals 2 or <code>idx</code> is out of bounds, return 0.</li>
<li>If <code>dp[idx][cnt]</code> equals <code>-1</code>, compute the result:
<ul>
<li>Let <code>end</code> be the end time of the current event <code>(events[idx][1])</code>.</li>
<li>Perform a binary search on <code>events</code> to find the first event starting after <code>end</code>. Use two pointers, <code>lo</code> and <code>hi</code>:</li>
<li>While <code>lo &lt; hi</code>, calculate <code>mid = lo + ((hi - lo) &gt;&gt; 1)</code>.
<ul>
<li>If <code>events[mid][0] &gt; end</code>, update <code>hi = mid</code>; otherwise, update <code>lo = mid + 1</code>.</li>
</ul>
</li>
<li>Calculate <code>include</code> as the sum of the current event value <code>(events[idx][2])</code> and the result of recursively calling <code>findEvents</code> with <code>lo</code> (if the start time of the event at lo is valid) and <code>cnt + 1</code>.</li>
<li>Calculate <code>exclude</code> as the result of recursively calling findEvents with <code>idx + 1</code> and <code>cnt</code>.</li>
<li>Store the maximum of <code>include</code> and <code>exclude</code> in <code>dp[idx][cnt]</code>.</li>
</ul>
</li>
<li>Return <code>dp[idx][cnt]</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JVD2SUwP/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of events in the <code>events</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The algorithm sorts the array of events by their starting times, which takes <span class="math inline">\(O(n \cdot \log n)\)</span> time. Calculating the maximum value for each event index involves solving recursive subproblems. For each of the <code>n</code> events, we compute the result for <code>3</code> states (0, 1, or 2 elements picked), and finding the next valid event using binary search takes <span class="math inline">\(O(\log n)\)</span> time.</p>
<p>Memoization ensures that each subproblem is solved only once, avoiding redundant computations. Therefore, the overall time complexity is given by <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm requires <span class="math inline">\(O(n)\)</span> space for the <code>memo</code> array, which stores the precomputed values of subproblems to avoid redundant calculations during recursion. Also, the recursion depth contributes <span class="math inline">\(O(n)\)</span> stack space.</p>
<p>Apart from this, the space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and  Insertion Sort and has <span class="math inline">\(O(l)\)</span> additional space, where <code>l</code> is the size of the list.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-min-heap">Approach 2: Min-heap</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we solved the problem recursively by sorting the events in increasing order of their start times. The key observation is that for every event, we need to calculate the potential maximum sum if it's paired with an earlier event. Since we are processing the list in the sorted order of start times, we'd need to store all end times up to the current index in a sorted order, and find the maximum value where the end time is less than the start time. We can use a priority queue (min-heap) that can help us to efficiently track and remove events that end before the current event starts. A priority queue provides efficient access to the highest or lowest priority element, with <span class="math inline">\(O(\log n)\)</span> insertion and deletion operations while maintaining a heap structure.</p>
<p>A <a href="https://leetcode.com/explore/featured/card/heap/">priority queue (min-heap)</a> is used to store events as pairs of <code>(end time, value)</code> so that we can efficiently manage events that might overlap with the current event. Alongside, a variable <code>maxVal</code> tracks the highest value of a single event encountered so far, which is used to calculate the maximum sum when combined with the current event.</p>
<p>As we process each event, we remove all valid events from the priority queue that end before the current event starts, as they are guaranteed not to overlap. While removing these events, we update <code>maxVal</code> to store the highest value of these popped events. For the current event, we calculate the maximum possible sum by adding its value to <code>maxVal</code>, representing the best event that ended before the current event started, and update the <code>maxSum</code> if this sum is greater. The current event is then added to the priority queue to be considered for future combinations.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Create a min-heap (<code>pq</code>) to store pairs of event ending times and their corresponding values.</li>
<li>Sort the <code>events</code> array in ascending order by the start times of the events.</li>
<li>Initialize:
<ul>
<li><code>maxVal</code> as 0 to store the maximum event value encountered so far.</li>
<li><code>maxSum</code> as 0 to store the maximum sum of two non-overlapping event values.</li>
</ul>
</li>
<li>Iterate through the <code>events</code> array:
<ul>
<li>For each <code>event</code>, while the heap is not empty and the ending time of the event at the top of the heap is less than the current event's start time:
<ul>
<li>Update <code>maxVal</code> to the maximum of its current value and the value from the top of the heap.</li>
<li>Remove the top element from the heap.</li>
</ul>
</li>
<li>Update <code>maxSum</code> to the maximum of its current value and the sum of <code>maxVal</code> and the current event's value.</li>
<li>Push the current event's end time and value as a pair into the heap.</li>
</ul>
</li>
<li>Return <code>maxSum</code> as the result after processing all events.</li>
</ul>
<p>!?!../Documents/2054/slideshow.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/4PHBYiVc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of events in the <code>events</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The algorithm sorts the events by their start times, which takes <span class="math inline">\(O(n \cdot \log n)\)</span>. While iterating through the event list, the algorithm performs operations related to the priority queue (min-heap) for each event. Popping from the heap and pushing a new event both take <span class="math inline">\(O(\log n)\)</span>, leading to a total of <span class="math inline">\(O(n \cdot \log n)\)</span> for all these operations.</p>
<p>Combining all steps, the overall time complexity is given by <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm requires <span class="math inline">\(O(n)\)</span> space for the priority queue in the worst case.</p>
<p>Apart from this, the space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(l)\)</span> additional space, where <code>l</code> is the size of the list.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-greedy">Approach 3: Greedy</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Is there a way to find the maximum sum without using a binary search? The problem with previous approaches is that since we can only sort based on either the start time or the end time, we need to use binary search and dynamic programming to find the most optimal values.</p>
<p>To find the best second element without using binary search, we can combine the start and end times into a single array, with a flag to differentiate between them. After sorting this array, with end times processed before start times in case of ties, we can iterate through it sequentially.</p>
<p>During the iteration, we maintain the maximum value of all events that have ended up to the current point. When we encounter a start time, we calculate the maximum sum by adding the current event's value to the maximum value of the previously ended events. This ensures that we efficiently track the best possible combination of non-overlapping events.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize a list <code>times</code> to store tuples containing the event's <code>timeValue</code>, type <code>(start or end)</code>, and <code>value</code>.</li>
<li>Loop through the input events:
<ul>
<li>For each event <code>(start, end, value)</code>, add two tuples to <code>times</code>:
<ul>
<li><code>(start, 1, value)</code> representing the <code>start</code> time of the event.</li>
<li><code>(end + 1, 0, value)</code> representing the <code>end</code> time of the event.</li>
</ul>
</li>
</ul>
</li>
<li>Sort <code>times</code> by the time value. If two entries have the same time, prioritize <code>end</code> times.</li>
<li>Initialize <code>ans</code> to track the maximum sum of two non-overlapping events, and <code>maxValue</code> to track the maximum event value seen so far.</li>
<li>Loop through each element in <code>times</code>:
<ul>
<li>If the element's type is <code>1</code> (start time):
<ul>
<li>Update <code>ans</code> as the maximum of its current value and the sum of the event value and <code>maxValue</code>.</li>
</ul>
</li>
<li>If the element's type is 0 (end time):
<ul>
<li>Update <code>maxValue</code> as the maximum of its current value and the event value.</li>
</ul>
</li>
</ul>
</li>
<li>After processing all elements, return <code>ans</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/k66MupZ5/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of events in the <code>events</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>For each event, we create two entries (<code>start</code> and <code>end</code>) in the <code>times</code> array. Since there are <code>n</code> events, this step takes <span class="math inline">\(O(n)\)</span> time. The <code>times</code> array contains <code>2*n</code> elements (start and end times for each event). Sorting this array takes <span class="math inline">\(O((2n) \cdot \log 2n) = O(n \cdot \log n)\)</span> time.</p>
<p>After sorting, we traverse the times array once to compute the result. This step takes <span class="math inline">\(O(2 \cdot n)=O(n)\)</span> time. Combining all steps, the overall time complexity is given by <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since there are exactly <span class="math inline">\(2 \cdot n\)</span> values in the <code>times</code> array, the algorithm requires <span class="math inline">\(O(2 \cdot n) = O(n)\)</span> space for the <code>times</code> array in the worst case.</p>
<p>Apart from this, the space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and  Insertion Sort and has <span class="math inline">\(O(l)\)</span> additional space, where <code>l</code> is the size of the list.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-287">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/two-sum-ii-input-array-is-sorted/description" target="_blank" rel="noopener noreferrer">Two Sum II - Input Array Is Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>

<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>

<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>

<p>Your solution must use only constant extra space.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6
<strong>Output:</strong> [1,3]
<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
	<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>
	<li><code>-1000 &lt;= target &lt;= 1000</code></li>
	<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-288">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ugly-number-iii/description" target="_blank" rel="noopener noreferrer">Ugly Number III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <strong>ugly number</strong> is a positive integer that is divisible by <code>a</code>, <code>b</code>, or <code>c</code>.</p>

<p>Given four integers <code>n</code>, <code>a</code>, <code>b</code>, and <code>c</code>, return the <code>n<sup>th</sup></code> <strong>ugly number</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, a = 2, b = 3, c = 5
<strong>Output:</strong> 4
<strong>Explanation:</strong> The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3<sup>rd</sup> is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, a = 2, b = 3, c = 4
<strong>Output:</strong> 6
<strong>Explanation:</strong> The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4<sup>th</sup> is 6.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, a = 2, b = 11, c = 13
<strong>Output:</strong> 10
<strong>Explanation:</strong> The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5<sup>th</sup> is 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, a, b, c &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= a * b * c &lt;= 10<sup>18</sup></code></li>
	<li>It is guaranteed that the result will be in range <code>[1, 2 * 10<sup>9</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-289">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-perfect-square/description" target="_blank" rel="noopener noreferrer">Valid Perfect Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a positive integer num, return <code>true</code> <em>if</em> <code>num</code> <em>is a perfect square or</em> <code>false</code> <em>otherwise</em>.</p>

<p>A <strong>perfect square</strong> is an integer that is the square of an integer. In other words, it is the product of some integer with itself.</p>

<p>You must not use any built-in library function, such as <code>sqrt</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = 16
<strong>Output:</strong> true
<strong>Explanation:</strong> We return true because 4 * 4 = 16 and 4 is an integer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = 14
<strong>Output:</strong> false
<strong>Explanation:</strong> We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-290">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-triangle-number/description" target="_blank" rel="noopener noreferrer">Valid Triangle Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,3,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,3,4]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p>The condition for the triplets <span class="math inline">\((a, b, c)\)</span> representing the lengths of the sides of a triangle, to form a valid triangle, is that the sum of any two sides should always be greater than the third side alone. i.e. <span class="math inline">\(a + b > c\)</span>, <span class="math inline">\(b + c > a\)</span>, <span class="math inline">\(a + c > b\)</span>.</p>
<p>The simplest method to check this is to consider every possible triplet in the given <span class="math inline">\(nums\)</span> array and checking if the triplet satisfies the three inequalities mentioned above. Thus, we can keep a track of the <span class="math inline">\(count\)</span> of the number of triplets satisfying these inequalities. When all the triplets have been considered, the <span class="math inline">\(count\)</span> gives the required result.</p>
<blockquote>
<p><strong>Caution:</strong> The brute force approach is included here because it is an intuitive way to approach this problem. However, when there are <span class="math inline">\(10^3\)</span> numbers, the if statement will be checked approximately <span class="math inline">\(10^9\)</span> times. Thus, this approach will result in TLE. In the following approaches we will discuss ways to optimize our solution.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/K5p9fUjs/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^3)\)</span>. Three nested loops are there to check every triplet.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant space is used.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-binary-search">Approach 2: Using Binary Search</h3>
<p><strong>Algorithm</strong></p>
<p>If we sort the given <span class="math inline">\(nums\)</span> array once, we can solve the given problem in a better way. This is because, if we consider a triplet <span class="math inline">\((a, b, c)\)</span> such that <span class="math inline">\(a &leq; b &leq; c\)</span>, we need not check all the three inequalities for checking the validity of the triangle formed by them. But, only one condition <span class="math inline">\(a + b > c\)</span> would suffice. This happens because <span class="math inline">\(c &geq; b\)</span> and <span class="math inline">\(c &geq; a\)</span>. Thus, adding any number to <span class="math inline">\(c\)</span> will always produce a sum which is greater than either <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> considered alone. Thus, the inequalities <span class="math inline">\(c + a > b\)</span> and <span class="math inline">\(c + b > a\)</span> are satisfied implicitly by virtue of the  property <span class="math inline">\(a < b < c\)</span>.</p>
<p>From this, we get the idea that we can sort the given <span class="math inline">\(nums\)</span> array. Then, for every pair <span class="math inline">\((nums[i], nums[j])\)</span> considered starting from the beginning of the array, such that <span class="math inline">\(j > i\)</span>(leading to <span class="math inline">\(nums[j] &geq; nums[i]\)</span>), we can find out the count of elements <span class="math inline">\(nums[k]$$(\)</span>k &gt; j<span class="math inline">\(), which satisfy the inequality \)</span>nums[k] &gt; nums[i] + nums[j]<span class="math inline">\(. We can do so for every pair \)</span>(i, j)$$ considered and get the required result.</p>
<p>We can also observe that, since we've sorted the <span class="math inline">\(nums\)</span> array, as we traverse towards the right for choosing the index <span class="math inline">\(k\)</span>(for number <span class="math inline">\(nums[k]\)</span>), the value of <span class="math inline">\(nums[k]\)</span> could increase or remain the same(doesn't decrease relative to the previous value). Thus, there will exist a right limit on the value of index <span class="math inline">\(k\)</span>, such that the elements satisfy <span class="math inline">\(nums[k] > nums[i] + nums[j]\)</span>. Any elements beyond this value of <span class="math inline">\(k\)</span> won't satisfy this inequality as well, which is obvious.</p>
<p>Thus, if we are able to find this right limit value of <span class="math inline">\(k\)</span>(indicating the element just greater than <span class="math inline">\(nums[i] + nums[j]\)</span>), we can conclude that all the elements in <span class="math inline">\(nums\)</span> array in the range <span class="math inline">\((j+1, k-1)\)</span>(both included) satisfy the required inequality. Thus, the <span class="math inline">\(count\)</span> of elements satisfying the inequality will be given by <span class="math inline">\((k-1) - (j+1) + 1 = k - j - 1\)</span>.</p>
<p>Since the <span class="math inline">\(nums\)</span> array has been sorted now, we can make use of Binary Search to find this right limit of <span class="math inline">\(k\)</span>. The following animation shows how Binary Search can be used to find the right limit for a simple example.</p>
<p>!?!../Documents/Valid_Triangle_Binary.json:1000,563!?!</p>
<p>Another point to be observed is that once we find a right limit index <span class="math inline">\(k_{(i,j)}\)</span> for a particular pair <span class="math inline">\((i, j)\)</span> chosen, when we choose a higher value of <span class="math inline">\(j\)</span> for the same value of <span class="math inline">\(i\)</span>, we need not start searching for the right limit <span class="math inline">\(k_{(i,j+1)}\)</span> from the index <span class="math inline">\(j+2\)</span>. Instead, we can start off from the index <span class="math inline">\(k_{(i,j)}\)</span> directly where we left off for the last <span class="math inline">\(j\)</span> chosen.</p>
<p>This holds correct because when we choose a higher value of <span class="math inline">\(j\)</span>(higher or equal <span class="math inline">\(nums[j]\)</span> than the previous one), all the <span class="math inline">\(nums[k]\)</span>, such that <span class="math inline">\(k < k_{(i,j)}\)</span> will obviously satisfy <span class="math inline">\(nums[i] + nums[j] > nums[k]\)</span> for the new value of <span class="math inline">\(j\)</span> chosen.</p>
<p>By taking advantage of this observation, we can limit the range of Binary Search for <span class="math inline">\(k\)</span> to shorter values for increasing values of <span class="math inline">\(j\)</span> considered while choosing the pairs <span class="math inline">\((i, j)\)</span>.</p>
<p><a href="https://leetcode.com/playground/jSUCbmrc/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2 \log n)\)</span>. In worst case inner loop will take <span class="math inline">\(n\log n\)</span> (binary search applied <span class="math inline">\(n\)</span> times).</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\log n)\)</span>. Sorting takes <span class="math inline">\(O(\log n)\)</span> space.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-3-linear-scan">Approach 3: Linear Scan</h3>
<p><strong>Algorithm</strong></p>
<p>As discussed in the last approach, once we sort the given <span class="math inline">\(nums\)</span> array, we need to find the right limit of the index <span class="math inline">\(k\)</span> for a pair of indices <span class="math inline">\((i, j)\)</span> chosen to find the <span class="math inline">\(count\)</span> of elements satisfying <span class="math inline">\(nums[i] + nums[j] > nums[k]\)</span> for the triplet <span class="math inline">\((nums[i], nums[j], nums[k])\)</span> to form a valid triangle.</p>
<p>We can find this right limit by simply traversing the index <span class="math inline">\(k\)</span>'s values starting from the index <span class="math inline">\(k=j+1\)</span> for a pair <span class="math inline">\((i, j)\)</span> chosen and stopping at the first value of <span class="math inline">\(k\)</span> not satisfying the above inequality. Again, the <span class="math inline">\(count\)</span> of elements <span class="math inline">\(nums[k]\)</span> satisfying <span class="math inline">\(nums[i] + nums[j] > nums[k]\)</span> for the pair of indices <span class="math inline">\((i, j)\)</span> chosen is given by <span class="math inline">\(k - j - 1\)</span> as discussed in the last approach.</p>
<p>Further, as discussed in the last approach, when we choose a higher value of index <span class="math inline">\(j\)</span> for a particular <span class="math inline">\(i\)</span> chosen, we need not start from the index <span class="math inline">\(j + 1\)</span>. Instead, we can start off directly from the value of <span class="math inline">\(k\)</span> where we left for the last index <span class="math inline">\(j\)</span>. This helps to save redundant computations.</p>
<p>The following animation depicts the process:</p>
<p>!?!../Documents/Valid_Triangle_Linear.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/HT9jpv3e/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. Loop of <span class="math inline">\(k\)</span> and <span class="math inline">\(j\)</span> will be executed <span class="math inline">\(O(n^2)\)</span> times in total, because, we do not reinitialize the value of <span class="math inline">\(k\)</span> for a new value of <span class="math inline">\(j\)</span> chosen(for the same <span class="math inline">\(i\)</span>). Thus the complexity will be <span class="math inline">\(O(n \log n + n^2)=O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\log n)\)</span>. Sorting takes <span class="math inline">\(O(\log n)\)</span> space.<br />
<br><br />
<br></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-291">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ways-to-split-array-into-three-subarrays/description" target="_blank" rel="noopener noreferrer">Ways to Split Array Into Three Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A split of an integer array is <strong>good</strong> if:</p>

<ul>
	<li>The array is split into three <strong>non-empty</strong> contiguous subarrays - named <code>left</code>, <code>mid</code>, <code>right</code> respectively from left to right.</li>
	<li>The sum of the elements in <code>left</code> is less than or equal to the sum of the elements in <code>mid</code>, and the sum of the elements in <code>mid</code> is less than or equal to the sum of the elements in <code>right</code>.</li>
</ul>

<p>Given <code>nums</code>, an array of <strong>non-negative</strong> integers, return <em>the number of <strong>good</strong> ways to split</em> <code>nums</code>. As the number may be too large, return it <strong>modulo</strong> <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only good way to split nums is [1] [1] [1].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,2,5,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three good ways of splitting nums:
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no good way to split nums.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-292">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zero-array-transformation-ii/description" target="_blank" rel="noopener noreferrer">Zero Array Transformation II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and a 2D array <code>queries</code> where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>, val<sub>i</sub>]</code>.</p>

<p>Each <code>queries[i]</code> represents the following action on <code>nums</code>:</p>

<ul>
	<li>Decrement the value at each index in the range <code>[l<sub>i</sub>, r<sub>i</sub>]</code> in <code>nums</code> by <strong>at most</strong> <code>val<sub>i</sub></code>.</li>
	<li>The amount by which each value is decremented<!-- notionvc: b232c9d9-a32d-448c-85b8-b637de593c11 --> can be chosen <strong>independently</strong> for each index.</li>
</ul>

<p>A <strong>Zero Array</strong> is an array with all its elements equal to 0.</p>

<p>Return the <strong>minimum</strong> possible <strong>non-negative</strong> value of <code>k</code>, such that after processing the first <code>k</code> queries in <strong>sequence</strong>, <code>nums</code> becomes a <strong>Zero Array</strong>. If no such <code>k</code> exists, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,0,2], queries = [[0,2,1],[0,2,1],[1,1,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>For i = 0 (l = 0, r = 2, val = 1):</strong>

	<ul>
		<li>Decrement values at indices <code>[0, 1, 2]</code> by <code>[1, 0, 1]</code> respectively.</li>
		<li>The array will become <code>[1, 0, 1]</code>.</li>
	</ul>
	</li>
	<li><strong>For i = 1 (l = 0, r = 2, val = 1):</strong>
	<ul>
		<li>Decrement values at indices <code>[0, 1, 2]</code> by <code>[1, 0, 1]</code> respectively.</li>
		<li>The array will become <code>[0, 0, 0]</code>, which is a Zero Array. Therefore, the minimum value of <code>k</code> is 2.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,3,2,1], queries = [[1,3,2],[0,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>For i = 0 (l = 1, r = 3, val = 2):</strong>

	<ul>
		<li>Decrement values at indices <code>[1, 2, 3]</code> by <code>[2, 2, 1]</code> respectively.</li>
		<li>The array will become <code>[4, 1, 0, 0]</code>.</li>
	</ul>
	</li>
	<li><strong>For i = 1 (l = 0, r = 2, val<span style="font-size: 13.3333px;"> </span>= 1):</strong>
	<ul>
		<li>Decrement values at indices <code>[0, 1, 2]</code> by <code>[1, 1, 0]</code> respectively.</li>
		<li>The array will become <code>[3, 0, 0, 0]</code>, which is not a Zero Array.</li>
	</ul>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 3</code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; nums.length</code></li>
	<li><code>1 &lt;= val<sub>i</sub> &lt;= 5</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>nums</code> of length <code>n</code>, and a list of queries that are each in the form <code>[left, right, val]</code>. For a given range <code>[left, right]</code>, we can decrease each element in that range by at most <code>val</code>. Our task is to determine the earliest query that allows us to turn <code>nums</code> into an array of all zeroes. If it's not possible, we return <code>-1</code>.</p>
<p>We can look at an example of the queries being processed:</p>
<p>!?!../Documents/3356/slideshow1.json:960,540!?!</p>
<p>From this example, we can see that there are two main operations that will occur:</p>
<ol>
<li>Iterating through each element in <code>queries</code>.</li>
<li>Applying the range and value of each query to <code>nums</code>.</li>
</ol>
<p>We need to assess how to optimally handle both operations to find the earliest value of <code>k</code> to reach a zero array.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>A simple approach would be to iterate through each query, applying the updates directly to <code>nums</code> and checking whether all elements have become zero. However, given the constraints where both <code>nums</code> and <code>queries</code> can be as large as <span class="math inline">\(10^5\)</span>, this approach is too slow. Each query might require traversing the entire array, leading to an impractical time complexity.</p>
<p>To optimize this, we need a more efficient way to apply queries to <code>nums</code>. Instead of modifying each element individually, we can take advantage of a <strong>difference array</strong>. This technique allows us to apply a range update in constant time. The key idea is to store the changes at the boundaries of the range rather than updating every element inside it. For a query <span class="math inline">\([ \text{left}, \text{right}, \text{val} ]\)</span>, we add <code>val</code> at index <code>left</code>, and subtract <code>val</code> at index <code>right + 1</code>. When we later compute the prefix sum of this difference array, it reconstructs the actual values efficiently. This way, instead of updating <code>nums</code> repeatedly, we can process all queries in an optimized manner and then traverse <code>nums</code> just once to check if all elements have become zero.</p>
<p>Let's look at how the difference array can be applied to this problem:</p>
<p>!?!../Documents/3356/slideshow2.json:960,540!?!</p>
<p>Now that we optimized how we apply queries, the next step is to determine how many queries we actually need. Instead of processing all queries one by one, we can use <strong>binary search</strong> to quickly determine the minimum number of queries required to achieve the zero array. We start by setting two pointers: <code>left = 0</code> and <code>right = len(queries)</code>, representing the search range. The middle index, <code>mid = (left + right) / 2</code>, represents the number of queries we will attempt to apply. We update <code>nums</code> using only the first <code>mid</code> queries, compute the final state using the prefix sum of the difference array, and check if <code>nums</code> is now a zero array.</p>
<p>If it is possible to achieve a zero array with <code>mid</code> queries, we reduce our search range by setting <code>right = mid - 1</code>, since we might be able to do it with even fewer queries. Otherwise, we increase our search range by setting <code>left = mid + 1</code>, since we need more queries to reach the desired state. This binary search ensures that instead of checking every possible number of queries linearly <span class="math inline">\(O(N)\)</span>, we find the answer in <span class="math inline">\(O(\log N)\)</span> time.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define a function <code>canFormZeroArray</code>, which takes the parameters <code>nums</code>, <code>queries</code>, and integer <code>k</code> and returns a boolean value:</p>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of <code>nums</code>.</li>
<li><code>sum</code> to <code>0</code> to track the cumulative sum of updates added to a given index.</li>
<li><code>differenceArray</code> as a vector of integers of size <code>n + 1</code> to apply range updates</li>
</ul>
</li>
<li>Iterate through the first <code>k</code> elements of <code>queries</code>:
<ul>
<li>Initialize <code>start</code>, <code>end</code>, and <code>val</code> to the respective values of the current query.</li>
<li>Increment <code>differenceArray[start]</code> by <code>val</code> to update the start of the range.</li>
<li>Decrement <code>differenceArray[end + 1]</code> by <code>val</code> to update the end of the range.</li>
</ul>
</li>
<li>Iterate through <code>nums</code>. For each index, <code>numIndex</code>:
<ul>
<li>Increment <code>sum</code> by <code>differenceArray[numIndex]</code>;</li>
<li>If <code>sum</code> is less than <code>nums[numIndex]</code>, return <code>false</code>, indicating that a zero array cannot be formed after the first <code>k</code> queries.</li>
</ul>
</li>
<li>Return <code>true</code>, meaning a zero array was formed after <code>k</code> queries.</li>
</ul>
</li>
<li>
<p>Define <code>minZeroArray</code>:</p>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of <code>nums</code>.</li>
<li><code>left</code> to <code>0</code>.</li>
<li><code>right</code> to the size of <code>queries</code>.</li>
</ul>
</li>
<li>If a zero array cannot be formed at <code>right</code>, return <code>-1</code>, since that means we processed all the queries without reaching a zero array.</li>
<li>Perform binary search on <code>queries</code>. While <code>left</code> is less than or equal to <code>right</code>:
<ul>
<li>Initialize <code>middle</code> to half of the current search interval (<code>left + (right - left) / 2</code>).</li>
<li>If <code>canFormZeroArray</code> returns <code>false</code> when we pass <code>middle</code> as the <code>k</code> parameter, set <code>right</code> to <code>middle - 1</code>.</li>
<li>Else, set <code>left</code> to <code>middle + 1</code>.</li>
</ul>
</li>
<li>Return <code>left</code>, which is the earliest query that a zero array can be formed.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/XkQaAdC4/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of array <code>nums</code> and <span class="math inline">\(M\)</span> be the size of array <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(log(M) \cdot (N + M))\)</span></p>
<p>We perform a binary search on <code>queries</code>, which repeatedly divides the search space in half at each step, leading to a time complexity of <span class="math inline">\(log(M)\)</span>.</p>
<p>In each iteration of the binary search, we first iterate through the first <code>k</code> elements in <code>queries</code>. In the worst case, we have to iterate through each element when <code>k</code> is the size of <code>queries</code>, leading to a time complexity of <span class="math inline">\(O(M)\)</span>.</p>
<p>From there, we iterate through each element of <code>nums</code> until one of the elements exceeds the value of <code>sum</code>. In the worst case, we have to iterate through each element in <code>nums</code> when this doesn't occur, leading to a time complexity of <span class="math inline">\(O(N)\)</span>.</p>
<p>As a result, each iteration of the binary search has a time complexity of <span class="math inline">\(O(N + M)\)</span>. Combining each iteration leads to a final time complexity of <span class="math inline">\(O(log(M) \cdot (N + M))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is based on the array <code>differenceArray</code>. Here, <code>differenceArray</code> is set to hold elements from the range <code>[0, N + 1]</code> to track all the changes in <code>nums</code>. As a result, this creates a space complexity of <span class="math inline">\(O(N + 1)\)</span>, which can be simplified to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-line-sweep">Approach 2: Line Sweep</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In our previous approach, we used binary search to determine how many queries were needed to turn <code>nums</code> into a zero array. This allowed us to efficiently process a subset of <code>queries</code>, applying them to a <strong>difference array</strong>, and then checking if <code>nums</code> had become all zeros. While this was an improvement over a naive approach, there was still an inefficiency: we were iterating over <code>queries</code> twice: once for binary search and again while applying updates.</p>
<p>To optimize further, we can change our perspective on how we traverse the data. Instead of iterating through <code>queries</code>, we can iterate directly through <code>nums</code>, using it as the main loop. This means that as we process each element in <code>nums</code>, we dynamically apply only the necessary queries at the right moment. The key challenge, then, is finding an efficient way to apply queries while moving through <code>nums</code>.</p>
<p>This is where a line sweep approach comes into play. Line sweeping is a technique that processes an array incrementally, maintaining only the relevant updates at each step. Instead of processing all queries upfront, we maintain an <strong>active set of queries</strong> and update <code>nums</code> only when necessary. Here, the <strong>difference array</strong> helps us track how <code>nums</code> is being modified, while <code>queries</code> provide the updates at specific points.</p>
<p>We start at index <code>0</code> of <code>nums</code> and check if it can be turned into <code>0</code> with the queries we have processed so far. If it cannot be zeroed out, we process additional queries to apply their effects. The key observation is that at any index <code>i</code> in <code>nums</code>, a query <code>[left, right, val]</code> can fall into three possible cases:</p>
<ol>
<li>If <code>i &lt; left</code>, the query affects a later part of <code>nums</code>, so we store it for later processing.</li>
<li>If <code>left ≤ i ≤ right</code>, the query is immediately relevant and should be applied.</li>
<li>If <code>right &lt; i</code>, the query is no longer useful for the current index and can be ignored.</li>
</ol>
<p>For example, if we're at index <code>4</code> in <code>nums</code> and the current query accesses the range <code>[0,2]</code>, we do not need to process that query and can simply move on to the next query.</p>
<p>Otherwise, we continue to the next element of <code>nums</code>. We repeat this process until we reach the end of either <code>nums</code> or <code>queries</code>, where we then return either <code>k</code> or <code>-1</code>, respectively.</p>
<p>Through this process, we only have to iterate through both <code>nums</code> and <code>queries</code> at most once each while skipping over unnecessary queries.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of <code>nums</code>.</li>
<li><code>sum</code> to <code>0</code> to track the cumulative sum of updates applied up to a given index</li>
<li><code>k</code> to <code>0</code> to represent the number of queries used.</li>
<li><code>differenceArray</code> as a vector of integers set to size <code>n + 1</code> to apply range updates.</li>
</ul>
</li>
<li>Iterate through <code>nums</code>. For each <code>index</code>:
<ul>
<li>If <code>sum + differenceArray[index]</code> is less than <code>nums[index]</code>, meaning more operations need to be applied at the current index:
<ul>
<li>Increase <code>k</code> by <code>1</code>.</li>
<li>If <code>k</code> is greater than the size of <code>queries</code>, return <code>-1</code>, since we processed all the queries without reaching a zero array.</li>
<li>Initialize <code>left</code>, <code>right</code>, and <code>val</code> to the respective values of the current query.</li>
<li>If <code>right</code> is greater than or equal to <code>index</code>:
<ul>
<li>Increment <code>differenceArray[max(left, index)]</code> by <code>val</code> to update the start of the range.</li>
<li>Decrement <code>differenceArray[right + 1]</code> by <code>val</code> to update the end of the range.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>sum</code> by <code>differenceArray[index]</code>.</li>
</ul>
</li>
<li>Return <code>k</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nYxo3uqw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code> and <span class="math inline">\(M\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N + M)\)</span></p>
<p>We iterate through each element of <code>nums</code> at most once. Within this loop, we loop through each element of <code>queries</code> at most once.</p>
<p>The program returns a value and ends when we reach the end of either of these arrays. In the worst case, we iterate through each element in <code>nums</code> and <code>queries</code> once before returning a value. As a result, this leads to a time complexity of <span class="math inline">\(O(N + M)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is based on the array <code>differenceArray</code>. Here, <code>differenceArray</code> is set to hold elements from the range <code>[0, N + 1]</code> to track all the changes in <code>nums</code>. As a result, this creates a space complexity of <span class="math inline">\(O(N + 1)\)</span>, which can be simplified to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>