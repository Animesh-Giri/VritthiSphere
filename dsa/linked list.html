<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>linked list - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>linked list</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">81</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Add Two Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Add Two Numbers II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">All O`one Data Structure</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Binary Tree to CDLL</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-4" class="toc-link">Binary Tree  to DLL</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-5" class="toc-link">Convert Binary Number in a Linked List to Integer</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Convert Sorted List to Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Copy List with Random Pointer</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Delete Node in a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Delete Nodes From Linked List Present in Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Delete the Middle Node of a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Design a Text Editor</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Design Authentication Manager</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Design Browser History</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Design Circular Deque</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Design Circular Queue</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Design Front Middle Back Queue</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Design HashMap</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Design HashSet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Design Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Design Skiplist</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Design Twitter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Double a Number Represented as a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Find the Minimum and Maximum Number of Nodes Between Critical Points</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Flatten a Multilevel Doubly Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Flatten binary tree to linked list</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-26" class="toc-link">Flatten Binary Tree to Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Insert Greatest Common Divisors in Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Insertion Sort List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Intersection of Two Linked Lists</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-30" class="toc-link">Intersection of Two Linked Lists</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Intersection Sorted Linked Lists</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-32" class="toc-link">Leaves to DLL</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-33" class="toc-link">LFU Cache</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Linked List Components</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Linked List Cycle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Linked List Cycle II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Linked List in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Linked List Random Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Linked List that is Sorted Alternatingly</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-40" class="toc-link">Linked List to Binary Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-41" class="toc-link">LRU Cache</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Maximum Twin Sum of a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Merge In Between Linked Lists</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Merge K sorted linked lists</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-45" class="toc-link">Merge k Sorted Lists</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Merge Nodes in Between Zeros</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Merge Sort for Linked List</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-48" class="toc-link">Merge Sort on Doubly Linked List</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-49" class="toc-link">Merge Two Sorted Lists</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Middle of the Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Minimum Pair Removal to Sort Array I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Minimum Pair Removal to Sort Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Next Greater Node In Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Odd Even Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Palindrome Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Partition List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Populating Next Right Pointers in Each Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Populating Next Right Pointers in Each Node II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Remove Duplicates from Sorted List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Remove Duplicates from Sorted List II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Remove Linked List Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Remove Nodes From Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Remove Nth Node From End of List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Remove Zero Sum Consecutive Nodes from Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Reorder List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Reverse Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Reverse Linked List II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Reverse Nodes in Even Length Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Reverse Nodes in k-Group</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Rotate List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Sorted Linked List to BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-72" class="toc-link">Sort List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Spiral Matrix IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Split Linked List in Parts</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Stack using Linked List</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-76" class="toc-link">Steps to Make Array Non-decreasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Subtraction in Linked List</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-78" class="toc-link">Swap Nodes in Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Swapping Nodes in a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Union of Two Linked Lists</a> <span class="toc-platform">GeeksForGeeks</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/add-two-numbers/description" target="_blank" rel="noopener noreferrer">Add Two Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">math</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" style="width: 483px; height: 342px;" />
<pre>
<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [7,0,8]
<strong>Explanation:</strong> 342 + 465 = 807.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> l1 = [0], l2 = [0]
<strong>Output:</strong> [0]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
<strong>Output:</strong> [8,9,9,9,0,0,0,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
	<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-elementary-math">Approach 1: Elementary Math</h3>
<p><strong>Intuition</strong></p>
<p>Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.</p>
<p><img src="../Figures/2_add_two_numbers.svg" alt="Illustration of Adding two numbers" />{:width=&quot;539px&quot;}</p>
<p><em>Figure 1. Visualization of the addition of two numbers: <span class="math inline">\(342 + 465 = 807\)</span>.<br />
Each node contains a single digit and the digits are stored in reverse order.</em></p>
<p><strong>Algorithm</strong></p>
<p>Just like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of <span class="math inline">\(l1\)</span> and <span class="math inline">\(l2\)</span>. Since each digit is in the range of <span class="math inline">\(0 \ldots 9\)</span>, summing two digits may &quot;overflow&quot;. For example <span class="math inline">\(5 + 7 = 12\)</span>. In this case, we set the current digit to <span class="math inline">\(2\)</span> and bring over the <span class="math inline">\(carry = 1\)</span> to the next iteration. <span class="math inline">\(carry\)</span> must be either <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> because the largest possible sum of two digits (including the carry) is <span class="math inline">\(9 + 9 + 1 = 19\)</span>.</p>
<p>The pseudocode is as following:</p>
<ul>
<li>Initialize current node to dummy head of the returning list.</li>
<li>Initialize carry to <span class="math inline">\(0\)</span>.</li>
<li>Loop through lists <span class="math inline">\(l1\)</span> and <span class="math inline">\(l2\)</span> until you reach both ends and carry is <span class="math inline">\(0\)</span>.
<ul>
<li>Set <span class="math inline">\(x\)</span> to node <span class="math inline">\(l1\)</span>'s value. If <span class="math inline">\(l1\)</span> has reached the end of <span class="math inline">\(l1\)</span>, set to <span class="math inline">\(0\)</span>.</li>
<li>Set <span class="math inline">\(y\)</span> to node <span class="math inline">\(l2\)</span>'s value. If <span class="math inline">\(l2\)</span> has reached the end of <span class="math inline">\(l2\)</span>, set to <span class="math inline">\(0\)</span>.</li>
<li>Set <span class="math inline">\(sum = x + y + carry\)</span>.</li>
<li>Update <span class="math inline">\(carry = sum / 10\)</span>.</li>
<li>Create a new node with the digit value of <span class="math inline">\((sum \bmod 10)\)</span> and set it to current node's next, then advance current node to next.</li>
<li>Advance both <span class="math inline">\(l1\)</span> and <span class="math inline">\(l2\)</span>.</li>
</ul>
</li>
<li>Return dummy head's next node.</li>
</ul>
<p>Note that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.</p>
<p>Take extra caution of the following cases:</p>
<table>
<thead>
<tr>
<th>Test case</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(l1=[0,1]\)</span><br><span class="math inline">\(l2=[0,1,2]\)</span></td>
<td>When one list is longer than the other.</td>
</tr>
<tr>
<td><span class="math inline">\(l1=[]\)</span><br><span class="math inline">\(l2=[0,1]\)</span></td>
<td>When one list is null, which means an empty list.</td>
</tr>
<tr>
<td><span class="math inline">\(l1=[9,9]\)</span><br><span class="math inline">\(l2=[1]\)</span></td>
<td>The sum could have an extra carry of one at the end, which is easy to forget.</td>
</tr>
</tbody>
</table>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/XsLdm2AA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(\max(m, n))\)</span>. Assume that <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represents the length of <span class="math inline">\(l1\)</span> and <span class="math inline">\(l2\)</span> respectively, the algorithm above iterates at most <span class="math inline">\(\max(m, n)\)</span> times.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. The length of the new list is at most <span class="math inline">\(\max(m,n) + 1\)</span> However, we don't count the answer as part of the space complexity.</p>
</li>
</ul>
<p><strong>Follow up</strong></p>
<p>What if the the digits in the linked list are stored in non-reversed order? For example:</p>
<p><span class="math display">\[(3 \to 4 \to 2) + (4 \to 6 \to 5) = 8 \to 0 \to 7
\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/add-two-numbers-ii/description" target="_blank" rel="noopener noreferrer">Add Two Numbers II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">math</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg" style="width: 523px; height: 342px;" />
<pre>
<strong>Input:</strong> l1 = [7,2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [7,8,0,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [8,0,7]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> l1 = [0], l2 = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
	<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong>&nbsp;Could you solve it without reversing the input lists?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-reverse-given-linked-lists">Approach 1: Reverse Given Linked Lists</h3>
<h4 id="intuition">Intuition</h4>
<p>We are told that the most significant digit comes first, and that each of their nodes includes a single digit. To do a basic addition of two numbers using a sum of two digits and a carry, we must start with the least significant digits (the lowest place) and work our way up to the most significant digits.</p>
<p>To get the order of digits from the least significant digits to the the most significant digits, we can reverse the given lists so the least significant digits come first.</p>
<p>We can then iterate over the reversed lists to perform the addition of digits at corresponding places similar to the first approach.</p>
<p>Let's understand how to reverse a linked list. This is a classical problem that you can try <a href="https://leetcode.com/problems/reverse-linked-list/">here</a>.</p>
<p>To reverse a linked list, we need three pointers. The first pointer <code>head</code> points to the current node under consideration, <code>temp</code> points to the next node, and <code>prev</code> points to the previous node. This is because while traversing the list, we change the current node's (<code>head</code>) next pointer to point to its previous element (<code>prev</code>). Since a node does not have reference to its previous node, we must store its previous element beforehand. We also need another pointer to store the next node (<code>temp</code>) before changing the reference so we don't lose it after changing <code>head.next</code>.</p>
<p>We start with initializing <code>prev</code> to <code>null</code>. We then loop until <code>head</code> is null, i.e., until we iterate over all the elements. We store <code>head.next</code> in <code>temp</code> to store the next node we will go to. After storing the next node, we reverse <code>next</code> of <code>head</code> to the previous element, i.e., <code>head.next = prev</code>. We then move <code>prev</code> to <code>head</code> as this becomes the previous node for the next node and also move <code>head</code> to <code>temp</code> as this becomes the new node under consideration.</p>
<p>Here's an animation visually showing how the approach works:</p>
<p>!?!../Documents/445/445-slides.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create two linked lists <code>r1</code> and <code>r2</code> to store the reverse of the linked lists <code>l1</code> and <code>l2</code> respectively.</li>
<li>Create two integers <code>totalSum</code> and <code>carry</code> to store the sum and carry of current digits.</li>
<li>Create a new <code>ListNode</code>, <code>ans</code> that will store the sum of current digits.</li>
<li>We will add the two numbers using the reverse list by adding the digits one by one. We continue until we cover all the nodes in <code>r1</code> and <code>r2</code>:
<ul>
<li>If <code>r1</code> is not <code>null</code>, we add <code>r1.val</code> to <code>totalSum</code>.</li>
<li>If <code>r2</code> is not <code>null</code>, we add <code>r2.val</code> to <code>totalSum</code>.</li>
<li>Set <code>ans.val = totalSum % 10</code>.</li>
<li>Store the <code>carry</code> as <code>totalSum / 10</code>.</li>
<li>Create a new <code>ListNode</code>, <code>newNode</code> that will have <code>val</code> as <code>carry</code>. Set <code>next</code> of <code>newNode</code> to <code>ans</code>. Update <code>ans = newNode</code> to use the same variable <code>ans</code> for the next iteration.</li>
<li>Update <code>totalSum = carry</code>.</li>
</ul>
</li>
<li>If <code>carry == 0</code>, it means the <code>newNode</code> that we created in the final iteration of while loop has <code>val = 0</code>. Because we perform <code>ans = newNode</code> at the end of each while loop iteration while loop, to avoid returning a linked list with a head of <code>0</code> (leading zero), we return the next element, i.e., we return <code>ans.next</code>. Otherwise, if <code>carry</code> is not equal to <code>0</code>, the value of <code>ans</code> is non-zero. Hence, we just return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/SxRyzmP8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are is the number of nodes in <code>l1</code> and <code>l2</code> respectively</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Reversing the list <code>l1</code> and <code>l2</code>  take <span class="math inline">\(O(m)\)</span> and <span class="math inline">\(O(n)\)</span> time respectively.</li>
<li>We then iterate over digits of the both lists. We iterate until both the lists are fully traversed. We iterate in the while loop <code>max(m, n)</code> times. We compute <code>totalSum</code>, <code>carry</code> and create a new node in each iteration which takes <span class="math inline">\(O(1)\)</span> time. Hence, the complexity of all the while loop can be written as <span class="math inline">\(O(m + n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>As we have reversed the input linked lists, we will count the space consumed by the reversed lists. The <code>r1</code> linked list takes <span class="math inline">\(O(m)\)</span> space and <code>r2</code> takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>Note: one could argue that because <code>r1</code> and <code>r2</code> are only referencing the input lists and not making copies of them, we are using <span class="math inline">\(O(1)\)</span> space. In most problems, you wouldn't count the input as part of the space complexity because the input doesn't contribute toward the algorithm. In this approach, the input is used heavily by our algorithm in terms of logic, and thus, we are counting it as part of the space complexity.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-stack">Approach 2: Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our task is to do a basic addition of two numbers starting with the least significant digits and working our way up to the most significant digits. In the previous approach, we reversed the linked lists to access the least significant digits first. We can also use <strong>stacks</strong> to access the least significant digits first.</p>
<p>The advantage of using a stack is that when we loop over a given linked list from the first node to the last and push all the digits in the stack, the top of the stack will have the least significant digit and the bottom will contain the most significant digit.</p>
<p>We can add the digits at corresponding places of the linked lists using the two stacks moving from the least to the most significant digits using the stack's <code>pop</code> method.</p>
<p>Here's a brief visual representation explaining the approach:</p>
<p><img src="../Figures/445/445-stack.png" alt="img" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create two integer stacks <code>s1</code> and <code>s2</code> to store the integers of the linked lists <code>l1</code> and <code>l2</code> respectively.</li>
<li>Push all the integers of <code>l1</code> in <code>s1</code> starting from the integer at the first node. The most significant comes first in the list, so it will be stored at the bottom of the stack and the least significant digit will stored at the top.</li>
<li>Similarly, push all the integers of <code>l2</code> in <code>s2</code>.</li>
<li>Create two integers <code>totalSum</code> and <code>carry</code> to store the sum and carry of current digits.</li>
<li>Create a new <code>ListNode</code>, <code>ans</code> that will store the answer.</li>
<li>We will add the two numbers present in the linked list now by adding the digits one by one. We continue until both <code>s1</code> and <code>s2</code> are empty:
<ul>
<li>If <code>s1</code> is not empty, pop the first element from the stack and add it to <code>totalSum</code>.</li>
<li>If <code>s2</code> is not empty, pop the first element from the stack and add it to <code>totalSum</code>.</li>
<li>Set <code>ans.val = totalSum % 10</code>.</li>
<li>Store the <code>carry</code> as <code>totalSum / 10</code>.</li>
<li>Create a new <code>ListNode</code>, <code>newNode</code> that will have <code>val</code> as <code>carry</code>. Set <code>next</code> of <code>newNode</code> to <code>ans</code>. Update <code>ans = newNode</code> to use the same variable <code>ans</code> for the next iteration.</li>
<li>Update <code>totalSum = carry</code>.</li>
</ul>
</li>
<li>If <code>carry == 0</code>, it means the <code>newNode</code> that we created in the final iteration of while loop has <code>val = 0</code>. Because we perform <code>ans = newNode</code> at the end of each while loop, to avoid returning a linked list with a head of <code>0</code> (leading zero), we return the next element, i.e., we return <code>ans.next</code>. Otherwise, if <code>carry</code> is not equal to <code>0</code>, the value of <code>ans</code> is non-zero. Hence, we just return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3xMD2Xjx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are is the number of nodes in <code>l1</code> and <code>l2</code> respectively</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Iterating over both the lists and pushing all the values in the respective stacks take <span class="math inline">\(O(m + n)\)</span> time.</li>
<li>We then iterate over digits of the both lists. We iterate until both the stacks are empty. We iterate in the while loop <code>max(m, n)</code> times. We compute <code>sum</code>, <code>carry</code> and create a new node in each iteration which takes <span class="math inline">\(O(1)\)</span> time. Hence, the complexity of all the while loop can be written as <span class="math inline">\(O(m + n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>The <code>s1</code> stack takes <span class="math inline">\(O(m)\)</span> space and the <code>s2</code> stack takes <span class="math inline">\(O(n)\)</span> space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-oone-data-structure/description" target="_blank" rel="noopener noreferrer">All O`one Data Structure</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure to store the strings&#39; count with the ability to return the strings with minimum and maximum counts.</p>

<p>Implement the <code>AllOne</code> class:</p>

<ul>
	<li><code>AllOne()</code> Initializes the object of the data structure.</li>
	<li><code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.</li>
	<li><code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.</li>
	<li><code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>&quot;&quot;</code>.</li>
	<li><code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>&quot;&quot;</code>.</li>
</ul>

<p><strong>Note</strong> that each function must run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;AllOne&quot;, &quot;inc&quot;, &quot;inc&quot;, &quot;getMaxKey&quot;, &quot;getMinKey&quot;, &quot;inc&quot;, &quot;getMaxKey&quot;, &quot;getMinKey&quot;]
[[], [&quot;hello&quot;], [&quot;hello&quot;], [], [], [&quot;leet&quot;], [], []]
<strong>Output</strong>
[null, null, null, &quot;hello&quot;, &quot;hello&quot;, null, &quot;hello&quot;, &quot;leet&quot;]

<strong>Explanation</strong>
AllOne allOne = new AllOne();
allOne.inc(&quot;hello&quot;);
allOne.inc(&quot;hello&quot;);
allOne.getMaxKey(); // return &quot;hello&quot;
allOne.getMinKey(); // return &quot;hello&quot;
allOne.inc(&quot;leet&quot;);
allOne.getMaxKey(); // return &quot;hello&quot;
allOne.getMinKey(); // return &quot;leet&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= key.length &lt;= 10</code></li>
	<li><code>key</code> consists of lowercase English letters.</li>
	<li>It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.</li>
	<li>At most <code>5 * 10<sup>4</sup></code>&nbsp;calls will be made to <code>inc</code>, <code>dec</code>, <code>getMaxKey</code>, and <code>getMinKey</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview:</h3>
<p>We need to create a specialized data structure that efficiently handles the following operations on strings and their associated counts:</p>
<ul>
<li>Increase the count of a specified string.</li>
<li>Decrease the count of a specified string.</li>
<li>Retrieve the string with the highest count.</li>
<li>Retrieve the string with the lowest count.</li>
</ul>
<p>A key requirement is that each of these operations must be performed in constant time, <span class="math inline">\(Î˜(1)\)</span> on average.</p>
<p><img src="../Figures/432/432_allOone.png" alt="AllOone" /></p>
<h3 id="approach-using-doubly-linked-list">Approach: Using Doubly Linked List</h3>
<h4 id="intuition">Intuition</h4>
<p>To manage a collection of keys and their frequencies, we need a structure that updates easily and provides quick access to maximum and minimum frequencies. We start with a hashmap to look up each keyâ€™s frequency quickly.</p>
<p>However, a hashmap alone does not track frequencies well. We need a way to group keys by their frequencies and find keys with the same frequency. We use a doubly linked list for this. Each node represents a frequency and holds all keys linked to that frequency. This setup allows us to add and remove keys efficiently as their frequencies change.</p>
<p>To handle edge cases better, we include dummy head and tail nodes in the list. These nodes make it easier to manage operations when the list is empty or when we add or remove nodes at the ends.</p>
<p>When we increment a key, we first check if it exists in the hashmap. If the key is new, we look at the node after the dummy head. If that node does not have a frequency of 1, we create a new node for frequency 1. We add the key to this node and update the hashmap. If the key already exists, we find its current frequency node and check the next node, which shows the next higher frequency. If that next node is the tail or does not have the expected frequency, we create a new node with the increased frequency. We then move the key to the right node, remove it from the old node, and delete the old node if it becomes empty.</p>
<p>When we decrement a key, we first check if it is in the hashmap. If it is, we remove it from its current node. If the keyâ€™s frequency is greater than one, we check the previous node. If needed, we create a new node for the decreased frequency and add the key to the appropriate previous node, updating the hashmap. If the frequency is one, we remove the key from the hashmap completely.</p>
<p>To find the key with the maximum frequency, we return one of the keys from the last node in the list. For the minimum frequency key, we get a key from the first node after the dummy head. If there are no keys, we return an empty string.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p><code>Node</code> Class:</p>
</li>
<li>
<p>Each <code>Node</code> contains:</p>
<ul>
<li><code>freq</code>: the frequency of the keys.</li>
<li><code>prev</code>: a pointer to the previous node.</li>
<li><code>next</code>: a pointer to the next node.</li>
<li><code>keys</code>: a set of strings representing the keys with this frequency.</li>
</ul>
</li>
<li>
<p>The constructor initializes the <code>freq</code>, and sets <code>prev</code> and <code>next</code> to <code>nullptr</code>.</p>
</li>
<li>
<p><code>AllOne</code> Class:</p>
<ul>
<li>
<p>Create a dummy head node and a dummy tail node.</p>
</li>
<li>
<p>Link the dummy head to the dummy tail and vice versa.</p>
</li>
<li>
<p>Incrementing a Key (<code>inc</code> function):</p>
<ul>
<li>
<p>If the key already exists:</p>
<ul>
<li>Retrieve the corresponding <code>node</code> from the <code>map</code>.</li>
<li>Erase the key from the current <code>node</code>.</li>
<li>Check the next node:
<ul>
<li>If it doesnâ€™t exist or its frequency is not <code>freq + 1</code>:
<ul>
<li>Create a new node with frequency <code>freq + 1</code>.</li>
<li>Insert the key into this new node.</li>
<li>Link the new node with the current and next nodes.</li>
<li>Update the <code>map</code> to point to the new node.</li>
</ul>
</li>
<li>Otherwise, insert the key into the existing next node.</li>
</ul>
</li>
<li>If the current node has no keys left, remove it.</li>
</ul>
</li>
<li>
<p>If the key does not exist:</p>
<ul>
<li>Check the first node after the head:
<ul>
<li>If it doesnâ€™t exist or its frequency is greater than <code>1</code>:
<ul>
<li>Create a new node with frequency <code>1</code>.</li>
<li>Insert the key into this new node.</li>
<li>Link this new node with the head and the first node.</li>
</ul>
</li>
<li>Otherwise, insert the key into the first node.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Decrementing a Key (<code>dec</code> function):</p>
<ul>
<li>If the key does not exist in the <code>map</code>, return immediately.</li>
<li>Retrieve the node corresponding to the key.</li>
<li>Erase the key from the current node.</li>
<li>If the frequency is <code>1</code>:
<ul>
<li>Remove the key from the <code>map</code>.</li>
</ul>
</li>
<li>Otherwise, check the previous node:
<ul>
<li>If it doesnâ€™t exist or its frequency is not <code>freq - 1</code>:
<ul>
<li>Create a new node with frequency <code>freq - 1</code>.</li>
<li>Insert the key into this new node and link it with the current node and the previous node.</li>
</ul>
</li>
<li>Otherwise, insert the key into the existing previous node.</li>
</ul>
</li>
<li>If the node has no keys left, remove it.</li>
</ul>
</li>
<li>
<p>Getting the Maximum Key (<code>getMaxKey</code> function):</p>
<ul>
<li>If there are no keys (i.e., the tail's previous node points to the head), return an empty string.</li>
<li>Return one of the keys from the tail's previous node.</li>
</ul>
</li>
<li>
<p>Getting the Minimum Key (<code>getMinKey</code> function):</p>
<ul>
<li>If there are no keys (i.e., the head's next node points to the tail), return an empty string.</li>
<li>Return one of the keys from the head's next node.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Removing a Node (<code>removeNode</code> function):</p>
<ul>
<li>Link the previous node to the next node and vice versa to remove the specified node from the linked list.</li>
<li>Delete the removed node to free its memory.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/eRAv3tYP/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of unique keys.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The <code>inc</code> and <code>dec</code> methods both perform operations that are constant time. In <code>inc</code>, whether inserting a new key or updating an existing one, the operations primarily involve updating pointers in the linked list and updating the hash map, which are <span class="math inline">\(O(1)\)</span> operations.</p>
<p>Similarly, in <code>dec</code>, removing a key, updating the hash map, and possibly creating a new node or modifying the previous node also take constant time. Therefore, both operations run in <span class="math inline">\(O(1)\)</span>.</p>
<p>The <code>getMaxKey</code> and <code>getMinKey</code> methods return a key from the front or back of the linked list, which is also <span class="math inline">\(O(1)\)</span> since it involves accessing the first or last element of the list.</p>
</li>
</ul>
<blockquote>
<p>This assumes that map operations typically run in &quot;average-case <span class="math inline">\(Î˜(1)\)</span>&quot;. However, in the worst case, where many hash collisions occur, these operations can degrade to <span class="math inline">\(O(N)\)</span>.</p>
</blockquote>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space used by the <code>AllOne</code> data structure is primarily due to the hash map and the linked list of <code>Node</code>s.</p>
<p>The hash map stores pointers to nodes for each unique key, requiring <span class="math inline">\(O(N)\)</span> space where <span class="math inline">\(N\)</span> is the number of unique keys.</p>
<p>Each <code>Node</code> contains a set of <code>keys</code>, which can also grow with the number of unique keys in the worst case. Hence, the total space consumed by the linked list of nodes will also contribute to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</br>
<details>
<summary>Further Thoughts: Understanding Hashmap Time Complexity [Click Here]</summary>
</br>
<p>A common question that always arises is: why are hashmap lookups considered <span class="math inline">\(O(1)\)</span> in terms of time complexity, even in worst-case scenarios? This seems counterintuitive, especially considering that hash collisions can occur.</p>
<p>If we use a predetermined hash function, the worst-case time for hashmap operations could indeed be <span class="math inline">\(O(n)\)</span>. Why? Because someone could craft a set of keys that all hash to the same value, causing a chain of collisions. This would force the lookup to scan through all <span class="math inline">\(n\)</span> elements, resulting in <span class="math inline">\(O(n)\)</span> time complexity.</p>
<p>The key to achieving <span class="math inline">\(O(1)\)</span> time complexity lies in randomization. Instead of using a fixed hash function like <code>h(x) = (constant_a . x + constant_b) % constant_prime</code>, we can use a randomized approach. For example, we might choose random values for the parameters in our hash function each time we initialize our hashmap, such as <code>h(x) = (random_a . x + random_b) % random_prime</code>. (This is just one way to construct a hash function; there are many other types you can design.)</p>
<p>This randomization makes it virtually impossible for someone to predict and exploit the hash function's behavior.</p>
<p>From a mathematical perspective, when analyzing the &quot;expected runtime&quot; of hashmap operations using a randomized hash function, it averages out to <span class="math inline">\(O(1)\)</span>. While some individual operations might take longer due to collisions, the overall average remains constant.</p>
<p>It's crucial to understand that when we say &quot;expected worst-case time is <span class="math inline">\(O(1)\)</span>&quot;, we're referring to the average over all possible random choices of the hash function, for any given input.</p>
<p>This isn't just theoreticalâ€”itâ€™s applied in practice. For instance, Googleâ€™s Abseil library randomizes hash functions at the program start. This helps prevent attacks that exploit hash collisions and makes systems more secure. Randomization also ensures that software doesn't become dependent on a specific hash function. Hardcoding a hash function and never changing it makes future updates to improve security or performance challenging.</p>
<p>This concept illustrates a broader principle in system design: the power of introducing controlled randomness to improve system performance and security. It also relates to Hyrum's Law, which suggests that all observable behaviors of a system will eventually be depended on by somebody. By randomizing hash functions, we prevent dependencies on specific hash behaviors, making systems more robust and flexible.</p>
<p>Additionally, when we say &quot;expected value,&quot; it's not just a random term; it is formally defined, similar to worst-case and average-case scenarios. You can read the definition and understand the concept here in <a href="https://en.m.wikipedia.org/wiki/Expected_value">probability theory: Expected value</a>.</p>
</details></div>
				</div>
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/binary-tree-to-cdll/1" target="_blank" rel="noopener noreferrer">Binary Tree to CDLL</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 12pt;">Given a root binary tree (BT), the task is to convert this to a Circular Doubly Linked List (CDLL) in-place. The<strong> </strong>left and right pointers<strong> </strong>in nodes will be used as previous and next pointers<strong> </strong>respectively in CDLL. The order of nodes in CDLL<strong> </strong>must be the same as <strong>Inorder </strong>of the given <strong>Binary Tree</strong>. The first node of <strong>Inorder traversal </strong>(leftmost node in<strong> </strong>BT) must be the<strong> </strong>head node of the CDLL.</span></p>
<p><span style="font-size: 12pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>root = [1, 3, 2]</span><br /><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908789/Web/Other/blobid0_1755585384.webp" width="275" height="170" /></span><br /><span style="font-size: 12pt;"><strong>Output: </strong>3 &lt;-&gt; 1 &lt;-&gt; 2 <strong>
Explanation: </strong></span>Inorder traversal of the tree is [3, 1, 2], which directly forms the Circular Doubly Linked List.</pre>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>root = [10, 20, 30, 40, 60]</span><br /><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908789/Web/Other/blobid1_1755585451.webp" width="254" height="197" /></span><br /><span style="font-size: 12pt;"><strong>Output: </strong>40 &lt;-&gt; 20 &lt;-&gt; 60 &lt;-&gt; 10 &lt;-&gt; 30 <strong>
Explanation</strong></span><strong>: </strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Inorder traversal of the tree is [10, 20, 30, 40, 60], which directly forms the Circular Doubly Linked List.</span></pre>
<p><span style="font-size: 12pt;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Constraints:<br /></strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1 &lt;= number of nodes &lt;= 10</span><sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">3<br /></sup><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">0 &lt;= data of a node &lt;= 10</span><sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/binary-tree-to-dll/1" target="_blank" rel="noopener noreferrer">Binary Tree  to DLL</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-pm-slice="0 0 []">G<span style="font-size: 14pt;">iven a <strong>root</strong> of binary tree (BT), convert it to a Doubly Linked List (DLL) in place using the <strong>same node</strong> structure. The<strong> left </strong>and <strong>right</strong> pointers in the binary tree nodes should be used as <strong>prev</strong> and <strong>next</strong> pointers respectively in the resulting DLL .The DLL should be formed by performing an <strong>inorder</strong> traversal of the binary tree (i.e., Left &rarr; Root &rarr; Right).The <strong>first node </strong>in the inorder traversal (i.e., the leftmost node) should become the <strong>head</strong> of the DLL. Return the <strong>head</strong> of the resulting DLL.<br /></span><span style="font-size: 14pt;"><strong>Note: </strong>h&nbsp;is the tree's height, and this space is used implicitly for the recursion stack.</span></p>
<p><span style="font-size: 12pt;"><img style="height: 234px; width: 375px;" src="http://www.geeksforgeeks.org/wp-content/uploads/TreeToList.png" alt="TreeToList" /></span></p>
<p><span style="font-size: 12pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>root<strong> = </strong>[1, 2, 3]
<strong>Output: </strong>[3, 1, 2] <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700144/Web/Other/blobid0_1723093893.png" width="375" height="244" /><strong>
Explanation:</strong> DLL would be 3&lt;=&gt;1&lt;=&gt;2</span></pre>
<pre><span style="font-size: 12pt;"><strong>Input:  </strong>root = [10, 20, 30, 40, 60]
<strong>Output:</strong> [40, 20, 60, 10, 30] <br /><strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700144/Web/Other/blobid1_1723093972.png" width="352" height="255" /><br />Explanation: </strong>DLL would be 40&lt;=&gt;20&lt;=&gt;60&lt;=&gt;10&lt;=&gt;30.</span></pre>
<p><span style="font-size: 12pt;"><strong>Constraints:</strong><br />1 &le; Number of nodes &le; 10<sup>5</sup><br />0 &le; Data of a node &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description" target="_blank" rel="noopener noreferrer">Convert Binary Number in a Linked List to Integer</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>head</code> which is a reference node to a singly-linked list. The value of each node in the linked list is either <code>0</code> or <code>1</code>. The linked list holds the binary representation of a number.</p>

<p>Return the <em>decimal value</em> of the number in the linked list.</p>

<p>The <strong>most significant bit</strong> is at the head of the linked list.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/05/graph-1.png" style="width: 426px; height: 108px;" />
<pre>
<strong>Input:</strong> head = [1,0,1]
<strong>Output:</strong> 5
<strong>Explanation:</strong> (101) in base 2 = (5) in base 10
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [0]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The Linked List is not empty.</li>
	<li>Number of nodes will not exceed <code>30</code>.</li>
	<li>Each node&#39;s value is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Convert Sorted List to Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list where elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword="height-balanced"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" style="width: 500px; height: 388px;" />
<pre>
<strong>Input:</strong> head = [-10,-3,0,5,9]
<strong>Output:</strong> [0,-3,9,-10,null,5]
<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/copy-list-with-random-pointer/description" target="_blank" rel="noopener noreferrer">Copy List with Random Pointer</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>

<p>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>

<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>

<p>Return <em>the head of the copied linked list</em>.</p>

<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>

<ul>
	<li><code>val</code>: an integer representing <code>Node.val</code></li>
	<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>
</ul>

<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" style="width: 700px; height: 142px;" />
<pre>
<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" style="width: 700px; height: 114px;" />
<pre>
<strong>Input:</strong> head = [[1,1],[2,1]]
<strong>Output:</strong> [[1,1],[2,1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" style="width: 700px; height: 122px;" /></strong></p>

<pre>
<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]
<strong>Output:</strong> [[3,null],[3,0],[3,null]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 1000</code></li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-node-in-a-linked-list/description" target="_blank" rel="noopener noreferrer">Delete Node in a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a singly-linked list <code>head</code> and we want to delete a node <code>node</code> in it.</p>

<p>You are given the node to be deleted <code>node</code>. You will <strong>not be given access</strong> to the first node of <code>head</code>.</p>

<p>All the values of the linked list are <strong>unique</strong>, and it is guaranteed that the given node <code>node</code> is not the last node in the linked list.</p>

<p>Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:</p>

<ul>
	<li>The value of the given node should not exist in the linked list.</li>
	<li>The number of nodes in the linked list should decrease by one.</li>
	<li>All the values before <code>node</code> should be in the same order.</li>
	<li>All the values after <code>node</code> should be in the same order.</li>
</ul>

<p><strong>Custom testing:</strong></p>

<ul>
	<li>For the input, you should provide the entire linked list <code>head</code> and the node to be given <code>node</code>. <code>node</code> should not be the last node of the list and should be an actual node in the list.</li>
	<li>We will build the linked list and pass the node to your function.</li>
	<li>The output will be the entire list after calling your function.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" style="width: 400px; height: 286px;" />
<pre>
<strong>Input:</strong> head = [4,5,1,9], node = 5
<strong>Output:</strong> [4,1,9]
<strong>Explanation: </strong>You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/node2.jpg" style="width: 400px; height: 315px;" />
<pre>
<strong>Input:</strong> head = [4,5,1,9], node = 1
<strong>Output:</strong> [4,5,9]
<strong>Explanation: </strong>You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
	<li>The value of each node in the list is <strong>unique</strong>.</li>
	<li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>To delete a node from a linked list, we typically redirect the previous node's <code>next</code> pointer to the subsequent node of the one being deleted. For example, to remove node 3 from a linked list, we would adjust node 2's <code>next</code> pointer to reference node 4 directly. This effectively excludes node 3 from the traversal path, rendering it inaccessible during iteration, and thus, it is considered deleted.</p>
<p><img src="../Documents/237/237-Page-1.svg" alt="initial_linkedlist" /></p>
<p><img src="../Documents/237/237-Page-2.svg" alt="changing_pointers" /></p>
<br />
<p>However, a challenge arises when we cannot access the previous node, as is the case in this specific problem. Since we can only traverse forward from the node to be deleted, the conventional deletion method is not feasible.</p>
<p><strong>Key Observations:</strong></p>
<ul>
<li>We've been presented with a scenario where we can't access the entire linked list structure, forcing us to devise a strategy that works within those limitations.</li>
<li>This problem goes beyond rote memorization of DSA techniques. <strong>It emphasizes the importance of creative thinking under limitations.</strong> It highlights the assessment of the candidate's problem-solving approach.</li>
</ul>
<hr />
<h3 id="approach-data-overwriting">Approach: Data Overwriting</h3>
<h4 id="intuition">Intuition</h4>
<p>To circumvent this limitation, we can employ an alternative strategy. By comparing the original linked list with the desired outcome post-deletion, we notice that the nodes following the target node appear to shift one position to the left.</p>
<p><img src="../Documents/237/237-Page-3.svg" alt="initial_linkedlist" /></p>
<p><img src="../Documents/237/237-Page-4.svg" alt="after_deletion" /></p>
<br />
<p>We can replicate this effect by copying the data from each subsequent node into its predecessor, starting from the node to be deleted, and then unlinking the last node.</p>
<p><img src="../Documents/237/237-Page-5.svg" alt="overwrite_linkedlist" /></p>
<p><img src="../Documents/237/237-Page-6.svg" alt="after_overwrite" /></p>
<br />
<p>This approach can be further optimized. Instead of shifting the data of all subsequent nodes, we only need to overwrite the data of the node to be deleted with that of its immediate successor. Subsequently, we update the <code>next</code> pointer of the node to be deleted to point to the successor's next node. This effectively removes the successor node, achieving the desired result with minimal operations.</p>
<p><img src="../Documents/237/237-Page-7.svg" alt="overwrite_linkedlist" /></p>
<p><img src="../Documents/237/237-Page-8.svg" alt="after_overwrite_1_node" /></p>
<p>Let's take a simpler example to understand this approach.<br />
Imagine the linked list as a train with connected cars (nodes). We want to remove a specific car (target node), but the conductor (you) can only access the current car and not the engine (head).<br />
By shifting all passengers from current car (&quot;overwriting&quot; the data of the current node) with the data from the next car, and then connecting the current car to the car after the next (skipping the unwanted car), we achieve the deletion effect.</p>
<p><strong>Note:</strong> This method will not work if we need to delete the last node of the linked list since there is no immediate successor. However, the problem description explicitly states that the node to be deleted is not the tail node in the list.</p>
<br />
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Copy the data from the successor node into the current node to be deleted.</li>
<li>Update the <code>next</code> pointer of the current node to reference the <code>next</code> pointer of the successor node.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/WZX53viv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>The method involves a constant number of operations: updating the data of the current node and altering its <code>next</code> pointer. Each of these operations requires a fixed amount of time, irrespective of the size of the linked list.</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>This deletion technique does not necessitate any extra memory allocation, as it operates directly on the existing nodes without creating additional data structures.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/description" target="_blank" rel="noopener noreferrer">Delete Nodes From Linked List Present in Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> and the <code>head</code> of a linked list. Return the <code>head</code> of the modified linked list after <strong>removing</strong> all nodes from the linked list that have a value that exists in <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3], head = [1,2,3,4,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,5]</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/06/11/linkedlistexample0.png" style="width: 400px; height: 66px;" /></strong></p>

<p>Remove the nodes with values 1, 2, and 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1], head = [1,2,1,2,1,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/11/linkedlistexample1.png" style="height: 62px; width: 450px;" /></p>

<p>Remove the nodes with value 1.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5], head = [1,2,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,3,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/06/11/linkedlistexample2.png" style="width: 400px; height: 83px;" /></strong></p>

<p>No node has value 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li>All elements in <code>nums</code> are unique.</li>
	<li>The number of nodes in the given list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>The input is generated such that there is at least one node in the linked list that has a value not present in <code>nums</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-hash-set">Approach: Hash Set</h3>
<h4 id="intuition">Intuition</h4>
<p>The first challenge is efficiently determining whether a linked list value exists in the <code>nums</code> array. A naive approach would involve searching through <code>nums</code> for each node, but this is inefficient for large arrays. Instead, we can use a Hash Set, which allows constant-time lookups. By adding all elements of <code>nums</code> to the set, we can check if a node should be removed by verifying if its value exists in constant time.</p>
<blockquote>
<p>If you're unfamiliar with hash sets, you can refer to this LeetCode <a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/">Explore Card</a> for an in-depth tutorial.</p>
</blockquote>
<p>With the lookup mechanism in place, we handle the linked list. The head requires special attention, as removing it alters the starting point of the list. We loop through the list to remove nodes from the beginning if their values are found in the hash set, then store the updated head. After this loop, the modified <code>head</code> is stored as the new starting point of the linked list.</p>
<p>Next, we traverse the rest of the list using a <code>current</code> node. As we iterate, we check if <code>current.next</code>'s value is in the hash set. If it is, we adjust <code>current.next</code> to skip over that node, removing it from the list.</p>
<p>Once the traversal is complete, we return the modified head of the list.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/3217/slideshow.json:1082,602!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a set <code>valuesToRemove</code> and populate it with the values of the <code>nums</code> array.</li>
<li>While the <code>head</code> of the linked list is not null and the <code>head</code>'s value is present in <code>valuesToRemove</code>:
<ul>
<li>Move <code>head</code> to <code>head.next</code>.</li>
</ul>
</li>
<li>If the <code>head</code> is <code>null</code>, return <code>null</code> since all nodes have been removed.</li>
<li>Start iterating from the <code>head</code> of the modified list:
<ul>
<li>For each node <code>current</code>, check if the value of the next node (<code>current.next</code>) is in the <code>valuesToRemove</code> set.
<ul>
<li>If it is, skip the next node by updating <code>current.next</code> to <code>current.next.next</code></li>
</ul>
</li>
<li>If it is not, move the <code>current</code> pointer to the next node in the list.</li>
</ul>
</li>
<li>Return the updated <code>head</code> of the list.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: In C++, memory management is manual, unlike languages with automatic garbage collection (like Java or Python). When you remove a node from a linked list, its memory remains allocated unless you explicitly free it. In the solution provided below, the memory of each removed node is properly deallocated using <code>delete</code>. However, if you're working in a production environment or during an interview, ensure that you discuss how the list nodes were allocated (e.g., via <code>new</code>) and ensure they are deallocated appropriately to avoid memory leaks. If possible, consider using smart pointers (<code>std::shared_ptr</code> or <code>std::unique_ptr</code>) for automatic memory management, which can help simplify the code and avoid manual memory management issues.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/PoaZKP3W/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the lengths of the <code>nums</code> array and the linked list, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>Iterating through the <code>nums</code> array and inserting each element into the hash set takes <span class="math inline">\(O(m)\)</span> time, as each insertion into the set is <span class="math inline">\(O(1)\)</span> on average.</p>
<p>The algorithm traverses the entire linked list exactly once, checking if each node's value is in the hash set. This operation takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m) + O(n) = O(m + n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The hash set can store up to <span class="math inline">\(m\)</span> elements, one for each unique value in the <code>nums</code> array, leading to a space complexity of <span class="math inline">\(O(m)\)</span>. All additional variables used take constant space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-the-middle-node-of-a-linked-list/description" target="_blank" rel="noopener noreferrer">Delete the Middle Node of a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list. <strong>Delete</strong> the <strong>middle node</strong>, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>

<p>The <strong>middle node</strong> of a linked list of size <code>n</code> is the <code>&lfloor;n / 2&rfloor;<sup>th</sup></code> node from the <b>start</b> using <strong>0-based indexing</strong>, where <code>&lfloor;x&rfloor;</code> denotes the largest integer less than or equal to <code>x</code>.</p>

<ul>
	<li>For <code>n</code> = <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>, the middle nodes are <code>0</code>, <code>1</code>, <code>1</code>, <code>2</code>, and <code>2</code>, respectively.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png" style="width: 500px; height: 77px;" />
<pre>
<strong>Input:</strong> head = [1,3,4,7,1,2,6]
<strong>Output:</strong> [1,3,4,1,2,6]
<strong>Explanation:</strong>
The above figure represents the given linked list. The indices of the nodes are written below.
Since n = 7, node 3 with value 7 is the middle node, which is marked in red.
We return the new list after removing this node. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png" style="width: 250px; height: 43px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [1,2,4]
<strong>Explanation:</strong>
The above figure represents the given linked list.
For n = 4, node 2 with value 3 is the middle node, which is marked in red.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png" style="width: 150px; height: 58px;" />
<pre>
<strong>Input:</strong> head = [2,1]
<strong>Output:</strong> [2]
<strong>Explanation:</strong>
The above figure represents the given linked list.
For n = 2, node 1 with value 1 is the middle node, which is marked in red.
Node 0 with value 2 is the only node remaining after removing node 1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-a-text-editor/description" target="_blank" rel="noopener noreferrer">Design a Text Editor</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a text editor with a cursor that can do the following:</p>

<ul>
	<li><strong>Add</strong> text to where the cursor is.</li>
	<li><strong>Delete</strong> text from where the cursor is (simulating the backspace key).</li>
	<li><strong>Move</strong> the cursor either left or right.</li>
</ul>

<p>When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that <code>0 &lt;= cursor.position &lt;= currentText.length</code> always holds.</p>

<p>Implement the <code>TextEditor</code> class:</p>

<ul>
	<li><code>TextEditor()</code> Initializes the object with empty text.</li>
	<li><code>void addText(string text)</code> Appends <code>text</code> to where the cursor is. The cursor ends to the right of <code>text</code>.</li>
	<li><code>int deleteText(int k)</code> Deletes <code>k</code> characters to the left of the cursor. Returns the number of characters actually deleted.</li>
	<li><code>string cursorLeft(int k)</code> Moves the cursor to the left <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>
	<li><code>string cursorRight(int k)</code> Moves the cursor to the right <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;TextEditor&quot;, &quot;addText&quot;, &quot;deleteText&quot;, &quot;addText&quot;, &quot;cursorRight&quot;, &quot;cursorLeft&quot;, &quot;deleteText&quot;, &quot;cursorLeft&quot;, &quot;cursorRight&quot;]
[[], [&quot;leetcode&quot;], [4], [&quot;practice&quot;], [3], [8], [10], [2], [6]]
<strong>Output</strong>
[null, null, 4, null, &quot;etpractice&quot;, &quot;leet&quot;, 4, &quot;&quot;, &quot;practi&quot;]

<strong>Explanation</strong>
TextEditor textEditor = new TextEditor(); // The current text is &quot;|&quot;. (The &#39;|&#39; character represents the cursor)
textEditor.addText(&quot;leetcode&quot;); // The current text is &quot;leetcode|&quot;.
textEditor.deleteText(4); // return 4
                          // The current text is &quot;leet|&quot;. 
                          // 4 characters were deleted.
textEditor.addText(&quot;practice&quot;); // The current text is &quot;leetpractice|&quot;. 
textEditor.cursorRight(3); // return &quot;etpractice&quot;
                           // The current text is &quot;leetpractice|&quot;. 
                           // The cursor cannot be moved beyond the actual text and thus did not move.
                           // &quot;etpractice&quot; is the last 10 characters to the left of the cursor.
textEditor.cursorLeft(8); // return &quot;leet&quot;
                          // The current text is &quot;leet|practice&quot;.
                          // &quot;leet&quot; is the last min(10, 4) = 4 characters to the left of the cursor.
textEditor.deleteText(10); // return 4
                           // The current text is &quot;|practice&quot;.
                           // Only 4 characters were deleted.
textEditor.cursorLeft(2); // return &quot;&quot;
                          // The current text is &quot;|practice&quot;.
                          // The cursor cannot be moved beyond the actual text and thus did not move. 
                          // &quot;&quot; is the last min(10, 0) = 0 characters to the left of the cursor.
textEditor.cursorRight(6); // return &quot;practi&quot;
                           // The current text is &quot;practi|ce&quot;.
                           // &quot;practi&quot; is the last min(10, 6) = 6 characters to the left of the cursor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length, k &lt;= 40</code></li>
	<li><code>text</code> consists of lowercase English letters.</li>
	<li>At most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>addText</code>, <code>deleteText</code>, <code>cursorLeft</code> and <code>cursorRight</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Could you find a solution with time complexity of <code>O(k)</code> per call?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-authentication-manager/description" target="_blank" rel="noopener noreferrer">Design Authentication Manager</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire <code>timeToLive</code> seconds after the <code>currentTime</code>. If the token is renewed, the expiry time will be <b>extended</b> to expire <code>timeToLive</code> seconds after the (potentially different) <code>currentTime</code>.</p>

<p>Implement the <code>AuthenticationManager</code> class:</p>

<ul>
	<li><code>AuthenticationManager(int timeToLive)</code> constructs the <code>AuthenticationManager</code> and sets the <code>timeToLive</code>.</li>
	<li><code>generate(string tokenId, int currentTime)</code> generates a new token with the given <code>tokenId</code> at the given <code>currentTime</code> in seconds.</li>
	<li><code>renew(string tokenId, int currentTime)</code> renews the <strong>unexpired</strong> token with the given <code>tokenId</code> at the given <code>currentTime</code> in seconds. If there are no unexpired tokens with the given <code>tokenId</code>, the request is ignored, and nothing happens.</li>
	<li><code>countUnexpiredTokens(int currentTime)</code> returns the number of <strong>unexpired</strong> tokens at the given currentTime.</li>
</ul>

<p>Note that if a token expires at time <code>t</code>, and another action happens on time <code>t</code> (<code>renew</code> or <code>countUnexpiredTokens</code>), the expiration takes place <strong>before</strong> the other actions.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png" style="width: 500px; height: 287px;" />
<pre>
<strong>Input</strong>
[&quot;AuthenticationManager&quot;, &quot;<code>renew</code>&quot;, &quot;generate&quot;, &quot;<code>countUnexpiredTokens</code>&quot;, &quot;generate&quot;, &quot;<code>renew</code>&quot;, &quot;<code>renew</code>&quot;, &quot;<code>countUnexpiredTokens</code>&quot;]
[[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]]
<strong>Output</strong>
[null, null, null, 1, null, null, null, 0]

<strong>Explanation</strong>
AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with <code>timeToLive</code> = 5 seconds.
authenticationManager.<code>renew</code>(&quot;aaa&quot;, 1); // No token exists with tokenId &quot;aaa&quot; at time 1, so nothing happens.
authenticationManager.generate(&quot;aaa&quot;, 2); // Generates a new token with tokenId &quot;aaa&quot; at time 2.
authenticationManager.<code>countUnexpiredTokens</code>(6); // The token with tokenId &quot;aaa&quot; is the only unexpired one at time 6, so return 1.
authenticationManager.generate(&quot;bbb&quot;, 7); // Generates a new token with tokenId &quot;bbb&quot; at time 7.
authenticationManager.<code>renew</code>(&quot;aaa&quot;, 8); // The token with tokenId &quot;aaa&quot; expired at time 7, and 8 &gt;= 7, so at time 8 the <code>renew</code> request is ignored, and nothing happens.
authenticationManager.<code>renew</code>(&quot;bbb&quot;, 10); // The token with tokenId &quot;bbb&quot; is unexpired at time 10, so the <code>renew</code> request is fulfilled and now the token will expire at time 15.
authenticationManager.<code>countUnexpiredTokens</code>(15); // The token with tokenId &quot;bbb&quot; expires at time 15, and the token with tokenId &quot;aaa&quot; expired at time 7, so currently no token is unexpired, so return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= timeToLive &lt;= 10<sup>8</sup></code></li>
	<li><code>1 &lt;= currentTime &lt;= 10<sup>8</sup></code></li>
	<li><code>1 &lt;= tokenId.length &lt;= 5</code></li>
	<li><code>tokenId</code> consists only of lowercase letters.</li>
	<li>All calls to <code>generate</code> will contain unique values of <code>tokenId</code>.</li>
	<li>The values of <code>currentTime</code> across all the function calls will be <strong>strictly increasing</strong>.</li>
	<li>At most <code>2000</code> calls will be made to all functions combined.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-browser-history/description" target="_blank" rel="noopener noreferrer">Design Browser History</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a <strong>browser</strong> of one tab where you start on the <code>homepage</code> and you can visit another <code>url</code>, get back in the history number of <code>steps</code> or move forward in the history number of <code>steps</code>.</p>

<p>Implement the <code>BrowserHistory</code> class:</p>

<ul>
	<li><code>BrowserHistory(string homepage)</code> Initializes the object with the <code>homepage</code>&nbsp;of the browser.</li>
	<li><code>void visit(string url)</code>&nbsp;Visits&nbsp;<code>url</code> from the current page. It clears up all the forward history.</li>
	<li><code>string back(int steps)</code>&nbsp;Move <code>steps</code> back in history. If you can only return <code>x</code> steps in the history and <code>steps &gt; x</code>, you will&nbsp;return only <code>x</code> steps. Return the current <code>url</code>&nbsp;after moving back in history <strong>at most</strong> <code>steps</code>.</li>
	<li><code>string forward(int steps)</code>&nbsp;Move <code>steps</code> forward in history. If you can only forward <code>x</code> steps in the history and <code>steps &gt; x</code>, you will&nbsp;forward only&nbsp;<code>x</code> steps. Return the current <code>url</code>&nbsp;after forwarding in history <strong>at most</strong> <code>steps</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example:</strong></p>

<pre>
<b>Input:</b>
[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]
[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]
<b>Output:</b>
[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]

<b>Explanation:</b>
BrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;);
browserHistory.visit(&quot;google.com&quot;);       // You are in &quot;leetcode.com&quot;. Visit &quot;google.com&quot;
browserHistory.visit(&quot;facebook.com&quot;);     // You are in &quot;google.com&quot;. Visit &quot;facebook.com&quot;
browserHistory.visit(&quot;youtube.com&quot;);      // You are in &quot;facebook.com&quot;. Visit &quot;youtube.com&quot;
browserHistory.back(1);                   // You are in &quot;youtube.com&quot;, move back to &quot;facebook.com&quot; return &quot;facebook.com&quot;
browserHistory.back(1);                   // You are in &quot;facebook.com&quot;, move back to &quot;google.com&quot; return &quot;google.com&quot;
browserHistory.forward(1);                // You are in &quot;google.com&quot;, move forward to &quot;facebook.com&quot; return &quot;facebook.com&quot;
browserHistory.visit(&quot;linkedin.com&quot;);     // You are in &quot;facebook.com&quot;. Visit &quot;linkedin.com&quot;
browserHistory.forward(2);                // You are in &quot;linkedin.com&quot;, you cannot move forward any steps.
browserHistory.back(2);                   // You are in &quot;linkedin.com&quot;, move back two steps to &quot;facebook.com&quot; then to &quot;google.com&quot;. return &quot;google.com&quot;
browserHistory.back(7);                   // You are in &quot;google.com&quot;, you can move back only one step to &quot;leetcode.com&quot;. return &quot;leetcode.com&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= homepage.length &lt;= 20</code></li>
	<li><code>1 &lt;= url.length &lt;= 20</code></li>
	<li><code>1 &lt;= steps &lt;= 100</code></li>
	<li><code>homepage</code> and <code>url</code> consist of&nbsp; &#39;.&#39; or lower case English letters.</li>
	<li>At most <code>5000</code>&nbsp;calls will be made to <code>visit</code>, <code>back</code>, and <code>forward</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-circular-deque/description" target="_blank" rel="noopener noreferrer">Design Circular Deque</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">linked list</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design your implementation of the circular double-ended queue (deque).</p>

<p>Implement the <code>MyCircularDeque</code> class:</p>

<ul>
	<li><code>MyCircularDeque(int k)</code> Initializes the deque with a maximum size of <code>k</code>.</li>
	<li><code>boolean insertFront()</code> Adds an item at the front of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>
	<li><code>boolean insertLast()</code> Adds an item at the rear of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>
	<li><code>boolean deleteFront()</code> Deletes an item from the front of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>
	<li><code>boolean deleteLast()</code> Deletes an item from the rear of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>
	<li><code>int getFront()</code> Returns the front item from the Deque. Returns <code>-1</code> if the deque is empty.</li>
	<li><code>int getRear()</code> Returns the last item from Deque. Returns <code>-1</code> if the deque is empty.</li>
	<li><code>boolean isEmpty()</code> Returns <code>true</code> if the deque is empty, or <code>false</code> otherwise.</li>
	<li><code>boolean isFull()</code> Returns <code>true</code> if the deque is full, or <code>false</code> otherwise.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyCircularDeque&quot;, &quot;insertLast&quot;, &quot;insertLast&quot;, &quot;insertFront&quot;, &quot;insertFront&quot;, &quot;getRear&quot;, &quot;isFull&quot;, &quot;deleteLast&quot;, &quot;insertFront&quot;, &quot;getFront&quot;]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
<strong>Output</strong>
[null, true, true, true, false, 2, true, true, true, 4]

<strong>Explanation</strong>
MyCircularDeque myCircularDeque = new MyCircularDeque(3);
myCircularDeque.insertLast(1);  // return True
myCircularDeque.insertLast(2);  // return True
myCircularDeque.insertFront(3); // return True
myCircularDeque.insertFront(4); // return False, the queue is full.
myCircularDeque.getRear();      // return 2
myCircularDeque.isFull();       // return True
myCircularDeque.deleteLast();   // return True
myCircularDeque.insertFront(4); // return True
myCircularDeque.getFront();     // return 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= 1000</code></li>
	<li><code>0 &lt;= value &lt;= 1000</code></li>
	<li>At most <code>2000</code> calls will be made to <code>insertFront</code>, <code>insertLast</code>, <code>deleteFront</code>, <code>deleteLast</code>, <code>getFront</code>, <code>getRear</code>, <code>isEmpty</code>, <code>isFull</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are asked to design a circular double-ended queue (deque) data structure. In a deque, we need to provide fast access to the first (front) and last (rear) elements, as well as an efficient way to add/remove elements at the front and rear.</p>
<p>We note that a circular deque is a specific implementation of a deque where the last element loops back to the first element, creating a circular assortment. Since this particular implementation is not enforced for a correct submission, we will go over two approaches: one that will satisfy the required deque operations without storing our elements in a circle, and one that will cover a more proper implementation of a circular deque.</p>
<h3 id="approach-1-linked-list">Approach 1: Linked List</h3>
<h3 id="intuition">Intuition</h3>
<p>If we aren't following the circular ordering of a circular deque, we can achieve an implementation by considering existing data structures that provide efficient ways to access the front and rear elements to add or remove elements.</p>
<p>One example of this is the doubly linked list data structure in which each node contains a reference to the next node as well as the previous node. The doubly linked list data structure also maintains pointers to the head (front element) as well as the rear (last element). This makes adding/removing elements to the front and rear fairly simple:</p>
<ul>
<li>To add a new node to the front, we first instantiate the new node and have it point to the current front node as its next node. We also want to make the current front node point to the new node as its previous node. Then, we update our reference of the head to this new front node.</li>
<li>To remove the front node, we can simply advance our head pointer by one.</li>
<li>To add a new node to the rear, we instantiate the new node and have the current rear node point to it as its next node. We also want the new node to point back to the current rear node as its previous node. Then, we update our reference of the rear to this new rear node.</li>
<li>To remove the rear node, we can simply move our rear pointer back by one node, by accessing the previous node of the rear node.</li>
</ul>
<p>With these pointer manipulations, we can fully support the required deque operations.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>Create a new <code>Node</code> class where each node contains a value <code>val</code>, a reference to its next node <code>next</code>, and a reference to its previous node <code>prev</code></li>
<li>The given <code>MyCircularDeque</code> class will then contain two <code>Node</code> references: one for the head of the deque, and one for the rear. It will also have a <code>size</code> field and <code>capacity</code> field to keep track of the current size and maximum size of the deque, respectively.</li>
<li>Defining constructor:
<ul>
<li>Initialize <code>size = 0</code> since our deque is initially empty and <code>capacity = k</code>.</li>
</ul>
</li>
<li>Defining <code>insertFront(int value)</code>:
<ul>
<li>If <code>isFull()</code> is true, we don't have room to insert a new node so we return <code>false</code>.</li>
<li>Otherwise, we add the node:
<ul>
<li>If <code>head == null</code>, this will be the first element in the list
<ul>
<li>Have <code>head</code> point to a new node with value <code>value</code></li>
<li>Have <code>rear</code> point to the new node as well</li>
</ul>
</li>
<li>Otherwise, there already exists at least 1 element in the list:
<ul>
<li>Create a new node <code>newHead</code> that points to <code>head</code> as its next node</li>
<li>Have <code>head.prev</code> point back to <code>newHead</code> as its previous node</li>
<li>Update <code>head</code> to point to the <code>newHead</code></li>
</ul>
</li>
<li>Increment <code>size</code> and return <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>Defining <code>insertLast(int value)</code>:
<ul>
<li>If <code>isFull()</code> is true, we don't have room to insert a new node so we return <code>false</code></li>
<li>Otherwise, we add the node:
<ul>
<li>If <code>head == null</code>, this will be the first element in the list
<ul>
<li>Have <code>head</code> point to a new node with value <code>value</code></li>
<li>Have <code>rear</code> point to the new node as well</li>
</ul>
</li>
<li>Otherwise, there already exists at least 1 element in the list:
<ul>
<li>Have <code>rear.next</code> point to a new node with <code>val = value</code> and <code>prev = rear</code>.</li>
<li>Update the <code>rear = rear.next</code> so it points to the new rear</li>
</ul>
</li>
<li>Increment <code>size</code> and return <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>Defining <code>deleteFront()</code>:
<ul>
<li>If <code>isEmpty()</code> is true, there are no nodes to delete so we return <code>false</code></li>
<li>Otherwise, we delete the front element:
<ul>
<li>If <code>size == 1</code>, then this deletion will make the deque empty, so make <code>head</code> and <code>rear</code> both <code>null</code></li>
<li>Otherwise, we can delete the existing <code>head</code> node by simply updating <code>head = head.next</code></li>
<li>We decrement <code>size</code> and return <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>Defining <code>deleteLast()</code>:
<ul>
<li>If <code>isEmpty()</code> is true, then there are no nodes to delete so we return <code>false</code></li>
<li>Otherwise, we delete the rear element:
<ul>
<li>If <code>size == 1</code>, then this deletion will make the deque empty, so make <code>head</code> and <code>rear</code> both <code>null</code></li>
<li>Otherwise, we can move <code>rear</code> back 1 node by updating <code>rear = rear.next</code></li>
<li>We decrement <code>size</code> and return <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>Defining <code>getFront()</code>:
<ul>
<li>If <code>isEmpty()</code> there is no front node so return -1.</li>
<li>Otherwise, return <code>head.val</code></li>
</ul>
</li>
<li>Defining <code>getRear()</code>:
<ul>
<li>If <code>isEmpty()</code> there is no rear node so return -1.</li>
<li>Otherwise, return <code>rear.val</code></li>
</ul>
</li>
<li>Defining <code>isEmpty()</code>:
<ul>
<li>Return <code>size == 0</code> to see if there are any nodes in our deque</li>
</ul>
</li>
<li>Defining <code>isFull()</code>:
<ul>
<li>Return <code>size == capacity</code> to see if our current size is the maximum size.</li>
</ul>
</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/HEXctuWu/shared">code</a></p>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Because we maintain access to the front and rear elements at all times, all operations simply involve pointer manipulations that take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(k)\)</span></p>
<p>In the worst case, there will be maximum <span class="math inline">\(k\)</span> nodes in our doubly linked list, which will involve instantiating <span class="math inline">\(k\)</span> node objects and thus take <span class="math inline">\(O(k)\)</span> space.</p>
</li>
</ul>
<h3 id="approach-2-fixed-array-with-circular-ordering">Approach 2: Fixed Array with Circular Ordering</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In Approach 1, we opted to use a doubly linked list in which the elements don't wrap around. For this approach, we will use a fixed-sized array that will have the elements placed circularly.</p>
<p>Similar to before, we can maintain quick access to the front and the rear of our deque. For our fixed-sized array approach, this means we will keep track of the indices of the front and rear elements via two variables <code>front</code> and <code>rear</code>. With our linked list approach, this required dynamically creating new nodes at the front and rear of our list. For this fixed-sized circular array approach, we will have to use some arithmetic and modulo operations to keep track of the <code>front</code> and <code>rear</code>. Let's dive into how to update these indices as we support the add/removal operations:</p>
<ul>
<li>When adding a new element to the front, we know that this element must be placed in front of the existing front element. In terms of indexing, it should be placed directly to the left of the element at <code>front</code>, which would be at an index of <code>front - 1</code>. In the case that <code>front - 1</code> &lt; 0, the index can be recalculated as <code>(front - 1 + k) % k)</code>, which will give us the index in case the front element goes beyond the first index and wraps back around to the end of the deque. Note that when <code>front - 1 &gt;= 0</code>, <code>front - 1 == (front - 1 + k) % k</code> so it'll have no effect as expected. Now that we have updated the <code>front</code> index, we can add the element by placing it at index <code>front</code> in the array.</li>
<li>When deleting a new element at the front, we can do the opposite of adding a new element at the front: We increment <code>front</code> by 1 so that it will point to the element directly to the right of the front element, effectively deleting the original front element. Similar to before, <code>front + 1</code> can go beyond the last possible index <code>k - 1</code> and wrap around back to the first index. To cover this case, we will update <code>front</code> to <code>(front + 1) % k</code>.</li>
<li>When adding a new element to the rear, we know that this element will be added to the right of the existing rear, placing it at an index of <code>(rear + 1) % k</code>.</li>
<li>To remove the rear node, we can reverse the above operation, and update <code>rear = (rear - 1 + k) % k</code>.</li>
</ul>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>Defining constructor:
<ul>
<li>We can initialize an array <code>array</code> of size <code>k</code> to represent our circular deque</li>
<li>We initialize current <code>size = 0</code> and maximum allowed size <code>capacity = k</code></li>
<li>We also want to keep track of the indices of the front and rear elements so we set <code>front = 0</code> and <code>rear = k - 1</code>. Note that setting <code>rear = k - 1</code> conveniently makes <code>front == rear</code> after adding our first element to the deque.</li>
</ul>
</li>
<li>Defining <code>insertFront(int value)</code>:
<ul>
<li>If <code>isFull()</code>: return <code>false</code> since there's no room to add new elements</li>
<li>Otherwise, update our front index <code>front = (front - 1 + capacity) % capacity</code> and set <code>array[front] = value</code></li>
<li>Increment <code>size</code></li>
</ul>
</li>
<li>Defining <code>insertLast(int value)</code>:
<ul>
<li>If <code>isFull()</code>, return <code>false</code> since there's no room to add new elements</li>
<li>Otherwise, update our rear index <code>rear = (rear + 1) % capacity</code> and set <code>array[rear] = value</code></li>
<li>Increment <code>size</code></li>
</ul>
</li>
<li>Defining <code>deleteFront(int value)</code>:
<ul>
<li>If <code>isEmpty()</code>, return <code>false</code> since there are no elements to delete</li>
<li>Otherwise, move the front index to the right by 1: <code>front = (front + 1) &amp; capacity</code>, decrement <code>size</code>, and return <code>true</code></li>
</ul>
</li>
<li>Defining <code>deleteLast(int value)</code>:
<ul>
<li>If <code>isEmpty()</code>, return <code>false</code> since there are no elements to delete</li>
<li>Otherwise, move the rear index to the left by 1: <code>rear = (rear - 1 + capacity) % capacity</code>, decrement <code>size</code>, and return <code>true</code></li>
</ul>
</li>
<li>Defining <code>getFront()</code>:
<ul>
<li>If <code>isEmpty()</code>, return -1</li>
<li>Otherwise, return <code>array[front]</code></li>
</ul>
</li>
<li>Defining <code>getRear()</code>:
<ul>
<li>If <code>isEmpty()</code>, return -1</li>
<li>Otherwise, return <code>array[rear]</code></li>
</ul>
</li>
<li>Defining <code>isEmpty()</code>:
<ul>
<li>Return <code>size == 0</code></li>
</ul>
</li>
<li>Defining <code>isFull()</code>:
<ul>
<li>Return <code>size == capacity</code></li>
</ul>
</li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/QNyW8S5G/shared">code</a></p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Similar to Approach 1, we maintain the references for the front and rear elements at all times, where all operations are simply arithmetic operations that take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(k)\)</span></p>
<p>Our fixed-sized array will always have <span class="math inline">\(k\)</span> elements and thus will take <span class="math inline">\(O(k)\)</span> space.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-circular-queue/description" target="_blank" rel="noopener noreferrer">Design Circular Queue</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">linked list</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called &quot;Ring Buffer&quot;.</p>

<p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p>

<p>Implement the <code>MyCircularQueue</code> class:</p>

<ul>
	<li><code>MyCircularQueue(k)</code> Initializes the object with the size of the queue to be <code>k</code>.</li>
	<li><code>int Front()</code> Gets the front item from the queue. If the queue is empty, return <code>-1</code>.</li>
	<li><code>int Rear()</code> Gets the last item from the queue. If the queue is empty, return <code>-1</code>.</li>
	<li><code>boolean enQueue(int value)</code> Inserts an element into the circular queue. Return <code>true</code> if the operation is successful.</li>
	<li><code>boolean deQueue()</code> Deletes an element from the circular queue. Return <code>true</code> if the operation is successful.</li>
	<li><code>boolean isEmpty()</code> Checks whether the circular queue is empty or not.</li>
	<li><code>boolean isFull()</code> Checks whether the circular queue is full or not.</li>
</ul>

<p>You must solve the problem without using the built-in queue data structure in your programming language.&nbsp;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
<strong>Output</strong>
[null, true, true, true, false, 3, true, true, true, 4]

<strong>Explanation</strong>
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= 1000</code></li>
	<li><code>0 &lt;= value &lt;= 1000</code></li>
	<li>At most <code>3000</code> calls will be made to&nbsp;<code>enQueue</code>, <code>deQueue</code>,&nbsp;<code>Front</code>,&nbsp;<code>Rear</code>,&nbsp;<code>isEmpty</code>, and&nbsp;<code>isFull</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-front-middle-back-queue/description" target="_blank" rel="noopener noreferrer">Design Front Middle Back Queue</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">linked list</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a queue that supports <code>push</code> and <code>pop</code> operations in the front, middle, and back.</p>

<p>Implement the <code>FrontMiddleBack</code> class:</p>

<ul>
	<li><code>FrontMiddleBack()</code> Initializes the queue.</li>
	<li><code>void pushFront(int val)</code> Adds <code>val</code> to the <strong>front</strong> of the queue.</li>
	<li><code>void pushMiddle(int val)</code> Adds <code>val</code> to the <strong>middle</strong> of the queue.</li>
	<li><code>void pushBack(int val)</code> Adds <code>val</code> to the <strong>back</strong> of the queue.</li>
	<li><code>int popFront()</code> Removes the <strong>front</strong> element of the queue and returns it. If the queue is empty, return <code>-1</code>.</li>
	<li><code>int popMiddle()</code> Removes the <strong>middle</strong> element of the queue and returns it. If the queue is empty, return <code>-1</code>.</li>
	<li><code>int popBack()</code> Removes the <strong>back</strong> element of the queue and returns it. If the queue is empty, return <code>-1</code>.</li>
</ul>

<p><strong>Notice</strong> that when there are <b>two</b> middle position choices, the operation is performed on the <strong>frontmost</strong> middle position choice. For example:</p>

<ul>
	<li>Pushing <code>6</code> into the middle of <code>[1, 2, 3, 4, 5]</code> results in <code>[1, 2, <u>6</u>, 3, 4, 5]</code>.</li>
	<li>Popping the middle from <code>[1, 2, <u>3</u>, 4, 5, 6]</code> returns <code>3</code> and results in <code>[1, 2, 4, 5, 6]</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong>
[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;, &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]
[[], [1], [2], [3], [4], [], [], [], [], []]
<strong>Output:</strong>
[null, null, null, null, null, 1, 3, 4, 2, -1]

<strong>Explanation:</strong>
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [<u>1</u>]
q.pushBack(2);    // [1, <u>2</u>]
q.pushMiddle(3);  // [1, <u>3</u>, 2]
q.pushMiddle(4);  // [1, <u>4</u>, 3, 2]
q.popFront();     // return 1 -&gt; [4, 3, 2]
q.popMiddle();    // return 3 -&gt; [4, 2]
q.popMiddle();    // return 4 -&gt; [2]
q.popBack();      // return 2 -&gt; []
q.popFront();     // return -1 -&gt; [] (The queue is empty)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= val &lt;= 10<sup>9</sup></code></li>
	<li>At most&nbsp;<code>1000</code>&nbsp;calls will be made to&nbsp;<code>pushFront</code>,&nbsp;<code>pushMiddle</code>,&nbsp;<code>pushBack</code>, <code>popFront</code>, <code>popMiddle</code>, and <code>popBack</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-hashmap/description" target="_blank" rel="noopener noreferrer">Design HashMap</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">hash function</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a HashMap without using any built-in hash table libraries.</p>

<p>Implement the <code>MyHashMap</code> class:</p>

<ul>
	<li><code>MyHashMap()</code> initializes the object with an empty map.</li>
	<li><code>void put(int key, int value)</code> inserts a <code>(key, value)</code> pair into the HashMap. If the <code>key</code> already exists in the map, update the corresponding <code>value</code>.</li>
	<li><code>int get(int key)</code> returns the <code>value</code> to which the specified <code>key</code> is mapped, or <code>-1</code> if this map contains no mapping for the <code>key</code>.</li>
	<li><code>void remove(key)</code> removes the <code>key</code> and its corresponding <code>value</code> if the map contains the mapping for the <code>key</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
<strong>Output</strong>
[null, null, null, 1, -1, null, 1, null, -1]

<strong>Explanation</strong>
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>put</code>, <code>get</code>, and <code>remove</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-hashset/description" target="_blank" rel="noopener noreferrer">Design HashSet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">hash function</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a HashSet without using any built-in hash table libraries.</p>

<p>Implement <code>MyHashSet</code> class:</p>

<ul>
	<li><code>void add(key)</code> Inserts the value <code>key</code> into the HashSet.</li>
	<li><code>bool contains(key)</code> Returns whether the value <code>key</code> exists in the HashSet or not.</li>
	<li><code>void remove(key)</code> Removes the value <code>key</code> in the HashSet. If <code>key</code> does not exist in the HashSet, do nothing.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
<strong>Output</strong>
[null, null, null, true, false, null, true, null, false]

<strong>Explanation</strong>
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // return True
myHashSet.contains(3); // return False, (not found)
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // return True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // return False, (already removed)</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>, <code>remove</code>, and <code>contains</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-linked-list/description" target="_blank" rel="noopener noreferrer">Design Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br />
A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br />
If you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>

<p>Implement the <code>MyLinkedList</code> class:</p>

<ul>
	<li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li>
	<li><code>int get(int index)</code> Get the value of the <code>index<sup>th</sup></code> node in the linked list. If the index is invalid, return <code>-1</code>.</li>
	<li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>
	<li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li>
	<li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code> before the <code>index<sup>th</sup></code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>
	<li><code>void deleteAtIndex(int index)</code> Delete the <code>index<sup>th</sup></code> node in the linked list, if the index is valid.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]
[[], [1], [3], [1, 2], [1], [1], [1]]
<strong>Output</strong>
[null, null, null, null, 2, null, 3]

<strong>Explanation</strong>
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3
myLinkedList.get(1);              // return 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= index, val &lt;= 1000</code></li>
	<li>Please do not use the built-in LinkedList library.</li>
	<li>At most <code>2000</code> calls will be made to <code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> and <code>deleteAtIndex</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-skiplist/description" target="_blank" rel="noopener noreferrer">Design Skiplist</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a <strong>Skiplist</strong> without using any built-in libraries.</p>

<p>A <strong>skiplist</strong> is a data structure that takes <code>O(log(n))</code> time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.</p>

<p>For example, we have a Skiplist containing <code>[30,40,50,60,70,90]</code> and we want to add <code>80</code> and <code>45</code> into it. The Skiplist works this way:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif" style="width: 500px; height: 173px;" /><br />
<small>Artyom Kalinin [CC BY-SA 3.0], via <a href="https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif" target="_blank" title="Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons">Wikimedia Commons</a></small></p>

<p>You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than <code>O(n)</code>. It can be proven that the average time complexity for each operation is <code>O(log(n))</code> and space complexity is <code>O(n)</code>.</p>

<p>See more about Skiplist: <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank">https://en.wikipedia.org/wiki/Skip_list</a></p>

<p>Implement the <code>Skiplist</code> class:</p>

<ul>
	<li><code>Skiplist()</code> Initializes the object of the skiplist.</li>
	<li><code>bool search(int target)</code> Returns <code>true</code> if the integer <code>target</code> exists in the Skiplist or <code>false</code> otherwise.</li>
	<li><code>void add(int num)</code> Inserts the value <code>num</code> into the SkipList.</li>
	<li><code>bool erase(int num)</code> Removes the value <code>num</code> from the Skiplist and returns <code>true</code>. If <code>num</code> does not exist in the Skiplist, do nothing and return <code>false</code>. If there exist multiple <code>num</code> values, removing any one of them is fine.</li>
</ul>

<p>Note that duplicates may exist in the Skiplist, your code needs to handle this situation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Skiplist&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;search&quot;, &quot;add&quot;, &quot;search&quot;, &quot;erase&quot;, &quot;erase&quot;, &quot;search&quot;]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
<strong>Output</strong>
[null, null, null, null, false, null, true, false, true, false]

<strong>Explanation</strong>
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0); // return False
skiplist.add(4);
skiplist.search(1); // return True
skiplist.erase(0);  // return False, 0 is not in skiplist.
skiplist.erase(1);  // return True
skiplist.search(1); // return False, 1 has already been erased.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= num, target &lt;= 2 * 10<sup>4</sup></code></li>
	<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>search</code>, <code>add</code>, and <code>erase</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-twitter/description" target="_blank" rel="noopener noreferrer">Design Twitter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the <code>10</code> most recent tweets in the user&#39;s news feed.</p>

<p>Implement the <code>Twitter</code> class:</p>

<ul>
	<li><code>Twitter()</code> Initializes your twitter object.</li>
	<li><code>void postTweet(int userId, int tweetId)</code> Composes a new tweet with ID <code>tweetId</code> by the user <code>userId</code>. Each call to this function will be made with a unique <code>tweetId</code>.</li>
	<li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> Retrieves the <code>10</code> most recent tweet IDs in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be <strong>ordered from most recent to least recent</strong>.</li>
	<li><code>void follow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started following the user with ID <code>followeeId</code>.</li>
	<li><code>void unfollow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started unfollowing the user with ID <code>followeeId</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Twitter&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;follow&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;unfollow&quot;, &quot;getNewsFeed&quot;]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
<strong>Output</strong>
[null, null, [5], null, null, [6, 5], null, [5]]

<strong>Explanation</strong>
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).
twitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5]. return [5]
twitter.follow(1, 2);    // User 1 follows user 2.
twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).
twitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.unfollow(1, 2);  // User 1 unfollows user 2.
twitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5], since user 1 is no longer following user 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= userId, followerId, followeeId &lt;= 500</code></li>
	<li><code>0 &lt;= tweetId &lt;= 10<sup>4</sup></code></li>
	<li>All the tweets have <strong>unique</strong> IDs.</li>
	<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>postTweet</code>, <code>getNewsFeed</code>, <code>follow</code>, and <code>unfollow</code>.</li>
	<li>A user cannot follow himself.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/double-a-number-represented-as-a-linked-list/description" target="_blank" rel="noopener noreferrer">Double a Number Represented as a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">math</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a <strong>non-empty</strong> linked list representing a non-negative integer without leading zeroes.</p>

<p>Return <em>the </em><code>head</code><em> of the linked list after <strong>doubling</strong> it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/05/28/example.png" style="width: 401px; height: 81px;" />
<pre>
<strong>Input:</strong> head = [1,8,9]
<strong>Output:</strong> [3,7,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/05/28/example2.png" style="width: 401px; height: 81px;" />
<pre>
<strong>Input:</strong> head = [9,9,9]
<strong>Output:</strong> [1,9,9,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>4</sup>]</code></li>
	<li><font face="monospace"><code>0 &lt;= Node.val &lt;= 9</code></font></li>
	<li>The input is generated such that the list represents a number that does not have leading zeros, except the number <code>0</code> itself.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a singly linked list representing a non-negative integer and we need to return a linked list that represents the result of doubling the original number.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The linked list does not contain any negative integers nor any leading zeros.</li>
<li>The result of doubling a digit can be greater than 9. In such cases, we need to carry over the extra digit to the next node and accommodate it in the answer.</li>
</ol>
<hr />
<h3 id="approach-1-reversing-the-list">Approach 1: Reversing the List</h3>
<h4 id="intuition">Intuition</h4>
<p>Doubling a number can be performed by adding a number to itself. We can develop a solution by following the steps of addition, which are performed from the least significant to the most significant digit. Reversing the order of the nodes in the list would allow us to traverse the list starting with the least significant digit. Then, we double each digit and perform the carry to double the number.</p>
<p>The idea of reversing the list seems promising, as it would allow us to process the nodes in the opposite order, starting from the least significant digit. This could make the logic for handling the carry much easier to implement.</p>
<p>Why would this make the logic for handling the carry much easier?</p>
<p>Let's consider the example from the problem statement:</p>
<pre><code>Input: head = [1,8,9]
Output: [3,7,8]
</code></pre>
<p>Now, let's think about how we would typically process this number to double each digit and handle the carry.</p>
<p>If we were to process the digits from the most significant to the least significant, it would look like this:</p>
<ul>
<li>Double the most significant digit (1): 2</li>
<li>Handle the carry (2): The carry is 0, so we don't need to do anything.</li>
<li>Double the next digit (8): 16</li>
<li>Handle the carry (16): The carry is 1, which needs to be added to the previous digit.</li>
<li>Double the least significant digit (9): 18</li>
<li>Handle the carry (18): The carry is 1, which needs to be added to the previous digit.</li>
</ul>
<p>As we can see, handling the carry becomes more complicated as we move from the most significant digit to the least significant digit. We need to keep track of the carry and propagate it to the previous digit, which can become cumbersome, especially for longer numbers.</p>
<p>However, if we reverse the list, the problem becomes much simpler:</p>
<ul>
<li>Reverse the list: [9, 8, 1]</li>
<li>Double the least significant digit (9): 18</li>
<li>Handle the carry (18): The carry is 1, which can be easily added to the next digit.</li>
<li>Double the next digit (8): 16</li>
<li>Handle the carry (16): The carry is 1, which can be easily added to the next digit.</li>
<li>Double the most significant digit (1): 2</li>
<li>Handle the carry (2): The carry is 0, so we don't need to do anything.</li>
</ul>
<p>By reversing the list, we're effectively processing the digits from the least significant to the most significant. This simplifies the carry handling logic because the carry only depends on the current digit and the previous carry, rather than having to consider the entire number.</p>
<p>Once the list is reversed, we can iterate through the nodes and perform the following steps for each node:</p>
<ul>
<li>Double the value of the current node.</li>
<li>Add the carry (if any) from the previous operation.</li>
<li>Replace the data of the current node with the result modulo 10 (to handle values greater than 9).</li>
<li>Compute the new carry by integer division (to handle values greater than 9).</li>
</ul>
<p>After processing all the nodes, if there is any remaining carry, we create a new node with the carry value and append it to the list.</p>
<p>Finally, we reverse the list one more time to restore the original order of the nodes.</p>
<p>The following is an illustration demonstrating the reversing the list approach:</p>
<p>!?!../Documents/2816/brute_reversing.json:977,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li><code>doubleIt(head)</code> function:</li>
</ol>
<ul>
<li>Call the <code>reverseList(head)</code> helper function to reverse the input linked list and store it in <code>reversedList</code>.</li>
<li>Initialize two pointers, <code>current</code> and <code>previous</code>, to keep track of the current node and the previous node, respectively. Also, initialize a <code>carry</code> variable to <code>0</code>.</li>
<li>Traverse the reversed linked list:
<ul>
<li>For each node in the reversed list:
<ul>
<li>Calculate the new value for the current node by doubling the current value and adding the carry.</li>
<li>Update the current node's value with the new value modulo <code>10</code>.</li>
<li>Update the <code>carry</code> variable based on the new value (<code>1</code> if the new value is greater than <code>9</code>, <code>0</code> otherwise).</li>
<li>Move the <code>previous</code> and <code>current</code> pointers to the next nodes.</li>
</ul>
</li>
</ul>
</li>
<li>If there's a non-zero carry left after the loop, create a new node with the carry value and attach it to the end of the list.</li>
<li>Reverse the list back to its original order: Call the <code>reverseList(reversedList)</code> function to reverse the list back to its original order and store the result in <code>result</code>.</li>
<li>Return the <code>result</code> list.</li>
</ul>
<ol start="2">
<li><code>reverseList(node)</code> function:</li>
</ol>
<ul>
<li>Initialize three pointers <code>previous</code> (initially <code>NULL</code>), <code>current</code> (initially <code>node</code>), and <code>nextNode</code> (to temporarily store the next node).</li>
<li>Traverse the list and reverse the links:
<ul>
<li>While the <code>current</code> pointer is not <code>NULL</code>:
<ul>
<li>Store the next node in <code>nextNode</code>.</li>
<li>Reverse the link by setting <code>current-&gt;next</code> to <code>previous</code>.</li>
<li>Move the <code>previous</code> and <code>current</code> pointers to the next nodes.</li>
</ul>
</li>
</ul>
</li>
<li>After the loop, <code>previous</code> will be the new head of the reversed list, so return <code>previous</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FAqg2iD8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm involves traversing the linked list once to double the values and handle carry, performing constant-time operations for each node. So, it takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Reversing the list also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>In-place reversal is performed, so it doesn't incur significant extra space usage. Thus, the space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-stack">Approach 2: Using Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>While the first approach works, it might not be suitable in situations where integer overflow is a concern, such as in languages with fixed-size integer data types. Additionally, the previous approach made three passes through the linked list, which can be inefficient. In this case, we can consider an alternative approach using a stack to manage carry values for generating the new head. This approach ensures that we handle integer overflow concerns efficiently while also reducing the number of passes through the linked list.</p>
<p>The stack-based approach involves traversing the list from head to tail and pushing each node's value onto a stack. This effectively reverses the order of the digits since the stack operates on the Last In, First Out (LIFO) principle. This reversal makes it easier to handle the carry. Instead of modifying the linked list in place, we build a new linked list to store the result. We build this list from tail to head, which eliminates the need for an additional reversal compared to the previous approach.</p>
<blockquote>
<p>Learn more about stacks by reading our <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card</a>.</p>
</blockquote>
<p>We then start popping values from the stack and perform the necessary doubling and carry-handling operations. If there is any carry left after processing the stack, we create a new node with the carry value and prepend it to the result linked list.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an empty stack <code>values</code> to store the values of the linked list nodes.</li>
<li>Initialize a variable <code>val</code> to hold the carryover value when doubling digits.</li>
<li>Traverse the linked list and push the values of the nodes onto the stack.</li>
<li>Initialize the tail of the new linked list as <code>null</code>.</li>
<li>Iterate over the stack of values:
<ul>
<li>Create a new <code>ListNode</code> with value <code>0</code> and the previous tail as its next node.</li>
<li>If the stack is not empty, pop the top value, double it, and add it to the <code>val</code>.</li>
<li>Set the value of the new node to the units digit of the new value.</li>
<li>Update the <code>val</code> to hold the carryover value for the next iteration.</li>
</ul>
</li>
<li>Return the tail of the new linked list.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/FgeXRH6a/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm traverses the linked list once to push its values onto the stack, which takes <span class="math inline">\(O(n)\)</span> time. Then, it iterates over the stack and performs operations to create the new linked list, which also takes <span class="math inline">\(O(n)\)</span> time, as the stack contains <span class="math inline">\(n\)</span> elements.</p>
<p>Therefore, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity mainly depends on the additional space used by the stack to store the values of the linked list, which takes <span class="math inline">\(O(n)\)</span> space.</p>
<p>Additionally, the space used for the new linked list is also <span class="math inline">\(O(n)\)</span> since we are creating a new node for each element in the original linked list.</p>
<p>Therefore, the overall space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-recursion">Approach 3: Recursion</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The previous approach used a stack. If a problem can be solved using stack, we can often implement a similar solution using recursion, which utilizes the recursive call stack instead of a stack data structure.</p>
<p>The idea here is to recursively traverse the list until we reach the end, doubling the value of each node and propagating the carry value back up the recursive calls.</p>
<p>Once the recursion unwinds, we check if there is any non-zero carry left. If so, we create a new node with the carry value and add it to the beginning of the result linked list.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define a helper function <code>twiceOfVal(head)</code> that recursively computes twice each node's value and propagates the carry.</p>
</li>
<li>
<p>Base case: If <code>head</code> is <code>null</code>, return <code>0</code>.</p>
</li>
<li>
<p>Compute twice the value of the current node and add the result of the next node.</p>
</li>
<li>
<p>Update the current node's value with the units digit of the result.</p>
</li>
<li>
<p>Return the <code>carry</code> (tens digit of the result).</p>
</li>
<li>
<p>In the main <code>doubleIt(head)</code> function, call the <code>twiceOfVal(head)</code> helper function to compute the carry and store it in a variable <code>carry</code>.</p>
</li>
<li>
<p>If the most significant digit has a <code>carry</code> value, insert a new node at the beginning with the <code>carry</code> value.</p>
</li>
<li>
<p>Return the <code>head</code> of the updated linked list.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/XbiMiicQ/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>twiceOfVal</code> function recursively traverses the entire linked list once, performing constant-time operations at each node. Therefore, the time complexity of the <code>twiceOfVal</code> function is <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>doubleIt</code> function calls the <code>twiceOfVal</code> function once, which has a time complexity of <span class="math inline">\(O(n)\)</span>. Additionally, inserting a new node at the beginning of the linked list takes constant time. Hence, the overall time complexity of the <code>doubleIt</code> function is <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>twiceOfVal</code> function is tail-recursive, meaning it should typically use <span class="math inline">\(O(1)\)</span> space on the call stack due to the recursive calls in C++ and Java. However, in languages like Python, which don't optimize tail recursion, each recursive call consumes additional space on the call stack. Therefore, the space complexity of <code>twiceOfVal</code> is <span class="math inline">\(O(n)\)</span> due to the recursive call stack.</p>
<p>The <code>doubleIt</code> function uses no additional space apart from the space required for the input linked list. Hence, its space complexity is <span class="math inline">\(O(1)\)</span>.</p>
<p>Therefore, the overall space complexity of the algorithm is dominated by the recursive call stack, making it <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-two-pointers">Approach 4: Two Pointers</h3>
<h4 id="intuition-3">Intuition</h4>
<p>One of the main challenges in the problem is dealing with the carry when doubling the values of the nodes. The previous approaches handled this by either reversing the list or using a stack to reverse the order of the digits, which introduced linear auxiliary space and/or multiple passes through the linked list. Now, let's consider a more efficient approach that aims to update the list in-place without reversing it.</p>
<p>The insight here is that to handle the carry efficiently, we need to maintain some context about the previous node's value. This would allow us to update the previous node's value if the current node's doubled value resulted in a carry. It's like preserving the state of the carry.</p>
<p>To maintain the necessary context, we can use two pointers: &quot;previous&quot; and &quot;current&quot;. The &quot;previous&quot; pointer keeps track of the previous node, while the &quot;current&quot; pointer points to the node being processed.</p>
<p>By using the two pointers, we can iterate through the list and process the nodes. For each node, we can double the value and handle the carry by updating the previous node's value if necessary.</p>
<p>When processing each node in the linked list, there are three distinct cases to consider:</p>
<ol>
<li>
<p>If the doubled value is less than <code>10</code>:</p>
<p>In this case, the value of the current node is simply replaced with its doubled value.</p>
</li>
<li>
<p>If the doubled value is greater than or equal to <code>10</code>:</p>
<p>Here, the value of the current node is replaced with the remainder (modulo <code>10</code>) of its doubled value, and the previous node's value is updated to reflect the carry.</p>
</li>
<li>
<p>If the first node's value needs to be updated with a carry:</p>
<p>If the doubled value of the first node is greater than or equal to <code>10</code>, a new node is created with a value of <code>1</code>, and it becomes the new head of the list.</p>
</li>
</ol>
<p>This structured approach ensures proper handling of each node in the linked list while accounting for carry values when necessary.</p>
<p>The following is an illustration demonstrating the two pointer approach:</p>
<p>!?!../Documents/2816/twopointer.json:976,302!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>current</code> and <code>previous</code> pointers to traverse the linked list.</li>
<li>For each node:</li>
<li>Compute twice the value of the current node.</li>
<li>If the doubled value is less than 10, update the current node's value.</li>
<li>If the doubled value is 10 or greater:
<ul>
<li>Update the current node's value with the units digit of the doubled value.</li>
<li>If the <code>previous</code> pointer is not <code>null</code> (not the first node), update the previous node's value to add the carry.</li>
</ul>
</li>
<li>If it's the first node and the doubled value is 10 or greater, create a new node with the carry value and link it to the current node, updating the <code>head</code> pointer.</li>
<li>Update the <code>previous</code> and <code>current</code> pointers to the next nodes.</li>
<li>Return the <code>head</code> of the modified linked list.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/FDhU7FiN/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm traverses the entire linked list once. Within the loop, each operation (including arithmetic operations and pointer manipulations) takes constant time.</p>
<p>Therefore, the time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses only a constant amount of additional space for storing pointers and temporary variables, regardless of the size of the input linked list.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-single-pointer">Approach 5: Single Pointer</h3>
<h4 id="intuition-4">Intuition</h4>
<p>A key goal of the two-pointer approach was to reduce the memory footprint of the solution. While efficient, this approach still required maintaining two separate pointers (<code>prev</code> and <code>curr</code>).</p>
<p>We found that updating the previous node's value was only necessary when there was a carry from the current node. This insight will become the foundation for the single-pointer approach.</p>
<p>By focusing on where the previous node's value needed to be updated, we could simplify the logic and eliminate the need for the previous pointer.</p>
<p>We can achieve this using a single pointer to traverse the list. For each node, we will double the value and check if there was a carry from the next node. Since each node's value can range from <code>0</code> to <code>9</code>, doubling it could result in values from 0 to 18.</p>
<p>If the doubled value exceeds <code>9</code>, it indicates a carry to the previous digit place. However, since we are doubling each digit, a carry would occur when the doubled value is greater than or equal to <code>10</code>. We check if the value of the next node (i.e., <code>current.next.val</code>) is greater than <code>4</code>, because if it's greater than <code>4</code>, it implies that its doubled value is at least <code>10</code>. Therefore, we can handle the carry by adding one to the current node's doubled value, which calculates the correct final value for the current node.</p>
<p>The following is an illustration demonstrating the single pointer approach:</p>
<p>!?!../Documents/2816/singlepointer.json:980,308!?!</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>If the value of the <code>head</code> node is greater than <code>4</code>, insert a new node with the value <code>0</code> at the beginning of the list.</li>
<li>Traverse the linked list using a single <code>node</code> pointer:</li>
<li>Double the value of the current node and update it with the units digit.</li>
<li>If the current node has a next node and the next node's value is greater than <code>4</code>, increment the current node's value to handle the carry.</li>
<li>Return the <code>head</code> of the updated linked list.</li>
</ul>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZAAg4Epc/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm traverses the entire linked list once, visiting each node. Within the loop, each operation (including arithmetic operations and pointer manipulations) takes constant time.</p>
<p>Therefore, the time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses only a constant amount of additional space for storing pointers and temporary variables, regardless of the size of the input linked list.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/description" target="_blank" rel="noopener noreferrer">Find the Minimum and Maximum Number of Nodes Between Critical Points</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>critical point</strong> in a linked list is defined as <strong>either</strong> a <strong>local maxima</strong> or a <strong>local minima</strong>.</p>

<p>A node is a <strong>local maxima</strong> if the current node has a value <strong>strictly greater</strong> than the previous node and the next node.</p>

<p>A node is a <strong>local minima</strong> if the current node has a value <strong>strictly smaller</strong> than the previous node and the next node.</p>

<p>Note that a node can only be a local maxima/minima if there exists <strong>both</strong> a previous node and a next node.</p>

<p>Given a linked list <code>head</code>, return <em>an array of length 2 containing </em><code>[minDistance, maxDistance]</code><em> where </em><code>minDistance</code><em> is the <strong>minimum distance</strong> between <strong>any&nbsp;two distinct</strong> critical points and </em><code>maxDistance</code><em> is the <strong>maximum distance</strong> between <strong>any&nbsp;two distinct</strong> critical points. If there are <strong>fewer</strong> than two critical points, return </em><code>[-1, -1]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/13/a1.png" style="width: 148px; height: 55px;" />
<pre>
<strong>Input:</strong> head = [3,1]
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong> There are no critical points in [3,1].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/13/a2.png" style="width: 624px; height: 46px;" />
<pre>
<strong>Input:</strong> head = [5,3,1,2,5,1,2]
<strong>Output:</strong> [1,3]
<strong>Explanation:</strong> There are three critical points:
- [5,3,<strong><u>1</u></strong>,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.
- [5,3,1,2,<u><strong>5</strong></u>,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.
- [5,3,1,2,5,<u><strong>1</strong></u>,2]: The sixth node is a local minima because 1 is less than 5 and 2.
The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.
The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/14/a5.png" style="width: 624px; height: 39px;" />
<pre>
<strong>Input:</strong> head = [1,3,2,2,3,2,2,2,7]
<strong>Output:</strong> [3,3]
<strong>Explanation:</strong> There are two critical points:
- [1,<u><strong>3</strong></u>,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.
- [1,3,2,2,<u><strong>3</strong></u>,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.
Both the minimum and maximum distances are between the second and the fifth node.
Thus, minDistance and maxDistance is 5 - 2 = 3.
Note that the last node is not considered a local maxima because it does not have a next node.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-one-pass">Approach: One Pass</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem requires finding the minimum and maximum distances between any two distinct critical points (local maxima or minima) in a given linked list. For example, consider the following list:</p>
<p><img src="../Figures/2058/image_1.png" alt="Image_1" /></p>
<p>The critical points for this list are:</p>
<p><img src="../Figures/2058/image_2.png" alt="Image_2" /></p>
<p>Notice that:</p>
<ol>
<li>The two critical points farthest away from each other are the ones at the beginning and the end of the list.</li>
<li>The minimum distance would always lie between any two consecutive critical points.</li>
</ol>
<p><img src="../Figures/2058/image_3.png" alt="Image_3" /></p>
<p>Now, the problem is reduced to identifying all the critical points in the linked list and continuously tracking the minimum distance between any two consecutive critical points. We must also note the first and last critical points encountered to calculate the maximum distance.</p>
<p>Let us traverse the linked list from its head. We will need to keep track of 6 things:</p>
<ol>
<li><strong>The current node</strong>: to iterate over the list</li>
<li><strong>The previous node</strong>: to compare its value with the current node</li>
<li><strong>Position of the current node</strong>: to calculate the distance in case it's a critical point</li>
<li><strong>Position of the previous critical point</strong>: to calculate the distance from the next critical point</li>
<li><strong>Position of the first critical point</strong>: to calculate the maximum distance</li>
<li><strong>Minimum distance</strong>: to update the minimum distance for each pair of consecutive critical points</li>
</ol>
<p>As we move through the list, encountering a critical point prompts us to update the minimum distance with the difference between the current node's position and the previous critical point. When we encounter the first critical point, we note its position and later subtract it from the position of the last critical point to find the maximum distance.</p>
<blockquote>
<p>Note: We can start the traversal from the second node and end at the second last node because, according to our problem definition, critical points require both a previous and a next node, which the first and last nodes lack.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>The <code>result</code> array to <code>[-1, -1]</code>, in case there is no valid solution.</li>
<li><code>minDistance</code> to the maximum permissible integer value.</li>
<li><code>previousNode</code> to point at <code>head</code>.</li>
<li><code>currentNode</code> to point at the next node from <code>head</code>.</li>
<li><code>currentIndex</code> storing the position of <code>currentNode</code>.</li>
<li><code>previousCriticalIndex</code> and <code>firstCriticalIndex</code> set to 0.</li>
</ul>
</li>
<li>Loop over the list till the second-last element:
<ul>
<li>If the current node is a critical point:
<ul>
<li>If it is the first critical point encountered:
<ul>
<li>Set <code>previousCriticalIndex</code> and <code>firstCriticalIndex</code> to the position of the current node.</li>
</ul>
</li>
<li>Else, update <code>minDistance</code> as the minimum of the current <code>minDistance</code> and difference between <code>currentIndex</code> and  <code>previousCriticalIndex</code>.</li>
</ul>
</li>
<li>Increment <code>currentIndex</code>. Move <code>previousNode</code> to the current node and <code>currentNode</code> to the next node in the list.</li>
</ul>
</li>
<li>If <code>minDistance</code> is not equal to its initial value:
<ul>
<li>Set <code>maxDistance</code> to the difference between <code>previousCriticalIndex</code> and <code>firstCriticalIndex</code>.</li>
<li>Update <code>result</code> with <code>minDistance</code> and <code>maxDistance</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/62TF9jMN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the the length of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm traverses the list only once, making the time complexity <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm has a constant space complexity since it does not utilize any additional data structures.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/description" target="_blank" rel="noopener noreferrer">Flatten a Multilevel Doubly Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional <strong>child pointer</strong>. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a <strong>multilevel data structure</strong> as shown in the example below.</p>

<p>Given the <code>head</code> of the first level of the list, <strong>flatten</strong> the list so that all the nodes appear in a single-level, doubly linked list. Let <code>curr</code> be a node with a child list. The nodes in the child list should appear <strong>after</strong> <code>curr</code> and <strong>before</strong> <code>curr.next</code> in the flattened list.</p>

<p>Return <em>the </em><code>head</code><em> of the flattened list. The nodes in the list must have <strong>all</strong> of their child pointers set to </em><code>null</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg" style="width: 700px; height: 339px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
<strong>Output:</strong> [1,2,3,7,8,11,12,9,10,4,5,6]
<strong>Explanation:</strong> The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
<img src="https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg" style="width: 1000px; height: 69px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> head = [1,2,null,3]
<strong>Output:</strong> [1,3,2]
<strong>Explanation:</strong> The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
<img src="https://assets.leetcode.com/uploads/2021/11/24/list.jpg" style="width: 300px; height: 87px;" />
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
<strong>Explanation:</strong> There could be empty list in the input.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of Nodes will not exceed <code>1000</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>How the multilevel linked list is represented in test cases:</strong></p>

<p>We use the multilevel linked list from <strong>Example 1</strong> above:</p>

<pre>
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL</pre>

<p>The serialization of each level is as follows:</p>

<pre>
[1,2,3,4,5,6,null]
[7,8,9,10,null]
[11,12,null]
</pre>

<p>To serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:</p>

<pre>
[1,    2,    3, 4, 5, 6, null]
             |
[null, null, 7,    8, 9, 10, null]
                   |
[            null, 11, 12, null]
</pre>

<p>Merging the serialization of each level and removing trailing nulls we obtain:</p>

<pre>
[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
</pre>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/flatten-binary-tree-to-linked-list/1" target="_blank" rel="noopener noreferrer">Flatten binary tree to linked list</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 12pt;">Given the root of a binary tree, flatten the tree into a "Linked list":</span></p>
<ul>
<li><span style="font-size: 12pt;">The "linked list" should use the same Node class where the right child pointer points to the next node in the list and the left child pointer is always null.</span></li>
<li><span style="font-size: 12pt;">The "linked list" should be in the same order as a pre-order traversal of the binary tree.</span></li>
</ul>
<p><span style="font-size: 12pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>
          1
        /   \
       2     5
      / \     \
     3   4     6</span><br /><span style="font-size: 12pt;"><strong>Output : </strong>1 2 3 4 5 6 </span><br /><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706436/Web/Other/blobid0_1722839451.png" height="100" /> </span><br /><span style="font-size: 12pt;"><strong>Explanation: </strong>After flattening, the tree looks like this - <br /><span style="font-size: 12pt;">     1
      \
       2
        \
         3
          \
           4
            \ 
             5 <br />              \<br />               6<br /></span>Here, left of each node points to NULL and right contains the next node in preorder.The inorder traversal of this flattened tree is 1 2 3 4 5 6.</span><br /><br /><span style="font-size: 12pt;"><strong>Input :</strong>
        1
       / \
      3   4
         /
        2
         \
          5 
<strong>Output :</strong> 
1 3 4 2 5 
<strong>Explanation : </strong>After flattening, the tree looks like this -
     1
      \
       3
        \
         4
          \
           2
            \ 
             5 
Here, left of each node points to NULL and right contains the next node in preorder.The inorder traversal of this flattened tree is 1 3 4 2 5.</span></pre>
<div><span style="font-size: 12pt;"><strong>Expected Time Complexity: </strong>O(n)</span></div>
<div><span style="font-size: 12pt;"><strong>Expected Space&nbsp;</strong><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Complexity</strong><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">:</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> O(1)</span></span></div>
<div>&nbsp;</div>
<div><span style="font-size: 12pt;"><strong>Constraints :</strong></span></div>
<div><span style="font-size: 12pt;">1&lt;= number of nodes in binary tree &lt;= 10<sup>5</sup></span></div>
<div><span style="font-size: 12pt;"><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1&lt;= data of nodes &lt;= 10</span><sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">5</sup></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flatten-binary-tree-to-linked-list/description" target="_blank" rel="noopener noreferrer">Flatten Binary Tree to Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>

<ul>
	<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>
	<li>The &quot;linked list&quot; should be in the same order as a <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" target="_blank"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" style="width: 500px; height: 226px;" />
<pre>
<strong>Input:</strong> root = [1,2,5,3,4,null,6]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/description" target="_blank" rel="noopener noreferrer">Insert Greatest Common Divisors in Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the head of a linked list <code>head</code>, in which each node contains an integer value.</p>

<p>Between every pair of adjacent nodes, insert a new node with a value equal to the <strong>greatest common divisor</strong> of them.</p>

<p>Return <em>the linked list after insertion</em>.</p>

<p>The <strong>greatest common divisor</strong> of two numbers is the largest positive integer that evenly divides both numbers.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png" style="width: 641px; height: 181px;" />
<pre>
<strong>Input:</strong> head = [18,6,10,3]
<strong>Output:</strong> [18,6,6,2,10,1,3]
<strong>Explanation:</strong> The 1<sup>st</sup> diagram denotes the initial linked list and the 2<sup>nd</sup> diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).
- We insert the greatest common divisor of 18 and 6 = 6 between the 1<sup>st</sup> and the 2<sup>nd</sup> nodes.
- We insert the greatest common divisor of 6 and 10 = 2 between the 2<sup>nd</sup> and the 3<sup>rd</sup> nodes.
- We insert the greatest common divisor of 10 and 3 = 1 between the 3<sup>rd</sup> and the 4<sup>th</sup> nodes.
There are no more adjacent nodes, so we return the linked list.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png" style="width: 51px; height: 191px;" />
<pre>
<strong>Input:</strong> head = [7]
<strong>Output:</strong> [7]
<strong>Explanation:</strong> The 1<sup>st</sup> diagram denotes the initial linked list and the 2<sup>nd</sup> diagram denotes the linked list after inserting the new nodes.
There are no pairs of adjacent nodes, so we return the initial linked list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 5000]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-simulation">Approach: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>To calculate the greatest common divisor (GCD) of every pair of adjacent nodes in a linked list, we maintain two pointers, <code>node1</code> and <code>node2</code>, initially pointing to the first and second nodes, respectively.</p>
<p>As we iterate through the list, we need to compute the GCD of the values stored in <code>node1</code> and <code>node2</code>. The most efficient method for finding the GCD of two numbers is the renowned <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a>. This algorithm is based on the principle that the GCD of two numbers also divides their difference.</p>
<p>In simple terms, the Euclidean algorithm works by repeatedly replacing the larger number by the remainder of the division of the larger number by the smaller number, until one of the numbers becomes zero. The non-zero number at this stage is the GCD of the original pair of numbers.</p>
<blockquote>
<p>Many programming languages offer built-in implementations of this algorithm, which you can utilize in your solution. For instance, Python has a built-in <code>math.gcd()</code> function, while C++ provides the <code>std::gcd()</code> function in the <code>&lt;numeric&gt;</code> header. If such a function is not available in your programming language, or if you prefer to implement it manually, you can write a custom GCD method using the following pseudo-code:</p>
</blockquote>
<p>Recursive Way:</p>
<pre><code>function gcd(a, b)
  if b = 0
    return a
  else
    return gcd(b, a mod b)
</code></pre>
<p>Iterative Way:</p>
<pre><code>function gcd(a, b)
  while b â‰  0
    t := b
    b := a mod b
    a := t
  return a
</code></pre>
<p>After computing the GCD, we create a new node with the GCD value and insert it between <code>node1</code> and <code>node2</code> as follows:</p>
<ol>
<li>Set <code>node1</code>'s next pointer to the new node.</li>
<li>Set the new node's next pointer to <code>node2</code>.</li>
<li>Disconnect the direct link between <code>node1</code> and <code>node2</code>.</li>
</ol>
<p>Next, we move <code>node1</code> and <code>node2</code> to the next pair of nodes and continue the process.</p>
<p>The below slideshow demonstrates the algorithm in action:</p>
<p>!?!../Documents/2807/slideshow.json:1452,768!?!</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main method <code>insertGreatestCommonDivisors</code>:</p>
<ul>
<li>If the list contains only one node (<code>head.next</code> is <code>null</code>), return the <code>head</code> as no insertion is needed.</li>
<li>Initialize <code>ListNode</code> variables <code>node1</code> and <code>node2</code> to <code>head</code> and <code>head.next</code> respectively, to traverse the linked list.</li>
<li>While <code>node2</code> is not <code>null</code>:
<ul>
<li>Calculate the GCD's of the values in <code>node1</code> and <code>node2</code>.</li>
<li>Create a new <code>ListNode</code> <code>gcdNode</code> with the calculated GCD value.</li>
<li>Update <code>node1.next</code> to <code>gcdNode</code>.</li>
<li>Update <code>gcdNode.next</code> to <code>node2</code>.</li>
<li>Set <code>node1</code> to <code>node2</code> and <code>node2</code> to <code>node2.next</code>, respectively. This essentially moves <code>node1</code> and <code>node2</code> to the next pair of nodes in the list.</li>
</ul>
</li>
<li>Return the modified <code>head</code> of the list as our answer.</li>
</ul>
<p>Helper method <code>calculateGCD(a, b)</code>:</p>
<ul>
<li>While <code>b</code> is greater than <code>0</code>:
<ul>
<li>Set a variable <code>temp</code> to <code>b</code>.</li>
<li>Set <code>b</code> to <code>a%b</code> and <code>a</code> to <code>temp</code>, respectively.</li>
</ul>
</li>
<li>Return <code>a</code>.</li>
</ul>
<blockquote>
<p>Note: We have used a custom method to calculate the GCD for completeness. In an interview, clarify with your interviewer if built-in GCD methods are acceptable.</p>
</blockquote>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/J4QeV4y6/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log(\min(a,b)))\)</span></p>
<p>The algorithm traverses the list, visiting each node exactly once. This takes linear time.</p>
<p>The GCD is calculated using the Euclidean algorithm, which has a time complexity of <span class="math inline">\(O(\log(\min(a, b)))\)</span>, where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are numbers whose GCD is being calculated.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n \cdot \log(\min(a,b)))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The iterative implementation of the GCD method has a space complexity of <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/insertion-sort-list/description" target="_blank" rel="noopener noreferrer">Insertion Sort List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, sort the list using <strong>insertion sort</strong>, and return <em>the sorted list&#39;s head</em>.</p>

<p>The steps of the <strong>insertion sort</strong> algorithm:</p>

<ol>
	<li>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.</li>
	<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</li>
	<li>It repeats until no input elements remain.</li>
</ol>

<p>The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p>
<img alt="" src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" style="height:180px; width:300px" />
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg" style="width: 422px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [4,2,1,3]
<strong>Output:</strong> [1,2,3,4]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [-1,5,3,4,0]
<strong>Output:</strong> [-1,0,3,4,5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 5000]</code>.</li>
	<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="overview">Overview</h3>
<p><a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion sort</a> is an intuitive sorting algorithm, although it is much less efficient than the more advanced algorithms such as quicksort or merge sort.</p>
<p>Often that we perform the sorting algorithm on an <a href="https://leetcode.com/explore/learn/card/fun-with-arrays">Array</a> structure,<br />
this problem though asks us to perform the insertion sort on a <strong>linked list</strong> data structure, which makes the implementation a bit challenging.</p>
<p>In this article, we will present some tricks to manipulate the linked list, which would help us to simplify the logics of implementation.</p>
<hr />
<h3 id="approach-1-insertion-sort">Approach 1: Insertion Sort</h3>
<h4 id="intuition">Intuition</h4>
<p>Let us first review the idea of insertion sort algorithm, which can be broke down into the following steps:</p>
<ul>
<li>
<p>First of all, we create an empty list which would be used to hold the results of sorting.</p>
</li>
<li>
<p>We then iterate through each element in the <em>input</em> list. For each element, we need to find a proper position in the resulting list to insert the element, so that the order of the resulting list is maintained.</p>
</li>
<li>
<p>As one can see, once the iteration in the above step terminates, we will obtain the resulting list where the elements are <em>ordered</em>.</p>
</li>
</ul>
<p>Now, let us walk through a simple example, by applying the above intuition.</p>
<p>Given the input list <code>input=[4, 3, 5]</code>, we have initially an empty resulting list <code>result=[]</code>.</p>
<ul>
<li>We then iterate over the input list. For the first element <code>4</code>, we need to find a proper position in the resulting list to place it.<br />
Since the resulting list is still empty, we then simply <em>append</em> it to the resulting list, <em>i.e.</em> <code>result=[4]</code>.</li>
</ul>
<p><img src="../Figures/147/147_linked_list_step_1.png" alt="step 1" /></p>
<ul>
<li>Now for the second element (<em>i.e.</em> <code>3</code>) in the input list, similarly we need to insert it properly into the resulting list.<br />
As one can see, we need to insert it right before the element <code>4</code>.<br />
As a result, the resulting list becomes <code>[3, 4]</code>.</li>
</ul>
<p><img src="../Figures/147/147_linked_list_step_2.png" alt="step 2" /></p>
<ul>
<li>Finally, for the last element (<em>i.e.</em> <code>5</code>) in the input list, as it turns out, the proper position to place it is the <em>tail</em> of the resulting list.<br />
With this last iteration, we obtain a <em>sorted</em> list as <code>result=[3, 4, 5]</code>.</li>
</ul>
<p><img src="../Figures/147/147_linked_list_step_3.png" alt="step 3" /></p>
<h4 id="algorithm">Algorithm</h4>
<p>To translate the above intuition into the implementation, we applied two <strong>tricks</strong>.</p>
<blockquote>
<p>The first trick is that we will create a <code>dummy</code> (<code>pseudo_head</code>) node which serves as a pointer pointing to the resulting list.</p>
</blockquote>
<p>More precisely, this node facilitates us to always get a <em>hold</em> on the resulting list, especially when we need to insert a new element to the head of the resulting list.<br />
One will see later in more details how it can greatly simplify the logic.</p>
<p>In a <em>singly-linked list</em>, each node has only one pointer that points to the next node.<br />
If we would like to insert a new node (say <code>B</code>) before certain node (say <code>A</code>), we need to know the node (say <code>C</code>) that is currently before the node <code>A</code>, <em>i.e.</em> <code>C -&gt; A</code>.<br />
With the reference in the node <code>C</code>, we could now insert the new node, <em>i.e.</em> <code>C -&gt; B -&gt; A</code>.</p>
<p>Given the above insight, in order to insert a new element into a singly-linked list, we apply another trick.</p>
<blockquote>
<p>The idea is that we use a <em><strong>pair of pointers</strong></em> (namely <code>prev -&gt; next</code>) which serve as place-holders to guard the position where in-between we would insert a new element (<em>i.e.</em> <code>prev -&gt; new_node -&gt; next</code>).</p>
</blockquote>
<p>With the same example before, <em>i.e.</em> <code>input=[4, 3, 5]</code>, we illustrate what the above helper pointers look like at the moment of insertion, in the following graph:</p>
<p><img src="../Figures/147/147_pointers.png" alt="pointers" /></p>
<h4 id="implementation">Implementation</h4>
<p>Here are some sample implementations based on the above ideas:</p>
<p><a href="https://leetcode.com/playground/gDxDYr3y/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of elements in the input list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(N^2)\)</span></p>
<ul>
<li>
<p>First of all, we run an iteration over the input list.</p>
</li>
<li>
<p>At each iteration, we insert an element into the resulting list. In the worst case where the position to insert is the tail of the list, we have to walk through the entire resulting list.</p>
</li>
<li>
<p>As a result, the total steps that we need to walk in the worst case would be <span class="math inline">\(\sum_{i=1}^{N} i = \frac{N(N+1)}{2}\)</span>.</p>
</li>
<li>
<p>To sum up, the overall time complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N^2)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(1)\)</span></p>
<ul>
<li>
<p>We used some pointers within the algorithm. However, their memory consumption is constant regardless of the input.</p>
</li>
<li>
<p><strong>Note</strong>, we did not create new nodes to hold the values of input list, but simply <em>reorder</em> the existing nodes.</p>
</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/intersection-of-two-linked-list/1" target="_blank" rel="noopener noreferrer">Intersection of Two Linked Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">linked list</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two linked lists <strong>head1 </strong>and <strong>head2</strong>, find&nbsp;the intersection of two linked lists. Each of the two linked lists contains distinct node values.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;The order of nodes in this list should be the same as the order in which those particular nodes appear in input head1 and return null if no common element is present.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;">Input: LinkedList1: 9-&gt;6-&gt;4-&gt;2-&gt;3-&gt;8 , LinkedList2: 1-&gt;2-&gt;8-&gt;6<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700535/Web/Other/blobid1_1720589846.png" width="399" height="188" /> <br /><strong>Output: </strong>6-&gt;2-&gt;8<br /><strong>Explanation: </strong>Nodes 6, 2 and 8 are common in both of the lists and the order will be according to LinkedList1. </span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>LinkedList1: 5-&gt;3-&gt;1-&gt;13-&gt;14 , LinkedList2: 3-&gt;13<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700535/Web/Other/blobid0_1720589787.png" width="399" height="188" /> <br /><strong>Output: </strong>3-&gt;13<br /><strong>Explanation: </strong>Nodes 3 and 13 are common in both of the lists and the order will be according to LinkedList1. </span></pre>
<p><span style="font-size: 18px;"><strong>Expected time complexity:</strong>&nbsp;O(m+n)<br /><strong>Expected auxiliary space:&nbsp;</strong>O(m+n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= no. of nodes in head1, head2 &lt;= 10<sup>4<br /></sup>1 &lt;= node-&gt;data &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intersection-of-two-linked-lists/description" target="_blank" rel="noopener noreferrer">Intersection of Two Linked Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>

<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" style="width: 500px; height: 162px;" />
<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>

<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>

<p><strong>Custom Judge:</strong></p>

<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>

<ul>
	<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>
	<li><code>listA</code> - The first linked list.</li>
	<li><code>listB</code> - The second linked list.</li>
	<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>
	<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>
</ul>

<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" style="width: 500px; height: 162px;" />
<pre>
<strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
<strong>Output:</strong> Intersected at &#39;8&#39;
<strong>Explanation:</strong> The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
- Note that the intersected node&#39;s value is not 1 because the nodes with value 1 in A and B (2<sup>nd</sup> node in A and 3<sup>rd</sup> node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3<sup>rd</sup> node in A and 4<sup>th</sup> node in B) point to the same location in memory.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" style="width: 500px; height: 194px;" />
<pre>
<strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>Output:</strong> Intersected at &#39;2&#39;
<strong>Explanation:</strong> The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" style="width: 300px; height: 189px;" />
<pre>
<strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>Output:</strong> No intersection
<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li>
	<li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li>
	<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= skipA &lt;= m</code></li>
	<li><code>0 &lt;= skipB &lt;= n</code></li>
	<li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li>
	<li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/intersection-of-two-sorted-linked-lists/1" target="_blank" rel="noopener noreferrer">Intersection Sorted Linked Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given <strong>that two linked lists are </strong>sorted in <strong>increasing order</strong>, create a new linked list representing the <strong>intersection </strong>of the two linked lists. The new linked list should be made without changing the original lists.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> The elements of the linked list are not necessarily distinct.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>LinkedList1 = 1-&gt;2-&gt;3-&gt;4-&gt;6, LinkedList2 = 2-&gt;4-&gt;6-&gt;8
<strong>Output: </strong>2-&gt;4-&gt;6<strong>
Explanation: </strong>For the given two linked list, 2, 4 and 6 are the elements in the intersection.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700191/Web/Other/blobid0_1724332831.png" width="399" height="191" /><br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>LinkedList1 = 10-&gt;20-&gt;40-&gt;50, LinkedList2 = 15-&gt;40
<strong>Output: </strong>40<br /><strong>Explaination:</strong><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700191/Web/Other/blobid1_1724332853.png" width="385" height="184" /><br /></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= size of linked lists &lt;= 10<sup>4</sup><br />1 &lt;= node-&gt;data&lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/leaves-to-dll/1" target="_blank" rel="noopener noreferrer">Leaves to DLL</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 12pt;">Given a Binary Tree, extract all its leaf nodes to form a Doubly Link List starting from the leftmost leaf. Modify the original tree to make the DLL thus removing the leaf nodes from the tree. Consider the left and right pointers of the tree to be the previous and next pointer of the DLL respectively.</span><br /><br /><span style="font-size: 12pt;"><strong>Note:&nbsp;</strong>The generated output will contain the in-order traversal of the modified tree, the DLL from left to right, and the DLL from right to left.</span></p>
<p><span style="font-size: 12pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input:</strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700615/Web/Other/blobid1_1722317045.png" width="398" height="262" /></span><br /><span style="font-size: 12pt;"><strong>Output: </strong>
Modified Tree :<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700615/Web/Other/blobid2_1722317056.png" width="401" height="169" />
Doubly Linked List :
4 &lt;-&gt; 5 &lt;-&gt; 6 &lt;-&gt; 7<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700615/Web/Other/blobid3_1722317094.png" height="100" />
<strong>Explanation:</strong>
The leaf nodes are modified to form the DLL in-place. Thus their links are removed from  the tree.</span></pre>
<pre><span style="font-size: 12pt;"><strong>Input:</strong></span><br /><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700615/Web/Other/blobid4_1722317145.png" width="401" height="264" /></span><br /><span style="font-size: 12pt;"><strong>Output: </strong>
Modified Tree :</span><br /><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700615/Web/Other/blobid5_1722317194.png" width="401" height="169" /></span><br /><span style="font-size: 12pt;">Doubly Linked List:
4 &lt;-&gt; 5 &lt;-&gt; 3<br /></span><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700615/Web/Other/blobid6_1722317203.png" width="400" height="90" /></span></pre>
<p><span style="font-size: 12pt;"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Auxiliary Space:</strong> O(height of tree)<br /><br /><strong>Constraints:</strong><br />1 &le; number of nodes in tree, data of nodes &le; 10<sup>4<br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lfu-cache/description" target="_blank" rel="noopener noreferrer">LFU Cache</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design and implement a data structure for a <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank">Least Frequently Used (LFU)</a> cache.</p>

<p>Implement the <code>LFUCache</code> class:</p>

<ul>
	<li><code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.</li>
	<li><code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.</li>
	<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.</li>
</ul>

<p>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</p>

<p>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.</p>

<p>The functions&nbsp;<code data-stringify-type="code">get</code>&nbsp;and&nbsp;<code data-stringify-type="code">put</code>&nbsp;must each run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

<strong>Explanation</strong>
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
&nbsp;                // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[4,3], cnt(4)=2, cnt(3)=3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= capacity&nbsp;&lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>2 * 10<sup>5</sup></code>&nbsp;calls will be made to <code>get</code> and <code>put</code>.</li>
</ul>

<p>&nbsp;</p>
<span style="display: none;">&nbsp;</span></div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-maintaining-2-hashmaps">Approach 1: Maintaining 2 HashMaps</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to maintain all the keys, values and frequencies. Without invalidation (removing from the data structure when it reaches capacity), they can be maintained by a HashMap&lt;Integer, Pair&lt;Integer, Integer&gt;&gt;, keyed by the original <code>key</code> and valued by the <code>frequency</code>-<code>value</code> pair.</p>
<p>With the invalidation, we need to maintain the current minimum frequency and delete particular keys. Hence, we can group the keys with the same frequency together and maintain another HashMap&lt;Integer, Set<Integer>&gt;, keyed by the frequency and valued by the set of <code>keys</code> that have the same frequency. This way, if we know the minimum frequency, we can access the potential keys to be deleted.</p>
<p>Also note that in the case of a tie, we're required to find the least recently used key and invalidate it, hence we need to keep the frequencies ordered in the Set. Instead of using a TreeSet which adds an extra <span class="math inline">\(O(log(N))\)</span> time complexity, we can maintain the keys using a LinkedList so that it supports finding both an arbitrary key and the least recently used key in constant time. Fortunately, LinkedHashSet can do the job. Once a <code>key</code> is inserted/updated, we put it to the end of the LinkedHashSet so that we can invalidate the first <code>key</code> in the LinkedHashSet corresponding to the minimum frequency.</p>
<p>The original operations can be transformed into operations on the 2 HashMaps, keeping them in sync and maintaining the minimum frequency.</p>
<p>Since C++ lacks LinkedHashSet, we have to use a workaround like maintaining a list of key and value pairs instead of the LinkedHashSet and keeping the iterator with the frequency in another unordered_map to keep this connection. The idea is similar but a little bit complicated. Another workaround would be to implement your own LRU cache with a doubly linked list.</p>
<h4 id="algorithm">Algorithm</h4>
<p>To make things simpler, assume we have 4 member variables:</p>
<ol>
<li><code>HashMap&lt;Integer, Pair&lt;Integer, Integer&gt;&gt; cache</code>, keyed by the original <code>key</code> and valued by the <code>frequency</code>-<code>value</code> pair.</li>
<li><code>HashMap&lt;Integer, LinkedListHashSet&lt;Integer&gt;&gt; frequencies</code>, keyed by frequency and valued by the set of <code>keys</code> that have the same frequency.</li>
<li><code>int minf</code>, which is the minimum frequency at any given time.</li>
<li><code>int capacity</code>, which is the <code>capacity</code> given in the input.</li>
</ol>
<p>It's also convenient to have a private utility function <code>insert</code> to insert a <code>key</code>-<code>value</code> pair with a given frequency.</p>
<h5 id="void-insertint-key-int-frequency-int-value">void insert(int key, int frequency, int value)</h5>
<ol>
<li>Insert <code>frequency</code>-<code>value</code> pair into <code>cache</code> with the given <code>key</code>.</li>
<li>Get the LinkedHashSet corresponding to the given <code>frequency</code> (default to empty Set) and insert the given <code>key</code>.</li>
</ol>
<h5 id="int-getint-key">int get(int key)</h5>
<ol>
<li>If the given <code>key</code> is not in the <code>cache</code>, return <code>-1</code>, otherwise go to step <code>2</code>.</li>
<li>Get the <code>frequency</code> and <code>value</code> from the <code>cache</code>.</li>
<li>Get the LinkedHashSet associated with <code>frequency</code> from <code>frequencies</code> and remove the given <code>key</code> from it, since the usage of the current key is increased by this function call.</li>
<li>If <code>minf</code> == <code>frequency</code> and the above LinkedHashSet is empty, that means there are no more elements used <code>minf</code> times, so increase <code>minf</code> by 1. To save some space, we can also delete the entry <code>frequency</code> from the <code>frequencies</code> hash map.</li>
<li>Call insert(<code>key</code>, <code>frequency</code> + 1, <code>value</code>), since the current key's usage has increased from this function call.</li>
<li>Return <code>value</code></li>
</ol>
<h5 id="void-putint-key-int-value">void put(int key, int value)</h5>
<ol>
<li>If <code>capacity</code> &lt;= 0, exit.</li>
<li>If the given <code>key</code> exists in <code>cache</code>, update the <code>value</code> in the original <code>frequency</code>-<code>value</code> (don't call insert here), and then increment the frequency by using get(<code>key</code>). Exit the function.</li>
<li>If <code>cache.size()</code> == <code>capacity</code>, get the first (least recently used) value in the LinkedHashSet corresponding to <code>minf</code> in <code>frequencies</code>, and remove it from <code>cache</code> and the LinkedHashSet.</li>
<li>If we didn't exit the function in step 2, it means that this element is a new one, so the minimum frequency cannot possibly be greater than one. Set <code>minf</code> to 1.</li>
<li>Call insert(<code>key</code>, 1, <code>value</code>)</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/njKVWiZK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the total number of operations.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span>, as required by the question.</p>
<p>Since we only have basic HashMap/(Linked)HashSet operations. For details,</p>
<p>Our utility function <code>insert</code> puts the <code>key</code>- <code>value</code> pair into the <code>cache</code>, queries and possibly puts an empty LinedHashSet in the <code>frequencies</code>, then queries <code>frequencies</code> again and adds a <code>key</code> into the associated <code>value</code> which is a LinkedHashSet. All the operations are based on the hash calculating for simple type (int or Integer) and the time complexity is constant.</p>
<p>For each <code>get</code> operation, in the worst case, we query the <code>frequencies</code> and remove a <code>key</code> from the associated <code>value</code> which is a LinkedHashSet and call <code>insert</code> function once. All the operations have the constant time complexity based on the hash calculating for simple type.</p>
<p>For each <code>put</code> operation, in the simple case we just insert the new <code>key</code>-<code>value</code> pair into the <code>cache</code> and call <code>get</code> function once. In the worst case, we query the <code>frequencies</code> to get the associated <code>value</code>, namely all the <code>keys</code> with the same frequencies which is a LinkedHashSet. And then we get the first key from the LinkedHashSet, remove it from both <code>cache</code> and <code>frequencies</code>. All the operations have the constant time complexity based on the hash calculating for simple type.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>We save all the <code>key</code>-<code>value</code> pairs as well as all the keys with frequencies in the 2 HashMaps (plus a LinkedHashSet), so there are at most $min(N, capacity) <code>keys</code> and <code>values</code> at any given time.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-components/description" target="_blank" rel="noopener noreferrer">Linked List Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list containing unique integer values and an integer array <code>nums</code> that is a subset of the linked list values.</p>

<p>Return <em>the number of connected components in </em><code>nums</code><em> where two values are connected if they appear <strong>consecutively</strong> in the linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg" style="width: 424px; height: 65px;" />
<pre>
<strong>Input:</strong> head = [0,1,2,3], nums = [0,1,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 0 and 1 are connected, so [0, 1] and [3] are the two connected components.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg" style="width: 544px; height: 65px;" />
<pre>
<strong>Input:</strong> head = [0,1,2,3,4], nums = [0,3,1,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the linked list is <code>n</code>.</li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= Node.val &lt; n</code></li>
	<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>1 &lt;= nums.length &lt;= n</code></li>
	<li><code>0 &lt;= nums[i] &lt; n</code></li>
	<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-cycle/description" target="_blank" rel="noopener noreferrer">Linked List Cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>

<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>

<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" style="width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;" />
<pre>
<strong>Input:</strong> head = [3,2,0,-4], pos = 1
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" style="width: 141px; height: 74px;" />
<pre>
<strong>Input:</strong> head = [1,2], pos = 0
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" style="width: 45px; height: 45px;" />
<pre>
<strong>Input:</strong> head = [1], pos = -1
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no cycle in the linked list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-cycle-ii/description" target="_blank" rel="noopener noreferrer">Linked List Cycle II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>

<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>

<p><strong>Do not modify</strong> the linked list.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" style="height: 145px; width: 450px;" />
<pre>
<strong>Input:</strong> head = [3,2,0,-4], pos = 1
<strong>Output:</strong> tail connects to node index 1
<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" style="height: 105px; width: 201px;" />
<pre>
<strong>Input:</strong> head = [1,2], pos = 0
<strong>Output:</strong> tail connects to node index 0
<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" style="height: 65px; width: 65px;" />
<pre>
<strong>Input:</strong> head = [1], pos = -1
<strong>Output:</strong> no cycle
<strong>Explanation:</strong> There is no cycle in the linked list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Linked List in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree <code>root</code> and a&nbsp;linked list with&nbsp;<code>head</code>&nbsp;as the first node.&nbsp;</p>

<p>Return True if all the elements in the linked list starting from the <code>head</code> correspond to some <em>downward path</em> connected in the binary tree&nbsp;otherwise return False.</p>

<p>In this context downward path means a path that starts at some node and goes downwards.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png" style="width: 220px; height: 280px;" /></strong></p>

<pre>
<strong>Input:</strong> head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>Output:</strong> true
<strong>Explanation:</strong> Nodes in blue form a subpath in the binary Tree.  
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/02/12/sample_2_1720.png" style="width: 220px; height: 280px;" /></strong></p>

<pre>
<strong>Input:</strong> head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no path in the binary tree that contains all the elements of the linked list from <code>head</code>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 2500]</code>.</li>
	<li>The number of nodes in the list will be in the range <code>[1, 100]</code>.</li>
	<li><code>1 &lt;= Node.val&nbsp;&lt;= 100</code>&nbsp;for each node in the linked list and binary tree.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary tree and a linked list. Our task is to determine if the linked list is represented by any downward path in the binary tree. A downward path in the binary tree is defined as a path that starts at any node and extends to its subsequent child nodes, going downward.</p>
<hr />
<h3 id="approach-1-dfs">Approach 1: DFS</h3>
<h4 id="intuition">Intuition</h4>
<p>A direct approach is to explore every possible path in the tree using Depth-First Search (DFS). This method allows us to examine each path fully before moving to the next.</p>
<p>We begin at the root of the tree and compare its value to the head of the linked list. If they match, we continue by checking the left and right children of the tree node against the next node in the linked list. If the tree node's value does not match the linked list node, we stop exploring that path since it can't lead to a match. We then backtrack and try the next possible path.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>If <code>root</code> is null, return <code>false</code> (base case).</p>
</li>
<li>
<p>Call <code>checkPath(root, head)</code> to start checking for the linked list path in the tree.</p>
</li>
<li>
<p><code>checkPath</code> function:</p>
<ul>
<li>If <code>node</code> is null, return <code>false</code> (base case).</li>
<li>Call <code>dfs(node, head)</code> to check if a matching path starts from <code>node</code>.
<ul>
<li>If <code>dfs</code> returns <code>true</code>, return <code>true</code> (a matching path is found).</li>
</ul>
</li>
<li>Recursively call <code>checkPath</code> on both left and right subtrees with the same <code>head</code>.</li>
</ul>
</li>
<li>
<p><code>dfs</code> function:</p>
<ul>
<li>If <code>head</code> is null, return <code>true</code> (all nodes in the list have been matched).</li>
<li>If <code>node</code> is null, return <code>false</code> (reached end of the tree without matching all nodes).</li>
<li>If the value of <code>node</code> does not match <code>head</code>, return <code>false</code> (value mismatch).</li>
<li>Recursively call <code>dfs</code> on both left and right children of <code>node</code> with <code>head-&gt;next</code>.</li>
</ul>
</li>
<li>
<p>Return <code>true</code> if <code>checkPath</code> or <code>dfs</code> finds a matching path; otherwise, continue checking.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6JiUxUZa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree and <span class="math inline">\(m\)</span> be the length of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>In the worst case, we might need to check every node in the tree as a potential starting point for the linked list. For each node, we might need to traverse up to m nodes in the linked list.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The space complexity remains the same as Approach 1 due to the recursive nature of the solution.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-approach">Approach 2: Iterative Approach</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A common rule of thumb is that all approaches solvable via recursion can also be solved using a stack to mimic the call stack's nature. Unlike recursion, where each function call adds a new frame to the call stack, using a stack avoids the risk of stack overflow errors in cases where the depth of recursion is too large (e.g., in a very deep tree).</p>
<p>We start by putting the root of the tree onto the stack. This stack helps us explore the tree without recursion. We repeatedly take the top node from the stack and check if there is a path from this node that matches the linked list. If there is, we return true. If not, we add the node's left and right children to the stack for further checking.</p>
<p>To match the path, we use another stack to keep track of pairs of tree nodes and linked list nodes. We compare each pair, and if they match, we continue with the next node in the linked list and the children of the current tree node. If we find that the entire linked list matches a path in the tree, we return true.</p>
<p>If we finish checking all possible paths without finding a match, we return false.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1367/iterative.json:1135,835!?!</p>
<blockquote>
<p>Fun fact: Iterative approaches often provide more control over traversal, allowing you to access every path and create patterns that do not follow traditional recursion rules.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Check if <code>root</code> is null:</p>
<ul>
<li>If <code>root</code> is null, return <code>false</code> (base case).</li>
</ul>
</li>
<li>
<p>Initialize a stack <code>nodes</code> and push <code>root</code> onto the stack.</p>
</li>
<li>
<p>While the stack <code>nodes</code> is not empty:</p>
<ul>
<li>Pop the top <code>node</code> from the stack.</li>
<li>Call <code>isMatch(node, head)</code> to check if the linked list <code>head</code> matches a path starting from <code>node</code>.
<ul>
<li>If <code>isMatch</code> returns <code>true</code>, return <code>true</code> (a matching path is found).</li>
</ul>
</li>
<li>If <code>node</code> has a left child, push it onto the stack.</li>
<li>If <code>node</code> has a right child, push it onto the stack.</li>
</ul>
</li>
<li>
<p>If no matching path is found after checking all nodes, return <code>false</code>.</p>
</li>
<li>
<p><code>isMatch</code> function:</p>
<ul>
<li>
<p>Initialize a stack <code>s</code> and push a pair <code>{node, lst}</code> onto it.</p>
</li>
<li>
<p>While the stack <code>s</code> is not empty:</p>
<ul>
<li>Pop the top pair <code>{currentNode, currentList}</code> from the stack.</li>
<li>While both <code>currentNode</code> and <code>currentList</code> are not null:
<ul>
<li>If <code>currentNode-&gt;val</code> does not match <code>currentList-&gt;val</code>, break (no match).</li>
<li>Move to the next node in the linked list (<code>currentList = currentList-&gt;next</code>).</li>
<li>If <code>currentList</code> is not null:
<ul>
<li>If <code>currentNode</code> has a left child, push <code>{currentNode-&gt;left, currentList}</code> onto the stack.</li>
<li>If <code>currentNode</code> has a right child, push <code>{currentNode-&gt;right, currentList}</code> onto the stack.</li>
<li>Break to continue with the next pair in the stack.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>currentList</code> becomes null, return <code>true</code> (all nodes in the list matched).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>false</code> if no matching path is found after exploring all possibilities.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GzvsGb96/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree and <span class="math inline">\(m\)</span> be the length of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>We potentially visit each node in the tree once. For each node, we might need to check up to <code>m</code> nodes in the linked list.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space is used by the stack, which in the worst case might contain all nodes of the tree. We don't need extra space for the linked list traversal as it's done iteratively.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-knuth-morris-pratt-kmp-algorithm">Approach 3: Knuth-Morris-Pratt (KMP) Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Approach 3 is more advanced and requires an understanding of the Knuth-Morris-Pratt (KMP) string-matching algorithm. We suggest reviewing <a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. Find the Index of the First Occurrence in a String - Easy Tagged</a> and solving it using the KMP algorithm before diving into this approach.</p>
<p>The previous approaches all involve searching the tree from the root and checking each path independently, which can be repetitive. By adjusting the idea behind the KMP algorithm, we can reduce this repetition and optimize the approach.</p>
<p>The KMP algorithm efficiently finds occurrences of a pattern (in this case, the linked list) within a text by using a prefix table, or failure function, to skip unnecessary comparisons.</p>
<p>The key to KMP is the prefix table, also known as the failure function. This table helps us understand how to skip certain comparisons based on what weâ€™ve already matched.</p>
<p>We first build a table that indicates the longest proper prefix of the pattern that is also a suffix. This table tells us where to resume the search in the pattern after a mismatch. For example, consider the pattern <code>ABABCABAB</code>. The prefix table for this pattern helps us understand that if a mismatch occurs after <code>AB</code>, we donâ€™t need to start from the beginning of the pattern but can skip to the next best position that aligns with what weâ€™ve already matched.</p>
<p>As we search for the pattern in the text, if we encounter a mismatch, the prefix table tells us how far back we should go in the pattern to continue the search efficiently. Instead of starting the comparison from the beginning of the pattern again, we use the prefix table to skip over parts of the pattern that have already been matched. This reduces unnecessary comparisons.</p>
<p>Similarly, we construct the prefix table for the linked list by following the same principle of finding the longest prefix that is also a suffix. This helps in efficiently finding where to resume the search if a mismatch occurs while traversing paths in the tree.</p>
<p>We perform a DFS on the tree, treating each node's value as part of the text where we want to match our pattern (the linked list). As we traverse the tree, if a mismatch occurs, the prefix table tells us how much of the pattern we can skip, based on what weâ€™ve already matched.</p>
<blockquote>
<p>Note: Running through a dry run of this approach will help you get a better grip on how it works. Itâ€™s a great way to see the logic in action with a few concrete examples and spot any issues.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Build the pattern and prefix table from the linked list:</p>
<ul>
<li>Initialize <code>pattern</code> with the value of the head node of the linked list.</li>
<li>Initialize <code>prefixTable</code> with <code>0</code> to store prefix lengths.</li>
<li>Iterate through the linked list to construct <code>pattern</code> and <code>prefixTable</code>:
<ul>
<li>For each value, update the <code>patternIndex</code> to find matching prefixes using the <code>prefixTable</code>.</li>
<li>Add the current value to <code>pattern</code> and update <code>prefixTable</code> accordingly.</li>
<li>Move to the next node in the linked list.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform DFS to search for the pattern in the tree:</p>
<ul>
<li>Call <code>searchInTree</code> with the root of the tree, starting pattern index <code>0</code>, and the <code>pattern</code> and <code>prefixTable</code>.</li>
</ul>
</li>
<li>
<p><code>searchInTree</code> function:</p>
<ul>
<li>
<p>If <code>node</code> is null, return <code>false</code> (base case).</p>
</li>
<li>
<p>Update <code>patternIndex</code> to find the matching prefix:</p>
<ul>
<li>If the current node value does not match the pattern at <code>patternIndex</code>, use the <code>prefixTable</code> to backtrack to the correct index.</li>
<li>Increment <code>patternIndex</code> if there is a match.</li>
</ul>
</li>
<li>
<p>Check if the entire <code>pattern</code> has been matched (<code>patternIndex == pattern.size()</code>):</p>
<ul>
<li>If matched, return <code>true</code>.</li>
</ul>
</li>
<li>
<p>Recursively search in both left and right subtrees of the current <code>node</code>:</p>
<ul>
<li>Return <code>true</code> if either subtree contains a matching path; otherwise, continue searching.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/H3NN3rA5/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree and <span class="math inline">\(m\)</span> be the length of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^{k - 1} \cdot m)\)</span></p>
<p>The complexity of building the <code>prefixTable</code> for the KMP pattern is <span class="math inline">\(O(m)\)</span>. However, the primary bottleneck is in the <code>searchInTree</code> function, which performs a DFS on the binary tree with <span class="math inline">\(n\)</span> nodes.</p>
<p>While traversing the tree, the algorithm repeatedly evaluates portions of the <code>pattern</code>, and due to the tree structure, a mismatch can trigger repetitive re-evaluation of the <code>prefixTable</code> across multiple nodes. In the worst case, this could result in up to <span class="math inline">\(O(2^{k - 1} \cdot m)\)</span> time complexity, where <span class="math inline">\(m = 2k - 1\)</span>, as each failed match can lead to exponential time growth due to repeated pattern comparisons.</p>
</li>
</ul>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We need <span class="math inline">\(O(m)\)</span> space for the pattern and prefix table. The recursive call stack in the worst case (skewed tree) can take up to <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-random-node/description" target="_blank" rel="noopener noreferrer">Linked List Random Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">math</span> <span class="topic-badge">randomized</span> <span class="topic-badge">reservoir-sampling</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a singly linked list, return a random node&#39;s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>

<p>Implement the <code>Solution</code> class:</p>

<ul>
	<li><code>Solution(ListNode head)</code> Initializes the object with the head of the singly-linked list <code>head</code>.</li>
	<li><code>int getRandom()</code> Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg" style="width: 302px; height: 62px;" />
<pre>
<strong>Input</strong>
[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]
[[[1, 2, 3]], [], [], [], [], []]
<strong>Output</strong>
[null, 1, 3, 2, 2, 3]

<strong>Explanation</strong>
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // return 1
solution.getRandom(); // return 3
solution.getRandom(); // return 2
solution.getRandom(); // return 2
solution.getRandom(); // return 3
// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the linked list will be in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>getRandom</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>What if the linked list is extremely large and its length is unknown to you?</li>
	<li>Could you solve this efficiently without using extra space?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/linked-list-that-is-sorted-alternatingly/1" target="_blank" rel="noopener noreferrer">Linked List that is Sorted Alternatingly</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a <strong>Linked list</strong><strong>.</strong> The list is in <strong>alternating ascending</strong> and <strong>descending orders</strong>. Sort&nbsp;the given linked list in <strong>non-decreasing order</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList = 13-&gt;99-&gt;21-&gt;80-&gt;50
<strong>Output: </strong>13-&gt;21-&gt;50-&gt;80-&gt;99<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700572/Web/Other/blobid1_1724073782.png" width="406" height="142" /><br /><strong>Explanation: </strong>After sorting the given list will be 13-&gt;21-&gt;50-&gt;80-&gt;99.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList = 1-&gt;9-&gt;2-&gt;8-&gt;3-&gt;7
<strong>Output: </strong>1-&gt;2-&gt;3-&gt;7-&gt;8-&gt;9<strong>
Explanation: </strong>After sorting the given list will be 1-&gt;2-&gt;3-&gt;7-&gt;8-&gt;9.
</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>4</sup><br />0 &lt;= node-&gt;data &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/make-binary-tree/1" target="_blank" rel="noopener noreferrer">Linked List to Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">queue</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>head&nbsp;</strong> Linked List . Construct the <strong>complete</strong> binary tree from the given <strong>Linked List</strong> and return the <strong>root </strong>of the tree. The result will be judged by printing the <strong>level order </strong>traversal of the binary tree. <br /></span><span style="font-size: 14pt;"><strong>Note:&nbsp;</strong>The complete binary tree is represented as a linked list in a way where if the root node is stored at position i, its left, and right children are stored at position&nbsp;<strong>2*i+1</strong>, and&nbsp;<strong>2*i+2</strong> respectively. H is the height of the tree and this space is used implicitly for the recursion stack.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>head : 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/907724/Web/Other/blobid4_1754630164.webp" width="466" height="58" /><br /><strong>Output: </strong>[1, 2, 3, 4, 5]<strong>
Explanation: </strong>The tree would look like <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/907724/Web/Other/blobid0_1754630061.webp" width="245" height="190" /><br />Now, the level order traversal of the above tree is 1 2 3 4 5.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>head: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/907724/Web/Other/blobid1_1754630079.webp" width="490" height="61" /><br /><strong>Output: </strong>[5, 4, 3, 2, 1]<strong>
Explanation: </strong>The tree would look like
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/907724/Web/Other/blobid2_1754630112.webp" width="262" height="203" /> <br />Now, the level order traversal of the above tree is 5 4 3 2 1.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; numbers of nodes &le; 10<sup>6</sup><br />1 &le; node-&gt;data &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lru-cache/description" target="_blank" rel="noopener noreferrer">LRU Cache</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure that follows the constraints of a <strong><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank">Least Recently Used (LRU) cache</a></strong>.</p>

<p>Implement the <code>LRUCache</code> class:</p>

<ul>
	<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>
	<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>
	<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>
</ul>

<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>Explanation</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= capacity &lt;= 3000</code></li>
	<li><code>0 &lt;= key &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-twin-sum-of-a-linked-list/description" target="_blank" rel="noopener noreferrer">Maximum Twin Sum of a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a linked list of size <code>n</code>, where <code>n</code> is <strong>even</strong>, the <code>i<sup>th</sup></code> node (<strong>0-indexed</strong>) of the linked list is known as the <strong>twin</strong> of the <code>(n-1-i)<sup>th</sup></code> node, if <code>0 &lt;= i &lt;= (n / 2) - 1</code>.</p>

<ul>
	<li>For example, if <code>n = 4</code>, then node <code>0</code> is the twin of node <code>3</code>, and node <code>1</code> is the twin of node <code>2</code>. These are the only nodes with twins for <code>n = 4</code>.</li>
</ul>

<p>The <strong>twin sum </strong>is defined as the sum of a node and its twin.</p>

<p>Given the <code>head</code> of a linked list with even length, return <em>the <strong>maximum twin sum</strong> of the linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png" style="width: 250px; height: 70px;" />
<pre>
<strong>Input:</strong> head = [5,4,2,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong>
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png" style="width: 250px; height: 70px;" />
<pre>
<strong>Input:</strong> head = [4,2,2,3]
<strong>Output:</strong> 7
<strong>Explanation:</strong>
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7. 
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png" style="width: 200px; height: 88px;" />
<pre>
<strong>Input:</strong> head = [1,100000]
<strong>Output:</strong> 100001
<strong>Explanation:</strong>
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is an <strong>even</strong> integer in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-in-between-linked-lists/description" target="_blank" rel="noopener noreferrer">Merge In Between Linked Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two linked lists: <code>list1</code> and <code>list2</code> of sizes <code>n</code> and <code>m</code> respectively.</p>

<p>Remove <code>list1</code>&#39;s nodes from the <code>a<sup>th</sup></code> node to the <code>b<sup>th</sup></code> node, and put <code>list2</code> in their place.</p>

<p>The blue edges and nodes in the following figure indicate the result:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/fig1.png" style="height: 130px; width: 504px;" />
<p><em>Build the result list and return its head.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/01/ll.png" style="width: 609px; height: 210px;" />
<pre>
<strong>Input:</strong> list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
<strong>Output:</strong> [10,1,13,1000000,1000001,1000002,5]
<strong>Explanation:</strong> We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex2.png" style="width: 463px; height: 140px;" />
<pre>
<strong>Input:</strong> list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]
<strong>Output:</strong> [0,1,1000000,1000001,1000002,1000003,1000004,6]
<strong>Explanation:</strong> The blue edges and nodes in the above figure indicate the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= list1.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= a &lt;= b &lt; list1.length - 1</code></li>
	<li><code>1 &lt;= list2.length &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The task is to replace the section of <code>list1</code> from the <code class="">a<sup>th</sup></code> node to the <code class="">b<sup>th</sup></code> node with <code>list2</code>. Note that <code>a</code> and <code>b</code> refer to the node's indices (0-indexed), not their values.</p>
<p>The resultant linked list will have this format:</p>
<p>[<code>list1</code> from index <code>0</code> to <code>a - 1</code>] âŸ¶ [<code>list2</code>] âŸ¶ [<code>list1</code> index <code>b + 1</code> to <code>tail</code>]</p>
<hr />
<h3 id="approach-1-merge-values-in-array">Approach 1: Merge Values in Array</h3>
<h4 id="intuition">Intuition</h4>
<p>The linked list is 0-indexed, and we need to merge the linked lists based on their indices. We can traverse the linked lists, and use an array <code>mergeArray</code> to store the nodes' values in the correct order.</p>
<blockquote>
<p>The <code>ListNode</code> implementation does not store the length of the linked list, so we cannot compute the required length of the <code>mergeArray</code>. We use a dynamic array implementation so we can add values as necessary.</p>
</blockquote>
<p>After adding the values to the array, we will build a new linked list using the values stored in the array.</p>
<p>First, we add the node values of <code>list1</code> before index <code>a</code> to the array.</p>
<p>Next, we add the node values of <code>list2</code> to the array.</p>
<p>Then, we add the node values of <code>list1</code> after index <code>b</code> to the array.</p>
<p>Finally, we iterate through the array, creating a new node for each value and adding it to the result linked list, which we return.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array,  <code>mergeArray</code>.</li>
<li>Add <code>list1</code> node values from index <code>0</code> to <code>a - 1</code> to the array:
<ul>
<li>Initialize a variable <code>index</code> to <code>0</code> and a ListNode <code>current1</code> to <code>list1</code>.</li>
<li>While <code>index</code> is less than <code>a</code>, add <code>current1.val</code> to the <code>mergeArray</code>, set <code>current1</code> to <code>current1.next</code>, and increment <code>index</code>.</li>
</ul>
</li>
<li>Add <code>list2</code> node values to the array:
<ul>
<li>Initialize a ListNode <code>current2</code> to <code>list2</code>.</li>
<li>While <code>current2</code> is not <code>null</code>, add <code>current2.val</code> to the <code>mergeArray</code> and set <code>current2</code> to <code>current2.next</code>.</li>
</ul>
</li>
<li>Find the node at index <code>b + 1</code>.
<ul>
<li>While <code>index</code> is less than <code>b + 1</code>, set <code>current1</code> to <code>current1.next</code>, and increment <code>index</code>.</li>
</ul>
</li>
<li>Add <code>list1</code> node values from index <code>b + 1</code> to tail to the array.
<ul>
<li>While <code>current1</code> is not <code>null</code>, add <code>current1.val</code> to the <code>mergeArray</code> and set <code>current1</code> to <code>current1.next</code>.</li>
</ul>
</li>
<li>Build a new linked list by traversing the <code>mergeArray</code> in a reverse manner:
<ul>
<li>Initialize a ListNode <code>resultList</code> with <code>null</code>.</li>
<li>For each value in <code>mergeArray</code>, create a new node <code>newNode</code> with the value and set the <code>next</code> field to <code>resultList</code>. Then set <code>resultList</code> to <code>newnode</code>. This adds the new node to the front of <code>resultList</code>.</li>
</ul>
</li>
<li>Return <code>resultList</code>, the front of the new linked list.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1669/1669_slideshow1.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LiRKLphS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>list1</code> and <span class="math inline">\(m\)</span> be the length of <code>list2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The algorithm traverses <code>list1</code> and <code>list2</code> to add the nodes to the array, taking <span class="math inline">\(n + m\)</span> computational steps.</p>
<p>Then, the array is traversed once to create the resulting linked list. The size of the array will be at most <span class="math inline">\(n + m\)</span>.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We use <code>mergeArray</code>, which can contain the values of <code>list1</code> and <code>list2</code>. It can have at most <span class="math inline">\(n + m\)</span> elements. Therefore, the space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer">Approach 2: Two Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The above approach used extra space to solve the problem. Because of the nature of linked lists, we can meet our goal by changing the pointers, which allows us to solve the problem with limited extra space.</p>
<p>The below image shows how to replace index <code>a</code> through <code>b</code> of <code>list1</code> with <code>list2</code> by modifying pointers with the following input:</p>
<p><strong>Input:</strong> list1 = [1,1,1,1,1,1,1], a = 3, b = 4, list2 = [2,2,2]</p>
<p><img src="../Figures/1669/image1.png" alt="Example" /></p>
<p>The <code>next</code> of the node at index <code>a - 1</code> of <code>list1</code> points to the head of <code>list2</code>.<br />
The <code>next</code> of the tail of <code>list2</code> points to the node at index <code>b + 1</code> of <code>list1</code>.</p>
<p>To solve the problem, we will need to complete the following two steps:</p>
<p><strong>Step 1</strong></p>
<ul>
<li>Find the node at index <code>a - 1</code> of <code>list1</code>, which we will call <code>start</code>.</li>
<li>Set <code>start.next</code> to <code>list2</code>.</li>
</ul>
<p><strong>Step 2</strong></p>
<ul>
<li>Find the node at (original) index <code>b</code> of <code>list1</code>, which we will call <code>end</code>.</li>
<li>Set the <code>next</code> of the tail of <code>list2</code> to <code>end.next</code>.</li>
</ul>
<p>We can find the <code>start</code> node and the <code>end</code> node using a for loop with the iterator <code>index</code> where <code>index</code> is the index of the current node.</p>
<p>We traverse <code>list1</code> with the pointer <code>end</code>, which starts at the head of <code>list1</code> and is progressed using <code>end = end.next</code> until <code>end</code> points to the node at index <code>b</code> of <code>list1</code>. Inside the loop, we set <code>start</code> to <code>end</code> if <code>index = a - 1</code>.</p>
<p>After the loop, we set <code>start.next</code> to <code>list2</code>, then traverse <code>list2</code> until we find its tail.</p>
<p>Next, we set the <code>next</code> of &quot;tail of <code>list2</code>&quot; to <code>end.next</code>. Moreover, we set <code>end.next</code> to <code>null</code> so there aren't multiple pointers to the node at (original) index <code>b + 1</code>.</p>
<p>Finally, we return <code>list1</code>.</p>
<blockquote>
<p><strong>Note:</strong> This approach modifies the input. The problem statement implies that the lists can be modified as they are merged.</p>
<p><strong>Interview Tip: In-place Algorithms</strong></p>
<p>In-place algorithms overwrite the input to save space, but sometimes this can cause problems.</p>
<p>Here are a couple of situations where an in-place algorithm might not be suitable.</p>
<ol>
<li>
<p>The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.</p>
</li>
<li>
<p>Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.</p>
</li>
</ol>
<p>In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize two ListNodes, <code>start</code> to <code>null</code> and <code>end</code> to <code>list1</code>.</li>
<li>Find the nodes at index <code>a - 1</code> and <code>b</code> of <code>list1</code>. Traverse through <code>list1</code> using a <code>for</code> loop with the iterator <code>index</code> from <code>0</code> to <code>b - 1</code>:
<ul>
<li>If <code>index</code> equals <code>a - 1</code> set <code>start</code> to <code>end</code>.</li>
<li>Progress to the next node in <code>list1</code>  by setting <code>end</code> to <code>end.next</code>.</li>
</ul>
</li>
<li>Set <code>start.next</code> to <code>list2</code>.</li>
<li>Find the tail of <code>list2</code> by traversing the list with <code>list2 = list2.next</code> until the last node is reached.</li>
<li>Set <code>list2.next</code> to <code>end.next</code> and set <code>end.next</code> to <code>null</code>. Note that the order of the statements is important.</li>
<li>Return <code>list1</code>, which points to the head of the resultant linked list.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1669/1669_slideshow2.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/4MXf743C/shared">code</a></p>
<p><strong>Note:</strong> Setting <code>end.next</code> to <code>null</code> is not necessary to solve this problem, but is a good practice to prevent unpredictable behavior. This way, modifications made to the removed nodes won't affect the result linked list.</p>
<details>
<summary>Click to see Recursive Implementation</summary>
<p>
<p>We start by defining a recursive function, <code>findTail</code>, that takes a linked list as a parameter and returns the tail of that linked list.</p>
<p>Then we define a recursive function, <code>merge</code>, which takes all the same parameters as <code>mergeInBetween</code>, plus an integer <code>index</code> and two pointers <code>start</code> and <code>end</code>. This function works very similarly to the above implementation. If <code>index</code> is <code>a - 1</code>, we set <code>start</code> to <code>end</code>. The base case is when <code>index</code> is <code>b</code>: we connect the <code>start</code> node to <code>list2</code>; find the tail of <code>list2</code> and set it to <code>end.next</code>; and return <code>list1</code> as the merged list. Otherwise, the function recursively calls itself, with <code>index + 1</code> and <code>end.next</code>.</p>
<p><a href="https://leetcode.com/playground/ZyiNF2fi/shared">code</a></p>
<p>Both functions in the recursive implementation use tail recursion, which is an optimization technique used in functional programming to avoid the use of explicit loops and improve performance.</p>
<p>In a recursive function, each recursive call creates a new stack frame, which can lead to a stack overflow if the function is called too many times. Tail recursion reduces this problem by reusing the current stack frame instead of creating a new one. Functions that use tail recursion have the following properties: the last statement of the function is a recursive call, and the function has a base case that can be reached by the recursive call. The base case is used to stop the recursion and return a value.</p>
<blockquote>
<p>Note: The recursive implementation shown here illustrates how an algorithm can be implemented both iteratively and recursively. While the recursion-based solution is valid, the iterative implementation remains the most intuitive and optimized solution.</p>
</blockquote>
<p><span class="math inline">\(\downarrow_{\text{Section after Recursive Implementation}}\)</span></p>
</p>
</details> 
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>list1</code> and <span class="math inline">\(m\)</span> be the length of <code>list2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The algorithm traverses <code>list1</code> once to find the nodes <code>start</code> and <code>end</code>. Note that <code>list1</code> is not fully traversed for every input, but in the worst case, we may need to traverse at most <span class="math inline">\(n\)</span> nodes. <code>list2</code> is traversed once to find its tail. The other operations all take constant time.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
<p>The recursive implementation has the same time complexity as the iterative implementation.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a few variables and pointers, including <code>index</code>, <code>start</code>, and <code>end</code>, which use constant extra space. We don't use any data structures that grow with input size, so the space complexity of the iterative implementation is <span class="math inline">\(O(1)\)</span>.</p>
<p>The recursive implementation may use up to <span class="math inline">\(O(n + m)\)</span> space for the recursive call stack, though this space may be reduced through the use of tail recursion, depending on the implementation language.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/merge-k-sorted-linked-lists/1" target="_blank" rel="noopener noreferrer">Merge K sorted linked lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">heap</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[] </strong>of <strong>n</strong> <strong>sorted linked lists</strong> of different sizes. You have to <strong>merge</strong> them in such a way that after merging they will be a <strong>single sorted</strong> linked list, then <strong>return </strong>the<strong> head</strong> of the merged linked list.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1 -&gt; 2 -&gt; 3, 4 -&gt; 5, 5 -&gt; 6, 7 -&gt; 8]
<strong>Output: </strong>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8<strong>
Explanation:<br /></strong>The arr[] has 4 sorted linked list of size 3, 2, 2, 2.
1st list: 1 -&gt; 2-&gt; 3
2nd list: 4 -&gt; 5
3rd list: 5 -&gt; 6
4th list: 7 -&gt; 8
The merged list will be:
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700265/Web/Other/blobid0_1737094930.png" width="388" height="68" /> </pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1 -&gt; 3, 8, 4 -&gt; 5 -&gt; 6]
<strong>Output: </strong>1 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 8<strong>
Explanation:<br /></strong>The arr[] has 3 sorted linked list of size 2, 3, 1.
1st list: 1 -&gt; 3
2nd list: 8
3rd list: 4 -&gt; 5 -&gt; 6
The merged list will be:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700265/Web/Other/blobid1_1722513386.png" width="400" height="70" /></span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints</strong><br />1 &le; total no. of nodes &le; 10<sup>5</sup><sup><br /></sup>1 &le; node-&gt;data &le; 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-k-sorted-lists/description" target="_blank" rel="noopener noreferrer">Merge k Sorted Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">linked list</span> <span class="topic-badge">merge sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>

<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]
<strong>Output:</strong> [1,1,2,3,4,4,5,6]
<strong>Explanation:</strong> The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted linked list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> lists = []
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> lists = [[]]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>k == lists.length</code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
	<li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>
	<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>
	<li>The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-nodes-in-between-zeros/description" target="_blank" rel="noopener noreferrer">Merge Nodes in Between Zeros</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list, which contains a series of integers <strong>separated</strong> by <code>0</code>&#39;s. The <strong>beginning</strong> and <strong>end</strong> of the linked list will have <code>Node.val == 0</code>.</p>

<p>For <strong>every </strong>two consecutive <code>0</code>&#39;s, <strong>merge</strong> all the nodes lying in between them into a single node whose value is the <strong>sum</strong> of all the merged nodes. The modified list should not contain any <code>0</code>&#39;s.</p>

<p>Return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png" style="width: 600px; height: 41px;" />
<pre>
<strong>Input:</strong> head = [0,3,1,0,4,5,2,0]
<strong>Output:</strong> [4,11]
<strong>Explanation:</strong> 
The above figure represents the given linked list. The modified list contains
- The sum of the nodes marked in green: 3 + 1 = 4.
- The sum of the nodes marked in red: 4 + 5 + 2 = 11.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png" style="width: 600px; height: 41px;" />
<pre>
<strong>Input:</strong> head = [0,1,0,3,0,2,2,0]
<strong>Output:</strong> [1,3,4]
<strong>Explanation:</strong> 
The above figure represents the given linked list. The modified list contains
- The sum of the nodes marked in green: 1 = 1.
- The sum of the nodes marked in red: 3 = 3.
- The sum of the nodes marked in yellow: 2 + 2 = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[3, 2 * 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
	<li>There are <strong>no</strong> two consecutive nodes with <code>Node.val == 0</code>.</li>
	<li>The <strong>beginning</strong> and <strong>end</strong> of the linked list have <code>Node.val == 0</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-two-pointer-one-pass">Approach 1: Two-Pointer (One-Pass)</h3>
<h4 id="intuition">Intuition</h4>
<p>We can break this problem into two tasks: finding the sum of all the nodes between two consecutive <code>0</code>s, and merging these values into a single list. One brute force idea is to iterate through the linked list, summing the node values, and adding this sum to a new linked list when we encounter a <code>0</code>. However, we can modify the linked list in the given problem.</p>
<p>We can use a two-pointer approach to modify the list. The first pointer, <code>modify</code>, changes the linked list and the second pointer, <code>nextSum</code>, calculates the sum for each block between two <code>0</code>s. Initially, both pointers start at the beginning of the list.</p>
<p>How can we manage both pointers while traversing the list? After <code>nextSum</code> calculates the sum for the current block, we store this value at the <code>modify</code> node. Since <code>nextSum</code> is at a <code>0</code> at the end of the block, it moves to the next node to start summing the next block.</p>
<p>The number of nodes in the modified linked list matches the number of blocks between consecutive <code>0</code>s. After processing each block, we update <code>modify</code>'s next pointer to <code>nextSum</code>, helping maintain the size of the modified list, with both pointers reaching the end simultaneously.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize <code>modify</code> and <code>nextSum</code> with <code>head-&gt;next</code> that stores the first node with a non-zero value.</li>
<li>Iterate through the list until <code>modify</code> is not null:
<ul>
<li>Initialize <code>sum</code> with <code>0</code> to store the sum of the current block.</li>
<li>Iterate through the block until <code>nextSum</code> encounters a <code>0</code>:
<ul>
<li>Add the value of the current node to <code>sum</code>.</li>
<li>Move <code>nextSum</code> to the next node.</li>
</ul>
</li>
<li>Modify the node value at <code>modify</code> to <code>sum</code>.</li>
<li>Move <code>nextSum</code> to the next node that stores the next block's first non-zero value. Also, set <code>modify-&gt;next</code> to this node.</li>
<li>Move <code>modify</code> to it's next node.</li>
</ul>
</li>
<li>Return <code>head-&gt;next</code>.</li>
</ol>
<p>!?!../Documents/2181/slideshow1.json:960,454!?!<br />
Â </p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jCEwUhzW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>All the nodes of the linked list are visited exactly once. Therefore, the total time complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Apart from the original list, we don't use any additional space. Therefore, the total space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Recursion is useful for solving problems that can be broken down into smaller, repetitive sub-problems. Finding the sum of every 0-separated block is an example of such a sub-problem, making recursion an appropriate approach.</p>
<p>We can start at the beginning of a block with the current node's value as <code>0</code> and calculate the sum for this block by iterating through the list and adding values until encountering another <code>0</code>. At this point, the pointer will be at the start of the next block. The new list starting at this pointer resembles the original list but with one less block to compute. Therefore, we can pass this pointer to the recursive function as a new sub-problem, as explained below:</p>
<p><img src="../Figures/2181/Slide8.png" alt="img" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Store the first non-zero value, given by <code>head-&gt;next</code>, in <code>head</code>.</li>
<li>If <code>head</code> is null, return <code>head</code>.</li>
<li>Initialize a dummy node <code>temp</code> with <code>head</code>.</li>
<li>Initialize <code>sum</code> with <code>0</code>.</li>
<li>Iterate through the list until the value of <code>temp</code> is not <code>0</code>:
<ul>
<li>Increment <code>sum</code> with the value of <code>temp</code>.</li>
<li>Set <code>temp</code> as <code>temp-&gt;next</code>.</li>
</ul>
</li>
<li>Store the updated <code>sum</code> in the value of <code>head</code>.</li>
<li>Store <code>head-&gt;next</code> as the solution of the sub-problem starting at <code>temp</code>, given by <code>mergeNodes(temp)</code>.</li>
<li>Return <code>head</code>.<br />
Â </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/FJrMZDRp/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>All the nodes of the linked list are visited exactly once. Therefore, the total time complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The extra space comes from implicit stack space due to recursion. The recursion could go up to <span class="math inline">\(n\)</span> levels deep. Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sort-a-linked-list/1" target="_blank" rel="noopener noreferrer">Merge Sort for Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a pointer/reference to the head of the linked list, the task is to <strong>sort the given linked list using Merge Sort</strong>.</span><br /><span style="font-size: 18px;"><strong>Note:</strong> If the length of the linked list is odd, then the extra node should go into the first list while splitting.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>LinkedList: 3-&gt;5-&gt;2-&gt;4-&gt;1
<strong>Output: </strong>1-&gt;2-&gt;3-&gt;4-&gt;5<strong>
Explanation: </strong>After sorting the given linked list, the resultant matrix will be 1-&gt;2-&gt;3-&gt;4-&gt;5.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700523/Web/Other/blobid0_1722065236.png" width="400" height="180" /></span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>LinkedList: 9-&gt;15-&gt;0
<strong>Output: </strong>0-&gt;9-&gt;15<strong>
Explanation: </strong>After sorting the given linked list , resultant will be 0-&gt;9-&gt;15.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700523/Web/Other/blobid1_1722065301.png" width="393" height="177" /><br /></span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n*log(n))<br /><strong>Expected Auxiliary Space:</strong> O(n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>5<br /></sup>0 &lt;= node-&gt;data &lt;= 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/merge-sort-on-doubly-linked-list/1" target="_blank" rel="noopener noreferrer">Merge Sort on Doubly Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given Pointer/Reference to the <strong>head</strong> of a<strong> </strong>doubly linked list, the task is to Sort<strong> </strong>the<strong> </strong>given doubly linked list<strong> </strong>using<strong> Merge Sort&nbsp;</strong>in both <strong>non-decreasing</strong> and <strong>non-increasing</strong> order.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong> Return the head of the sorted&nbsp;non-decreasing&nbsp;doubly linked list. The driver code will print it forward and backward in both directions.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList:<strong> </strong>7 &harr; 3 &harr; 5 &harr; 2 &harr; 6 &harr; 4 &harr; 1 &harr; 8
<strong>Output:
</strong>LinkedList: 1 &harr; 2 &harr; 3 &harr; 4 &harr; 5 &harr; 6 &harr; 7 &harr; 8
LinkedList: 8 &harr; 7 &harr; 6 &harr; 5 &harr; 4 &harr; 3 &harr; 2 &harr; 1<strong>
Explanation: </strong>After sorting the given linked list in both ways, the resultant matrix will be as shown in the first two lines of the output. The first line shows the output for non-decreasing order, and the next line shows the output for non-increasing order.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700538/Web/Other/blobid0_1725342004.png" width="371" height="139" /><br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList: 9 &harr; 15 &harr; 0 &harr; -1 &harr; 0<br /><strong>Output:</strong>
LinkedList: -1 &harr; 0 &harr; 0 &harr; 9 &harr; 15
LinkedList: 15 &harr; 9 &harr; 0 &harr; 0 &harr; -1<strong>
Explanation: </strong>After sorting the given linked list in both ways, the resultant list will be -1 &rarr; 0 &rarr; 0 &rarr; 9 &rarr; 15 in non-decreasing order and 15 &rarr; 9 &rarr; 0 &rarr; 0 &rarr; -1 in non-increasing order.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700538/Web/Other/blobid1_1725342021.png" width="363" height="136" /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;=&nbsp;<span style="font-family: Arial; white-space-collapse: preserve; background-color: #ffffff;">number of nodes</span> &lt;= 10<sup>5<br /></sup>-10<sup>5</sup> &lt;= node-&gt;data &lt;= 10<sup>5<br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-two-sorted-lists/description" target="_blank" rel="noopener noreferrer">Merge Two Sorted Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>

<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>

<p>Return <em>the head of the merged linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" style="width: 662px; height: 302px;" />
<pre>
<strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]
<strong>Output:</strong> [1,1,2,3,4,4]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> list1 = [], list2 = []
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> list1 = [], list2 = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/middle-of-the-linked-list/description" target="_blank" rel="noopener noreferrer">Middle of the Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, return <em>the middle node of the linked list</em>.</p>

<p>If there are two middle nodes, return <strong>the second middle</strong> node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" style="width: 544px; height: 65px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [3,4,5]
<strong>Explanation:</strong> The middle node of the list is node 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg" style="width: 664px; height: 65px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5,6]
<strong>Output:</strong> [4,5,6]
<strong>Explanation:</strong> Since the list has two middle nodes with values 3 and 4, we return the second one.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-pair-removal-to-sort-array-i/description" target="_blank" rel="noopener noreferrer">Minimum Pair Removal to Sort Array I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code>, you can perform the following operation any number of times:</p>

<ul>
	<li>Select the <strong>adjacent</strong> pair with the <strong>minimum</strong> sum in <code>nums</code>. If multiple such pairs exist, choose the leftmost one.</li>
	<li>Replace the pair with their sum.</li>
</ul>

<p>Return the <strong>minimum number of operations</strong> needed to make the array <strong>non-decreasing</strong>.</p>

<p>An array is said to be <strong>non-decreasing</strong> if each element is greater than or equal to its previous element (if it exists).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,2,3,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The pair <code>(3,1)</code> has the minimum sum of 4. After replacement, <code>nums = [5,2,4]</code>.</li>
	<li>The pair <code>(2,4)</code> has the minimum sum of 6. After replacement, <code>nums = [5,6]</code>.</li>
</ul>

<p>The array <code>nums</code> became non-decreasing in two operations.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The array <code>nums</code> is already sorted.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-pair-removal-to-sort-array-ii/description" target="_blank" rel="noopener noreferrer">Minimum Pair Removal to Sort Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code>, you can perform the following operation any number of times:</p>

<ul>
	<li>Select the <strong>adjacent</strong> pair with the <strong>minimum</strong> sum in <code>nums</code>. If multiple such pairs exist, choose the leftmost one.</li>
	<li>Replace the pair with their sum.</li>
</ul>

<p>Return the <strong>minimum number of operations</strong> needed to make the array <strong>non-decreasing</strong>.</p>

<p>An array is said to be <strong>non-decreasing</strong> if each element is greater than or equal to its previous element (if it exists).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,2,3,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The pair <code>(3,1)</code> has the minimum sum of 4. After replacement, <code>nums = [5,2,4]</code>.</li>
	<li>The pair <code>(2,4)</code> has the minimum sum of 6. After replacement, <code>nums = [5,6]</code>.</li>
</ul>

<p>The array <code>nums</code> became non-decreasing in two operations.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The array <code>nums</code> is already sorted.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-node-in-linked-list/description" target="_blank" rel="noopener noreferrer">Next Greater Node In Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked list</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list with <code>n</code> nodes.</p>

<p>For each node in the list, find the value of the <strong>next greater node</strong>. That is, for each node, find the value of the first node that is next to it and has a <strong>strictly larger</strong> value than it.</p>

<p>Return an integer array <code>answer</code> where <code>answer[i]</code> is the value of the next greater node of the <code>i<sup>th</sup></code> node (<strong>1-indexed</strong>). If the <code>i<sup>th</sup></code> node does not have a next greater node, set <code>answer[i] = 0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg" style="width: 304px; height: 133px;" />
<pre>
<strong>Input:</strong> head = [2,1,5]
<strong>Output:</strong> [5,5,0]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg" style="width: 500px; height: 113px;" />
<pre>
<strong>Input:</strong> head = [2,7,4,3,5]
<strong>Output:</strong> [7,0,5,5,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We start by copying the individual node values in the linked list <code>head</code> into an array (let's call it <code>values</code>), which is easier to access and makes the problem a bit more intuitive.</p>
<p><img src="../Figures/1019/1019-1.png" alt="img" /></p>
<p>Now the problem becomes, for each value in the array, we need to find the next larger element on its right side.</p>
<hr />
<h3 id="approach-1-monotonic-stack">Approach 1: Monotonic Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's start with the most straightforward approach: brute force. That is, to iterate over all elements after <code>values[i]</code> until finding the first larger element for <code>values[i]</code>. This approach has two nested loops, so it may not pass all test cases.</p>
<p>Instead of using one iteration for each value, can we finish finding all the first larger values in a single traverse? The answer is YES!</p>
<p>Note that we are looking for the <strong>next</strong> greater value. If the value we are currently visiting (<code>values[i]</code>) is larger than the value <code>values[smaller]</code> on the top of the stack, we can pop <code>smaller</code> from the stack to prevent it from being visited again later, and let <code>values[i]</code> be <code>values[smaller]</code>'s next greater value.</p>
<p><img src="../Figures/1019/1019-ex.png" alt="img" /></p>
<p>When will the above process stop? When the stack is empty, or <code>values[i]</code> is not larger than the top element of the stack, we can safely push <code>i</code> to stack and move on to the next index <code>i + 1</code>. Similarly, if we encounter any value that is larger than <code>values[i]</code>, we can use it to pop <code>i</code> from the stack.</p>
<p>Since we want to set the next greater value for each index, we would better push the index <code>i</code> instead of the value <code>values[i]</code> to the stack, so that every time we pop an index from the stack, we can directly update the next greater value for this index. After the iteration over the array stops, indexes left in the stack stand for values that don't have such next greater values, we can just set their next greater values as 0.</p>
<p>Refer to the following slides as an example:</p>
<p>!?!../Documents/1019/s1.json:601,301!?!</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Traverse through the linked list <code>head</code>, and use an array <code>values</code> to store the values of nodes.</li>
<li>Initialize an array <code>answer</code> with the same size as <code>values</code> and an empty stack <code>stack</code> to store the previous indexes.</li>
<li>Iterate over <code>values</code>, before we push each index <code>i</code> to <code>stack</code>:
<ul>
<li>If the value represented by the top element of <code>stack</code> (let's call it <code>values[smaller]</code>) is smaller than <code>values[i]</code>, it means that <code>values[i]</code> is <code>values[smaller]</code>'s larger value. So we pop <code>smaller</code> from the <code>stack</code>, update <code>answer[smaller] = values[i]</code> and repeat this step.</li>
<li>Otherwise, it means there is no value smaller than <code>values[i]</code>, we add <code>values[i]</code> to stack and repeat step 3.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8kCjQAdo/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the linked list <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We iterate over <code>head</code> to record all values in <code>values</code>, it takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>We then iterate over <code>values</code> which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>During the iteration, there may be multiple operations on the stack, however, each index is pushed to and popped from the stack at most once, so the total time in the worst-case scenario is <span class="math inline">\(O(n)\)</span>.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We used an array <code>values</code> to store the values of eery node in <code>head</code> which takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>We used a stack <code>stack</code> to maintain a non-increasing sequence, there may be up to <span class="math inline">\(n\)</span> elements in <code>stack</code> thus it also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack-1-pass">Approach 2: Monotonic Stack, 1 Pass</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can further reduce the number of iterations. In the previous approach, we store node values from the linked list <code>head</code> into <code>values</code> by the first iteration and find the next greater value in the second iteration. Here we only use one iteration by recording the value from the <code>head</code> and updating <code>stack</code> in the same iteration step!</p>
<p>Compared to approach 1, the differences are as follows:</p>
<ul>
<li>We don't know the size of the linked list <code>head</code>, thus we can't initialize an array of equal size. Instead, we start with an empty array <code>answer</code> and increment its size during the iteration.</li>
<li>We don't use the array <code>values</code> to store all values from <code>head</code>, so we should store both the index and the value of each node to <code>stack</code>. Then we can get the value of each node from the index without referring to <code>values</code>.</li>
</ul>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an empty <code>answer</code> and an empty stack <code>stack</code> to store the previous indexes.</li>
<li>Iterate over <code>head</code> starting with index <code>i = 0</code>, for each current node, and compare the value of <code>head.val</code> with the element <code>[i, val]</code> on the top of the stack, if <code>head.val &gt; val</code>, pop the top element <code>[top_i, val]</code> from the stack and update <code>answer[top_i] = head.val</code>.</li>
<li>Push the <code>[i, head.val]</code> to the top of <code>stack</code>.</li>
<li>Add <code>0</code> to <code>answer</code>, which is the default next larger value for <code>head.val</code>.</li>
<li>Repeat step 2 until we finish the iteration.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/iRUQDkZx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the linked list <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We iterate over <code>head</code>. During the iteration, there may be multiple operations on the stack, however, each index <code>cnt</code> is pushed to and popped from the stack at most once, so the total time in the worst-case scenario is <span class="math inline">\(O(n)\)</span>.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We only used a stack <code>stack</code>, there may be up to <span class="math inline">\(n\)</span> elements in <code>stack</code> thus it also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/odd-even-linked-list/description" target="_blank" rel="noopener noreferrer">Odd Even Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p>

<p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p>

<p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p>

<p>You must solve the problem&nbsp;in <code>O(1)</code>&nbsp;extra space complexity and <code>O(n)</code> time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" style="width: 300px; height: 123px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [1,3,5,2,4]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" style="width: 500px; height: 142px;" />
<pre>
<strong>Input:</strong> head = [2,1,3,5,6,4,7]
<strong>Output:</strong> [2,3,6,7,1,5,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the linked list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>6</sup> &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/palindrome-linked-list/description" target="_blank" rel="noopener noreferrer">Palindrome Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, return <code>true</code><em> if it is a </em><span data-keyword="palindrome-sequence"><em>palindrome</em></span><em> or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" style="width: 422px; height: 62px;" />
<pre>
<strong>Input:</strong> head = [1,2,2,1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" style="width: 182px; height: 62px;" />
<pre>
<strong>Input:</strong> head = [1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-list/description" target="_blank" rel="noopener noreferrer">Partition List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>

<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" style="width: 662px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3
<strong>Output:</strong> [1,2,2,4,3,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [2,1], x = 2
<strong>Output:</strong> [1,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li><code>-200 &lt;= x &lt;= 200</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/populating-next-right-pointers-in-each-node/description" target="_blank" rel="noopener noreferrer">Populating Next Right Pointers in Each Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>

<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>

<p>Initially, all next pointers are set to <code>NULL</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" style="width: 500px; height: 171px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]
<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong></p>

<ul>
	<li>You may only use constant extra space.</li>
	<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description" target="_blank" rel="noopener noreferrer">Populating Next Right Pointers in Each Node II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree</p>

<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>

<p>Initially, all next pointers are set to <code>NULL</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" style="width: 500px; height: 171px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,null,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]
<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 6000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong></p>

<ul>
	<li>You may only use constant extra space.</li>
	<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-duplicates-from-sorted-list/description" target="_blank" rel="noopener noreferrer">Remove Duplicates from Sorted List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a sorted linked list, <em>delete all duplicates such that each element appears only once</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" style="width: 302px; height: 242px;" />
<pre>
<strong>Input:</strong> head = [1,1,2]
<strong>Output:</strong> [1,2]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,1,2,3,3]
<strong>Output:</strong> [1,2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description" target="_blank" rel="noopener noreferrer">Remove Duplicates from Sorted List II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a sorted linked list, <em>delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" style="width: 500px; height: 142px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,3,4,4,5]
<strong>Output:</strong> [1,2,5]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" style="width: 500px; height: 205px;" />
<pre>
<strong>Input:</strong> head = [1,1,1,2,3]
<strong>Output:</strong> [2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-linked-list-elements/description" target="_blank" rel="noopener noreferrer">Remove Linked List Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" style="width: 500px; height: 142px;" />
<pre>
<strong>Input:</strong> head = [1,2,6,3,4,5,6], val = 6
<strong>Output:</strong> [1,2,3,4,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [], val = 1
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = [7,7,7,7], val = 7
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 50</code></li>
	<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-nodes-from-linked-list/description" target="_blank" rel="noopener noreferrer">Remove Nodes From Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list.</p>

<p>Remove every node which has a node with a greater value anywhere to the right side of it.</p>

<p>Return <em>the </em><code>head</code><em> of the modified linked list.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/02/drawio.png" style="width: 631px; height: 51px;" />
<pre>
<strong>Input:</strong> head = [5,2,13,3,8]
<strong>Output:</strong> [13,8]
<strong>Explanation:</strong> The nodes that should be removed are 5, 2 and 3.
- Node 13 is to the right of node 5.
- Node 13 is to the right of node 2.
- Node 8 is to the right of node 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1,1,1,1]
<strong>Output:</strong> [1,1,1,1]
<strong>Explanation:</strong> Every node has value 1, so no nodes are removed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the given list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given the head of a linked list, the task is to remove every node that has a node with a greater value anywhere on its right side. This means that after processing the linked list, every node will only have nodes with smaller values to their right, or the linked list should be in decreasing order.</p>
<p><strong>Key Observations</strong></p>
<ol>
<li>The nodes in the linked list have positive values.</li>
<li>There may be duplicate values.</li>
<li>We manipulate the list by deleting values, not by sorting it.</li>
</ol>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>A challenge associated with this problem is that, for a given node, we need to not only delete the node directly to the right if it has a larger value but also delete all other nodes to the right that have larger values. The brute force approach involves iterating through the linked list using nested loops, comparing the value of each node with the nodes that follow it, and deleting any nodes whose values are smaller than the following nodes. However, this approach is inefficient, with a quadratic time complexity.</p>
<p>The resultant linked list should be in decreasing order. We can leverage this fact to develop a more efficient solution.</p>
<p>A list in decreasing order, if reversed, is in increasing order.</p>
<p>If we reverse the list, the node values should be in increasing order after deleting nodes. We can delete any nodes whose values are smaller than the nodes before them. This strategy ensures efficient deletion of all nodes that have nodes with a greater value to their right (in the original order) without using nested loops.</p>
<p>The list we are given is a singly linked list, so we can't easily traverse it in reverse from tail to head.</p>
<p>Whenever a problem requires reversing a sequence, it is worth considering using a stack.</p>
<p>Stacks are a First-In-Last-Out (FILO) data structure, meaning that the first items added to the stack are the last ones removed. Consequently, if you push a sequence of items into a stack and then remove them, the sequence will be reversed. Learn more about stacks by reading our <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card</a>.</p>
<p>We start by adding all of the nodes to a stack.</p>
<p>Next, we create a new linked list to store the result. We keep track of the maximum node value encountered so far using the variable <code>maximum</code>.</p>
<p>Then, we pop each node from the stack. If the node's value is not smaller than the <code>maximum</code>, we create a new node with that value and add it to the <code>resultList</code>. Since the linked list is reversed, we build the <code>resultList</code> from back to front, continuously adding new nodes to the beginning.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an empty <code>stack</code> to be used for reversing the nodes.</li>
<li>Set a pointer <code>current</code> to <code>head</code>.</li>
<li>While <code>current</code> is not <code>Null</code>:
<ul>
<li>Add <code>current</code> to the <code>stack</code>.</li>
<li>Set <code>current</code> to <code>current.next</code>.</li>
</ul>
</li>
<li>Pop the node from the top of the <code>stack</code> and set <code>current</code> to that node.</li>
<li>Initialize a variable <code>maximum</code> to <code>current.val</code>.</li>
<li>Create a new ListNode <code>resultList</code> with <code>maximum</code> as its value.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop the node from the top of the <code>stack</code> and set <code>current</code> to that node.</li>
<li>If <code>current.val</code> &lt; <code>maximum</code>:
<ul>
<li>Continue; this node does not need to be added to the <code>resultList</code>.</li>
</ul>
</li>
<li>Otherwise, add a new node to the front of the <code>resultList</code>:
<ul>
<li>Create a new ListNode <code>newNode</code> with <code>current.val</code> as its value.</li>
<li>Set <code>newNode.next</code> to <code>resultList</code>.</li>
<li>Set <code>resultList</code> to <code>newNode</code>.</li>
<li>Update <code>maximum</code> to <code>current.val</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>resultList</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2487/2487_slideshow2.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/2CTMtkxy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Adding the nodes from the original linked list to the stack takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Removing nodes from the stack and adding them to the result takes <span class="math inline">\(O(n)\)</span>, as each node is popped from the stack exactly once.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(2n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We add each of the nodes from the original linked list to the <code>stack</code>, making its size <span class="math inline">\(n\)</span>.</p>
<p>We only use <code>resultList</code> to store the result, so it does not contribute to the space complexity.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The nodes we retain in the linked list must meet the following criteria: Each node's value is not smaller than the values of the following nodes.</p>
<p>Linked lists are often manipulated using recursion. This problem is an excellent candidate for recursion because it can be broken down into subproblems that collectively solve the main problem.</p>
<p>Consider a node <span class="math inline">\(B\)</span> situated in the middle of the linked list, where all subsequent nodes have values less than or equal to <span class="math inline">\(B\)</span>'s value. If node <span class="math inline">\(B\)</span> satisfies this criterion, its value is not smaller than the values of the following nodes. For the node <span class="math inline">\(A\)</span> directly preceding <span class="math inline">\(B\)</span>, if <span class="math inline">\(A\)</span> is not smaller than <span class="math inline">\(B\)</span>, then <span class="math inline">\(A\)</span> is also not smaller than any nodes following <span class="math inline">\(B\)</span>. This holds due to the transitive property: if <span class="math inline">\(a \geq b\)</span> and <span class="math inline">\(b \geq c\)</span>, then <span class="math inline">\(a \geq c\)</span>.</p>
<p>This means that if we've solved the subproblem for nodes to the right of a given node in the linked list, we can efficiently solve the problem for that node.</p>
<p>Let`s begin by discussing the base cases:</p>
<ol>
<li>
<p>The linked list is empty:</p>
<ul>
<li>An empty list meets the criteria, so we return the <code>head</code>.</li>
</ul>
</li>
<li>
<p>The linked list has only one node:</p>
<ul>
<li>A list with one node also meets the criteria, because there are no following nodes. Again, we return the <code>head</code>.</li>
</ul>
</li>
</ol>
<p>We can develop a strategy for handling longer lists by thinking about handling a linked list with two nodes.</p>
<p>For a linked list with two nodes, there are two cases for the <code>head</code> node:</p>
<ol>
<li>
<p>The <code>head</code> node's value is the same size or larger than the next node's value.</p>
<ul>
<li>This linked list meets the criteria. Return the list.</li>
</ul>
</li>
<li>
<p>The <code>head</code> node's value is smaller than the next node's value.</p>
<ul>
<li>We need to delete <code>head</code>. Return the next node.</li>
</ul>
</li>
</ol>
<p>For linked lists with more than two nodes, the main adjustment we need to make is to check the rest of the linked list.</p>
<p>The challenge we face is ensuring that <code>head.next</code> is set to the correct next node. Does the next node also need to be deleted? Are there other nodes later in the linked list that have values that are greater than <code>head</code>?</p>
<p>Instead of simply setting <code>head</code> to <code>head.next</code> to progress to the next node, we recursively call <code>removeNodes(head.next)</code>. This recursive function removes nodes with greater values anywhere to the right. This ensures that <code>head</code> is set to the correct node and that the rest of the linked list also meets the criteria.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Base Case: If <code>head</code> or <code>head.next</code> is <code>Null</code>, return <code>head</code>.</li>
<li>Recursive Call: Set <code>nextNode</code> to <code>removeNodes(head.next)</code>.</li>
<li>Comparison: If <code>head.val</code> is less than <code>nextNode.val</code>, we need to remove <code>head</code>. Return <code>nextNode</code>.</li>
<li>Otherwise, set <code>head</code> to <code>head.next</code> and then return <code>head</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/L2EFsxaF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We call <code>removeNodes()</code> once for each node in the original linked list. The other operations inside the function all take constant time, so the time complexity is dominated by the recursive calls. Thus, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since we make <span class="math inline">\(n\)</span> recursive calls to <code>removeNodes()</code>, the call stack can grow up to size <span class="math inline">\(n\)</span>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-reverse-twice">Approach 3: Reverse Twice</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The first approach used a stack to reverse the linked list, resulting in linear auxiliary space. However, instead of using a stack, we can write a function to reverse the nodes in place, avoiding the need for auxiliary space. This task is explored in the problem <a href="https://leetcode.com/problems/reverse-linked-list/description/">Reverse Linked List</a>. The basic idea is to set each node's next field to point to the previous node.</p>
<p>After reversing the linked list, the node values will be in increasing order, allowing us to delete any nodes whose values are smaller than the nodes preceding them.</p>
<p>To facilitate this process, we maintain the maximum node value found so far using the variable <code>maximum</code>.</p>
<p>We traverse each node, <code>current</code>, in the reversed linked list and update the <code>maximum</code> value accordingly. If the value of the <code>current</code> node is smaller than the <code>maximum</code>, we delete <code>current</code>. Deleting nodes in place requires us to track the previous node so that we can correctly link it to the next node if we delete the <code>current</code> node.</p>
<p>Once we have traversed the linked list to delete the nodes, we have a linked list that is in increasing order.</p>
<p>However, since the desired result should be in decreasing order, we reverse the modified linked list and then return it.</p>
<blockquote>
<p><strong>Interview Tip: In-place Algorithms</strong></p>
<p>This approach modifies the input. In-place algorithms overwrite the input to save space, but sometimes this can cause problems.</p>
<p>Here are a couple of situations where an in-place algorithm might not be suitable.</p>
<ol>
<li>
<p>The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.</p>
</li>
<li>
<p>Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.</p>
</li>
</ol>
<p>In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Define a function <code>reverseList</code> that takes the head of a linked list as input and reverses it, returning the new head.
<ul>
<li>Initialize three pointers, <code>prev</code> to <code>null</code>, <code>current</code> to <code>head</code>, and <code>nextTemp</code> to <code>null</code>.</li>
<li>While <code>current</code> is not <code>null</code>:
<ul>
<li>Set <code>nextTemp</code> to <code>current.next</code>.</li>
<li>Reverse the order of the nodes by setting <code>current.next</code> to <code>prev</code>.</li>
<li>Progress both pointers by setting <code>prev</code> to <code>current</code> and <code>current</code> to <code>nextTemp</code>.</li>
</ul>
</li>
<li>Return <code>prev</code>.</li>
</ul>
</li>
<li>Reverse the original linked list using <code>reverseList(head)</code>. Set <code>head</code> to the reversed linked list.</li>
<li>Initialize a variable <code>maximum</code> to <code>0</code>.</li>
<li>Initialize two pointers, <code>prev</code> to <code>null</code> and <code>current</code> to <code>head</code>.</li>
<li>Delete the nodes that are smaller than the node before them. While <code>current</code> is not <code>null</code>:
<ul>
<li>Update <code>maximum</code> to the max between <code>maximum</code> and <code>current.val</code>.</li>
<li>If <code>current.val</code> is less than <code>maximum</code>, delete <code>current</code>.
<ul>
<li>Skip the current node by setting <code>prev.next</code> to <code>current.next</code>.</li>
<li>Set a pointer <code>deleted</code> to <code>current</code>.</li>
<li>Move <code>current</code> to <code>current.next</code> to progress to the next node.</li>
<li>Set <code>deleted.next</code> to <code>null</code> to remove any additional pointers to the new <code>current</code> node.</li>
</ul>
</li>
<li>Otherwise, if <code>current.val</code> is not less than <code>maximum</code>, retain <code>current</code> and progress both pointers by setting <code>prev</code> to <code>current</code> and <code>current</code> to <code>current.next</code>.</li>
</ul>
</li>
<li>Reverse and return the modified linked list using <code>reverseList(head)</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2487/2487_slideshow3.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/aq46D8sp/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Reversing the original linked list takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Traversing the reversed original linked list and removing nodes takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Reversing the modified linked list takes an additional <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the total time complexity is <span class="math inline">\(O(3n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a few variables and pointers that use constant extra space. Since we don't use any data structures that grow with input size, the space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-nth-node-from-end-of-list/description" target="_blank" rel="noopener noreferrer">Remove Nth Node From End of List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], n = 2
<strong>Output:</strong> [1,2,3,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1], n = 1
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = [1,2], n = 1
<strong>Output:</strong> [1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>sz</code>.</li>
	<li><code>1 &lt;= sz &lt;= 30</code></li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
	<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you do this in one pass?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/description" target="_blank" rel="noopener noreferrer">Remove Zero Sum Consecutive Nodes from Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, we repeatedly delete consecutive sequences of nodes that sum to <code>0</code> until there are no such sequences.</p>

<p>After doing so, return the head of the final linked list.&nbsp; You may return any such answer.</p>

<p>&nbsp;</p>
<p>(Note that in the examples below, all sequences are serializations of <code>ListNode</code> objects.)</p>

<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> head = [1,2,-3,3,1]
<strong>Output:</strong> [3,1]
<strong>Note:</strong> The answer [1,2,1] would also be accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1,2,3,-3,4]
<strong>Output:</strong> [1,2,4]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = [1,2,3,-3,-2]
<strong>Output:</strong> [1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The given linked list will contain between <code>1</code> and <code>1000</code> nodes.</li>
	<li>Each node in the linked list has <code>-1000 &lt;= node.val &lt;= 1000</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The task is to delete consecutive sequences of nodes that sum to zero from the given linked list.</p>
<p>If all of the nodes in a given consecutive sequence are negative, or they are all positive, there is not a zero-sum consecutive sequence. If a consecutive sequence of nodes has mixed signs, as in both positive and negative values, there may be a zero-sum consecutive sequence.</p>
<p>One case of nodes that sum to zero is additive inverses, or opposites, such as <code>-3 âŸ¶ 3</code>. Other consecutive sequences that sum to zero may have multiple nodes such as <code>1 âŸ¶ -3 âŸ¶ 2</code>.</p>
<p>We can break this problem up into two main tasks:</p>
<ol>
<li>Identifying consecutive sequences of zero-sum nodes.</li>
<li>Removing those consecutive sequences.</li>
</ol>
<hr />
<h3 id="approach-1-prefix-sum-for-each-consecutive-sequence">Approach 1: Prefix Sum for Each Consecutive Sequence</h3>
<h4 id="intuition">Intuition</h4>
<p>We may need to remove the <code>head</code> of the given linked list if it is part of a sequence of zero-sum consecutive nodes. We will save a ListNode <code>front</code> with any arbitrary value whose <code>next</code> field points to <code>head</code>. If <code>head</code> is deleted, <code>front.next</code> will be updated to the next remaining node, so we still have a reference to the front of the final linked list.</p>
<p><strong>1. How do we identify consecutive sequences of zero-sum nodes?</strong></p>
<p>Problems that require sequences of elements to meet certain criteria are often efficiently solved with <a href="https://leetcode.com/tag/prefix-sum/">prefix sum</a>. A prefix sum is the sum of prefixes, or running total, of the input sequence.</p>
<blockquote>
<p><strong>Prefix Sum Example</strong></p>
<p>Linked List: <code>1 âŸ¶ 4 âŸ¶ -3</code></p>
<ul>
<li>The prefix sum of node <code>1</code> is <span class="math inline">\(1\)</span>.</li>
<li>The prefix sum of node <code>4</code> is <span class="math inline">\(1 + 4 = 5\)</span>.</li>
<li>The prefix sum of node <code>-3</code> is <span class="math inline">\(1 + 4 - 3 = 2\)</span>.</li>
</ul>
</blockquote>
<p>We can calculate the prefix sum for every sequence of consecutive nodes. We loop through nodes in the linked list with <code>start</code>, which is the node before the start of each sequence, and <code>end</code>, which is the end of each sequence. We calculate the prefix sum of the nodes between <code>start</code> (exclusive) and <code>end</code> (inclusive).</p>
<p><img src="../Figures/1171/1171ExampleA1.png" alt="Example A1" /></p>
<p>When the prefix sum of the last element in a consecutive sequence is <code>0</code>, we know we need to remove nodes. In this case, the consecutive zero-sum sequence is <code>3 âŸ¶ -3</code>, so we need to remove those nodes. The remaining list should be <code>1 âŸ¶ 4 âŸ¶ 5 âŸ¶ 6</code>.</p>
<p><strong>2. How do we delete the consecutive zero-sum nodes?</strong></p>
<p>To delete the nodes, we need to add a connection from node <code>4</code> to node <code>5</code>, which will skip the zero-sum nodes in the linked list.</p>
<p><img src="../Figures/1171/1171ExampleA2.png" alt="Example A2" /></p>
<p>When we encounter a prefix sum of <code>0</code>, we can &quot;delete&quot; the zero-sum consecutive sequence by setting <code>start.next</code> to <code>end.next</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize a new ListNode <code>front</code> with the value <code>0</code> whose <code>next</code> field points to <code>head</code> and a node <code>start</code> to <code>front</code>.</p>
</li>
<li>
<p>Process all of the nodes in the linked list, while <code>start != null</code>:</p>
<ul>
<li>
<p>Initialize a variable <code>prefixSum</code> to <code>0</code> and a ListNode <code>end</code> to <code>start.next</code>.</p>
</li>
<li>
<p>Process the rest of the nodes in the linked list, while <code>end != null</code>:</p>
<ul>
<li>
<p>Add <code>end</code>'s value to <code>prefixSum</code>.</p>
</li>
<li>
<p>If <code>prefixSum</code> equals <code>0</code>, make a connection from <code>start</code> to the last node after the zero-sum consecutive sequence by setting <code>start.next</code> to <code>end.next</code></p>
</li>
<li>
<p>Set <code>end</code> to <code>end.next</code>.</p>
</li>
</ul>
</li>
<li>
<p>Set <code>start</code> to <code>start.next</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>front.next</code>. The <code>front</code> points to the head of the final linked list.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/7M3XSFku/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We use nested <code>while</code> loops to process the list. The outer while loop will run <span class="math inline">\(n\)</span> times since there are <span class="math inline">\(n\)</span> nodes in the list. With each iteration of the outer while loop, there will be one fewer node remaining in the linked list.</p>
<p>The inner while loop will run <span class="math inline">\(n\)</span> times then, <span class="math inline">\(n - 1\)</span> times, then <span class="math inline">\(n -2\)</span>, etc. until the <span class="math inline">\(n^{th}\)</span> iteration of the outer while loop, where the inner while loop will run <span class="math inline">\(1\)</span> time. The total number of times the inner while loop runs is the sum <span class="math inline">\(n + (n - 1) + (n - 2) + \dots + (n - (n - 1))\)</span>. This can be calculated by the formula <span class="math inline">\(\frac{n(n + 1)}{2}\)</span>, which we can simplify to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a handful of variables and no extra space that grows with input size, so the space complexity is constant, i.e. <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-sum-hash-table">Approach 2: Prefix Sum Hash Table</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We will use a dummy node <code>front</code> similar to the above approach.</p>
<p><strong>1. How do we identify consecutive sequences of zero-sum nodes?</strong></p>
<p>The above approach has a quadratic time complexity, which is not very efficient. We need a way to identify consecutive sequences of zero-sum nodes without calculating the prefix sum for every possible consecutive sequence. Let's look at an example of the prefix sum of each node from the front of the linked list.</p>
<p><img src="../Figures/1171/1171ExampleA3.png" alt="prefix_sum Example A3" /></p>
<p>How can we use the prefix sum to determine zero-sum consecutive sequences? Let's examine the above example to determine what patterns we notice in the prefix sum when there is a zero-sum consecutive sequence. One pattern we notice is that the prefix sum increases when the node has a positive value, and decreases when the node has a negative value.</p>
<p>The zero-sum consecutive sequence in the example is <code>3 âŸ¶ -3</code>. What do we notice about the prefix sum? The prefix sum at the end of this consecutive sequence, <span class="math inline">\(5\)</span>, is the same as the prefix sum before the sequence.</p>
<p>This makes sense; a zero-sum consecutive sequence will have a prefix sum of zero. The prefix sum before and at the end of the sequence will be the same. When we encounter a prefix sum that we have seen before, we have discovered a zero-sum consecutive sequence.</p>
<blockquote>
<p>The crucial insight is that the prefix sum from the <code>front</code> node to node <code>A</code> will be equal to the sum from the <code>front</code> node to node <code>B</code> if and only if the sum from node <code>A.next</code> to node <code>B</code> is <code>0</code>.</p>
</blockquote>
<p>To determine when to remove nodes, we need to be able to store and reference the prefix sums found so far. A <a href="https://leetcode.com/explore/learn/card/hash-table/">hash table</a> is an efficient way to do this.</p>
<p>We will use a hash table to store the prefix sum. The key will be the prefix sum, and the value will be the node that has that prefix sum.</p>
<p>We will process the linked list, calculating the prefix sum for each node, <code>current</code>, and saving it in the hash table <code>prefixSumToNode</code>.</p>
<p><strong>2. How do we remove the consecutive zero-sum nodes?</strong></p>
<p>Let's look at this example:</p>
<p><img src="../Figures/1171/1171ExampleB1.png" alt="Example B1" /></p>
<p>When we encounter a prefix sum we have seen before, we know we need to remove nodes. In this case, we need to remove nodes <code>-3</code>, <code>1</code>, and <code>2</code>. The remaining list should be <code>1 âŸ¶ 4 âŸ¶ 5 âŸ¶ 6</code>.</p>
<p>To delete the nodes, we need to add a connection from node <code>4</code> to node <code>5</code>, which will skip the zero-sum nodes in the linked list. In the example, node <code>4</code> is A, and node 2 is <code>B</code>.</p>
<p>Let's start by making our hash table.</p>
<p>!?!../Documents/1171/1171_slideshow.json: 960,540!?!</p>
<p>Notice that there is only one entry for the prefix sum 5. First, the corresponding node is node 4, then it is node 2. A duplicate prefix sum means there is a zero-sum consecutive sequence. Recall that the hash table does not store duplicate keys, so only the last occurrence of a given prefix sum is stored in the hash table. This is node <code>B</code>. All nodes between the first occurrence of a prefix sum through node <code>B</code> need to be deleted because they are part of a zero-sum consecutive sequence.</p>
<p>To find the first occurrence of a prefix sum, we can traverse through the linked list again, recalculating the prefix sums.</p>
<p><img src="../Figures/1171/1171ExampleB2.png" alt="Example B2" /></p>
<p>We can connect <code>A</code>, the last node before the zero-sum consecutive sequence, to <code>B.next</code>, the first node after. This will eliminate the zero-sum nodes <code>A.next</code> through <code>B</code>.</p>
<p>We can find <code>B.next</code> with <code>prefixSumToNode[prefixSum].next</code>.</p>
<p>When there is no zero-sum consecutive sequence, <code>A</code> and <code>B</code> are essentially the same node. Hence, by assigning <code>A.next</code> to <code>B.next</code>, we aren't changing the linked list.</p>
<p>After removing zero-sum nodes, we return <code>front.next</code>. The <code>front</code> points to the head of the final linked list.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialization:</p>
<ul>
<li>
<p>Initialize a new ListNode <code>front</code> with the value <code>0</code> whose <code>next</code> field points to <code>head</code> and a node <code>current</code> to <code>front</code>.</p>
</li>
<li>
<p>Initialize a variable <code>prefixSum</code> to <code>0</code> and a hashmap <code>prefixSumToNode</code>, which stores integer, ListNode pairs. The key is the prefix sum, and the value is the corresponding ListNode. Add <code>front</code> to the hashmap.</p>
</li>
</ul>
</li>
<li>
<p>Process all of the nodes in the linked list, while <code>current != null</code>:</p>
<ul>
<li>
<p>Add <code>current</code>'s value to <code>prefixSum</code>.</p>
</li>
<li>
<p>Add the prefix sum and node pair to the <code>prefixSumToNode</code> hashmap.</p>
</li>
<li>
<p>Set <code>current</code> to <code>current.next</code>.</p>
</li>
</ul>
</li>
<li>
<p>Reset <code>prefixSum</code> to <code>0</code> and <code>current</code> to <code>front</code>.</p>
</li>
<li>
<p>Process all of the nodes in the linked list, while <code>current != null</code>:</p>
<ul>
<li>
<p>Add <code>current</code>'s value to <code>prefixSum</code>.</p>
</li>
<li>
<p>Make a connection from <code>current</code> to the last node after the zero-sum consecutive sequence by setting <code>current.next</code> to <code>prefixSumToNode[prefixSum].next</code>.</p>
</li>
<li>
<p>Set <code>current</code> to <code>current.next</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>front.next</code>. The <code>front</code> points to the head of the final linked list.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/8bqe42aa/shared">code</a></p>
<p>The above implementation visited each node in the linked list twice. Can we form a one-pass solution?</p>
<p>We can implement a solution using aspects of both previous solutions. Like the above approach, it uses a prefix sum hash table to identify consecutive zero-sum sequences, but like the first approach, it traverses the linked list with a nested while loop.</p>
<p>When we encounter a prefix sum we have seen before, we know we need to remove a sequence of consecutive zero-sum nodes. We can connect node <code>A</code>, the first node before the sequence, to <code>B.next</code>, the node after the zero-sum consecutive sequence. We need to delete the hash table entries of the nodes in the zero-sum sequence so we don't incorrectly delete any following nodes that have the same prefix sum as a node in this zero-sum consecutive sequence. We iterate through the nodes between <code>A</code> and <code>B</code>, removing each one from the hash table.</p>
<p>In this implementation, we do not necessarily visit every node twice, but we do visit nodes that are part of zero-sum consecutive sequences twice to delete them from the hash table.</p>
<p><a href="https://leetcode.com/playground/7cheg7sP/shared">code</a></p>
<p>Although we use a nested while loop, the inner loop deletes nodes that are part of zero-sum sequences, and once a node is deleted, it will not be re-visited. We handle each node of the linked list <em>at most twice</em>, once to add it to the hash table and once to delete it. In the previous implementation, we were visiting each node <em>exactly twice</em>.</p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse through the linked list twice, once to calculate the prefix sums, and once to delete nodes, so the time complexity is <span class="math inline">\(O(2n)\)</span>, which we can simplify to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We initialize the hash table <code>prefixSumToNode</code>, which is size <span class="math inline">\(O(e)\)</span> where <span class="math inline">\(e\)</span> is the number of distinct prefix sums calculated from in <code>nums</code>. At worst, when there are no zero-sum consecutive sequences, there can be <span class="math inline">\(n\)</span> distinct prefix sums, so the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reorder-list/description" target="_blank" rel="noopener noreferrer">Reorder List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the head of a singly linked-list. The list can be represented as:</p>

<pre>
L<sub>0</sub> &rarr; L<sub>1</sub> &rarr; &hellip; &rarr; L<sub>n - 1</sub> &rarr; L<sub>n</sub>
</pre>

<p><em>Reorder the list to be on the following form:</em></p>

<pre>
L<sub>0</sub> &rarr; L<sub>n</sub> &rarr; L<sub>1</sub> &rarr; L<sub>n - 1</sub> &rarr; L<sub>2</sub> &rarr; L<sub>n - 2</sub> &rarr; &hellip;
</pre>

<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg" style="width: 422px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [1,4,2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [1,5,2,4,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-linked-list/description" target="_blank" rel="noopener noreferrer">Reverse Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [5,4,3,2,1]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" style="width: 182px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2]
<strong>Output:</strong> [2,1]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>
	<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-linked-list-ii/description" target="_blank" rel="noopener noreferrer">Reverse Linked List II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4
<strong>Output:</strong> [1,4,3,2,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [5], left = 1, right = 1
<strong>Output:</strong> [5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
	<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you do it in one pass?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-nodes-in-even-length-groups/description" target="_blank" rel="noopener noreferrer">Reverse Nodes in Even Length Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list.</p>

<p>The nodes in the linked list are <strong>sequentially</strong> assigned to <strong>non-empty</strong> groups whose lengths form the sequence of the natural numbers (<code>1, 2, 3, 4, ...</code>). The <strong>length</strong> of a group is the number of nodes assigned to it. In other words,</p>

<ul>
	<li>The <code>1<sup>st</sup></code> node is assigned to the first group.</li>
	<li>The <code>2<sup>nd</sup></code> and the <code>3<sup>rd</sup></code> nodes are assigned to the second group.</li>
	<li>The <code>4<sup>th</sup></code>, <code>5<sup>th</sup></code>, and <code>6<sup>th</sup></code> nodes are assigned to the third group, and so on.</li>
</ul>

<p>Note that the length of the last group may be less than or equal to <code>1 + the length of the second to last group</code>.</p>

<p><strong>Reverse</strong> the nodes in each group with an <strong>even</strong> length, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/25/eg1.png" style="width: 699px; height: 124px;" />
<pre>
<strong>Input:</strong> head = [5,2,6,3,9,1,7,3,8,4]
<strong>Output:</strong> [5,6,2,3,9,1,4,8,3,7]
<strong>Explanation:</strong>
- The length of the first group is 1, which is odd, hence no reversal occurs.
- The length of the second group is 2, which is even, hence the nodes are reversed.
- The length of the third group is 3, which is odd, hence no reversal occurs.
- The length of the last group is 4, which is even, hence the nodes are reversed.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/25/eg2.png" style="width: 284px; height: 114px;" />
<pre>
<strong>Input:</strong> head = [1,1,0,6]
<strong>Output:</strong> [1,0,1,6]
<strong>Explanation:</strong>
- The length of the first group is 1. No reversal occurs.
- The length of the second group is 2. The nodes are reversed.
- The length of the last group is 1. No reversal occurs.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/17/ex3.png" style="width: 348px; height: 114px;" />
<pre>
<strong>Input:</strong> head = [1,1,0,6,5]
<strong>Output:</strong> [1,0,1,5,6]
<strong>Explanation:</strong>
- The length of the first group is 1. No reversal occurs.
- The length of the second group is 2. The nodes are reversed.
- The length of the last group is 2. The nodes are reversed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-nodes-in-k-group/description" target="_blank" rel="noopener noreferrer">Reverse Nodes in k-Group</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return <em>the modified list</em>.</p>

<p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p>

<p>You may not alter the values in the list&#39;s nodes, only nodes themselves may be changed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], k = 2
<strong>Output:</strong> [2,1,4,3,5]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], k = 3
<strong>Output:</strong> [3,2,1,4,5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Can you solve the problem in <code>O(1)</code> extra memory space?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotate-list/description" target="_blank" rel="noopener noreferrer">Rotate List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked&nbsp;list, rotate the list to the right by <code>k</code> places.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" style="width: 450px; height: 191px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], k = 2
<strong>Output:</strong> [4,5,1,2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" style="width: 305px; height: 350px;" />
<pre>
<strong>Input:</strong> head = [0,1,2], k = 4
<strong>Output:</strong> [2,0,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 500]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li><code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sorted-list-to-bst/1" target="_blank" rel="noopener noreferrer">Sorted Linked List to BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 12pt;">Given a Singly Linked List which has data members sorted in ascending order. Construct a&nbsp;Balanced Binary Search Tree&nbsp;which has same data members as the given Linked List.<br /><strong>Note: </strong>There might be nodes with the same value.</span></p>
<p><span style="font-size: 12pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>Linked List: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706336/Web/Other/blobid0_1722838240.png" width="404" height="63" />
<strong>Output: </strong>4 2 1 3 6 5 7<br /><strong>Explanation : </strong>The BST formed using elements of the linked list is -
        4
      /   \
     2     6
   /  \   / \
  1   3  5   7  
Hence, preorder traversal of this tree is 4 2 1 3 6 5 7
</span></pre>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>Linked List : 1-&gt;2-&gt;3-&gt;4<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706336/Web/Other/blobid1_1722838295.png" width="404" height="63" /> <br /><strong>Ouput: </strong>3 2 1 4<br /></span><strong style="font-size: 12pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation: </strong><span style="font-size: 12pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">The BST formed using elements of the linked list is -</span><br /><span style="font-size: 12pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706336/Web/Other/blobid2_1722838310.png" width="402" height="141" />
Hence, the preorder traversal of this tree is 3 2 1 4
</span></pre>
<div><span style="font-size: 12pt;"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Auxiliary Space:</strong> O(n)</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 12pt;"><strong>Constraints</strong>:</span></div>
<div><span style="font-size: 12pt;">1 &le; Number of Nodes &le; 10<sup>6</sup></span></div>
<div><span style="font-size: 12pt;">1 &le; Value of each node &le; 10<sup>6</sup></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-list/description" target="_blank" rel="noopener noreferrer">Sort List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">linked list</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" style="width: 450px; height: 194px;" />
<pre>
<strong>Input:</strong> head = [4,2,1,3]
<strong>Output:</strong> [1,2,3,4]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" style="width: 550px; height: 184px;" />
<pre>
<strong>Input:</strong> head = [-1,5,3,4,0]
<strong>Output:</strong> [-1,0,3,4,5]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/spiral-matrix-iv/description" target="_blank" rel="noopener noreferrer">Spiral Matrix IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked list</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>m</code> and <code>n</code>, which represent the dimensions of a matrix.</p>

<p>You are also given the <code>head</code> of a linked list of integers.</p>

<p>Generate an <code>m x n</code> matrix that contains the integers in the linked list presented in <strong>spiral</strong> order <strong>(clockwise)</strong>, starting from the <strong>top-left</strong> of the matrix. If there are remaining empty spaces, fill them with <code>-1</code>.</p>

<p>Return <em>the generated matrix</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg" style="width: 240px; height: 150px;" />
<pre>
<strong>Input:</strong> m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
<strong>Output:</strong> [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
<strong>Explanation:</strong> The diagram above shows how the values are printed in the matrix.
Note that the remaining spaces in the matrix are filled with -1.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg" style="width: 221px; height: 60px;" />
<pre>
<strong>Input:</strong> m = 1, n = 4, head = [0,1,2]
<strong>Output:</strong> [[0,1,2,-1]]
<strong>Explanation:</strong> The diagram above shows how the values are printed from left to right in the matrix.
The last space in the matrix is set to -1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li>The number of nodes in the list is in the range <code>[1, m * n]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-simulation">Approach: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>We have two integers, <code>m</code> and <code>n</code>, representing the dimensions of a matrix. We are also given the <code>head</code> of a linked list containing the elements of the matrix in spiral order. Our task is to reconstruct the original matrix.</p>
<p>We can simulate the spiral movement by following these steps:</p>
<ul>
<li>Start by moving to the right until reaching the boundary.</li>
<li>Then move downwards until reaching the boundary.</li>
<li>Next, move to the left until reaching the boundary.</li>
<li>Finally, move upwards until reaching the boundary.</li>
<li>Repeat these steps until all elements are placed in the matrix.</li>
</ul>
<p>The movement pattern repeats in the order of right, down, left, and up. We can store these directional movements in an array. For example, moving right corresponds to <code>(x+0, y+1)</code> and moving down to <code>(x+1, y+0)</code>. We simulate the process by following each direction until we reach the matrix boundary, then switch to the next direction, continuing until all nodes in the linked list are used.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Set <code>i</code> (row index) to 0, <code>j</code> (column index) to 0, and <code>cur_d</code> (current direction) to 0.</li>
<li>Define a <code>movement</code> matrix that stores the directions for east, south, west, and north movements:
<ul>
<li><code>East: (0, 1)</code></li>
<li><code>South: (1, 0)</code></li>
<li><code>West: (0, -1)</code></li>
<li><code>North: (-1, 0)</code></li>
</ul>
</li>
<li>Initialize a 2D matrix <code>res</code> with dimensions <code>m x n</code>, filled with -1.</li>
<li>Iterate over the linked list until you reach the end (<code>head</code> is not <code>nullptr</code>):
<ul>
<li>Assign the current node's value <code>head-&gt;val</code> to the matrix at position <code>res[i][j]</code>.</li>
<li>Calculate the next position <code>newi</code> and <code>newj</code> using the current direction from the movement matrix.</li>
<li>If the next position <code>newi, newj</code> is out of the matrix bounds (less than 0 or greater than/equal to m or n), or is already filled (<code>res[newi][newj]</code> is not -1):
<ul>
<li>Then, change the direction by incrementing <code>cur_d</code> (<code>modulus 4</code> to keep within the bounds of the direction matrix).</li>
</ul>
</li>
<li>Update the current position <code>i, j</code> using the updated direction.</li>
</ul>
</li>
<li>Once the linked list is fully traversed and the matrix is filled, return the resulting matrix <code>res</code>.</li>
</ol>
<p>!?!../Documents/2326/slideshow.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/o2rpHqJ2/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(k\)</span> be the size of the linked list with the first node <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>We start by creating a matrix of size <code>n * m</code> and fill it with <code>-1</code>, which takes <span class="math inline">\(O(n \cdot m)\)</span> time. After that, we loop through the linked list once. In the worst case, the list has <code>k</code> nodes, which can go up to <code>n * m</code>. So, the overall time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No additional space is used proportional to the list size <code>k</code>. Therefore, the space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-linked-list-in-parts/description" target="_blank" rel="noopener noreferrer">Split Linked List in Parts</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list and an integer <code>k</code>, split the linked list into <code>k</code> consecutive linked list parts.</p>

<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.</p>

<p>The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.</p>

<p>Return <em>an array of the </em><code>k</code><em> parts</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg" style="width: 400px; height: 134px;" />
<pre>
<strong>Input:</strong> head = [1,2,3], k = 5
<strong>Output:</strong> [[1],[2],[3],[],[]]
<strong>Explanation:</strong>
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but its string representation as a ListNode is [].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg" style="width: 600px; height: 60px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5,6,7,8,9,10], k = 3
<strong>Output:</strong> [[1,2,3,4],[5,6,7],[8,9,10]]
<strong>Explanation:</strong>
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a linked list <code>head</code> and an integer <code>k</code>. We want to split <code>head</code> evenly into <code>k</code> equally sized parts and return an array of the <code>k</code> parts. If <code>head</code> cannot be split evenly, the sizes of the <code>k</code> parts can differ by at most 1, with the larger parts appearing before the smaller ones.</p>
<h3 id="approach-1-create-new-parts">Approach 1: Create New Parts</h3>
<h3 id="intuition">Intuition</h3>
<p>We can split the linked list into <code>k</code> parts by considering two scenarios: when the list can be split evenly and when it cannot.</p>
<ul>
<li><strong>Even Split</strong>: If the list's size <code>size</code> is divisible by <code>k</code>, each part will have exactly <code>size / k</code> nodes.</li>
<li><strong>Uneven Split</strong>: If <code>size</code> is not divisible by <code>k</code>, a remainder of <code>size % k</code> nodes will remain after dividing <code>size / k</code> nodes among the parts. To handle this, we add one extra node to the first <code>size % k</code> parts, making their size <code>size / k + 1</code>. The rest of the parts will have <code>size / k</code> nodes.</li>
</ul>
<p>In short, each part will have at least <code>size / k</code> nodes. If the list doesn't split evenly, the first <code>size % k</code> parts will have one extra node.</p>
<p>To create these parts, we determine each part's size <code>currentSize</code>, then use a pointer to traverse the list. We visit the next <code>currentSize</code> nodes for each part and build a new linked list. Once the nodes for that part are processed, we assign the new list to the corresponding element in our array. We repeat this process for all <code>k</code> parts.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>Initialize <code>ans</code> array to store the <code>k</code> parts.</li>
<li>Initialize <code>size = 0</code> and pointer <code>current = head</code>.</li>
<li>Iterate through <code>head</code> via <code>current</code> and increment <code>size</code> at each step to find the total size of <code>head</code>.</li>
<li>Now that <code>size</code> has the total size of the linked list, we can calculate the minimum size for the <code>k</code> parts: <code>splitSize = size / k</code>.</li>
<li>We can also calculate how many remaining nodes we have: <code>numRemainingParts = size % k</code>.</li>
<li>Reset <code>current</code> back to <code>head</code> so we can iterate through the linked list again to create our <code>k</code> parts.</li>
<li>For <code>i</code> where <code>0 &lt; i &lt; k</code>:
<ul>
<li>Initialize the head of the new part <code>newPart</code> to a dummy node and initialize a new pointer <code>tail</code> to keep track of the end of <code>newPart</code> for efficient appending</li>
<li>Calculate the current size <code>currentSize</code> of the current part:
<ul>
<li>Initialize <code>currentSize = splitSize</code></li>
<li>If there are any remaining parts (<code>numRemainingParts &gt; 0</code>), then increment <code>currentSize</code> and decrement <code>numRemainingParts</code> to assign the remaining nodes to the first <code>size % k</code> parts</li>
</ul>
</li>
<li>Initialize a counter <code>j = 0</code>.</li>
<li>While <code>j &lt; currentSize</code>:
<ul>
<li>Copy the current node and append it to <code>newPart</code> by performing <code>tail.next = new ListNode(current.val)</code>.</li>
<li>Advance <code>tail</code> since a new node just got added to the end</li>
<li>Advance <code>current</code> to move on to the next node</li>
<li>Increment <code>j</code></li>
</ul>
</li>
<li>Now that <code>newPart</code> is fully built, we can assign it in our array: <code>ans[i] = newPart.next</code></li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/S29dXQKK/shared">code</a></p>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the size of the linked list <code>head.</code></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We traverse the entire linked list <code>head</code> twice, where each time takes <span class="math inline">\(O(N)\)</span> time. Thus, the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>There are <span class="math inline">\(N\)</span> new nodes created. This results in a space complexity of <span class="math inline">\(O(N)\)</span>. We ignore the <span class="math inline">\(O(K)\)</span> space needed for <code>ans</code> since the array is required for the question.</p>
</li>
</ul>
<h3 id="approach-2-modify-linked-list">Approach 2: Modify Linked List</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In the previous approach, we required extra space because we created new nodes for the <code>k</code> parts, resulting in a space complexity of <span class="math inline">\(O(N)\)</span>. In our second approach, we can modify the input linked list <code>head</code> to form the <code>k</code> parts directly, eliminating the need for extra space and reducing the space complexity to <span class="math inline">\(O(1)\)</span>.</p>
<p>As before, we iterate through the linked list, processing the next <code>currentSize</code> nodes for each part. However, this time, when we reach the last node of a part, we set its <code>next</code> field to <code>null</code>, effectively dividing the linked list in place without creating new nodes.</p>
<blockquote>
<p>Before presenting this approach to the interviewer, check if modifications are allowed. Some interviewers permit changes, while others do not.</p>
</blockquote>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>Repeat steps 1-6 from Approach 1 to calculate the total size of the linked list, as well as the minimum size of the <code>k</code> parts and the number of remainder nodes.</li>
<li>Initialize a pointer <code>prev = current</code> to keep track of the node preceding <code>current</code></li>
<li>For <code>i</code> where <code>0 &lt; i &lt; k</code>:
<ul>
<li>Initialize <code>newPart</code> to <code>current</code>, which will be the head of part <code>i</code>.</li>
<li>Calculate the current size <code>currentSize</code> of the current part using the same logic in Approach 1</li>
<li>Initialize a counter <code>j = 0</code>.</li>
<li>While <code>j &lt; currentSize</code>:
<ul>
<li>Update <code>prev</code> to <code>current</code></li>
<li>Advance <code>current</code> to next node</li>
<li>Increment <code>j</code></li>
</ul>
</li>
<li>Now, <code>prev</code> is pointing to the last node of part <code>i</code>, and <code>current</code> is pointing to the head of part <code>i+1</code>. To cut off the rest of the linked list for part <code>i</code>, we reassign <code>prev.next</code> to null.</li>
<li>Set <code>ans[i] = newPart</code>.</li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/69vsAB8a/shared">code</a></p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the size of the linked list <code>head.</code></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p><code>head</code> is traversed twice, which takes <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>In contrast to Approach 1, no new nodes are created and the input is modified to create <code>k</code> parts. Thus, the space complexity is a constant <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/implement-stack-using-linked-list/1" target="_blank" rel="noopener noreferrer">Stack using Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Let's give it a try! You have a linked list and must implement the functionalities push and pop of stack using this given linked list. Your task is to use the class as shown in the comments in the code editor and complete the functions push() and pop() to implement a stack.&nbsp;<br /></span><span style="font-size: 18px;">The push() method takes one argument, an integer&nbsp;</span><strong style="font-size: 18px;">'x'</strong><span style="font-size: 18px;">&nbsp;to be pushed into the stack and&nbsp;</span><strong style="font-size: 18px;">pop()</strong><span style="font-size: 18px;">&nbsp;which returns an integer present at the top and popped out from the stack. If the stack is empty then return&nbsp;</span><strong style="font-size: 18px;">-1</strong><span style="font-size: 18px;">&nbsp;from the pop() method.<br /></span><strong><span style="font-size: 18px;">Note:&nbsp;</span></strong><span style="font-size: 18px;">The input is given in the form of queries. Since there are two operations push() and pop(), there is two types of queries as described below:<br /></span><span style="font-size: 18px;">(i) 1&nbsp;&nbsp; (a query of this type takes <strong>x</strong> as another parameter and pushes it into the stack)<br /></span><span style="font-size: 18px;">(ii) 2&nbsp; (a query of this type means to pop an element from the stack and return the popped element)<br /></span><span style="font-size: 18px;">Input is separated by space and as described above.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples </strong>:</span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: [[1,2], [1,3], [2], [1,4], [2]]
<strong>Output</strong>: [3, 4]
<strong>Explanation</strong>: 
push(2)  : the stack will be {2}
push(3)  : the stack will be {2 3}
pop()    : poped element will be 3,the stack will be {2}
push(4)  : the stack will be {2 4}
pop()    : poped element will be 4</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: [[2], [1,4], [1,5], [2]]
<strong>Output</strong>: [-1, 4]</span><br /><span style="font-size: 18px;"><strong>Explanation</strong>: 
pop()    : the stack is empty so its -1.
push(4)  : the stack will be {4}
push(5)  : the stack will be {4 5}
pop()    : poped element will be 5, the stack will be {4}</span></pre>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;"><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>: O(1)</span><br /><span style="font-size: 18px;"><strong>Expected Auxillary Space:</strong>&nbsp;O(1)</span></p>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;"><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= numbers of calls made to push, pop &lt;= 100<br />1 &lt;= x &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/steps-to-make-array-non-decreasing/description" target="_blank" rel="noopener noreferrer">Steps to Make Array Non-decreasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked list</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one step, <strong>remove</strong> all elements <code>nums[i]</code> where <code>nums[i - 1] &gt; nums[i]</code> for all <code>0 &lt; i &lt; nums.length</code>.</p>

<p>Return <em>the number of steps performed until </em><code>nums</code><em> becomes a <strong>non-decreasing</strong> array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,4,4,7,3,6,11,8,5,11]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The following are the steps performed:
- Step 1: [5,<strong><u>3</u></strong>,4,4,7,<u><strong>3</strong></u>,6,11,<u><strong>8</strong></u>,<u><strong>5</strong></u>,11] becomes [5,4,4,7,6,11,11]
- Step 2: [5,<u><strong>4</strong></u>,4,7,<u><strong>6</strong></u>,11,11] becomes [5,4,7,11,11]
- Step 3: [5,<u><strong>4</strong></u>,7,11,11] becomes [5,7,11,11]
[5,7,11,11] is a non-decreasing array. Therefore, we return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,7,7,13]
<strong>Output:</strong> 0
<strong>Explanation:</strong> nums is already a non-decreasing array. Therefore, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/subtraction-in-linked-list/1" target="_blank" rel="noopener noreferrer">Subtraction in Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given two <strong>linked lists</strong>&nbsp;representing two <strong>large positive numbers</strong>. The linked lists represent these two numbers, <strong>subtract </strong>the smaller number from the larger one and <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">return the head&nbsp;</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">of the&nbsp;linked list</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">&nbsp;</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">representing the result</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. Please take a look at the examples to get a better understanding of the task.<br /></span></span></p>
<p><span style="font-size: 18.6667px;">The linked list does not contain leading zeros, except for the number zero itself.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList1: 1-&gt;0-&gt;0, LinkedList2: 1-&gt;2<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Output:  </strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">LinkedList: 8-&gt;8<br /></span><strong>Explanation: </strong>First linked list represents 100 and the second one represents 12. 12 subtracted from 100 gives us 88 as the result. It is represented as 8-&gt;8 in the linked list.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700313/Web/Other/blobid1_1735211009.png" width="300" height="193" /><br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList1: 6-&gt;3, LinkedList2: 7-&gt;1-&gt;0<br /><strong>Output: </strong>LinkedList: 6-&gt;4-&gt;7<br /><strong>Explanation: </strong>First linked list represents 63 and the second one represents 710. 63 subtracted from 710 gives us 647 as the result. It is represented as 6-&gt;4-&gt;7 in the linked list.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700313/Web/Other/blobid2_1735211034.png" width="299" height="193" /><br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= size of both linked lists &lt;= 10<sup>6</sup><br />0 &lt;= node-&gt;data &lt;= 9<sup><br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swap-nodes-in-pairs/description" target="_blank" rel="noopener noreferrer">Swap Nodes in Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">head = [1,2,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,1,4,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" style="width: 422px; height: 222px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">head = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">head = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">head = [1,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,1,3]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the&nbsp;list&nbsp;is in the range <code>[0, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swapping-nodes-in-a-linked-list/description" target="_blank" rel="noopener noreferrer">Swapping Nodes in a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list, and an integer <code>k</code>.</p>

<p>Return <em>the head of the linked list after <strong>swapping</strong> the values of the </em><code>k<sup>th</sup></code> <em>node from the beginning and the </em><code>k<sup>th</sup></code> <em>node from the end (the list is <strong>1-indexed</strong>).</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/linked1.jpg" style="width: 400px; height: 112px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], k = 2
<strong>Output:</strong> [1,4,3,2,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [7,9,6,6,7,8,3,0,9,5], k = 5
<strong>Output:</strong> [7,9,6,6,8,7,3,0,9,5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/union-of-two-linked-list/1" target="_blank" rel="noopener noreferrer">Union of Two Linked Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">linked list</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 12pt;">Given two linked lists (L1 &amp; L2), your task is to complete the function <strong>makeUnion(),&nbsp;</strong>which returns the union list of two linked lists. This union list should include all the <strong>distinct </strong>elements only and it should be sorted in <strong>ascending </strong>order.</span></p>
<p><span style="font-size: 12pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>L1 = 9-&gt;6-&gt;4-&gt;2-&gt;3-&gt;8, L2 = 1-&gt;2-&gt;8-&gt;6-&gt;2
<strong>Output: </strong>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 9<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700534/Web/Other/blobid0_1723400421.png" width="371" height="175" /><br /><strong>Explanation:</strong> All the distinct numbers from two lists, when sorted form the list in the output. </span></pre>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>L1 = 1-&gt;5-&gt;1-&gt;2-&gt;2-&gt;5, L2 = 4-&gt;5-&gt;6-&gt;7-&gt;1
<strong>Output: </strong>1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700534/Web/Other/blobid2_1723400444.png" width="364" height="172" /><br /><strong>Explaination:</strong> All the distinct numbers from two lists, when sorted forms the list in the output.</span></pre>
<p><span style="font-size: 12pt;"><strong>Expected Time Complexity:</strong> O((n+m)*Log(n+m))<br /><strong>Expected Space&nbsp;</strong></span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: 16px;">Complexity</strong><strong style="font-size: 12pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">:</strong><span style="font-size: 12pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> O(n+m)</span></p>
<p><span style="font-size: 12pt;"><strong>Constraints:</strong><br />1&lt;=size of both linked lists&lt;=10<sup>5<br /></sup>1&lt;= data of nodes&lt;=10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>