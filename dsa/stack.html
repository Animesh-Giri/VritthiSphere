<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>stack - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>stack</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">240</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> June 26, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">132 Geeky Buildings</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-1" class="toc-link">132 Pattern</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Add Two Numbers II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">A Game of Numbers</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-4" class="toc-link">Alice&#39;s library</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-5" class="toc-link">Apply Operations to Maximize Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Array Formation &lt;Liv.ai&gt;</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-7" class="toc-link">Asteroid Collision</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Asteroid Collision</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-9" class="toc-link">A Weird Game</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-10" class="toc-link">Backspace String Compare</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Baseball Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Basic Calculator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Basic Calculator II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Basic Calculator IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Beautiful Towers I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Beautiful Towers II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Binary Search Tree Iterator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Binary Tree Inorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Binary Tree Postorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Binary Tree Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Brace Expansion II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Build an Array With Stack Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Car Fleet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Car Fleet II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Check if a Parentheses String Can Be Valid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Check If Word Is Valid After Substitutions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Check Mirror in N-ary tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-28" class="toc-link">Clear Digits</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Clone a stack without using extra space</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-30" class="toc-link">Clumsy Factorial</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Construct Binary Search Tree from Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Construct Smallest Number From DI String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Count Collisions on a Road</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Count Non-Decreasing Subarrays After K Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Count Submatrices With All Ones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Count the Reversals</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-37" class="toc-link">Crawler Log Folder</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Create Maximum Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Daily Temperatures</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Decoded String at Index</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Decode String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Decode the string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-43" class="toc-link">Delete Array Elements</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-44" class="toc-link">Delete Mid of a Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-45" class="toc-link">Design a Stack With Increment Operation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Design a Text Editor</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Design Browser History</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Design Browser History</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-49" class="toc-link">Design Twitter</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-50" class="toc-link">Dinner Plate Stacks</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Double a Number Represented as a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Easy string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-53" class="toc-link">Evaluate Reverse Polish Notation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Exclusive Time of Functions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Expression contains redundant bracket or not</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-56" class="toc-link">Final Prices With a Special Discount in a Shop</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Find Building Where Alice and Bob Can Meet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Find Maximum Non-decreasing Array Length</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Find Mirror Score of a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Find the Most Competitive Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Find the Number of Subarrays Where Boundary Elements Are Maximum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Flatten Binary Tree to Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Flatten Nested List Iterator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Fun Game &lt;Capillary&gt;</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-65" class="toc-link">Geek and Number String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-66" class="toc-link">Geeks And The String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-67" class="toc-link">Get min at pop</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-68" class="toc-link">Get Min from Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-69" class="toc-link">Greater tower sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-70" class="toc-link">Help Classmates</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-71" class="toc-link">Histogram Max Rectangular Area</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-72" class="toc-link">Immediate Smaller Element</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-73" class="toc-link">Implement Queue using Stacks</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Implement stack using array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-75" class="toc-link">Implement Stack using Queues</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Increasing Order Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Indent Ruby</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-78" class="toc-link">Infix to Postfix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-79" class="toc-link">Insert an Element at the Bottom of a Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-80" class="toc-link">Interleave the First Half of the Queue with Second Half</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-81" class="toc-link">IPL 2021 - Final</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-82" class="toc-link">IPL 2021 - Match Day 6 - Semi Final</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-83" class="toc-link">Iterative Inorder</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-84" class="toc-link">Iterative Postorder</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-85" class="toc-link">Jumpy Humpy</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-86" class="toc-link">Largest Rectangle in Histogram</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Level Order in spiral form</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-88" class="toc-link">Lexicographically Largest String After K Deletions</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-89" class="toc-link">Lexicographically Minimum String After Removing Stars</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Lexicographically smallest string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-91" class="toc-link">Little Shino and Pairs</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-92" class="toc-link">Longest Absolute File Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Longest valid Parentheses</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-94" class="toc-link">Longest Valid Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Longest Well-Performing Interval</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-96" class="toc-link">Make Array Non-decreasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-97" class="toc-link">Make the array beautiful</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-98" class="toc-link">Make The String Great</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Mancunian And Fantabulous Pairs</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-100" class="toc-link">Max Chunks To Make Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Max Chunks To Make Sorted II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Max Equal sum of 3 Stacks</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-103" class="toc-link">Maximal Rectangle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Maximum and Minimum Sums of at Most Size K Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">Maximum Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Maximum Difference</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-107" class="toc-link">Maximum Elegance of a K-Length Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Maximum Frequency Stack</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Maximum Nesting Depth of the Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Maximum Nesting Depth of Two Valid Parentheses Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Maximum Score From Removing Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Maximum Score of a Good Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Maximum Subarray Min-Product</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Maximum Sum Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Maximum Twin Sum of a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Maximum Width Ramp</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Max of min for every window size</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-118" class="toc-link">Max  rectangle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-119" class="toc-link">Max Score from Subarray Mins</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-120" class="toc-link">Minimum Additions to Make Valid String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Minimum Add to Make Parentheses Valid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-122" class="toc-link">Minimum Cost to Change the Final Value of Expression</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Minimum Cost Tree From Leaf Values</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Minimum Deletions to Make Array Beautiful</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Minimum Deletions to Make String Balanced</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Minimum Insertions to Balance a Parentheses String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-127" class="toc-link">Minimum Number of Increments on Subarrays to Form a Target Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Minimum Number of Swaps to Make the String Balanced</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-129" class="toc-link">Minimum Number of Visited Cells in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Minimum Operations to Convert All Elements to Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Minimum Operations to Make Array Equal to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Minimum Remove to Make Valid Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Minimum String Length After Removing Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Minimum Time to Complete All Tasks</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Mini Parser</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Min Stack</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">N-ary Tree Postorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-138" class="toc-link">N-ary Tree Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-139" class="toc-link">Nearest smaller tower</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-140" class="toc-link">Next element with greater frequency</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-141" class="toc-link">Next Greater Element</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-142" class="toc-link">Next Greater Element I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-143" class="toc-link">Next Greater Element II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-144" class="toc-link">Next Greater Element in Circular Array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-145" class="toc-link">Next Greater Element IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-146" class="toc-link">Next Greater Node In Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-147" class="toc-link">Number of Atoms</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Number of Students Unable to Eat Lunch</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-149" class="toc-link">Number of Visible People in a Queue</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-150" class="toc-link">Odd Even Jump</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-151" class="toc-link">Online Stock Span</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-152" class="toc-link">Operations on Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-153" class="toc-link">Pairwise Consecutive Elements</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-154" class="toc-link">Palindrome Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-155" class="toc-link">Parenthesis Checker</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-156" class="toc-link">Parse Lisp Expression</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-157" class="toc-link">Parsing A Boolean Expression</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-158" class="toc-link">Postfix Evaluation</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-159" class="toc-link">Preorder to BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-160" class="toc-link">Preorder Traversal</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-161" class="toc-link">Preorder traversal (Iterative)</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-162" class="toc-link">Print Bracket Number</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-163" class="toc-link">Print leaf nodes from preorder traversal of BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-164" class="toc-link">Queue Reversal</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-165" class="toc-link">Queue using stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-166" class="toc-link">Queue using two Stacks</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-167" class="toc-link">Redundant Parenthesis</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-168" class="toc-link">Remove All Adjacent Duplicates In String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-169" class="toc-link">Remove All Adjacent Duplicates in String II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-170" class="toc-link">Remove All Occurrences of a Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-171" class="toc-link">Remove Duplicate Letters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-172" class="toc-link">Remove Friends</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-173" class="toc-link">Remove K Digits</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-174" class="toc-link">Remove K Digits</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-175" class="toc-link">Remove Nodes From Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-176" class="toc-link">Remove Outermost Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-177" class="toc-link">Remove the balls</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-178" class="toc-link">Removing consecutive duplicates - 2</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-179" class="toc-link">Removing Consecutive Elements</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-180" class="toc-link">Removing Stars From a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-181" class="toc-link">Reorder List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-182" class="toc-link">Replace Non-Coprime Numbers in Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-183" class="toc-link">Restrictive Candy Crush</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-184" class="toc-link">Resulting String After Adjacent Removals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-185" class="toc-link">Reverse Array Using Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-186" class="toc-link">Reverse a Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-187" class="toc-link">Reverse each word in a given string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-188" class="toc-link">Reverse first K of a Queue</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-189" class="toc-link">Reverse First K of Queue</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-190" class="toc-link">Reverse Prefix of Word</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-191" class="toc-link">Reverse Substrings Between Each Pair of Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-192" class="toc-link">Reverse Using Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-193" class="toc-link">Reversing the equation</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-194" class="toc-link">Robot Collisions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-195" class="toc-link">Score of Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-196" class="toc-link">Secret Cipher</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-197" class="toc-link">Shopkeeper Profit</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-198" class="toc-link">Shortest Subarray to be Removed to Make Array Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-199" class="toc-link">Shortest Unsorted Continuous Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-200" class="toc-link">Simplify Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-201" class="toc-link">Smaller on Left</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-202" class="toc-link">Smallest K-Length Subsequence With Occurrences of a Letter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-203" class="toc-link">Smallest Subsequence of Distinct Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-204" class="toc-link">Sort a stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-205" class="toc-link">Special Stack</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-206" class="toc-link">Stack and Queue &lt;Nissan&gt;</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-207" class="toc-link">Stack designer</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-208" class="toc-link">Stack operations</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-209" class="toc-link">Stack Operations</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-210" class="toc-link">Stack Permutations</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-211" class="toc-link">Stack using Linked List</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-212" class="toc-link">Stack using two queues</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-213" class="toc-link">Stamping The Sequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-214" class="toc-link">Steps to Make Array Non-decreasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-215" class="toc-link">Stock span problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-216" class="toc-link">String Manipulation</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-217" class="toc-link">String rp or pr</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-218" class="toc-link">Subarray With Elements Greater Than Varying Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-219" class="toc-link">Sum of Max of Subarrays</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-220" class="toc-link">Sum of subarray minimum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-221" class="toc-link">Sum of Subarray Minimums</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-222" class="toc-link">Sum of subarray ranges</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-223" class="toc-link">Sum of Subarray Ranges</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-224" class="toc-link">Sum of Total Strength of Wizards</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-225" class="toc-link">Tag Validator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-226" class="toc-link">The Celebrity Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-227" class="toc-link">The Number of Weak Characters in the Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-228" class="toc-link">The Score of Students Solving Math Expression</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-229" class="toc-link">Thief and Warehouses</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-230" class="toc-link">Trapping Rain Water</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-231" class="toc-link">Trapping Rain Water</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-232" class="toc-link">Two Stacks in an Array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-233" class="toc-link">Using a Robot to Print the Lexicographically Smallest String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-234" class="toc-link">Validate Stack Sequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-235" class="toc-link">Valid Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-236" class="toc-link">Valid Parenthesis String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-237" class="toc-link">Valid Substring</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-238" class="toc-link">Verify Preorder Serialization of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-239" class="toc-link">Zuma Game</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/132-geeky-buildings--141631/1" target="_blank" rel="noopener noreferrer">132 Geeky Buildings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">There are <strong>N</strong> buildings in Linear Land. They appear in a linear line one after the other and their heights are given in the array <strong>arr[]</strong>. Geek wants to select <strong>three</strong> buildings in Linear Land and remodel them as recreational spots. The third of the selected building must be taller than the first and shorter than the second.<br />
Can geek build the three-building recreational zone?&nbsp;</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 6
arr[] = {4, 7, 11, 5, 13, 2}
<strong>Output:</strong>
True
<strong>Explanation:
</strong>[4, 7, 5] fits the condition. </span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 4
arr[] = {11, 11, 12, 9}
<strong>Output:</strong>
False
<strong>Explanation:</strong>
No 3 buildings fit the given condition. </span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>recreationalSpot()</strong> which takes the array arr[] and its size N as input parameters and returns a boolean value based on whether his building selection was successful or not.<br />
<strong>Note:</strong> The generated output will be &quot;True&quot; or &quot;False&quot;.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<sup>4</sup><br />
1 &le; arr[i] &le; 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/132-pattern/description" target="_blank" rel="noopener noreferrer">132 Pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">ordered-set</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>

<p>Return <code>true</code><em> if there is a <strong>132 pattern</strong> in </em><code>nums</code><em>, otherwise, return </em><code>false</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no 132 pattern in the sequence.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,4,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a 132 pattern in the sequence: [1, 4, 2].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,3,2,0]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p>The simplest solution is to consider every triplet <span class="math inline">\((i, j, k)\)</span> and check if the corresponding numbers satisfy the 132 criteria. If any such triplet is found, we can return a True value. If no such triplet is found, we need to return a False value.</p>
<p><a href="https://leetcode.com/playground/hGnnTJMn/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^3)\)</span>. Three loops are used to consider every possible triplet. Here, <span class="math inline">\(n\)</span> refers to the size of <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant extra space is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force">Approach 2: Better Brute Force</h3>
<p><strong>Algorithm</strong></p>
<p>We can improve the last approach to some extent, if we make use of some observations. We can note that for a particular number <span class="math inline">\(nums[j]\)</span> chosen as 2nd element in the 132 pattern, if we don't consider <span class="math inline">\(nums[k]\)</span>(the 3rd element) for the time being, our job is to find out the first element, <span class="math inline">\(nums[i]$$(\)</span>i&lt;j<span class="math inline">\() which is lesser than \)</span>nums[j]$$.</p>
<p>Now, assume that we have somehow found a <span class="math inline">\(nums[i],nums[j]\)</span> pair. Our task now reduces to finding out a <span class="math inline">\(nums[k]$$(\)</span>Kk&gt;j&gt;i)<span class="math inline">\(, which falls in the range \)</span>(nums[i], nums[j])<span class="math inline">\(. Now, to maximize the likelihood of a \)</span>nums[k]$$ falling in this range, we need to increase this range as much as possible.</p>
<p>Since, we started off by fixing a <span class="math inline">\(nums[j]\)</span>, the only option in our hand is to choose a minimum value of <span class="math inline">\(nums[i]\)</span> given a particular <span class="math inline">\(nums[j]\)</span>. Once, this pair <span class="math inline">\(nums[i],nums[j]\)</span>, has been found out, we simply need to traverse beyond the index <span class="math inline">\(j\)</span> to find if a <span class="math inline">\(nums[k]\)</span> exists for this pair satisfying the 132 criteria.</p>
<p>Based on the above observations, while traversing over the <span class="math inline">\(nums\)</span> array choosing various values of <span class="math inline">\(nums[j]\)</span>, we simultaneously keep a track of the minimum element found so far(excluding <span class="math inline">\(nums[j]\)</span>). This minimum element always serves as the <span class="math inline">\(nums[i]\)</span> for the current <span class="math inline">\(nums[j]\)</span>. Thus, we only need to traverse beyond the <span class="math inline">\(j^{th}\)</span> index to check the <span class="math inline">\(nums[k]\)</span>'s to determine if any of them satisfies the 132 criteria.</p>
<p><a href="https://leetcode.com/playground/4Mv4ZmY8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. Two loops are used to find the <span class="math inline">\(nums[j],nums[k]\)</span> pairs. Here, <span class="math inline">\(n\)</span> refers to the size of <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant extra space is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-3-searching-intervals">Approach 3: Searching Intervals</h3>
<p><strong>Algorithm</strong></p>
<p>As discussed in the last approach, once we've fixed a <span class="math inline">\(nums[i],nums[j]\)</span> pair, we just need to determine a <span class="math inline">\(nums[k]\)</span> which falls in the range <span class="math inline">\((nums[i],nums[j])\)</span>. Further, to maximize the likelihood of any arbitrary <span class="math inline">\(nums[k]\)</span> falling in this range, we need to try to keep this range as much as possible. But, in the last approach, we tried to work only on <span class="math inline">\(nums[i]\)</span>. But, it'll be a better choice, if we can somehow work out on <span class="math inline">\(nums[j]\)</span> as well.</p>
<p>To do so, we can look at the given <span class="math inline">\(nums\)</span> array in the form of a graph, as shown below:</p>
<p><img src="../Figures/456/456_132_Pattern.PNG" alt="Graph" /></p>
<p>From the above graph, which consists of rising and falling slopes, we know, the best qualifiers to act as the <span class="math inline">\(nums[i],nums[j]\)</span> pair,  as discussed above, to maximize the range <span class="math inline">\(nums[i], nums[j]\)</span>, at any instant, while traversing the <span class="math inline">\(nums\)</span> array, will be the points at the endpoints of a local rising slope. Thus, once we've found such points, we can traverse over the <span class="math inline">\(nums\)</span> array to find a <span class="math inline">\(nums[k]\)</span> satisfying the given 132 criteria.</p>
<p>To find these points at the ends of a local rising slope, we can traverse over the given <span class="math inline">\(nums\)</span> array. While traversing, we can keep a track of the minimum point found after the last peak(<span class="math inline">\(nums[s]\)</span>).</p>
<p>Now, whenever we encounter a falling slope, say, at index <span class="math inline">\(i\)</span>, we know, that <span class="math inline">\(nums[i-1]\)</span> was the endpoint of the last rising slope found. Thus, we can scan over the <span class="math inline">\(k\)</span> indices(k&gt;i), to find a 132 pattern.</p>
<p>But, instead of traversing over <span class="math inline">\(nums\)</span> to find a <span class="math inline">\(k\)</span> satisfying the 132 pattern for every such rising slope, we can store this range <span class="math inline">\((nums[s], nums[i-1])\)</span>(acting as <span class="math inline">\((nums[i], nums[j])\)</span>) in, say an <span class="math inline">\(intervals\)</span> array.</p>
<p>While traversing over the <span class="math inline">\(nums\)</span> array to check the rising/falling slopes, whenever we find any rising slope, we can keep adding the endpoint pairs to this <span class="math inline">\(intervals\)</span> array. At the same time, we can also check if the current element falls in any of the ranges found so far. If so, this element satisfies the 132 criteria for that range.</p>
<p>If no such element is found till the end, we need to return a False value.</p>
<p><a href="https://leetcode.com/playground/Zy6HRCyV/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. We traverse over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to find the slopes. But for every element, we also need to traverse over the <span class="math inline">\(intervals\)</span> to check if any element falls in any range found so far. This array can contain at most <span class="math inline">\((n/2)\)</span> pairs, in the case of an alternate increasing-decreasing sequence(worst case e.g.<code>[5 6 4 7 3 8 2 9]</code>).</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(intervals\)</span> array can contain at most <span class="math inline">\(n/2\)</span> pairs, in the worst case(alternate increasing-decreasing sequence).<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-4-stack">Approach 4: Stack</h3>
<p><strong>Algorithm</strong></p>
<p>In Approach 2, we found out <span class="math inline">\(nums[i]\)</span> corresponding to a particular <span class="math inline">\(nums[j]\)</span> directly without having to consider every pair possible in <span class="math inline">\(nums\)</span> to find this <span class="math inline">\(nums[i],nums[j]\)</span> pair. If we do some preprocessing, we can make the process of finding a <span class="math inline">\(nums[k]\)</span> corresponding to this <span class="math inline">\(nums[i],nums[j]\)</span> pair also easy.</p>
<p>The preprocessing required is to just find the best <span class="math inline">\(nums[i]\)</span> value corresponding to every <span class="math inline">\(nums[j]\)</span> value. This is done in the same manner as in the second approach i.e. we find the minimum element found till the <span class="math inline">\(j^{th}\)</span> element which acts as the <span class="math inline">\(nums[i]\)</span> for the current <span class="math inline">\(nums[j]\)</span>. We maintain thes values in a <span class="math inline">\(min\)</span> array. Thus, <span class="math inline">\(min[j]\)</span> now refers to the best <span class="math inline">\(nums[i]\)</span> value for a particular <span class="math inline">\(nums[j]\)</span>.</p>
<p>Now, we traverse back from the end of the <span class="math inline">\(nums\)</span> array to find the <span class="math inline">\(nums[k]\)</span>'s. Suppose, we keep a track of the <span class="math inline">\(nums[k]\)</span> values which can potentially satisfy the 132 criteria for the current <span class="math inline">\(nums[j]\)</span>. We know, one of the conditions to be satisfied by such a <span class="math inline">\(nums[k]\)</span> is that it must be greater than <span class="math inline">\(nums[i]\)</span>. Or in other words, we can also say that it must be greater than <span class="math inline">\(min[j]\)</span> for a particular <span class="math inline">\(nums[j]\)</span> chosen.</p>
<p>Once it is ensured that the elements left for competing for the <span class="math inline">\(nums[k]\)</span> are all greater than <span class="math inline">\(min[j]\)</span>(or <span class="math inline">\(nums[i]\)</span>), our only task is to ensure that it should be lesser than <span class="math inline">\(nums[j]\)</span>. Now, the best element from among the competitors, for satisfying this condition will be the minimum one from out of these elements.</p>
<p>If this element, <span class="math inline">\(nums[k]\)</span> satisfies <span class="math inline">\(nums[k] < nums[j]\)</span>, we've found a 132 pattern. If not, no other element will satisfy this criteria, since they are all greater than or equal to <span class="math inline">\(nums[min]\)</span> and thus greater than or equal to <span class="math inline">\(nums[j]\)</span> as well.</p>
<p>To keep a track of these potential <span class="math inline">\(nums[k]\)</span> values for a particular <span class="math inline">\(nums[i],nums[j]\)</span> considered currently, we maintain a <span class="math inline">\(stack\)</span> on which these potential <span class="math inline">\(nums[k]\)</span>'s satisfying the 132 criteria lie in a descending order(minimum element on the top). We need not sort these elements on the <span class="math inline">\(stack\)</span>, but they'll be sorted automatically as we'll discuss along with the process.</p>
<p>After creating a <span class="math inline">\(min\)</span> array, we start traversing the <span class="math inline">\(nums[j]\)</span> array in a backward manner. Let's say, we are currently at the <span class="math inline">\(j^{th}\)</span> element and let's also assume that the <span class="math inline">\(stack\)</span> is sorted right now. Now, firstly, we check if <span class="math inline">\(nums[j] > min[j]\)</span>. If not, we continue with the <span class="math inline">\((j-1)^{th}\)</span> element and the <span class="math inline">\(stack\)</span> remains sorted. If not, we keep on popping the elements from the top of the <span class="math inline">\(stack\)</span> till we find an element, <span class="math inline">\(stack[top]\)</span> such that, <span class="math inline">\(stack[top] > min[j]\)</span>(or <span class="math inline">\(stack[top] > nums[i]\)</span>).</p>
<p>Once the popping is done, we're sure that all the elements pending on the <span class="math inline">\(stack\)</span> are greater than <span class="math inline">\(nums[i]\)</span> and are thus, the potential candidates for <span class="math inline">\(nums[k]\)</span> satisfying the 132 criteria. We can also note that the elements which have been popped from the <span class="math inline">\(stack\)</span>, all satisfy <span class="math inline">\(stack[top] &leq; min[j]\)</span>.</p>
<p>Since, in the <span class="math inline">\(min\)</span> array, <span class="math inline">\(min[p] &leq; min[q]\)</span>, for every <span class="math inline">\(p > q\)</span>, these popped elements also satisfy <span class="math inline">\(stack[top] &leq; min[k]\)</span>, for all <span class="math inline">\(0 &leq; k < j\)</span>. Thus, they are not the potential <span class="math inline">\(nums[k]\)</span> candidates for even the preceding elements. Even after  doing the popping, the <span class="math inline">\(stack\)</span> remains sorted.</p>
<p>After the popping is done, we've got the minimum element from amongst all the potential <span class="math inline">\(nums[k]\)</span>'s on the top of the <span class="math inline">\(stack\)</span>(as per the assumption). We can check if it is less than or equal to <span class="math inline">\(nums[j]\)</span> to satisfy the 132 criteria(we've already checked <span class="math inline">\(stack[top] > nums[i]\)</span>). If this element satisfies the 132 criteria, we can return a True value. If not, we know that for the current <span class="math inline">\(j\)</span>, <span class="math inline">\(nums[j] > min[j]\)</span>. Thus, the element <span class="math inline">\(nums[j]\)</span> could be a potential <span class="math inline">\(nums[k]\)</span> value, for the preceding <span class="math inline">\(nums[i]'s\)</span>.</p>
<p>Thus, we push it over the <span class="math inline">\(stack\)</span>. We can note that, we need to push this element <span class="math inline">\(nums[j]\)</span> on the <span class="math inline">\(stack\)</span> only when it didn't satisfy <span class="math inline">\(stack[top]<nums[j]\)</span>. Thus, <span class="math inline">\(nums[j] &leq; stack[top]\)</span>. Thus, even after pushing this element on the <span class="math inline">\(stack\)</span>, the <span class="math inline">\(stack\)</span> remains sorted. Thus, we've seen by induction, that the <span class="math inline">\(stack\)</span> always remains sorted.</p>
<p>Also, note that in case <span class="math inline">\(nums[j] &leq; min[j]\)</span>, we don't push <span class="math inline">\(nums[j]\)</span> onto the <span class="math inline">\(stack\)</span>. This is because this <span class="math inline">\(nums[j]\)</span> isn't greater than even the minimum element lying towards its left and thus can't act as <span class="math inline">\(nums[k]\)</span> in the future.</p>
<p>If no element is found satisfying the 132 criteria till reaching the first element, we return a False value.</p>
<p>The following animation better illustrates the process.</p>
<p>!?!../Documents/456_132_Pattern.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/kueGKV2B/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We travesre over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to fill the <span class="math inline">\(min\)</span> array. After this, we traverse over <span class="math inline">\(nums\)</span> to find the <span class="math inline">\(nums[k]\)</span>. During this process, we also push and pop the elements on the <span class="math inline">\(stack\)</span>. But, we can note that at most <span class="math inline">\(n\)</span> elements can be pushed and popped off the <span class="math inline">\(stack\)</span> in total. Thus, the second traversal requires only <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The <span class="math inline">\(stack\)</span> can grow upto a maximum depth of <span class="math inline">\(n\)</span>. Furhter, <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-5-binary-search">Approach 5: Binary Search</h3>
<p><strong>Algorithm</strong></p>
<p>In the last approach, we've made use of a separate <span class="math inline">\(stack\)</span> to push and pop the <span class="math inline">\(nums[k]\)</span>'s. But, we can also note that when we reach the index <span class="math inline">\(j\)</span> while scanning backwards for finding <span class="math inline">\(nums[k]\)</span>, the <span class="math inline">\(stack\)</span> can contain at most <span class="math inline">\(n-j-1\)</span> elements. Here, <span class="math inline">\(n\)</span> refers to the number of elements in <span class="math inline">\(nums\)</span> array.</p>
<p>We can also note that this is the same number of elements which lie beyond the <span class="math inline">\(j^{th}\)</span> index in <span class="math inline">\(nums\)</span> array. We also know that these elements lying beyond the <span class="math inline">\(j^{th}\)</span> index won't be needed in the future ever again. Thus, we can make use of this space in <span class="math inline">\(nums\)</span> array instead of using a separate <span class="math inline">\(stack\)</span>. The rest of the process can be carried on in the same manner as discussed in the last approach.</p>
<p>We can try to go for another optimization here. Since, we've got an array for storing the potential <span class="math inline">\(nums[k]\)</span> values now, we need not do the popping process for a <span class="math inline">\(min[j]\)</span> to find an element just larger than <span class="math inline">\(min[j]\)</span> from amongst these potential values.</p>
<p>Instead, we can make use of Binary Search to directly find an element, which is just larger than <span class="math inline">\(min[j]\)</span> in the required interval, if it exists. If such an element is found, we can compare it with <span class="math inline">\(nums[j]\)</span> to check the 132 criteria. Otherwise, we continue the process as in the last approach.</p>
<p><a href="https://leetcode.com/playground/8yeXd5nB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\big(n \log n\big)\)</span>. Filling <span class="math inline">\(min\)</span> array requires <span class="math inline">\(O(n)\)</span> time. The second traversal is done over the whole <span class="math inline">\(nums\)</span> array of length <span class="math inline">\(n\)</span>. For every current <span class="math inline">\(nums[j]\)</span> we need to do the Binary Search, which requires <span class="math inline">\(O\big(\log n\big)\)</span>. In the worst case, this Binary Search will be done for all the <span class="math inline">\(n\)</span> elements, and the required element won't be found in any case, leading to a complexity of <span class="math inline">\(O\big(n \log n\big)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-6-using-array-as-a-stack">Approach 6: Using Array as a Stack</h3>
<p><strong>Algorithm</strong></p>
<p>In the last approach, we've seen that in the worst case, the required element won't be found for all the <span class="math inline">\(n\)</span> elements and thus Binary Search is done at every step increasing the time complexity.</p>
<p>To remove this problem, we can follow the same steps as in Approach 4 i.e. We can remove those elements(update the index <span class="math inline">\(k\)</span>) which aren't greater than <span class="math inline">\(nums[i]$$(\)</span>min[j]<span class="math inline">\(). Thus, in case no element is larger than \)</span>min[j]<span class="math inline">\( the index $$k\)</span> reaches the last element.</p>
<p>Now, at every step, only <span class="math inline">\(nums[j]\)</span> will be added and removed from consideration in the next step, improving the time complexity in the worst case. The rest of the method remains the same as in Approach 4.</p>
<p>This approach is inspired by <a href="https://leetcode.com/fun4leetcode/">@fun4leetcode</a></p>
<p><a href="https://leetcode.com/playground/gN3j3eSo/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We travesre over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to fill the <span class="math inline">\(min\)</span> array. After this, we traverse over <span class="math inline">\(nums\)</span> to find the <span class="math inline">\(nums[k]\)</span>. At most <span class="math inline">\(n\)</span> elements can be put in and out of the <span class="math inline">\(nums\)</span> array in total. Thus, the second traversal requires only <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/add-two-numbers-ii/description" target="_blank" rel="noopener noreferrer">Add Two Numbers II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked-list</span> <span class="topic-badge">math</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg" style="width: 523px; height: 342px;" />
<pre>
<strong>Input:</strong> l1 = [7,2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [7,8,0,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [8,0,7]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> l1 = [0], l2 = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
	<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong>&nbsp;Could you solve it without reversing the input lists?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-reverse-given-linked-lists">Approach 1: Reverse Given Linked Lists</h3>
<h4 id="intuition">Intuition</h4>
<p>We are told that the most significant digit comes first, and that each of their nodes includes a single digit. To do a basic addition of two numbers using a sum of two digits and a carry, we must start with the least significant digits (the lowest place) and work our way up to the most significant digits.</p>
<p>To get the order of digits from the least significant digits to the the most significant digits, we can reverse the given lists so the least significant digits come first.</p>
<p>We can then iterate over the reversed lists to perform the addition of digits at corresponding places similar to the first approach.</p>
<p>Let's understand how to reverse a linked list. This is a classical problem that you can try <a href="https://leetcode.com/problems/reverse-linked-list/">here</a>.</p>
<p>To reverse a linked list, we need three pointers. The first pointer <code>head</code> points to the current node under consideration, <code>temp</code> points to the next node, and <code>prev</code> points to the previous node. This is because while traversing the list, we change the current node's (<code>head</code>) next pointer to point to its previous element (<code>prev</code>). Since a node does not have reference to its previous node, we must store its previous element beforehand. We also need another pointer to store the next node (<code>temp</code>) before changing the reference so we don't lose it after changing <code>head.next</code>.</p>
<p>We start with initializing <code>prev</code> to <code>null</code>. We then loop until <code>head</code> is null, i.e., until we iterate over all the elements. We store <code>head.next</code> in <code>temp</code> to store the next node we will go to. After storing the next node, we reverse <code>next</code> of <code>head</code> to the previous element, i.e., <code>head.next = prev</code>. We then move <code>prev</code> to <code>head</code> as this becomes the previous node for the next node and also move <code>head</code> to <code>temp</code> as this becomes the new node under consideration.</p>
<p>Here's an animation visually showing how the approach works:</p>
<p>!?!../Documents/445/445-slides.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create two linked lists <code>r1</code> and <code>r2</code> to store the reverse of the linked lists <code>l1</code> and <code>l2</code> respectively.</li>
<li>Create two integers <code>totalSum</code> and <code>carry</code> to store the sum and carry of current digits.</li>
<li>Create a new <code>ListNode</code>, <code>ans</code> that will store the sum of current digits.</li>
<li>We will add the two numbers using the reverse list by adding the digits one by one. We continue until we cover all the nodes in <code>r1</code> and <code>r2</code>:
<ul>
<li>If <code>r1</code> is not <code>null</code>, we add <code>r1.val</code> to <code>totalSum</code>.</li>
<li>If <code>r2</code> is not <code>null</code>, we add <code>r2.val</code> to <code>totalSum</code>.</li>
<li>Set <code>ans.val = totalSum % 10</code>.</li>
<li>Store the <code>carry</code> as <code>totalSum / 10</code>.</li>
<li>Create a new <code>ListNode</code>, <code>newNode</code> that will have <code>val</code> as <code>carry</code>. Set <code>next</code> of <code>newNode</code> to <code>ans</code>. Update <code>ans = newNode</code> to use the same variable <code>ans</code> for the next iteration.</li>
<li>Update <code>totalSum = carry</code>.</li>
</ul>
</li>
<li>If <code>carry == 0</code>, it means the <code>newNode</code> that we created in the final iteration of while loop has <code>val = 0</code>. Because we perform <code>ans = newNode</code> at the end of each while loop iteration while loop, to avoid returning a linked list with a head of <code>0</code> (leading zero), we return the next element, i.e., we return <code>ans.next</code>. Otherwise, if <code>carry</code> is not equal to <code>0</code>, the value of <code>ans</code> is non-zero. Hence, we just return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/SxRyzmP8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are is the number of nodes in <code>l1</code> and <code>l2</code> respectively</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Reversing the list <code>l1</code> and <code>l2</code>  take <span class="math inline">\(O(m)\)</span> and <span class="math inline">\(O(n)\)</span> time respectively.</li>
<li>We then iterate over digits of the both lists. We iterate until both the lists are fully traversed. We iterate in the while loop <code>max(m, n)</code> times. We compute <code>totalSum</code>, <code>carry</code> and create a new node in each iteration which takes <span class="math inline">\(O(1)\)</span> time. Hence, the complexity of all the while loop can be written as <span class="math inline">\(O(m + n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>As we have reversed the input linked lists, we will count the space consumed by the reversed lists. The <code>r1</code> linked list takes <span class="math inline">\(O(m)\)</span> space and <code>r2</code> takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>Note: one could argue that because <code>r1</code> and <code>r2</code> are only referencing the input lists and not making copies of them, we are using <span class="math inline">\(O(1)\)</span> space. In most problems, you wouldn't count the input as part of the space complexity because the input doesn't contribute toward the algorithm. In this approach, the input is used heavily by our algorithm in terms of logic, and thus, we are counting it as part of the space complexity.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-stack">Approach 2: Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our task is to do a basic addition of two numbers starting with the least significant digits and working our way up to the most significant digits. In the previous approach, we reversed the linked lists to access the least significant digits first. We can also use <strong>stacks</strong> to access the least significant digits first.</p>
<p>The advantage of using a stack is that when we loop over a given linked list from the first node to the last and push all the digits in the stack, the top of the stack will have the least significant digit and the bottom will contain the most significant digit.</p>
<p>We can add the digits at corresponding places of the linked lists using the two stacks moving from the least to the most significant digits using the stack's <code>pop</code> method.</p>
<p>Here's a brief visual representation explaining the approach:</p>
<p><img src="../Figures/445/445-stack.png" alt="img" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create two integer stacks <code>s1</code> and <code>s2</code> to store the integers of the linked lists <code>l1</code> and <code>l2</code> respectively.</li>
<li>Push all the integers of <code>l1</code> in <code>s1</code> starting from the integer at the first node. The most significant comes first in the list, so it will be stored at the bottom of the stack and the least significant digit will stored at the top.</li>
<li>Similarly, push all the integers of <code>l2</code> in <code>s2</code>.</li>
<li>Create two integers <code>totalSum</code> and <code>carry</code> to store the sum and carry of current digits.</li>
<li>Create a new <code>ListNode</code>, <code>ans</code> that will store the answer.</li>
<li>We will add the two numbers present in the linked list now by adding the digits one by one. We continue until both <code>s1</code> and <code>s2</code> are empty:
<ul>
<li>If <code>s1</code> is not empty, pop the first element from the stack and add it to <code>totalSum</code>.</li>
<li>If <code>s2</code> is not empty, pop the first element from the stack and add it to <code>totalSum</code>.</li>
<li>Set <code>ans.val = totalSum % 10</code>.</li>
<li>Store the <code>carry</code> as <code>totalSum / 10</code>.</li>
<li>Create a new <code>ListNode</code>, <code>newNode</code> that will have <code>val</code> as <code>carry</code>. Set <code>next</code> of <code>newNode</code> to <code>ans</code>. Update <code>ans = newNode</code> to use the same variable <code>ans</code> for the next iteration.</li>
<li>Update <code>totalSum = carry</code>.</li>
</ul>
</li>
<li>If <code>carry == 0</code>, it means the <code>newNode</code> that we created in the final iteration of while loop has <code>val = 0</code>. Because we perform <code>ans = newNode</code> at the end of each while loop, to avoid returning a linked list with a head of <code>0</code> (leading zero), we return the next element, i.e., we return <code>ans.next</code>. Otherwise, if <code>carry</code> is not equal to <code>0</code>, the value of <code>ans</code> is non-zero. Hence, we just return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3xMD2Xjx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are is the number of nodes in <code>l1</code> and <code>l2</code> respectively</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Iterating over both the lists and pushing all the values in the respective stacks take <span class="math inline">\(O(m + n)\)</span> time.</li>
<li>We then iterate over digits of the both lists. We iterate until both the stacks are empty. We iterate in the while loop <code>max(m, n)</code> times. We compute <code>sum</code>, <code>carry</code> and create a new node in each iteration which takes <span class="math inline">\(O(1)\)</span> time. Hence, the complexity of all the while loop can be written as <span class="math inline">\(O(m + n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>The <code>s1</code> stack takes <span class="math inline">\(O(m)\)</span> space and the <code>s2</code> stack takes <span class="math inline">\(O(n)\)</span> space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/a-game-of-numbers-1-5d3a8cb3/" target="_blank" rel="noopener noreferrer">A Game of Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">easy</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <em>A</em> of <em>N</em> integers. Now, two functions <span class="mathjax-latex">\(F(X)\)</span> and <span class="mathjax-latex">\(G(X)\)</span> are defined:</p>
<p><span class="mathjax-latex">\( F(X) \)</span> : This is the smallest number <em>Z</em> such that <span class="mathjax-latex">\( X &lt; Z \le N  \)</span> and <span class="mathjax-latex">\(A[X] &lt; A[Z] \)</span> </p>
<p><span class="mathjax-latex">\( G(X) \)</span> : This is the smallest number <em>Z</em> such that <span class="mathjax-latex">\( X &lt; Z \le N  \)</span> and <span class="mathjax-latex">\(A[X] &gt; A[Z] \)</span>  </p>
<p>Now, you need to find for each index <em>i</em> of this array <span class="mathjax-latex">\(G(F(i))\)</span>, where <span class="mathjax-latex">\( 1 \le i \le N \)</span> . If such a number does not exist, for a particular index <em>i</em>, output <em>1</em> as its answer. If such a number does exist, output <span class="mathjax-latex">\(A[G(F(i))]\)</span> </p>
<p><b>Input</b> :</p>
<p>The first line contains a single integer <em>N</em> denoting the size of array <em>A</em>. Each of the next <em>N</em> lines contains a single integer, where the integer on the <span class="mathjax-latex">\(i^{th}\)</span> line denotes <span class="mathjax-latex">\(A[i]\)</span>. </p>
<p><b>Output</b> :</p>
<p>Print <em>N</em> space separated integers on a single line, where the <span class="mathjax-latex">\(i^{th}\)</span> integer denotes <span class="mathjax-latex">\(A[G(F(i))]\)</span> or <em>1</em>, if <span class="mathjax-latex">\(G(F(i))\)</span> does not exist.  </p>
<p><b>Constraints</b>:</p>
<p><span class="mathjax-latex">\(1 \le N \le 30000 \)</span> </p>
<p><span class="mathjax-latex">\( 0 \le A[i] \le 10^{18} \)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Next Greater Â Â Â        Next Smaller<br />
3 --&gt; 7  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  7 --&gt;1<br />
7 --&gt; 8 Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â    8 --&gt;4<br />
1 --&gt; 7 Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â   7 --&gt; 4<br />
7 --&gt; 8 Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â   8 --&gt; 4<br />
8 --&gt; -1Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â   -1 --&gt; -1<br />
4 --&gt; 5 Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â   5 --&gt; 2<br />
5 --&gt; -1Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  -1 --&gt; -1<br />
2 --&gt; -1Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â   -1 --&gt; -1<br /></p></div>
				</div>
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/katrina-and-library-c2ed51f3/" target="_blank" rel="noopener noreferrer">Alice&#39;s library</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">trees</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice is rearranging her library. She takes the innermost shelf and reverses the order of books. She&nbsp;breaks the walls of the shelf. In the end, there will be only books and no shelf walls. Print the order of books.</p>

<p>Opening and closing walls of shelves are shown by '<strong>/</strong>' and '<strong>\</strong>' respectively whereas books are represented by lower case alphabets.</p>

<p><strong>Input format</strong></p>

<p>The first line contains string <span class="mathjax-latex">\(s\)</span> displaying her library.</p>

<p><strong>Output format</strong></p>

<p>Print only one string displaying Alice's library after rearrangement.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(2 \leÂ |s| \leÂ 10^3\)</span></p>

<p><strong>Note</strong></p>

<p>The first character of the string is '<strong>/</strong>' and the last character of the string is '<strong>\</strong>' indicating outermost walls of the shelf.&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>/u/love\i\</p>

<p>Here Katrina breaks the inner most shelf and reverse the order. So the library will beÂ  /uevoli\ .Â </p>

<p>Now she breaks the outermost wall and reverses the order. So the library will be iloveu.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/apply-operations-to-maximize-score/description" target="_blank" rel="noopener noreferrer">Apply Operations to Maximize Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of <code>n</code> positive integers and an integer <code>k</code>.</p>

<p>Initially, you start with a score of <code>1</code>. You have to maximize your score by applying the following operation at most <code>k</code> times:</p>

<ul>
	<li>Choose any <strong>non-empty</strong> subarray <code>nums[l, ..., r]</code> that you haven&#39;t chosen previously.</li>
	<li>Choose an element <code>x</code> of <code>nums[l, ..., r]</code> with the highest <strong>prime score</strong>. If multiple such elements exist, choose the one with the smallest index.</li>
	<li>Multiply your score by <code>x</code>.</li>
</ul>

<p>Here, <code>nums[l, ..., r]</code> denotes the subarray of <code>nums</code> starting at index <code>l</code> and ending at the index <code>r</code>, both ends being inclusive.</p>

<p>The <strong>prime score</strong> of an integer <code>x</code> is equal to the number of distinct prime factors of <code>x</code>. For example, the prime score of <code>300</code> is <code>3</code> since <code>300 = 2 * 2 * 3 * 5 * 5</code>.</p>

<p>Return <em>the <strong>maximum possible score</strong> after applying at most </em><code>k</code><em> operations</em>.</p>

<p>Since the answer may be large, return it modulo <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,3,9,3,8], k = 2
<strong>Output:</strong> 81
<strong>Explanation:</strong> To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [19,12,14,6,10,18], k = 3
<strong>Output:</strong> 4788
<strong>Explanation:</strong> To get a score of 4788, we can apply the following operations: 
- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.
- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.
It can be proven that 4788 is the highest score one can obtain.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10<sup>9</sup>)</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of positive integers <code>nums</code>, a number <code>k</code>, and the ability to perform the following operation at most <code>k</code> times:</p>
<ul>
<li>Select any non-empty subarray that has <strong>not been chosen before</strong>.</li>
<li>Identify the number in this subarray with the highest <em>prime score</em>. The prime score of a number <code>num</code> is defined as the number of distinct prime factors of <code>num</code>. For example, <code>60</code> has a prime score of <code>3</code> because <code>60 = 2 Ã— 2 Ã— 3 Ã— 5</code>, whereas <code>24 = 2 Ã— 2 Ã— 2 Ã— 3</code> has a prime score of <code>2</code>. If the selected subarray contains only <code>60</code> and <code>24</code>, we choose <code>60</code>. If multiple numbers have the same prime score, we select the one that appears first in the subarray.</li>
<li>Multiply the current score by the chosen number. The score starts at <code>1</code>.</li>
</ul>
<p>Our task is to determine the greatest possible score we can achieve by performing the operation at most <code>k</code> times. Since the result may be large, we return it modulo <code>10^9 + 7</code>.</p>
<p>An important observation is that since the array consists of positive integers, multiplying the current score by any of them can only increase or maintain its value. Therefore, it is always optimal to perform all <code>k</code> allowed operations. Notice that the constraint <code>k &lt;= (n + 1) * n / 2</code> ensures that there are always enough unique subarrays to apply the operations on.</p>
<p>Now, consider a variation of the problem where we are not restricted to choosing a previously unselected subarray for each operation. What would be the optimal strategy to maximize our score? Intuitively, we would always select the subarray containing the greatest element, repeating this choice <code>k</code> times. This is valid because, in subarrays of length <code>1</code>, the largest element would have the highest prime score and would always be chosen.</p>
<p>However, in our original problem, we cannot repeatedly select the same subarray. We could start by choosing the subarray containing the maximum element, but what happens next? While there may still be subarrays that include this maximum element, we cannot be certain that it has the highest prime score in each of them.</p>
<hr />
<h3 id="approach-1-monotonic-stack--priority-queue">Approach 1: Monotonic Stack &amp; Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>For convenience, let the element with the highest prime score in a subarray be the &quot;dominant&quot; element of that subarray.</p>
</blockquote>
<p>To address the challenge described above, it is helpful to calculate the number of subarrays each number is dominant in. With this information, we can start with the largest element and apply the operation to all subarrays where it remains dominant. We then repeat this for the second-largest element, and so on, until no further operations can be performed.</p>
<p>First, we need an efficient way to calculate the prime score of a number <code>n</code>. To do this, we iterate over all numbers in the range <code>[2, sqrt(n)]</code>. If we find a number <code>p</code> that divides <code>n</code>, we increment the prime score and remove all occurrences of <code>p</code> in <code>n</code> by repeatedly dividing <code>n</code> by <code>p</code> until it is no longer possible. Notice that we don't need to check if <code>p</code> is prime to increment the prime score because any composite number (e.g., <code>9</code>, <code>15</code>) will have had its smaller prime factors removed earlier and therefore will not divide <code>n</code>. Finally, if <code>n &gt;= 2</code>, <code>n</code> must be prime, so we increment the score once more.</p>
<p>Now, notice that a number remains dominant until another element with a greater prime score appears either to its left or right. To efficiently determine this region, we use a monotonic decreasing stack, which helps identify the nearest elements with a higher prime score on both sides.</p>
<p>To better understand monotonic stacks, you can try solving <a href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element I</a> first. Itâ€™s a great prerequisite for this problem!</p>
<p>A monotonic stack is a data structure that maintains a specific order as elements are inserted. In this case, we need a monotonically decreasing stack based on prime scores, meaning each new element can only be added if it has a lower prime score than the one at the top. If the top element has a greater prime score, we pop it from the stack. When the current element causes another to be popped, it means it is the first element with a higher prime score to the right. Conversely, if we reach an element in the stack with a greater prime score than the current one, that element is the first with a higher prime score to the left.</p>
<p>!?!../Documents/2818/2818_monotonic_decreasing_stack.json:960,540!?!</p>
<p>After finding the indices of the nearest elements with a higher prime score on the left and right, <code>prevDominant[i]</code> and <code>nextDominant[i]</code>, we can compute the number of subarrays in which the <code>i-th</code> element is dominant.</p>
<p>For the left boundary, we have <code>i - prevDominant[i]</code> choices, and for each of them, we have <code>nextDominant[i] - i</code> choices for the right boundary. This gives a total of: <code>(i - prevDominant[i]) * (nextDominant[i] - i)</code> subarrays, where the <code>i-th</code> element is dominant.</p>
<p><img src="../Figures/2818/2818_number_of_subarrays.png" alt="Visual Representation of All Valid Subarrays" /></p>
<p>Finally, we need an efficient way to determine the next element on which we will apply operations across all subarrays where it is dominant. Since we need to process elements in decreasing order to maximize the score, a priority queue (max-heap) is a useful data structure. It allows us to quickly extract the largest element and then remove it to move on to the next one.</p>
<blockquote>
<p>If you need a refresher on heaps, check out the <a href="https://leetcode.com/problem-list/heap-priority-queue/">Heap Explore Card</a> to review their functionality and common patterns.</p>
</blockquote>
<p>To sum up, the algorithm follows these steps:</p>
<ol>
<li>Calculate the prime score for each number in <code>nums</code>.</li>
<li>Use a monotonic stack to determine the <code>prevDominant[i]</code> and <code>nextDominant[i]</code> indices for each <code>nums[i]</code>.</li>
<li>Compute the number of subarrays in which each number is dominant.</li>
<li>Use a priority queue to process the numbers in decreasing order and apply operations to all subarrays where they are dominant.</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of the <code>nums</code> array.</li>
<li>an array, called <code>primeScores</code> of size <code>n</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to calculate the prime scores:
<ul>
<li>Set <code>num</code> to <code>nums[index]</code>.</li>
<li>For each <code>factor</code> in range <code>[2, sqrt(num)]</code>:
<ul>
<li>If <code>factor</code> divides <code>num</code>:
<ul>
<li>Increment <code>primeScores[index]</code> by <code>1</code>.</li>
<li>Remove all occurrences of <code>factor</code> in <code>num</code> by repeatedly dividing by <code>factor</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>num &gt;= 2</code>, <code>num</code> is prime, so increment <code>primeScores[index]</code> one more time.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>two arrays <code>nextDominant</code> and <code>prevDominant</code> to store the indices of the nearest elements with a higher prime score on both sides of each number. Set all elements in <code>nextDominant</code> to <code>n</code> and all values of <code>prevDominant</code> to <code>-1</code>.</li>
<li>an empty stack <code>decreasingPrimeScoreStack</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to fill the <code>nextDominant</code> and <code>prevDominant</code> arrays:
<ul>
<li>While the stack is not empty and the element at index <code>decreasingPrimeScoreStack.top()</code> has a lower prime score than <code>nums[index]</code>:
<ul>
<li>Pop the top element of the stack as <code>topIndex</code>.</li>
<li>Set <code>nextDominant[topIndex]</code> to the current <code>index</code>.</li>
</ul>
</li>
<li>If the stack is not empty, set <code>prevDominant[index]</code> to the index at the top of the stack.</li>
<li>Push <code>index</code> into the stack.</li>
</ul>
</li>
<li>Initialize an array of size <code>n</code> called <code>numOfSubarrays</code>.</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to count the number of subarrays in which each element is dominant:
<ul>
<li>Calculate <code>numOfSubarrays[index]</code> as <code>(nextDominant[index] - index) * (index - prevDominant[index])</code>.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a priority queue, <code>processingQueue</code> of pairs <code>(value, index)</code> and insert all elements of <code>nums</code> into it.</li>
<li><code>score</code> to <code>1</code>.</li>
</ul>
</li>
<li>While <code>k &gt; 0</code>, meaning that we are still allowed to perform operations:
<ul>
<li>Pop the front element of the queue as <code>[num, index]</code>.</li>
<li>Calculate the number of <code>operations</code> that we will perform on subarrays in which <code>num</code> is dominant, as <code>min(k, subarrays[index])</code>.</li>
<li>Multiply <code>score</code> by <code>num ^ operations</code> using modular exponentiation.</li>
<li>Decrement <code>k</code> by <code>operations</code>.</li>
</ul>
</li>
<li>Return <code>score</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/L5dp8Mfa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>nums</code> array, <span class="math inline">\(k\)</span> the number of operations and <span class="math inline">\(m\)</span> the largest element in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (\sqrt{m} + \log{n}))\)</span></p>
<p>The algorithm consists of the following steps:</p>
<ol>
<li>First, we calculate the prime scores of each number in <code>nums</code>. This is done by iterating over all numbers in the range <span class="math inline">\([2, \sqrt{\text{num}}]\)</span> and removing all occurrences of each factor in <span class="math inline">\(\text{num}\)</span>. In the worst case (when <span class="math inline">\(\text{num}\)</span> is prime), the outer loop runs <span class="math inline">\(\sqrt{\text{num}}\)</span> times, and therefore the time complexity of this step is <span class="math inline">\(O(n \times \sqrt{m})\)</span>.</li>
<li>Next, we fill the <code>nextDominant</code> and <code>prevDominant</code> arrays in <span class="math inline">\(O(n)\)</span> time, since each index is inserted and removed from the stack at most once. The calculation of the number of subarrays where each element is dominant takes an additional <span class="math inline">\(O(n)\)</span> time, since it only involves looping over <code>nums</code> and performing constant-time (arithmetic) operations in each iteration.</li>
<li>Finally, we create a priority queue where each element is inserted and removed at most once. The time complexity of this step is <span class="math inline">\(O(n \log{n})\)</span>, since both insertion and removal from a priority queue take <span class="math inline">\(O(\log{n})\)</span> time. To calculate the result, we use binary exponentiation, which runs in <span class="math inline">\(O(\log{\text{exponent}})\)</span> time. Since the exponent represents the number of operations, the total time complexity of the binary exponentiation steps is <span class="math inline">\(O(\log{k})\)</span>, which is bounded by <span class="math inline">\(O(n \log{n})\)</span>.</li>
</ol>
<p>As a result, the overall time complexity of the algorithm is <span class="math inline">\(O(n \times (\sqrt{m} + \log{n}))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>All data structures we use, including <code>primeScores</code>, <code>nextDominant</code>, and <code>prevDominant</code> arrays, as well as <code>decreasingPrimeScoreStack</code> and <code>processingQueue</code>, grow linearly with the size of the input array. Therefore, the algorithm requires <span class="math inline">\(O(n)\)</span> auxiliary space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sieve-of-eratosthenes--sorting">Approach 2: Sieve of Eratosthenes &amp; Sorting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we will follow the same logic as the previous one, but we will focus on different strategies for executing the two main steps: calculating the prime scores and determining the processing order of the elements.</p>
<p>To calculate the prime score of each number in <code>nums</code>, we will use the &quot;Sieve of Eratosthenes,&quot; an ancient and efficient method for finding all primes in a range <code>[1, n]</code>. The sieve works by iteratively marking the multiples of each prime number, starting from <code>2</code>. For each prime <code>p</code>, it marks all multiples of <code>p</code> as non-prime (composite). This process continues up to <code>sqrt(n)</code>, as any composite number greater than this will have already been marked by smaller primes. The remaining unmarked numbers are primes. Using this information, we can then iterate over each number and count how many smaller primes divide it evenly.</p>
<p>Next, we will again use a monotonic stack to identify the regions where each number is dominant in any subarray.</p>
<p>Finally, in the previous approach, we used a priority queue to quickly access the largest remaining element. However, a priority queue is only necessary when the insertion and removal of elements disrupt the order. In this case, since we process the elements in decreasing order, we can use a sorted array instead, which simplifies the process.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define a helper function <code>getPrimes(limit)</code>:
<ul>
<li>Initialize:
<ul>
<li>an array of size <code>limit + 1</code>, called <code>isPrime</code> and set all values to <code>true</code>.</li>
<li>an empty array, called <code>primes</code>.</li>
</ul>
</li>
<li>For each <code>number</code> in range: <code>[2, limit]</code>:
<ul>
<li>If <code>number</code> is not prime, continue.</li>
<li>Otherwise, push <code>number</code> into <code>primes</code>.</li>
<li>Mark every multiple of <code>number</code> in range <code>[number * number, limit]</code> as not prime.</li>
</ul>
</li>
<li>Return <code>primes</code>.</li>
</ul>
</li>
<li>In the main <code>maximumScore(nums, k)</code> function:
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of the <code>nums</code> array.</li>
<li>an array, called <code>primeScores</code> of size <code>n</code>.</li>
</ul>
</li>
<li>Store the greatest element of <code>nums</code> in <code>maxElement</code>.</li>
<li>Find all <code>primes</code> up to <code>maxElement</code> by calling <code>getPrimes(maxElement)</code>.</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to calculate the prime scores:
<ul>
<li>Set <code>num = nums[index]</code>.</li>
<li>For each <code>prime</code> in <code>primes</code>:
<ul>
<li>If <code>prime * prime &gt; num</code>, no more primes divide <code>num</code>, so break.</li>
<li>If <code>num % prime != 0</code>, continue to the next prime.</li>
<li>Increment <code>primeScores[index]</code> by <code>1</code>.</li>
<li>While <code>num</code> is divisible by <code>prime</code>, divide <code>num</code> by <code>prime</code>.</li>
</ul>
</li>
<li>If <code>num &gt; 1</code>, <code>num</code> is prime, so increment <code>primeScores[index]</code> by <code>1</code>.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>two arrays <code>nextDominant</code> and <code>prevDominant</code> to store the indices of the nearest elements with a higher prime score on both sides of each number. Set all elements in <code>nextDominant</code> to <code>n</code> and all values of <code>prevDominant</code> to <code>-1</code>.</li>
<li>an empty stack <code>decreasingPrimeScoreStack</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to fill the <code>nextDominant</code> and <code>prevDominant</code> arrays:
<ul>
<li>While the stack is not empty and the element at index <code>decreasingPrimeScoreStack.top()</code> has a lower prime score than <code>nums[index]</code>:
<ul>
<li>Pop the top element of the stack as <code>topIndex</code>.</li>
<li>Set <code>nextDominant[topIndex]</code> to the current <code>index</code>.</li>
</ul>
</li>
<li>If the stack is not empty, set <code>prevDominant[index]</code> to the index at the top of the stack.</li>
<li>Push <code>index</code> into the stack.</li>
</ul>
</li>
<li>Initialize an array of size <code>n</code>, called <code>numOfSubarrays</code>.</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to count the number of subarrays in which each element is dominant:
<ul>
<li>Calculate <code>numOfSubarrays[index]</code> as <code>(nextDominant[index] - index) * (index - prevDominant[index])</code>.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>an array <code>sortedArray</code> of pairs <code>(value, index)</code> and push all elements of <code>nums</code> into it.</li>
<li><code>score</code> to <code>1</code>.</li>
<li><code>processingIndex</code> to <code>0</code>.</li>
</ul>
</li>
<li>Sort <code>sortedArray</code> in decreasing order of <code>value</code>.</li>
<li>While <code>k &gt; 0</code>, meaning that we are still allowed to perform operations:
<ul>
<li>Get the element of the <code>sortedArray</code> at <code>processingIndex</code> as <code>[num, index]</code>.</li>
<li>Increment <code>processingIndex</code> by <code>1</code> to continue to the next element.</li>
<li>Calculate the number of <code>operations</code> that we will perform on subarrays in which <code>num</code> is dominant, as <code>min(k, subarrays[index])</code>.</li>
<li>Multiply <code>score</code> by <code>num ^ operations</code>, using modular exponentiation.</li>
<li>Decrement <code>k</code> by <code>operations</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>score</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/W9WKyk3v/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>nums</code> array, <span class="math inline">\(k\)</span> the number of operations and <span class="math inline">\(m\)</span> the largest element in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O\left(n \times \left(\log{n} + \frac{\sqrt{m}}{\log{m}} + \log{k}\right) + m \log{\log{m}}\right)\)</span></p>
<p>The algorithm consists of the following steps:</p>
<ol>
<li>
<p>We first use the Sieve of Eratosthenes to find all primes in the range <span class="math inline">\([1, m]\)</span>, which takes <span class="math inline">\(O(m \log \log m)\)</span> time to compute the primes up to <span class="math inline">\(m\)</span>.</p>
</li>
<li>
<p>For each number in <code>nums</code>, we iterate over the list of primes up to <span class="math inline">\(\sqrt{m}\)</span>. The number of primes up to <span class="math inline">\(\sqrt{m}\)</span> is approximately <span class="math inline">\(\frac{\sqrt{m}}{\log{m}}\)</span>, so the prime factorization of each number takes <span class="math inline">\(O(\frac{\sqrt{m}}{\log{m}})\)</span> time, and for all numbers in <code>nums</code>, this takes <span class="math inline">\(O(n \times \frac{\sqrt{m}}{\log{m}})\)</span>.</p>
</li>
<li>
<p>Filling the <code>nextDominant</code> and <code>prevDominant</code> arrays takes <span class="math inline">\(O(n)\)</span> time, as each index is processed at most once, and the number of subarrays is calculated in constant time for each index, which also takes <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Sorting the <code>sortedArray</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
</li>
<li>
<p>Binary exponentiation is performed to compute the result, which takes <span class="math inline">\(O(\log{k})\)</span> time for each operation. Since the loop runs at most <span class="math inline">\(n\)</span> times, the total time complexity for the exponentiation step is <span class="math inline">\(O(n \log k)\)</span>.</p>
</li>
</ol>
<p>Therefore, the overall time complexity is: <span class="math inline">\(O\left(n \times \left(\log{n} + \frac{\sqrt{m}}{\log{m}} + \log{k}\right) + m \log{\log{m}}\right)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>We use an array <code>isPrime</code> of size <span class="math inline">\(O(m)\)</span> to mark numbers as prime or not. Additionally, several data structures such as <code>primes</code>, <code>primeScores</code>, <code>nextDominant</code>, <code>prevDominant</code>, and <code>sortedArray</code> are used, all of which grow linearly with the size of the input array, <span class="math inline">\(O(n)\)</span>.</p>
<p>The space required for sorting depends on the language:</p>
<ul>
<li>In Java, the space complexity is <span class="math inline">\(O(\log n)\)</span> due to Quick Sort.</li>
<li>In C++, it is <span class="math inline">\(O(\log n)\)</span> for the hybrid sort.</li>
<li>In Python, it is <span class="math inline">\(O(n)\)</span> due to Timsort.</li>
</ul>
<p>Therefore, the total space complexity is <span class="math inline">\(O(m + n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/circular-list-8e1319c9/" target="_blank" rel="noopener noreferrer">Array Formation &lt;Liv.ai&gt;</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">easy</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <em>A</em> of <em>n</em> integers. You have to make a queue and stack of the given integers. Queue should contain only prime numbers and stack should contain only composite numbers. All numbers in the array will be <span class="mathjax-latex">\(\gt 1\)</span>.<br />
The rule to form the stack and queue is that you should be able to generate the array using the pop and dequeue operations.<br />
<strong>Note : Please read this explanation carefully</strong><br /></p>
<p>Let the array <em>A</em> contains <strong>5</strong> integers : 7 , 21 , 18 , 3 , 12 then the content of queue and stack will be :<br />
<strong>Queue :</strong> 7 , 3<br />
<strong>Stack   :</strong> 12 , 18 , 21<br />
Now if you follow the rules of stack and queue then you see that you can generate the array using the pop operations of stack and dequeue operation of queue as follows : 
<br /></p>
<p>dequeue from queue : <strong>7</strong><br />
pop from stack : <strong>7 , 21</strong><br />
pop from stack : <strong>7 , 21 , 18</strong><br />
dequeue from queue : <strong>7 , 21 , 18 , 3</strong><br />
pop from stack : <strong>7 , 21 , 18 , 3 , 12</strong><br /></p>
<p>Thus for every array <em>A</em> you have to print the contents of queue in the first line and contents of stack in the second line.<br /></p>
<p><strong>Input Format</strong><br />
First line contains an integer <em>n</em> as input denoting total numbers of integers in the array.<br />
 Next line contains <em>n</em> space separated integers denoting the elements of array <em>A</em>.<br />
Your output should print two arrays , one in each line. First line should be the contents of queue and second line should be the contents of stack.<br /></p>
<p><strong>Output Format</strong><br />
In the first line print the contents of queue and in second line print the contents of the stack.<br /></p>
<p><strong>Input Constraints</strong><br />
<span class="mathjax-latex">\(1 \le n \le 10^6\)</span><br />
<span class="mathjax-latex">\(2 \le A[i] \le 10^6\)</span><br /></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The sample test case is explained in the problem statement.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/asteroid-collision/description" target="_blank" rel="noopener noreferrer">Asteroid Collision</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are given an array <code>asteroids</code> of integers representing asteroids in a row. The indices of the asteriod in the array represent their relative position in space.</p>

<p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p>

<p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> asteroids = [5,10,-5]
<strong>Output:</strong> [5,10]
<strong>Explanation:</strong> The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> asteroids = [8,-8]
<strong>Output:</strong> []
<strong>Explanation:</strong> The 8 and -8 collide exploding each other.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> asteroids = [10,2,-5]
<strong>Output:</strong> [10]
<strong>Explanation:</strong> The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= asteroids.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>
	<li><code>asteroids[i] != 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/asteroid-collision/1" target="_blank" rel="noopener noreferrer">Asteroid Collision</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">We are given an integer array <strong>asteroids</strong>&nbsp;of size <strong>N</strong> representing asteroids in a row. For&nbsp;each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.<br />
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are of&nbsp;same size, both will explode. Two asteroids moving in the same direction will never meet.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<div style="background: rgb(238, 238, 238); border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#222426; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;"><span style="font-size:18px"><strong>Input:</strong><br />
N = 3<br />
asteroids[ ] = {3,&nbsp;5, -3}<br />
<strong>Output:&nbsp;</strong>{3, 5}<br />
<strong>Explanation:</strong>&nbsp;The asteroid 5 and -3&nbsp;collide resulting in 5. The 5 and 3 never collide.</span></div>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<div style="background: rgb(238, 238, 238); border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#222426; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;"><span style="font-size:18px"><strong>Input:</strong><br />
N = 2<br />
asteroids[ ] = {10, -10}<br />
<strong>Output:&nbsp;</strong>{ }<br />
<strong>Explanation:</strong>&nbsp;The asteroid -10&nbsp;and 10&nbsp;collide exploding each other.</span></div>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>asteroidCollision()</strong>&nbsp;which takes the&nbsp;array of&nbsp;integers <strong>asteroids&nbsp;</strong>and <strong>N&nbsp;</strong>as parameters and returns the state of asteroids after all collisions.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(N)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<sup>5</sup><br />
-1000 &le; asteroids<sub>i&nbsp; </sub>&le; 1000<br />
asteroids[i]!=0</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/a-weird-game-e2b9afe4/" target="_blank" rel="noopener noreferrer">A Weird Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">medium</span> <span class="topic-badge">stack</span> <span class="topic-badge">stringmanipulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <em>S</em> and <em>T</em> where <em>T</em> is a subsequence of <em>S</em>, you need to find the number of pairs of indices <span class="mathjax-latex">\((i, j)\)</span>, where <span class="mathjax-latex">\( i \le j \)</span> , such that if we delete a non-empty substring <span class="mathjax-latex">\(S[i... j]\)</span> from string <em>S</em> and concatenate the remaining two parts, string <em>T</em> still remains a <a href="https://en.wikipedia.org/wiki/Subsequence">subsequence</a> of string <em>S</em>.  Note that we consider each pair of indices <span class="mathjax-latex">\((i, j)\)</span> independent of all other pairs.   </p>
<p><strong>Input Format</strong>:<br />
The first line of the input consists of a single integer <em>t</em>, denoting the number of test cases.<br />
The first line of each test case consists of string <em>S</em>.<br />
The second line of each test case consists of string <em>T</em>.    </p>
<p><strong>Output Format</strong>:<br />
For each test case, print the required answer in a separate line. </p>
<p><strong>Input Constraints</strong>:<br />
</p>
<ul>
<li><span class="mathjax-latex">\(1 \le t \le 10\)</span></li>
<li><span class="mathjax-latex">\(1 \le |S| \le 10^{5}\)</span></li>
<li><span class="mathjax-latex">\(1 \le |T| \le |S|\)</span></li>
<li>Both strings <em>S</em> and <em>T</em> contain only lowercase English alphabets.</li>
</ul>
<p></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The substrings we can remove are :<br />
[2,2] , [4,4], [5,5], [6,6], [4,5], [5,6], [4,6]</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/backspace-string-compare/description" target="_blank" rel="noopener noreferrer">Backspace String Compare</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if they are equal when both are typed into empty text editors</em>. <code>&#39;#&#39;</code> means a backspace character.</p>

<p>Note that after backspacing an empty text, the text will continue empty.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ab#c&quot;, t = &quot;ad#c&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Both s and t become &quot;ac&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ab##&quot;, t = &quot;c#d#&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Both s and t become &quot;&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a#c&quot;, t = &quot;b&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> s becomes &quot;c&quot; while t becomes &quot;b&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code><span>1 &lt;= s.length, t.length &lt;= 200</span></code></li>
	<li><span><code>s</code> and <code>t</code> only contain lowercase letters and <code>&#39;#&#39;</code> characters.</span></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve it in <code>O(n)</code> time and <code>O(1)</code> space?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-build-string-accepted">Approach #1: Build String [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Let's individually build the result of each string (<code>build(S)</code> and <code>build(T)</code>), then compare if they are equal.</p>
<p><strong>Algorithm</strong></p>
<p>To build the result of a string <code>build(S)</code>, we'll use a stack based approach, simulating the result of each keystroke.</p>
<p><a href="https://leetcode.com/playground/g7aBaNuB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(M + N)\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>S</code> and <code>T</code> respectively.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer-accepted">Approach #2: Two Pointer [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>When writing a character, it may or may not be part of the final string depending on how many backspace keystrokes occur in the future.</p>
<p>If instead we iterate through the string in reverse, then we will know how many backspace characters we have seen, and therefore whether the result includes our character.</p>
<p><strong>Algorithm</strong></p>
<p>Iterate through the string in reverse.  If we see a backspace character, the next non-backspace character is skipped.  If a character isn't skipped, it is part of the final answer.</p>
<p>See the comments in the code for more details.</p>
<p><a href="https://leetcode.com/playground/DGF5YvNa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(M + N)\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>S</code> and <code>T</code> respectively.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/baseball-game/description" target="_blank" rel="noopener noreferrer">Baseball Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.</p>

<p>You are given a list of strings <code>operations</code>, where <code>operations[i]</code> is the <code>i<sup>th</sup></code> operation you must apply to the record and is one of the following:</p>

<ul>
	<li>An integer <code>x</code>.

	<ul>
		<li>Record a new score of <code>x</code>.</li>
	</ul>
	</li>
	<li><code>&#39;+&#39;</code>.
	<ul>
		<li>Record a new score that is the sum of the previous two scores.</li>
	</ul>
	</li>
	<li><code>&#39;D&#39;</code>.
	<ul>
		<li>Record a new score that is the double of the previous score.</li>
	</ul>
	</li>
	<li><code>&#39;C&#39;</code>.
	<ul>
		<li>Invalidate the previous score, removing it from the record.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the sum of all the scores on the record after applying all the operations</em>.</p>

<p>The test cases are generated such that the answer and all intermediate calculations fit in a <strong>32-bit</strong> integer and that all operations are valid.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]
<strong>Output:</strong> 30
<strong>Explanation:</strong>
&quot;5&quot; - Add 5 to the record, record is now [5].
&quot;2&quot; - Add 2 to the record, record is now [5, 2].
&quot;C&quot; - Invalidate and remove the previous score, record is now [5].
&quot;D&quot; - Add 2 * 5 = 10 to the record, record is now [5, 10].
&quot;+&quot; - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
The total sum is 5 + 10 + 15 = 30.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]
<strong>Output:</strong> 27
<strong>Explanation:</strong>
&quot;5&quot; - Add 5 to the record, record is now [5].
&quot;-2&quot; - Add -2 to the record, record is now [5, -2].
&quot;4&quot; - Add 4 to the record, record is now [5, -2, 4].
&quot;C&quot; - Invalidate and remove the previous score, record is now [5, -2].
&quot;D&quot; - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].
&quot;9&quot; - Add 9 to the record, record is now [5, -2, -4, 9].
&quot;+&quot; - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].
&quot;+&quot; - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].
The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> ops = [&quot;1&quot;,&quot;C&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
&quot;1&quot; - Add 1 to the record, record is now [1].
&quot;C&quot; - Invalidate and remove the previous score, record is now [].
Since the record is empty, the total sum is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= operations.length &lt;= 1000</code></li>
	<li><code>operations[i]</code> is <code>&quot;C&quot;</code>, <code>&quot;D&quot;</code>, <code>&quot;+&quot;</code>, or a string representing an integer in the range <code>[-3 * 10<sup>4</sup>, 3 * 10<sup>4</sup>]</code>.</li>
	<li>For operation <code>&quot;+&quot;</code>, there will always be at least two previous scores on the record.</li>
	<li>For operations <code>&quot;C&quot;</code> and <code>&quot;D&quot;</code>, there will always be at least one previous score on the record.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-stack-accepted">Approach #1: Stack [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Let's maintain the value of each valid round on a stack as we process the data. A stack is ideal since we only deal with operations involving the last or second-last valid round.</p>
<p><a href="https://leetcode.com/playground/FRAbgcgJ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>ops</code>. We parse through every element in the given array once, and do <span class="math inline">\(O(1)\)</span> work for each element.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the space used to store our <code>stack</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/basic-calculator/description" target="_blank" rel="noopener noreferrer">Basic Calculator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</p>

<p><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1 + 1&quot;
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot; 2-1 + 2 &quot;
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(1+(4+5+2)-3)+(6+8)&quot;
<strong>Output:</strong> 23
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>
	<li><code>s</code> represents a valid expression.</li>
	<li><code>&#39;+&#39;</code> is <strong>not</strong> used as a unary operation (i.e., <code>&quot;+1&quot;</code> and <code>&quot;+(2 + 3)&quot;</code> is invalid).</li>
	<li><code>&#39;-&#39;</code> could be used as a unary operation (i.e., <code>&quot;-1&quot;</code> and <code>&quot;-(2 + 3)&quot;</code> is valid).</li>
	<li>There will be no two consecutive operators in the input.</li>
	<li>Every number and running calculation will fit in a signed 32-bit integer.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/basic-calculator-ii/description" target="_blank" rel="noopener noreferrer">Basic Calculator II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>.&nbsp;</p>

<p>The integer division should truncate toward zero.</p>

<p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p>

<p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "3+2*2"
<strong>Output:</strong> 7
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = " 3/2 "
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> s = " 3+5 / 2 "
<strong>Output:</strong> 5
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists of integers and operators <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> separated by some number of spaces.</li>
	<li><code>s</code> represents <strong>a valid expression</strong>.</li>
	<li>All the integers in the expression are non-negative integers in the range <code>[0, 2<sup>31</sup> - 1]</code>.</li>
	<li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>There are multiple variations of this problem like <a href="https://leetcode.com/problems/basic-calculator/">Basic Calculator</a> and <a href="https://leetcode.com/problems/basic-calculator-iii/">Basic Calculator III</a>. This problem is relatively simpler to solve, as we don't have to take care of the parenthesis.</p>
<p>The aim is to evaluate the given mathematical expression by applying the basic mathematical rules. The expressions are evaluated from left to right and the order of evaluation depends on the <a href="https://en.wikipedia.org/wiki/Order_of_operations">Operator Precedence</a>. Let's understand how we could implement the problem using different approaches.</p>
<hr />
<h3 id="approach-1-using-stack">Approach 1: Using Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>We know that there could be 4 types of operations - addition <code>(+)</code>, subtraction <code>(-)</code>, multiplication <code>(*)</code> and division <code>(/)</code>.  Without parenthesis, we know that, multiplication  <code>(*)</code> and <code>(\)</code> operations would always have higher precedence than addition <code>(+)</code> and subtraction <code>(-)</code> based on operator precedence rules.</p>
<p><img src="../Figures/227/calculator_overview.png" alt="img" /></p>
<p>If we look at the above examples, we can make the following observations -</p>
<ul>
<li>If the current operation is addition <code>(+)</code> or subtraction <code>(-)</code>, then the expression is evaluated based on the precedence of the next operation.</li>
</ul>
<p>In example 1, <code>4+3</code> is evaluated later because the next operation is multiplication <code>(3*5)</code> which has higher precedence.<br />
But,  in example 2, <code>4+3</code> is evaluated first because the next operation is subtraction <code>(3-5)</code> which has equal precedence.</p>
<ul>
<li>If the current operator is multiplication <code>(*)</code> or division <code>(/)</code>, then the expression is evaluated irrespective of the next operation. This is because in the given set of operations <code>(+,-,*,/)</code>, the  <code>*</code> and <code>/</code> operations have the highest precedence and therefore must be evaluated first.</li>
</ul>
<p>In the above examples 3 and 4, <code>4*3</code> is always evaluated first irrespective of the next operation.</p>
<p>Using this intuition let's look at the algorithm to implement the problem.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Scan the input string <code>s</code> from left to right and evaluate the expressions based on the following rules</p>
<ol>
<li>If the current character is a digit <code>0-9</code> ( operand ), add it to the number <code>currentNumber</code>.</li>
<li>Otherwise, the current character must be an operation <code>(+,-,*, /)</code>. Evaluate the expression based on the type of operation.</li>
</ol>
<ul>
<li>Addition <code>(+)</code> or Subtraction <code>(-)</code>: We must evaluate the expression later based on the next operation. So, we must store the <code>currentNumber</code> to be used later. Let's push the currentNumber in the Stack.</li>
</ul>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack data structure</a> follows Last In First Out (LIFO) principle. Hence, the last pushed number in the stack would be popped out first for evaluation.  In addition, when we pop from the stack and evaluate this expression in the future, we need a way to determine if the operation was Addition <code>(+)</code> or Subtraction <code>(-)</code>. To simplify our evaluation, we can push <code>-currentNumber</code> in a stack if the current operation is subtraction (<code>-</code>) and assume that the operation for all the values in the stack is addition <code>(+)</code>. This works because <code>(a - currentNumber)</code> is equivalent to <code>(a + (-currentNumber))</code>.</p>
</blockquote>
<ul>
<li>Multiplication <code>(*)</code> or Division <code>(/)</code>: Pop the top values from the stack and evaluate the current expression. Push the evaluated value back to the stack.</li>
</ul>
<p>Once the string is scanned, pop from the stack and add to the <code>result</code>.</p>
<p>!?!../Documents/227_LIS.json:1414,716!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6A5bNZvg/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(n)\)</span>,  where <span class="math inline">\(n\)</span> is the length of the string <span class="math inline">\(s\)</span>. We iterate over the string <span class="math inline">\(s\)</span> at most twice.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(n)\)</span>, where <span class="math inline">\(n\)</span> is the length of the string <span class="math inline">\(s\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimised-approach-without-the-stack">Approach 2: Optimised Approach without the stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a stack to track the values of the evaluated expressions. In the end, we pop all the values from the stack and add to the result. Instead of that, we could add the values to the result beforehand and keep track of the last calculated number, thus eliminating the need for the stack. Let's understand the algorithm in detail.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>The approach works similar to <em>Approach 1</em> with the following differences :</p>
<ul>
<li>Instead of using a <code>stack</code>, we use a variable <code>lastNumber</code> to track the value of the last evaluated expression.</li>
<li>If the operation is Addition <code>(+)</code> or Subtraction <code>(-)</code>, add the <code>lastNumber</code> to the result instead of pushing it to the stack. The <code>currentNumber</code> would be updated to <code>lastNumber</code> for the next iteration.</li>
<li>If the operation is Multiplication <code>(*)</code> or Division <code>(/)</code>, we must evaluate the expression <code>lastNumber * currentNumber</code> and update the <code>lastNumber</code> with the result of the expression.  This would be added to the result after the entire string is scanned.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ao7b4uv8/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(n)\)</span>,  where <span class="math inline">\(n\)</span> is the length of the string <span class="math inline">\(s\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(1)\)</span>, as we use constant extra space to store <code>lastNumber</code>, <code>result</code> and so on.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/basic-calculator-iv/description" target="_blank" rel="noopener noreferrer">Basic Calculator IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an expression such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code></p>

<ul>
	<li>An expression alternates chunks and symbols, with a space separating each chunk and symbol.</li>
	<li>A chunk is either an expression in parentheses, a variable, or a non-negative integer.</li>
	<li>A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.</li>
</ul>

<p>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.</p>

<ul>
	<li>For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.</li>
</ul>

<p>The format of the output is as follows:</p>

<ul>
	<li>For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.
	<ul>
		<li>For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.</li>
	</ul>
	</li>
	<li>Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
	<ul>
		<li>For example, <code>&quot;a*a*b*c&quot;</code> has degree <code>4</code>.</li>
	</ul>
	</li>
	<li>The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.</li>
	<li>An example of a well-formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>.</li>
	<li>Terms (including constant terms) with coefficient <code>0</code> are not included.
	<ul>
		<li>For example, an expression of <code>&quot;0&quot;</code> has an output of <code>[]</code>.</li>
	</ul>
	</li>
</ul>

<p><strong>Note:</strong> You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;e + 8 - a + 5&quot;, evalvars = [&quot;e&quot;], evalints = [1]
<strong>Output:</strong> [&quot;-1*a&quot;,&quot;14&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;e - 8 + temperature - pressure&quot;, evalvars = [&quot;e&quot;, &quot;temperature&quot;], evalints = [1, 12]
<strong>Output:</strong> [&quot;-1*pressure&quot;,&quot;5&quot;]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;(e + 8) * (e - 8)&quot;, evalvars = [], evalints = []
<strong>Output:</strong> [&quot;1*e*e&quot;,&quot;-64&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 250</code></li>
	<li><code>expression</code> consists of lowercase English letters, digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39; &#39;</code>.</li>
	<li><code>expression</code> does not contain any leading or trailing spaces.</li>
	<li>All the tokens in <code>expression</code> are separated by a single space.</li>
	<li><code>0 &lt;= evalvars.length &lt;= 100</code></li>
	<li><code>1 &lt;= evalvars[i].length &lt;= 20</code></li>
	<li><code>evalvars[i]</code> consists of lowercase English letters.</li>
	<li><code>evalints.length == evalvars.length</code></li>
	<li><code>-100 &lt;= evalints[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/beautiful-towers-i/description" target="_blank" rel="noopener noreferrer">Beautiful Towers I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>heights</code> of <code>n</code> integers representing the number of bricks in <code>n</code> consecutive towers. Your task is to remove some bricks to form a <strong>mountain-shaped</strong> tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing.</p>

<p>Return the <strong>maximum possible sum</strong> of heights of a mountain-shaped tower arrangement.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">heights = [5,3,4,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p>We remove some bricks to make <code>heights =&nbsp;[5,3,3,1,1]</code>, the peak is at index 0.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">heights = [6,5,3,9,2,7]</span></p>

<p><strong>Output:</strong> <span class="example-io">22</span></p>

<p><strong>Explanation:</strong></p>

<p>We remove some bricks to make <code>heights =&nbsp;[3,3,3,9,2,2]</code>, the peak is at index 3.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">heights = [3,2,5,5,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">18</span></p>

<p><strong>Explanation:</strong></p>

<p>We remove some bricks to make <code>heights = [2,2,5,5,2,2]</code>, the peak is at index 2 or 3.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == heights.length &lt;= 10<sup>3</sup></code></li>
	<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/beautiful-towers-ii/description" target="_blank" rel="noopener noreferrer">Beautiful Towers II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>maxHeights</code> of <code>n</code> integers.</p>

<p>You are tasked with building <code>n</code> towers in the coordinate line. The <code>i<sup>th</sup></code> tower is built at coordinate <code>i</code> and has a height of <code>heights[i]</code>.</p>

<p>A configuration of towers is <strong>beautiful</strong> if the following conditions hold:</p>

<ol>
	<li><code>1 &lt;= heights[i] &lt;= maxHeights[i]</code></li>
	<li><code>heights</code> is a <strong>mountain</strong> array.</li>
</ol>

<p>Array <code>heights</code> is a <strong>mountain</strong> if there exists an index <code>i</code> such that:</p>

<ul>
	<li>For all <code>0 &lt; j &lt;= i</code>, <code>heights[j - 1] &lt;= heights[j]</code></li>
	<li>For all <code>i &lt;= k &lt; n - 1</code>, <code>heights[k + 1] &lt;= heights[k]</code></li>
</ul>

<p>Return <em>the <strong>maximum possible sum of heights</strong> of a beautiful configuration of towers</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> maxHeights = [5,3,4,1,1]
<strong>Output:</strong> 13
<strong>Explanation:</strong> One beautiful configuration with a maximum sum is heights = [5,3,3,1,1]. This configuration is beautiful since:
- 1 &lt;= heights[i] &lt;= maxHeights[i]  
- heights is a mountain of peak i = 0.
It can be shown that there exists no other beautiful configuration with a sum of heights greater than 13.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> maxHeights = [6,5,3,9,2,7]
<strong>Output:</strong> 22
<strong>Explanation:</strong> One beautiful configuration with a maximum sum is heights = [3,3,3,9,2,2]. This configuration is beautiful since:
- 1 &lt;= heights[i] &lt;= maxHeights[i]
- heights is a mountain of peak i = 3.
It can be shown that there exists no other beautiful configuration with a sum of heights greater than 22.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> maxHeights = [3,2,5,5,2,3]
<strong>Output:</strong> 18
<strong>Explanation:</strong> One beautiful configuration with a maximum sum is heights = [2,2,5,5,2,2]. This configuration is beautiful since:
- 1 &lt;= heights[i] &lt;= maxHeights[i]
- heights is a mountain of peak i = 2. 
Note that, for this configuration, i = 3 can also be considered a peak.
It can be shown that there exists no other beautiful configuration with a sum of heights greater than 18.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == maxHeights.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= maxHeights[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-search-tree-iterator/description" target="_blank" rel="noopener noreferrer">Binary Search Tree Iterator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-search-tree</span> <span class="topic-badge">binary-tree</span> <span class="topic-badge">design</span> <span class="topic-badge">iterator</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)" target="_blank">in-order traversal</a></strong> of a binary search tree (BST):</p>

<ul>
	<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>
	<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>
	<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>
</ul>

<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>

<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" style="width: 189px; height: 178px;" />
<pre>
<strong>Input</strong>
[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
<strong>Output</strong>
[null, 3, 7, true, 9, true, 15, true, 20, false]

<strong>Explanation</strong>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-inorder-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Inorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-tree</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" style="width: 200px; height: 264px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,2,6,5,7,1,3,9,8]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" style="width: 350px; height: 286px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursive-approach">Approach 1: Recursive Approach</h3>
<p>The first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.</p>
<p><a href="https://leetcode.com/playground/E5pBkUup/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The time complexity is <span class="math inline">\(O(n)\)</span> because the recursive function is <span class="math inline">\(T(n) = 2 \cdot T(n/2)+1\)</span>.</li>
</ul>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The worst case space required is <span class="math inline">\(O(n)\)</span>, and in the average case it's <span class="math inline">\(O(\log n)\)</span> where <span class="math inline">\(n\)</span> is number of nodes.</li>
</ul>
<br />
<hr />
<h3 id="approach-2-iterating-method-using-stack">Approach 2: Iterating method using Stack</h3>
<p>The strategy is very similiar to the first method, the different is using stack.</p>
<p>Here is an illustration:</p>
<p>!?!../Documents/94_Binary.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/9k44r9CB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<br />
<hr />
<h3 id="approach-3-morris-traversal">Approach 3: Morris Traversal</h3>
<p>In this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows:</p>
<blockquote>
<p>Step 1: Initialize current as root</p>
<p>Step 2: While current is not NULL,</p>
<pre><code>If current does not have left child

    a. Add currentâ€™s value

    b. Go to the right, i.e., current = current.right

Else

    a. In current's left subtree, make current the right child of the rightmost node

    b. Go to this left child, i.e., current = current.left
</code></pre>
</blockquote>
<p>For example:</p>
<pre><code>
          1
        /   \
       2     3
      / \   /
     4   5 6

</code></pre>
<p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is</p>
<pre><code>         2
        / \
       4   5
</code></pre>
<p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2).<br />
The tree now looks like:</p>
<pre><code>         2
        / \
       4   5
            \
             1
              \
               3
              /
             6
</code></pre>
<p>For current 2, which has left child 4, we can continue with the same process as we did above</p>
<pre><code>        4
         \
          2
           \
            5
             \
              1
               \
                3
               /
              6
</code></pre>
<p>then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.<br />
Finally, the inorder traversal is [4,2,5,1,6,3].</p>
<p>For more details, please check<br />
<a href="https://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded binary tree</a> and<br />
<a href="https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion">Explanation of Morris Method</a></p>
<p><a href="https://leetcode.com/playground/fVkds6Bx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>To prove that the time complexity is <span class="math inline">\(O(n)\)</span>, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is <span class="math inline">\(O(n \log n)\)</span>, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs <span class="math inline">\(O(n)\)</span> time. Because a binary Tree with <span class="math inline">\(n\)</span> nodes has <span class="math inline">\(n-1\)</span> edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>Extra space is only allocated for the ArrayList of size <span class="math inline">\(n\)</span>, however the output does not count towards the space complexity.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-postorder-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Postorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-tree</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" style="width: 200px; height: 264px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,6,7,5,2,9,8,3,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" style="width: 350px; height: 286px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>To traverse a tree, we use two main strategies:</p>
<ul>
<li>
<p>Breadth-First Search (BFS): This strategy involves scanning the tree level by level from the top down, visiting nodes at higher levels before those at lower levels.</p>
</li>
<li>
<p>Depth-First Search (DFS): This approach explores as far down a branch as possible before backtracking. It starts at the root, proceeds to a leaf, and then returns to explore other branches. DFS can be further categorized into:</p>
<ul>
<li>Preorder: Visit the root first, then the left subtree, followed by the right subtree.</li>
<li>Inorder: Visit the left subtree first, then the root, and then the right subtree.</li>
<li>Postorder: Visit the left subtree first, then the right subtree, and finally the root.</li>
</ul>
</li>
</ul>
<p><img src="../Figures/145/traverse2.png" alt="Tree Traversal Example" /><br />
<em>Figure 1. Nodes are numbered in the order they are visited; refer to the sequence <code>1-2-3-4-5</code> to compare different traversal strategies.</em></p>
<p>For a binary tree with the root <code>[1, null, 2, 3]</code>, the tree structure is as follows:</p>
<pre><code>1
 \
  2
 /
3
</code></pre>
<p>In Postorder traversal, nodes are visited in the sequence: <code>3</code> (left subtree), <code>2</code> (right subtree), and finally <code>1</code> (root). Thus, the output for this input should be <code>[3, 2, 1]</code>.</p>
<hr />
<h3 id="approach-1-recursive-postorder-traversal">Approach 1: Recursive Postorder Traversal</h3>
<h4 id="intuition">Intuition</h4>
<p><img src="../Figures/145/recursion.png" alt="recursion" /><br />
<em>Figure 2. Recursive DFS traversals.</em></p>
<p>In this approach, we treat each node as the root of its subtree. We start by recursively traversing the left subtree. If the left child is not null, we continue exploring until the left subtree is fully traversed. Then, we move to the right subtree and repeat the process. After both subtrees are explored, we process the current node by adding its value to the result list.</p>
<p>The base case occurs when the current node is null, indicating no further subtree to explore. At this point, we simply return and backtrack.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Define a helper function <code>postorderTraversalHelper</code>:
<ul>
<li>If <code>currentNode</code> is <code>null</code>, return to stop further recursion.</li>
<li>Recursively call <code>postorderTraversalHelper</code> with <code>currentNode-&gt;left</code> to process the left subtree.</li>
<li>Recursively call <code>postorderTraversalHelper</code> with <code>currentNode-&gt;right</code> to process the right subtree.</li>
<li>Append <code>currentNode-&gt;val</code> to the <code>result</code> array to collect values in postorder.</li>
</ul>
</li>
<li>In the <code>postorderTraversal</code> function:
<ul>
<li>Initialize an empty <code>result</code> array to store the postorder ordering of the nodes in<code>root</code>.</li>
<li>Call <code>postorderTraversalHelper</code> with the root node and <code>result</code> to start the traversal.</li>
<li>Return the <code>result</code> array containing the postorder traversal.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/X7v7GcVB/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is visited once during the traversal, so the time complexity is linear with respect to the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> due to the recursion stack. In the worst case (e.g., a completely unbalanced tree), the recursion stack could hold all <code>n</code> nodes.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-manipulating-preorder-traversal-iterative-hack">Approach 2: Manipulating Preorder Traversal (Iterative Hack)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's take a creative leap in this approach by exploiting the relationship between preorder and postorder traversals. In a standard preorder traversal, we visit the root node before we visit the left and right subtrees. However, postorder traversal requires us to visit the left and right subtrees before the root node.</p>
<p>We can adapt the preorder traversal by visiting nodes in the order of root, right subtree, and then left subtree. Reversing the resulting list from this modified preorder traversal gives us the correct postorder sequence.</p>
<p>We use a stack to traverse the tree iteratively, starting with the root node. We push the current node onto the stack and add its value to the result list. Instead of moving to the left child, we move to the right child. If there's no right child, we pop a node from the stack and move to its left child. This approach processes the right subtree before the left subtree, aligning with the modified preorder traversal.</p>
<p>After traversing the entire tree, we reverse the result list to get the postorder sequence: left subtree, right subtree, root.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list to store the traversal result, a <code>traversalStack</code> for nodes, and set <code>currentNode</code> to <code>root</code>.</li>
<li>While <code>currentNode</code> is not <code>null</code> or <code>traversalStack</code> is not empty:
<ul>
<li>If <code>currentNode</code> is not <code>null</code>, add <code>currentNode-&gt;val</code> to the <code>result</code> list before processing its children.</li>
<li>Push <code>currentNode</code> onto the <code>traversalStack</code> to revisit it later.</li>
<li>Move <code>currentNode</code> to <code>currentNode-&gt;right</code> to continue traversal in the right subtree.</li>
<li>If <code>currentNode</code> is <code>null</code>, pop the top node from <code>traversalStack</code> and set it to <code>currentNode</code>.</li>
<li>Move <code>currentNode</code> to <code>currentNode-&gt;left</code> to process the left subtree.</li>
</ul>
</li>
<li>Reverse the <code>result</code> list to correct the order from preorder to postorder.</li>
<li>Return the <code>result</code> list with postorder traversal values.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5wrszGxT/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is processed a constant number of times (essentially twice), so the time complexity remains linear with respect to <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(2n) = O(n)\)</span> due to the stack used for traversing the tree nodes. This stack could hold up to <code>n</code> nodes in the worst case.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-stack-postorder-traversal-iterative">Approach 3: Two Stack Postorder Traversal (Iterative)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of relying on hacks and tricks, this time we will build on the idea that we need to control the order in which nodes are processed to achieve postorder traversal.</p>
<p>To achieve postorder traversal without recursion, we use two stacks to control the node processing order systematically.</p>
<p>First, we push the root node onto the first stack. This stack simulates the recursive traversal of the tree. To process nodes in postorder (left-right-root), we need a second stack to reverse the order. As we pop nodes from the first stack, we push them onto the second stack. This reversal ensures that nodes are processed in the correct order.</p>
<p>After all nodes are transferred to the second stack, popping from it gives us the nodes in postorder sequence. This method efficiently achieves the desired traversal order by leveraging the two stacks to manage the processing sequence without needing a final reversal step.</p>
<p>In summary, the two-stack approach uses the first stack for tree traversal and the second stack to reverse the order, resulting in a postorder traversal. Despite initially seeming like a manipulation of preorder traversal, the final order of nodes from the second stack aligns with postorder traversal.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list, and create <code>mainStack</code> and <code>pathStack</code> for nodes.</li>
<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>
<li>Push <code>root</code> onto <code>mainStack</code> to start the traversal.</li>
<li>While <code>mainStack</code> is not empty:
<ul>
<li>Peek at the top of <code>mainStack</code> to examine the current node.</li>
<li>If the top of <code>pathStack</code> is the same as the top of <code>mainStack</code>, add <code>root-&gt;val</code> to the <code>result</code> list.</li>
<li>Pop the top node from both <code>mainStack</code> and <code>pathStack</code> after processing.</li>
<li>Otherwise, push the current node onto <code>pathStack</code>.</li>
<li>Push <code>root-&gt;right</code> and <code>root-&gt;left</code> onto <code>mainStack</code> if they exist to process their children.</li>
</ul>
</li>
<li>Return the <code>result</code> list containing postorder traversal values.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/GkvWqGqp/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is processed a constant number of times (once when pushed to the first stack and once when popped to the second stack), so the time complexity is linear with respect to <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> due to the use of two stacks. Each stack can hold up to <code>n</code> nodes in the worst case.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-single-stack-postorder-traversal-iterative">Approach 4: Single Stack Postorder Traversal (Iterative)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>After exploring the two-stack approach, we might seek to optimize further by reducing space complexity. While two stacks effectively manage traversal order, they double our space usage. Instead, we can use a single stack combined with a <code>previousNode</code> pointer to track the traversal.</p>
<p>We start by pushing nodes onto the stack while traversing left, similar to inorder traversal. In postorder traversal, we must process each node after its right subtree. To manage this, the <code>previousNode</code> pointer helps remember the last processed node.</p>
<p>When a node is reached on the stack, we first check if it has an unvisited right child. If so, we move to that right child since we can't process the current node until after its right subtree. If the node has no right child or its right child has already been processed (indicated by <code>previousNode</code>), we process the node by popping it from the stack and adding its value to the result list, then update <code>previousNode</code> to this node.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list, set <code>previousNode</code> to <code>null</code>, and initialize <code>traversalStack</code>.</li>
<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>
<li>While <code>root</code> is not <code>null</code> or <code>traversalStack</code> is not empty:
<ul>
<li>If <code>root</code> is not <code>null</code>, push <code>root</code> onto <code>traversalStack</code>.</li>
<li>Move <code>root</code> to <code>root-&gt;left</code> to process the left subtree.</li>
<li>If <code>root</code> is <code>null</code>, peek at the top of <code>traversalStack</code>.</li>
<li>If <code>root-&gt;right</code> is <code>null</code> or <code>root-&gt;right</code> equals <code>previousNode</code>, add <code>root-&gt;val</code> to <code>result</code>.</li>
<li>Pop <code>root</code> from <code>traversalStack</code>, set <code>previousNode</code> to <code>root</code>, and set <code>root</code> to <code>null</code>.</li>
<li>If <code>root-&gt;right</code> is not <code>null</code>, move <code>root</code> to <code>root-&gt;right</code> to continue the traversal.</li>
</ul>
</li>
<li>Return the <code>result</code> list containing postorder traversal values.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/PMTa9tEv/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is processed a constant number of times. The stack operations and pointer manipulations also contribute to a linear time complexity with respect to <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Although this approach uses only a single stack, in the worst case, the stack can still hold up to <code>n</code> nodes, so the space complexity remains <span class="math inline">\(O(n)\)</span>. However, this approach optimizes the space usage compared to using two stacks.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-morris-traversal-no-stack">Approach 5: Morris Traversal (No stack)</h3>
<h4 id="intuition-4">Intuition</h4>
<p>All the approaches so far have been using some auxiliary space. To optimize for space complexity, we can use a traversal algorithm called Morris traversal. In Morris traversal, the tree structure is temporarily modified to create temporary links that simulate the effect of a stack or recursion. As a result, there is no overhead from additional data structures and the space complexity is constant. This traversal is tricky to understand at first, but the high level idea is to link each predecessor back to the current node, which allows us to trace back to the top of the tree. We encourage you to simulate the traversal on a piece of paper to get a stronger understanding.</p>
<p>In setting up Morris traversal, we introduce a <code>dummyNode</code> with a value that is not part of the original tree and link it to the root. Our traversal begins with this dummyNode, treating it as the new root of the tree.</p>
<p>For each node, we look for its in-order predecessor, the rightmost node in its left subtree. We do this so that the in-order predecessor can be used to create a temporary link back to the current node, simulating the recursive call stack.</p>
<ul>
<li>If the current node has a left child, we find the rightmost node in the left subtree. This rightmost node is the in-order predecessor.</li>
<li>We then create a temporary link from this predecessor to the current node by setting its right pointer to the current node.</li>
</ul>
<p>If the predecessorâ€™s right pointer is <code>null</code>, set it to point to the current node and move to the left child. This simulates the recursive call by allowing us to return to the current node after processing the left subtree.</p>
<p>When a nodeâ€™s predecessorâ€™s right pointer points back to the current node, it indicates the left subtree is processed. Process the current node and reverse the temporary link to restore the treeâ€™s structure.</p>
<p>Finally, move to the right child and continue the traversal.</p>
<p>Morris traversal operates in <span class="math inline">\(O(n)\)</span> time because finding the predecessor is not done for every node but only for nodes with a valid left child.</p>
<blockquote>
<p>Note: Morris traversal may be a surprise topic in interviews. Itâ€™s useful to know but not always the main focus; prioritize understanding basic traversal methods first.</p>
</blockquote>
<h4 id="algorithm-4">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list and create a dummy node with the value <code>-1</code>. Set <code>dummyNode-&gt;left</code> to <code>root</code> and update <code>root</code> to <code>dummyNode</code>.</li>
<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>
<li>While <code>root</code> is not <code>null</code>:
<ul>
<li>If <code>root-&gt;left</code> is not <code>null</code>, find the rightmost node (predecessor) in the <code>root-&gt;left</code> subtree.</li>
<li>If the right child of the predecessor is <code>null</code>, set the right child to <code>root</code> and move <code>root</code> to <code>root-&gt;left</code>.</li>
<li>If the right child of the predecessor is <code>root</code>, perform reverse traversal of the <code>root-&gt;left</code> subtree and add values to <code>result</code>.</li>
<li>Reverse the subtree back to its original state by restoring pointers.</li>
<li>Remove the temporary link from the predecessor to <code>root</code> and move <code>root</code> to <code>root-&gt;right</code>.</li>
<li>If <code>root-&gt;left</code> is <code>null</code>, move <code>root</code> to <code>root-&gt;right</code>.</li>
</ul>
</li>
<li>Return the <code>result</code> list containing postorder traversal values.</li>
</ol>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/XKjo3KQc/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is visited a constant number of times, and the traversal through the tree is linear in terms of <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The Morris Traversal technique uses no extra space beyond the pointers used for traversal. The temporary modifications to the tree structure are reversed before the traversal ends, so the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-tree</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" style="width: 200px; height: 264px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,4,5,6,7,3,8,9]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" style="width: 350px; height: 286px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/brace-expansion-ii/description" target="_blank" rel="noopener noreferrer">Brace Expansion II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Under the grammar given below, strings can represent a set of lowercase words. Let&nbsp;<code>R(expr)</code>&nbsp;denote the set of words the expression represents.</p>

<p>The grammar can best be understood through simple examples:</p>

<ul>
	<li>Single letters represent a singleton set containing that word.
	<ul>
		<li><code>R(&quot;a&quot;) = {&quot;a&quot;}</code></li>
		<li><code>R(&quot;w&quot;) = {&quot;w&quot;}</code></li>
	</ul>
	</li>
	<li>When we take a comma-delimited list of two or more expressions, we take the union of possibilities.
	<ul>
		<li><code>R(&quot;{a,b,c}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code></li>
		<li><code>R(&quot;{{a,b},{b,c}}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code> (notice the final set only contains each word at most once)</li>
	</ul>
	</li>
	<li>When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.
	<ul>
		<li><code>R(&quot;{a,b}{c,d}&quot;) = {&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;}</code></li>
		<li><code>R(&quot;a{b,c}{d,e}f{g,h}&quot;) = {&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;}</code></li>
	</ul>
	</li>
</ul>

<p>Formally, the three rules for our grammar:</p>

<ul>
	<li>For every lowercase letter <code>x</code>, we have <code>R(x) = {x}</code>.</li>
	<li>For expressions <code>e<sub>1</sub>, e<sub>2</sub>, ... , e<sub>k</sub></code> with <code>k &gt;= 2</code>, we have <code>R({e<sub>1</sub>, e<sub>2</sub>, ...}) = R(e<sub>1</sub>) &cup; R(e<sub>2</sub>) &cup; ...</code></li>
	<li>For expressions <code>e<sub>1</sub></code> and <code>e<sub>2</sub></code>, we have <code>R(e<sub>1</sub> + e<sub>2</sub>) = {a + b for (a, b) in R(e<sub>1</sub>) &times; R(e<sub>2</sub>)}</code>, where <code>+</code> denotes concatenation, and <code>&times;</code> denotes the cartesian product.</li>
</ul>

<p>Given an expression representing a set of words under the given grammar, return <em>the sorted list of words that the expression represents</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;{a,b}{c,{d,e}}&quot;
<strong>Output:</strong> [&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;{{a,z},a{b,c},{ab,z}}&quot;
<strong>Output:</strong> [&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;]
<strong>Explanation:</strong> Each distinct word is written only once in the final answer.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 60</code></li>
	<li><code>expression[i]</code> consists of <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;,&#39;</code>or lowercase English letters.</li>
	<li>The given&nbsp;<code>expression</code>&nbsp;represents a set of words based on the grammar given in the description.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/build-an-array-with-stack-operations/description" target="_blank" rel="noopener noreferrer">Build an Array With Stack Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>target</code> and an integer <code>n</code>.</p>

<p>You have an empty stack with the two following operations:</p>

<ul>
	<li><strong><code>&quot;Push&quot;</code></strong>: pushes an integer to the top of the stack.</li>
	<li><strong><code>&quot;Pop&quot;</code></strong>: removes the integer on the top of the stack.</li>
</ul>

<p>You also have a stream of the integers in the range <code>[1, n]</code>.</p>

<p>Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to <code>target</code>. You should follow the following rules:</p>

<ul>
	<li>If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.</li>
	<li>If the stack is not empty, pop the integer at the top of the stack.</li>
	<li>If, at any moment, the elements in the stack (from the bottom to the top) are equal to <code>target</code>, do not read new integers from the stream and do not do more operations on the stack.</li>
</ul>

<p>Return <em>the stack operations needed to build </em><code>target</code> following the mentioned rules. If there are multiple valid answers, return <strong>any of them</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = [1,3], n = 3
<strong>Output:</strong> [&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]
<strong>Explanation:</strong> Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Pop the integer on the top of the stack. s = [1].
Read 3 from the stream and push it to the stack. s = [1,3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = [1,2,3], n = 3
<strong>Output:</strong> [&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]
<strong>Explanation:</strong> Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Read 3 from the stream and push it to the stack. s = [1,2,3].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> target = [1,2], n = 4
<strong>Output:</strong> [&quot;Push&quot;,&quot;Push&quot;]
<strong>Explanation:</strong> Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.
The answers that read integer 3 from the stream are not accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= target.length &lt;= 100</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= target[i] &lt;= n</code></li>
	<li><code>target</code> is strictly increasing.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-simulate">Approach: Simulate</h3>
<p><strong>Intuition</strong></p>
<p>In this problem, we are given two stack operations:</p>
<ul>
<li>Push a number to the stack</li>
<li>Pop off the top of the stack</li>
</ul>
<p>The numbers that we push to the stack are ordered from <code>1</code> to <code>n</code>. Each number is available only once, so if we pop a number from the stack, that number is permanently gone. This means we want to pop every number that does not appear in <code>target</code> and should never pop any number that does appear in <code>target</code>.</p>
<p>We stop once the stack is equal to <code>target</code> and we are allowed to return any valid answer. Because <code>target</code> is always sorted and the stream of numbers always comes in ascending order, we can build <code>target</code> one element at a time, starting with the first element.</p>
<p>Let's use an integer <code>i</code> that represents the most recently pushed number. Initially, <code>i = 0</code> as no numbers have been pushed yet.</p>
<p><img src="../Figures/1441/1.png" alt="example" /><br />
<br></p>
<p>In this example, the first number we need to reach in <code>target</code> is <code>3</code>. Before we can reach <code>3</code>, we need to go through <code>1, 2</code>. However, we don't want either <code>1</code> or <code>2</code> in the answer, so we can immediately pop <code>1</code> after pushing it, and pop <code>2</code> after pushing it. Essentially, we are only pushing them to move forward until we reach <code>3</code>.</p>
<p><img src="../Figures/1441/2.png" alt="example" /><br />
<br></p>
<p><img src="../Figures/1441/3.png" alt="example" /><br />
<br></p>
<p>Now, we are ready to push <code>3</code>, so we do so.</p>
<p><img src="../Figures/1441/4.png" alt="example" /><br />
<br></p>
<p>To get to the next number <code>6</code>, we must first go through <code>4, 5</code>. Again, we don't want either <code>4</code> or <code>5</code> in the answer, so we can immediately pop <code>4</code> after pushing it, and pop <code>5</code> after pushing it.</p>
<p><img src="../Figures/1441/5.png" alt="example" /><br />
<br></p>
<p><img src="../Figures/1441/6.png" alt="example" /><br />
<br></p>
<p>Now, we are ready to push <code>6</code>, so we do so.</p>
<p><img src="../Figures/1441/7.png" alt="example" /><br />
<br></p>
<p>We continue this process for each number in <code>target</code>. This brings us to our solution. We iterate over each <code>num</code> in <code>target</code>:</p>
<ul>
<li>We push and immediately pop the current number, then increment <code>i</code>, and repeat the process until we are ready to push <code>num</code>.</li>
<li>When are we ready to push <code>num</code>? Recall that <code>i</code> represents the most recently pushed number. Thus, we are ready to push <code>num</code> when the most recently pushed number is <code>i = num - 1</code>.</li>
<li>Once we are ready, we simply push and increment <code>i</code>.</li>
</ul>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize the answer <code>ans</code> and the integer <code>i = 0</code>.</li>
<li>For each <code>num</code> in <code>target</code>:
<ul>
<li>While <code>i &lt; num - 1</code>:
<ul>
<li>Add <code>&quot;Push&quot;</code> to <code>ans</code>.</li>
<li>Add <code>&quot;Pop&quot;</code> to <code>ans</code>.</li>
<li>Increment <code>i</code>.</li>
</ul>
</li>
<li>Add <code>&quot;Push&quot;</code> to <code>ans</code>.</li>
<li>Increment <code>i</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8EWijpYD/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Let <code>k</code> denote the largest (final) element in <code>target</code>. We push (and maybe pop) every number from <code>1</code> until <code>k</code>. This gives us a maximum of <span class="math inline">\(2k\)</span> operations. In the worst case scenario, <code>k = n</code>, which gives us a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We don't count the answer as part of the space complexity. Thus, we aren't using any extra space other than the integer <code>i</code>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/car-fleet/description" target="_blank" rel="noopener noreferrer">Car Fleet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cars at given miles away from the starting mile 0, traveling to reach the mile <code>target</code>.</p>

<p>You are given two integer array <code>position</code> and <code>speed</code>, both of length <code>n</code>, where <code>position[i]</code> is the starting mile of the <code>i<sup>th</sup></code> car and <code>speed[i]</code> is the speed of the <code>i<sup>th</sup></code> car in miles per hour.</p>

<p>A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.</p>

<p>A <strong>car fleet</strong> is a car or cars driving next to each other. The speed of the car fleet is the <strong>minimum</strong> speed of any car in the fleet.</p>

<p>If a car catches up to a car fleet at the mile <code>target</code>, it will still be considered as part of the car fleet.</p>

<p>Return the number of car fleets that will arrive at the destination.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at <code>target</code>.</li>
	<li>The car starting at 0 (speed 1) does not catch up to any other car, so it is a fleet by itself.</li>
	<li>The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches <code>target</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">target = 10, position = [3], speed = [3]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>
There is only one car, hence there is only one fleet.</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">target = 100, position = [0,2,4], speed = [4,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The car starting at 4 (speed 1) travels to 5.</li>
	<li>Then, the fleet at 4 (speed 2) and the car at position 5 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches <code>target</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == position.length == speed.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt; target &lt;= 10<sup>6</sup></code></li>
	<li><code>0 &lt;= position[i] &lt; target</code></li>
	<li>All the values of <code>position</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/car-fleet-ii/description" target="_blank" rel="noopener noreferrer">Car Fleet II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">math</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cars traveling at different speeds in the same direction along a one-lane road. You are given an array <code>cars</code> of length <code>n</code>, where <code>cars[i] = [position<sub>i</sub>, speed<sub>i</sub>]</code> represents:</p>

<ul>
	<li><code>position<sub>i</sub></code> is the distance between the <code>i<sup>th</sup></code> car and the beginning of the road in meters. It is guaranteed that <code>position<sub>i</sub> &lt; position<sub>i+1</sub></code>.</li>
	<li><code>speed<sub>i</sub></code> is the initial speed of the <code>i<sup>th</sup></code> car in meters per second.</li>
</ul>

<p>For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the <strong>slowest</strong> car in the fleet.</p>

<p>Return an array <code>answer</code>, where <code>answer[i]</code> is the time, in seconds, at which the <code>i<sup>th</sup></code> car collides with the next car, or <code>-1</code> if the car does not collide with the next car. Answers within <code>10<sup>-5</sup></code> of the actual answers are accepted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cars = [[1,2],[2,1],[4,3],[7,2]]
<strong>Output:</strong> [1.00000,-1.00000,3.00000,-1.00000]
<strong>Explanation:</strong> After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cars = [[3,4],[5,4],[6,3],[9,1]]
<strong>Output:</strong> [2.00000,1.00000,1.50000,-1.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= cars.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= position<sub>i</sub>, speed<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li><code>position<sub>i</sub> &lt; position<sub>i+1</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/description" target="_blank" rel="noopener noreferrer">Check if a Parentheses String Can Be Valid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A parentheses string is a <strong>non-empty</strong> string consisting only of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>:</p>

<ul>
	<li>It is <code>()</code>.</li>
	<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid parentheses strings.</li>
	<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid parentheses string.</li>
</ul>

<p>You are given a parentheses string <code>s</code> and a string <code>locked</code>, both of length <code>n</code>. <code>locked</code> is a binary string consisting only of <code>&#39;0&#39;</code>s and <code>&#39;1&#39;</code>s. For <strong>each</strong> index <code>i</code> of <code>locked</code>,</p>

<ul>
	<li>If <code>locked[i]</code> is <code>&#39;1&#39;</code>, you <strong>cannot</strong> change <code>s[i]</code>.</li>
	<li>But if <code>locked[i]</code> is <code>&#39;0&#39;</code>, you <strong>can</strong> change <code>s[i]</code> to either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>
</ul>

<p>Return <code>true</code> <em>if you can make <code>s</code> a valid parentheses string</em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/06/eg1.png" style="width: 311px; height: 101px;" />
<pre>
<strong>Input:</strong> s = &quot;))()))&quot;, locked = &quot;010100&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> locked[1] == &#39;1&#39; and locked[3] == &#39;1&#39;, so we cannot change s[1] or s[3].
We change s[0] and s[4] to &#39;(&#39; while leaving s[2] and s[5] unchanged to make s valid.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;()()&quot;, locked = &quot;0000&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> We do not need to make any changes because s is already valid.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;)&quot;, locked = &quot;0&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> locked permits us to change s[0]. 
Changing s[0] to either &#39;(&#39; or &#39;)&#39; will not make s valid.
</pre>

<p><strong class="example">Example 4:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(((())(((())&quot;, locked = &quot;111111010111&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> locked permits us to change s[6] and s[8]. 
We change s[6] and s[8] to &#39;)&#39; to make s valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == s.length == locked.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>
	<li><code>locked[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two strings, <code>s</code> and <code>locked</code>. The string <code>s</code> is a sequence of parentheses, consisting of opening brackets <code>(</code> and closing brackets <code>)</code>. The string locked is a binary string of the same length as <code>s</code>, where:</p>
<ul>
<li>
<p>If <code>locked[i]</code> is 1, the character at index <code>i</code> in <code>s</code> cannot be changed.</p>
</li>
<li>
<p>If <code>locked[i]</code> is 0, the character can be modified: an opening bracket <code>(</code> can become a closing bracket <code>)</code> and vice versa.</p>
</li>
</ul>
<p>Our task is to determine if itâ€™s possible to make the sequence in <code>s</code> balanced by modifying the characters marked as changeable (<code>locked[i] = 0</code>).</p>
<p>What does a balanced parentheses sequence mean?</p>
<p>A sequence of parentheses is considered balanced if:</p>
<ol>
<li>Every opening bracket <code>(</code> has a corresponding closing bracket <code>)</code>.</li>
<li>The brackets are properly nested. For example, <code>(())</code> is balanced, but <code>())(</code> is not.</li>
</ol>
<p>To gain familiarity with similar parentheses-based problems, you may first solve an easier version: <a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a>.</p>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>To get a good intuition to this problem, we need to ensure that at any point while iterating through <code>s</code>, the number of closing brackets <code>)</code> should not exceed the number of opening brackets <code>(</code> and by the end of the string, the total number of opening and closing brackets must be equal.</p>
<p>Observe that the locked characters (<code>locked[i] = 1</code>) cannot be modified, so they must remain fixed. However, we have the flexibility to assign the unlocked characters (<code>locked[i] = 0</code>) as either opening or closing brackets, depending on what is needed to maintain balance.</p>
<p>The main challenge is that if at any point the number of closing brackets exceeds the number of opening brackets and there are no unlocked characters available to &quot;fix&quot; the imbalance, itâ€™s impossible to balance the string, and we return false.</p>
<p>And to address this, we need a way to keep track of all previously encountered unlocked characters so we can use them later if needed. Thus a stack is a suitable data structure for this, because it follows the Last In, First Out (LIFO) principle, which works well for keeping track of unmatched brackets.</p>
<p>To implement this, we iterate through the string, whenever we encounter an unlocked character (locked[i] = 0), we push its index onto the stack.</p>
<p>If we encounter a closing bracket <code>)</code> and find that the number of closing brackets exceeds the number of opening brackets at that point, we can &quot;fix&quot; the imbalance by popping an index from the stack and treating that unlocked character as an opening bracket <code>(</code>.</p>
<p>If at any point we need an unlocked character to balance the string but the stack is empty (i.e., there are no more unlocked characters left), it means balancing the string is impossible, and we return false.</p>
<p>After processing all the characters in the string:</p>
<ul>
<li>If the stack still contains indices of unused unlocked characters, we can pair them up to form balanced brackets, such as <code>()()()</code>.</li>
<li>As long as the number of opening and closing brackets is equal by the end, the string is balanced, and we return true.</li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>If the length of the string <code>s</code> is odd, return <code>false</code> because an odd-length string cannot have balanced parentheses.</p>
</li>
<li>
<p>Use a stack <code>openBrackets</code> to keep track of the indices of open parentheses <code>'('</code> in the locked positions and a stack <code>unlocked</code> to keep track of the indices of positions where parentheses can be changed (<code>locked[i] == '0'</code>).</p>
</li>
<li>
<p>For each character in the string <code>s</code>, check:</p>
<ul>
<li>If the position is unlocked (i.e., <code>locked[i] == '0'</code>), add its index to the <code>unlocked</code> stack.</li>
<li>If the character is an open parenthesis <code>'('</code>, add its index to the <code>openBrackets</code> stack.</li>
<li>If the character is a close parenthesis <code>')'</code>:
<ul>
<li>If there is a matching open parenthesis (i.e., the <code>openBrackets</code> stack is not empty), pop the stack.</li>
<li>If no open parenthesis is available, try to use an unlocked position and pop the <code>unlocked</code> stack to match with it.</li>
<li>If neither an open parenthesis nor an unlocked position is available to match, return <code>false</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After processing all characters, check if there are any unmatched open parentheses remaining in the <code>openBrackets</code> stack.</p>
<ul>
<li>If there are unmatched open parentheses, try to match them with the available unlocked positions and pop the stacks.</li>
<li>If any open parentheses remain unmatched, return <code>false</code>. Otherwise, return <code>true</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/errfNJRc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs two passes over the string <code>s</code>:</p>
<ol>
<li>In the first pass, it iterates through the string to process open brackets and unlocked positions, which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>In the second pass, it matches the remaining open brackets with unlocked characters, which also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ol>
<p>Therefore, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses two stacks, <code>openBrackets</code> and <code>unlocked</code>, to store indices of open brackets and unlocked characters, respectively. In the worst case, each list can store up to <span class="math inline">\(n\)</span> elements.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-constant-space">Approach 2: Constant Space</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a stack to store the unlocked characters and open brackets in the order they appear in the string. However, do we actually need a stack, or is a simple count of the unlocked characters and open brackets sufficient?</p>
<p>The stack indices are required when matching the remaining opening brackets with the unlocked characters, as shown in the code snippet below:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Match remaining open brackets with unlocked characters
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">while</span> (<span style="color:#000;font-weight:bold">!</span>openBrackets.empty() <span style="color:#000;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">!</span>unlocked.empty() <span style="color:#000;font-weight:bold">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>       openBrackets.top() <span style="color:#000;font-weight:bold">&lt;</span> unlocked.top()) {
</span></span><span style="display:flex;"><span>    openBrackets.pop();
</span></span><span style="display:flex;"><span>    unlocked.pop();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>To address this, we could explore a trick to match the brackets using only the counts of the unpaired opening brackets and unlocked characters.</p>
<p>Since we want to balance the remaining opening brackets, note that the unlocked characters towards the end of the string can be converted into closing brackets to pair them up. This allows us to iterate from the end of the string <code>s</code> while maintaining a <code>balance</code> variable to check whether the parentheses are balanced.</p>
<p>We use the integer counters <code>openBrackets</code> and <code>unlocked</code> from the previous steps:</p>
<ul>
<li>If we encounter an unlocked character, we can treat it as a closing bracket.</li>
<li>If the <code>balance</code> variable indicates that the string is unbalanced at any point, we return <code>false</code>.</li>
</ul>
<p>Finally, if all the <code>openBrackets</code> are balanced by the end of the iteration, we can return <code>true</code>. Otherwise, we return <code>false</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize <code>length</code> as the size of the string <code>s</code>.</p>
</li>
<li>
<p>Check if the <code>length</code> is odd:</p>
<ul>
<li>If <code>length % 2 == 1</code>, return <code>false</code>.</li>
</ul>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>openBrackets</code> to count the unmatched opening brackets.</li>
<li><code>unlocked</code> to count the wildcard positions.</li>
</ul>
</li>
<li>
<p>Perform a forward pass to process the string:</p>
<ul>
<li>Iterate through <code>s</code> from left to right.</li>
<li>For each character:
<ul>
<li>If <code>locked[i] == '0'</code>, increment <code>unlocked</code>.</li>
<li>If <code>s[i] == '('</code>, increment <code>openBrackets</code>.</li>
<li>If <code>s[i] == ')'</code>:
<ul>
<li>If <code>openBrackets &gt; 0</code>, decrement <code>openBrackets</code>.</li>
<li>Else if <code>unlocked &gt; 0</code>, decrement <code>unlocked</code>.</li>
<li>Else, return <code>false</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform a reverse pass to match remaining open brackets:</p>
<ul>
<li>Initialize <code>balance</code> to track excess unmatched opening brackets.</li>
<li>Iterate through <code>s</code> from right to left.</li>
<li>For each character:
<ul>
<li>If <code>locked[i] == '0'</code>, decrement <code>balance</code> and <code>unlocked</code>.</li>
<li>If <code>s[i] == '('</code>, increment <code>balance</code> and decrement <code>openBrackets</code>.</li>
<li>If <code>s[i] == ')'</code>, decrement <code>balance</code>.</li>
<li>If <code>balance &gt; 0</code>, return <code>false</code>.</li>
<li>If <code>unlocked == 0</code> and <code>openBrackets == 0</code>, break out of the loop.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After the reverse pass:</p>
<ul>
<li>If <code>openBrackets &gt; 0</code>, return <code>false</code>.</li>
</ul>
</li>
<li>
<p>Return <code>true</code> if no unmatched brackets remain.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZeCXSCZx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs two passes over the string <code>s</code>:</p>
<ol>
<li>In the first pass, it iterates through the string to process open brackets and unlocked positions, which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>In the second pass, it iterates from the end of the string to balance the remaining open brackets with unlocked characters, which also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ol>
<p>Therefore, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of space for variables like <code>openBrackets</code>, <code>unlocked</code>, and <code>balance</code>. It does not use any additional data structures such as stacks or lists.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-word-is-valid-after-substitutions/description" target="_blank" rel="noopener noreferrer">Check If Word Is Valid After Substitutions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, determine if it is <strong>valid</strong>.</p>

<p>A string <code>s</code> is <strong>valid</strong> if, starting with an empty string <code>t = &quot;&quot;</code>, you can <strong>transform </strong><code>t</code><strong> into </strong><code>s</code> after performing the following operation <strong>any number of times</strong>:</p>

<ul>
	<li>Insert string <code>&quot;abc&quot;</code> into any position in <code>t</code>. More formally, <code>t</code> becomes <code>t<sub>left</sub> + &quot;abc&quot; + t<sub>right</sub></code>, where <code>t == t<sub>left</sub> + t<sub>right</sub></code>. Note that <code>t<sub>left</sub></code> and <code>t<sub>right</sub></code> may be <strong>empty</strong>.</li>
</ul>

<p>Return <code>true</code> <em>if </em><code>s</code><em> is a <strong>valid</strong> string, otherwise, return</em> <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabcbc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong>
&quot;&quot; -&gt; &quot;<u>abc</u>&quot; -&gt; &quot;a<u>abc</u>bc&quot;
Thus, &quot;aabcbc&quot; is valid.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcabcababcc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong>
&quot;&quot; -&gt; &quot;<u>abc</u>&quot; -&gt; &quot;abc<u>abc</u>&quot; -&gt; &quot;abcabc<u>abc</u>&quot; -&gt; &quot;abcabcab<u>abc</u>c&quot;
Thus, &quot;abcabcababcc&quot; is valid.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abccba&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to get &quot;abccba&quot; using the operation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of letters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/check-mirror-in-n-ary-tree1528/1" target="_blank" rel="noopener noreferrer">Check Mirror in N-ary tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given two <strong>n</strong>-ary trees.&nbsp;Check if they are mirror images of each other or not. You are also given <strong>e</strong> denoting the number of edges in both trees, and two arrays, <strong>A[] </strong>and<strong> </strong><strong>B[]</strong>. </span> <span style="font-size:18px">Each array has&nbsp;2*e space separated values u,v denoting an edge from u to v for the both trees.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>n = </strong>3, <strong>e = </strong>2</span>
<span style="font-size:18px"><strong>A[] = </strong>{1, 2, 1, 3}</span>
<span style="font-size:18px"><strong>B[] = </strong>{1, 3, 1, 2}</span>
<span style="font-size:18px"><strong>Output:
</strong>1</span>
<span style="font-size:18px"><strong>Explanation:
</strong></span>   <span style="font-size:18px">1          1
 / \        /  \
2   3      3    2</span> 
<span style="font-size:18px">As we can clearly see, the second tree
is mirror image of the first.</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>n = </strong>3, <strong>e = </strong>2</span>
<span style="font-size:18px"><strong>A[] = </strong>{1, 2, 1, 3}</span>
<span style="font-size:18px"><strong>B[] = </strong>{1, 2, 1, 3}</span>
<span style="font-size:18px"><strong>Output:
</strong>0</span>
<span style="font-size:18px"><strong>Explanation:
</strong></span>   <span style="font-size:18px">1          1
 / \        /  \
2   3      2    3</span> 
<span style="font-size:18px">As we can clearly see, the second tree
isn&#39;t mirror image of the first.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>checkMirrorTree()</strong> which takes 2 Integers n, and e;&nbsp; and two arrays A[] and B[] of size 2*e as input and returns 1 if the trees are mirror images of each other and 0 if not.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(e)<br />
<strong>Expected Auxiliary Space:</strong> O(e)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong></span><br />
<span style="font-size:18px">1 &lt;= n,e &lt;= 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/clear-digits/description" target="_blank" rel="noopener noreferrer">Clear Digits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>.</p>

<p>Your task is to remove <strong>all</strong> digits by doing this operation repeatedly:</p>

<ul>
	<li>Delete the <em>first</em> digit and the <strong>closest</strong> <b>non-digit</b> character to its <em>left</em>.</li>
</ul>

<p>Return the resulting string after removing all digits.</p>

<p><strong>Note</strong> that the operation <em>cannot</em> be performed on a digit that does not have any non-digit character to its left.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;abc&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no digit in the string.<!-- notionvc: ff07e34f-b1d6-41fb-9f83-5d0ba3c1ecde --></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;cb34&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>First, we apply the operation on <code>s[2]</code>, and <code>s</code> becomes <code>&quot;c4&quot;</code>.</p>

<p>Then we apply the operation on <code>s[1]</code>, and <code>s</code> becomes <code>&quot;&quot;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists only of lowercase English letters and digits.</li>
	<li>The input is generated such that it is possible to delete all digits.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> containing letters and digits. Our task is to perform the following operations on every digit of the string:</p>
<ol>
<li>Remove the digit.</li>
<li>Remove the last non-digit character to the left of the digit.</li>
</ol>
<p>As we iterate through each digit in the string and apply these operations, we end up removing all digits along with some non-digit characters. In the end, we will return the final string, after processing and removing all digits.</p>
<blockquote>
<p>According to the problem's constraints, it will always be possible to remove all digits, meaning that every digit will have a corresponding non-digit character on the left.</p>
</blockquote>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>In this approach, we will simply simulate the described process until we have removed all digits from <code>s</code>.</p>
<p>An important observation is that as we process the string from left to right and remove digits, the part of the string we've already processed will only contain non-digit characters (or be empty). This means that the first non-digit character to the left of the current digit will always be the one immediately before it.</p>
<p>With this in mind, we iterate over the characters of <code>s</code> with <code>charIndex</code> from <code>0</code> to <code>s.length - 1</code>. When we encounter a digit, we remove both the digit and the non-digit character immediately before it. A key detail in the implementation is that after deleting a character, we should not increment the <code>charIndex</code>, as the next character will shift to the current position. Similarly, when deleting two characters, we should decrement the <code>charIndex</code> by <code>1</code>, as the next character to process will shift to one position left from the current one.</p>
<blockquote>
<p>To check whether the current character is a digit in the implementations below, we will use the provided built-in functions. Alternatively, we could create a custom function that checks whether the ASCII value of the character falls between the ASCII values of <code>'0'</code> and <code>'9'</code>.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>charIndex</code> to <code>0</code>.</li>
<li>While <code>charIndex</code> is less than the current length of <code>s</code>:
<ul>
<li>If the character at <code>charIndex</code> is a digit:
<ul>
<li>Remove the digit at <code>charIndex</code>.</li>
<li>Remove the character at <code>charIndex - 1</code>.</li>
<li>Decrement <code>charIndex</code> by <code>1</code> to account for the removed character.</li>
</ul>
</li>
<li>Otherwise, if the character at <code>charIndex</code> is not a digit:
<ul>
<li>Move to the next character by incrementing <code>charIndex</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the modified string <code>s</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/hSY8duQu/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code> and <span class="math inline">\(m\)</span> the number of digit characters in it.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \times m)\)</span> or <span class="math inline">\(O(n ^ 2)\)</span>.</p>
<p>For each digit character, we perform one or two &quot;erase&quot; operations, each with time complexity <span class="math inline">\(O(n)\)</span>. Therefore, processing <span class="math inline">\(m\)</span> digits takes <span class="math inline">\(O(n \times m)\)</span>. Non-digit characters are skipped and contribute <span class="math inline">\(O((n - m) \times 1)\)</span> checks, which is <span class="math inline">\(O(n)\)</span>. Since <span class="math inline">\(m \leq n\)</span> the overall time complexity can be expressed as <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>Excluding the input string (which does not count toward the auxiliary space complexity), we only use a single variable (<code>charIndex</code>) to track the current character's position in the string. Therefore, the space complexity of the algorithm is <span class="math inline">\(O(1)\)</span>.</p>
<blockquote>
<p>In Java, we use a StringBuilder to store a copy of the input string and perform all operations on it. Therefore, the space complexity for this implementation is <span class="math inline">\(O(n)\)</span>.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-2-stack-like">Approach 2: Stack-Like</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we saw, the main issue with the brute-force approach was the repeated 'erase' operations on the input string, which added a factor of <span class="math inline">\(n\)</span> to the algorithm's time complexity.</p>
<p>To avoid this, instead of modifying the input, we construct the answer from scratch as we iterate over the characters of <code>s</code>:</p>
<ul>
<li>When we encounter a non-digit character, we add it to the end of the answer, as it should appear in the final string unless a digit later removes it.</li>
<li>When we encounter a digit, we do not add it to the final answer. Additionally, we remove the last character from the answer, as this is the last non-digit character to the left of the current digit.</li>
</ul>
<p>The main difference to the previous approach is that removing the last character from a string takes constant time, whereas removing a character from an arbitrary position requires <span class="math inline">\(O(n)\)</span> time.</p>
<blockquote>
<p>In Java, we declare the answer string as a <code>StringBuilder</code>. This is essential for improving time complexity, as removing the last character from a regular String is still a <span class="math inline">\(O(n)\)</span> operation. Similarly, in Python we will use a list to take advantage of the <span class="math inline">\(O(1)\)</span> pop operation.</p>
</blockquote>
<p>In this approach, we essentially treat the answer string like a stack. We push non-digit characters onto it, and we may remove some from the end as we process the string. The key idea is that we only remove the most recently added characters, ensuring that we never need to remove a character that was added before another character that hasn't been removed yet.</p>
<blockquote>
<p>For a more comprehensive understanding of Stacks, check out the <a href="https://leetcode.com/explore/featured/card/queue-stack/">Stack Explore Card ðŸ”—</a>. This resource provides an in-depth look at stacks, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>!?!../Documents/3174/3174_approach2_fix.json:960,540!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>answer</code> to an empty string.</li>
<li>Iterate over <code>s</code> with <code>charIndex</code> from <code>0</code> to <code>s.length - 1</code>:
<ul>
<li>If the character at <code>charIndex</code> is a digit:
<ul>
<li>Remove the last character from <code>answer</code>.</li>
</ul>
</li>
<li>Otherwise, if the character at <code>charIndex</code> is not a digit:
<ul>
<li>Add it to the end of the <code>answer</code> string.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>answer</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/k5UkNpaX/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We iterate over all characters in <code>s</code> and perform constant-time operations, including checks and either removing the last character of the <code>answer</code> string or adding the current character to the end of it. Therefore, the total time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>In the C++ implementation, we only need a single variable, <code>charIndex</code>, to track the position of the current character in <code>s</code>. Consequently, the algorithm uses constant (<span class="math inline">\(O(1)\)</span>) extra space.</p>
<p>On the other hand, the Java and Python implementations require additional structures (such as a list or a StringBuilder), to simulate stack operations. Since these structures are neither part of the input nor the output of the algorithm, they contribute to its auxiliary space complexity. This complexity is <span class="math inline">\(O(n)\)</span>, as these structures can grow to at most the size of the input string.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-in-place">Approach 3: In-place</h3>
<h4 id="intuition-2">Intuition</h4>
<p>One big advantage of the previous approach is that it does not change the input string. This is helpful in situations where the input is passed by reference (like in Java) and the algorithm runs in a multithreaded environment or when the input needs to be used again after the function call. In these cases, algorithms that modify the input directly should be avoided.</p>
<p>However, when this is not the case, modifying the input can be more space-efficient. In such cases, in-place algorithms like the one weâ€™ll discuss here can be good alternatives.</p>
<p>So, in this approach we will integrate the &quot;stack&quot; logic directly into the input string. Instead of pushing non-digit characters into a separate structure, we overwrite the input string in place so that non-digit characters are positioned exactly where they will appear in the final result.</p>
<p>To achieve this, we use a variable <code>answerLength</code> to track the current length of the result. When adding a new character, we place it at the <code>answerLength</code> position in the string and increase <code>answerLength</code> by <code>1</code>. When removing a character, we decrease <code>answerLength</code> by <code>1</code>, which effectively makes the last character irrelevant and ready to be overwritten.</p>
<p>At the end, the result is the prefix of the modified input string up to <code>answerLength</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>answerLength</code> to <code>0</code>.</li>
<li>Iterate over <code>s</code> with <code>charIndex</code> from <code>0</code> to <code>s.length - 1</code>:
<ul>
<li>If the character at <code>charIndex</code> is a digit:
<ul>
<li>Decrement <code>answerLength</code> by <code>1</code>.</li>
</ul>
</li>
<li>Otherwise, if the character at <code>charIndex</code> is not a digit:
<ul>
<li>Add it to the end of the answer, by setting <code>s[answerLength] = s[charIndex]</code>.</li>
<li>Increment <code>answerLength</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the first <code>answerLength</code> characters of the modified string <code>s</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/mE87b9bk/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>Like in the previous approach, we iterate over all characters in <code>s</code> and perform constant-time operations, including checks and retrievals of characters in a string. Additionally, the &quot;resize&quot; operation on the string requires <span class="math inline">\(O(n)\)</span> time and therefore the total time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>As the input string does not count as auxiliary space, the C++ implementation requires only constant extra space for the variables <code>answerLength</code> and <code>charIndex</code>.</p>
<p>However, the Java and Python implementations require additional structures (such as a list or a charArray), as they do not provide mutable strings. Since these structures are neither part of the input nor the output of the algorithm, they contribute to its auxiliary space complexity, which is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/clone-a-stack-without-usinig-extra-space/1" target="_blank" rel="noopener noreferrer">Clone a stack without using extra space</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given elements of a stack, clone the stack without using extra space.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong></span>:
<span style="font-size:18px">N = 10
st[] = {1, 1, 2, 2, 3, 4, 5, 5, 6, 7}
<strong>Output:</strong>
1&nbsp;</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>clonestack()</strong>&nbsp;which takes the input stack st[], an empty stack cloned[], you have to clone the stack st into stack cloned.<br />
The driver code itself prints 1 in the output if the stack st is cloned properly and prints 0 otherwise.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N*N)<br />
<strong>Expected Auxiliary Space:</strong> O(1)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N &lt;= 1000</span><br />
<span style="font-size:18px">1&lt;= st[i] &lt;= 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/clumsy-factorial/description" target="_blank" rel="noopener noreferrer">Clumsy Factorial</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>factorial</strong> of a positive integer <code>n</code> is the product of all positive integers less than or equal to <code>n</code>.</p>

<ul>
	<li>For example, <code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>.</li>
</ul>

<p>We make a <strong>clumsy factorial</strong> using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply <code>&#39;*&#39;</code>, divide <code>&#39;/&#39;</code>, add <code>&#39;+&#39;</code>, and subtract <code>&#39;-&#39;</code> in this order.</p>

<ul>
	<li>For example, <code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>.</li>
</ul>

<p>However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.</p>

<p>Additionally, the division that we use is floor division such that <code>10 * 9 / 8 = 90 / 8 = 11</code>.</p>

<p>Given an integer <code>n</code>, return <em>the clumsy factorial of </em><code>n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 7
<strong>Explanation:</strong> 7 = 4 * 3 / 2 + 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 12
<strong>Explanation:</strong> 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Construct Binary Search Tree from Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search-tree</span> <span class="topic-badge">binary-tree</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers preorder, which represents the <strong>preorder traversal</strong> of a BST (i.e., <strong>binary search tree</strong>), construct the tree and return <em>its root</em>.</p>

<p>It is <strong>guaranteed</strong> that there is always possible to find a binary search tree with the given requirements for the given test cases.</p>

<p>A <strong>binary search tree</strong> is a binary tree where for every node, any descendant of <code>Node.left</code> has a value <strong>strictly less than</strong> <code>Node.val</code>, and any descendant of <code>Node.right</code> has a value <strong>strictly greater than</strong> <code>Node.val</code>.</p>

<p>A <strong>preorder traversal</strong> of a binary tree displays the value of the node first, then traverses <code>Node.left</code>, then traverses <code>Node.right</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" style="height: 386px; width: 590px;" />
<pre>
<strong>Input:</strong> preorder = [8,5,1,7,10,12]
<strong>Output:</strong> [8,5,10,1,7,null,12]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> preorder = [1,3]
<strong>Output:</strong> [1,null,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 100</code></li>
	<li><code>1 &lt;= preorder[i] &lt;= 1000</code></li>
	<li>All the values of <code>preorder</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-smallest-number-from-di-string/description" target="_blank" rel="noopener noreferrer">Construct Smallest Number From DI String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>pattern</code> of length <code>n</code> consisting of the characters <code>&#39;I&#39;</code> meaning <strong>increasing</strong> and <code>&#39;D&#39;</code> meaning <strong>decreasing</strong>.</p>

<p>A <strong>0-indexed</strong> string <code>num</code> of length <code>n + 1</code> is created using the following conditions:</p>

<ul>
	<li><code>num</code> consists of the digits <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code>, where each digit is used <strong>at most</strong> once.</li>
	<li>If <code>pattern[i] == &#39;I&#39;</code>, then <code>num[i] &lt; num[i + 1]</code>.</li>
	<li>If <code>pattern[i] == &#39;D&#39;</code>, then <code>num[i] &gt; num[i + 1]</code>.</li>
</ul>

<p>Return <em>the lexicographically <strong>smallest</strong> possible string </em><code>num</code><em> that meets the conditions.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> pattern = &quot;IIIDIDDD&quot;
<strong>Output:</strong> &quot;123549876&quot;
<strong>Explanation:
</strong>At indices 0, 1, 2, and 4 we must have that num[i] &lt; num[i+1].
At indices 3, 5, 6, and 7 we must have that num[i] &gt; num[i+1].
Some possible values of num are &quot;245639871&quot;, &quot;135749862&quot;, and &quot;123849765&quot;.
It can be proven that &quot;123549876&quot; is the smallest possible num that meets the conditions.
Note that &quot;123414321&quot; is not possible because the digit &#39;1&#39; is used more than once.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> pattern = &quot;DDD&quot;
<strong>Output:</strong> &quot;4321&quot;
<strong>Explanation:</strong>
Some possible values of num are &quot;9876&quot;, &quot;7321&quot;, and &quot;8742&quot;.
It can be proven that &quot;4321&quot; is the smallest possible num that meets the conditions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pattern.length &lt;= 8</code></li>
	<li><code>pattern</code> consists of only the letters <code>&#39;I&#39;</code> and <code>&#39;D&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string pattern consisting of the characters <code>'I'</code> (increasing) and <code>'D'</code>. We need to construct and return in the form of a string the lexicographically smallest number that satisfies certain conditions determined by the pattern.</p>
<blockquote>
<p>The term &quot;lexicographically smallest&quot; refers to the smallest possible sequence of numbers when compared as strings. This means we need to prioritize smaller numbers in the earlier positions when constructing the sequence.</p>
</blockquote>
<p>To break down the problem, let's first understand the requirements. The pattern is a string of length <code>n</code>, where each character dictates the relationship between consecutive digits in the number. The primary goal is to satisfy the following conditions:</p>
<ul>
<li>If <code>pattern[i] == 'I'</code>, then the digit at position <code>i</code> in the number should be smaller than the digit at position <code>i + 1</code>.</li>
<li>If <code>pattern[i] == 'D'</code>, then the digit at position <code>i</code> should be larger than the digit at position <code>i + 1</code>.</li>
</ul>
<p>In other words, this means:</p>
<ul>
<li>At positions where the pattern has <code>'I'</code>, the number must increase.</li>
<li>At positions where the pattern has <code>'D'</code>, the number must decrease.</li>
</ul>
<p>The resulting number, <code>num</code>, has a length of <code>n + 1</code> because it includes one more digit than the pattern. Additionally, the digits used in the number must be distinct, ranging from <code>'1'</code> to <code>'9'</code>, meaning that each digit can appear at most once.</p>
<p>Consider the input pattern <code>&quot;IIIDIDDD&quot;</code>. One valid number that satisfies this pattern is <code>&quot;123549876&quot;</code>. Here's why:</p>
<ul>
<li>For the first three <code>'I'</code>s, the numbers must increase: <code>1 &lt; 2 &lt; 3 &lt; 5</code>.</li>
<li>At position 3, we hit a <code>'D'</code>, so the numbers must decrease: <code>5 &gt; 4</code>.</li>
<li>Then, we have another <code>'I'</code> (position 4), so the number at position 4 must be smaller than the one at position 5: <code>4 &lt; 9</code>.</li>
<li>The rest of the pattern requires a decreasing sequence at positions 5, 6, 7 and 8: <code>9 &gt; 8 &gt; 7 &gt; 6</code>.</li>
</ul>
<p>The number <code>&quot;123549876&quot;</code> is the smallest possible number that adheres to this pattern. Notably, each digit is used only once, and the number is constructed in lexicographically smallest order.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>A straightforward way to solve this problem is to generate all possible arrangements of the digits '1' to '9' and check whether any of them matches the given pattern. Since the constraints are quite small, this brute-force approach will work within the allowed time.</p>
<p>The first step is to determine whether a given sequence of numbers satisfies the pattern. To do this, we define a <code>check</code> function. This function iterates through the pattern and verifies whether each character in the pattern is correctly reflected in the corresponding numbers. If the character is <code>'I'</code>, the number at that position must be smaller than the next one, and if the character is <code>'D'</code>, the number must be greater than the next one. If at any point the sequence does not match the pattern, we return <code>false</code>. Otherwise, if the entire sequence follows the pattern correctly, we return <code>true</code>.</p>
<p>Once we can check if a sequence is valid, the next step is to generate every possible sequence and pick the smallest one that works. We start by creating a sequence of numbers from 1 to <code>n + 1</code> (where <code>n</code> is the length of the pattern) in increasing order. This gives us a unique set of numbers to work with.</p>
<p>To explore all possible orders of these numbers, we can use a built-in function, which systematically generates the next lexicographically greater arrangement of the sequence. For each permutation, we use the <code>check</code> function to verify whether it follows the given pattern. The first valid permutation that satisfies the pattern is our answer, since permutations are generated in lexicographical order, ensuring that the first valid sequence found is also the smallest one.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="check-function-pattern-validation"><code>check</code> Function (Pattern Validation):</h5>
<ul>
<li>The <code>check</code> function verifies if the given sequence matches the pattern of <code>'I'</code> (Increasing) and <code>'D'</code> (Decreasing).</li>
<li>For each character in the pattern:
<ul>
<li>If the pattern character is <code>'I'</code>, ensure that the corresponding number in the sequence is in increasing order (<code>sequence[patternIndex] &lt; sequence[patternIndex + 1]</code>).</li>
<li>If the pattern character is <code>'D'</code>, ensure that the corresponding number in the sequence is in decreasing order (<code>sequence[patternIndex] &gt; sequence[patternIndex + 1]</code>).</li>
</ul>
</li>
<li>If any mismatch is found between the sequence and the pattern, return <code>false</code>.</li>
<li>If the sequence matches the pattern for all characters, return <code>true</code>.</li>
</ul>
<h5 id="smallestnumber-function"><code>smallestNumber</code> Function:</h5>
<ul>
<li>Given a pattern string, the <code>smallestNumber</code> function returns the smallest lexicographically valid sequence that matches the pattern.</li>
<li>Initialize a string <code>sequence</code> by creating a sequence of numbers from 1 to <code>n + 1</code>, where <code>n</code> is the length of the pattern.</li>
<li>Convert the sequence into a string by appending numbers (1 through <code>n + 1</code>) to the string <code>sequence</code>.</li>
<li>Generate the initial <code>permutation</code> of the sequence.</li>
<li>Use the <code>next_permutation</code> function to generate successive permutations of the sequence.</li>
<li>Keep generating permutations until a permutation that satisfies the pattern (checked using the <code>check</code> function) is found.</li>
<li>Once a valid permutation is found, return it.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/d24iGeGd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n! \cdot n^2)\)</span></p>
<p>The algorithm generates all possible permutations of the sequence of numbers from 1 to <span class="math inline">\(n + 1\)</span>. The number of permutations of a sequence of length <span class="math inline">\(n + 1\)</span> is <span class="math inline">\((n + 1)!\)</span>, which is <span class="math inline">\(O(n! \cdot n)\)</span>. For each permutation, the algorithm checks if it matches the given pattern using the <code>check</code> function. The <code>check</code> function iterates through the permutation and the pattern, performing comparisons, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Since there are <span class="math inline">\(O(n! \cdot n)\)</span> permutations and each check takes <span class="math inline">\(O(n)\)</span> time, the overall time complexity is <span class="math inline">\(O(n! \cdot n^2)\)</span>. This is because the algorithm may need to check all permutations in the worst case before finding the correct one.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a string <code>sequence</code> to store the initial sequence of numbers from 1 to <span class="math inline">\(n + 1\)</span>, which requires <span class="math inline">\(O(n)\)</span> space. Additionally, it uses a string <code>permutation</code> to store the current permutation being checked, which also requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>The <code>check</code> function uses constant extra space for comparisons, and the built-in function operates in-place, requiring no additional space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>, dominated by the storage of the <code>sequence</code> and <code>permutation</code> strings.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimization-with-bit-masking">Approach 2: Optimization with Bit Masking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A different way to construct the smallest valid number is to use bit masking to track which digits have already been used, rather than generating and checking every single permutation like we did in the first approach. By representing the digits 1 to 9 as individual bits in an integer, we can quickly check whether a digit is available.</p>
<p>To construct the number, we start with an empty sequence and recursively attempt to place digits while ensuring that they satisfy the given pattern. The core idea is to define a recursive function that keeps track of three things: (1) the current position in the pattern, (2) a bitmask representing which digits have already been used, and (3) the number being formed. Initially, we start at position 0 with an empty number and aim to fill all positions while maintaining the constraints imposed by the pattern.</p>
<p>At each step, we loop through digits from 1 to 9 and check two conditions before placing a digit:</p>
<ol>
<li><strong>Is the digit already used?</strong> The bitmask helps here â€” we can efficiently check whether a digit is available by inspecting its corresponding bit.</li>
<li><strong>Does the digit follow the pattern constraint?</strong> If the previous character in the pattern is <code>'I'</code>, the current digit must be greater than the last one placed. If it's <code>'D'</code>, the current digit must be smaller.</li>
</ol>
<p>If a digit satisfies both conditions, we make a recursive call to the next position, appending this digit to our number. We also update the bitmask to mark this digit as used, ensuring it won't be selected again. Since our goal is to find the lexicographically smallest number, we explore digits in increasing order, ensuring that the first valid solution we find is also the smallest.</p>
<p>The recursion proceeds until we have placed all required digits. Once a complete sequence is formed, we compare it with the smallest valid number found so far and continue searching for a better (smaller) result if possible.</p>
<p>The recursion terminates when all positions have been filled (i.e., when <code>currentPosition</code> exceeds the length of the pattern). At this point, we have successfully constructed a valid number, which we return as the final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="findsmallestnumber-function"><code>findSmallestNumber</code> Function:</h5>
<ul>
<li>
<p>This recursive function finds the smallest number that satisfies the given pattern.</p>
</li>
<li>
<p>Base Case: If the current position exceeds the pattern length, return the current number (<code>currentNum</code>).</p>
</li>
<li>
<p>Initialize <code>result</code> as some max value to track the smallest valid number.</p>
</li>
<li>
<p>Retrieve the last digit of the current number (<code>lastDigit</code>).</p>
</li>
<li>
<p>Determine if the next digit should be larger or smaller based on the previous character in the pattern:</p>
<ul>
<li>If <code>currentPosition == 0</code> or the previous pattern character is <code>'I'</code>, the next digit should be larger.</li>
<li>Otherwise, the next digit should be smaller.</li>
</ul>
</li>
<li>
<p>For each possible digit from 1 to 9:</p>
<ul>
<li>Check if the digit has already been used by checking the <code>usedDigitsMask</code>.</li>
<li>Ensure the digit follows the pattern (greater or smaller than the last digit based on the pattern).</li>
<li>If valid, recursively call <code>findSmallestNumber</code> with the updated parameters:
<ul>
<li>Move to the next position in the pattern.</li>
<li>Mark the current digit as used by updating the <code>usedDigitsMask</code>.</li>
<li>Update the <code>currentNum</code> by appending the current digit.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Once the recursive function completes and finds the smallest valid number, return the result.</p>
</li>
</ul>
<h5 id="smallestnumber-function-1">smallestNumber Function:</h5>
<ul>
<li>The main function converts the result of <code>findSmallestNumber</code> to a string and returns it.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Yv4o8XZd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(9^n)\)</span></p>
<p>The algorithm uses a recursive approach to explore all possible combinations of digits (from 1 to 9) that satisfy the given pattern. At each step, it tries all unused digits (up to 9 choices) and recursively checks if they fit the pattern. In the worst case, the recursion depth is <span class="math inline">\(n + 1\)</span> (one level for each character in the pattern plus one for the base case), and at each level, there are up to 9 choices.</p>
<p>This results in an exponential number of recursive calls, leading to a time complexity of <span class="math inline">\(O(9^n)\)</span>. This is because the recursion tree has a branching factor of 9 and a depth of <span class="math inline">\(n + 1\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the recursion stack. In the worst case, the recursion depth is <span class="math inline">\(n + 1\)</span>, which means the stack can grow up to <span class="math inline">\(O(n)\)</span> levels deep. Additionally, the algorithm uses a few auxiliary variables like <code>currentPosition</code>, <code>usedDigitsMask</code>, and <code>currentNum</code>, which occupy constant space.</p>
<p>The <code>usedDigitsMask</code> is an integer used to track which digits have been used, and it does not grow with the input size. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>, primarily due to the recursion stack.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-regulated-brute-force-via-recursion">Approach 3: Regulated Brute Force via Recursion</h3>
<h4 id="intuition-2">Intuition</h4>
<p>A key observation is how the digits must be arranged based on the given pattern. When we see an <code>'I'</code>, the numbers should be in increasing order, which is straightforward to handle. However, when we encounter a <code>'D'</code>, the numbers should be in decreasing order, which introduces complexity.</p>
<p>If the pattern consists only of <code>'I'</code> characters, the solution is simple. For example, with the pattern <code>&quot;III&quot;</code>, the answer would be <code>&quot;1234&quot;</code> â€” we just place the smallest available number at each step in sequential order. This is because each <code>'I'</code> ensures that the next number must be greater than the previous one, so we can directly append numbers in increasing order.</p>
<p>However, when we introduce <code>'D'</code> into the pattern, we must be more careful. A <code>'D'</code> means that the current number must be larger than the next one, and we canâ€™t just keep adding numbers sequentially as we did for <code>'I'</code>. The challenge is that when we see a <code>'D'</code>, we don't immediately know how many consecutive <code>'D'</code> characters will follow, which affects how we assign numbers.</p>
<p>To resolve this, when we encounter a <code>'D'</code>, instead of placing a number at that position immediately, we delay the decision. We keep processing the pattern recursively until we reach an <code>'I'</code> or the end of the pattern. Once weâ€™ve fully processed all future indices, we &quot;unwind&quot; the recursion and start placing numbers in reverse order. This ensures that the numbers corresponding to the <code>'D'</code> positions are placed in descending order, maintaining the correct decreasing relationship.</p>
<p>To keep track of how many positions we have assigned a digit to, we introduce a variable <code>currentCount</code>. Clearly, the next available digit at any point is <code>currentCount + 1</code>.</p>
<p>For an <code>'I'</code>, we can simply place the next available number and move forward. The recursive relation in this case follows a natural increasing order: we call the helper function for the next index and proceed normally leading to <code>buildSequence(currentIndex = currentIndex + 1, currentCount = currentIndex + 1, patternArray, result)</code>.</p>
<p>However, for a <code>'D'</code>, we defer placement and allow recursion to handle future numbers first. By the time we return from the recursive calls, we are guaranteed to place the correct larger number first, followed by smaller ones, satisfying the <code>'D'</code> condition. As we skip assigning a digit to the current position, we simply move to the next index without incrementing the <code>currentCount</code>: <code>buildSequence(currentIndex = currentIndex + 1, currentCount, patternArray, result)</code>.</p>
<p>For example, consider the pattern <code>&quot;IIIDIDDD&quot;</code>. The first three <code>'I'</code> characters result in <code>&quot;1234&quot;</code>, following a simple increasing sequence. However, once we reach <code>'D'</code>, we stop placing numbers immediately and let recursion take control. After unwinding, we correctly place <code>&quot;5&quot;</code> before <code>&quot;4&quot;</code>, then continue the <code>'D'</code> sequence properly, resulting in <code>&quot;123549876&quot;</code>.</p>
<p>Since numbers are appended at the bottom of the recursion stack, the final sequence is initially built in reverse order. To get the correct lexicographical order, we reverse the string at the end.</p>
<blockquote>
<p>For a more comprehensive understanding of recursion, check out the <a href="https://leetcode.com/explore/learn/card/recursion-i/">Recursion Explore Card ðŸ”—</a>. This resource provides an in-depth look at recursion, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>result</code> as an empty string.</p>
</li>
<li>
<p>Call <code>buildSequence</code> recursively with <code>currentIndex = 0</code> and <code>currentCount = 0</code> to construct the sequence.</p>
</li>
<li>
<p>Reverse <code>result</code> after recursion completes.</p>
</li>
<li>
<p>Return <code>result</code> as the final smallest number.</p>
</li>
<li>
<p>In <code>buildSequence</code>:</p>
<ul>
<li>If <code>currentIndex</code> is not at the end of <code>pattern</code>:
<ul>
<li>If <code>pattern[currentIndex]</code> is 'I', increment <code>currentCount</code> and recurse with the next index.</li>
<li>If <code>pattern[currentIndex]</code> is 'D', recurse without incrementing <code>currentCount</code> and recurse with the next index.</li>
</ul>
</li>
<li>Append <code>currentCount + 1</code> to <code>result</code> to construct the sequence in reverse order.</li>
<li>Return <code>currentCount + 1</code> to propagate the correct value upward in recursion.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RPnzTqTC/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a recursive approach to build the sequence based on the pattern. Each recursive call processes one character of the pattern, and the recursion depth is at most <span class="math inline">\(n + 1\)</span> (one level for each character in the pattern plus one for the base case). Since each recursive call performs a constant amount of work (appending to the <code>result</code> and updating the count), the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, the final reversal of the <code>result</code> takes <span class="math inline">\(O(n)\)</span> time, but this is a single operation and does not change the overall linear time complexity. Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the recursion stack and the <code>result</code>. The recursion stack can grow up to <span class="math inline">\(n + 1\)</span> levels deep, requiring <span class="math inline">\(O(n)\)</span> space. The <code>result</code> also grows linearly with the input size, storing up to <span class="math inline">\(n + 1\)</span> characters, which requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Apart from these, the algorithm uses a few auxiliary variables like <code>currentIndex</code> and <code>currentCount</code>, which occupy constant space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>, primarily due to the recursion stack and the <code>result</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-using-stack">Approach 4: Using Stack</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The problems that are solved via recursion can almost always be solved using a stack as well. The reason is that recursion inherently uses a call stack to keep track of function calls, storing the current state before diving deeper into the problem. Each recursive call pushes a new frame onto the call stack, which holds the functionâ€™s local variables and execution context. When the base case is reached, the function calls start returning, effectively unwinding the stack in a last-in, first-out (LIFO) manner.</p>
<p>In this case, the core idea is to use a stack to manage the order in which numbers are appended. The stack helps handle consecutive <code>'D'</code> characters efficiently by delaying their placement, ensuring that numbers in a decreasing sequence are correctly placed in the smallest lexicographical order.</p>
<p>More specifically, we iterate through the pattern while pushing numbers onto the stack. Every time we see a <code>'D'</code>, we push the current number onto the stack and continue, delaying its placement in the result. This is because a <code>'D'</code> means the next number should be smaller than the current one, so we must delay placing the numbers to ensure that they appear in decreasing order when finally appended.</p>
<p>When we encounter an <code>'I'</code> or reach the end of the pattern, we know that all numbers stored in the stack must now be placed in the result to maintain the correct order. At this point, we start popping from the stack, appending each number to the result before moving forward. This guarantees that any numbers stored due to a sequence of <code>'D'</code> characters appear in descending order, ensuring the smallest valid number.</p>
<p>For example, given the pattern <code>&quot;IDID&quot;</code>, we start by pushing <code>1</code> onto the stack because we always push the next number. Since the first character is <code>'I'</code>, we immediately pop from the stack and append <code>1</code> to the result. Then we push <code>2</code> and, seeing the next <code>'D'</code>, we push <code>3</code> instead of immediately appending. The <code>'I'</code> that follows tells us it's time to pop and append the numbers, so <code>3</code> and then <code>2</code> are added to the result, maintaining the required decreasing order. The process continues in this manner, ensuring that the number we build respects the pattern while remaining lexicographically smallest.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty string <code>result</code> to store the final smallest number.</p>
</li>
<li>
<p>Use a <code>stack</code> named <code>numStack</code> to manage digits based on the pattern.</p>
</li>
<li>
<p>Iterate through the <code>pattern</code>:</p>
<ul>
<li>Push <code>index + 1</code> onto <code>numStack</code>, ensuring numbers are pushed in increasing order.</li>
<li>If at the end of the pattern or the current character is <code>'I'</code>:
<ul>
<li>Pop all elements from <code>numStack</code> and append them to <code>result</code>, ensuring that decreasing sequences are handled before moving to the next increasing sequence.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code> as the smallest number following the given pattern.</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/4qKnP7Fr/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the <code>pattern</code> string once, processing each character exactly once. In each iteration, we push at most one number onto the stack, contributing <span class="math inline">\(O(n)\)</span> operations in total. Additionally, whenever we encounter <code>'I'</code> or reach the end, we pop all elements from the stack. Since each number is pushed and popped exactly once, this also contributes <span class="math inline">\(O(n)\)</span>. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The extra space usage comes from the <code>stack</code>, which, in the worst case, holds all numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n+1\)</span>. This happens when the entire <code>pattern</code> consists of <code>'D'</code> characters, causing all numbers to be pushed before any are popped. Thus, the worst-case space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-greedy-approach-with-sliding-window-reversal">Approach 5: Greedy Approach with Sliding Window Reversal</h3>
<h4 id="intuition-4">Intuition</h4>
<p>A more structured approach to constructing the smallest number that fits the given pattern is to use a <strong>greedy strategy with a sliding window reversal technique</strong>. Instead of constructing the number from scratch, we begin with a baseline sequence of consecutive numbers (e.g., <code>123456789</code> for a pattern of length <code>n</code>). This ensures that we always start with the smallest possible number and then modify it as needed to satisfy the given pattern.</p>
<p>The idea is to use two pointers: <code>currentIndex</code>, which traverses the pattern, and <code>previousIndex</code>, which marks the start of the segment that needs to be reversed after we encounter a <code>'D'</code> (Decreasing) character. Whenever we find an <code>'I'</code> (Increasing) or reach the end of the pattern, we reverse the segment between <code>previousIndex</code> and <code>currentIndex</code> to ensure that the digits follow the required decreasing order.</p>
<p>For each character in the pattern:</p>
<ul>
<li>If the current character is <code>'I'</code>, no modification is required because the sequence already maintains increasing order.</li>
<li>If the current character is <code>'D'</code>, we continue moving until we find an <code>'I'</code> or reach the end of the pattern. Once we find an <code>'I'</code> or exhaust the pattern, we reverse the substring from <code>previousIndex</code> to <code>currentIndex</code> to create the required decreasing order.</li>
</ul>
<p>Consider an example where the pattern is <code>&quot;DDI&quot;</code>:</p>
<ol>
<li>We initialize our sequence as <code>&quot;1234&quot;</code>, since the pattern length is 3.</li>
<li>The first character is <code>'D'</code>, so we continue scanning until we reach an <code>'I'</code>. Once we reach the <code>'I'</code>, we reverse the first three elements (<code>&quot;123&quot; â†’ &quot;321&quot;</code>).</li>
<li>Since the final character is <code>'I'</code>, no further modifications are needed, and we append the last digit as is.</li>
<li>The final result is <code>&quot;3214&quot;</code>.</li>
</ol>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>
<p>Initialize a string called <code>result</code> to store the final result.</p>
</li>
<li>
<p>Iterate through the <code>pattern</code>:</p>
<ul>
<li>
<p>Use <code>currentIndex</code> to traverse the pattern and <code>previousIndex</code> to mark the start of the substring that may need to be reversed.</p>
</li>
<li>
<p>Append the value <code>1 + currentIndex</code> to <code>result</code>.</p>
</li>
<li>
<p>When necessary, reverse the substring starting from <code>previousIndex</code>:</p>
<ul>
<li>If <code>currentIndex</code> reaches the end of the pattern or the current character in the pattern is <code>'I'</code>:
<ul>
<li>Create a temporary string (<code>temp</code>) and reverse the substring starting from <code>previousIndex</code> to <code>currentIndex</code>.</li>
<li>Update <code>result</code> by concatenating the part before <code>previousIndex</code> and the reversed substring from <code>previousIndex</code> onward.</li>
<li>Update <code>previousIndex</code> to <code>currentIndex + 1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the final <code>result</code> as a string.</p>
</li>
</ul>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/Amx83eMt/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the input string <code>pattern</code> once, which takes <span class="math inline">\(O(n)\)</span> time. During each iteration, when the character is 'I' or the end of the string is reached, the algorithm reverses a contiguous segment of the <code>result</code> string. While reversing a substring of length <span class="math inline">\(k\)</span> takes <span class="math inline">\(O(k)\)</span> time, each position in the array is reversed at most once throughout the entire process.</p>
<p>Since each element participates in at most one reversal, the total number of operations across all reversals is at most <span class="math inline">\(O(n)\)</span>. Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses an extra string <code>result</code> to store the intermediate and final result, which grows linearly with the input size, requiring <span class="math inline">\(O(n)\)</span> space. Additionally, a temporary extra string named <code>temp</code> is used during substring reversal, which also requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Apart from these, the algorithm uses a few auxiliary variables like <code>currentIndex</code> and <code>previousIndex</code>, which occupy constant space. Thus, the dominant space usage comes from the extra strings, making the overall space complexity <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-6-optimized-greedy-approach-with-precomputed-d-segments">Approach 6: Optimized Greedy Approach with Precomputed 'D' Segments</h3>
<h4 id="intuition-5">Intuition</h4>
<p>The previous approach used a sliding window reversal to handle decreasing sequences efficiently. An alternate strategy would involve precomputing the number of consecutive <code>'D'</code>s at each position. This allows us to directly determine the correct digit placement without the need for explicit reversal operations.</p>
<p>Instead of modifying an existing sequence as we traverse the pattern, we first scan the pattern <strong>backward</strong> to compute an array <code>arrD[i]</code>, where each entry represents the number of consecutive <code>'D'</code>s that appear after the corresponding position. This precomputed information allows us to determine the exact digit that should be placed in each position without needing to reverse segments manually.</p>
<p>As we build the answer, we maintain two key values:</p>
<ol>
<li><code>maxSoFar</code>: The largest number assigned so far.</li>
<li><code>currMax</code>: A helper variable to ensure that subsequent digits are placed in proper increasing order, preventing conflicts between previously placed numbers.</li>
</ol>
<p>When encountering an <code>'I'</code>, we simply assign the smallest available number, which is <code>maxSoFar + 1</code>. However, when encountering a <code>'D'</code>, we need to ensure that the digits form a descending order. To achieve this, we use <code>arrD[i]</code> to determine how far the descending sequence extends. Instead of constructing the decreasing sequence step by step, we calculate the correct number directly:</p>
<p><span class="math inline">\(\text{digit} = 1 + \text{maxSoFar} + \text{arrD}[i]\)</span></p>
<p>This formula ensures that:</p>
<ul>
<li>The assigned number is large enough to maintain the required descending order.</li>
<li>The sequence remains lexicographically minimal by assigning the smallest possible numbers that satisfy the constraints.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2375_fix/optimized_greedy_fix.json:1120,475!?!</p>
<h4 id="algorithm-5">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>patternLength</code> to the length of the input <code>pattern</code>.</p>
</li>
<li>
<p>Initialize <code>maxSoFar</code> and <code>currMax</code> to 0, which will keep track of the largest digits used so far.</p>
</li>
<li>
<p>Initialize a vector <code>arrD</code> of size <code>patternLength + 1</code> to store the lengths of decreasing subsequences in the pattern.</p>
</li>
<li>
<p>Calculate the lengths of decreasing subsequences in the pattern:</p>
<ul>
<li>Iterate backward through the <code>pattern</code>:
<ul>
<li>If the current character is <code>'D'</code>, calculate the length of the decreasing subsequence starting from the current index as <code>arrD[patternIndex + 1] + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize an empty string <code>result</code> to build the final result.</p>
</li>
<li>
<p>Build the result string based on the pattern:</p>
<ul>
<li>Iterate through each position in the pattern:
<ul>
<li>If the current character is <code>'I'</code>, increment <code>maxSoFar</code>, append it to <code>result</code>, and update <code>maxSoFar</code>, as the maximum of its current value and <code>currMax</code>.</li>
<li>If the current character is <code>'D'</code>, calculate the appropriate digit from <code>maxSoFar</code> and <code>arrD[position]</code>, append it to <code>result</code>, and update <code>currMax</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>result</code>, which represents the smallest number satisfying the pattern.</p>
</li>
</ul>
<h4 id="implementation-5">Implementation</h4>
<p><a href="https://leetcode.com/playground/XLhyzwNC/shared">code</a></p>
<h4 id="complexity-analysis-5">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm processes the input string <code>pattern</code> in two main steps. First, it performs a backward traversal to compute the lengths of decreasing subsequences. This step iterates through the string once, taking <span class="math inline">\(O(n)\)</span> time. Second, it performs a forward traversal to construct the result string based on the computed subsequence lengths. This step also iterates through the string once, taking <span class="math inline">\(O(n)\)</span> time. Since both steps are linear and independent, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, the use of built-in functions and string concatenation (<code>+=</code>) does not increase the time complexity beyond <span class="math inline">\(O(n)\)</span>, as these operations are either constant time or linear in the context of this algorithm. Thus, the total time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space for two main purposes. First, it stores the lengths of decreasing subsequences in an array <code>arrD</code>, which requires <span class="math inline">\(O(n)\)</span> space. Second, it constructs the result string, which also grows linearly with the input size, requiring <span class="math inline">\(O(n)\)</span> space.</p>
<p>Apart from these, the algorithm uses a few auxiliary variables like <code>maxSoFar</code>, <code>currMax</code>, and <code>temp</code>, which occupy constant space. Therefore, the dominant space usage comes from the array <code>arrD</code> and the result string, making the overall space complexity <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-collisions-on-a-road/description" target="_blank" rel="noopener noreferrer">Count Collisions on a Road</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cars on an infinitely long road. The cars are numbered from <code>0</code> to <code>n - 1</code> from left to right and each car is present at a <strong>unique</strong> point.</p>

<p>You are given a <strong>0-indexed</strong> string <code>directions</code> of length <code>n</code>. <code>directions[i]</code> can be either <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, or <code>&#39;S&#39;</code> denoting whether the <code>i<sup>th</sup></code> car is moving towards the <strong>left</strong>, towards the <strong>right</strong>, or <strong>staying</strong> at its current point respectively. Each moving car has the <strong>same speed</strong>.</p>

<p>The number of collisions can be calculated as follows:</p>

<ul>
	<li>When two cars moving in <strong>opposite</strong> directions collide with each other, the number of collisions increases by <code>2</code>.</li>
	<li>When a moving car collides with a stationary car, the number of collisions increases by <code>1</code>.</li>
</ul>

<p>After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.</p>

<p>Return <em>the <strong>total number of collisions</strong> that will happen on the road</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> directions = &quot;RLRSLL&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong>
The collisions that will happen on the road are:
- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.
- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.
- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.
- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.
Thus, the total number of collisions that will happen on the road is 5. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> directions = &quot;LLRR&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong>
No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= directions.length &lt;= 10<sup>5</sup></code></li>
	<li><code>directions[i]</code> is either <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, or <code>&#39;S&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-non-decreasing-subarrays-after-k-operations/description" target="_blank" rel="noopener noreferrer">Count Non-Decreasing Subarrays After K Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-queue</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">queue</span> <span class="topic-badge">segment-tree</span> <span class="topic-badge">sliding-window</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of <code>n</code> integers and an integer <code>k</code>.</p>

<p>For each subarray of <code>nums</code>, you can apply <strong>up to</strong> <code>k</code> operations on it. In each operation, you increment any element of the subarray by 1.</p>

<p><strong>Note</strong> that each subarray is considered independently, meaning changes made to one subarray do not persist to another.</p>

<p>Return the number of subarrays that you can make <strong>non-decreasing</strong> â€‹â€‹â€‹â€‹â€‹after performing at most <code>k</code> operations.</p>

<p>An array is said to be <strong>non-decreasing</strong> if each element is greater than or equal to its previous element, if it exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [6,3,1,2,4,4], k = 7</span></p>

<p><strong>Output:</strong> <span class="example-io">17</span></p>

<p><strong>Explanation:</strong></p>

<p>Out of all 21 possible subarrays of <code>nums</code>, only the subarrays <code>[6, 3, 1]</code>, <code>[6, 3, 1, 2]</code>, <code>[6, 3, 1, 2, 4]</code> and <code>[6, 3, 1, 2, 4, 4]</code> cannot be made non-decreasing after applying up to k = 7 operations. Thus, the number of non-decreasing subarrays is <code>21 - 4 = 17</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [6,3,1,3,6], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarray <code>[3, 1, 3, 6]</code> along with all subarrays of <code>nums</code> with three or fewer elements, except <code>[6, 3, 1]</code>, can be made non-decreasing after <code>k</code> operations. There are 5 subarrays of a single element, 4 subarrays of two elements, and 2 subarrays of three elements except <code>[6, 3, 1]</code>, so there are <code>1 + 5 + 4 + 2 = 12</code> subarrays that can be made non-decreasing.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-submatrices-with-all-ones/description" target="_blank" rel="noopener noreferrer">Count Submatrices With All Ones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> binary matrix <code>mat</code>, <em>return the number of <strong>submatrices</strong> that have all ones</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[1,0,1],[1,1,0],[1,1,0]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> 
There are 6 rectangles of side 1x1.
There are 2 rectangles of side 1x2.
There are 3 rectangles of side 2x1.
There is 1 rectangle of side 2x2. 
There is 1 rectangle of side 3x1.
Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg" style="width: 324px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
<strong>Output:</strong> 24
<strong>Explanation:</strong> 
There are 8 rectangles of side 1x1.
There are 5 rectangles of side 1x2.
There are 2 rectangles of side 1x3. 
There are 4 rectangles of side 2x1.
There are 2 rectangles of side 2x2. 
There are 2 rectangles of side 3x1. 
There is 1 rectangle of side 3x2. 
Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 150</code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-the-reversals0401/1" target="_blank" rel="noopener noreferrer">Count the Reversals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>s</strong> consisting of only opening and closing curly brackets<strong> '{'</strong> and<strong> '}',</strong>&nbsp;find out the <strong>minimum&nbsp;</strong>number of reversals required to convert the string into a balanced expression. A reversal means changing&nbsp;<strong>'{'</strong>&nbsp;to&nbsp;<strong>'}'</strong>&nbsp;or vice-versa.<br /><br /></span><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s = "}{{}}{{{"
<strong>Output:</strong> 3
<strong>Explanation</strong>: One way to balance is:
"<strong>{</strong>{{}}{<strong>}}</strong>". There is no balanced sequence
that can be formed in lesser reversals.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: s = "{{}{{{}{{}}{{"</span><span style="font-size: 18px;">
<strong>Output:</strong> -1
<strong>Explanation</strong>: There's no way we can balance
this sequence of braces.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; |s| &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/crawler-log-folder/description" target="_blank" rel="noopener noreferrer">Crawler Log Folder</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The Leetcode file system keeps a log each time some user performs a <em>change folder</em> operation.</p>

<p>The operations are described below:</p>

<ul>
	<li><code>&quot;../&quot;</code> : Move to the parent folder of the current folder. (If you are already in the main folder, <strong>remain in the same folder</strong>).</li>
	<li><code>&quot;./&quot;</code> : Remain in the same folder.</li>
	<li><code>&quot;x/&quot;</code> : Move to the child folder named <code>x</code> (This folder is <strong>guaranteed to always exist</strong>).</li>
</ul>

<p>You are given a list of strings <code>logs</code> where <code>logs[i]</code> is the operation performed by the user at the <code>i<sup>th</sup></code> step.</p>

<p>The file system starts in the main folder, then the operations in <code>logs</code> are performed.</p>

<p>Return <em>the minimum number of operations needed to go back to the main folder after the change folder operations.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/sample_11_1957.png" style="width: 775px; height: 151px;" /></p>

<pre>
<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]
<strong>Output:</strong> 2
<strong>Explanation: </strong>Use this change folder operation &quot;../&quot; 2 times and go back to the main folder.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/sample_22_1957.png" style="width: 600px; height: 270px;" /></p>

<pre>
<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= logs.length &lt;= 10<sup>3</sup></code></li>
	<li><code>2 &lt;= logs[i].length &lt;= 10</code></li>
	<li><code>logs[i]</code> contains lowercase English letters, digits, <code>&#39;.&#39;</code>, and <code>&#39;/&#39;</code>.</li>
	<li><code>logs[i]</code> follows the format described in the statement.</li>
	<li>Folder names consist of lowercase English letters and digits.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given a list of strings <code>logs</code>, the task is to calculate the minimum steps needed to navigate back to the main folder.</p>
<p>Each string in <code>logs</code> represents a moving operation:</p>
<ul>
<li><code>&quot;../&quot;</code>: To the Parent Folder</li>
<li><code>&quot;./&quot;</code>: Staying in the same Folder</li>
<li><code>&quot;x/&quot;</code>: To the Child Folder named <code>x</code></li>
</ul>
<hr />
<h3 id="approach-1-counter">Approach 1: Counter</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve this problem, we need to track the user's position within the folder structure relative to the main folder. We can achieve this using a numerical counter that represents the depth of the current folder.</p>
<p>Here's how the counter system works when we move around the file system:</p>
<ol>
<li>We initialize the counter to 0, representing the main folder.</li>
<li>If we enter a child folder (<code>&quot;x/&quot;</code>), we increase the counter by 1 to go deeper into the folder structure.</li>
<li>When we encounter <code>&quot;../&quot;</code>, we decrease the counter by 1 to move up a level. If the counter is already at 0, it remains at 0 because we can't move above the main folder.</li>
<li><code>&quot;./&quot;</code> operations do not change the counter since they keep us in the current folder.</li>
</ol>
<p>We process each operation in the <code>logs</code> sequentially, updating our counter according to these rules. This approach allows us to track the user's depth in the folder structure without needing to store or process the actual folder names or full paths.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>folderDepth</code> to <code>0</code> to keep track of the current depth in the file system.</li>
<li>For each <code>currentOperation</code> in <code>logs</code>, perform the following steps:
<ul>
<li>If <code>currentOperation</code> equals <code>&quot;../&quot;</code>, decrease <code>folderDepth</code> by <code>1</code> to move up one directory level, but ensure <code>folderDepth</code> does not go below <code>0</code> (to prevent navigating above the root directory).</li>
<li>If <code>currentOperation</code> equals <code>&quot;./&quot;</code>, ignore it, as it means staying in the current directory and does not affect <code>folderDepth</code>.</li>
<li>For any other <code>currentOperation</code>(<code>&quot;x/&quot;</code>), increment <code>folderDepth</code> by <code>1</code>, indicating moving into a new directory.</li>
</ul>
</li>
<li>Return <code>folderDepth</code> as the minimum number of operations required to navigate back to the main folder.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LwX2yRUJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>logs</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through each operation exactly once.</p>
<blockquote>
<p>Note: String matching operations take linear time with respect to the length of the string. However, given the constraint that the length of the strings is limited to 10, this does not significantly impact the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space (<code>folderDepth</code>), regardless of the size of <code>logs</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-stack">Approach 2: Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Thereâ€™s no need for a stack or other data structures because we only care about the depth, not the actual path taken. We include this approach here for completeness in the article, in case you might be asked about the actual path in an interview scenario.</p>
<p>We use a stack to represent the folder structure, where each element denotes a folder and the stack's height indicates our current depth in the structure.</p>
<p>Starting with an empty stack represents being in the main folder. We process each operation in the <code>logs</code> array sequentially:</p>
<ul>
<li>When we encounter a folder name (any operation that isn't <code>&quot;../&quot;</code> or <code>&quot;./&quot;</code>), we push it onto the stack, signifying entry into a new folder.</li>
<li>Upon encountering <code>&quot;../&quot;</code>, we move up to the parent folder by popping the top element from the stack, provided the stack isn't empty. An empty stack means we're already at the main folder.</li>
<li><code>&quot;./&quot;</code> operations are ignored as they maintain the current folder context.</li>
</ul>
<p>After processing all operations, the stack's height reflects our depth in the folder structure. This height also corresponds to the number of operations needed to return to the main folder, as each <code>&quot;../&quot;</code> operation represents moving up one level.</p>
<blockquote>
<p>This algorithm may not seem directly useful if you're just looking to solve this specific question, but in practice, it mirrors how we navigate folders in real life. Entering a folder adds it to your path, and going up removes the last folder from your path. It naturally handles redundant operations. If you enter and then immediately exit a folder, the stack returns to its previous state, akin to real folder navigation. It retains only the essential information: the folders necessary to return to the main folder at any point.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an empty stack <code>folderStack</code>. This stack will track the sequence of directories as we navigate through them.</li>
<li>For each <code>currentOperation</code> in <code>logs</code>, perform the following steps:
<ul>
<li>If <code>currentOperation</code> equals <code>&quot;../&quot;</code>, check if <code>folderStack</code> is not empty. If true, pop the top directory from <code>folderStack</code> to move up to the parent directory.</li>
<li>If <code>currentOperation</code> equals <code>&quot;./&quot;</code>, ignore it as it signifies staying in the current directory and does not change the stack.</li>
<li>For any other <code>currentOperation</code>, push <code>currentOperation</code> onto <code>folderStack</code>, indicating we are entering a new directory.</li>
</ul>
</li>
<li>Operations such as <code>&quot;./&quot;</code> are ignored because they do not change the current directory structure represented by <code>folderStack</code>.</li>
<li>Return the size of <code>folderStack</code> as it represents the minimum number of operations required to navigate the file system effectively. The size of <code>folderStack</code> corresponds to the depth of the directory structure we have navigated.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1598/approach2.json:975,448!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ee2qZzRi/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>logs</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through each operation exactly once. This is because each operation (<code>push</code> or <code>pop</code>) on the stack is <span class="math inline">\(O(1)\)</span>, and we perform exactly one operation per entry in logs.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses linear amount of extra space (<code>folderStack</code>). This is because the stack (<code>folderStack</code>) can store up to <code>n</code> entries.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/create-maximum-number/description" target="_blank" rel="noopener noreferrer">Create Maximum Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of lengths <code>m</code> and <code>n</code> respectively. <code>nums1</code> and <code>nums2</code> represent the digits of two numbers. You are also given an integer <code>k</code>.</p>

<p>Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two numbers. The relative order of the digits from the same array must be preserved.</p>

<p>Return an array of the <code>k</code> digits representing the answer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
<strong>Output:</strong> [9,8,6,5,3]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [6,7], nums2 = [6,0,4], k = 5
<strong>Output:</strong> [6,7,6,0,4]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,9], nums2 = [8,9], k = 3
<strong>Output:</strong> [9,8,9]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == nums1.length</code></li>
	<li><code>n == nums2.length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>
	<li><code>1 &lt;= k &lt;= m + n</code></li>
	<li><code>nums1</code> and <code>nums2</code> do not have leading zeros.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/daily-temperatures/description" target="_blank" rel="noopener noreferrer">Daily Temperatures</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>temperatures</code> represents the daily temperatures, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is the number of days you have to wait after the</em> <code>i<sup>th</sup></code> <em>day to get a warmer temperature</em>. If there is no future day for which this is possible, keep <code>answer[i] == 0</code> instead.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> temperatures = [73,74,75,71,69,72,76,73]
<strong>Output:</strong> [1,1,4,2,1,1,0,0]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> temperatures = [30,40,50,60]
<strong>Output:</strong> [1,1,1,0]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> temperatures = [30,60,90]
<strong>Output:</strong> [1,1,0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>
	<li><code>30 &lt;=&nbsp;temperatures[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/decoded-string-at-index/description" target="_blank" rel="noopener noreferrer">Decoded String at Index</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an encoded string <code>s</code>. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:</p>

<ul>
	<li>If the character read is a letter, that letter is written onto the tape.</li>
	<li>If the character read is a digit <code>d</code>, the entire current tape is repeatedly written <code>d - 1</code> more times in total.</li>
</ul>

<p>Given an integer <code>k</code>, return <em>the </em><code>k<sup>th</sup></code><em> letter (<strong>1-indexed)</strong> in the decoded string</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leet2code3&quot;, k = 10
<strong>Output:</strong> &quot;o&quot;
<strong>Explanation:</strong> The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.
The 10<sup>th</sup> letter in the string is &quot;o&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ha22&quot;, k = 5
<strong>Output:</strong> &quot;h&quot;
<strong>Explanation:</strong> The decoded string is &quot;hahahaha&quot;.
The 5<sup>th</sup> letter is &quot;h&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a2345678999999999999999&quot;, k = 1
<strong>Output:</strong> &quot;a&quot;
<strong>Explanation:</strong> The decoded string is &quot;a&quot; repeated 8301530446056247680 times.
The 1<sup>st</sup> letter is &quot;a&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of lowercase English letters and digits <code>2</code> through <code>9</code>.</li>
	<li><code>s</code> starts with a letter.</li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
	<li>It is guaranteed that <code>k</code> is less than or equal to the length of the decoded string.</li>
	<li>The decoded string is guaranteed to have less than <code>2<sup>63</sup></code> letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/decode-string/description" target="_blank" rel="noopener noreferrer">Decode String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an encoded string, return its decoded string.</p>

<p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p>

<p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p>

<p>The test cases are generated so that the length of the output will never exceed <code>10<sup>5</sup></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;3[a]2[bc]&quot;
<strong>Output:</strong> &quot;aaabcbc&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;3[a2[c]]&quot;
<strong>Output:</strong> &quot;accaccacc&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;2[abc]3[cd]ef&quot;
<strong>Output:</strong> &quot;abcabccdcdcdef&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 30</code></li>
	<li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li>
	<li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li>
	<li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/decode-the-string2444/1" target="_blank" rel="noopener noreferrer">Decode the string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an encoded string&nbsp;<strong>s</strong>, the task is to decode it.&nbsp;</span><span style="font-size: 18px;">The encoding rule is :</span></p>
<ul>
<li><span style="font-size: 18px;"><strong>k[encodedString],</strong>&nbsp;where the&nbsp;<strong>encodedString</strong>&nbsp;inside the square brackets is being repeated exactly&nbsp;<strong>k</strong>&nbsp;times. Note that&nbsp;<strong>k</strong>&nbsp;is guaranteed to be a positive integer, and encodedString contains only lowercase english alphabets.<br /></span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Note:&nbsp;</strong></span><span style="font-size: 18px;">The test cases are generated so that the length of the output string will never exceed&nbsp;</span><span style="font-size: 18px;">10</span><sup>5</sup><span style="font-size: 18px;">&nbsp;.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s = "1[b]"
<strong>Output:</strong> "b"
<strong>Explanation:</strong> "b" is present only one time.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s = "3[b2[ca]]"
<strong>Output:</strong> "bcacabcacabcaca"
<strong>Explanation:<br /></strong>1. Inner substring &ldquo;2[ca]&rdquo; breakdown into &ldquo;caca&rdquo;.<br />2. Now, new string becomes &ldquo;3[bcaca]&rdquo;
3. Similarly &ldquo;3[bcaca]&rdquo; becomes &ldquo;bcacabcacabcaca &rdquo; which is final result.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; |s| &le; 10<sup>5</sup>&nbsp;<br />1 &lt;= k &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/delete-array-elements-which-are-smaller-than-next-or-become-smaller3115/1" target="_blank" rel="noopener noreferrer">Delete Array Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">cpp</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array<strong> arr[] </strong>and a number <strong>k</strong>. The task is to delete <strong>k</strong> elements that are smaller than the next element (i.e., we delete arr[i] if arr[i] &lt; arr[i+1]) or become smaller than the next because the next element is deleted.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> arr[] = [20, 10, 25, 30, 40], k = 2
<strong>Output: </strong>[25, 30, 40]
<strong>Explanation: </strong>First we delete 10 because it follows arr[i] &lt; arr[i+1]. Then we delete 20 because 25 is moved next to it and it also starts following the condition.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> arr[] = [3, 100, 1] , k = 1<strong>
Output: </strong>[100, 1] </span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />2 &le; arr.size() &le; 10<sup>6</sup><br />1 &le; k &lt; arr.size()</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/delete-middle-element-of-a-stack/1" target="_blank" rel="noopener noreferrer">Delete Mid of a Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a stack <strong>s</strong>, delete the <strong>middle element </strong>of the stack without using any additional data structure.</span></p>
<blockquote>
<p><span style="font-size: 18px;"><strong>Middle element:- </strong>floor((size_of_stack+1)/2) (1-based indexing) from the bottom of the stack.</span></p>
</blockquote>
<p><span style="font-size: 18px;">Note</span><span style="font-size: 18px;">: The output shown by the compiler is the stack from top to bottom.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: s = [10, 20, 30, 40, 50]
<strong>Output</strong>: [50, 40, 20, 10]
<strong>Explanation</strong>: The bottom-most element will be 10 and the top-most element will be 50. Middle element will be element at index 3 from bottom, which is 30. Deleting 30, stack will look like {10 20 40 50}.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: s = [10, 20, 30, 40]
<strong>Output</strong>: [40, 30, 10]
<strong>Explanation</strong>: T</span><span style="font-size: 14pt;">he bottom-most element will be 10 and the top-most element will be 40. Middle element will be element at index 2 from bottom, which is 20. Deleting 20, stack will look like {10 30 40}.<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: s = [5, 8, 6, 7, 6, 6, 5, 10, 12, 9]
<strong>Output</strong>: [9, 12, 10, 5, 6, 7, 6, 8, 5]</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />2 &le; element of stack &le; 10<sup>5<br /></sup>2 &le; s.size() &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-a-stack-with-increment-operation/description" target="_blank" rel="noopener noreferrer">Design a Stack With Increment Operation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a stack that supports increment operations on its elements.</p>

<p>Implement the <code>CustomStack</code> class:</p>

<ul>
	<li><code>CustomStack(int maxSize)</code> Initializes the object with <code>maxSize</code> which is the maximum number of elements in the stack.</li>
	<li><code>void push(int x)</code> Adds <code>x</code> to the top of the stack if the stack has not reached the <code>maxSize</code>.</li>
	<li><code>int pop()</code> Pops and returns the top of the stack or <code>-1</code> if the stack is empty.</li>
	<li><code>void inc(int k, int val)</code> Increments the bottom <code>k</code> elements of the stack by <code>val</code>. If there are less than <code>k</code> elements in the stack, increment all the elements in the stack.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
<strong>Output</strong>
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
<strong>Explanation</strong>
CustomStack stk = new CustomStack(3); // Stack is Empty []
stk.push(1);                          // stack becomes [1]
stk.push(2);                          // stack becomes [1, 2]
stk.pop();                            // return 2 --&gt; Return top of the stack 2, stack becomes [1]
stk.push(2);                          // stack becomes [1, 2]
stk.push(3);                          // stack becomes [1, 2, 3]
stk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4
stk.increment(5, 100);                // stack becomes [101, 102, 103]
stk.increment(2, 100);                // stack becomes [201, 202, 103]
stk.pop();                            // return 103 --&gt; Return top of the stack 103, stack becomes [201, 202]
stk.pop();                            // return 202 --&gt; Return top of the stack 202, stack becomes [201]
stk.pop();                            // return 201 --&gt; Return top of the stack 201, stack becomes []
stk.pop();                            // return -1 --&gt; Stack is empty return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= maxSize, x, k &lt;= 1000</code></li>
	<li><code>0 &lt;= val &lt;= 100</code></li>
	<li>At most <code>1000</code> calls will be made to each method of <code>increment</code>, <code>push</code> and <code>pop</code> each separately.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-array">Approach 1: Array</h3>
<h4 id="intuition">Intuition</h4>
<p>At its core, a stack is essentially a list with limited access where we can only interact with the topmost element. For a comprehensive understanding of stacks, refer to this LeetCode <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Explore Card</a> for an in-depth explanation.</p>
<p>Let's keep a pointer <code>topIndex</code> to point to the top element. We'll simulate the stack using an array since we can access each index of the array in constant time.</p>
<ul>
<li>
<p><code>push()</code>:<br />
The push operation adds an element to the top of the stack, which corresponds to the end of our array. We increment <code>topIndex</code> to the next available position in the array and insert the new element there.</p>
</li>
<li>
<p><code>pop()</code>:<br />
The pop operation removes and returns the element currently at the top of the stack. We return the element that <code>topIndex</code> points to and then decrement <code>topIndex</code> to indicate the new top element. There's no need to physically remove the element from the array; when <code>topIndex</code> next reaches that position, the element will simply be overwritten.</p>
</li>
<li>
<p><code>increment()</code>:<br />
This operation is unique to our custom stack implementation, as it manipulates elements other than the topmost one. Here, our array representation proves advantageous. We iterate through the first <code>k</code> elements (or all elements if the array's length is less than <code>k</code>) and increase each element by the given value.</p>
</li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize</p>
<ol>
<li>an integer array <code>stackArray</code> to store the stack elements.</li>
<li>an integer variable <code>topIndex</code> to -1, representing an empty stack.</li>
</ol>
</li>
<li>
<p>In the constructor, initialize <code>stackArray</code> with the given <code>maxSize</code>.</p>
</li>
<li>
<p>In the <code>push</code> method:</p>
<ul>
<li>Check if <code>topIndex</code> is less than the last index of <code>stackArray</code>.</li>
<li>If true, increment <code>topIndex</code> and add the new element <code>x</code> at that index.</li>
</ul>
</li>
<li>
<p>In the <code>pop</code> method:</p>
<ul>
<li>Check if <code>topIndex</code> is greater than or equal to <code>0</code>.</li>
<li>If true, return the element at <code>topIndex</code> and decrement <code>topIndex</code>.</li>
<li>If false, return <code>-1</code> to indicate an empty stack.</li>
</ul>
</li>
<li>
<p>In the <code>increment</code> method:</p>
<ul>
<li>Calculate the <code>limit</code> as the minimum of <code>k</code> and <code>topIndex + 1</code>.</li>
<li>Iterate from <code>0</code> to <code>limit - 1</code>:
<ul>
<li>For each iteration, add <code>val</code> to the element at index <code>i</code> in <code>stackArray</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LS96QBTV/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span> for <code>push</code> and <code>pop</code>, <span class="math inline">\(O(k)\)</span> for <code>increment</code></p>
<p>The <code>push</code> and <code>pop</code> methods both perform a single comparison and at most one array operation, all of which are constant time operations.</p>
<p>The <code>increment</code> method iterates over <span class="math inline">\(k\)</span> elements in the worst case, thus having a <span class="math inline">\(O(k)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\text{maxSize})\)</span></p>
<p>The overall space complexity is <span class="math inline">\(O(\text{maxSize})\)</span>, due to the <code>stackArray</code> which can store at most <span class="math inline">\(\text{maxSize}\)</span> elements.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-linked-list">Approach 2: Linked List</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, the array has a fixed size (<code>maxSize</code>), regardless of whether the stack ever reaches full capacity. This can lead to wasted space. A more efficient solution is to use a data structure that grows dynamically with the stack while still allowing constant-time operations on its end element. A linked list is well-suited for this purpose.</p>
<p>The linked list implementation is similar to the array-based approach, but it optimizes space usage. Instead of modifying the element at a specific <code>topIndex</code>, the push operation adds a new node to the tail of the linked list, and the pop operation removes the tail node. The increment operation remains largely the same: we iterate through the first <code>k</code> elements (or all elements if the list has fewer than <code>k</code> nodes) and update their values.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize</p>
<ul>
<li>a list named <code>stack</code> to store the elements of the custom stack.</li>
<li>a variable <code>maxSize</code> to hold the maximum capacity of the stack.</li>
</ul>
</li>
<li>
<p>In the constructor:</p>
<ul>
<li>Set <code>maxSize</code> to the provided parameter value.</li>
</ul>
</li>
<li>
<p>In the <code>push</code> method:</p>
<ul>
<li>Check if the current size of <code>stack</code> is less than <code>maxSize</code>:
<ul>
<li>If true, add the new element to the end of <code>stack</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>In the <code>pop</code> method:</p>
<ul>
<li>If the <code>stack</code> is empty, return -1.</li>
<li>Else, remove and return the last element of <code>stack</code>.</li>
</ul>
</li>
<li>
<p>In the <code>increment</code> method:</p>
<ul>
<li>Iterate over the first <code>k</code> elements of the stack (or all elements if <code>k</code> exceeds the <code>stack</code> size).
<ul>
<li>For each element, update its value by adding <code>val</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5aBvpcmf/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span> for <code>push</code> and <code>pop</code>, <span class="math inline">\(O(k)\)</span> for <code>increment</code></p>
<p>The <code>push</code> and <code>pop</code> operations modify the last node in the list, both taking constant time.</p>
<p>In the worst case, the <code>increment</code> method updates <span class="math inline">\(k\)</span> elements, taking <span class="math inline">\(O(k)\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\text{maxSize})\)</span></p>
<p>The stack can store <span class="math inline">\(\text{maxSize}\)</span> elements in the worst case.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-array-using-lazy-propagation">Approach 3: Array using Lazy Propagation</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, the <code>increment</code> operation modified the bottom <code>k</code> elements directly, which can become inefficient for large stacks or frequent increments. To improve this, we can use lazy propagation, a technique where updates are delayed until absolutely necessary.</p>
<p>Instead of immediately updating all affected elements during an increment, we store the increment value and apply it only when needed. This is useful when dealing with a range of elements but without the need for immediate updates.</p>
<p>We introduce an additional array, <code>incrementArray</code>, that tracks the increment values. Each index <code>i</code> in this array holds the cumulative value by which the elements <code>[0, i]</code> in the stack will be incremented.</p>
<ul>
<li>
<p><code>push()</code>:<br />
The push operation remains the same as before. No changes are needed in the <code>incrementArray</code> because pushing doesn't involve any increment adjustments.</p>
</li>
<li>
<p><code>pop()</code>:<br />
When popping an element, we return the value at the top of the stack, including any increments that apply to it. This is where lazy propagation is used.</p>
<p>First, we retrieve the value at <code>topIndex</code> and add the corresponding increment from <code>incrementArray</code>. Since this top position is being removed, the increment for it needs to be passed down to the next element below. We do this by adding the increment at <code>topIndex</code> to <code>incrementArray[topIndex-1]</code>, preserving the necessary increments for future pops.</p>
<p>Then, we decrement <code>topIndex</code> to remove the current top element.</p>
</li>
<li>
<p><code>increment()</code>:<br />
Instead of directly modifying the bottom <code>k</code> elements, we simply update the value at index <code>k-1</code> in <code>incrementArray</code>. If the stack size is less than <code>k</code>, we update the increment at <code>topIndex</code> instead. This avoids unnecessary modifications and applies the increments only when the affected elements are accessed.</p>
</li>
</ul>
<p>Check out the algorithm in action in the slideshow below:</p>
<p>!?!../Documents/1381/slideshow.json:1132,754!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize</p>
<ol>
<li>an integer array <code>stackArray</code> to store the stack elements.</li>
<li>an integer array <code>incrementArray</code> to store increments for lazy propagation.</li>
<li>an integer variable <code>topIndex</code> to <code>-1</code>, representing an empty stack.</li>
</ol>
</li>
<li>
<p>In the constructor:</p>
<ul>
<li>Initialize <code>stackArray</code> with the given <code>maxSize</code>.</li>
<li>Initialize <code>incrementArray</code> with the same <code>maxSize</code>.</li>
<li>Set <code>topIndex</code> to <code>-1</code>.</li>
</ul>
</li>
<li>
<p>In the <code>push</code> method:</p>
<ul>
<li>Check if <code>topIndex</code> is less than the last index of <code>stackArray</code>.</li>
<li>If true, increment <code>topIndex</code> and add the new element <code>x</code> at that index in <code>stackArray</code>.</li>
</ul>
</li>
<li>
<p>In the <code>pop</code> method:</p>
<ul>
<li>Check if <code>topIndex</code> is less than 0.</li>
<li>If true, return <code>-1</code> to indicate an empty stack.</li>
<li>Calculate the actual value by adding <code>stackArray[topIndex]</code> and <code>incrementArray[topIndex]</code>.</li>
<li>If <code>topIndex</code> is greater than 0, add <code>incrementArray[topIndex]</code> to <code>incrementArray[topIndex - 1]</code>.</li>
<li>Reset <code>incrementArray[topIndex]</code> to <code>0</code>.</li>
<li>Decrement <code>topIndex</code>.</li>
<li>Return the calculated result.</li>
</ul>
</li>
<li>
<p>In the <code>increment</code> method:</p>
<ul>
<li>Check if <code>topIndex</code> is greater than or equal to <code>0</code>.</li>
<li>If true, calculate <code>incrementIndex</code> as the minimum of <code>topIndex</code> and <code>k - 1</code>.</li>
<li>Add <code>val</code> to <code>incrementArray[incrementIndex]</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/4D5jeCLA/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span> for all operations</p>
<p>The <code>push</code>, <code>pop</code>, and <code>increment</code> methods perform only constant time operations (comparisons and array operations).</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\text{maxSize})\)</span></p>
<p>The <code>stackArray</code> and the <code>incrementArray</code> arrays both have a size of <span class="math inline">\(\text{maxSize}\)</span>. Thus, the overall space complexity of the algorithm is <span class="math inline">\(O(2 \cdot \text{maxSize}) = O(\text{maxSize})\)</span></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-a-text-editor/description" target="_blank" rel="noopener noreferrer">Design a Text Editor</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked-list</span> <span class="topic-badge">linked-list</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a text editor with a cursor that can do the following:</p>

<ul>
	<li><strong>Add</strong> text to where the cursor is.</li>
	<li><strong>Delete</strong> text from where the cursor is (simulating the backspace key).</li>
	<li><strong>Move</strong> the cursor either left or right.</li>
</ul>

<p>When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that <code>0 &lt;= cursor.position &lt;= currentText.length</code> always holds.</p>

<p>Implement the <code>TextEditor</code> class:</p>

<ul>
	<li><code>TextEditor()</code> Initializes the object with empty text.</li>
	<li><code>void addText(string text)</code> Appends <code>text</code> to where the cursor is. The cursor ends to the right of <code>text</code>.</li>
	<li><code>int deleteText(int k)</code> Deletes <code>k</code> characters to the left of the cursor. Returns the number of characters actually deleted.</li>
	<li><code>string cursorLeft(int k)</code> Moves the cursor to the left <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>
	<li><code>string cursorRight(int k)</code> Moves the cursor to the right <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;TextEditor&quot;, &quot;addText&quot;, &quot;deleteText&quot;, &quot;addText&quot;, &quot;cursorRight&quot;, &quot;cursorLeft&quot;, &quot;deleteText&quot;, &quot;cursorLeft&quot;, &quot;cursorRight&quot;]
[[], [&quot;leetcode&quot;], [4], [&quot;practice&quot;], [3], [8], [10], [2], [6]]
<strong>Output</strong>
[null, null, 4, null, &quot;etpractice&quot;, &quot;leet&quot;, 4, &quot;&quot;, &quot;practi&quot;]

<strong>Explanation</strong>
TextEditor textEditor = new TextEditor(); // The current text is &quot;|&quot;. (The &#39;|&#39; character represents the cursor)
textEditor.addText(&quot;leetcode&quot;); // The current text is &quot;leetcode|&quot;.
textEditor.deleteText(4); // return 4
                          // The current text is &quot;leet|&quot;. 
                          // 4 characters were deleted.
textEditor.addText(&quot;practice&quot;); // The current text is &quot;leetpractice|&quot;. 
textEditor.cursorRight(3); // return &quot;etpractice&quot;
                           // The current text is &quot;leetpractice|&quot;. 
                           // The cursor cannot be moved beyond the actual text and thus did not move.
                           // &quot;etpractice&quot; is the last 10 characters to the left of the cursor.
textEditor.cursorLeft(8); // return &quot;leet&quot;
                          // The current text is &quot;leet|practice&quot;.
                          // &quot;leet&quot; is the last min(10, 4) = 4 characters to the left of the cursor.
textEditor.deleteText(10); // return 4
                           // The current text is &quot;|practice&quot;.
                           // Only 4 characters were deleted.
textEditor.cursorLeft(2); // return &quot;&quot;
                          // The current text is &quot;|practice&quot;.
                          // The cursor cannot be moved beyond the actual text and thus did not move. 
                          // &quot;&quot; is the last min(10, 0) = 0 characters to the left of the cursor.
textEditor.cursorRight(6); // return &quot;practi&quot;
                           // The current text is &quot;practi|ce&quot;.
                           // &quot;practi&quot; is the last min(10, 6) = 6 characters to the left of the cursor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length, k &lt;= 40</code></li>
	<li><code>text</code> consists of lowercase English letters.</li>
	<li>At most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>addText</code>, <code>deleteText</code>, <code>cursorLeft</code> and <code>cursorRight</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Could you find a solution with time complexity of <code>O(k)</code> per call?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-browser-history/description" target="_blank" rel="noopener noreferrer">Design Browser History</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">data-stream</span> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked-list</span> <span class="topic-badge">linked-list</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a <strong>browser</strong> of one tab where you start on the <code>homepage</code> and you can visit another <code>url</code>, get back in the history number of <code>steps</code> or move forward in the history number of <code>steps</code>.</p>

<p>Implement the <code>BrowserHistory</code> class:</p>

<ul>
	<li><code>BrowserHistory(string homepage)</code> Initializes the object with the <code>homepage</code>&nbsp;of the browser.</li>
	<li><code>void visit(string url)</code>&nbsp;Visits&nbsp;<code>url</code> from the current page. It clears up all the forward history.</li>
	<li><code>string back(int steps)</code>&nbsp;Move <code>steps</code> back in history. If you can only return <code>x</code> steps in the history and <code>steps &gt; x</code>, you will&nbsp;return only <code>x</code> steps. Return the current <code>url</code>&nbsp;after moving back in history <strong>at most</strong> <code>steps</code>.</li>
	<li><code>string forward(int steps)</code>&nbsp;Move <code>steps</code> forward in history. If you can only forward <code>x</code> steps in the history and <code>steps &gt; x</code>, you will&nbsp;forward only&nbsp;<code>x</code> steps. Return the current <code>url</code>&nbsp;after forwarding in history <strong>at most</strong> <code>steps</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example:</strong></p>

<pre>
<b>Input:</b>
[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]
[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]
<b>Output:</b>
[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]

<b>Explanation:</b>
BrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;);
browserHistory.visit(&quot;google.com&quot;);       // You are in &quot;leetcode.com&quot;. Visit &quot;google.com&quot;
browserHistory.visit(&quot;facebook.com&quot;);     // You are in &quot;google.com&quot;. Visit &quot;facebook.com&quot;
browserHistory.visit(&quot;youtube.com&quot;);      // You are in &quot;facebook.com&quot;. Visit &quot;youtube.com&quot;
browserHistory.back(1);                   // You are in &quot;youtube.com&quot;, move back to &quot;facebook.com&quot; return &quot;facebook.com&quot;
browserHistory.back(1);                   // You are in &quot;facebook.com&quot;, move back to &quot;google.com&quot; return &quot;google.com&quot;
browserHistory.forward(1);                // You are in &quot;google.com&quot;, move forward to &quot;facebook.com&quot; return &quot;facebook.com&quot;
browserHistory.visit(&quot;linkedin.com&quot;);     // You are in &quot;facebook.com&quot;. Visit &quot;linkedin.com&quot;
browserHistory.forward(2);                // You are in &quot;linkedin.com&quot;, you cannot move forward any steps.
browserHistory.back(2);                   // You are in &quot;linkedin.com&quot;, move back two steps to &quot;facebook.com&quot; then to &quot;google.com&quot;. return &quot;google.com&quot;
browserHistory.back(7);                   // You are in &quot;google.com&quot;, you can move back only one step to &quot;leetcode.com&quot;. return &quot;leetcode.com&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= homepage.length &lt;= 20</code></li>
	<li><code>1 &lt;= url.length &lt;= 20</code></li>
	<li><code>1 &lt;= steps &lt;= 100</code></li>
	<li><code>homepage</code> and <code>url</code> consist of&nbsp; &#39;.&#39; or lower case English letters.</li>
	<li>At most <code>5000</code>&nbsp;calls will be made to <code>visit</code>, <code>back</code>, and <code>forward</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/design-browser-history/1" target="_blank" rel="noopener noreferrer">Design Browser History</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">design-pattern</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You have a&nbsp;<strong>browser</strong>&nbsp;of one tab where you start on the&nbsp;<code>homepage</code>&nbsp;and you can visit another&nbsp;<code>url</code>, get back in the history number of&nbsp;<code>steps</code>&nbsp;or move forward in the history number of&nbsp;<code>steps</code>.</span></p>

<p><span style="font-size:18px">Implement the&nbsp;<code>BrowserHistory</code>&nbsp;class:</span></p>

<ul>
	<li><span style="font-size:18px"><code>BrowserHistory (string homepage)</code>&nbsp;Initializes the object with the&nbsp;<code>homepage</code>&nbsp;of the browser.</span></li>
	<li><span style="font-size:18px"><code>void visit (string url)</code>&nbsp;Visits&nbsp;<code>url</code>&nbsp;from the current page. It clears up all the forward history.</span></li>
	<li><span style="font-size:18px"><code>string back (int steps)</code>&nbsp;Move&nbsp;<code>steps</code>&nbsp;back in history. If you can only return&nbsp;<code>x</code>&nbsp;steps in the history and&nbsp;<code>steps &gt; x</code>, you will&nbsp;return only&nbsp;<code>x</code>&nbsp;steps. Return the current&nbsp;<code>url</code>&nbsp;after moving back in history&nbsp;<strong>at most</strong>&nbsp;<code>steps</code>.</span></li>
	<li><span style="font-size:18px"><code>string forward (int steps)</code>&nbsp;Move&nbsp;<code>steps</code>&nbsp;forward in history. If you can only forward&nbsp;<code>x</code>&nbsp;steps in the history and&nbsp;<code>steps &gt; x</code>, you will&nbsp;forward only&nbsp;<code>x</code>&nbsp;steps. Return the current&nbsp;<code>url</code>&nbsp;after forwarding in history&nbsp;<strong>at most</strong>&nbsp;<code>steps</code>.</span></li>
</ul>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
homepage = &quot;gfg.org&quot;
visit(&quot;google.com&quot;);
visit(&quot;facebook.com&quot;);
visit(&quot;youtube.com&quot;);
back(1);
back(1);
forward(1);
visit(&quot;linkedin.com&quot;);
forward(2);
back(2);
back(7);

<strong>Output:</strong></span>
<span style="font-size:18px">facebook.com</span>
<span style="font-size:18px">google.com</span>
<span style="font-size:18px">facebook.com</span>
<span style="font-size:18px">linkedin.com</span>
<span style="font-size:18px">google.com</span>
<span style="font-size:18px">gfg.org

<strong>Explanation: </strong>
query1: you are now at &quot;google.com&quot;
query2: you are now at &quot;facebook.com&quot;
query3: you are now at &quot;youtube.com&quot;
query4: move one step back, you will be at
&nbsp;       &quot;facebook.com&quot; again.
query5: move one more step back, you will be
&nbsp;       at &quot;google.com&quot;
query6: move one step forward, you will be 
&nbsp;       at &quot;facebook.com&quot;
query7: jump to &quot;linkedin.com&quot;
query8: No forward steps available, be at 
&nbsp;       &quot;linkedin.com&quot;
query9: move two steps back, you will go to 
&nbsp;       &quot;facebook.com&quot; and then &quot;google.com&quot;
query10: required 7 steps backward but only 
&nbsp;        1 step available, so move 1 step  
&nbsp;        back, you will be at &quot;gfg.org&quot;</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
homepage = &quot;google.com&quot;
visit(&quot;youtube.com&quot;);
back(2);

<strong>Output:
</strong>google.com

<strong>Explanation:</strong>
Required 2 steps backward, but only 1 step
available. So move 1 step back and you will
be at &quot;google.com&quot;</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to design your data structure inside&nbsp;<strong>class&nbsp;BrowserHistory</strong>&nbsp;and&nbsp;complete&nbsp;the functions <strong>visit()</strong>, <strong>back(),&nbsp;forward()&nbsp;</strong>and the <strong>constructor</strong>.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(1) for back(), forward() and O(n) for visit()</span></p>

<p><span style="font-size:18px"><strong>Expected Space Complexity:</strong> O(n)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span></p>

<ul>
	<li><span style="font-size:18px"><code>1 &lt;= no. of queries &lt;= 5000</code></span></li>
	<li><span style="font-size:18px"><code>1 &lt;= homepage.length &lt;= 20</code></span></li>
	<li><span style="font-size:18px"><code>1 &lt;= url.length &lt;= 20</code></span></li>
	<li><span style="font-size:18px"><code>1 &lt;= steps &lt;= 100</code></span></li>
	<li><span style="font-size:18px"><code>homepage</code>&nbsp;and&nbsp;<code>url</code>&nbsp;consist of&nbsp; &#39;.&#39; or lower case English letters.</span></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/design-twitter/1" target="_blank" rel="noopener noreferrer">Design Twitter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">design-pattern</span> <span class="topic-badge">hash</span> <span class="topic-badge">heap</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:</span></p>
<ol>
<li><span style="font-size: 18px;"><strong>postTweet (userId, tweetId)</strong>: Compose a new tweet.</span></li>
<li><span style="font-size: 18px;"><strong>getNewsFeed (userId)</strong>: Retrieve the 10 most recent tweet ids in the user's news feed (If total number of tweets in news feed is less than 10, then return all). Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</span></li>
<li><span style="font-size: 18px;"><strong>follow (followerId, followeeId)</strong>: Follower follows a followee.</span></li>
<li><span style="font-size: 18px;"><strong>unfollow (followerId, followeeId)</strong>: Follower unfollows a followee.</span></li>
</ol>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">postTweet(1, 5);</span>
<span style="font-size: 18px;">getNewsFeed(1);</span>
<span style="font-size: 18px;">follow(1, 2);</span>
<span style="font-size: 18px;">postTweet(2, 6);</span>
<span style="font-size: 18px;">getNewsFeed(1);</span>
<span style="font-size: 18px;">unfollow(1, 2);</span>
<span style="font-size: 18px;">getNewsFeed(1);</span>

<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">[5]</span>
<span style="font-size: 18px;">[6, 5]</span>
<span style="font-size: 18px;">[5]</span>
<span style="font-size: 18px;">
<strong>Explanation: </strong>
postTweet(1,5): User 1 posts a new tweet (id=5)
getNewsFeed(1): Return a list with 1 tweet [5]</span>
<span style="font-size: 18px;">follow(1,2)   : User 1 follows user 2.
postTweet(2,6): User 2 posts a new tweet (id=6)</span>
<span style="font-size: 18px;">getNewsFeed(1): Return a list with 2 tweets 
[6,5]. One his own tweet and one followee's tweet
(sorted from most recent to least recent).</span>
<span style="font-size: 18px;">unfollow(1,2) : User 1 unfollows user 2</span>
<span style="font-size: 18px;">getNewsFeed(1): Return a list with 1 tweet [5],
because user 1 is no longer following anyone.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>follow(1, 2);
postTweet(1, 3);
getNewsFeed(2);</span>
<span style="font-size: 18px;"><strong>Output:
</strong>[]</span>
<span style="font-size: 18px;"><strong>Explanation:</strong>
follow(1,2)   : User 1 follows user 2.
postTweet(1,3): User 1 posts a new tweet (id=3)
getNewsFeed(2): Return a list with 0 tweet [],
because user2 have no tweets and don't follow
anyone (user1 follows user 2 but user 2 don't
follow anyone)</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp; </strong><br />You don't need to read input or print anything. Your task is to design your data structure inside the&nbsp;<strong>class Twitter</strong> and complete the functions <strong>postTweet()</strong>, <strong>getNewsFeed()</strong>, <strong>follow()</strong>, <strong>unfollow(),</strong> and the <strong>constructor</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<p><span style="font-size: 18px;"><code>1 &lt;= no. of queries&nbsp;&lt;= 1000</code></span><br /><span style="font-size: 18px;"><code>1 &lt;= userId, tweetId, followerId, followeeId&nbsp;&lt;= 10<sup>5</sup></code></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/dinner-plate-stacks/description" target="_blank" rel="noopener noreferrer">Dinner Plate Stacks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have an infinite number of stacks arranged in a row and numbered (left to right) from <code>0</code>, each of the stacks has the same maximum capacity.</p>

<p>Implement the <code>DinnerPlates</code> class:</p>

<ul>
	<li><code>DinnerPlates(int capacity)</code> Initializes the object with the maximum capacity of the stacks <code>capacity</code>.</li>
	<li><code>void push(int val)</code> Pushes the given integer <code>val</code> into the leftmost stack with a size less than <code>capacity</code>.</li>
	<li><code>int pop()</code> Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns <code>-1</code> if all the stacks are empty.</li>
	<li><code>int popAtStack(int index)</code> Returns the value at the top of the stack with the given index <code>index</code> and removes it from that stack or returns <code>-1</code> if the stack with that given index is empty.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;DinnerPlates&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAtStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAtStack&quot;, &quot;popAtStack&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;]
[[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]
<strong>Output</strong>
[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]

<strong>Explanation:</strong> 
DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // The stacks are now:  2  4
                                           1  3  5
                                           ï¹ˆ ï¹ˆ ï¹ˆ
D.popAtStack(0);   // Returns 2.  The stacks are now:     4
                                                       1  3  5
                                                       ï¹ˆ ï¹ˆ ï¹ˆ
D.push(20);        // The stacks are now: 20  4
                                           1  3  5
                                           ï¹ˆ ï¹ˆ ï¹ˆ
D.push(21);        // The stacks are now: 20  4 21
                                           1  3  5
                                           ï¹ˆ ï¹ˆ ï¹ˆ
D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21
                                                        1  3  5
                                                        ï¹ˆ ï¹ˆ ï¹ˆ
D.popAtStack(2);   // Returns 21.  The stacks are now:     4
                                                        1  3  5
                                                        ï¹ˆ ï¹ˆ ï¹ˆ 
D.pop()            // Returns 5.  The stacks are now:      4
                                                        1  3 
                                                        ï¹ˆ ï¹ˆ  
D.pop()            // Returns 4.  The stacks are now:   1  3 
                                                        ï¹ˆ ï¹ˆ   
D.pop()            // Returns 3.  The stacks are now:   1 
                                                        ï¹ˆ   
D.pop()            // Returns 1.  There are no stacks.
D.pop()            // Returns -1.  There are still no stacks.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= capacity &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= val &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= index &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>push</code>, <code>pop</code>, and <code>popAtStack</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/double-a-number-represented-as-a-linked-list/description" target="_blank" rel="noopener noreferrer">Double a Number Represented as a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked-list</span> <span class="topic-badge">math</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a <strong>non-empty</strong> linked list representing a non-negative integer without leading zeroes.</p>

<p>Return <em>the </em><code>head</code><em> of the linked list after <strong>doubling</strong> it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/05/28/example.png" style="width: 401px; height: 81px;" />
<pre>
<strong>Input:</strong> head = [1,8,9]
<strong>Output:</strong> [3,7,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/05/28/example2.png" style="width: 401px; height: 81px;" />
<pre>
<strong>Input:</strong> head = [9,9,9]
<strong>Output:</strong> [1,9,9,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>4</sup>]</code></li>
	<li><font face="monospace"><code>0 &lt;= Node.val &lt;= 9</code></font></li>
	<li>The input is generated such that the list represents a number that does not have leading zeros, except the number <code>0</code> itself.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a singly linked list representing a non-negative integer and we need to return a linked list that represents the result of doubling the original number.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The linked list does not contain any negative integers nor any leading zeros.</li>
<li>The result of doubling a digit can be greater than 9. In such cases, we need to carry over the extra digit to the next node and accommodate it in the answer.</li>
</ol>
<hr />
<h3 id="approach-1-reversing-the-list">Approach 1: Reversing the List</h3>
<h4 id="intuition">Intuition</h4>
<p>Doubling a number can be performed by adding a number to itself. We can develop a solution by following the steps of addition, which are performed from the least significant to the most significant digit. Reversing the order of the nodes in the list would allow us to traverse the list starting with the least significant digit. Then, we double each digit and perform the carry to double the number.</p>
<p>The idea of reversing the list seems promising, as it would allow us to process the nodes in the opposite order, starting from the least significant digit. This could make the logic for handling the carry much easier to implement.</p>
<p>Why would this make the logic for handling the carry much easier?</p>
<p>Let's consider the example from the problem statement:</p>
<pre><code>Input: head = [1,8,9]
Output: [3,7,8]
</code></pre>
<p>Now, let's think about how we would typically process this number to double each digit and handle the carry.</p>
<p>If we were to process the digits from the most significant to the least significant, it would look like this:</p>
<ul>
<li>Double the most significant digit (1): 2</li>
<li>Handle the carry (2): The carry is 0, so we don't need to do anything.</li>
<li>Double the next digit (8): 16</li>
<li>Handle the carry (16): The carry is 1, which needs to be added to the previous digit.</li>
<li>Double the least significant digit (9): 18</li>
<li>Handle the carry (18): The carry is 1, which needs to be added to the previous digit.</li>
</ul>
<p>As we can see, handling the carry becomes more complicated as we move from the most significant digit to the least significant digit. We need to keep track of the carry and propagate it to the previous digit, which can become cumbersome, especially for longer numbers.</p>
<p>However, if we reverse the list, the problem becomes much simpler:</p>
<ul>
<li>Reverse the list: [9, 8, 1]</li>
<li>Double the least significant digit (9): 18</li>
<li>Handle the carry (18): The carry is 1, which can be easily added to the next digit.</li>
<li>Double the next digit (8): 16</li>
<li>Handle the carry (16): The carry is 1, which can be easily added to the next digit.</li>
<li>Double the most significant digit (1): 2</li>
<li>Handle the carry (2): The carry is 0, so we don't need to do anything.</li>
</ul>
<p>By reversing the list, we're effectively processing the digits from the least significant to the most significant. This simplifies the carry handling logic because the carry only depends on the current digit and the previous carry, rather than having to consider the entire number.</p>
<p>Once the list is reversed, we can iterate through the nodes and perform the following steps for each node:</p>
<ul>
<li>Double the value of the current node.</li>
<li>Add the carry (if any) from the previous operation.</li>
<li>Replace the data of the current node with the result modulo 10 (to handle values greater than 9).</li>
<li>Compute the new carry by integer division (to handle values greater than 9).</li>
</ul>
<p>After processing all the nodes, if there is any remaining carry, we create a new node with the carry value and append it to the list.</p>
<p>Finally, we reverse the list one more time to restore the original order of the nodes.</p>
<p>The following is an illustration demonstrating the reversing the list approach:</p>
<p>!?!../Documents/2816/brute_reversing.json:977,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li><code>doubleIt(head)</code> function:</li>
</ol>
<ul>
<li>Call the <code>reverseList(head)</code> helper function to reverse the input linked list and store it in <code>reversedList</code>.</li>
<li>Initialize two pointers, <code>current</code> and <code>previous</code>, to keep track of the current node and the previous node, respectively. Also, initialize a <code>carry</code> variable to <code>0</code>.</li>
<li>Traverse the reversed linked list:
<ul>
<li>For each node in the reversed list:
<ul>
<li>Calculate the new value for the current node by doubling the current value and adding the carry.</li>
<li>Update the current node's value with the new value modulo <code>10</code>.</li>
<li>Update the <code>carry</code> variable based on the new value (<code>1</code> if the new value is greater than <code>9</code>, <code>0</code> otherwise).</li>
<li>Move the <code>previous</code> and <code>current</code> pointers to the next nodes.</li>
</ul>
</li>
</ul>
</li>
<li>If there's a non-zero carry left after the loop, create a new node with the carry value and attach it to the end of the list.</li>
<li>Reverse the list back to its original order: Call the <code>reverseList(reversedList)</code> function to reverse the list back to its original order and store the result in <code>result</code>.</li>
<li>Return the <code>result</code> list.</li>
</ul>
<ol start="2">
<li><code>reverseList(node)</code> function:</li>
</ol>
<ul>
<li>Initialize three pointers <code>previous</code> (initially <code>NULL</code>), <code>current</code> (initially <code>node</code>), and <code>nextNode</code> (to temporarily store the next node).</li>
<li>Traverse the list and reverse the links:
<ul>
<li>While the <code>current</code> pointer is not <code>NULL</code>:
<ul>
<li>Store the next node in <code>nextNode</code>.</li>
<li>Reverse the link by setting <code>current-&gt;next</code> to <code>previous</code>.</li>
<li>Move the <code>previous</code> and <code>current</code> pointers to the next nodes.</li>
</ul>
</li>
</ul>
</li>
<li>After the loop, <code>previous</code> will be the new head of the reversed list, so return <code>previous</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FAqg2iD8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm involves traversing the linked list once to double the values and handle carry, performing constant-time operations for each node. So, it takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Reversing the list also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>In-place reversal is performed, so it doesn't incur significant extra space usage. Thus, the space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-stack">Approach 2: Using Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>While the first approach works, it might not be suitable in situations where integer overflow is a concern, such as in languages with fixed-size integer data types. Additionally, the previous approach made three passes through the linked list, which can be inefficient. In this case, we can consider an alternative approach using a stack to manage carry values for generating the new head. This approach ensures that we handle integer overflow concerns efficiently while also reducing the number of passes through the linked list.</p>
<p>The stack-based approach involves traversing the list from head to tail and pushing each node's value onto a stack. This effectively reverses the order of the digits since the stack operates on the Last In, First Out (LIFO) principle. This reversal makes it easier to handle the carry. Instead of modifying the linked list in place, we build a new linked list to store the result. We build this list from tail to head, which eliminates the need for an additional reversal compared to the previous approach.</p>
<blockquote>
<p>Learn more about stacks by reading our <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card</a>.</p>
</blockquote>
<p>We then start popping values from the stack and perform the necessary doubling and carry-handling operations. If there is any carry left after processing the stack, we create a new node with the carry value and prepend it to the result linked list.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an empty stack <code>values</code> to store the values of the linked list nodes.</li>
<li>Initialize a variable <code>val</code> to hold the carryover value when doubling digits.</li>
<li>Traverse the linked list and push the values of the nodes onto the stack.</li>
<li>Initialize the tail of the new linked list as <code>null</code>.</li>
<li>Iterate over the stack of values:
<ul>
<li>Create a new <code>ListNode</code> with value <code>0</code> and the previous tail as its next node.</li>
<li>If the stack is not empty, pop the top value, double it, and add it to the <code>val</code>.</li>
<li>Set the value of the new node to the units digit of the new value.</li>
<li>Update the <code>val</code> to hold the carryover value for the next iteration.</li>
</ul>
</li>
<li>Return the tail of the new linked list.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/FgeXRH6a/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm traverses the linked list once to push its values onto the stack, which takes <span class="math inline">\(O(n)\)</span> time. Then, it iterates over the stack and performs operations to create the new linked list, which also takes <span class="math inline">\(O(n)\)</span> time, as the stack contains <span class="math inline">\(n\)</span> elements.</p>
<p>Therefore, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity mainly depends on the additional space used by the stack to store the values of the linked list, which takes <span class="math inline">\(O(n)\)</span> space.</p>
<p>Additionally, the space used for the new linked list is also <span class="math inline">\(O(n)\)</span> since we are creating a new node for each element in the original linked list.</p>
<p>Therefore, the overall space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-recursion">Approach 3: Recursion</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The previous approach used a stack. If a problem can be solved using stack, we can often implement a similar solution using recursion, which utilizes the recursive call stack instead of a stack data structure.</p>
<p>The idea here is to recursively traverse the list until we reach the end, doubling the value of each node and propagating the carry value back up the recursive calls.</p>
<p>Once the recursion unwinds, we check if there is any non-zero carry left. If so, we create a new node with the carry value and add it to the beginning of the result linked list.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define a helper function <code>twiceOfVal(head)</code> that recursively computes twice each node's value and propagates the carry.</p>
</li>
<li>
<p>Base case: If <code>head</code> is <code>null</code>, return <code>0</code>.</p>
</li>
<li>
<p>Compute twice the value of the current node and add the result of the next node.</p>
</li>
<li>
<p>Update the current node's value with the units digit of the result.</p>
</li>
<li>
<p>Return the <code>carry</code> (tens digit of the result).</p>
</li>
<li>
<p>In the main <code>doubleIt(head)</code> function, call the <code>twiceOfVal(head)</code> helper function to compute the carry and store it in a variable <code>carry</code>.</p>
</li>
<li>
<p>If the most significant digit has a <code>carry</code> value, insert a new node at the beginning with the <code>carry</code> value.</p>
</li>
<li>
<p>Return the <code>head</code> of the updated linked list.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/XbiMiicQ/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>twiceOfVal</code> function recursively traverses the entire linked list once, performing constant-time operations at each node. Therefore, the time complexity of the <code>twiceOfVal</code> function is <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>doubleIt</code> function calls the <code>twiceOfVal</code> function once, which has a time complexity of <span class="math inline">\(O(n)\)</span>. Additionally, inserting a new node at the beginning of the linked list takes constant time. Hence, the overall time complexity of the <code>doubleIt</code> function is <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>twiceOfVal</code> function is tail-recursive, meaning it should typically use <span class="math inline">\(O(1)\)</span> space on the call stack due to the recursive calls in C++ and Java. However, in languages like Python, which don't optimize tail recursion, each recursive call consumes additional space on the call stack. Therefore, the space complexity of <code>twiceOfVal</code> is <span class="math inline">\(O(n)\)</span> due to the recursive call stack.</p>
<p>The <code>doubleIt</code> function uses no additional space apart from the space required for the input linked list. Hence, its space complexity is <span class="math inline">\(O(1)\)</span>.</p>
<p>Therefore, the overall space complexity of the algorithm is dominated by the recursive call stack, making it <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-two-pointers">Approach 4: Two Pointers</h3>
<h4 id="intuition-3">Intuition</h4>
<p>One of the main challenges in the problem is dealing with the carry when doubling the values of the nodes. The previous approaches handled this by either reversing the list or using a stack to reverse the order of the digits, which introduced linear auxiliary space and/or multiple passes through the linked list. Now, let's consider a more efficient approach that aims to update the list in-place without reversing it.</p>
<p>The insight here is that to handle the carry efficiently, we need to maintain some context about the previous node's value. This would allow us to update the previous node's value if the current node's doubled value resulted in a carry. It's like preserving the state of the carry.</p>
<p>To maintain the necessary context, we can use two pointers: &quot;previous&quot; and &quot;current&quot;. The &quot;previous&quot; pointer keeps track of the previous node, while the &quot;current&quot; pointer points to the node being processed.</p>
<p>By using the two pointers, we can iterate through the list and process the nodes. For each node, we can double the value and handle the carry by updating the previous node's value if necessary.</p>
<p>When processing each node in the linked list, there are three distinct cases to consider:</p>
<ol>
<li>
<p>If the doubled value is less than <code>10</code>:</p>
<p>In this case, the value of the current node is simply replaced with its doubled value.</p>
</li>
<li>
<p>If the doubled value is greater than or equal to <code>10</code>:</p>
<p>Here, the value of the current node is replaced with the remainder (modulo <code>10</code>) of its doubled value, and the previous node's value is updated to reflect the carry.</p>
</li>
<li>
<p>If the first node's value needs to be updated with a carry:</p>
<p>If the doubled value of the first node is greater than or equal to <code>10</code>, a new node is created with a value of <code>1</code>, and it becomes the new head of the list.</p>
</li>
</ol>
<p>This structured approach ensures proper handling of each node in the linked list while accounting for carry values when necessary.</p>
<p>The following is an illustration demonstrating the two pointer approach:</p>
<p>!?!../Documents/2816/twopointer.json:976,302!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>current</code> and <code>previous</code> pointers to traverse the linked list.</li>
<li>For each node:</li>
<li>Compute twice the value of the current node.</li>
<li>If the doubled value is less than 10, update the current node's value.</li>
<li>If the doubled value is 10 or greater:
<ul>
<li>Update the current node's value with the units digit of the doubled value.</li>
<li>If the <code>previous</code> pointer is not <code>null</code> (not the first node), update the previous node's value to add the carry.</li>
</ul>
</li>
<li>If it's the first node and the doubled value is 10 or greater, create a new node with the carry value and link it to the current node, updating the <code>head</code> pointer.</li>
<li>Update the <code>previous</code> and <code>current</code> pointers to the next nodes.</li>
<li>Return the <code>head</code> of the modified linked list.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/FDhU7FiN/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm traverses the entire linked list once. Within the loop, each operation (including arithmetic operations and pointer manipulations) takes constant time.</p>
<p>Therefore, the time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses only a constant amount of additional space for storing pointers and temporary variables, regardless of the size of the input linked list.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-single-pointer">Approach 5: Single Pointer</h3>
<h4 id="intuition-4">Intuition</h4>
<p>A key goal of the two-pointer approach was to reduce the memory footprint of the solution. While efficient, this approach still required maintaining two separate pointers (<code>prev</code> and <code>curr</code>).</p>
<p>We found that updating the previous node's value was only necessary when there was a carry from the current node. This insight will become the foundation for the single-pointer approach.</p>
<p>By focusing on where the previous node's value needed to be updated, we could simplify the logic and eliminate the need for the previous pointer.</p>
<p>We can achieve this using a single pointer to traverse the list. For each node, we will double the value and check if there was a carry from the next node. Since each node's value can range from <code>0</code> to <code>9</code>, doubling it could result in values from 0 to 18.</p>
<p>If the doubled value exceeds <code>9</code>, it indicates a carry to the previous digit place. However, since we are doubling each digit, a carry would occur when the doubled value is greater than or equal to <code>10</code>. We check if the value of the next node (i.e., <code>current.next.val</code>) is greater than <code>4</code>, because if it's greater than <code>4</code>, it implies that its doubled value is at least <code>10</code>. Therefore, we can handle the carry by adding one to the current node's doubled value, which calculates the correct final value for the current node.</p>
<p>The following is an illustration demonstrating the single pointer approach:</p>
<p>!?!../Documents/2816/singlepointer.json:980,308!?!</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>If the value of the <code>head</code> node is greater than <code>4</code>, insert a new node with the value <code>0</code> at the beginning of the list.</li>
<li>Traverse the linked list using a single <code>node</code> pointer:</li>
<li>Double the value of the current node and update it with the units digit.</li>
<li>If the current node has a next node and the next node's value is greater than <code>4</code>, increment the current node's value to handle the carry.</li>
<li>Return the <code>head</code> of the updated linked list.</li>
</ul>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZAAg4Epc/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm traverses the entire linked list once, visiting each node. Within the loop, each operation (including arithmetic operations and pointer manipulations) takes constant time.</p>
<p>Therefore, the time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses only a constant amount of additional space for storing pointers and temporary variables, regardless of the size of the input linked list.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/easy-string2212/1" target="_blank" rel="noopener noreferrer">Easy string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:20px">You are given the string S . Compress the string&nbsp;when lower and upper cases are the same. In compressed string characters should be in lowercase.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>S = &quot;aaABBb&quot;
<strong>Output:</strong> &quot;3a3b&quot;
<strong>Explanation</strong>: As &#39;a&#39; appears 3 times
consecutively and &#39;b&#39; also 3 times,
and &#39;b&#39; and &#39;B&#39; considered as same. 
</span></pre>

<p><span style="font-size:18px">Ã¢â‚¬â€¹<strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>: S = &quot;aaacca&quot;
<strong>Output:</strong> &quot;3a2c1a&quot;
<strong>Explanation</strong>: As &#39;a&#39; appears 3 times
consecutively and &#39;c&#39; also 2 times,
and then &#39;a&#39; 1 time.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>transform()</strong>&nbsp;which takes the string <strong>S&nbsp;</strong>as inputs and returns the compressed string.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(|S|)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(1)<br />
<br />
<strong>Constraints:</strong><br />
1 &le; |S| &le; 2 * 10<sup>5</sup></span></p>

<p><span style="font-size:18px">S contains only lowercase and uppercase characters.</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/evaluate-reverse-polish-notation/description" target="_blank" rel="noopener noreferrer">Evaluate Reverse Polish Notation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">Reverse Polish Notation</a>.</p>

<p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p>

<p><strong>Note</strong> that:</p>

<ul>
	<li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li>
	<li>Each operand may be an integer or another expression.</li>
	<li>The division between two integers always <strong>truncates toward zero</strong>.</li>
	<li>There will not be any division by zero.</li>
	<li>The input represents a valid arithmetic expression in a reverse polish notation.</li>
	<li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
<strong>Output:</strong> 9
<strong>Explanation:</strong> ((2 + 1) * 3) = 9
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]
<strong>Output:</strong> 6
<strong>Explanation:</strong> (4 + (13 / 5)) = 6
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
<strong>Output:</strong> 22
<strong>Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>
	<li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/exclusive-time-of-functions/description" target="_blank" rel="noopener noreferrer">Exclusive Time of Functions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On a <strong>single-threaded</strong> CPU, we execute a program containing <code>n</code> functions. Each function has a unique ID between <code>0</code> and <code>n-1</code>.</p>

<p>Function calls are <strong>stored in a <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a></strong>: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is <strong>the current function being executed</strong>. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.</p>

<p>You are given a list <code>logs</code>, where <code>logs[i]</code> represents the <code>i<sup>th</sup></code> log message formatted as a string <code>&quot;{function_id}:{&quot;start&quot; | &quot;end&quot;}:{timestamp}&quot;</code>. For example, <code>&quot;0:start:3&quot;</code> means a function call with function ID <code>0</code> <strong>started at the beginning</strong> of timestamp <code>3</code>, and <code>&quot;1:end:2&quot;</code> means a function call with function ID <code>1</code> <strong>ended at the end</strong> of timestamp <code>2</code>. Note that a function can be called <b>multiple times, possibly recursively</b>.</p>

<p>A function&#39;s <strong>exclusive time</strong> is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for <code>2</code> time units and another call executing for <code>1</code> time unit, the <strong>exclusive time</strong> is <code>2 + 1 = 3</code>.</p>

<p>Return <em>the <strong>exclusive time</strong> of each function in an array, where the value at the </em><code>i<sup>th</sup></code><em> index represents the exclusive time for the function with ID </em><code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/04/05/diag1b.png" style="width: 550px; height: 239px;" />
<pre>
<strong>Input:</strong> n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]
<strong>Output:</strong> [3,4]
<strong>Explanation:</strong>
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]
<strong>Output:</strong> [8]
<strong>Explanation:</strong>
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls itself again.
Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.
Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.
So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 2, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]
<strong>Output:</strong> [7,1]
<strong>Explanation:</strong>
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls function 1.
Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.
Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.
So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>2 &lt;= logs.length &lt;= 500</code></li>
	<li><code>0 &lt;= function_id &lt; n</code></li>
	<li><code>0 &lt;= timestamp &lt;= 10<sup>9</sup></code></li>
	<li>No two start events will happen at the same timestamp.</li>
	<li>No two end events will happen at the same timestamp.</li>
	<li>Each function has an <code>&quot;end&quot;</code> log for each <code>&quot;start&quot;</code> log.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/expression-contains-redundant-bracket-or-not/1" target="_blank" rel="noopener noreferrer">Expression contains redundant bracket or not</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string of balanced expression <strong>str</strong>, find if it contains a redundant parenthesis or not. A set of parenthesis are redundant if the same sub-expression is surrounded by unnecessary or multiple brackets. Return <strong>1</strong> if</span><span style="font-size: 18px;">it contains a redundant parenthesis</span><span style="font-size: 18px;">, else <strong>0</strong>.<br /></span><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;Expression may contain <strong>+ , - ,&nbsp;*,</strong> and<strong> /</strong> operators. Given expression is&nbsp;<strong>valid</strong>&nbsp;and there are&nbsp;<strong>no white</strong>&nbsp;spaces present.</span><br /><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>exp = ((a+b))</span><span style="font-size: 18px;">
<strong>Output:
</strong>Yes
<strong>Explanation:</strong>
((a+b)) can reduced to (a+b).
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
exp = (a+b+(c+d))</span><span style="font-size: 18px;">
<strong>Output:</strong>
No
<strong>Explanation:</strong>
(a+b+(c+d)) doesn't have any redundant or multiple
brackets.</span></pre>
<p><span style="font-size: 18px;"><strong>Your task:<br /></strong></span><span style="font-size: 18px;">You don't have to read input or print anything. Your task is to complete the function <strong>checkRedundancy</strong></span><span style="font-size: 18px;"><strong>()</strong> which takes the string <strong>s</strong> as input and returns <strong>1</strong> if&nbsp;it contains redundant parentheses else <strong>0</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1&lt;=|str|&lt;=10<sup>4</sup></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N)<br /></span><span style="font-size: 18px;"><strong>Expected Auxiliary Space:&nbsp;</strong>O(N)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description" target="_blank" rel="noopener noreferrer">Final Prices With a Special Discount in a Shop</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of the <code>i<sup>th</sup></code> item in a shop.</p>

<p>There is a special discount for items in the shop. If you buy the <code>i<sup>th</sup></code> item, then you will receive a discount equivalent to <code>prices[j]</code> where <code>j</code> is the minimum index such that <code>j &gt; i</code> and <code>prices[j] &lt;= prices[i]</code>. Otherwise, you will not receive any discount at all.</p>

<p>Return an integer array <code>answer</code> where <code>answer[i]</code> is the final price you will pay for the <code>i<sup>th</sup></code> item of the shop, considering the special discount.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> prices = [8,4,6,2,3]
<strong>Output:</strong> [4,2,4,2,3]
<strong>Explanation:</strong> 
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.
For items 3 and 4 you will not receive any discount at all.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> prices = [1,2,3,4,5]
<strong>Output:</strong> [1,2,3,4,5]
<strong>Explanation:</strong> In this case, for all items, you will not receive any discount at all.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> prices = [10,1,1,6]
<strong>Output:</strong> [9,0,1,6]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= prices.length &lt;= 500</code></li>
	<li><code>1 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have an integer array <code>prices</code> listing the prices of items from a shop. Items can receive a special discount based on the price of the next item on the list that is less than or equal to it (if such an item exists). In other words, the discount for <code>prices[i]</code> is <code>prices[j]</code>, where <code>j &gt; i</code>, <code>prices[j] &lt;= prices[i]</code>, and <code>j</code> is the smallest such index that satisfies these conditions.</p>
<p>The task is to calculate the final price for each item, after applying this special discount, and return these final prices in an array called answer.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute-Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the constraints are small, we can solve this problem using a brute-force approach. For each item in the <code>prices</code> array, we need to find a price that is smaller or equal to it and appears later in the array. This price will be our discount amount. We then subtract this discount from the original price to get the final discounted price.</p>
<p>To implement this, let's start by creating a copy of the <code>prices</code> array called <code>result</code>. We'll loop through the <code>prices</code> array and apply the discount we find for each element to the corresponding element in the <code>result</code> array.</p>
<p>For each element in the <code>prices</code> array, we'll run another loop starting from the next element to the right. If we find a price that is less than or equal to the current element, we'll subtract this price from the original price in the <code>result</code> array and stop looking further. If we don't find any suitable discount after checking all subsequent prices, the item's price in the <code>result</code> array will remain unchanged.</p>
<p>After processing all the prices in this manner, the <code>result</code> array will contain the final discounted prices for each item. We can then return this array as our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a variable <code>n</code> to store the length of the input <code>prices</code> array.</li>
<li>Initialize a <code>result</code> array by creating a copy of the input <code>prices</code> array. This ensures we have a copy of the original <code>prices</code> to work with.</li>
<li>Start an outer loop that iterates from <code>0</code> to <code>n - 1</code>, with loop variable <code>i</code>:
<ul>
<li>Start an inner loop that iterates from index <code>i + 1</code> to <code>n - 1</code>, with loop variable <code>j</code>.
<ul>
<li>If <code>prices[j]</code> is less than or equal to <code>prices[i]</code>:
<ul>
<li>Calculate the discounted price by subtracting <code>prices[j]</code> from <code>prices[i]</code>.</li>
<li>Store the calculated discounted price in <code>result[i]</code>.</li>
<li>Break the inner loop as we have found the first valid discount.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>result</code> array containing all final prices after discounts.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cotSxu8J/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>prices</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses two nested loops. The outer loop iterates through each element of the array, and for each element, the inner loop can potentially iterate through all remaining elements. In the worst case, where prices are in strictly increasing order, for each element <code>i</code>, we need to check all elements from <code>i + 1</code> to <code>n - 1</code>. Thus, the time complexity is quadratic, <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm creates a new array <code>result</code> of the same size as the input array to store the final prices. Besides this, only a constant amount of extra space is used for loop variables and temporary calculations.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's focus on a key part of the problem: for any given item, we need to find the first price that is smaller or equal to it and comes after it. This is similar to a classic problem known as finding the &quot;next smaller element,&quot; which can be efficiently solved using a stack. But why does a stack work so well here?</p>
<p>Imagine we are processing prices from left to right. At each step, we need to determine if the current price can serve as a discount for any previous prices. The stack helps us keep track of those previous prices that haven't found their discount yet.</p>
<p>The key intuition is that when we find a price that is smaller than some earlier prices, it must be the discount for those earlier prices that are larger than it. We only care about the most recent of these prices because we want the first available discount.</p>
<p>So, for each element, our stack must contain all the most recent prices before that element that are greater than it. This implies that each element present in the stack must be in increasing order of value. This is called a monotonic stack.</p>
<p>When we encounter an element that is smaller than the top of the stack, this means a discount can be applied to the stack element. We continue popping prices from the stack and applying the discount until the stack is empty or the top price is less than the current price. Then, we push the current price to the top of the stack, to wait for a discount which may come further down. This way, we can both apply discounts and also maintain the monotonic property of the stack.</p>
<p>To implement this idea, we'll maintain a <code>stack</code> of indices (not prices, since we need the positions to apply discounts). We iterate over the <code>prices</code> array and check if the current price is less than or equal to the price at the top of the <code>stack</code>. If it is, the current element can be used as a discount to the elements waiting in the <code>stack</code>. We remove each larger price from the <code>stack</code> and apply the discount, then add the current price to the <code>stack</code>. Any prices left on the <code>stack</code> at the end of the main loop had no discount available.</p>
<p>The slideshow below demonstrates this algorithm in action:</p>
<p>!?!../Documents/1475/slideshow.json:916,756!?!</p>
<br>
<blockquote>
<p>Note: If you are unfamiliar with the workings of monotonic stacks, try out these problems to practice:</p>
<ul>
<li><a href="https://leetcode.com/problems/next-greater-element-i/">496. Next Greater Element I ðŸ”—</a></li>
<li><a href="https://leetcode.com/problems/next-greater-element-ii/">503. Next Greater Element II ðŸ”—</a></li>
<li><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures ðŸ”—</a></li>
</ul>
</blockquote>
<blockquote>
<p>For a more comprehensive understanding of stacks, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card ðŸ”—</a>. This resource provides an in-depth look at the stack data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a <code>result</code> array by creating a copy of the input <code>prices</code> array to store the discounted prices.</li>
<li>an empty <code>stack</code> that will store indices of prices.</li>
</ul>
</li>
<li>For each index <code>i</code> of the prices array:
<ul>
<li>Start a while loop that continues as long as:
<ol>
<li>The <code>stack</code> is not empty, AND</li>
<li>The price at the index stored at the <code>stack</code>'s top is greater than or equal to the current price</li>
</ol>
<ul>
<li>Inside the while loop, pop the top index from the <code>stack</code>.</li>
<li>Calculate the discounted price by subtracting the current price from the price at the popped index.</li>
<li>Store the result in the <code>result</code> array at the popped index.</li>
</ul>
</li>
<li>Add the current index <code>i</code> to the stack.</li>
</ul>
</li>
<li>Return the <code>result</code> array containing all final prices after discounts.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/EMaz6crS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>prices</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the array once with a single loop. Although there is a while loop inside, each element can be pushed and popped from the <code>stack</code> exactly once. This means the total number of operations on the <code>stack</code> across all iterations is at most <span class="math inline">\(2 \cdot n\)</span> (<span class="math inline">\(n\)</span> pushes and <span class="math inline">\(n\)</span> pops).</p>
<p>Thus, the time complexity is <span class="math inline">\(O(2 \cdot n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a <code>result</code> array of size <span class="math inline">\(n\)</span> to store the final prices. Additionally, in the worst case scenario (when prices are in strictly increasing order), the stack could store all <span class="math inline">\(n\)</span> indices.</p>
<p>Thus, the total space complexity is linear, <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-building-where-alice-and-bob-can-meet/description" target="_blank" rel="noopener noreferrer">Find Building Where Alice and Bob Can Meet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-indexed-tree</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">segment-tree</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>heights</code> of positive integers, where <code>heights[i]</code> represents the height of the <code>i<sup>th</sup></code> building.</p>

<p>If a person is in building <code>i</code>, they can move to any other building <code>j</code> if and only if <code>i &lt; j</code> and <code>heights[i] &lt; heights[j]</code>.</p>

<p>You are also given another array <code>queries</code> where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>. On the <code>i<sup>th</sup></code> query, Alice is in building <code>a<sub>i</sub></code> while Bob is in building <code>b<sub>i</sub></code>.</p>

<p>Return <em>an array</em> <code>ans</code> <em>where</em> <code>ans[i]</code> <em>is <strong>the index of the leftmost building</strong> where Alice and Bob can meet on the</em> <code>i<sup>th</sup></code> <em>query</em>. <em>If Alice and Bob cannot move to a common building on query</em> <code>i</code>, <em>set</em> <code>ans[i]</code> <em>to</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
<strong>Output:</strong> [2,5,-1,5,2]
<strong>Explanation:</strong> In the first query, Alice and Bob can move to building 2 since heights[0] &lt; heights[2] and heights[1] &lt; heights[2]. 
In the second query, Alice and Bob can move to building 5 since heights[0] &lt; heights[5] and heights[3] &lt; heights[5]. 
In the third query, Alice cannot meet Bob since Alice cannot move to any other building.
In the fourth query, Alice and Bob can move to building 5 since heights[3] &lt; heights[5] and heights[4] &lt; heights[5].
In the fifth query, Alice and Bob are already in the same building.  
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
<strong>Output:</strong> [7,6,-1,4,6]
<strong>Explanation:</strong> In the first query, Alice can directly move to Bob&#39;s building since heights[0] &lt; heights[7].
In the second query, Alice and Bob can move to building 6 since heights[3] &lt; heights[6] and heights[5] &lt; heights[6].
In the third query, Alice cannot meet Bob since Bob cannot move to any other building.
In the fourth query, Alice and Bob can move to building 4 since heights[3] &lt; heights[4] and heights[0] &lt; heights[4].
In the fifth query, Alice can directly move to Bob&#39;s building since heights[1] &lt; heights[6].
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= heights.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= heights.length - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>heights</code> and an array of pairs <code>queries</code>, where each pair is of the form <span class="math inline">\([a_i, b_i]\)</span>, representing the positions of Alice and Bob at indices <code>i</code> and <code>j</code>, respectively. For each query, the task is to find the closest value to the right in the <code>heights</code> array that is greater than the <code>heights</code> at both the given positions.</p>
<p>In other words, given indices <code>i</code> and <code>j</code>, we need to find the first value in the <code>heights</code> array that is greater than the values at <code>heights[i]</code> and <code>heights[j]</code>. If no such value exists, return -1.</p>
<hr />
<h3 id="approach-1-monotonic-stack">Approach 1: Monotonic Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Letâ€™s start by breaking down the problem into simpler terms. Suppose <code>queries</code> only contained single integer indices. The goal would then be to find, for each index, the first building to the right in the <code>heights</code> array that is taller than the building at that index. Instead of scanning the array repeatedly for each query, we can preprocess the <code>heights</code> array to store this &quot;next taller building&quot; information in advance.</p>
<p>The key insight here is that for each building, the next taller building to its right depends only on the heights of the buildings that come after it. Using a monotonic stack, we can compute this efficiently. By traversing the <code>heights</code> array from right to left, we maintain a stack of indices in decreasing order of heights. For the current building, any shorter or equal buildings already in the stack cannot be the answer, so we remove them. If the stack is not empty, the top element gives the position of the next taller building. If the stack is empty, it means no taller building exists to the right, so we store <code>-1</code>. This preprocessing step allows us to handle single queries in constant time. For a better understanding of this idea, you can refer to <a href="https://leetcode.com/problems/next-greater-element-ii/">Next Greater Element - II</a>, which applies a similar technique.</p>
<p>Now, letâ€™s extend this idea to handle queries that are pairs of values. In this scenario, the task is to find the first height to the right in the <code>heights</code> array that is greater than both values in each pair. Here the key realization is that the answer for a pair depends on the larger of the two values since a building must be taller than both. This simplifies the problem by reducing it to a comparison with a single threshold for each query.</p>
<p>While traversing the <code>heights</code> array, we use a monotonic stack to maintain all elements greater than the current height, with the nearest greater height at the top of the stack. When processing a query, the stack already contains all elements greater than the current height.</p>
<p>For each query pair, we use binary search on the stack to quickly find the first element greater than the larger value in the pair. This ensures that each query is processed in <span class="math inline">\(O(\log n)\)</span> time.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main function - <code>leftmostBuildingQueries(heights, queries)</code></p>
<ol>
<li>Create a list <code>newQueries</code> where each index stores the list of queries that require this index as the maximum index of the query pair. Each query is stored as a pair containing the required height (<code>heights[a]</code>) and the query index.</li>
<li>Initialize a monotonic stack <code>monoStack</code> to keep track of building heights and their indices in decreasing order of height while iterating from right to left in the <code>heights</code> array.</li>
<li>Initialize an array <code>result</code> to store the answers for each query, with all elements initially set to <code>-1</code>.</li>
<li>Iterate over the <code>queries</code>:
<ul>
<li>For each query, extract the two indices <code>a</code> and <code>b</code>.</li>
<li>If <code>a &gt; b</code>, swap the indices to ensure <code>a &lt;= b</code>.</li>
<li>If <code>heights[b] &gt; heights[a]</code> or <code>a == b</code>, set <code>result[currQuery] = b</code>.</li>
<li>Otherwise, add the query to <code>newQueries[b]</code> with its required height (<code>heights[a]</code>) and the query index.</li>
</ul>
</li>
<li>Iterate over the indices of the <code>heights</code> array from right to left:
<ul>
<li>For each query stored at the current index in <code>newQueries</code>, use binary search on the <code>monoStack</code> to find the first building with a height greater than the query's required height. If such a building exists, set the result for the query to the index of this building.</li>
<li>Remove all elements from the top of the <code>monoStack</code> where the height is less than or equal to the current height, as they are no longer relevant.</li>
<li>Push the current height and index onto the <code>monoStack</code>.</li>
</ul>
</li>
<li>Return the <code>result</code> array.</li>
</ol>
<p>Helper Binary Search function - <code>search(height, monoStack)</code></p>
<ol>
<li>Initialize two pointers <code>left = 0</code> and <code>right = size of monoStack - 1</code>. Set a variable <code>ans = -1</code> to store the search result.</li>
<li>Perform a binary search:
<ul>
<li>Calculate <code>mid = (left + right) / 2</code>.</li>
<li>If the height at <code>monoStack[mid]</code> is greater than the required height:
<ul>
<li>Update <code>ans = max(ans, mid)</code> and set <code>left = mid + 1</code>.</li>
</ul>
</li>
<li>Otherwise, set <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>, which will be the index of the first building with a height greater than the required height. If no such building exists, <code>ans</code> remains <code>-1</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AFfMGimL/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>heights</code> and <span class="math inline">\(q\)</span> be the number of queries in the <code>queries</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \cdot \log n + n)\)</span></p>
<p>The algorithm  processes each query using binary search on the monotonic stack, which takes <span class="math inline">\(O(\log n)\)</span> per query. With <span class="math inline">\(q\)</span> queries, the total query processing time is <span class="math inline">\(O(q \cdot \log n)\)</span>. Apart from this, we also iterate through the <code>heights</code> and <code>queries</code> arrays, that takes <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(q)\)</span> time, respectively.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(q \cdot \log n + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The algorithm uses a monotonic stack to store building indices, requiring <span class="math inline">\(O(n)\)</span> space. It also stores queries in the <code>newQueries</code> array and results in the <code>result</code> array, each taking <span class="math inline">\(O(q)\)</span> space.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we calculated the answer using a monotonic stack. Each query asks for the closest index to the right with a value greater than both elements in the query pair. Instead of processing each query one at a time, we can optimize by checking, for each index in the <code>heights</code> array, if it can serve as the answer for any query.</p>
<p>To do this efficiently, we can iterate through the <code>heights</code> array from left to right. For each index, we look for query pairs where both indices are smaller than the current index, and both values in the pair are smaller than the value at the current index. To make this process faster, we prioritize assigning answers to the smallest query pairs first.</p>
<p>By maintaining the query pairs sorted based on their maximum value and index up to the current position, we can process them more efficiently.</p>
<p>To implement this idea, we process the <code>heights</code> array while managing the queries by storing them in a 2D array of arrays, where each subarray holds the queries for the corresponding building.</p>
<p>We begin by sorting and mapping the queries to track the index and values that we need. Using a priority queue, we store queries based on their maximum value and index. This helps us quickly retrieve the smallest index for processing.</p>
<p>As we move through the <code>heights</code> array, we pop the queries from the queue. For each query, if the current index is greater than both indices of the query, we assign the current index as the answer and store it. We also check if new queries, whose maximum index matches the current one, should be added to the queue for future processing.</p>
<p>This allows us to handle queries without reprocessing them repeatedly.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>storeQueries</code> as a 2D array of arrays to store queries for each building.</p>
</li>
<li>
<p>Initialize <code>maxIndex</code> as a priority queue to track the queries that need to be answered based on building heights.</p>
</li>
<li>
<p>Initialize <code>result</code> as an array of <code>-1</code> to store the answers for each query.</p>
</li>
<li>
<p>Loop through each query:</p>
<ul>
<li>For each query <code>(a, b)</code>:
<ul>
<li>If the height of building <code>a</code> is less than building <code>b</code> and <code>a</code> is smaller than <code>b</code>, set <code>result[currQuery]</code> to <code>b</code> (building <code>b</code> is the answer).</li>
<li>If the height of building <code>a</code> is greater than building <code>b</code> and <code>a</code> is greater than <code>b</code>, set <code>result[currQuery]</code> to <code>a</code> (building <code>a</code> is the answer).</li>
<li>If <code>a</code> is equal to <code>b</code>, set <code>result[currQuery]</code> to <code>a</code> (both are the same building).</li>
<li>Otherwise, store the query in <code>storeQueries[max(a, b)]</code> for future processing.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Loop through each building index <code>index</code>:</p>
<ul>
<li>While the priority queue <code>maxIndex</code> has elements and the minimum value in <code>maxIndex</code> is smaller than the current building height:
<ul>
<li>Set the corresponding query's result in <code>result</code> and pop the element from <code>maxIndex</code> (this query is answered).</li>
</ul>
</li>
<li>Push new queries from <code>storeQueries[index]</code> into <code>maxIndex</code>, sorting them by height.</li>
</ul>
</li>
<li>
<p>Return the <code>result</code> array containing the answers to all queries.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gobEvzsi/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>heights</code> and <span class="math inline">\(q\)</span> be the number of queries in the <code>queries</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \cdot \log q + n)\)</span></p>
<p>The algorithm first iterates over the <code>queries</code> array to map the maximum indices and heights in <code>storeQueries</code>, taking <span class="math inline">\(O(q)\)</span> time. It then processes each index in the <code>heights</code> array, updating results via a priority queue. Insertion and deletion operations in the priority queue take <span class="math inline">\(O(\log q)\)</span> each, with at most <span class="math inline">\(q\)</span> queries processed. For each index, the algorithm checks and pushes relevant queries from <code>storeQueries</code>, resulting in an overall <span class="math inline">\(O(n)\)</span> time for all iterations.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(q \cdot \log q + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The algorithm uses a array <code>storeQueries</code> to store query mappings, which requires <span class="math inline">\(O(n)\)</span> space, as each element corresponds to an index in <code>heights</code>. Additionally, a priority queue <code>maxIndex</code> is used to handle queries, which at most can store <span class="math inline">\(O(q)\)</span> elements. The <code>result</code> array also requires <span class="math inline">\(O(q)\)</span> space to store the answers.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-maximum-non-decreasing-array-length/description" target="_blank" rel="noopener noreferrer">Find Maximum Non-decreasing Array Length</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">monotonic-queue</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>You can perform any number of operations, where each operation involves selecting a <strong>subarray</strong> of the array and replacing it with the <strong>sum</strong> of its elements. For example, if the given array is <code>[1,3,5,6]</code> and you select subarray <code>[3,5]</code> the array will convert to <code>[1,8,6]</code>.</p>

<p>Return <em>the </em><strong><em>maximum</em></strong><em> length of a </em><strong><em>non-decreasing</em></strong><em> array that can be made after applying operations.</em></p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,2,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> This array with length 3 is not non-decreasing.
We have two ways to make the array length two.
First, choosing subarray [2,2] converts the array to [5,4].
Second, choosing subarray [5,2] converts the array to [7,2].
In these two ways the array is not non-decreasing.
And if we choose subarray [5,2,2] and replace it with [9] it becomes non-decreasing. 
So the answer is 1.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The array is non-decreasing. So the answer is 4.
</pre>

<p><strong>Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Replacing [3,2] with [5] converts the given array to [4,5,6] that is non-decreasing.
Because the given array is not non-decreasing, the maximum<!-- notionvc: 3447a505-d1ee-4411-8cae-e52162f53a55 --> possible answer is 3.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-mirror-score-of-a-string/description" target="_blank" rel="noopener noreferrer">Find Mirror Score of a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash-table</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>.</p>

<p>We define the <strong>mirror</strong> of a letter in the English alphabet as its corresponding letter when the alphabet is reversed. For example, the mirror of <code>&#39;a&#39;</code> is <code>&#39;z&#39;</code>, and the mirror of <code>&#39;y&#39;</code> is <code>&#39;b&#39;</code>.</p>

<p>Initially, all characters in the string <code>s</code> are <strong>unmarked</strong>.</p>

<p>You start with a score of 0, and you perform the following process on the string <code>s</code>:</p>

<ul>
	<li>Iterate through the string from left to right.</li>
	<li>At each index <code>i</code>, find the closest <strong>unmarked</strong> index <code>j</code> such that <code>j &lt; i</code> and <code>s[j]</code> is the mirror of <code>s[i]</code>. Then, <strong>mark</strong> both indices <code>i</code> and <code>j</code>, and add the value <code>i - j</code> to the total score.</li>
	<li>If no such index <code>j</code> exists for the index <code>i</code>, move on to the next index without making any changes.</li>
</ul>

<p>Return the total score at the end of the process.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aczzx&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>i = 0</code>. There is no index <code>j</code> that satisfies the conditions, so we skip.</li>
	<li><code>i = 1</code>. There is no index <code>j</code> that satisfies the conditions, so we skip.</li>
	<li><code>i = 2</code>. The closest index <code>j</code> that satisfies the conditions is <code>j = 0</code>, so we mark both indices 0 and 2, and then add <code>2 - 0 = 2</code> to the score.</li>
	<li><code>i = 3</code>. There is no index <code>j</code> that satisfies the conditions, so we skip.</li>
	<li><code>i = 4</code>. The closest index <code>j</code> that satisfies the conditions is <code>j = 1</code>, so we mark both indices 1 and 4, and then add <code>4 - 1 = 3</code> to the score.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcdef&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>For each index <code>i</code>, there is no index <code>j</code> that satisfies the conditions.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-most-competitive-subsequence/description" target="_blank" rel="noopener noreferrer">Find the Most Competitive Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and a positive integer <code>k</code>, return <em>the most<strong> competitive</strong> subsequence of </em><code>nums</code> <em>of size </em><code>k</code>.</p>

<p>An array&#39;s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.</p>

<p>We define that a subsequence <code>a</code> is more <strong>competitive</strong> than a subsequence <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, subsequence <code>a</code> has a number <strong>less</strong> than the corresponding number in <code>b</code>. For example, <code>[1,3,4]</code> is more competitive than <code>[1,3,5]</code> because the first position they differ is at the final number, and <code>4</code> is less than <code>5</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,2,6], k = 2
<strong>Output:</strong> [2,6]
<strong>Explanation:</strong> Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,3,3,5,4,9,6], k = 4
<strong>Output:</strong> [2,3,3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/description" target="_blank" rel="noopener noreferrer">Find the Number of Subarrays Where Boundary Elements Are Maximum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>positive</strong> integers <code>nums</code>.</p>

<p>Return the number of <span data-keyword="subarray-nonempty">subarrays</span> of <code>nums</code>, where the <strong>first</strong> and the <strong>last</strong> elements of the subarray are <em>equal</em> to the <strong>largest</strong> element in the subarray.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,3,3,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>

<ul>
	<li>subarray <code>[<strong><u>1</u></strong>,4,3,3,2]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</li>
	<li>subarray <code>[1,<u><strong>4</strong></u>,3,3,2]</code>, with its largest element 4. The first element is 4 and the last element is also 4.</li>
	<li>subarray <code>[1,4,<u><strong>3</strong></u>,3,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[1,4,3,<u><strong>3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[1,4,3,3,<u><strong>2</strong></u>]</code>, with its largest element 2. The first element is 2 and the last element is also 2.</li>
	<li>subarray <code>[1,4,<u><strong>3,3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
</ul>

<p>Hence, we return 6.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>

<ul>
	<li>subarray <code>[<u><strong>3</strong></u>,3,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,<strong><u>3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,3,<u><strong>3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[<strong><u>3,3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,<u><strong>3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[<u><strong>3,3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
</ul>

<p>Hence, we return 6.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>There is a single subarray of <code>nums</code> which is <code>[<strong><u>1</u></strong>]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</p>

<p>Hence, we return 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flatten-binary-tree-to-linked-list/description" target="_blank" rel="noopener noreferrer">Flatten Binary Tree to Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-tree</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">linked-list</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>

<ul>
	<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>
	<li>The &quot;linked list&quot; should be in the same order as a <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" target="_blank"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" style="width: 500px; height: 226px;" />
<pre>
<strong>Input:</strong> root = [1,2,5,3,4,null,6]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flatten-nested-list-iterator/description" target="_blank" rel="noopener noreferrer">Flatten Nested List Iterator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">design</span> <span class="topic-badge">iterator</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>

<p>Implement the <code>NestedIterator</code> class:</p>

<ul>
	<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>
	<li><code>int next()</code> Returns the next integer in the nested list.</li>
	<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>
</ul>

<p>Your code will be tested with the following pseudocode:</p>

<pre>
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
</pre>

<p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]
<strong>Output:</strong> [1,1,2,1,1]
<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nestedList = [1,[4,[6]]]
<strong>Output:</strong> [1,4,6]
<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>
	<li>The values of the integers in the nested list is in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/fun-game-91510e9f/" target="_blank" rel="noopener noreferrer">Fun Game &lt;Capillary&gt;</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">easy</span> <span class="topic-badge">hiring</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><strong><span class="mathjax-latex">\(A\)</span></strong> and <span class="mathjax-latex">\(B\)</span> Â are playing a game. In this game, both of them are initially provided with a <strong>list of <span class="mathjax-latex">\(n\)</span>Â numbers</strong>. (Both have the same list but their own copy).</p>

<p>Now, they both have a different strategy to play the game. <strong><span class="mathjax-latex">\(A\)</span></strong> picks the element from <strong>start of his list</strong>.<strong> <span class="mathjax-latex">\(B\)</span></strong> picks from the <strong>end of his list</strong>.</p>

<p>You need to generate the result in form of an output list.</p>

<p>Method to be followed at each step to build the output list is:</p>

<ol>
	<li>If the number picked by <strong><span class="mathjax-latex">\(A\)</span> is bigger than <span class="mathjax-latex">\(B\)</span> </strong> then this step's <strong>output is <span class="mathjax-latex">\(1\)</span> </strong>. <strong><span class="mathjax-latex">\(B\)</span></strong> <strong>removes</strong> the number that was picked from their list.</li>
	<li>If the number picked by <strong><span class="mathjax-latex">\(A\)</span> is smaller than <span class="mathjax-latex">\(B\)</span> </strong> then this step's <strong>output is <span class="mathjax-latex">\(2\)</span> </strong>. <strong><span class="mathjax-latex">\(A\)</span>Â removes</strong> the number that was picked from their list.</li>
	<li>If both have the <strong>same number</strong> then this step's<strong> output is <span class="mathjax-latex">\(0\)</span> </strong>. <strong>Both </strong>$$A$$<strong> and </strong>$$B$$<strong>Â  remove</strong>Â the number that was picked from their list.</li>
</ol>

<p>This game <strong>ends</strong> when at least one of them has no more elements to be picked i.e. when the<strong> list gets empty</strong>.</p>

<p>Output the built output list.<br>
Â Â </p>

<p><strong>Input format:</strong></p>

<p>First line consists of a number <strong><span class="mathjax-latex">\(n\)</span> </strong>, size of the list provided.<br>
Next line consists of <strong><span class="mathjax-latex">\(n\)</span> </strong> numbers separated by space.</p>

<p><br>
<strong>Output format:</strong></p>

<p>Output the required output list.</p>

<p><br>
<strong>Constraints:</strong></p>

<p>$$1 \le N \le 10^6$$<br>
$$1 \leÂ numbers \; in \; the \; listÂ \le 10^9$$</p>

<p>Â </p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>1st step: A picks 1. B picks 3. B &gt; A. So output is 2. A removes 1.<br>
2nd step: A picks 2. B picks 3. B &gt; A. So output is 2. A removes 2.<br>
3rd step: A picks 3. B picks 3. B = A. So output is 0. A removes 3. B removes 3.</p>

<p>Output list: [2, 2, 0]</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/geek-and-number-string--141631/1" target="_blank" rel="noopener noreferrer">Geek and Number String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Geek has a string&nbsp;<strong>S </strong>of size&nbsp;<strong>N </strong>consisting&nbsp;of characters from&nbsp;<strong>'0'</strong>to '<strong>9'.</strong>&nbsp;He wants to minimise&nbsp;the length of the string. In each minimising operation, geek can remove&nbsp;any two consecutive characters if they are of the form&nbsp;<strong>{"12", "21", "34", "43", "56", "65", "78", "87", "09", "90"}</strong>.<br />Find the minimum possible length of the string after applying minimising operations.&nbsp;</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>N = 5 
S = "12213"
<strong>Output:</strong> 1
<strong>Explanation: </strong>Geek can get the string of 
length 1 in two minimising operation,
In 1st operation Geek will remove "12" 
from "<strong>12</strong>213" then Geek left with "213"
In 2nd operation Geek will remove "21" 
from "<strong>21</strong>3" then Geek left with "3"</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>N = 4
S = "1350"
<strong>Output:</strong> 4
<strong>Explanation: </strong>Can't remove any character.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task: &nbsp;</strong><br />You don't need to read input or print anything. Complete the function<strong>minLength()&nbsp;</strong>which takes N and S as input parameters&nbsp;and returns the the minimum possible length of the string.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(N)<br /><strong>Expected Auxiliary Space:</strong>O(N)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/geeks-and-the-string--170645/1" target="_blank" rel="noopener noreferrer">Geeks And The String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Our geek loves to play with strings, Currently, he is trying to reduce the size of a string by recursively removing all the consecutive duplicate pairs. In other words, He can apply the below operations any number of times.</span></p>

<ul>
	<li><span style="font-size:18px">Remove all the consecutive duplicate pairs and concatenate the remaining string to replace the original string.</span></li>
</ul>

<p><span style="font-size:18px">Your task is to find the string with minimum length after applying the above operations.</span></p>

<p><strong><span style="font-size:18px">Note:&nbsp;</span></strong><span style="font-size:18px">If the string length become zero after applying operations, return &quot;-1&quot; as a string.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
aaabbaaccd
<strong>Output</strong>: 
ad
<strong>Explanation</strong>: 
Remove (aa)abbaaccd =&gt;abbaaccd
Remove a(bb)aaccd =&gt; aaaccd
Remove (aa)accd =&gt; accd
Remove a(cc)d =&gt; ad
</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>: 
aaaa
<strong>Output</strong>: 
Empty String
<strong>Explanation</strong>: 
Remove (aa)aa =&gt; aa
Again removing pair of duplicates then (aa) 
will be removed and we will get &#39;Empty String&#39;.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
This is a <strong>function </strong>problem. You only need to <strong>complete </strong>the function<strong> removePair()&nbsp;</strong>that takes a&nbsp;<strong>string </strong>as a&nbsp;<strong>parameter</strong> and <strong>returns </strong>the <strong>modified string</strong>. Return &quot;-1&quot; if the whole string is deleted.</span></p>

<p><span style="font-size:16px"><strong>Expected Time Complexity:</strong>&nbsp;O(N)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N)</span><br />
<br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= |str| &lt;= 10<sup>4</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/get-min-at-pop/1" target="_blank" rel="noopener noreferrer">Get min at pop</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an integer array <strong>A[]</strong>. You need to first push the elements of the array into a stack and then print minimum in the stack at each pop until stack becomes empty.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: A[] = [1 2 3 4 5]
<strong>Output</strong>: 1 1 1 1 1
<strong>Explanation</strong>: 
After pushing elements to the stack, 
the stack will be "top -&gt; 5, 4, 3, 2, 1". 
Now, start popping elements from the stack
popping&nbsp;5: min in&nbsp;the stack is&nbsp;1.popped 5
popping&nbsp;4: min in the stack is 1. popped 4
popping&nbsp;3: min in the stack is&nbsp;1. popped 3
popping 2: min in the stack is 1. popped 2
popping 1: min in the stack is 1. popped 1
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: A[] = [1 6 43 1 2 0 5]
<strong>Output</strong>: 0 0 1 1 1 1 1
<strong>Explanation</strong>: 
After pushing the elements to the stack, 
the stack will be 5-&gt;0-&gt;2-&gt;1-&gt;43-&gt;6-&gt;1. 
Now, poping the elements from the stack:
popping 5: min in the stack is 0. popped 5
popping 0: min in the stack is 0. popped 0
popping 2: min in the stack is 1. popped 2
popping 1: min in the stack is 1. popped 1
popping 43: min in the stack is 1. popped 43
popping 6: min in the stack is 1. popped 6
popping 1: min in the stack is 1. popped 1.</span>
</pre>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong><br /><span style="font-size: 18px;">0 &lt;= A<sub>i</sub> &lt;= 10<sup>7</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/get-minimum-element-from-stack/1" target="_blank" rel="noopener noreferrer">Get Min from Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given <strong>q</strong> queries,&nbsp;</span><span style="font-size: 18.6667px;">You task is to implement the following <strong>four</strong> functions for a stack:</span></p>
<ul>
<li style="text-align: left;"><span style="font-size: 18.6667px;"><strong>push(x) &ndash; </strong>Insert an integer x onto the stack.</span></li>
<li style="text-align: left;"><span style="font-size: 18.6667px;"><strong>pop() &ndash; </strong>Remove the top element from the stack.</span></li>
<li style="text-align: left;"><span style="font-size: 18.6667px;"><strong>peek() - </strong>Return the top element&nbsp;</span><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px;">from the stack.</span><strong><strong style="font-size: 18.6667px;">&nbsp;</strong><span style="font-family: monospace; font-size: 18.6667px; font-weight: 400;">If the stack is empty, return -1.</span><br /></strong></span></li>
<li style="text-align: left;"><span style="font-size: 18.6667px;"><strong>getMin() &ndash; </strong>Retrieve the minimum element from the stack in O(1) time. If the stack is empty, return -1.</span></li>
</ul>
<p><span style="font-size: 14pt;">Each query can be one of the following:</span></p>
<ul>
<li><span style="font-size: 14pt;"><strong>1 x</strong> : Push x onto the stack.</span></li>
<li><span style="font-size: 14pt;"><strong>2 :</strong> Pop the top element from the stack.</span></li>
<li><span style="font-family: monospace;"><span style="font-size: 18.6667px;"><strong>3:</strong> Return the top element from the stack. If the stack is empty, return -1.</span></span></li>
<li><span style="font-family: monospace;"><span style="font-size: 18.6667px;"><strong>4:</strong> Return the minimum element from the stack.</span></span></li>
</ul>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> q = 7, queries = [[1, 2], [1, 3], [3], [2], [4], [1, 1], [4]]<strong>
Output: </strong>[3, 2, 1]<strong>
Explanation: </strong>
push(2): Stack is [2]
push(3): Stack is [2, 3]
peek(): Top element is 3
pop(): Removes 3, stack is [2]
getMin(): Minimum element is 2
push(1): Stack is [2, 1]
getMin(): Minimum element is 1</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input:</strong><span style="font-size: 14pt;"> q = 4, queries = [[1, 4], [1, 2], [4], [3]]</span><strong style="font-size: 14pt;">
Output: </strong><span style="font-size: 14pt;">[2, 2]</span><strong style="font-size: 14pt;">
Explanation: <br /></strong><span style="font-size: 18.6667px;">push(4): Stack is [4]
push(2): Stack is [4, 2]</span><span style="font-size: 14pt;"><br /></span><span style="font-size: 18.6667px;">getMin(): Minimum element is 2</span><span style="font-size: 14pt;"><br /></span><span style="font-size: 18.6667px;">peek(): Top element is 2</span></span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input:</strong><span style="font-size: 14pt;"> q = 5, queries = [[1, 10], [4], [1, 5], [4], [2]]</span><strong style="font-size: 14pt;">
Output: </strong><span style="font-size: 14pt;">[10, 5]</span><strong style="font-size: 14pt;">
Explanation: <br /></strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"><span style="font-size: 18.6667px;">push(10): Stack is [10]</span><span style="font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif;"><span style="font-size: 14pt;"><br /></span></span></span></span><span style="font-size: 18.6667px;">getMin(): Minimum element is 10</span><br /><span style="font-size: 14pt;"><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"><span style="font-size: 18.6667px;">push(5): Stack is [10, 5]</span><span style="font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif;"><span style="font-size: 14pt;"><br /></span></span></span></span><span style="font-size: 18.6667px;">getMin(): Minimum element is 5</span><br /><span style="font-size: 18.6667px;">pop(): Removes 5, stack is [10]</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= q &lt;= 10<sup>5</sup><br />0 &lt;= values on the stack &lt;= 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/save-gotham1222/1" target="_blank" rel="noopener noreferrer">Greater tower sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are some towers in stright line. You are given an array <strong>arr </strong>denoting the height of each tower. For tower <strong>p</strong>, the greater tower is the closest tower (towards the right), greater than the height of tower <strong>p</strong>. Return the sum of the heights of all tower's greater towers.<br /><strong>Note: </strong>Return the answer by taking modulo 1e9+7.&nbsp;&nbsp;If for a tower&nbsp;<strong>k</strong>, no such tower exists then take its height as 0<br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input :</strong> arr[] = [112, 133, 161, 311, 122, 512, 1212, 0, 19212]
<strong>Output :</strong> 41265
<strong>Explanation: </strong>nextgreater(112) : 133 nextgreater(133) : 161 nextgreater(161) : 311 nextgreater(311) : 512 nextgreater(122) : 512 nextgreater(512) : 1212 nextgreater(1212) : 19212 nextgreater(0) : 19212 nextgreater(19212) : 0
add = 133+161+311+512+512+1212+19212+19212+0 = 41265.<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input :</strong> arr[] = [5, 9, 7, 6] <strong>
Output :</strong> 9<br /><strong>Explanation: </strong>nextgreater(5) : 9 </span><span style="font-size: 14pt;">nextgreater(9) : 0 nextgreater(7) : 0 nextgreater(6) : 0</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n).<br /><strong>Expected Auxiliary Space:</strong> O(n).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />0 &le; arr[i] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/help-classmates--141631/1" target="_blank" rel="noopener noreferrer">Help Classmates</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Professor X wants his students to help each other in the chemistry lab. He suggests that every student should help out a classmate who scored less marks than him in chemistry and whose roll number appears after him. But the students are lazy and they don&#39;t want to search too far. They each pick the first roll number after them that fits the criteria. Find the marks of the classmate that each student picks.<br />
<strong>Note:</strong> one student may be selected by multiple classmates.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>N = 5, arr[] = {3, 8, 5, 2, 25}
<strong>Output:</strong> 2 5 2 -1 -1
<strong>Explanation:</strong> 
1. Roll number 1 has 3 marks. The first person 
who has less marks than him is roll number 4, 
who has 2 marks.
2. Roll number 2 has 8 marks, he helps student 
with 5 marks.
3. Roll number 3 has 5 marks, he helps student 
with 2 marks.
4. Roll number 4 and 5 can not pick anyone as 
no student with higher roll number has lesser 
marks than them. This is denoted by -1.
Output shows the marks of the weaker student that 
each roll number helps in order. ie- 2,5,2,-1,-1</span></pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>N = 4, a[] = {1, 2, 3, 4}
<strong>Output:</strong> -1 -1 -1 -1&nbsp;
<strong>Explanation:</strong> As the marks ars in increasing order. 
None of the students can find a classmate who has 
a higher roll number and less marks than them.
</span></pre>

<p><span style="font-size:18px"><strong>Your Task: </strong>&nbsp;<br />
You don&#39;t need to read input or print anything. Complete the function <strong>help_classmate()</strong> which takes the array arr[] and&nbsp;size of array N as input parameters and returns a list of numbers. If a student is unable to find anyone then output is&nbsp;-1.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 5*10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-rectangular-area-in-a-histogram-1587115620/1" target="_blank" rel="noopener noreferrer">Histogram Max Rectangular Area</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a <strong>histogram</strong> represented by an array <strong>arr</strong>, where each element of the array denotes the <strong>height</strong> of the bars in the histogram. All bars have the same <strong>width of 1 unit</strong>. </span></p>
<p><span style="font-size: 18px;">Your task is to find the <strong>largest</strong> rectangular area possible in the given histogram, where the rectangle can be formed using a number of contiguous bars.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = <span style="font-family: 'andale mono', monospace;">[</span></span><span style="color: #273239; font-family: 'andale mono', monospace; font-size: 18px; letter-spacing: 0.162px; text-wrap: wrap; background-color: #f9f9f9;">60, 20, 50, 40, 10, 50, 60]<br /></span><span style="font-size: 18px;"> <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240924161857/Largest-Rectangular-Area-in-a-Histogram.webp" alt="Largest-Rectangular-Area-in-a-Histogram" width="437" height="210" />
<strong>Output: </strong>100<strong>
Explanation: </strong></span><span style="font-size: 18px;">We get the maximum by picking bars highlighted above in green (50, and 60). The area is computed (smallest height) * (no. of the picked bars) = 50 * 2 = 100.</span><img src="http://d1hyf4ir1gqw6c.cloudfront.net/wp-content/uploads/histogram1.png" alt="" />
</pre>
<pre><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [3, 5, 1, 7, 5, 9]<strong>
Output: </strong>15<strong>
Explanation:  </strong>We get the maximum by picking bars 7, 5 and 9. The area is computed (smallest height) * (no. of the picked bars) = 5 * 3 = 15.</span></span></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [3]</span><span style="font-size: 18px;">
<strong>Output: </strong>3<strong>
Explanation: </strong>In this example the largest area would be 3 of height 3 and width 1.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>5</sup><br />0 &le; arr[i] &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/immediate-smaller-element1142/1" target="_blank" rel="noopener noreferrer">Immediate Smaller Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer array <strong>arr</strong>. For each element in the array, check whether the right adjacent element (on the next immediate position) of the array is smaller. If the next element is smaller, update the current index to that element. If not, then update to <strong>-</strong>1.</span></p>
<p><span style="font-size: 18px;">Note: Update the array in itself.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [4, 2, 1, 5, 3]
<strong>Output: </strong>[2, 1, -1, 3, -1]
<strong>Explanation:</strong> Array elements are 4, 2, 1, 5, 3. Next to 4 is 2 which is smaller, so we print 2. Next of 2 is 1 which is smaller,so we print 1. Next of 1 is 5 which is greater, so we print -1. Next of 5 is 3 which is smaller, so we print 3.&nbsp; Note that for last element, output is always  going to be -1 because there is no element on right.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [5, 6, 2, 3, 1, 7]
<strong>Output: </strong>[-1, 2, -1, 1, -1, -1]
<strong>Explanation: </strong>Next to 5 is 6 which is greater, so we print -1. Next of 6 is 2 which is smaller, so we print 2. Next of 2 is 3 which is greater, so we print -1. Next of 3 is 1 which is smaller, so we print 1. Next of 1 is 7 which is greater, so we print -1. Note that for last element, output is always going to be -1 because there is no element on right.<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [4, 1]
<strong>Output: </strong>[1, -1]
<strong>Explanation:</strong> 4 will be updated to 1 and 1 will be updated </span><span style="font-size: 14pt;">to -1.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>5</sup><br />1 &le; arr[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/implement-queue-using-stacks/description" target="_blank" rel="noopener noreferrer">Implement Queue using Stacks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>

<p>Implement the <code>MyQueue</code> class:</p>

<ul>
	<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
	<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
	<li><code>int peek()</code> Returns the element at the front of the queue.</li>
	<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
</ul>

<p><strong>Notes:</strong></p>

<ul>
	<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
	<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&#39;s standard operations.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]
[[], [1], [2], [], [], []]
<strong>Output</strong>
[null, null, null, 1, 1, false]

<strong>Explanation</strong>
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= x &lt;= 9</code></li>
	<li>At most <code>100</code>&nbsp;calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>
	<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href="https://en.wikipedia.org/wiki/Amortized_analysis" target="_blank">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="summary">Summary</h2>
<p>This article is for beginners. It introduces the following ideas:<br />
Queue, Stack.</p>
<h2 id="solution">Solution</h2>
<p>Queue is <strong>FIFO</strong> (first in - first out) data structure, in which the elements are inserted from one side - <code>rear</code> and removed from the other - <code>front</code>.<br />
The most intuitive way to implement it is with linked lists, but this article will introduce another approach  using stacks.<br />
Stack is <strong>LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called <code>top</code>.<br />
To satisfy <strong>FIFO</strong> property of a queue we need to keep two stacks. They serve to reverse arrival order of the  elements and one of them store the queue elements in their final order.</p>
<hr />
<h3 id="approach-1-two-stacks-push---on-per-operation-pop---o1-per-operation">Approach #1 (Two Stacks) Push - <span class="math inline">\(O(n)\)</span> per operation, Pop - <span class="math inline">\(O(1)\)</span> per operation.</h3>
<h4 id="push">Push</h4>
<p>A queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all <code>s1</code> elements to auxiliary stack <code>s2</code>. Then the newly arrived element is pushed on top of <code>s2</code> and all its elements are popped and pushed to <code>s1</code>.</p>
<p><img src="https://leetcode.com/media/original_images/232_queue_using_stacksBPush.png" alt="Push an element in queue" />{:width=&quot;539px&quot;}</p>
<p><em>Figure 1. Push an element in queue</em></p>
<p><a href="https://leetcode.com/playground/ZddHrP5d/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis**</h4>
<ul>
<li>Time complexity : <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives  <span class="math inline">\(4 n + 2\)</span>  operations where <span class="math inline">\(n\)</span> is the queue size. The  <code>push</code> and <code>pop</code> operations have <span class="math inline">\(O(1)\)</span> time complexity.</p>
<ul>
<li>Space complexity : <span class="math inline">\(O(n)\)</span>.<br />
We need additional memory to store the queue elements</li>
</ul>
<h4 id="pop">Pop</h4>
<p>The algorithm pops an element from  the stack <code>s1</code>, because <code>s1</code> stores always on its top the first inserted element in the queue.<br />
The front element of the queue is kept as <code>front</code>.</p>
<p><img src="https://leetcode.com/media/original_images/232_queue_using_stacksBPop.png" alt="Pop an element from queue" />{:width=&quot;539px&quot;}</p>
<p><em>Figure 2. Pop an element from queue</em></p>
<p><a href="https://leetcode.com/playground/UZJY8ns5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>Time complexity : <span class="math inline">\(O(1)\)</span>.</li>
<li>Space complexity : <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<h4 id="empty">Empty</h4>
<p>Stack <code>s1</code> contains all stack elements, so the algorithm checks <code>s1</code> size to return if the queue is empty.</p>
<p><a href="https://leetcode.com/playground/2urvcw97/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>Time complexity : <span class="math inline">\(O(1)\)</span>.</li>
<li>Space complexity : <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<h4 id="peek">Peek</h4>
<p>The <code>front</code> element is kept in constant memory and is modified when we push or pop an element.</p>
<p><a href="https://leetcode.com/playground/VGjvtStE/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<ul>
<li>Time complexity : <span class="math inline">\(O(1)\)</span>. The <code>front</code> element has been calculated in advance and only returned in <code>peek</code> operation.</li>
<li>Space complexity : <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<hr />
<h3 id="approach-2-two-stacks-push---o1-per-operation-pop---amortized-o1-per-operation">Approach #2 (Two Stacks) Push - <span class="math inline">\(O(1)\)</span> per operation, Pop - Amortized <span class="math inline">\(O(1)\)</span> per operation.</h3>
<h4 id="push-1">Push</h4>
<p>The newly arrived element is always added on top of stack <code>s1</code> and the first element is kept as <code>front</code> queue element</p>
<p><img src="https://leetcode.com/media/original_images/232_queue_using_stacksAPush.png" alt="Push an element in queue" />{:width=&quot;539px&quot;}</p>
<p><em>Figure 3. Push an element in queue</em></p>
<p><a href="https://leetcode.com/playground/qaVbztQ7/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(1)\)</span>. Ðppending an element to a stack is an O(1) operation.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. We need additional memory to store the queue elements</p>
</li>
</ul>
<h4 id="pop-1">Pop</h4>
<p>We have to remove element in front of the queue. This is the first inserted element in the stack <code>s1</code> and it is positioned at the bottom of the stack because of stack's <code>LIFO (last in - first out)</code> policy. To remove the bottom element  from  <code>s1</code>, we have to pop all elements from <code>s1</code> and to push them on to an additional stack <code>s2</code>, which helps us to store the elements of <code>s1</code> in reversed order. This way  the bottom element of <code>s1</code> will be positioned on top of <code>s2</code> and we can simply pop it from stack <code>s2</code>. Once <code>s2</code> is empty, the algorithm transfer data from <code>s1</code> to <code>s2</code> again.</p>
<p><img src="https://leetcode.com/media/original_images/232_queue_using_stacksAPop.png" alt="Pop an element from stack" />{:width=&quot;539px&quot;}</p>
<p><em>Figure 4. Pop an element from stack</em></p>
<p><a href="https://leetcode.com/playground/PF3J5wXs/shared">code</a></p>
<h4 id="complexity-analysis-5">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: Amortized <span class="math inline">\(O(1)\)</span>, Worst-case <span class="math inline">\(O(n)\)</span>. In the worst case scenario when stack <code>s2</code> is empty, the algorithm pops <span class="math inline">\(n\)</span> elements from stack s1 and pushes <span class="math inline">\(n\)</span> elements to <code>s2</code>, where <span class="math inline">\(n\)</span> is the queue size. This gives <span class="math inline">\(2n\)</span> operations, which is <span class="math inline">\(O(n)\)</span>. But when stack <code>s2</code> is not empty the algorithm has <span class="math inline">\(O(1)\)</span> time complexity. So what does it mean by Amortized <span class="math inline">\(O(1)\)</span>? Please see the next section on Amortized Analysis for more information.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<h4 id="amortized-analysis">Amortized Analysis</h4>
<p>Amortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost.</p>
<p>Consider this example where we start with an empty queue with the following sequence of operations applied:</p>
<p><span class="math display">\[push_1, push_2, \ldots, push_n, pop_1,pop_2 \ldots, pop_n
\]</span></p>
<p>The worst case time complexity of a single pop operation is <span class="math inline">\(O(n)\)</span>. Since we have <span class="math inline">\(n\)</span> pop operations, using the worst-case per operation analysis gives us a total of <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>However, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time.</p>
<p>In the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per <code>n</code> times (queue size), when <code>s2</code> is empty and there is a need for data transfer between <code>s1</code> and <code>s2</code>. Hence the total time complexity of the sequence is : <code>n</code> (for push operations) + <code>2*n</code> (for first pop operation) + <code>n - 1</code> ( for pop operations) which is <span class="math inline">\(O(2*n)\)</span>.This gives <span class="math inline">\(O(2n/2n)\)</span> = <span class="math inline">\(O(1)\)</span> average time per operation.</p>
<h4 id="empty-1">Empty</h4>
<p>Both stacks <code>s1</code> and <code>s2</code> contain all stack elements, so the algorithm checks <code>s1</code> and <code>s2</code> size to return if the queue is empty.</p>
<p><a href="https://leetcode.com/playground/hswBjmcT/shared">code</a></p>
<h4 id="complexity-analysis-6">Complexity Analysis</h4>
<ul>
<li>Time complexity : <span class="math inline">\(O(1)\)</span>.</li>
<li>Space complexity : <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<h4 id="peek-1">Peek</h4>
<p>The <code>front</code> element is kept in constant memory and is modified when we push an element. When <code>s2</code> is not empty, front element is positioned on the top of <code>s2</code></p>
<p><a href="https://leetcode.com/playground/xmLcBbmw/shared">code</a></p>
<h4 id="complexity-analysis-7">Complexity Analysis</h4>
<ul>
<li>Time complexity : <span class="math inline">\(O(1)\)</span>. The <code>front</code> element was either previously calculated or returned as a top element of stack <code>s2</code>. Therefore complexity is <span class="math inline">\(O(1)\)</span></li>
<li>Space complexity : <span class="math inline">\(O(1)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/implement-stack-using-array/1" target="_blank" rel="noopener noreferrer">Implement stack using array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Write a program to implement a Stack&nbsp;using Array. Your task is to use the class as shown in the comments in the code editor&nbsp;and complete&nbsp;the functions push() and pop() to implement a stack.&nbsp;</span><span style="font-size: 18px;">The push() method&nbsp;takes one argument, an integer&nbsp;</span><strong style="font-size: 18px;">'x'</strong><span style="font-size: 18px;">&nbsp;to be pushed into the stack and&nbsp;</span><strong style="font-size: 18px;">pop()</strong><span style="font-size: 18px;">&nbsp;which returns an integer present at the top and popped out from the stack. If the stack is empty then return&nbsp;</span><strong style="font-size: 18px;">-1</strong><span style="font-size: 18px;"> from the pop() method.</span></p>
<p><strong><span style="font-size: 18px;">Note:&nbsp;</span></strong><span style="font-size: 18px;">The input is given in form of queries. Since there are two operations push() and pop(), there is two types of queries as described below:<br /></span><span style="font-size: 18px;">(i) 1 x&nbsp; &nbsp;(a query of this type means&nbsp; pushing 'x' into the stack)<br /></span><span style="font-size: 18px;">(ii) 2&nbsp; &nbsp; &nbsp;(a query of this type means to pop an element from the stack and print the popped element)<br /></span><span style="font-size: 18px;">Input contains separated by space and as described above.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples </strong>:</span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: 1 2 1 3 2 1 4 2 
<strong>Output</strong>: 3, 4
<strong>Explanation</strong>: 
push(2)    the stack will be {2}
push(3)    the stack will be {2 3}
pop()      poped element will be 3,
&nbsp;          the stack will be {2}
push(4)    the stack will be {2 4}
pop()      poped element will be 4</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: 2 1 4 1 5 2
<strong>Output</strong>: -1, 5</span>
</pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>: O(1)</span><br /><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong>&nbsp;O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= numbers of calls made to push, pop &lt;= 100<br />1 &lt;= x &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/implement-stack-using-queues/description" target="_blank" rel="noopener noreferrer">Implement Stack using Queues</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>

<p>Implement the <code>MyStack</code> class:</p>

<ul>
	<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
	<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
	<li><code>int top()</code> Returns the element on the top of the stack.</li>
	<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>
</ul>

<p><b>Notes:</b></p>

<ul>
	<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>
	<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&#39;s standard operations.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]
[[], [1], [2], [], [], []]
<strong>Output</strong>
[null, null, null, 2, 2, false]

<strong>Explanation</strong>
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= x &lt;= 9</code></li>
	<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>
	<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Can you implement the stack using only one queue?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/increasing-order-search-tree/description" target="_blank" rel="noopener noreferrer">Increasing Order Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-search-tree</span> <span class="topic-badge">binary-tree</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" style="width: 600px; height: 350px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" style="width: 300px; height: 114px;" />
<pre>
<strong>Input:</strong> root = [5,1,7]
<strong>Output:</strong> [1,null,5,null,7]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/indent-ruby-1/" target="_blank" rel="noopener noreferrer">Indent Ruby</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">ad-hoc</span> <span class="topic-badge">medium</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write your program in Ruby which takes an un-indented Ruby code as string and outputs the indented Ruby code as string.</p>
<p><strong>Input Format</strong>
A string which is un-indented Ruby code</p>
<p><strong>Output Format</strong>
A string which is indented Ruby code</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Indentation is of 2 spaces.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/infix-to-postfix-1587115620/1" target="_blank" rel="noopener noreferrer">Infix to Postfix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an infix expression in the form of string <strong>s</strong>. Convert this infix expression to a postfix expression.</span></p>
<ul>
<li><span style="font-size: 14pt;"><strong>Infix expression:</strong> The expression of the form a <strong>op</strong> b. When an operator is in between every pair of operands.</span></li>
<li><span style="font-size: 14pt;"><strong>Postfix expression:</strong> The expression of the form a b <strong>op</strong>. When an operator is followed for every pair of operands.</span></li>
</ul>
<p><span style="font-size: 14pt;">Note:&nbsp;The order of precedence is: ^&nbsp;greater than&nbsp;*&nbsp;equals to&nbsp;/&nbsp;greater than&nbsp;+&nbsp;equals to&nbsp;-. Ignore the right associativity of&nbsp;<strong>^</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: s = "a+b*(c^d-e)^(f+g*h)-i"
<strong>Output</strong>: abcd^e-fgh*+^*+i-
<strong>Explanation</strong>: After converting the infix expression into postfix expression, the resultant expression will be abcd^e-fgh*+^*+i-
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: s = "A*(B+C)/D"
<strong>Output</strong>: ABC+*D/
<strong>Explanation</strong>: After converting the infix expression into postfix expression, the resultant expression will be ABC+*D/<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: s = "(a+b)*(c+d)"
<strong>Output</strong>: ab+cd+*</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; s.length &le; 30</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/insert-an-element-at-the-bottom-of-a-stack/1" target="_blank" rel="noopener noreferrer">Insert an Element at the Bottom of a Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">implementation</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a stack <strong>st</strong> of <strong>n</strong> integers and an element <strong>x</strong>. You have to insert <strong>x</strong> at the bottom of the given stack.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> Everywhere in this problem, the bottommost element of the stack is shown first while priniting the stack.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">n = 5
x = 2
st = {4,3,2,1,8}</span><strong><span style="font-size: 18px;">
Output:
</span></strong><span style="font-size: 18px;">{2,4,3,2,1,8}</span><strong><span style="font-size: 18px;">
Explanation:
</span></strong><span style="font-size: 18px;">After insertion of 2, the final stack will be {2,4,3,2,1,8}.</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">n = 3
x = 4
st = {5,3,1}</span><strong><span style="font-size: 18px;">
Output:
</span></strong><span style="font-size: 18px;">{4,5,3,1}</span><strong><span style="font-size: 18px;">
Explanation:
</span></strong><span style="font-size: 18px;">After insertion of 4, the final stack will be {4,5,3,1}.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function <strong>insertAtBottom()</strong> which takes a stack <strong>st </strong>and an integer <strong>x </strong>as inputs and returns the modified stack after insertion.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Auxiliary Space:</strong> O(n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 10<sup>5</sup><br />0 &lt;= x, elements of stack &lt;= 10<sup>9</sup><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/interleave-the-first-half-of-the-queue-with-second-half/1" target="_blank" rel="noopener noreferrer">Interleave the First Half of the Queue with Second Half</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">implementation</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a Queue of <strong>even </strong>size . Your task is to rearrange the queue by interleaving its <strong>first half </strong>with the<strong> second half</strong>.<br /><strong data-start="0" data-end="16">Interleaving</strong> is the process of mixing two sequences by alternating their elements while preserving their relative order.<br /></span><span style="font-size: 18.6667px;">In other words, Interleaving means place the <strong>first element</strong> from the first half and then <strong>first element</strong> from the 2nd half and again <strong>2nd element</strong> from the first half and then <strong>second element</strong> from the 2nd half and so on...<strong>.</strong></span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>q = [2, 4, 3, 1]</span><span style="font-size: 18px;"><strong>
Output: </strong>[2, 3, 4, 1]<strong>
Explanation: </strong>we place the first element of the first half 2 and after that place the first element of second half 3 and after that repeat<br /></span><span style="font-size: 18px;">the same process one more time so the resulting queue will be [2, 3, 4, 1]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>q = [3, 5]<strong><br />Output: </strong>[3, 5]<strong><br />Explanation: </strong>We place the first element of the first half 3 and first element of the second half 5 so the resulting queue is [3, 5]</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;=queue.size()&lt;= 5*10<sup>5<br /></sup>1 &lt;=queue[i]&lt;= 5*10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/ipl-2021-final--141634/1" target="_blank" rel="noopener noreferrer">IPL 2021 - Final</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">IPL 2021 Finals are here and it is between the most successful team of the IPL Mumbai Indians and the team striving to grab their first trophy Royal Challengers Banglore. Rohit Sharma, captain of the team Mumbai Indians has the most experience in IPL finals, he feels lucky if he solves a programming question before the IPL finals. So, he asked the team's head coach&nbsp; Mahela Jayawardene for a question. Question is</span><span style="font-size: 18px;">, given a string <strong>S </strong>consisting only of opening and closing parenthesis 'ie <strong>'(' &nbsp;</strong>and <strong>')'</strong>,&nbsp; the task is to find out the length of the longest valid parentheses</span><span style="font-size: 18px;"> substring.</span></p>
<p><span style="font-size: 18px;"><strong>NOTE: </strong>The length of the smallest valid substring&nbsp;<strong>( )</strong> is <strong>2</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: S</strong> = "(()(</span><span style="font-size: 18px;">"
<strong>Output:</strong> 2
<strong>Explanation: </strong>The longest valid 
substring is "()". Length = 2.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: S</strong> = "()(())(</span><span style="font-size: 18px;">"
<strong>Output:</strong> 6
<strong>Explanation: </strong>The longest valid 
substring is "()(())</span><span style="font-size: 18px;">". Length = 6.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> |S|&nbsp;</span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/ipl-2021-match-day-6-semi-final--141634/1" target="_blank" rel="noopener noreferrer">IPL 2021 - Match Day 6 - Semi Final</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">IPL 2021 knockouts are over, teams MI, CSK, DC, and RCB are qualified for the semis. </span></p>

<p><span style="font-size:18px">Today is matchday 6 and it is between Delhi Capitals and Royal Challengers Banglore. Glenn Maxwell of RCB playing flawlessly. Rishabh Pant, the new captain of the team who is also a wicket-keeper wants to send a message to the bowler. But, he can&#39;t&nbsp;shout message directly as a batsman can hear. So, he decided to encrypt the message by putting &#39;*&#39;s in the message. And this is how the bowler decrypts the message. Bowler iterates over the message string from left to right, if he finds a <strong>&#39;*&#39;</strong>, he removes it and adds all the letters read so far to the message. He keeps on doing this till he gets rid of all the <strong>&#39;*&#39;</strong>. Given a decrypted message in the form of the string, the task is to find the encrypted</span> <span style="font-size:18px">message</span>.</p>

<p><span style="font-size:18px"><strong>Note:</strong> If the string can be encrypted in multiple ways, find&nbsp;the encrypted string of smallest length.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> s = &quot;ababcababcd&quot;
<strong>Output:</strong> ab*c*d
<strong>Explanation: </strong>We can encrypt the string 
in following way : &quot;ababcababcd&quot;&nbsp;-&gt; 
&quot;ababc*d&quot; -&gt; &quot;ab*c*d&quot;</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>s = &quot;zzzzzzz&quot;
<strong>Output:</strong> z*z*z
<strong>Explanation: </strong>The string can be encrypted 
in 2 ways: &quot;z*z*z&quot; and &quot;z**zzz&quot;. Out of 
the two &quot;z*z*z&quot; is smaller in length.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>compress()</strong> which takes the message string <strong>s</strong> as input parameter and returns the shortest possible encrypted&nbsp;string.</span></p>

<p><span style="font-size:18px"><strong>Constraints:&nbsp;</strong><br />
1 &le; |s| &le; 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/inorder-traversal-iterative/1" target="_blank" rel="noopener noreferrer">Iterative Inorder</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary tree. Find the inorder traversal of the tree <strong>without using recursion</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong> &nbsp;<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706110/Web/Other/blobid0_1746697687.webp" width="185" height="165" /><br /><strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">4 2 5 1 3</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">Inorder traversal (Left-&gt;Root-&gt;Right) of </span>
<span style="font-size: 18px;">the tree is 4 2 5 1 3.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input:<br /></span></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706110/Web/Other/blobid1_1746697734.webp" width="195" height="174" /><br /><strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">1 7 10 8 6 10 5 6</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">Inorder traversal (Left-&gt;Root-&gt;Right) 
of </span><span style="font-size: 18px;">the tree is 1 7 10 8 6 10 5 6.</span></pre>
<p>&nbsp;</p>
<div><strong><span style="font-size: 18px;">Your task:</span></strong></div>
<div><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function <strong>inOrder() </strong>which takes the root of the tree as input and returns a list containing the inorder traversal of the tree, calculated</span><strong><span style="font-size: 18px;"> without using recursion.</span></strong></div>
<p><br /><strong><span style="font-size: 18px;">Expected time complexity: </span></strong><span style="font-size: 18px;">O(N)</span><br /><strong><span style="font-size: 18px;">Expected auxiliary space: </span></strong><span style="font-size: 18px;">O(N)</span></p>
<div><br /><strong><span style="font-size: 18px;">Constraints:</span></strong></div>
<div><span style="font-size: 18px;">1 &lt;= Number of nodes &lt;= 10<sup>5</sup><br />1 &lt;= Data of a node &lt;= 10<sup>5</sup></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/postorder-traversal-iterative/1" target="_blank" rel="noopener noreferrer">Iterative Postorder</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary tree. Find the postorder traversal of the tree <strong>without using recursion</strong>. R</span><span style="font-size: 18px;">eturn a list containing the postorder traversal of the tree, calculated</span><strong style="font-size: 18px;">&nbsp;without using recursion.</strong></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
<strong>           </strong>1
<strong>         /   \</strong>
        2     3
      /  \
     4    5

<strong>Output: </strong>4 5 2 3 1
<strong>Explanation: </strong>Postorder traversal (Left-&gt;Right-&gt;Root) of the tree is 4 5 2 3 1.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
             8
          /      \
        1          5
         \       /   \
          7     10    6
           \   /
&nbsp;           10 6

<strong>Output: </strong>10 7 1 6 10 6 5 8&nbsp;
<strong>Explanation: </strong>Postorder traversal (Left-&gt;Right-&gt;Root) of the tree is 10 7 1 6 10 6 5 8 .</span></pre>
<div>&nbsp;</div>
<div><span style="font-size: 18px;"><strong>Expected time complexity: </strong>O(n)</span></div>
<div><span style="font-size: 18px;"><strong>Expected auxiliary space: </strong>O(n)</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 18px;"><strong>Constraints:</strong></span></div>
<div><span style="font-size: 18px;">1 &lt;= Number of nodes &lt;= 10<sup>5</sup><br />1 &lt;= Data of a node &lt;= 10<sup>5</sup></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/jumpy-humpy-5e0231d6/" target="_blank" rel="noopener noreferrer">Jumpy Humpy</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">easy</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Humpy likes to jump from one building to another. But he only jumps to next higher building and stops when no higher building is available. Stamina required for a journey is <strong>xor </strong>of all the heights on which humpy jumps until he stops.</p>

<p>If heights are [1 2 4], and he starts from 1, goes to 2 stamina required is <span class="mathjax-latex">\(1 \oplus 2 = 3\)</span>, then from 2 to 3. Stamina for the entire journey is <span class="mathjax-latex">\(1 \oplus 2 \oplus 4 = 7\)</span>. Find the maximum stamina required if can start his journey from any building.</p>

<p><strong>Input</strong></p>

<p>First line:Â $$N$$,Â no of buildings.</p>

<p>Second line: $$N$$<em>Â </em>integers, defining heights of buildings.</p>

<p><strong>Output</strong></p>

<p>Single Integer that is the maximum stamina required for any journey.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \le N \le 10^5\)</span></p>

<p><span class="mathjax-latex">\(1 \le Heights \le 10^9\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>If he starts from building 1, the stamina required is 1 ^ 2 ^ 3 ^ 8 = 8</p>

<p>From the building 2, the stamina requiredÂ is 2 ^ 3 ^ 8 = 9</p>

<p>From the building 3, the stamina required is 3 ^ 8 = 11</p>

<p>Similarly, from 8 and 6, staminaÂ required are 8 and 6 respectively.</p>

<p>The maximum staminaÂ required for the journey is from building 3 is 11.</p>

<p>So theÂ answer is 11.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-rectangle-in-histogram/description" target="_blank" rel="noopener noreferrer">Largest Rectangle in Histogram</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>heights</code> representing the histogram&#39;s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" style="width: 522px; height: 242px;" />
<pre>
<strong>Input:</strong> heights = [2,1,5,6,2,3]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" style="width: 202px; height: 362px;" />
<pre>
<strong>Input:</strong> heights = [2,4]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/level-order-traversal-in-spiral-form/1" target="_blank" rel="noopener noreferrer">Level Order in spiral form</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a binary tree and the task is to find the spiral order traversal of the tree and return the list containing the elements.<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Spiral order Traversal mean:</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> Starting from level 0 for root node, for all the even levels we print the node's value from right to left and for all the odd levels we print the node's value from left to right.</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> <br /></span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">For below tree, function should return [1, 2, 3, 4, 5, 6, 7]</span></span></p>
<p><span style="font-size: 14pt;"><strong>&nbsp;<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700201/Web/Other/blobid0_1746530348.webp" width="244" height="218" /></strong></span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root = [1, 3, 2]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700201/Web/Other/blobid2_1746530526.webp" width="167" height="135" /> <br /><strong>Output: </strong>[1, 3, 2]<br /><strong>Explanation</strong>: Start with root (1), print level 0 (right to left), then level 1 (left to right).</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root = [10, 20, 30, 40, 60]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700201/Web/Other/blobid3_1746530612.webp" width="197" height="210" /><br /><strong>Output: </strong>[10, 20, 30, 60, 40]<br /><strong>Explanation</strong>: Start with root (10), print level 0 (right to left), level 1 (left to right), and continue alternating.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>root = [1, 2, N, 4]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700201/Web/Other/blobid0_1746530910.webp" width="174" height="185" /> &nbsp;<br /><strong>Output: </strong>[1, 2, 4]<br /><strong>Explanation</strong>: Start with root (1), then level 1 (left to right), then level 2 (right to left).</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>5</sup><br />0 &lt;= node-&gt;data &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/lexicographically-largest-string-after-deleting-k-characters/1" target="_blank" rel="noopener noreferrer">Lexicographically Largest String After K Deletions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a string <strong>s</strong> consisting of lowercase English letters and an integer <strong>k</strong>, your task is to remove exactly k characters from the string. The resulting string must be the<strong> </strong>largest possible in <strong>lexicographical&nbsp; order</strong>, while maintain the relative order of the remaining characters.</span></p>
<h3><strong><span style="font-size: 18px;">Examples:</span></strong></h3>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s = "ritz", k = 2
<strong>Output:</strong> tz 
<strong>Explaination: </strong></span><span style="font-size: 14pt;">By removing two characters in all possible ways, we get: "ri", "rt", "rz", "it", "iz", and "tz". Among these, "tz" is lexicographically largest string.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s = "zebra", k = 3
<strong>Output:</strong> zr 
<strong>Explaination: </strong></span><span style="font-size: 14pt;">Removing "e", "b", and "a" results in "zr", which is lexicographically largest string.</span></pre>
<p><strong style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Constraints:<br /></strong><span style="font-size: 18px;">1 &le; s.size() &le; 10<sup>5<br /></sup>0&nbsp; &le;&nbsp; k &lt; s.size()</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lexicographically-minimum-string-after-removing-stars/description" target="_blank" rel="noopener noreferrer">Lexicographically Minimum String After Removing Stars</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>. It may contain any number of <code>&#39;*&#39;</code> characters. Your task is to remove all <code>&#39;*&#39;</code> characters.</p>

<p>While there is a <code>&#39;*&#39;</code>, do the following operation:</p>

<ul>
	<li>Delete the leftmost <code>&#39;*&#39;</code> and the <strong>smallest</strong> non-<code>&#39;*&#39;</code> character to its <em>left</em>. If there are several smallest characters, you can delete any of them.</li>
</ul>

<p>Return the <span data-keyword="lexicographically-smaller-string">lexicographically smallest</span> resulting string after removing all <code>&#39;*&#39;</code> characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aaba*&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;aab&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>We should delete one of the <code>&#39;a&#39;</code> characters with <code>&#39;*&#39;</code>. If we choose <code>s[3]</code>, <code>s</code> becomes the lexicographically smallest.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;abc&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no <code>&#39;*&#39;</code> in the string.<!-- notionvc: ff07e34f-b1d6-41fb-9f83-5d0ba3c1ecde --></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters and <code>&#39;*&#39;</code>.</li>
	<li>The input is generated such that it is possible to delete all <code>&#39;*&#39;</code> characters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-greedy">Approach: Greedy</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem statement, whenever a <code>*</code> is encountered, we must remove the smallest character (in lexicographical order) to its left. To ensure that the resulting string is as lexicographically small as possible, and following the greedy principle, it's better to remove characters from the end rather than the beginning. This helps keep the smaller characters closer to the front, which contributes to minimizing the overall lexicographical order of the string.</p>
<p>We traverse the string <span class="math inline">\(s\)</span> from left to right. Since the string contains only lowercase letters, we use <span class="math inline">\(26\)</span> stacks to store the indices of each character we've seen so far. The <span class="math inline">\(k\)</span>-th stack stores the indices of the <span class="math inline">\(k\)</span>-th lowercase letter (<code>a</code> corresponds to 0, <code>b</code> to 1, and so on).</p>
<ul>
<li>When we encounter a <code>*</code>, we find the non-empty stack with the smallest lexicographical character, mark the corresponding character in the string <span class="math inline">\(s\)</span> as <code>*</code>, and remove the index from the top of that stack.</li>
<li>When we encounter a non-<code>*</code> character, we push its index into the corresponding stack.</li>
</ul>
<p>The final answer is formed by selecting all characters from left to right in the string <span class="math inline">\(s\)</span> that are not <code>*</code>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Wzy2mi7D/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span>, and let <span class="math inline">\(|\Sigma|\)</span> be the size of the character set. Since all characters in this problem are lowercase letters, we have <span class="math inline">\(|\Sigma| = 26\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times |\Sigma|)\)</span>.</p>
<p>During traversal, whenever we encounter a <code>*</code>, we need to find the smallest character (in lexicographical order) to its left. This requires scanning through all <span class="math inline">\(|\Sigma|\)</span> possible character stacks, which takes <span class="math inline">\(O(|\Sigma|)\)</span> time. Since there can be at most <span class="math inline">\(n\)</span> occurrences of <code>*</code>, the total time complexity is <span class="math inline">\(O(n \times |\Sigma|)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + |\Sigma|)\)</span>.</p>
<p>The space used is <span class="math inline">\(O(n + |\Sigma|)\)</span>: we need <span class="math inline">\(O(n)\)</span> space to store the indices of all characters in the string, and <span class="math inline">\(O(|\Sigma|)\)</span> space for maintaining the stacks for each character.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/mila-and-strings0435/1" target="_blank" rel="noopener noreferrer">Lexicographically smallest string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a string <strong>S</strong> consisting of <strong>only lowercase characters</strong>. Find&nbsp;the lexicographically smallest string after removing <strong>exactly</strong>&nbsp;<strong>k</strong> characters from the string. But you have to correct the value of <strong>k</strong>, i.e.,&nbsp;if the length of the string is a <strong>power of 2</strong>, reduce <strong>k by half</strong>, else multiply <strong>k by 2</strong>. You can remove <strong>any k</strong> character.<br />
<strong>NOTE:&nbsp;</strong>If it is not possible to remove k (the value of k after correction) characters or if the resulting string is empty return&nbsp;<strong>-1</strong>. </span><br />
<br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>: S = &quot;fooland&quot;, k = 2
<strong>Output:</strong>&nbsp;&quot;and&quot;&nbsp;
<strong>Explanation</strong>: As the size of the string = 7
which is not a power of 2, hence k = 4.
After removing 4 characters from the given 
string, the lexicographically smallest
string is &quot;and&quot;.</span><span style="font-size:18px">
</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>S = &quot;code&quot;, k = 4
<strong>Output:&nbsp;</strong>&quot;cd&quot;
<strong>Explanation</strong>: As the length of the string = 4, 
which is 2 to the power 2, hence k = 2.
Hence, lexicographically smallest string after 
removal of 2 characters is &quot;cd&quot;.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You dont need to read input or print anything. Complete the function <strong>lexicographicallySmallest()&nbsp;</strong>which takes S&nbsp;and k as input parameters and returns the lexicographically smallest string after removing k characters.<br />
<br />
<strong>Expected Time Complexity:</strong> O(n+k), n is size of the string<br />
<strong>Expected Auxiliary Space:</strong> O(n)<br />
<br />
<strong>Constraints:</strong><br />
1&lt;= |S|&nbsp;&lt;=10<sup>5</sup><br />
1&lt;= k &lt;= 10</span><sup><span style="font-size:15px">5</span></sup></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/little-shino-and-pairs/" target="_blank" rel="noopener noreferrer">Little Shino and Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">easy</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a permutation of number from <em>1</em> to <em>N</em>. Among all the subarrays, find the number of unique pairs <span class="mathjax-latex">\((a, b)\)</span> such that <span class="mathjax-latex">\(a \neq b\)</span> and <em>a</em> is maximum and <em>b</em> is second maximum in that subarray.</p>
<p><strong>Input:</strong><br />
First line contains an integer, <em>N</em> <span class="mathjax-latex">\((1 \le N \le 10^5)\)</span>. Second line contains <em>N</em> space separated distinct integers, <span class="mathjax-latex">\(A_i\)</span> <span class="mathjax-latex">\((1 \le A_i \le N)\)</span>, denoting the permutation.</p>
<p><strong>Output:</strong><br />
Print the required answer.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>All the possible subarrays are:</p>
<p><em>1</em><br />
<span class="mathjax-latex">\(1\; 2\)</span><br />
<span class="mathjax-latex">\(1\; 2\; 3\)</span><br />
<span class="mathjax-latex">\(1\; 2\; 3\; 4\)</span><br />
<span class="mathjax-latex">\(1\; 2\; 3\; 4\; 5\)</span><br />
<em>2</em><br />
<span class="mathjax-latex">\(2\; 3\)</span><br />
<span class="mathjax-latex">\(2\; 3\; 4\)</span><br />
<span class="mathjax-latex">\(2\; 3\; 4\; 5\)</span><br />
<em>3</em><br />
<span class="mathjax-latex">\(3\; 4\)</span><br />
<span class="mathjax-latex">\(3\; 4\; 5\)</span><br />
<em>4</em><br />
<span class="mathjax-latex">\(4\; 5\)</span><br />
<em>5</em>  </p>
<p>The <em>4</em> unique pairs are:<br />
<span class="mathjax-latex">\((2,\; 1)\)</span><br />
<span class="mathjax-latex">\((3,\; 2)\)</span><br />
<span class="mathjax-latex">\((4,\; 3)\)</span><br />
<span class="mathjax-latex">\((5,\; 4)\)</span>  </p></div>
				</div>
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-absolute-file-path/description" target="_blank" rel="noopener noreferrer">Longest Absolute File Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg" style="width: 681px; height: 322px;" /></p>

<p>Here, we have <code>dir</code> as the only directory in the root. <code>dir</code> contains two subdirectories, <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and subdirectory <code>subsubdir1</code>. <code>subdir2</code> contains a subdirectory <code>subsubdir2</code>, which contains a file <code>file2.ext</code>.</p>

<p>In text form, it looks like this (with âŸ¶ representing the tab character):</p>

<pre>
dir
âŸ¶ subdir1
âŸ¶ âŸ¶ file1.ext
âŸ¶ âŸ¶ subsubdir1
âŸ¶ subdir2
âŸ¶ âŸ¶ subsubdir2
âŸ¶ âŸ¶ âŸ¶ file2.ext
</pre>

<p>If we were to write this representation in code, it will look like this: <code>&quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;</code>. Note that the <code>&#39;\n&#39;</code> and <code>&#39;\t&#39;</code> are the new-line and tab characters.</p>

<p>Every file and directory has a unique <strong>absolute path</strong> in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by <code>&#39;/&#39;s</code>. Using the above example, the <strong>absolute path</strong> to <code>file2.ext</code> is <code>&quot;dir/subdir2/subsubdir2/file2.ext&quot;</code>. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form <code>name.extension</code>, where <code>name</code> and <code>extension</code> consist of letters, digits, and/or spaces.</p>

<p>Given a string <code>input</code> representing the file system in the explained format, return <em>the length of the <strong>longest absolute path</strong> to a <strong>file</strong> in the abstracted file system</em>. If there is no file in the system, return <code>0</code>.</p>

<p><strong>Note</strong> that the testcases are generated such that the file system is valid and no file or directory name has length 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg" style="width: 401px; height: 202px;" />
<pre>
<strong>Input:</strong> input = &quot;dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext&quot;
<strong>Output:</strong> 20
<strong>Explanation:</strong> We have only one file, and the absolute path is &quot;dir/subdir2/file.ext&quot; of length 20.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg" style="width: 641px; height: 322px;" />
<pre>
<strong>Input:</strong> input = &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;
<strong>Output:</strong> 32
<strong>Explanation:</strong> We have two files:
&quot;dir/subdir1/file1.ext&quot; of length 21
&quot;dir/subdir2/subsubdir2/file2.ext&quot; of length 32.
We return 32 since it is the longest absolute path to a file.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> input = &quot;a&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> We do not have any files, just a single directory named &quot;a&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= input.length &lt;= 10<sup>4</sup></code></li>
	<li><code>input</code> may contain lowercase or uppercase English letters, a new line character <code>&#39;\n&#39;</code>, a tab character <code>&#39;\t&#39;</code>, a dot <code>&#39;.&#39;</code>, a space <code>&#39; &#39;</code>, and digits.</li>
	<li>All file and directory names have <strong>positive</strong> length.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/longest-valid-parentheses5657/1" target="_blank" rel="noopener noreferrer">Longest valid Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>s</strong>&nbsp;consisting of opening and closing parenthesis '<strong>(</strong>' and '<strong>)</strong>'. Find the length of the longest valid parenthesis substring.</span></p>
<p><span style="font-size: 18px;">A parenthesis string is valid if:</span></p>
<ul>
<li><span style="font-size: 18px;">For every opening parenthesis, there is a closing parenthesis.</span></li>
<li><span style="font-size: 18px;">The closing parenthesis must be after its opening parenthesis.</span></li>
</ul>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s = "((()"
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest valid parenthesis substring is "()".</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s = ")()())"
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest valid parenthesis substring is "()()".</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s = "())()"
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest valid parenthesis substring is "()".</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; s.size() &le; 10<sup>6</sup>&nbsp;&nbsp;<br />s consists of '(' and ')' only</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-valid-parentheses/description" target="_blank" rel="noopener noreferrer">Longest Valid Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, return <em>the length of the longest valid (well-formed) parentheses </em><span data-keyword="substring-nonempty"><em>substring</em></span>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(()&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;)()())&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()()&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;&quot;
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>s[i]</code> is <code>&#39;(&#39;</code>, or <code>&#39;)&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-well-performing-interval/description" target="_blank" rel="noopener noreferrer">Longest Well-Performing Interval</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">prefix-sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are given <code>hours</code>, a list of the number of hours worked per day for a given employee.</p>

<p>A day is considered to be a <em>tiring day</em> if and only if the number of hours worked is (strictly) greater than <code>8</code>.</p>

<p>A <em>well-performing interval</em> is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</p>

<p>Return the length of the longest well-performing interval.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> hours = [9,9,6,0,6,6,9]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The longest well-performing interval is [9,9,6].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> hours = [6,6,6]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= hours.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= hours[i] &lt;= 16</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-array-non-decreasing/description" target="_blank" rel="noopener noreferrer">Make Array Non-decreasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. In one operation, you can select a <span data-keyword="subarray-nonempty">subarray</span> and replace it with a single element equal to its <strong>maximum</strong> value.</p>

<p>Return the <strong>maximum possible size</strong> of the array after performing zero or more operations such that the resulting array is <strong>non-decreasing</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,2,5,3,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>One way to achieve the maximum size is:</p>

<ol>
	<li>Replace subarray <code>nums[1..2] = [2, 5]</code> with <code>5</code> &rarr; <code>[4, 5, 3, 5]</code>.</li>
	<li>Replace subarray <code>nums[2..3] = [3, 5]</code> with <code>5</code> &rarr; <code>[4, 5, 5]</code>.</li>
</ol>

<p>The final array <code>[4, 5, 5]</code> is non-decreasing with size <font face="monospace">3.</font></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>No operation is needed as the array <code>[1,2,3]</code> is already non-decreasing.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/make-the-array-beautiful--170647/1" target="_blank" rel="noopener noreferrer">Make the array beautiful</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an array of negative and non-negative integers. You have to make the array beautiful. An array is beautiful if two adjacent integers, arr[i] and arr[i+1] are either negative or non-negative. And you can do the following&nbsp;operation any number of times until the array becomes beautiful.</span></p>

<ul>
	<li><span style="font-size:18px">If two adjacent integers are&nbsp;different i.e. one of them is negative and other is non-negative, remove them.</span></li>
</ul>

<p><span style="font-size:18px">Return the beautiful array after performing the above operation.</span></p>

<p><span style="font-size:18px"><strong>Note:</strong>An empty array is also a beautiful array. There can be many adjacent integers which are different as stated above. So remove different adjacent integers as described above from <strong>left to right</strong>.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>4 2 -2 1<strong>
Output: </strong>4 1
<strong>Explanation:</strong> As at indices 1 and 2 , 2 and -2 have
different sign, they are removed. And the  the final
array is: 4 1.</span>
</pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input: </span></strong><span style="font-size:18px">2 -2 1 -1</span><strong><span style="font-size:18px">
Output: </span></strong><span style="font-size:18px">[]</span><strong><span style="font-size:18px">
Explanation: </span></strong><span style="font-size:18px">As at indices 0 and 1, 2 and -2 have
different sign, so they are removed. Now the array
is 1 -1.Now 1 and -1 are also removed as they have
different sign. So the final array is empty. </span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>makeBeautiful()&nbsp;</strong>which takes an array as an input parameter and returns an array.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Space Complexity:</strong> O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= size of the array&nbsp;&lt;= 10</span><sup><span style="font-size:18px">5</span></sup><br />
<span style="font-size:18px">-10<sup>5</sup> &lt;= arr[i] &lt;= 10</span><sup><span style="font-size:18px">5</span></sup><br />
&nbsp;</p>

<p>&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-the-string-great/description" target="_blank" rel="noopener noreferrer">Make The String Great</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> of lower and upper case English letters.</p>

<p>A good string is a string which doesn&#39;t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - 2</code></li>
	<li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li>
</ul>

<p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p>

<p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p>

<p><strong>Notice</strong> that an empty string is also good.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leEeetcode&quot;
<strong>Output:</strong> &quot;leetcode&quot;
<strong>Explanation:</strong> In the first step, either you choose i = 1 or i = 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abBAcC&quot;
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> We have many possible scenarios, and all lead to the same answer. For example:
&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;
&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;s&quot;
<strong>Output:</strong> &quot;s&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> contains only lower and upper case English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/mancunian-and-fantabulous-pairs/" target="_blank" rel="noopener noreferrer">Mancunian And Fantabulous Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">math</span> <span class="topic-badge">medium</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>First off, some definitions.<br />
An array of length at least 2 having distinct integers is said to be fantabulous iff the second highest element lies <strong>strictly to the left</strong> of the highest value. For example, <em>[1, 2, 13, 10, 15]</em> is fantabulous as the second-highest value <em>13</em> lies to the left of highest value <em>15</em>.<br />
For every fantabulous array, we define a fantabulous pair <strong>(a, b)</strong> where <strong>a</strong> denotes the index of the second-highest value (1-indexed) and <strong>b</strong> denotes the index of the highest value (1-indexed). In the above array, the fantabulous pair is (3, 5).<br />
Mancunian challenges you to solve the following problem. Given an array, find the total number of <strong>distinct</strong> fantabulous pairs over all its subarrays.</p>
<p><strong>Input:</strong> <br />
The first line contains an integer <strong>N</strong> denoting the length of the array. The next line contains <strong>N</strong> <strong>distinct</strong> integers denoting the elements of the array.</p>
<p><strong>Output:</strong><br />
Output a single integer which is the answer to the problem.</p>
<p><strong>Constraints:</strong><br />
 1 &lt;= N &lt;= 10<sup>6</sup><br />
 1 &lt;= array elements &lt;= 10<sup>9</sup><br />
 Array elements are distinct.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Let us consider all the subarrays of the given array.<br />
The subarray [1] is not fantabulous.<br />
The subarray [2] is not fantabulous.<br />
The subarray [3] is not fantabulous.<br />
The subarray [4] is not fantabulous.<br />
The fantabulous pair for subarray [1, 3] is (1, 2).<br />
The subarray [3, 2] is not fantabulous.<br />
The fantabulous pair for subarray [2, 4] is (1, 2).<br />
The subarray [1, 3, 2] is not fantabulous.<br />
The fantabulous pair for subarray [3, 2, 4] is (1, 3).<br />
The fantabulous pair for subarray [1, 3, 2, 4] is (2, 4).<br />
So, there are the <strong>3</strong> distinct pairs, which are (1, 2), (1, 3) and (2, 4).</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-chunks-to-make-sorted/description" target="_blank" rel="noopener noreferrer">Max Chunks To Make Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>arr</code> of length <code>n</code> that represents a permutation of the integers in the range <code>[0, n - 1]</code>.</p>

<p>We split <code>arr</code> into some number of <strong>chunks</strong> (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.</p>

<p>Return <em>the largest number of chunks we can make to sort the array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,3,2,1,0]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&#39;t sorted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,0,2,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == arr.length</code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>0 &lt;= arr[i] &lt; n</code></li>
	<li>All the elements of <code>arr</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>arr</code> of length <code>n</code> that contains the numbers <code>0</code>, <code>1</code>, ... , <code>n - 1</code> in random order. According to the problem description, three operations are to be performed:</p>
<ol>
<li>Split the array into a number of <em>chunks</em> (i.e., segments).</li>
<li>Sort each segment separately in increasing order.</li>
<li>Concatenate all segments <strong>in the same order</strong> as they appear in the original array.</li>
</ol>
<p>Our task is to find the highest possible number of chunks we can split the array into such that each chunk can be sorted independently and still be concatenated to match the sorted version of the entire array.</p>
<p>A key observation here is that a split is valid if and only if each segment contains numbers strictly greater than those in the previous segment. In other words, the minimum value of each segment must be greater than the maximum value of the previous segment.</p>
<hr />
<h3 id="approach-1-prefixmax-and-suffixmin-arrays">Approach 1: PrefixMax and SuffixMin Arrays</h3>
<h4 id="intuition">Intuition</h4>
<p>Building on the above observation, we further notice that for each number in the array, we have two options: we can either include it in the same chunk as the previous number or create a new chunk for it. However, we must consider the limitation that a new chunk at index <span class="math inline">\(i\)</span> can only be created if all the numbers in the current and previous chunks (the &quot;prefix&quot; of the array) are smaller than all the numbers in the following chunks (the &quot;suffix&quot; of the array). This is equivalent to checking whether:</p>
<p><span class="math display">\[\begin{aligned}
max(prefix[0:i]) < min(suffix[i:n]).
\end{aligned}
\]</span></p>
<p>Since we aim to find the largest possible number of chunks, we will choose the second option (i.e., create a new chunk) whenever the above condition is satisfied. Therefore, the problem reduces to counting how many indices in the array satisfy this condition.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>prefixMax</code> and <code>suffixMin</code> arrays to <code>arr</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>1</code> to <code>n - 1</code>:
<ul>
<li>Set <code>prefixMax[i] = max(prefixMax[i], prefixMax[i-1])</code>.</li>
</ul>
</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>n - 2</code> to <code>0</code>:
<ul>
<li>Set <code>suffixMin[i] = min(suffixMin[i], suffixMin[i+1])</code>.</li>
</ul>
</li>
<li>Initialize <code>chunks</code> to <code>0</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Check if <code>i == 0</code> (create a chunk for the first element) or <code>suffixMin[i] &gt; prefixMax[i - 1]</code>.
<ul>
<li>If true, increment <code>chunks</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>chunks</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DUP4x9QQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The initialization of the <code>prefixMax</code> and <code>suffixMin</code> arrays, as well as the computation of <code>chunks</code>, each requires a single pass through the array <code>arr</code>, taking <span class="math inline">\(O(n)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n) + O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>prefixMax</code> and <code>suffixMin</code> arrays require <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-sums">Approach 2: Prefix Sums</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An important observation is that a segment of the array can form a valid chunk if, when sorted, it matches the corresponding segment in the fully sorted version of the array.</p>
<p>Since the numbers in <code>arr</code> belong to the range <code>[0, n - 1]</code>, we can simplify the problem by using the property of sums. Specifically, for any index, it suffices to check whether the sum of the elements in <code>arr</code> up to that index is equal to the sum of the elements in the corresponding prefix of the sorted array.</p>
<p>If these sums are equal, it guarantees that the elements in the current segment of <code>arr</code> match the elements in the corresponding segment of the sorted array (possibly in a different order). When this condition is satisfied, we can form a new chunk â€” either starting from the beginning of the array or the end of the previous chunk.</p>
<p>For example, consider <code>arr = [1, 2, 0, 3, 4]</code> and the sorted version <code>sortedArr = [0, 1, 2, 3, 4]</code>. We find the valid segments as follows:</p>
<ul>
<li>Segment <code>[0, 0]</code> is not valid, since <code>sum = 1</code> and <code>sortedSum = 0</code>.</li>
<li>Segment <code>[0, 1]</code> is not valid, since <code>sum = 1 + 2 = 3</code> and <code>sortedSum = 0 + 1 = 1</code>.</li>
<li>Segment <code>[0, 2]</code> is valid, since <code>sum = 1 + 2 + 0 = 3</code> and <code>sortedSum = 0 + 1 + 2 = 3</code>.</li>
<li>Segment <code>[3, 3]</code> is valid, because <code>sum = 1 + 2 + 0 + 3 = 6</code> and <code>sortedSum = 0 + 1 + 2 + 3 = 6</code>.</li>
<li>Segment <code>[4, 4]</code> is valid, because <code>sum = 1 + 2 + 0 + 3 + 4 = 10</code> and <code>sortedSum = 0 + 1 + 2 + 3 + 4 = 10</code>.</li>
</ul>
<p>Therefore, the answer here is 3.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>chunks</code>, <code>prefixSum</code>, and <code>sortedPrefixSum</code> to <code>0</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Increment <code>prefixSum</code> by <code>arr[i]</code>.</li>
<li>Increment <code>sortedPrefixSum</code> by <code>i</code>.</li>
<li>Check if <code>prefixSum == sortedPrefixSum</code>:
<ul>
<li>If so, increment <code>chunks</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>chunks</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/DBPgzN5d/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over the array <code>arr</code> once and perform constant-time operations on each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We are only using a fixed number of variables which does not depend on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-monotonic-increasing-stack">Approach 3: Monotonic Increasing Stack</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The main idea of this approach is that if a number in the array is less than any number in the previous chunks, this number cannot create a new chunk, as we cannot swap elements from different chunks to fix their relative order. We will iterate over the array and maintain a stack to represent the maximum values of the chunks created so far. As we loop over the array, we decide whether the current element (<code>arr[i]</code>) can start a new chunk or should merge with an existing chunk. We handle two cases:</p>
<ol>
<li><code>arr[i] &gt; stack.top</code>: If the current element is greater than the top of the stack, it means it can start a new chunk because itâ€™s larger than all previous chunks. We push <code>arr[i]</code> into the stack to represent a new chunk.</li>
<li><code>arr[i] &lt; stack.top</code>: If the current element is smaller the top of the stack, it cannot form a new chunk. Instead, it must merge with one or more existing chunks. To merge, remove all chunks from the stack whose maximum values are greater than the current element. Then, push back the maximum value of the merged chunks to maintain the stack sorted.</li>
</ol>
<p>Let's take a look at an example, where <code>arr = [1, 2, 0, 3, 4]</code>. Initially the stack is empty: <code>stack = []</code>.</p>
<ul>
<li>We then push <code>1</code> into the stack: <code>stack = [1]</code>.</li>
<li><code>2 &gt; 1</code>, we push <code>2</code> into the stack: <code>stack = [1, 2]</code>.</li>
<li><code>0 &lt; 2</code>, <code>0 &lt; 1</code>, we pop <code>2</code> and <code>1</code> from the stack. We push <code>2</code> back into the stack, as it the maximum element of the current chunk: <code>stack = [2]</code>.</li>
<li><code>3 &gt; 2</code>, we push <code>3</code> into the stack: <code>stack = [2, 3]</code>.</li>
<li><code>4 &gt; 3</code>, we push <code>4</code> into the stack: <code>stack = [2, 3, 4]</code>.</li>
</ul>
<p>Now recall that at each point the elements in the stack represent the maximum elements of the chunks created so far. Therefore, at the end of the iteration, the size of the stack equals the maximum number of chunks that can be formed.</p>
<blockquote>
<p>For a more comprehensive understanding of stacks, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/">Stack Explore Card</a>. This resource provides an in-depth look at stacks, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>monotonicStack</code> to an empty stack.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If the <code>monotonicStack</code> is empty or <code>arr[i]</code> is greater than the top of the stack:
<ul>
<li>Push <code>arr[i]</code> into the <code>monotonicStack</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Initialize <code>maxElement</code> to the top element of the <code>monotonicStack</code>.</li>
<li>While the <code>monotonicStack</code> is not empty and the top element is greater than <code>arr[i]</code>:
<ul>
<li>Pop the top element from the <code>monotonicStack</code>.</li>
</ul>
</li>
<li>Push <code>maxElement</code> into the <code>monotonicStack</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the size of the <code>monotonicStack</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/XVZvpjGz/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over the array, and during each iteration, we either push an element into the <code>monotonicStack</code> (constant-time operation) or pop elements from the stack using the inner while loop. Notice that the number of times the while loop runs in a single iteration corresponds to the size of the current chunk being merged. The total number of pop operations across all iterations is therefore equal to the sum of the sizes of the chunks which is the total number of elements in the array. Hence the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case (i.e., <code>arr</code> is in increasing order), the stack contains <span class="math inline">\(n\)</span> elements, so the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-maximum-element">Approach 4: Maximum Element</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Similarly to the second approach, we will use a condition to determine when a segment can be considered a valid chunk. Here, we iterate through the array while keeping track of the maximum element we've encountered up to the current index.</p>
<p>Now, consider the case where the current index <span class="math inline">\(i\)</span>, is equal to the maximum element encountered so far, <span class="math inline">\(\text{maxElement}\)</span>. This condition means that all elements preceding index <span class="math inline">\(i\)</span> are less than <span class="math inline">\(\text{maxElement}\)</span>. Since the array is a permutation of integers in the range <span class="math inline">\([0, n - 1]\)</span>, it also guarantees that all integers from <span class="math inline">\(0\)</span> to <span class="math inline">\(\text{maxElement}\)</span> must appear in the array before index <span class="math inline">\(i\)</span>. Therefore, whenever the current index matches the maximum value so far (i.e., <span class="math inline">\(i == \text{maxElement}\)</span>), we increment the count of chunks.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>chunks</code> and <code>maxElement</code> to <code>0</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Update <code>maxElement</code> to <code>max(maxElement, arr[i])</code>.</li>
<li>If <code>maxElement == i</code>:
<ul>
<li>Increment <code>chunks</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>chunks</code>.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZvF2KSk7/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over the array <code>arr</code> once and perform constant-time operations on each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We are only using a fixed number of variables which does not depend on the input size.</p>
</li>
</ul>
<hr />
<p><strong>Follow Up:</strong> Want to challenge yourself further? Try out the harder version of the problem: <a href="https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/">Max Chunks To Make Sorted II</a></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-chunks-to-make-sorted-ii/description" target="_blank" rel="noopener noreferrer">Max Chunks To Make Sorted II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>arr</code>.</p>

<p>We split <code>arr</code> into some number of <strong>chunks</strong> (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.</p>

<p>Return <em>the largest number of chunks we can make to sort the array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,4,3,2,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
Splitting into two or more chunks will not return the required result.
For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&#39;t sorted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,1,3,4,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 2000</code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-maximum-equal-sum-of-three-stacks/1" target="_blank" rel="noopener noreferrer">Max Equal sum of 3 Stacks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given three stacks <strong>S1</strong>, <strong>S2</strong> &amp;&nbsp;<strong>S3</strong> of size <strong>N1</strong>, <strong>N2 </strong>&amp; <strong>N3 </strong>respectively, having only <strong>Positive </strong>Integers. The task is to find the possible equal <strong>maximum sum</strong> of the stacks with the removal of top elements allowed. Stacks are represented as an array, and the first index of the array represents the top element of the stack.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N1 = 3, N2 = 4, N3 = 2
S1 = {4,2,3}
S2 = {1,1,2,3}
S3 = {1,4}<strong>
Output:</strong></span><span style="font-size: 18px;">
5<strong>
Explanation:
</strong>We can pop 1 element from the 1st stack, and 2
elements from the 2nd stack. Now remaining elements
yield the equal sum of the three stacks, that is 5.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span><span style="font-size: 18px;">
N1 =2, N2 = 1, N3 = 3
S1 = {4,7}</span><span style="font-size: 18px;">
S2 = {10}
S3 = {1,2,3}<strong>
Output:
</strong>0<strong>
Explanation:
</strong>We will never get an equal sum after popping
some elements, so the answer will be 0.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>maxEqualSum()</strong>&nbsp;which takes the arrays <strong>S1[], S2[], </strong>and<strong> S3[]</strong>&nbsp;and their&nbsp;sizes&nbsp;<strong>N1, N2, </strong>and<strong> N3&nbsp;</strong>as inputs and returns the maximum equal sum we can obtain.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N1+N2+N3)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= N1, N2, N3 &lt;= 10<sup>5</sup></span><br /><span style="font-size: 18px;">1 &lt;= S1[i],&nbsp;S2[i], S3[i] &lt;= 10<sup>3</sup></span><br /><span style="font-size: 18px;">The sum, N1+N2+N3 doesn't exceed 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximal-rectangle/description" target="_blank" rel="noopener noreferrer">Maximal Rectangle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>rows x cols</code>&nbsp;binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, find the largest rectangle containing only <code>1</code>&#39;s and return <em>its area</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" style="width: 402px; height: 322px;" />
<pre>
<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[&quot;0&quot;]]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[&quot;1&quot;]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == matrix.length</code></li>
	<li><code>cols == matrix[i].length</code></li>
	<li><code>1 &lt;= row, cols &lt;= 200</code></li>
	<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-and-minimum-sums-of-at-most-size-k-subarrays/description" target="_blank" rel="noopener noreferrer">Maximum and Minimum Sums of at Most Size K Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and a <strong>positive</strong> integer <code>k</code>. Return the sum of the <strong>maximum</strong> and <strong>minimum</strong> elements of all <span data-keyword="subarray-nonempty">subarrays</span> with <strong>at most</strong> <code>k</code> elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">20</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarrays of <code>nums</code> with at most 2 elements are:</p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;"><b>Subarray</b></th>
			<th style="border: 1px solid black;">Minimum</th>
			<th style="border: 1px solid black;">Maximum</th>
			<th style="border: 1px solid black;">Sum</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[2]</code></td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[3]</code></td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">6</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1, 2]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[2, 3]</code></td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><strong>Final Total</strong></td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">20</td>
		</tr>
	</tbody>
</table>

<p>The output would be 20.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,-3,1], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">-6</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarrays of <code>nums</code> with at most 2 elements are:</p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;"><b>Subarray</b></th>
			<th style="border: 1px solid black;">Minimum</th>
			<th style="border: 1px solid black;">Maximum</th>
			<th style="border: 1px solid black;">Sum</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[-3]</code></td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">-6</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1, -3]</code></td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">-2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[-3, 1]</code></td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">-2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><strong>Final Total</strong></td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">-6</td>
		</tr>
	</tbody>
</table>

<p>The output would be -6.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 80000</code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
	<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-tree</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p>

<ol>
	<li>Create a root node whose value is the maximum value in <code>nums</code>.</li>
	<li>Recursively build the left subtree on the <strong>subarray prefix</strong> to the <strong>left</strong> of the maximum value.</li>
	<li>Recursively build the right subtree on the <strong>subarray suffix</strong> to the <strong>right</strong> of the maximum value.</li>
</ol>

<p>Return <em>the <strong>maximum binary tree</strong> built from </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" style="width: 302px; height: 421px;" />
<pre>
<strong>Input:</strong> nums = [3,2,1,6,0,5]
<strong>Output:</strong> [6,3,5,null,2,0,null,null,1]
<strong>Explanation:</strong> The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" style="width: 182px; height: 301px;" />
<pre>
<strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> [3,null,2,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
	<li>All integers in <code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursive-solution">Approach 1: Recursive Solution</h3>
<p>The current solution is very simple. We make use of a function <code>construct(nums, l, r)</code>, which returns the maximum binary tree consisting of numbers within the indices <span class="math inline">\(l\)</span> and <span class="math inline">\(r\)</span> in the given <span class="math inline">\(nums\)</span> array(excluding the <span class="math inline">\(r^{th}\)</span> element).</p>
<p>The algorithm consists of the following steps:</p>
<ol>
<li>
<p>Start with the function call <code>construct(nums, 0, n)</code>. Here, <span class="math inline">\(n\)</span> refers to the number of elements in the given <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Find the index, <span class="math inline">\(max_i\)</span>, of the largest element in the current range of indices <span class="math inline">\((l:r-1)\)</span>. Make this largest element, <span class="math inline">\(nums[max\_i]\)</span> as the local root node.</p>
</li>
<li>
<p>Determine the left child using <code>construct(nums, l, max_i)</code>. Doing this recursively finds the largest element in the subarray left to the current largest element.</p>
</li>
<li>
<p>Similarly, determine the right child using <code>construct(nums, max_i + 1, r)</code>.</p>
</li>
<li>
<p>Return the root node to the calling function.</p>
</li>
</ol>
<p><a href="https://leetcode.com/playground/3hVy3spd/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. The function <code>construct</code> is called <span class="math inline">\(n\)</span> times. At each level of the recursive tree, we traverse over all the <span class="math inline">\(n\)</span> elements to find the maximum element.  In the average case, there will be a <span class="math inline">\(\log n\)</span> levels leading to a complexity of <span class="math inline">\(O\big(n\log n\big)\)</span>. In the worst case, the depth of the recursive tree can grow upto <span class="math inline">\(n\)</span>, which happens in the case of a sorted <span class="math inline">\(nums\)</span> array, giving a complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The size of the <span class="math inline">\(set\)</span> can grow upto <span class="math inline">\(n\)</span> in the worst case. In the average case, the size will be <span class="math inline">\(\log n\)</span> for <span class="math inline">\(n\)</span> elements in <span class="math inline">\(nums\)</span>, giving an average case complexity of <span class="math inline">\(O(\log n)\)</span></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-difference-1587115620/1" target="_blank" rel="noopener noreferrer">Maximum Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 12pt;">Given an integer array <strong>arr </strong>of<strong> </strong>integers, the task is to find the maximum absolute difference between the nearest <strong>left smaller</strong> element and the nearest <strong>right smaller </strong>element of every element in array arr. If for any component of the arr, the nearest smaller element doesn't exist then consider it as 0.</span></p>
<p><span style="font-size: 12pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>arr = [2, 1, 8]
<strong>Output:</strong> 1<br /><strong>Explanation: </strong>left smaller array ls = [0, 0, 1], right smaller array rs = [1, 0, 0]. Maximum Diff of abs(ls[i] - rs[i]) = 1</span></pre>
<pre><span style="font-size: 12pt;"><strong>Input: </strong>arr = [2, 4, 8, 7, 7, 9, 3]
<strong>Output:</strong> 4<br /><strong>Explanation:</strong> left smaller array ls = [0, 2, 4, 4, 4, 7, 2], right smaller rs = [0, 3, 7, 3, 3, 3, 0]. Maximum Diff of abs(ls[i] - rs[i]) = abs(7 - 3) = 4</span></pre>
<p><span style="font-size: 12pt;"><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>6</sup><br />1&lt;= arr[i] &lt;=10<sup>9</sup><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-elegance-of-a-k-length-subsequence/description" target="_blank" rel="noopener noreferrer">Maximum Elegance of a K-Length Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>items</code> of length <code>n</code> and an integer <code>k</code>.</p>

<p><code>items[i] = [profit<sub>i</sub>, category<sub>i</sub>]</code>, where <code>profit<sub>i</sub></code> and <code>category<sub>i</sub></code> denote the profit and category of the <code>i<sup>th</sup></code> item respectively.</p>

<p>Let&#39;s define the <strong>elegance</strong> of a <strong>subsequence</strong> of <code>items</code> as <code>total_profit + distinct_categories<sup>2</sup></code>, where <code>total_profit</code> is the sum of all profits in the subsequence, and <code>distinct_categories</code> is the number of <strong>distinct</strong> categories from all the categories in the selected subsequence.</p>

<p>Your task is to find the <strong>maximum elegance</strong> from all subsequences of size <code>k</code> in <code>items</code>.</p>

<p>Return <em>an integer denoting the maximum elegance of a subsequence of </em><code>items</code><em> with size exactly </em><code>k</code>.</p>

<p><strong>Note:</strong> A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> items = [[3,2],[5,1],[10,1]], k = 2
<strong>Output:</strong> 17
<strong>Explanation: </strong>In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2<sup>2</sup> = 17, and we can show that it is the maximum achievable elegance. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> items = [[3,1],[3,1],[2,2],[5,3]], k = 3
<strong>Output:</strong> 19
<strong>Explanation:</strong> In this example, we have to select a subsequence of size 3. 
We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. 
The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. 
Hence, the elegance is 10 + 3<sup>2</sup> = 19, and we can show that it is the maximum achievable elegance.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> items = [[1,1],[2,1],[3,1]], k = 3
<strong>Output:</strong> 7
<strong>Explanation:</strong> In this example, we have to select a subsequence of size 3. 
We should select all the items. 
The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. 
Hence, the maximum elegance is 6 + 1<sup>2</sup> = 7.  </pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= items.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>items[i].length == 2</code></li>
	<li><code>items[i][0] == profit<sub>i</sub></code></li>
	<li><code>items[i][1] == category<sub>i</sub></code></li>
	<li><code>1 &lt;= profit<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= category<sub>i</sub> &lt;= n </code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-frequency-stack/description" target="_blank" rel="noopener noreferrer">Maximum Frequency Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">ordered-set</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.</p>

<p>Implement the <code>FreqStack</code> class:</p>

<ul>
	<li><code>FreqStack()</code> constructs an empty frequency stack.</li>
	<li><code>void push(int val)</code> pushes an integer <code>val</code> onto the top of the stack.</li>
	<li><code>int pop()</code> removes and returns the most frequent element in the stack.
	<ul>
		<li>If there is a tie for the most frequent element, the element closest to the stack&#39;s top is removed and returned.</li>
	</ul>
	</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;FreqStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;]
[[], [5], [7], [5], [7], [4], [5], [], [], [], []]
<strong>Output</strong>
[null, null, null, null, null, null, null, 5, 7, 5, 4]

<strong>Explanation</strong>
FreqStack freqStack = new FreqStack();
freqStack.push(5); // The stack is [5]
freqStack.push(7); // The stack is [5,7]
freqStack.push(5); // The stack is [5,7,5]
freqStack.push(7); // The stack is [5,7,5,7]
freqStack.push(4); // The stack is [5,7,5,7,4]
freqStack.push(5); // The stack is [5,7,5,7,4,5]
freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].
freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].
freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].
freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>2 * 10<sup>4</sup></code> calls will be made to <code>push</code> and <code>pop</code>.</li>
	<li>It is guaranteed that there will be at least one element in the stack before calling <code>pop</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description" target="_blank" rel="noopener noreferrer">Maximum Nesting Depth of the Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>valid parentheses string</strong> <code>s</code>, return the <strong>nesting depth</strong> of<em> </em><code>s</code>. The nesting depth is the <strong>maximum</strong> number of nested parentheses.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;(1+(2*3)+((8)/4))+1&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>Digit 8 is inside of 3 nested parentheses in the string.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;(1)+((2))+(((3)))&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>Digit 3 is inside of 3 nested parentheses in the string.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;()(())((()()))&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of digits <code>0-9</code> and characters <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;(&#39;</code>, and <code>&#39;)&#39;</code>.</li>
	<li>It is guaranteed that parentheses expression <code>s</code> is a VPS.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>The most important point in the problem description is that the given string is a valid parentheses string (VPS). This means there will always be a matching closing bracket for every opening bracket. Hence, we don't need to check the validity of the given expression. Since the nesting depth depends only on the bracket counts, we can ignore the rest of the characters, such as integers and operators.</p>
<p>The maximum nesting depth is equal to the maximum number of open brackets at a time. The stack data structure is the first choice in solving brackets matching problems. In this approach, we will use a stack to store the opening brackets. Whenever we reach a closing bracket, we will pop one bracket from the stack. Since the string is always valid, we don't have to check if the stack is empty. After each iteration, we will check the size of the stack and update the variable <code>ans</code> if the size is more than the value of <code>ans</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize a variable <code>ans</code> to <code>0</code>. This will store the maximum nesting depth so far.</p>
</li>
<li>
<p>Initialize an empty stack <code>st</code>.</p>
</li>
<li>
<p>Iterate over the characters in the string <code>s</code>, for each character <code>c</code>:</p>
<ul>
<li>If <code>c</code> is equal to <code>(</code>, add it to the stack <code>st</code>.</li>
<li>If <code>c</code> is equal to <code>)</code>, pop one element from the stack <code>st</code>.</li>
<li>Update <code>ans</code> as the max of <code>ans</code> and <code>st.size()</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VVGe6qYi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of characters in the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We are iterating over each character in the string <code>s</code>, and hence the time complexity will be equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The size of the stack can grow up to <span class="math inline">\(\frac{N}{2}\)</span> for strings like <code>(((())))</code>, and hence the space complexity of this approach will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-counter-variable">Approach 2: Counter variable</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The above approach is easily extendable to cases where the input has brackets of multiple types like <code>[]</code>, <code>()</code>, and <code>{}</code>. It is also useful if the input is invalid because we can match the current closing bracket with the previous one, even if they are different types.</p>
<p>However, the problem here is a very specific use case where the string will only have brackets of type <code>()</code> and will always be valid. Hence, using a stack is not necessary. Instead, we can use a variable to keep the count of open brackets and compare it with the variable <code>ans</code> to track the maximum nesting depth. For every open bracket <code>(</code>, we will increment the variable <code>openBrackets</code>, and for every closing bracket, we will decrement it (it will never be negative as the string is valid).</p>
<p><img src="../Figures/1614/1614A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize a variable <code>ans</code> to <code>0</code>. This will store the maximum nesting depth so far.</p>
</li>
<li>
<p>Initialize a variable <code>openBrackets</code> to <code>0</code>. This will store the current open brackets count.</p>
</li>
<li>
<p>Iterate over the characters in the string <code>s</code>, for each character <code>c</code>:</p>
<ul>
<li>If <code>c</code> is equal to <code>(</code>, increment the counter <code>openBrackets</code>.</li>
<li>If <code>c</code> is equal to <code>)</code>, decrement the counter <code>openBrackets</code>.</li>
<li>Update <code>ans</code> as the max of <code>ans</code> and <code>openBrackets</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/TRPZUwje/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of characters in the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We are iterating over each character in the string <code>s</code>, and hence the time complexity will be equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only variables we require are <code>openBrackets</code> and <code>ans</code>. Hence, the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/description" target="_blank" rel="noopener noreferrer">Maximum Nesting Depth of Two Valid Parentheses Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A string is a <em>valid parentheses string</em>&nbsp;(denoted VPS) if and only if it consists of <code>&quot;(&quot;</code> and <code>&quot;)&quot;</code> characters only, and:</p>

<ul>
	<li>It is the empty string, or</li>
	<li>It can be written as&nbsp;<code>AB</code>&nbsp;(<code>A</code>&nbsp;concatenated with&nbsp;<code>B</code>), where&nbsp;<code>A</code>&nbsp;and&nbsp;<code>B</code>&nbsp;are VPS&#39;s, or</li>
	<li>It can be written as&nbsp;<code>(A)</code>, where&nbsp;<code>A</code>&nbsp;is a VPS.</li>
</ul>

<p>We can&nbsp;similarly define the <em>nesting depth</em> <code>depth(S)</code> of any VPS <code>S</code> as follows:</p>

<ul>
	<li><code>depth(&quot;&quot;) = 0</code></li>
	<li><code>depth(A + B) = max(depth(A), depth(B))</code>, where <code>A</code> and <code>B</code> are VPS&#39;s</li>
	<li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>, where <code>A</code> is a VPS.</li>
</ul>

<p>For example,&nbsp; <code>&quot;&quot;</code>,&nbsp;<code>&quot;()()&quot;</code>, and&nbsp;<code>&quot;()(()())&quot;</code>&nbsp;are VPS&#39;s (with nesting depths 0, 1, and 2), and <code>&quot;)(&quot;</code> and <code>&quot;(()&quot;</code> are not VPS&#39;s.</p>

<p>&nbsp;</p>

<p>Given a VPS <font face="monospace">seq</font>, split it into two disjoint subsequences <code>A</code> and <code>B</code>, such that&nbsp;<code>A</code> and <code>B</code> are VPS&#39;s (and&nbsp;<code>A.length + B.length = seq.length</code>).</p>

<p>Now choose <strong>any</strong> such <code>A</code> and <code>B</code> such that&nbsp;<code>max(depth(A), depth(B))</code> is the minimum possible value.</p>

<p>Return an <code>answer</code> array (of length <code>seq.length</code>) that encodes such a&nbsp;choice of <code>A</code> and <code>B</code>:&nbsp; <code>answer[i] = 0</code> if <code>seq[i]</code> is part of <code>A</code>, else <code>answer[i] = 1</code>.&nbsp; Note that even though multiple answers may exist, you may return any of them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> seq = &quot;(()())&quot;
<strong>Output:</strong> [0,1,1,1,1,0]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> seq = &quot;()(())()&quot;
<strong>Output:</strong> [0,0,0,1,1,0,1,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= seq.size &lt;= 10000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-from-removing-substrings/description" target="_blank" rel="noopener noreferrer">Maximum Score From Removing Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and two integers <code>x</code> and <code>y</code>. You can perform two types of operations any number of times.</p>

<ul>
	<li>Remove substring <code>&quot;ab&quot;</code> and gain <code>x</code> points.

	<ul>
		<li>For example, when removing <code>&quot;ab&quot;</code> from <code>&quot;c<u>ab</u>xbae&quot;</code> it becomes <code>&quot;cxbae&quot;</code>.</li>
	</ul>
	</li>
	<li>Remove substring <code>&quot;ba&quot;</code> and gain <code>y</code> points.
	<ul>
		<li>For example, when removing <code>&quot;ba&quot;</code> from <code>&quot;cabx<u>ba</u>e&quot;</code> it becomes <code>&quot;cabxe&quot;</code>.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the maximum points you can gain after applying the above operations on</em> <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cdbcbbaaabab&quot;, x = 4, y = 5
<strong>Output:</strong> 19
<strong>Explanation:</strong>
- Remove the &quot;ba&quot; underlined in &quot;cdbcbbaaa<u>ba</u>b&quot;. Now, s = &quot;cdbcbbaaab&quot; and 5 points are added to the score.
- Remove the &quot;ab&quot; underlined in &quot;cdbcbbaa<u>ab</u>&quot;. Now, s = &quot;cdbcbbaa&quot; and 4 points are added to the score.
- Remove the &quot;ba&quot; underlined in &quot;cdbcb<u>ba</u>a&quot;. Now, s = &quot;cdbcba&quot; and 5 points are added to the score.
- Remove the &quot;ba&quot; underlined in &quot;cdbc<u>ba</u>&quot;. Now, s = &quot;cdbc&quot; and 5 points are added to the score.
Total score = 5 + 4 + 5 + 5 = 19.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabbaaxybbaabb&quot;, x = 5, y = 4
<strong>Output:</strong> 20
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= x, y &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-greedy-way-stack">Approach 1: Greedy Way (Stack)</h3>
<h4 id="intuition">Intuition</h4>
<p>The fundamental insight here is that we should always try to remove the substring ('ab' or 'ba') that yields the higher points first.</p>
<p>To solve this problem, we use a two-pass approach to efficiently remove both substrings:</p>
<ol>
<li>In the first pass, remove all instances of the higher-scoring substring.</li>
<li>In the second pass, remove all instances of the lower-scoring substring from the remaining text.</li>
</ol>
<p>We implement this using a stack-based approach. As we iterate through the string, we push characters onto a stack. If the character at the top of the stack and the current character form the target substring, we pop the stack and move on without pushing the current character. This effectively removes the substring. If you are unfamiliar with such a technique, trying out <a href="https://leetcode.com/problems/valid-parentheses/description/">this</a> problem first may help.</p>
<p>After the first pass, we reconstruct the remaining string by popping all characters from the stack into a new string and reversing it. We repeat this process for the lower-scoring substring.</p>
<p>We determine the total number of removed substrings by comparing the string's length before and after the removal process. The length difference, divided by 2 (since each substring is two characters long), gives the count of removed substrings. We then multiply this count by the point value of that substring to calculate the score for each pass.</p>
<details>
<summary>Let us prove the greedy approach using the principle of contradiction:</summary>
<br>
<p>Suppose <span class="math inline">\(x \geq y\)</span>. Therefore, removing 'ab' yields higher or equal points compared to 'ba'. Assume there exists an optimal sequence where removing 'ba' is more optimal than removing 'ab'. This would imply removing 1 'ab' restricts us from removing 2 'ba's, i.e., the 'ab' is shared by 2 'ba's.</p>
<p>Consider the string 'baba'. If we remove 'ba' first, we are left with another 'ba', totaling <span class="math inline">\(2 \cdot y\)</span> points.</p>
<p>Conversely, if we remove 'ab' first, we are left with one 'ba', totaling <span class="math inline">\(x + y\)</span> points.</p>
<p>Since <span class="math inline">\(x \geq y\)</span>, <span class="math inline">\(2 \cdot y\)</span> cannot be greater than <span class="math inline">\(x + y\)</span>. Thus, our initial assumption is wrong.</p>
</details>
<h4 id="algorithm">Algorithm</h4>
<p>Main Method <code>maximumGain</code>:</p>
<ul>
<li>Initialize <code>totalScore</code> to <code>0</code> to keep track of the accumulated points.</li>
<li>Determine <code>highPriorityPair</code> based on which of <code>x</code> or <code>y</code> is larger. If <code>x</code> &gt; <code>y</code>, it's &quot;ab&quot;, otherwise &quot;ba&quot;.</li>
<li>Set <code>lowPriorityPair</code> as the opposite of <code>highPriorityPair</code>.</li>
<li>Call <code>removeSubstring</code> with the original string and <code>highPriorityPair</code>.</li>
<li>Calculate the number of removed pairs (<code>removedPairsCount</code>) by comparing the lengths of the original and processed strings, divided by 2.</li>
<li>Add to <code>totalScore</code> the product of removed pairs and the higher of <code>x</code> and <code>y</code>.</li>
<li>Call <code>removeSubstring</code> again with the result of the first pass and <code>lowPriorityPair</code>.</li>
<li>Calculate the number of removed pairs in this second pass.</li>
<li>Add to <code>totalScore</code> the product of removed pairs and the lower of <code>x</code> and <code>y</code>.</li>
<li>Return <code>totalScore</code>.</li>
</ul>
<p>Helper Method <code>removeSubstring</code>:</p>
<ul>
<li>Define a method <code>removeSubstring</code> which takes the input string <code>input</code> and the substring to remove <code>targetPair</code> as parameters.</li>
<li>Initialize a stack <code>charStack</code> to store characters during processing.</li>
<li>Iterate over each character in <code>input</code>:
<ul>
<li>If the top of the stack and the current character combine to form the target string, pop from the stack.</li>
<li>Else, push the current character onto the stack.</li>
</ul>
</li>
<li>Form a string by popping each character in the stack, reverse it, and return it.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HTbbNxsD/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>removeSubstring</code> method is called twice in the algorithm. In it, the algorithm iterates over each character in the <code>input</code> string, which has a time complexity of <span class="math inline">\(O(n)\)</span>. Reconstructing the string from the stack also takes <span class="math inline">\(O(n)\)</span>. Thus, the total time complexity of the algorithm is <span class="math inline">\(2 \cdot ( O(n) + O(n) )\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>stringAfterFirstPass</code> and <code>stringAfterSecondPass</code> variables can use an additional space of <span class="math inline">\(O(n)\)</span> in the worst case. In the <code>removeSubstring</code> method, the stack can store at most <span class="math inline">\(n\)</span> characters, and the reconstructed string can also store at most <code>n</code> characters, resulting in a space complexity of <span class="math inline">\(O(n)\)</span> for each. When considering all these individual complexities together, the space complexity of the algorithm amounts to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-greedy-way-without-stack">Approach 2: Greedy Way (Without Stack)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's consider eliminating the stack to improve the space complexity of Approach 1. In the <code>removeSubstring</code> method, we search for occurrences of the <code>target</code> string and remove them. Why not just remove these occurrences from the string directly?</p>
<p>We maintain two indices: <code>readIndex</code> and <code>writeIndex</code>. <code>readIndex</code> iterates over each character in <code>input</code>, while <code>writeIndex</code> indicates where the next character should be written in the modified string. During each iteration, we copy the character at <code>readIndex</code> to <code>writeIndex</code>. We then check if the last two characters of the modified string match <code>target</code>. If they do, we remove the substring from <code>input</code> by moving <code>writeIndex</code> back by 2 (the length of <code>target</code>). Subsequent iterations continue to overwrite positions of the removed substring.</p>
<p>After processing all characters, we trim the modified <code>input</code> to remove any excess characters beyond <code>writeIndex</code>. The resulting string, now without any occurrences of <code>target</code>, can then be passed to the second call of the <code>removeSubstring</code> method.</p>
<p>Have a look at the slideshow to better understand this process. In this example, we consider <code>s = &quot;cdbcbbaaabab&quot;</code>, <code>x = 4</code> and <code>y = 2</code>.</p>
<p>!?!../Documents/1717/app2_slideshow.json:1524,604!?!</p>
<p>Note: The algorithm modifies the input string in place, which is feasible because strings are mutable in C++ but immutable in Java and Python3. Therefore, in Java, we convert the string to a StringBuilder object, and in Python3, to a list. This conversion increases the space complexity of the algorithm but avoids using a stack at each call of the <code>removeSubstring</code> method.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>maximumGain</code>:</p>
<ul>
<li>Initialize <code>totalPoints</code> to keep track of the score.</li>
<li>Compare <code>x</code> and <code>y</code> to determine which substring to remove first:
<ul>
<li>If <code>x &gt; y</code>, call <code>removeSubstring</code> on &quot;ab&quot; first, then &quot;ba&quot;.</li>
<li>Else, call <code>removeSubstring</code> on &quot;ba&quot; first, then &quot;ab&quot;.</li>
<li>Add the value returned by <code>removeSubstring</code> after each call.</li>
</ul>
</li>
<li>Return <code>totalPoints</code>, which contains the maximum score from removing substrings.</li>
</ul>
<p>Helper method <code>removeSubstring</code>:</p>
<ul>
<li>Define a method <code>removeSubstring</code> which takes the <code>inputString</code>, the <code>targetString</code> and <code>pointsPerRemoval</code> as parameters.</li>
<li>Initialize <code>totalPoints</code> and <code>writeIndex</code> to <code>0</code>.</li>
<li>Iterate through the input string using <code>readIndex</code>:
<ul>
<li>Copy the current character to the position at <code>writeIndex</code> and increment <code>writeIndex</code>.</li>
<li>Check if the last two written characters match the target substring:
<ul>
<li>If so, decrement <code>writeIndex</code> by 2.</li>
<li>Add <code>pointsPerRemoval</code> to <code>totalPoints</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Trim the string to remove all excess characters after <code>writeIndex</code>.</li>
<li>Return <code>totalPoints</code> accumulated during this pass.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/8VSgpRRE/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm calls <code>removeSubstring</code> twice, each iterating through the entire string once. All operations within the loopâ€”such as character comparisons and index manipulationsâ€”are constant time. Thus, the time complexity is <span class="math inline">\(2 \cdot O(n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>In the C++ implementation of the algorithm, where strings are mutable, we do not use any additional data structures which scale with input size. Thus, the space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
<p>In the Java and Python3 implementations, we use an additional data structure to bypass the caveat of immutable strings. This takes <span class="math inline">\(O(n)\)</span> space, which is the space complexity of the algorithm.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-greedy-way-counting">Approach 3: Greedy Way (Counting)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Notice that in previous approaches, removing substrings from the input string posed as the bottleneck to better performance. Instead of removing the substrings, can we count the number of substrings that can be potentially removed, and count the total score from there?</p>
<p>Let's consider a case where &quot;ab&quot; is the higher-scoring substring. To find the score, we need to form pairs of the characters <code>a</code> and <code>b</code>, where:</p>
<ul>
<li>If we encounter <code>b</code> and have previously seen an <code>a</code>, we can form an &quot;ab&quot; pair.</li>
<li>If we encounter <code>a</code> and have previously seen a <code>b</code>, we can form a &quot;ba&quot; pair.</li>
</ul>
<p>But, how do we ensure that the score is maximum? That's where the greedy strategy comes in:</p>
<p>Let's use <code>aCount</code> and <code>bCount</code> to keep track of unpaired 'a's and 'b's respectively.</p>
<ol>
<li>When we come across an <code>a</code>, we simply increment <code>aCount</code>. We don't immediately pair it because a future 'b' might form a higher-scoring &quot;ab&quot; pair.</li>
<li>When we encounter a <code>b</code>, we have two choices. If there's an unpaired <code>a</code> available (<code>aCount</code> &gt; 0), we immediately form an &quot;ab&quot; pair, decrement <code>aCount</code>, and add points, since this is the most profitable option. Otherwise, we increment <code>bCount</code> for potential future &quot;ba&quot; pairs.</li>
<li>When we encounter a non <code>a</code> or <code>b</code> character, it acts as a barrier. We form as many &quot;ba&quot; pairs as possible, add the points, and reset the counters. This segmentation ensures we don't incorrectly pair across these barriers.</li>
</ol>
<p>The below slideshow gives a step-by-step demonstration of the entire algorithm. In this example, we consider <code>s = &quot;cdbcbbaaabab&quot;</code>, <code>x = 4</code> and <code>y = 2</code>.</p>
<p>!?!../Documents/1717/app3_slideshow.json:1522,462!?!</p>
<p>However, all of this is valid when &quot;ab&quot; is the higher-scoring substring. What if &quot;ba&quot; is the more profitable one? An easy trick to fix this is to simply reverse the given string <code>s</code> and flip the values of <code>x</code> and <code>y</code>. Since the order of counting does not matter, all &quot;ba&quot; substrings present in <code>s</code> are now &quot;ab&quot; and vice-versa.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>If <code>x</code> is less than <code>y</code>:
<ul>
<li>Swap the values of <code>x</code> and <code>y</code> to ensure &quot;ab&quot; always has higher points than &quot;ba&quot;.</li>
<li>Reverse <code>s</code> to maintain the logic of the algorithm after swapping.</li>
</ul>
</li>
<li>Initialize variables:
<ul>
<li><code>aCount</code> to count occurrences of 'a'.</li>
<li><code>bCount</code> to count occurrences of 'b'.</li>
<li><code>totalPoints</code> to accumulate the total score.</li>
</ul>
</li>
<li>Iterate through the string <code>s</code>. For each character:
<ul>
<li>If the character is 'a', increment <code>aCount</code>.</li>
<li>If the character is 'b':
<ul>
<li>If <code>aCount</code> is greater than 0, decrement <code>aCount</code> and increment <code>totalPoints</code> by <code>x</code> (for removing &quot;ab&quot; and gaining points).</li>
<li>Else, increment <code>bCount</code> (for potential future &quot;ba&quot; pairs).</li>
</ul>
</li>
<li>If the character is neither <code>a</code> nor <code>b</code>:
<ul>
<li>Increment <code>totalPoints</code> by the minimum of <code>aCount</code> and <code>bCount</code>, multiplied by <code>y</code> (for removing &quot;ba&quot; pairs and gaining points).</li>
<li>Reset <code>aCount</code> and <code>bCount</code> to <code>0</code> to start counting for the next segment.</li>
</ul>
</li>
</ul>
</li>
<li>Add any remaining &quot;ba&quot; pairs by incrementing <code>totalPoints</code> by the minimum of <code>aCount</code> and <code>bCount</code>, multiplied by <code>y</code>.</li>
<li>Return <code>totalPoints</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/oUT94eA5/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the given string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm reverses the string in the worst case and iterates over each character of the string exactly once, with each operation taking <span class="math inline">\(O(n)\)</span> time. Therefore, the time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>In the C++ implementation of the algorithm, the string reversal takes constant space since <code>reverse()</code> flips the string in-place.</p>
<p>For the Java and Python3 implementations, the string reversal requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>We do not use any other data structures that scale with the input size. Therefore, the space complexity of the algorithm is <span class="math inline">\(O(1)\)</span> for C++, and <span class="math inline">\(O(n)\)</span> for Java and Python3.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-of-a-good-subarray/description" target="_blank" rel="noopener noreferrer">Maximum Score of a Good Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> <strong>(0-indexed)</strong> and an integer <code>k</code>.</p>

<p>The <strong>score</strong> of a subarray <code>(i, j)</code> is defined as <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>. A <strong>good</strong> subarray is a subarray where <code>i &lt;= k &lt;= j</code>.</p>

<p>Return <em>the maximum possible <strong>score</strong> of a <strong>good</strong> subarray.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,3,7,4,5], k = 3
<strong>Output:</strong> 15
<strong>Explanation:</strong> The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,4,5,4,1,1,1], k = 0
<strong>Output:</strong> 20
<strong>Explanation:</strong> The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= k &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>The score of a subarray is its length multiplied by its minimum element. In this problem, we must find the maximum score of all subarrays that contain <code>nums[k]</code>.</p>
<p>How can we improve our score? When we take more elements we increase the length of the subarray, which helps the score. However, we may find new minimums, which would decrease our score.</p>
<p>We can start by separating the array - numbers to the left of <code>k</code> and numbers to the right of <code>k</code> (and including <code>k</code>).</p>
<p><img src="../Figures/1793/1.png" alt="img" /><br />
<br></p>
<p>Notice that <code>k</code> is the meeting point of these sections. If we want to take elements in the left section, we start from the end of the left section and move toward the beginning. If we want to take elements in the right section, we start from the beginning and move toward the end.</p>
<p>Of course, each element we take will increase our length by <code>1</code>. But how will it affect our minimum? To compute this quickly, we can create new arrays for each section. These arrays will represent the minimum element we have seen in the section if we started from <code>k</code>.</p>
<p><img src="../Figures/1793/2.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we took two elements from the left section. We can quickly see that the minimum element from the left section is <code>3</code> using these arrays. Similarly, if we took all elements from the right section, we could quickly see that the minimum element from the right section is <code>4</code>.</p>
<blockquote>
<p>We will call these arrays that allow us to find the minimums <code>left</code> and <code>right</code>.</p>
</blockquote>
<p>Now that we have these arrays, how can we solve the problem? Because <code>nums[k]</code> is in the right section, we will iterate over the entire right section and try to take each element. Let's say we take some number of elements from the right section, and the minimum is <code>x</code>. How many elements can we take from the left section without changing <code>x</code> as the minimum? We must only take elements from the left that are greater than or equal to <code>x</code>.</p>
<p>Let's switch to another example. For a given array, assuming we have already built the <code>left</code> and <code>right</code> arrays using the previous method.</p>
<p><img src="../Figures/1793/3.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we take four elements from the right section. The minimum is <code>5</code>. How many elements can we take from the left section without changing the minimum? Two. This gives us a total size of <code>4 + 2 = 6</code>, and a total score of <code>6 * 5 = 30</code>.</p>
<p>How do we quickly find the number of elements we can take from the left section? Note that when we are building the array <code>left</code> from right to left, each time we go left we encounter a new number that is only likely to lower the minimum value, and the further to the left we go, the smaller the minimum value becomes, i.e., <code>left</code> is already sorted from smallest to largest. Therefore, we can perform a binary search to identify how many elements we can take.</p>
<p>This brings us to our solution. We iterate with <code>j</code> over each index of <code>right</code> and assign <code>currMin = right[j]</code>, which represents the minimum of our subarray. We then perform a binary search to find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code>. Once we have <code>i</code>, we can calculate the size of our subarray, and thus the score. We take the maximum of all scores.</p>
<p>How do we calculate the size of our subarray given <code>i</code> and <code>j</code>?</p>
<p><img src="../Figures/1793/4.png" alt="img" /><br />
<br></p>
<p>Because the right section starts at index <code>k</code>, its indices are offset by <code>k</code> from the real indices. Thus, in the original array, <code>right[j]</code> points to index <code>k + j</code>. The left section is not offset at all, so <code>i</code> is correctly positioned. The size of a subarray bounded by <code>[left, right]</code> is <code>right - left + 1</code>. Thus, the size of our subarray <code>[i, k + j]</code> is <code>(k + j) - i + 1</code>. We can multiply this by <code>right[j]</code> to calculate our score.</p>
<p>You may have noticed: this algorithm assumes that in the optimal subarray, the minimum value is in the right section. But what if this assumption is wrong, and its actually in the left section? We can check the left section by simply reversing the array and then applying the same algorithm to it. Note that when we reverse the array, <code>k</code> will change. After reversal, the original <code>k</code> will be at <code>nums.length - k - 1</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>solve(nums, k)</code> that runs our algorithm:
<ul>
<li>Set <code>n = nums.length</code>, <code>left</code> to an array of length <code>k</code>, and <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k - 1</code> until <code>0</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and set <code>left[i] = currMin</code>.</li>
<li>Initialize an empty array <code>right</code> and reset <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k</code> until <code>n - 1</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and push <code>currMin</code> to <code>right</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>j</code> over the indices of <code>right</code>:
<ul>
<li>Set <code>currMin = right[j]</code>.</li>
<li>Find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code> using binary search.</li>
<li>Calculate <code>size = (k + j) - i - 1</code>.</li>
<li>Update <code>ans</code> with <code>currMin * size</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = solve(nums, k)</code>.</li>
<li>Reverse <code>nums</code>.</li>
<li>Return the larger of <code>ans, solve(nums, nums.length - k - 1)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/AePxSPjG/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> time to create <code>left</code> and <code>right</code>. Then, we iterate over the indices of <code>right</code>, which is not more than <span class="math inline">\(O(n)\)</span> iterations. At each iteration, we perform a binary search over <code>left</code>, which does not cost more than <span class="math inline">\(O(\log{}n)\)</span>. Thus, <code>solve</code> costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>, and we call it twice.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code> and <code>right</code> have a combined length of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<p><strong>Intuition</strong></p>
<p>In this approach, we will use a similar idea as in the previous approach. For a given index <code>i</code>, if we treat <code>nums[i]</code> as the minimum element, we need to know how many elements we can take on the left and right such that we do not take any elements less than <code>nums[i]</code>.</p>
<blockquote>
<p>You might be thinking: what if <code>nums[k]</code> is not included? We will get to that after presenting the full idea of the approach.</p>
</blockquote>
<p>Essentially, we need to know how far away the next lesser element is on both sides. If we have this information for all indices, we can quickly calculate the maximum score possible by treating every <code>nums[i]</code> as the minimum, since in the optimal solution, one of the indices must be the minimum.</p>
<p>There is a very similar problem called <a href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element</a>. The logic is identical, except that we are looking for the next smaller element. We can accomplish this using a monotonic stack.</p>
<details><summary><b>If you aren't familiar with monotonic stacks, click here.</b></summary>
<p>A monotonic stack is a stack whose elements are always sorted. In our case, we want a monotonic <strong>increasing</strong> stack, i.e. the elements in the stack are always sorted in ascending order.</p>
<p>To maintain this monotonic stack, we need to make sure that whenever we push a new element, it is the largest value in the stack. Before we push an element <code>num</code>, we check the top of the stack. If the top of the stack is greater than <code>num</code>, we pop from it. Since there may be multiple elements greater than <code>num</code> in the stack, we need to use a while loop to &quot;clean&quot; the stack before pushing <code>num</code>.</p>
<p>Only once there are no elements in the stack greater than <code>num</code> will we push <code>num</code>.</p>
</details>
<br>
<p>We will create an array <code>left</code>, where <code>left[i]</code> has the index of the first element to the left of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>Similarly, we will create an array <code>right</code> where <code>right[i]</code> has the index of the first element to the right of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>So how do we calculate <code>right</code>? Let's say that we are iterating over <code>nums</code> from the left and we have a chain of increasing numbers:</p>
<p><img src="../Figures/1793/5.png" alt="img" /><br />
<br></p>
<p>As you can see in the example, we have 6 increasing numbers, and then a <code>1</code> that is less than all of them. This <code>1</code> (at index 6) should be the value of <code>right</code> for all the indices of the increasing numbers. If we maintain a monotonic increasing stack, then this <code>1</code> will cause all those numbers to be popped out.</p>
<p>With a monotonic increasing stack, whenever we see an element that is smaller than the top of the stack, it is guaranteed to be the first smaller element for the element at the top of the stack. This is exactly what we are looking for.</p>
<p>To calculate <code>left</code>, we use the exact same process, except we iterate backward starting from the end of <code>nums</code>.</p>
<p>Note that because we need to remember what indices to update when we pop from the stack, we will store indices on the stack instead of the elements themselves. We can easily find the values by referencing <code>nums</code>.</p>
<p>We will initialize the values of <code>left</code> to <code>-1</code> and the values of <code>right</code> to <code>n</code>. This way, the math will still work out later if there are elements that do not have any lower values to the left or right.</p>
<p>Once we have <code>left</code> and <code>right</code>, we can iterate over all indices <code>i</code> and try to find a maximum score. Remember that the subarray must contain index <code>k</code>. Thus, we can only use an index <code>i</code> as the minimum if <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>.</p>
<p>When we treat an index <code>i</code> as the minimum, what score can we achieve? Our window starts one index after <code>left[i]</code> because including <code>left[i]</code> would create a new minimum. Similarly, our window ends one index before <code>right[i]</code>. Thus, we need to subtract <code>2</code> from the normal subarray size formula. This gives us a subarray size of <code>right[i] - left[i] - 1</code>. We multiply this size by <code>nums[i]</code> to get our score.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left</code> as an array of length <code>n</code> with values of <code>-1</code>, and an empty <code>stack</code>.</li>
<li>Iterate <code>i</code> from <code>n - 1</code> until <code>0</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>left[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>right</code> as an array of length <code>n</code> with values of <code>n</code> and reset <code>stack</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>right[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>If <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>, update <code>ans</code> with <code>nums[i] * (right[i] - left[i] - 1)</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/N4kEkyfF/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>It costs <span class="math inline">\(O(n)\)</span> to calculate <code>left</code> and <code>right</code>. We iterate over each index once and perform amortized <span class="math inline">\(O(1)\)</span> work at each iteration. The reason it amortizes to <span class="math inline">\(O(1)\)</span>, despite the while loop, is because the while loop can run a maximum of <span class="math inline">\(n\)</span> times across all iterations, and each index can only be pushed onto and popped from the stack once.</p>
<p>To calculate <code>ans</code>, we iterate over the indices once and perform <span class="math inline">\(O(1)\)</span> work at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code>, <code>right</code>, and <code>stack</code> all require <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-greedy">Approach 3: Greedy</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes the simplest approach is the best! The optimal subarray must contain index <code>k</code>, so it makes sense to consider the subarray with only <code>nums[k]</code> as a starting point.</p>
<p>From here, how do we expand the subarray? We can either add an element to the left or an element to the right. Let's say we have two pointers, <code>left</code> and <code>right</code> that represent our subarray. Which direction should we go?</p>
<p>If we move left, it's equivalent to adding <code>nums[left - 1]</code> to our subarray. If we move right, it's equivalent to adding <code>nums[right + 1]</code> to our subarray. We should move in the direction of the greater element.</p>
<p>At each step, we update <code>currMin</code> which is initially set to <code>nums[k]</code>, and try to update <code>ans</code> which is also initially set to <code>nums[k]</code>. We can update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is larger.</p>
<p>This greedy process is very similar to the one used to solve <a href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water</a>. But why does it work? We will use a proof by contradiction to demonstrate that not doing it this way wouldn't result in a higher value either.</p>
<p>At each step, we choose between having our subarray as <code>[left - 1, right]</code> or <code>[left, right + 1]</code>. Let's assume that <code>nums[left - 1] &gt; nums[right + 1]</code> and the optimal subarray has not been found yet. The optimal subarray must include <code>nums[left - 1]</code>. If it doesn't, then it must include <code>nums[right + 1]</code>, since we could only move right to &quot;avoid&quot; <code>nums[left - 1]</code>. However, any subarray that includes <code>nums[right + 1]</code> could also include <code>nums[left - 1]</code> without affecting the minimum, while also increasing the length of the subarray and thus the score. Thus, it is impossible for the optimal subarray to include <code>nums[right + 1]</code> and not <code>nums[left - 1]</code>, and in general the optimal subarray must include <code>nums[left - 1]</code>.</p>
<p><strong>Algorithm</strong></p>
<p>To implement the while loop, we will iterate until we have exhausted the array. If one of the pointers is out of bounds, we will consider the element it points to as <code>0</code>.</p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left = k</code>, <code>right = k</code>, <code>ans = nums[k]</code>, and <code>currMin = nums[k]</code>.</li>
<li>While <code>left &gt; 0</code> or <code>right &lt; n - 1</code>:
<ul>
<li>Compare <code>nums[left - 1]</code> with <code>nums[right + 1]</code>:
<ul>
<li>If <code>nums[right + 1]</code> is greater, increment <code>right</code> and update <code>currMin</code> with <code>nums[right]</code> if it is lower.</li>
<li>Otherwise, decrement <code>left</code> and update <code>currMin</code> with <code>nums[left]</code> if it is lower.</li>
</ul>
</li>
<li>Update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is greater.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/ayvayDq2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>At each iteration, our <code>left</code> or <code>right</code> pointers move closer to the edges of the array by <code>1</code>. Thus, we perform <span class="math inline">\(O(n)\)</span> iterations. Each iteration costs <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We aren't using any extra space other than a few integers.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-subarray-min-product/description" target="_blank" rel="noopener noreferrer">Maximum Subarray Min-Product</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">prefix-sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>min-product</strong> of an array is equal to the <strong>minimum value</strong> in the array <strong>multiplied by</strong> the array&#39;s <strong>sum</strong>.</p>

<ul>
	<li>For example, the array <code>[3,2,5]</code> (minimum value is <code>2</code>) has a min-product of <code>2 * (3+2+5) = 2 * 10 = 20</code>.</li>
</ul>

<p>Given an array of integers <code>nums</code>, return <em>the <strong>maximum min-product</strong> of any <strong>non-empty subarray</strong> of </em><code>nums</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Note that the min-product should be maximized <strong>before</strong> performing the modulo operation. Testcases are generated such that the maximum min-product <strong>without</strong> modulo will fit in a <strong>64-bit signed integer</strong>.</p>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,<u>2,3,2</u>]
<strong>Output:</strong> 14
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).
2 * (2+3+2) = 2 * 7 = 14.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,<u>3,3</u>,1,2]
<strong>Output:</strong> 18
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).
3 * (3+3) = 3 * 6 = 18.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,<u>5,6,4</u>,2]
<strong>Output:</strong> 60
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).
4 * (5+6+4) = 4 * 15 = 60.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-queries/description" target="_blank" rel="noopener noreferrer">Maximum Sum Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-indexed-tree</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">segment-tree</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, each of length <code>n</code>, and a <strong>1-indexed 2D array</strong> <code>queries</code> where <code>queries[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p>

<p>For the <code>i<sup>th</sup></code> query, find the <strong>maximum value</strong> of <code>nums1[j] + nums2[j]</code> among all indices <code>j</code> <code>(0 &lt;= j &lt; n)</code>, where <code>nums1[j] &gt;= x<sub>i</sub></code> and <code>nums2[j] &gt;= y<sub>i</sub></code>, or <strong>-1</strong> if there is no <code>j</code> satisfying the constraints.</p>

<p>Return <em>an array </em><code>answer</code><em> where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]
<strong>Output:</strong> [6,10,7]
<strong>Explanation:</strong> 
For the 1st query <code node="[object Object]">x<sub>i</sub> = 4</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 1</code>, we can select index&nbsp;<code node="[object Object]">j = 0</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 4</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 1</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 6, and we can show that 6 is the maximum we can obtain.

For the 2nd query <code node="[object Object]">x<sub>i</sub> = 1</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 3</code>, we can select index&nbsp;<code node="[object Object]">j = 2</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 1</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 3</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 10, and we can show that 10 is the maximum we can obtain. 

For the 3rd query <code node="[object Object]">x<sub>i</sub> = 2</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 5</code>, we can select index&nbsp;<code node="[object Object]">j = 3</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 2</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 5</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 7, and we can show that 7 is the maximum we can obtain.

Therefore, we return&nbsp;<code node="[object Object]">[6,10,7]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]
<strong>Output:</strong> [9,9,9]
<strong>Explanation:</strong> For this example, we can use index&nbsp;<code node="[object Object]">j = 2</code>&nbsp;for all the queries since it satisfies the constraints for each query.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]
<strong>Output:</strong> [-1]
<strong>Explanation:</strong> There is one query in this example with <code node="[object Object]">x<sub>i</sub></code> = 3 and <code node="[object Object]">y<sub>i</sub></code> = 3. For every index, j, either nums1[j] &lt; <code node="[object Object]">x<sub>i</sub></code> or nums2[j] &lt; <code node="[object Object]">y<sub>i</sub></code>. Hence, there is no solution. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>nums1.length == nums2.length</code>&nbsp;</li>
	<li><code>n ==&nbsp;nums1.length&nbsp;</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup>&nbsp;</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length ==&nbsp;2</code></li>
	<li><code>x<sub>i</sub>&nbsp;== queries[i][1]</code></li>
	<li><code>y<sub>i</sub> == queries[i][2]</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-twin-sum-of-a-linked-list/description" target="_blank" rel="noopener noreferrer">Maximum Twin Sum of a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked-list</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a linked list of size <code>n</code>, where <code>n</code> is <strong>even</strong>, the <code>i<sup>th</sup></code> node (<strong>0-indexed</strong>) of the linked list is known as the <strong>twin</strong> of the <code>(n-1-i)<sup>th</sup></code> node, if <code>0 &lt;= i &lt;= (n / 2) - 1</code>.</p>

<ul>
	<li>For example, if <code>n = 4</code>, then node <code>0</code> is the twin of node <code>3</code>, and node <code>1</code> is the twin of node <code>2</code>. These are the only nodes with twins for <code>n = 4</code>.</li>
</ul>

<p>The <strong>twin sum </strong>is defined as the sum of a node and its twin.</p>

<p>Given the <code>head</code> of a linked list with even length, return <em>the <strong>maximum twin sum</strong> of the linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png" style="width: 250px; height: 70px;" />
<pre>
<strong>Input:</strong> head = [5,4,2,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong>
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png" style="width: 250px; height: 70px;" />
<pre>
<strong>Input:</strong> head = [4,2,2,3]
<strong>Output:</strong> 7
<strong>Explanation:</strong>
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7. 
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png" style="width: 200px; height: 88px;" />
<pre>
<strong>Input:</strong> head = [1,100000]
<strong>Output:</strong> 100001
<strong>Explanation:</strong>
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is an <strong>even</strong> integer in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-width-ramp/description" target="_blank" rel="noopener noreferrer">Maximum Width Ramp</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>ramp</strong> in an integer array <code>nums</code> is a pair <code>(i, j)</code> for which <code>i &lt; j</code> and <code>nums[i] &lt;= nums[j]</code>. The <strong>width</strong> of such a ramp is <code>j - i</code>.</p>

<p>Given an integer array <code>nums</code>, return <em>the maximum width of a <strong>ramp</strong> in </em><code>nums</code>. If there is no <strong>ramp</strong> in <code>nums</code>, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,0,8,2,1,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,8,1,0,1,9,4,0,4,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach 1: Brute Force (Time Limit Exceeded)</h3>
<h4 id="intuition">Intuition</h4>
<p>For this problem, we need to efficiently find two indices <code>i</code> and <code>j</code> such that <code>i &lt; j</code> and <span class="math inline">\(\text{nums}[i] \leq \text{nums}[j]\)</span>.</p>
<p>The brute force approach is to check every possible pair <code>(i, j)</code> where <code>i &lt; j</code> and <span class="math inline">\(\text{nums}[i] \leq \text{nums}[j]\)</span>, and compute the maximum ramp width.</p>
<p>For each valid pair, compute the width <code>j - i</code> and update the maximum width if necessary.</p>
<p>However, this brute force approach will not work due to the constraints below:</p>
<ul>
<li><span class="math inline">\(2 \leq \text{nums.length} \leq 5 \times 10^4\)</span></li>
<li><span class="math inline">\(0 \leq \text{nums}[i] \leq 5 \times 10^4\)</span></li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>nums</code> array and <code>maxWidth</code> to 0.</li>
<li>Use a nested loop to iterate through all pairs <code>(i, j)</code> where:
<ul>
<li>The outer loop variable <code>i</code> goes from <code>0</code> to <code>n - 1</code>.</li>
<li>The inner loop variable <code>j</code> goes from <code>i + 1</code> to <code>n - 1</code>.</li>
</ul>
</li>
<li>For each pair <code>(i, j)</code>:
<ul>
<li>Check if <code>nums[i]</code> is less than or equal to <code>nums[j]</code>.
<ul>
<li>If true, calculate the width as <code>j - i</code>.</li>
<li>Update <code>maxWidth</code> with the maximum value between the current <code>maxWidth</code> and the calculated width.</li>
</ul>
</li>
</ul>
</li>
<li>After checking all pairs, return <code>maxWidth</code> as the result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/E2gfxGiq/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a nested loop where the outer loop iterates <span class="math inline">\(n\)</span> times and the inner loop can iterate up to <span class="math inline">\(n - 1\)</span> times for each iteration of the outer loop. This results in a total of <span class="math inline">\(\frac{n(n-1)}{2}\)</span> iterations, leading to a quadratic time complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only requires a few integer variables (<code>n</code> and <code>maxWidth</code>) regardless of the size of the input array <code>nums</code>. There are no data structures used that would grow with the size of the input. Hence, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting">Approach 2: Sorting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In Approach 1, comparing <code>nums[i]</code> with <code>nums[j]</code> needed to be done for all pairs since <code>nums</code> is not sorted in order. This leads to an inefficient solution.</p>
<p>To make our solution more efficient, we can sort the indices of the array based on the values of <code>nums</code>. This way, when processing indices in the sorted order, each value is guaranteed to be greater than or equal to the values of previously processed indices.</p>
<p>Once the indices are sorted, we track the smallest index we've seen so far as we move through the sorted list. For each index we encounter, we calculate the difference between the current index and the smallest one. This difference represents a potential ramp width, and we update our maximum width as we go.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Find the size of the input array <code>nums</code> and initialize a array <code>indices</code> of the same size to hold the indices.</li>
<li>Initialize the <code>indices</code> array and fill it with values from <code>0</code> to <code>n-1</code> (each index corresponding to its position in <code>nums</code>).</li>
<li>Sort the <code>indices</code> based on the values in <code>nums</code>:
<ul>
<li>Use a custom comparator to ensure stability while sorting:
<ul>
<li>Compare values in <code>nums</code> for the corresponding indices.</li>
<li>If the values are equal, maintain the original order of the indices.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>minIndex</code> to <code>n</code> (a value larger than any possible index) to track the minimum index encountered so far.</li>
<li>Initialize <code>maxWidth</code> to <code>0</code> to store the maximum width ramp found.</li>
<li>Iterate over the sorted <code>indices</code>:
<ul>
<li>Update <code>maxWidth</code> to be the maximum of its current value and the difference between the current index (<code>indices[i]</code>) and <code>minIndex</code>.</li>
<li>Update <code>minIndex</code> to be the minimum of its current value and the current index (<code>indices[i]</code>).</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/DqjkzxEw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The most significant factor in the time complexity comes from the sorting operation on the <code>indices</code> array. Sorting takes <span class="math inline">\(O(n \log n)\)</span> time. The subsequent loop that calculates the maximum width ramp runs in <span class="math inline">\(O(n)\)</span> time. Thus, the overall time complexity is dominated by the sorting step, resulting in <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + S) = O(n)\)</span></p>
<p>The space complexity is primarily determined by the additional <code>indices</code> array that stores the indices of the <code>nums</code> array, which requires <span class="math inline">\(O(n)\)</span> space. Other variables used in the algorithm are of constant space, leading to an overall space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The other additional space used is for the sorting algorithm. The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pointers">Approach 3: Two Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another way to approach the problem is to recognize that if we could process the indices in such a way that we can easily compare their relative positions, it might help us avoid unnecessary comparisons.</p>
<p>We can notice that it would be helpful to know the maximum value from each index to the end of the array.  Given this information, we can easily check if the ramp condition is satisfied for any left index while iterating from the start of the array. Thus, we initialize <code>rightMax</code> where each element at index <code>i</code> stores the maximum value from index <code>i</code> to the last index. We populate this array in reverse order. Starting from the end of the <code>nums</code> array, we set the last element of <code>rightMax</code> to be equal to the last element of <code>nums</code>. For all previous indices, we store the maximum of the current value in <code>nums[i]</code> and the value at <code>rightMax[i + 1]</code>. This ensures that each index in <code>rightMax</code> contains the highest value from that index to the end of the original array.</p>
<p>With <code>rightMax</code> constructed, we can proceed with our two-pointer approach. We initialize one pointer (<code>left</code>) at the start of the array and another pointer (<code>right</code>) that we will move through the array. As we iterate:</p>
<ul>
<li>We check if the condition <span class="math inline">\(nums[left] \leq rightMax[right]\)</span> holds. If true, we calculate the ramp width as <code>right - left</code> and update our maximum width if this is the largest weâ€™ve seen.</li>
<li>If the condition is not satisfied, it means the value at <code>nums[left]</code> is too large to form a ramp with <code>rightMax[right]</code>, so we increment the <code>left</code> pointer to try and find a smaller value.</li>
</ul>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> as the size of the input vector <code>nums</code>.</li>
<li>Create a <code>rightMax</code> array of the same size to store the maximum values from the right side of <code>nums</code>.</li>
<li>Fill the <code>rightMax</code> array:
<ul>
<li>Set <code>rightMax[n - 1]</code> to <code>nums[n - 1]</code> (the last element).</li>
<li>Iterate backward from the second-to-last element to the first:
<ul>
<li>For each index <code>i</code>, set <code>rightMax[i]</code> to the maximum of <code>rightMax[i + 1]</code> and <code>nums[i]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize two pointers, <code>left</code> and <code>right</code>, both starting at 0, and a variable <code>maxWidth</code> initialized to 0.</li>
<li>Traverse the array using <code>left</code> and <code>right</code> pointers:
<ul>
<li>While <code>right</code> is less than <code>n</code>:
<ul>
<li>Move the <code>left</code> pointer forward while the current value at <code>nums[left]</code> exceeds the corresponding value in <code>rightMax[right]</code>.</li>
<li>Calculate the current width as <code>right - left</code> and update <code>maxWidth</code> to the maximum of <code>maxWidth</code> and the current width.</li>
<li>Increment the <code>right</code> pointer.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/CFRwxcEm/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm consists of two main parts. The first loop fills the <code>rightMax</code> array, which takes <span class="math inline">\(O(n)\)</span> time since it iterates through the <code>nums</code> array once. The second part uses a two-pointer technique to traverse the <code>nums</code> array and the <code>rightMax</code> array, where both pointers traverse the array at most <span class="math inline">\(n\)</span> times. Thus, the total time taken is linear in terms of the size of the input array, leading to an overall time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the additional storage used, which in this case is the <code>rightMax</code> array. This array also has a size of <span class="math inline">\(n\)</span>, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>. Other variables used (like <code>left</code>, <code>right</code>, and <code>maxWidth</code>) take constant space, <span class="math inline">\(O(1)\)</span>, but they do not contribute to the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-monotonic-stack">Approach 4: Monotonic Stack</h3>
<h4 id="intuition-3">Intuition</h4>
<p>We notice that for any element <span class="math inline">\(nums[i]\)</span>, we'd like to consider the indices of all elements <span class="math inline">\(nums[j]\)</span> preceding <span class="math inline">\(nums[i]\)</span> such that <span class="math inline">\(nums[j] < nums[i]\)</span>. We can efficiently find all these indices by maintaining a monotonic stack. The key observation is that this problem involves finding valid pairs where an earlier index has a smaller or equal value than a later index, making it a perfect candidate for a monotonic stack. This way, whenever we encounter a value in <span class="math inline">\(nums\)</span> that is greater than the element at the index in top of our stack, we can pop all the indices from the stack to find left indices that can form valid pairs.</p>
<p>As we iterate over the array, we push indices onto a stack only if the value at the current index is smaller than or equal to the value at the index on top of the stack. This ensures that the stack contains a list of potential starting points for ramps, in decreasing order of value. The key insight is that when we encounter a larger value, we begin popping indices from the stack. For each index popped, we calculate the ramp width formed with the current index and check if it exceeds the maximum width we have tracked. Since the values on the stack are always decreasing, popping an index means that we have found a ramp where the condition <span class="math inline">\(nums[i] \leq nums[j]\)</span> is satisfied.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/962/monotonic.json:1025,535!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>nums</code> array and create an empty stack <code>indicesStack</code>.</li>
<li>Iterate through the array from index 0 to <code>n-1</code>.
<ul>
<li>If <code>indicesStack</code> is empty or the value at the top index of the stack is greater than the current value <code>nums[i]</code>, push <code>i</code> onto the stack.</li>
<li>This ensures the stack contains indices in increasing order of their corresponding values in <code>nums</code>.</li>
</ul>
</li>
<li>Initialize <code>maxWidth</code> to 0.</li>
<li>Iterate through the array from index <code>n-1</code> down to 0.
<ul>
<li>While the stack is not empty and the value at the index on the top of the stack is less than or equal to <code>nums[j]</code>:</li>
<li>Update <code>maxWidth</code> to the maximum of its current value and the width calculated as <code>j - indicesStack.top()</code>.</li>
<li>Pop the index from the stack, as it has already been processed.</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/bUmS9o8r/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates through the <code>nums</code> array once, pushing indices onto the stack. This operation takes <span class="math inline">\(O(n)\)</span> time in the worst case since each index is pushed at most once. The second loop also iterates through the <code>nums</code> array, but each index is popped from the stack at most once. Hence, both loops combined result in a total of <span class="math inline">\(O(n)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity arises primarily from the stack that holds indices. In the worst case, where all elements are in strictly increasing order, all <span class="math inline">\(n\)</span> indices could be pushed onto the stack. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span> in this scenario.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-of-minimum-for-every-window-size3453/1" target="_blank" rel="noopener noreferrer">Max of min for every window size</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">sliding-window</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array of integers <strong>arr[]</strong>, the task is to find the <strong>maximum of the minimum values</strong> for every possible window size in the array, where the window size ranges from <strong>1 to arr.size()</strong>.</span></p>
<p><span style="font-size: 14pt;">More formally, for each window size <strong>k</strong>, determine the smallest element in all windows of size <strong>k</strong>, and then find the largest value among these minimums where 1&lt;=k&lt;=arr.size().</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [10, 20, 30, 50, 10, 70, 30]
<strong>Output: </strong>[70, 30, 20, 10, 10, 10, 10] <strong>
Explanation: 
</strong>1. First element in output indicates maximum of minimums of all </span><span style="font-size: 18px;">windows of size 1.</span><span style="font-size: 18px;"> Minimums of windows of size 1 are [10], [20], [30], [50], [10], [</span><span style="font-size: 18px;">70] and [30]. Maximum of these minimums is 70. </span>
<span style="font-size: 18px;">2. Second element in output indicates maximum of minimums of all </span><span style="font-size: 18px;">windows of size 2.</span><span style="font-size: 18px;"> Minimums of windows of size 2 are [10], [20], [30], [10], [10], </span><span style="font-size: 18px;">and [30]. Maximum of these minimums is 30. <br /></span><span style="font-size: 18px;">3. Third element in output indicates maximum of minimums of all </span><span style="font-size: 18px;">windows of size 3. </span><span style="font-size: 18px;">Minimums of windows of size 3 are [10], [20], [10], [10] and [10].</span><span style="font-size: 18px;"> Maximum of these minimums is 20. <br /></span><span style="font-size: 18px;">Similarly other elements of output are computed.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [10, 20, 30]
<strong>Output: </strong>[30, 20, 10]<strong>
Explanation: </strong>First element in output indicates maximum of minimums of all </span><span style="font-size: 18px;">windows of size 1. Minimums of windows of size 1 are [10] , [20] , [30]. Maximum of these minimums are 30 and similarly other outputs can be computed</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>5</sup><br />1 &lt;= arr[i] &lt;= 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/max-rectangle/1" target="_blank" rel="noopener noreferrer">Max  rectangle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary matrix <strong>mat[][] </strong>of size <strong>n * m</strong>. Find the maximum area of a rectangle formed only of <strong>1s</strong> in the given matrix. </span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">mat[][] = [[0, 1, 1, 0],
                [1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, 1, 0, 0]]
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">8</span><strong style="font-size: 18px;">
Explanation: </strong><span style="font-size: 18px;">The largest rectangle with only 1&rsquo;s is from (1, 0) to (2, 3) which is
[1, 1, 1, 1]
[1, 1, 1, 1]
and area is 4 *2 = 8</span></span><span style="font-size: 18px;">.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat[][] = [[0, 1, 1],
                [1, 1, 1],
                [0, 1, 1]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The largest rectangle with only 1&rsquo;s is from (0, 1) to (2, 2) which is
[1, 1]
[1, 1]
[1, 1]</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;= mat.size(), mat[0].size()&lt;=1000<br />0&lt;=mat[][]&lt;=1<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/max-sum-in-sub-arrays0824/1" target="_blank" rel="noopener noreferrer">Max Score from Subarray Mins</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong>, with 0-based indexing, select any two indexes, <strong>i</strong> and <strong>j</strong> such that <strong>i &lt; j</strong>. From the subarray <strong>arr[i...j]</strong>, select the <strong>smallest</strong> and <strong>second smallest&nbsp;</strong>numbers and add them, you will get the <strong>score </strong>for that subarray. Return the <strong>maximum </strong>possible score<strong> </strong>across all the subarrays of array <strong>arr[]</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input :</strong> arr[] = [4, 3, 1, 5, 6]
<strong>Output :</strong> 11
<strong>Explanation :</strong> Subarrays with smallest and second smallest are:- [4, 3] smallest = 3,second smallest = 4
[4, 3, 1] smallest = 1, second smallest = 3
[4, 3, 1, 5] smallest = 1, second smallest = 3
[4, 3, 1, 5, 6] smallest = 1, second smallest = 3
[3, 1] smallest = 1, second smallest = 3
[3, 1, 5] smallest = 1, second smallest = 3
[3, 1, 5, 6] smallest = 1, second smallest = 3
[1, 5] smallest = 1, second smallest = 5
[1, 5, 6] smallest = 1, second smallest = 5
[5, 6] smallest = 5, second smallest = 6
Maximum sum among all above choices is, 5 + 6 = 11.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input :</strong> arr[] = [5, 4, 3, 1, 6] 
<strong>Output :</strong> 9</span></pre>
<p><span style="font-size: 14pt;"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Auxiliary Space:</strong> O(1)</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />2 &le; arr.size &le; 10<sup>5</sup><br />1 &le; arr[i] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-additions-to-make-valid-string/description" target="_blank" rel="noopener noreferrer">Minimum Additions to Make Valid String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>word</code> to which you can insert letters &quot;a&quot;, &quot;b&quot; or &quot;c&quot; anywhere and any number of times, return <em>the minimum number of letters that must be inserted so that <code>word</code> becomes <strong>valid</strong>.</em></p>

<p>A string is called <strong>valid </strong>if it can be formed by concatenating the string &quot;abc&quot; several times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;b&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Insert the letter &quot;a&quot; right before &quot;b&quot;, and the letter &quot;c&quot; right next to &quot;b&quot; to obtain the valid string &quot;<strong>a</strong>b<strong>c</strong>&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;aaa&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> Insert letters &quot;b&quot; and &quot;c&quot; next to each &quot;a&quot; to obtain the valid string &quot;a<strong>bc</strong>a<strong>bc</strong>a<strong>bc</strong>&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abc&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> word is already valid. No modifications are needed. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 50</code></li>
	<li><code>word</code> consists of letters &quot;a&quot;, &quot;b&quot;&nbsp;and &quot;c&quot; only.&nbsp;</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-add-to-make-parentheses-valid/description" target="_blank" rel="noopener noreferrer">Minimum Add to Make Parentheses Valid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A parentheses string is valid if and only if:</p>

<ul>
	<li>It is the empty string,</li>
	<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li>
	<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li>
</ul>

<p>You are given a parentheses string <code>s</code>. In one move, you can insert a parenthesis at any position of the string.</p>

<ul>
	<li>For example, if <code>s = &quot;()))&quot;</code>, you can insert an opening parenthesis to be <code>&quot;(<strong>(</strong>)))&quot;</code> or a closing parenthesis to be <code>&quot;())<strong>)</strong>)&quot;</code>.</li>
</ul>

<p>Return <em>the minimum number of moves required to make </em><code>s</code><em> valid</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;())&quot;
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(((&quot;
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s[i]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-open-bracket-counter">Approach: Open Bracket Counter</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a string <code>s</code> that consists only of open (<code>(</code>) and close (<code>)</code>) parentheses. This string may not be valid, meaning that an open parenthesis might not have a corresponding close parenthesis, or vice versa. Our goal is to determine the minimum number of operations required to make the string valid. In each operation, we can add either an open or close parenthesis at any position in the string.</p>
<p>The key observation is to match as many parentheses as possible to minimize the number of additional parentheses needed. We will iterate over the string from left to right and track the parentheses as we encounter them. Open parentheses should appear before their corresponding close parentheses. We will keep a count of open parentheses, and when we encounter a close parenthesis, we check if there is an unmatched open parenthesis available. If there is, we match them by reducing the open parenthesis count.</p>
<p>If we encounter a close parenthesis but no open parenthesis is available to match it, this means that we need to add an open parenthesis to balance the string, so we increment the <code>minAddsRequired</code> counter. After iterating through the entire string, there may still be unmatched open parentheses left. In this case, we need to add a close parenthesis for each remaining unmatched open parenthesis. Therefore, the total number of operations required to make the string valid is the sum of <code>minAddsRequired</code> and the remaining unmatched open parentheses.</p>
<p>In problems involving parentheses matching, a stack is often useful for storing open parentheses, and when encountering a close parenthesis, we can check if a matching open parenthesis exists at the top of the stack. Although we could use a stack in this problem to find the remaining open parentheses by checking its size, a simpler approach is possible here. Since there is only one type of parenthesis, we can efficiently handle the matching process with a counter.</p>
<p>While the stack-based approach is more generic and preferred for cases involving multiple types of parentheses, it is not necessary here. We can use a counter variable, <code>openBrackets</code>, to track the number of unmatched open parentheses. We increment it for every open parenthesis and decrement it when encountering a close parenthesis. By the end, this counter will reflect the number of unmatched open parentheses.</p>
<p><img src="../Figures/921/921-Steps-Demonstration.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create two variables: <code>openBrackets</code> (to track unmatched open brackets) and <code>minAddsRequired</code> both initialized to <code>0</code>.</li>
<li>Loop through each character in the string <code>s</code>:
<ul>
<li>If the current character is an open bracket <code>(</code>, increment the <code>openBrackets</code> counter, as it is unmatched for now.</li>
<li>If the current character is a close bracket <code>)</code>:
<ul>
<li>Check if there are any unmatched open brackets (<code>openBrackets</code> &gt; 0).</li>
<li>If an unmatched open bracket exists, decrement <code>openBrackets</code> to indicate that a matching pair has been formed.</li>
<li>If no unmatched open brackets are available, increment <code>minAddsRequired</code> as we need to add an open bracket to make this close bracket valid.</li>
</ul>
</li>
</ul>
</li>
<li>The total number of additions required will be the sum of <code>minAddsRequired</code> and any remaining unmatched open brackets (<code>openBrackets</code>). Return this value as the result.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8cBrGdG9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of characters in the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We iterate over each character in the string <code>s</code> once. For each character, we either increment, decrement, or compare a counter. These operations take constant time. Therefore, the overall time complexity is linear, <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use only two variables, <code>openBrackets</code> and <code>minAddsRequired</code>, to count unmatched brackets. These variables require constant space, and we do not use any extra data structures that depend on the input size. Thus, the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Change the Final Value of Expression</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>valid</strong> boolean expression as a string <code>expression</code> consisting of the characters <code>&#39;1&#39;</code>,<code>&#39;0&#39;</code>,<code>&#39;&amp;&#39;</code> (bitwise <strong>AND</strong> operator),<code>&#39;|&#39;</code> (bitwise <strong>OR</strong> operator),<code>&#39;(&#39;</code>, and <code>&#39;)&#39;</code>.</p>

<ul>
	<li>For example, <code>&quot;()1|1&quot;</code> and <code>&quot;(1)&amp;()&quot;</code> are <strong>not valid</strong> while <code>&quot;1&quot;</code>, <code>&quot;(((1))|(0))&quot;</code>, and <code>&quot;1|(0&amp;(1))&quot;</code> are <strong>valid</strong> expressions.</li>
</ul>

<p>Return<em> the <strong>minimum cost</strong> to change the final value of the expression</em>.</p>

<ul>
	<li>For example, if <code>expression = &quot;1|1|(0&amp;0)&amp;1&quot;</code>, its <strong>value</strong> is <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code>. We want to apply operations so that the<strong> new</strong> expression evaluates to <code>0</code>.</li>
</ul>

<p>The <strong>cost</strong> of changing the final value of an expression is the <strong>number of operations</strong> performed on the expression. The types of <strong>operations</strong> are described as follows:</p>

<ul>
	<li>Turn a <code>&#39;1&#39;</code> into a <code>&#39;0&#39;</code>.</li>
	<li>Turn a <code>&#39;0&#39;</code> into a <code>&#39;1&#39;</code>.</li>
	<li>Turn a <code>&#39;&amp;&#39;</code> into a <code>&#39;|&#39;</code>.</li>
	<li>Turn a <code>&#39;|&#39;</code> into a <code>&#39;&amp;&#39;</code>.</li>
</ul>

<p><strong>Note:</strong> <code>&#39;&amp;&#39;</code> does <strong>not</strong> take precedence over <code>&#39;|&#39;</code> in the <strong>order of calculation</strong>. Evaluate parentheses <strong>first</strong>, then in <strong>left-to-right</strong> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;1&amp;(0|1)&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can turn &quot;1&amp;(0<u><strong>|</strong></u>1)&quot; into &quot;1&amp;(0<u><strong>&amp;</strong></u>1)&quot; by changing the &#39;|&#39; to a &#39;&amp;&#39; using 1 operation.
The new expression evaluates to 0. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;(0&amp;0)&amp;(0&amp;0&amp;0)&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can turn &quot;(0<u><strong>&amp;0</strong></u>)<strong><u>&amp;</u></strong>(0&amp;0&amp;0)&quot; into &quot;(0<u><strong>|1</strong></u>)<u><strong>|</strong></u>(0&amp;0&amp;0)&quot; using 3 operations.
The new expression evaluates to 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;(0|(1|0&amp;1))&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can turn &quot;(0|(<u><strong>1</strong></u>|0&amp;1))&quot; into &quot;(0|(<u><strong>0</strong></u>|0&amp;1))&quot; using 1 operation.
The new expression evaluates to 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 10<sup>5</sup></code></li>
	<li><code>expression</code>&nbsp;only contains&nbsp;<code>&#39;1&#39;</code>,<code>&#39;0&#39;</code>,<code>&#39;&amp;&#39;</code>,<code>&#39;|&#39;</code>,<code>&#39;(&#39;</code>, and&nbsp;<code>&#39;)&#39;</code></li>
	<li>All parentheses&nbsp;are properly matched.</li>
	<li>There will be no empty parentheses (i.e:&nbsp;<code>&quot;()&quot;</code>&nbsp;is not a substring of&nbsp;<code>expression</code>).</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-tree-from-leaf-values/description" target="_blank" rel="noopener noreferrer">Minimum Cost Tree From Leaf Values</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>arr</code> of positive integers, consider all binary trees such that:</p>

<ul>
	<li>Each node has either <code>0</code> or <code>2</code> children;</li>
	<li>The values of <code>arr</code> correspond to the values of each <strong>leaf</strong> in an in-order traversal of the tree.</li>
	<li>The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.</li>
</ul>

<p>Among all possible binary trees considered, return <em>the smallest possible sum of the values of each non-leaf node</em>. It is guaranteed this sum fits into a <strong>32-bit</strong> integer.</p>

<p>A node is a <strong>leaf</strong> if and only if it has zero children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg" style="width: 500px; height: 169px;" />
<pre>
<strong>Input:</strong> arr = [6,2,4]
<strong>Output:</strong> 32
<strong>Explanation:</strong> There are two possible trees shown.
The first has a non-leaf node sum 36, and the second has non-leaf node sum 32.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg" style="width: 224px; height: 145px;" />
<pre>
<strong>Input:</strong> arr = [4,11]
<strong>Output:</strong> 44
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= arr.length &lt;= 40</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 15</code></li>
	<li>It is guaranteed that the answer fits into a <strong>32-bit</strong> signed integer (i.e., it is less than 2<sup>31</sup>).</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-deletions-to-make-array-beautiful/description" target="_blank" rel="noopener noreferrer">Minimum Deletions to Make Array Beautiful</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. The array <code>nums</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>nums.length</code> is even.</li>
	<li><code>nums[i] != nums[i + 1]</code> for all <code>i % 2 == 0</code>.</li>
</ul>

<p>Note that an empty array is considered beautiful.</p>

<p>You can delete any number of elements from <code>nums</code>. When you delete an element, all the elements to the right of the deleted element will be <strong>shifted one unit to the left</strong> to fill the gap created and all the elements to the left of the deleted element will remain <strong>unchanged</strong>.</p>

<p>Return <em>the <strong>minimum</strong> number of elements to delete from </em><code>nums</code><em> to make it </em><em>beautiful.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,3,5]
<strong>Output:</strong> 1
<strong>Explanation:</strong> You can delete either <code>nums[0]</code> or <code>nums[1]</code> to make <code>nums</code> = [1,2,3,5] which is beautiful. It can be proven you need at least 1 deletion to make <code>nums</code> beautiful.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,2,3,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can delete <code>nums[0]</code> and <code>nums[5]</code> to make nums = [1,2,2,3] which is beautiful. It can be proven you need at least 2 deletions to make nums beautiful.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-deletions-to-make-string-balanced/description" target="_blank" rel="noopener noreferrer">Minimum Deletions to Make String Balanced</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting only of characters <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>â€‹â€‹â€‹â€‹.</p>

<p>You can delete any number of characters in <code>s</code> to make <code>s</code> <strong>balanced</strong>. <code>s</code> is <strong>balanced</strong> if there is no pair of indices <code>(i,j)</code> such that <code>i &lt; j</code> and <code>s[i] = &#39;b&#39;</code> and <code>s[j]= &#39;a&#39;</code>.</p>

<p>Return <em>the <strong>minimum</strong> number of deletions needed to make </em><code>s</code><em> <strong>balanced</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aababbab&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can either:
Delete the characters at 0-indexed positions 2 and 6 (&quot;aa<u>b</u>abb<u>a</u>b&quot; -&gt; &quot;aaabbb&quot;), or
Delete the characters at 0-indexed positions 3 and 6 (&quot;aab<u>a</u>bb<u>a</u>b&quot; -&gt; &quot;aabbbb&quot;).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bbaaaaabb&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The only solution is to delete the first two characters.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is&nbsp;<code>&#39;a&#39;</code> or <code>&#39;b&#39;</code>â€‹â€‹.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> containing only two characters: <code>'a'</code> and <code>'b'</code>. Our goal is to make the string &quot;balanced&quot; by removing any number of characters in the string. A string is considered &quot;balanced&quot; if there are no occurrences where a <code>'b'</code> is followed by an <code>'a'</code> at any point later in the string.</p>
<p>We have to find the minimum number of deletions required to balance the string. In other words, after all the deletions, when reading the string from left to right, if you see the character <code>'b'</code>, there should not be any <code>'a'</code> following it.</p>
<hr />
<h3 id="approach-1-three-pass-count-method">Approach 1: Three-Pass Count Method</h3>
<h4 id="intuition">Intuition</h4>
<p>Each position in the string can be a potential dividing point such that all the characters to the left of that character are <code>'a'</code>s and all the characters to the right are <code>'b'</code>s. The idea is to find the dividing point that minimizes the number of deletions. For example, in the string <code>s = aabbabba</code>, if the dividing point is located at index <code>2</code> (0-indexed), two deletions are required to balance <code>s</code>. On the other hand, if the dividing point is located at index <code>5</code>, three deletions are required to balance <code>s</code>.</p>
<p>To implement this, we use three passes through the string. In the first pass, we count and store the number of <code>'b'</code>s that occur to the left of each position. In the second pass, we count and store the number of <code>'a'</code>s that occur to the right of each position.</p>
<p>We can balance the string around a dividing point by deleting all <code>'b'</code>s to the left and all <code>'a'</code>s to the right of the point. Thus, in the third pass, we calculate the minimum deletions required at each position by adding the number of <code>'a'</code>s to the right and the number of <code>'b'</code>s to the left.</p>
<p>By checking every position, we ensure we find the optimal dividing line that minimizes the number of deletions.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize arrays <code>count_a</code> and <code>count_b</code> of size <code>n</code> to store counts of <code>'a'</code>s and <code>'b'</code>s.</li>
<li>Traverse the string from left to right:
<ul>
<li>Update <code>count_b[i]</code> with the cumulative count of <code>'b'</code>s encountered so far.</li>
</ul>
</li>
<li>Traverse the string from right to left:
<ul>
<li>Update <code>count_a[i]</code> with the cumulative count of <code>'a'</code>s encountered so far.</li>
</ul>
</li>
<li>Traverse the string from left to right:
<ul>
<li>Compute the minimum deletions needed as <code>count_a[i] + count_b[i]</code>.</li>
</ul>
</li>
<li>Return the minimum value computed.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ESN2Q7AP/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs three linear passes over the string.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use two arrays of size <code>n</code> to store counts, resulting in linear space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-combined-pass-method">Approach 2: Combined Pass Method</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we traversed the string twice to count and store the number of <code>'a'</code>s after and the number of <code>'b'</code>s before for each position. We can improve efficiency by merging the two passes into a single pass.</p>
<p>Although we still need to count the occurrences of <code>'a'</code>s and <code>'b'</code>s, we can optimize our process by avoiding storing the counts of <code>'b'</code>s to the left at every position. Instead, we count the <code>'a'</code>s while traversing the string from right to left. Then, during the second pass, we count the <code>'b'</code>s and simultaneously calculate the minimum deletions required. We achieve this by adding the current number of <code>'b'</code>s encountered to the pre-stored count of <code>'a'</code>s.</p>
<p>This optimization reduces our passes from three to two, which is an improvement in time efficiency. However, we are still using <span class="math inline">\(O(n)\)</span> extra space to store the <code>'a'</code> counts.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize array <code>count_a</code> of size <code>n</code> to store counts of <code>'a'</code>s from the right.</li>
<li>Traverse the string from right to left:
<ul>
<li>Update <code>count_a[i]</code> with the cumulative count of <code>'a'</code>s encountered so far.</li>
</ul>
</li>
<li>Initialize <code>b_count</code> to 0.</li>
<li>Traverse the string from left to right:
<ul>
<li>Compute the minimum deletions needed as <code>count_a[i] + b_count</code>.</li>
<li>Update <code>b_count</code> with the count of <code>'b'</code>s encountered so far.</li>
</ul>
</li>
<li>Return the minimum value computed.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/dYvWkWdm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs two linear passes over the string.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use one array of size <code>n</code> to store counts, resulting in linear space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-variable-method">Approach 3: Two-Variable Method</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can optimize our previous approach even further by using two variables to track the total counts of <code>'a'</code>s and <code>'b'</code>s. In the first pass, we traverse the string from left to right to count all occurrences of <code>'a'</code>. Then, in the second pass, we maintain and update these counts as we move through the string.</p>
<p>As we iterate through the string in the second pass, we keep track of the current number of <code>'b'</code>s encountered to the left and the remaining number of <code>'a'</code>s to the right. At each position, we calculate the minimum deletions required by adding the current count of <code>'b'</code>s to the left and the remaining count of <code>'a'</code>s to the right.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>a_count</code> to the total number of <code>'a'</code>s in the string.</li>
<li>Initialize <code>b_count</code> to 0.</li>
<li>Initialize <code>min_deletions</code> to the length of the string.</li>
<li>Traverse the string from left to right:
<ul>
<li>If the current character is <code>'a'</code>, decrement <code>a_count</code>.</li>
<li>Compute the minimum deletions needed as <code>a_count + b_count</code>.</li>
<li>If the current character is <code>'b'</code>, increment <code>b_count</code>.</li>
</ul>
</li>
<li>Return the minimum value computed.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/HSAh3Cok/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs a single linear pass over the string.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use constant space auxiliary variables, resulting in constant space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-using-stack-one-pass">Approach 4: Using stack (one pass)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>What if we focus on removing &quot;ba&quot; pairs? These pairs unbalance the string because an <code>'a'</code> character is to the right of a <code>'b'</code> character. By leveraging a stack, we can efficiently count and remove these pairs in a single traversal of the string.</p>
<p>To implement this approach, we traverse the string and push each character onto the stack. When we encounter a &quot;ba&quot; pairâ€”where an <code>'a'</code> is on top of the stack and a <code>'b'</code> is currently being processedâ€”we pop the <code>'a'</code> from the stack, effectively &quot;removing&quot; this out-of-order pair. We keep a count of such removals throughout this process.</p>
<p>However, in the worst case (when no deletions are needed), it still uses <span class="math inline">\(O(n)\)</span> space for the stack.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize an empty stack <code>char_stack</code> and <code>delete_count</code> to 0.</li>
<li>Traverse the string from left to right:
<ul>
<li>If the stack is not empty and the top of the stack is <code>'b'</code> and the current character is <code>'a'</code>, pop the stack and increment <code>delete_count</code>.</li>
<li>Otherwise, push the current character onto the stack.</li>
</ul>
</li>
<li>Return <code>delete_count</code>.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1653/approach4.json:805,580!?!</p>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/3Ga2ZcWb/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs a single linear pass over the string, with stack operations (push and pop) taking <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a stack that may grow up to the size of the string.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-using-dp-one-pass">Approach 5: Using DP (One Pass)</h3>
<h4 id="intuition-4">Intuition</h4>
<p>Notice that we can use the solution for a smaller subproblem to solve the bigger problem. For example, if we knew how many deletions are required to balance the first 8 characters of the string <code>s</code>, we can use this information to find how many deletions are required to balance the first 9 characters of <code>s</code>.</p>
<p>Thus, the problem has an optimal substructure, meaning the solution for the entire string can be built from solutions to its prefixes. This leads us to consider a dynamic programming approach.</p>
<p>Let's define the <code>dp</code> array such that, <code>dp[i]</code> is the minimum number of deletions required to balance the substring <code>s[0 ... i - 1]</code>. We initialize the first element of the array based on whether the first character of the substring is <code>'a'</code> or <code>'b'</code>. As we traverse the string, we update the dp array by considering the current character and the state of the previous elements.</p>
<p>The key to this approach is the DP formula used when we encounter an <code>'a'</code> character:</p>
<pre><code>dp[i + 1] = min(dp[i] + 1, b_count)
</code></pre>
<p>This formula encapsulates two possible actions:</p>
<ol>
<li>
<p>&quot;Remove <code>'a'</code>&quot; case (<code>dp[i] + 1</code>):<br />
This represents the option of deleting the current <code>'a'</code>. If we choose to remove it, we need one more deletion than what was required for the previous substring (<code>dp[i]</code>), hence <code>dp[i] + 1</code>.</p>
</li>
<li>
<p>&quot;Keep <code>'a'</code>&quot; case (<code>b_count</code>):<br />
This represents the option of keeping the current <code>'a'</code> and removing all the <code>'b'</code>s that came before it. The number of <code>'b'</code>s we've seen so far is <code>b_count</code>, so this is the number of deletions needed if we keep this <code>'a'</code>.</p>
</li>
</ol>
<p>We consider these two cases to balance the string:</p>
<ul>
<li>By removing <code>'a'</code>, we're reducing the number of <code>'a'</code>s to match the existing <code>'b'</code>s.</li>
<li>By keeping <code>'a'</code> and removing all previous <code>'b'</code>s, we're ensuring all <code>'a'</code>s come before <code>'b'</code>s.</li>
</ul>
<p>We take the minimum of these two options because we want the least number of deletions. This approach helps balance the string because at each step, we're either making the current prefix end with <code>'b'</code> (by removing <code>'a'</code>) or making it end with <code>'a'</code> (by removing all previous <code>'b'</code>s). Both of these actions move us towards a balanced string where all <code>'a'</code>s come before all <code>'b'</code>s.</p>
<p>The DP approach allows us to solve the problem in a single pass, which is efficient in time. However, it requires <span class="math inline">\(O(n)\)</span> space to store the <code>dp</code> array.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>Initialize array <code>dp</code> of size <code>n + 1</code> to 0, and <code>b_count</code> to 0.</li>
<li>Traverse the string from left to right:
<ul>
<li>If the current character is <code>'b'</code>, update <code>dp[i + 1]</code> as <code>dp[i]</code> and increment <code>b_count</code>.</li>
<li>If the current character is <code>'a'</code>, update <code>dp[i + 1]</code> as <code>min(dp[i] + 1, b_count)</code>.</li>
</ul>
</li>
<li>Return <code>dp[n]</code>.</li>
</ul>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/Vrb5e3Qf/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs a single linear pass over the string with updates to the <code>dp</code> array.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses requires additional space for the <code>dp</code> array.</p>
</li>
</ul>
<hr />
<h3 id="approach-6-optimized-dp">Approach 6: Optimized DP</h3>
<h4 id="intuition-5">Intuition</h4>
<p>Reviewing our dynamic programming (DP) solution, we observe that calculating the current state only requires knowledge of the previous state and a running count of <code>'b'</code>s. This insight indicates that storing the entire DP array is unnecessary. Instead, we can simplify the approach by using a single variable to keep track of the current minimum deletions and update the counts as we process the string.</p>
<p>To implement this optimization, we maintain two variables: one to track the current minimum deletions and another to count the number of <code>'b'</code>s encountered up to the current position. As we iterate through each character in the string, we update these variables accordingly. By doing so, we streamline our solution and reduce both time and space complexity, focusing only on the essential information needed to compute the minimum deletions efficiently.</p>
<h4 id="algorithm-5">Algorithm</h4>
<ul>
<li>Initialize <code>min_deletions</code> to 0 and <code>b_count</code> to 0.</li>
<li>Traverse the string from left to right:
<ul>
<li>If the current character is <code>'b'</code>, increment <code>b_count</code>.</li>
<li>If the current character is <code>'a'</code>, update <code>min_deletions</code> as <code>min(min_deletions + 1, b_count)</code>.</li>
</ul>
</li>
<li>Return <code>min_deletions</code>.</li>
</ul>
<h4 id="implementation-5">Implementation</h4>
<p><a href="https://leetcode.com/playground/npwze8do/shared">code</a></p>
<h4 id="complexity-analysis-5">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs a single linear pass over the string.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of additional space for <code>min_deletions</code> and <code>b_count</code>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/description" target="_blank" rel="noopener noreferrer">Minimum Insertions to Balance a Parentheses String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a parentheses string <code>s</code> containing only the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. A parentheses string is <strong>balanced</strong> if:</p>

<ul>
	<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>
	<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>
</ul>

<p>In other words, we treat <code>&#39;(&#39;</code> as an opening parenthesis and <code>&#39;))&#39;</code> as a closing parenthesis.</p>

<ul>
	<li>For example, <code>&quot;())&quot;</code>, <code>&quot;())(())))&quot;</code> and <code>&quot;(())())))&quot;</code> are balanced, <code>&quot;)()&quot;</code>, <code>&quot;()))&quot;</code> and <code>&quot;(()))&quot;</code> are not balanced.</li>
</ul>

<p>You can insert the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> at any position of the string to balance it if needed.</p>

<p>Return <em>the minimum number of insertions</em> needed to make <code>s</code> balanced.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(()))&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The second &#39;(&#39; has two matching &#39;))&#39;, but the first &#39;(&#39; has only &#39;)&#39; matching. We need to add one more &#39;)&#39; at the end of the string to be &quot;(())))&quot; which is balanced.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;())&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> The string is already balanced.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;))())(&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> Add &#39;(&#39; to match the first &#39;))&#39;, Add &#39;))&#39; to match the last &#39;(&#39;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/description" target="_blank" rel="noopener noreferrer">Minimum Number of Increments on Subarrays to Form a Target Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>target</code>. You have an integer array <code>initial</code> of the same size as <code>target</code> with all elements initially zeros.</p>

<p>In one operation you can choose <strong>any</strong> subarray from <code>initial</code> and increment each value by one.</p>

<p>Return <em>the minimum number of operations to form a </em><code>target</code><em> array from </em><code>initial</code>.</p>

<p>The test cases are generated so that the answer fits in a 32-bit integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = [1,2,3,2,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We need at least 3 operations to form the target array from the initial array.
[<strong><u>0,0,0,0,0</u></strong>] increment 1 from index 0 to 4 (inclusive).
[1,<strong><u>1,1,1</u></strong>,1] increment 1 from index 1 to 3 (inclusive).
[1,2,<strong><u>2</u></strong>,2,1] increment 1 at index 2.
[1,2,3,2,1] target array is formed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = [3,1,1,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> [<strong><u>0,0,0,0</u></strong>] -&gt; [1,1,1,<strong><u>1</u></strong>] -&gt; [<strong><u>1</u></strong>,1,1,2] -&gt; [<strong><u>2</u></strong>,1,1,2] -&gt; [3,1,1,2]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> target = [3,1,5,4,2]
<strong>Output:</strong> 7
<strong>Explanation:</strong> [<strong><u>0,0,0,0,0</u></strong>] -&gt; [<strong><u>1</u></strong>,1,1,1,1] -&gt; [<strong><u>2</u></strong>,1,1,1,1] -&gt; [3,1,<strong><u>1,1,1</u></strong>] -&gt; [3,1,<strong><u>2,2</u></strong>,2] -&gt; [3,1,<strong><u>3,3</u></strong>,2] -&gt; [3,1,<strong><u>4</u></strong>,4,2] -&gt; [3,1,5,4,2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= target.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= target[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/description" target="_blank" rel="noopener noreferrer">Minimum Number of Swaps to Make the String Balanced</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code> of <strong>even</strong> length <code>n</code>. The string consists of <strong>exactly</strong> <code>n / 2</code> opening brackets <code>&#39;[&#39;</code> and <code>n / 2</code> closing brackets <code>&#39;]&#39;</code>.</p>

<p>A string is called <strong>balanced</strong> if and only if:</p>

<ul>
	<li>It is the empty string, or</li>
	<li>It can be written as <code>AB</code>, where both <code>A</code> and <code>B</code> are <strong>balanced</strong> strings, or</li>
	<li>It can be written as <code>[C]</code>, where <code>C</code> is a <strong>balanced</strong> string.</li>
</ul>

<p>You may swap the brackets at <strong>any</strong> two indices <strong>any</strong> number of times.</p>

<p>Return <em>the <strong>minimum</strong> number of swaps to make </em><code>s</code> <em><strong>balanced</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;][][&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> You can make the string balanced by swapping index 0 with index 3.
The resulting string is &quot;[[]]&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;]]][[[&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can do the following to make the string balanced:
- Swap index 0 with index 4. s = &quot;[]][][&quot;.
- Swap index 1 with index 5. s = &quot;[[][]]&quot;.
The resulting string is &quot;[[][]]&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;[]&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> The string is already balanced.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == s.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>6</sup></code></li>
	<li><code>n</code> is even.</li>
	<li><code>s[i]</code> is either <code>&#39;[&#39; </code>or <code>&#39;]&#39;</code>.</li>
	<li>The number of opening brackets <code>&#39;[&#39;</code> equals <code>n / 2</code>, and the number of closing brackets <code>&#39;]&#39;</code> equals <code>n / 2</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a 0-indexed string <code>s</code> of even length <code>n</code> made up of <code>n/2</code> opening brackets <code>[</code> and <code>n/2</code> closing brackets <code>]</code>. Our task is to return the minimum number of swaps to make the string balanced.</p>
<p>Balanced parentheses mean that every opening bracket <code>[</code> has a matching closing bracket <code>]</code> in the correct order. Unbalanced parentheses occur when there are more closing brackets <code>]</code> than opening brackets <code>[</code> at some point in the string.</p>
<p>There are two key points to keep in mind:</p>
<ol>
<li>Swapping balanced brackets won't help. If you swap characters in a balanced pair like <code>[]</code>, it becomes <code>][</code>, which makes the string unbalanced. So, this type of swap increases the problem instead of solving it.</li>
<li>Swapping unbalanced brackets can fix the string. If a closing bracket <code>]</code> appears before its matching opening bracket <code>[</code>, a swap between an unbalanced <code>]</code> and an unbalanced <code>[</code> will balance one pair.</li>
</ol>
<p>What is the maximum number of brackets that you can balance with a single swap? The answer is 2 for all parentheses of the form <code>][</code>. Therefore, the optimal approach is to swap unbalanced parentheses with each other. Since 2 unbalanced parentheses are made balanced with a single swap, the total number of swaps to balance are given by <code>unbalanced / 2</code>.</p>
<p>Let's understand this with an example:</p>
<p>For the string <code>]]][[[</code>,</p>
<p>There are total 3 mismatches in the string. Now, we need to swap the <code>]</code> and <code>[</code> at index <code>0</code> and <code>5</code> respectively.</p>
<p>The string is now given by <code>[]][[]</code>. There is 1 mismatch in the string. So, swap <code>]</code> and <code>[</code> at index <code>2</code> and <code>3</code> respectively. This swap reduced exactly 2 mismatches.</p>
<p>The string is balanced and given by <code>[][][]</code>. Therefore, it requires exactly 2 swaps to balance the string.</p>
<p>To solve the problem, we can use a stack to keep track of unmatched opening brackets <code>[</code> as we move through the string. Each time we find a closing bracket <code>]</code>, we check if thereâ€™s an unmatched opening bracket <code>[</code> on the stack. If there is, we remove it, as weâ€™ve found a match and balanced the pair. If the stack is empty when we encounter a closing bracket <code>]</code>, this bracket is unbalanced.</p>
<p>We count how many unbalanced closing brackets <code>]</code> we find. After traversing the string, the number of unbalanced <code>]</code> brackets tells us how many swaps are needed. Each swap fixes two bracketsâ€”one unbalanced <code>[</code> and one unbalanced <code>]</code>. So, the minimum number of swaps is half the total number of unbalanced closing brackets.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a <code>stack</code> to keep track of unmatched opening brackets <code>[</code> and an integer <code>unbalanced</code> to count unbalanced closing brackets <code>]</code>.</li>
<li>Traverse the string <code>s</code> character by character:
<ul>
<li>If the current character is an opening bracket <code>[</code>, push it onto the <code>stack</code>.</li>
<li>If the current character is a closing bracket <code>]</code>:
<ul>
<li>Check if the <code>stack</code> is not empty:
<ul>
<li>If it is not empty, pop the top element from the <code>stack</code>.</li>
<li>If the <code>stack</code> is empty, increment the <code>unbalanced</code> counter.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the result as the minimum number of swaps required to balance the string. The minimum number of swaps is calculated as <code>(unbalanced + 1) / 2</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JnbKuFHN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through each character of the string exactly once in the loop. Each push or pop operation on the stack takes constant time <span class="math inline">\(O(1)\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, we may end up pushing all opening brackets <code>[</code> into the stack, so the space used by the stack can go up to <span class="math inline">\(O(n)\)</span>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-space-optimized-stack">Approach 2: Space-Optimized Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We only need to count the unbalanced opening brackets <code>[</code> that don't have matching closing brackets <code>]</code>. This helps us figure out how many swaps are needed. Instead of using a stack, we can track the number of unmatched brackets with an integer, which saves space.</p>
<p>The <code>stackSize</code> represents the number of unmatched <code>[</code> brackets as we go through the string. When we encounter a closing bracket <code>]</code>, we try to balance it by reducing <code>stackSize</code> if thereâ€™s already an unmatched opening bracket (i.e., <code>stackSize</code> &gt; 0).</p>
<p>After the loop, the value of <code>stackSize</code> will show how many opening brackets are still unmatched. These remaining <code>[</code> brackets need to be balanced with closing brackets by performing swaps. Each swap balances two brackets (one <code>[</code> and one <code>]</code>), so the minimum number of swaps is <code>(stackSize + 1) / 2</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize <code>stackSize</code> to 0. This integer will keep track of the number of unmatched opening brackets <code>[</code>.</li>
<li>For each character <code>ch</code> in the string <code>s</code>:
<ul>
<li>If <code>ch</code> is an opening bracket <code>[</code>, increment <code>stackSize</code> by 1.</li>
<li>If <code>ch</code> is a closing bracket <code>]</code>:
<ul>
<li>Check if <code>stackSize</code> is greater than 0:
<ul>
<li>If true, decrement <code>stackSize</code> by 1 (indicating a matching opening bracket has been found).</li>
<li>If false, do nothing (this indicates an unbalanced closing bracket <code>]</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the result as the minimum number of swaps required to balance the string. The minimum number of swaps is calculated as <code>(stackSize+1)/2</code>.</li>
</ol>
<p>!?!../Documents/1963/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/PfFu3Nah/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through each character of the string exactly once in the loop. Each increment or decrement operation on the <code>stackSize</code> variable takes constant time <span class="math inline">\(O(1)\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use a single integer (<code>stackSize</code>) to keep track of unmatched opening brackets, which means the space complexity is constant. Thus, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Number of Visited Cells in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. Your initial position is at the <strong>top-left</strong> cell <code>(0, 0)</code>.</p>

<p>Starting from the cell <code>(i, j)</code>, you can move to one of the following cells:</p>

<ul>
	<li>Cells <code>(i, k)</code> with <code>j &lt; k &lt;= grid[i][j] + j</code> (rightward movement), or</li>
	<li>Cells <code>(k, j)</code> with <code>i &lt; k &lt;= grid[i][j] + i</code> (downward movement).</li>
</ul>

<p>Return <em>the minimum number of cells you need to visit to reach the <strong>bottom-right</strong> cell</em> <code>(m - 1, n - 1)</code>. If there is no valid path, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex1.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows one of the paths that visits exactly 4 cells.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex2.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The image above shows one of the paths that visits exactly 3 cells.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/26/ex3.png" style="width: 181px; height: 81px;" />
<pre>
<strong>Input:</strong> grid = [[2,1,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven that no path exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>
	<li><code>grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Convert All Elements to Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of size <code>n</code>, consisting of <strong>non-negative</strong> integers. Your task is to apply some (possibly zero) operations on the array so that <strong>all</strong> elements become 0.</p>

<p>In one operation, you can select a <span data-keyword="subarray">subarray</span> <code>[i, j]</code> (where <code>0 &lt;= i &lt;= j &lt; n</code>) and set all occurrences of the <strong>minimum</strong> <strong>non-negative</strong> integer in that subarray to 0.</p>

<p>Return the <strong>minimum</strong> number of operations required to make all elements in the array 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Select the subarray <code>[1,1]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0]</code>.</li>
	<li>Thus, the minimum number of operations required is 1.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,1,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Select subarray <code>[1,3]</code> (which is <code>[1,2,1]</code>), where the minimum non-negative integer is 1. Setting all occurrences of 1 to 0 results in <code>[3,0,2,0]</code>.</li>
	<li>Select subarray <code>[2,2]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[3,0,0,0]</code>.</li>
	<li>Select subarray <code>[0,0]</code> (which is <code>[3]</code>), where the minimum non-negative integer is 3. Setting all occurrences of 3 to 0 results in <code>[0,0,0,0]</code>.</li>
	<li>Thus, the minimum number of operations required is 3.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,1,2,1,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Select subarray <code>[0,5]</code> (which is <code>[1,2,1,2,1,2]</code>), where the minimum non-negative integer is 1. Setting all occurrences of 1 to 0 results in <code>[0,2,0,2,0,2]</code>.</li>
	<li>Select subarray <code>[1,1]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0,0,2,0,2]</code>.</li>
	<li>Select subarray <code>[3,3]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0,0,0,0,2]</code>.</li>
	<li>Select subarray <code>[5,5]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0,0,0,0,0]</code>.</li>
	<li>Thus, the minimum number of operations required is 4.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-array-equal-to-target/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make Array Equal to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integer arrays <code>nums</code> and <code>target</code>, of the same length.</p>

<p>In a single operation, you can select any subarray of <code>nums</code> and increment each element within that subarray by 1 or decrement each element within that subarray by 1.</p>

<p>Return the <strong>minimum</strong> number of operations required to make <code>nums</code> equal to the array <code>target</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,5,1,2], target = [4,6,2,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We will perform the following operations to make <code>nums</code> equal to <code>target</code>:<br />
- Increment&nbsp;<code>nums[0..3]</code> by 1, <code>nums = [4,6,2,3]</code>.<br />
- Increment&nbsp;<code>nums[3..3]</code> by 1, <code>nums = [4,6,2,4]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,3,2], target = [2,1,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>We will perform the following operations to make <code>nums</code> equal to <code>target</code>:<br />
- Increment&nbsp;<code>nums[0..0]</code> by 1, <code>nums = [2,3,2]</code>.<br />
- Decrement&nbsp;<code>nums[1..1]</code> by 1, <code>nums = [2,2,2]</code>.<br />
- Decrement&nbsp;<code>nums[1..1]</code> by 1, <code>nums = [2,1,2]</code>.<br />
- Increment&nbsp;<code>nums[2..2]</code> by 1, <code>nums = [2,1,3]</code>.<br />
- Increment&nbsp;<code>nums[2..2]</code> by 1, <code>nums = [2,1,4]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == target.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], target[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description" target="_blank" rel="noopener noreferrer">Minimum Remove to Make Valid Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <font face="monospace">s</font> of <code>&#39;(&#39;</code> , <code>&#39;)&#39;</code> and lowercase English characters.</p>

<p>Your task is to remove the minimum number of parentheses ( <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>, in any positions ) so that the resulting <em>parentheses string</em> is valid and return <strong>any</strong> valid string.</p>

<p>Formally, a <em>parentheses string</em> is valid if and only if:</p>

<ul>
	<li>It is the empty string, contains only lowercase characters, or</li>
	<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li>
	<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;lee(t(c)o)de)&quot;
<strong>Output:</strong> &quot;lee(t(c)o)de&quot;
<strong>Explanation:</strong> &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a)b(c)d&quot;
<strong>Output:</strong> &quot;ab(c)d&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;))((&quot;
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> An empty string is also valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either&nbsp;<code>&#39;(&#39;</code> , <code>&#39;)&#39;</code>, or lowercase English letter.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-string-length-after-removing-substrings/description" target="_blank" rel="noopener noreferrer">Minimum String Length After Removing Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting only of <strong>uppercase</strong> English letters.</p>

<p>You can apply some operations to this string where, in one operation, you can remove <strong>any</strong> occurrence of one of the substrings <code>&quot;AB&quot;</code> or <code>&quot;CD&quot;</code> from <code>s</code>.</p>

<p>Return <em>the <strong>minimum</strong> possible length of the resulting string that you can obtain</em>.</p>

<p><strong>Note</strong> that the string concatenates after removing the substring and could produce new <code>&quot;AB&quot;</code> or <code>&quot;CD&quot;</code> substrings.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ABFCACDB&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can do the following operations:
- Remove the substring &quot;<u>AB</u>FCACDB&quot;, so s = &quot;FCACDB&quot;.
- Remove the substring &quot;FCA<u>CD</u>B&quot;, so s = &quot;FCAB&quot;.
- Remove the substring &quot;FC<u>AB</u>&quot;, so s = &quot;FC&quot;.
So the resulting length of the string is 2.
It can be shown that it is the minimum length that we can obtain.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ACBBD&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> We cannot do any operations on the string so the length remains the same.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code>&nbsp;consists only of uppercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-string-replace">Approach 1: String Replace</h3>
<h4 id="intuition">Intuition</h4>
<p>The core issue with this problem is the ripple effect of removing substrings. When we delete one occurrence of &quot;AB&quot; or &quot;CD&quot;, it can create another substring that also needs removal. For example, in &quot;CABD&quot;, if we remove &quot;AB&quot;, we are left with &quot;CD&quot;, which must also be eliminated to minimize the string length.</p>
<p>A brute force approach will be to continuously check the string for &quot;AB&quot; and &quot;CD&quot; and remove them until none are left. Once the loop ends, the string will have no remaining &quot;AB&quot; or &quot;CD&quot;, and we can return its length. Many programming languages offer built-in functions for finding and removing substrings, which will be helpful here.</p>
<blockquote>
<p>Note: Some programming practices suggest avoiding direct modifications to input data. If this applies, consider making a copy of the input string before you start. Itâ€™s a good idea to clarify this with your interviewer before you implement the solution.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Enter a loop that continues while <code>s</code> contains either &quot;AB&quot; or &quot;CD&quot;.
<ul>
<li>Check if <code>s</code> contains &quot;AB&quot;:
<ul>
<li>If &quot;AB&quot; is present, remove all occurrences of &quot;AB&quot; from <code>s</code>.</li>
</ul>
</li>
<li>If &quot;AB&quot; is not present, check if <code>s</code> contains &quot;CD&quot;.
<ul>
<li>If &quot;CD&quot; is present, remove all occurrences of &quot;CD&quot; from <code>s</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the loop ends, return the length of <code>s</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/KkwgASTV/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The outer while loop can run up to <span class="math inline">\(n/2\)</span> times in the worst case. This occurs when we remove two characters in each iteration (e.g., for a string like &quot;ABABABAB&quot;). Inside the loop, the string methods need to scan the entire string, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n/2 \cdot n) = O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> for Python3 and Java, <span class="math inline">\(O(1)\)</span> for C++</p>
<p>In Python3 and Java, strings are immutable. So, each string operation creates a new string object. However, at any given time, we only need to store one version of the processed string. So, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>However, in C++, strings are mutable. So, string operations like <code>erase()</code> are performed in place. Thus, the space complexity in C++ is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-stack">Approach 2: Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the string removal process, we face two choices for each character:</p>
<ol>
<li>Keep the character if it does not form a removable pattern.</li>
<li>Remove it along with the previous character if it completes a pattern.</li>
</ol>
<p>Using a stack simplifies this task. We push characters onto the stack as we read them and pop them off when we find a pattern.</p>
<p>We read the input string from left to right. For each character, we decide to either add it to the stack or remove a previous character. If the stack is not empty, we compare the current character with the top character on the stack. If they form &quot;AB&quot; or &quot;CD,&quot; we pop the stack. We do not push the current character, thus removing both characters. If there is no pattern, we push the current character onto the stack.</p>
<p>After processing all characters, the remaining elements in the stack represent the minimum length of the string after all possible removals.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a stack to store the characters from the string.</li>
<li>Iterate over each character in the input string <code>s</code>. For each character <code>currentChar</code>:
<ul>
<li>If the stack is empty, push <code>currentChar</code> onto the stack and continue to the next character.</li>
<li>If the current character is 'B' and the top of the stack is 'A', remove the top element from the stack.</li>
<li>If the current character is 'D' and the top of the stack is 'C', remove the top element from the stack.</li>
<li>If neither of the above conditions is met, push <code>currentChar</code> onto the stack.</li>
</ul>
</li>
<li>After processing all characters, return the size of the stack.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QejeDCWG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over each character of <code>s</code> exactly once. All stack operations inside the loop take constant time. Thus, the time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use a stack to store characters from the input string. In the worst-case scenario, where no &quot;AB&quot; or &quot;CD&quot; patterns are found, we would end up storing all <span class="math inline">\(n\)</span> characters in the stack. Thus, the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-in-place-modification">Approach 3: In Place Modification</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To optimize space, we can modify the string in place.</p>
<p>We use two pointers:</p>
<ol>
<li>Read Pointer (<code>readPtr</code>): This pointer moves from left to right through the string, checking each character.</li>
<li>Write Pointer (<code>writePtr</code>): This pointer tracks where to write the next character we want to keep.</li>
</ol>
<p>We start by setting <code>writePtr</code> to 0. As we move <code>readPtr</code> through the string, we copy the character at <code>readPtr</code> to the position indicated by <code>writePtr</code>. Next, we check if the last two characters (positions <code>writePtr-1</code> and <code>writePtr</code>) form a removable pattern, such as &quot;AB&quot; or &quot;CD&quot;. If they do, we decrease <code>writePtr</code>, which means we will overwrite this part in the next steps.</p>
<p>If the last two characters do not form a removable pattern, we increment <code>writePtr</code> to point to the next position where we can write a character. This way, we can effectively &quot;remove&quot; unwanted characters by overwriting them.</p>
<p>After processing all characters, the position of <code>writePtr</code> tells us the length of the final string. All the characters we want to keep are now at the beginning of the array, up to the position of <code>writePtr</code>.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2696/slideshow.json:802,442!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a variable <code>writePtr</code> to 0, which will keep track of the current write position.</li>
<li>Iterate over each character in the string using a <code>readPtr</code>:
<ul>
<li>Copy the character at <code>readPtr</code> to the position at <code>writePtr</code> in the string.</li>
<li>Check if the following conditions are met:
<ul>
<li><code>writePtr</code> is greater than 0 (ensuring there's a previous character).</li>
<li>The previous character (at <code>writePtr - 1</code>) is either 'A' or 'C'.</li>
<li>The current character is exactly one ASCII value higher than the previous character.</li>
</ul>
</li>
<li>If these conditions are met:
<ul>
<li>Decrement <code>writePtr</code> by 1, effectively removing the pair of characters.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Increment <code>writePtr</code> by 1, moving to the next position for writing.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value of <code>writePtr</code>, which represents the length of the remaining string after all removals.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/KSQEfBwu/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the input string exactly once. All operations within the loop take constant time. Thus, the overall time complexity is linear, <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> for Java and Python3, <span class="math inline">\(O(1)\)</span> for C++</p>
<p>In Java and Python3, strings are immutable. So, the input string needs to be converted to an array or list to perform in place modifications. Thus, the space complexity remains <span class="math inline">\(O(n)\)</span>.</p>
<p>String are mutable in C++. So, all modifications can be done on the input string itself. No additional data structures are used, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-complete-all-tasks/description" target="_blank" rel="noopener noreferrer">Minimum Time to Complete All Tasks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a computer that can run an unlimited number of tasks <strong>at the same time</strong>. You are given a 2D integer array <code>tasks</code> where <code>tasks[i] = [start<sub>i</sub>, end<sub>i</sub>, duration<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> task should run for a total of <code>duration<sub>i</sub></code> seconds (not necessarily continuous) within the <strong>inclusive</strong> time range <code>[start<sub>i</sub>, end<sub>i</sub>]</code>.</p>

<p>You may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.</p>

<p>Return <em>the minimum time during which the computer should be turned on to complete all tasks</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [[2,3,1],[4,5,1],[1,5,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- The first task can be run in the inclusive time range [2, 2].
- The second task can be run in the inclusive time range [5, 5].
- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].
The computer will be on for a total of 2 seconds.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [[1,3,2],[2,5,3],[5,6,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
- The first task can be run in the inclusive time range [2, 3].
- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].
- The third task can be run in the two inclusive time range [5, 6].
The computer will be on for a total of 4 seconds.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>
	<li><code>tasks[i].length == 3</code></li>
	<li><code>1 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 2000</code></li>
	<li><code>1 &lt;= duration<sub>i</sub> &lt;= end<sub>i</sub> - start<sub>i</sub> + 1 </code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/mini-parser/description" target="_blank" rel="noopener noreferrer">Mini Parser</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return <em>the deserialized</em> <code>NestedInteger</code>.</p>

<p>Each element is either an integer or a list whose elements may also be integers or other lists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;324&quot;
<strong>Output:</strong> 324
<strong>Explanation:</strong> You should return a NestedInteger object which contains a single integer 324.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;[123,[456,[789]]]&quot;
<strong>Output:</strong> [123,[456,[789]]]
<strong>Explanation:</strong> Return a NestedInteger object containing a nested list with 2 elements:
1. An integer containing value 123.
2. A nested list containing two elements:
    i.  An integer containing value 456.
    ii. A nested list with one element:
         a. An integer containing value 789
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of digits, square brackets <code>&quot;[]&quot;</code>, negative sign <code>&#39;-&#39;</code>, and commas <code>&#39;,&#39;</code>.</li>
	<li><code>s</code> is the serialization of valid <code>NestedInteger</code>.</li>
	<li>All the values in the input are in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/min-stack/description" target="_blank" rel="noopener noreferrer">Min Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>

<p>Implement the <code>MinStack</code> class:</p>

<ul>
	<li><code>MinStack()</code> initializes the stack object.</li>
	<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>
	<li><code>void pop()</code> removes the element on the top of the stack.</li>
	<li><code>int top()</code> gets the top element of the stack.</li>
	<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>
</ul>

<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

<strong>Output</strong>
[null,null,null,null,-3,null,0,-2]

<strong>Explanation</strong>
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>
	<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>
	<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/n-ary-tree-postorder-traversal/description" target="_blank" rel="noopener noreferrer">N-ary Tree Postorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of an n-ary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>

<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" style="width: 100%; max-width: 300px;" />
<pre>
<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]
<strong>Output:</strong> [5,6,3,2,4,1]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" style="width: 296px; height: 241px;" />
<pre>
<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>Output:</strong> [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>The height of the n-ary tree is less than or equal to <code>1000</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The N-ary tree is a generalization of a binary tree where each node can have more than two children. In postorder traversal, the traversal order is as follows:</p>
<ol>
<li>Visit all the children of a node from left to right.</li>
<li>After all the children have been visited, visit the node itself.</li>
</ol>
<p>The problem provides the tree in a level-order traversal format, where children of a node are grouped and separated by a null value.</p>
<p>If you are completely unfamiliar with N-ary trees, check out this LeetCode <a href="https://leetcode.com/explore/learn/card/n-ary-tree/">Explore Card</a> for an in-depth discussion.</p>
<hr />
<h3 id="approach-1-recursive">Approach 1: Recursive</h3>
<h4 id="intuition">Intuition</h4>
<p>Before we explore the solution, let's visualize the postorder traversal in this slideshow:</p>
<p>!?!../Documents/590/slideshow.json:934,902!?!</p>
<p>Let's walk through the process using a recursive function <code>traversePostorder</code>. This function will call itself for each child of the current node, effectively breaking down the traversal into smaller, manageable subproblems. The key idea here is that recursion allows us to naturally explore the entire depth of each subtree before moving on to the next sibling subtree.</p>
<ol>
<li>Base Case: If the node has no children (i.e., it's a leaf node), the function simply adds the node's value to the result list.</li>
<li>Recursive Step: For a non-leaf node, the function iterates over all its children, recursively calling <code>traversePostorder</code> on each one. After all children have been processed, the function adds the current node's value to the result list.</li>
</ol>
<p>For example, consider an n-ary tree where the root has three children. The function will:</p>
<ul>
<li>Traverse all the subtrees rooted at the first child.</li>
<li>After finishing with the first subtree, it moves to the second child and repeats the process.</li>
<li>Finally, after all subtrees have been traversed, the function adds the root nodeâ€™s value to the result list.</li>
</ul>
<p>The result list now contains the nodes' values in the correct postorder sequence.</p>
<p>This approach effectively mimics the natural recursive nature of postorder traversal, where the exploration of each subtree is completed before moving to the next.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main method <code>postorder</code>:</p>
<ul>
<li>Initialize a list <code>result</code> to store the postorder traversal of the nodes' values.</li>
<li>If the input <code>root</code> node is <code>null</code>, return the empty <code>result</code> list immediately.</li>
<li>Invoke the helper method <code>traversePostorder</code> to perform the postorder traversal.</li>
<li>Return <code>result</code> as our answer.</li>
</ul>
<p>Helper method <code>traversePostorder</code>:</p>
<ul>
<li>Define a method <code>traversePostorder</code> with parameters: <code>currentNode</code> and the <code>postorderList</code> to store the result.</li>
<li>If <code>currentNode</code> is <code>null</code>, return.</li>
<li>Loop over each <code>childNode</code> of <code>currentNode</code>:
<ul>
<li>Recursively call <code>traversePostorder</code> on each <code>childNode</code>.</li>
</ul>
</li>
<li>Add the value of <code>currentNode</code> to <code>postorderList</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/U4oRxsP8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The method <code>traversePostorder</code> visits each node in the tree exactly once. Thus, the time complexity of the algorithm is <span class="math inline">\(O(m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The <code>traversePostorder</code> method uses recursion, and the maximum depth of the recursion is the height of the tree, which is <span class="math inline">\(O(m)\)</span> in the worst case (for a skewed tree).</p>
<p>Thus, the space complexity of the algorithm is also <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-explicit-reversal">Approach 2: Iterative (Explicit Reversal)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In contrast to the recursive method, implementing an iterative approach for postorder traversal in an n-ary tree presents a challenge. The recursive method naturally processes nodes in a bottom-up manner, but this behavior doesn't translate directly to an iterative stack-based approach, since a stack processes elements in a last-in-first-out (LIFO) order.</p>
<p>To achieve postorder traversal iteratively, we can adopt a method that initially resembles preorder traversal but with some modifications.</p>
<ol>
<li>
<p>Simulate Preorder with Stack: We start by pushing the root node onto the stack. As long as the stack isnâ€™t empty, we pop the top element, add it to the result list, and then push all its children onto the stack from left to right.</p>
<ul>
<li>This order means that when children are popped from the stack for further evaluation, they come out in the reverse order (right to left). Thus, at this point, our traversal order is root -&gt; right-to-left children.</li>
</ul>
</li>
<li>
<p>Reverse the Result: After the entire tree has been processed, and the stack is empty, the result list will reflect the reverse of what we want. By reversing this result list, we obtain the correct postorder traversal, where each nodeâ€™s children are fully processed before the node itself.</p>
</li>
</ol>
<p>This approach leverages the stack to mimic the recursive behavior, but because of the LIFO nature of the stack, we reverse the result at the end to achieve the desired postorder sequence. Although this method doesn't traverse the tree in a strict postorder manner, it remains a valid solution since the problem only requires the correct order in the final result.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Create a list <code>result</code> to store the postorder traversal of the nodes' values.</li>
<li>If the input <code>root</code> node is <code>null</code>, return the empty result list immediately.</li>
<li>Initialize a <code>stack</code> and push the root node onto it. This stack will be used to traverse the tree.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop a node from <code>stack</code> and assign it to a variable <code>currentNode</code>.</li>
<li>Add the value of <code>currentNode</code> to <code>result</code>.</li>
<li>Iterate through the <code>children</code> of <code>currentNode</code>. For each <code>child</code> node:
<ul>
<li>Push <code>child</code> onto the <code>stack</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Reverse the <code>result</code> list.</li>
<li>Return <code>result</code> as our answer.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/LAiQ7Az3/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The main loop iterates over every node in the tree, taking <span class="math inline">\(O(m)\)</span> time. Each stack operation inside the loop takes constant time. Reversing the <code>result</code> list takes an additional linear time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>In the worst case, if the tree is highly unbalanced (e.g., a skewed tree), the stack can grow to store all nodes at once, contributing <span class="math inline">\(O(m)\)</span> to the space complexity. No other additional data structures are used.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterative-two-stacks">Approach 3: Iterative (Two Stacks)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>This approach refines the iterative method by utilizing two stacks to better manage the order in which nodes are processed, ultimately eliminating the need to reverse the result at the end.</p>
<p>In this method, we use two stacks: <code>nodeStack</code> for the main traversal and <code>reverseStack</code> to temporarily hold the nodes in reverse order before they are added to the final result.</p>
<p>We start by pushing the <code>root</code> node onto the <code>nodeStack</code>. As long as <code>nodeStack</code> is not empty, we proceed with the following steps.</p>
<p>We pop the top node from <code>nodeStack</code>. Instead of adding it directly to the result list (as its children haven't been processed yet), we push it onto <code>reverseStack</code>. This postpones the addition of the node to the final result, allowing us to process its children first.</p>
<p>Now we iterate over the children of the current node from left to right, pushing each child onto <code>nodeStack</code>. Due to the LIFO nature of stacks, these children will be popped and processed in the reverse order (right to left). As a result, the nodes in <code>reverseStack</code> will eventually be ordered such that when we pop them, we get the correct postorder sequence: children from left to right, followed by their parent node.</p>
<p>After processing all nodes, <code>reverseStack</code> will contain the nodes in postorder, but in reverse order. We then simply pop elements from <code>reverseStack</code> one by one and add them to our result list. This ensures that the final list is in the correct postorder sequence.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a list <code>result</code> to store the postorder traversal of the nodes' values.</li>
<li>If the input <code>root</code> node is <code>null</code>, return the empty <code>result</code> list immediately.</li>
<li>Initialize two stacks: <code>nodeStack</code> for traversal and <code>reverseStack</code> to store nodes in reverse order.</li>
<li>Push <code>root</code> onto the <code>nodeStack</code> to start the traversal.</li>
<li>While <code>nodeStack</code> is not empty:
<ul>
<li>Pop a node <code>currentNode</code> from the <code>nodeStack</code>.</li>
<li>Push <code>currentNode</code> onto <code>reverseStack</code>.</li>
<li>Iterate through the <code>children</code> of <code>currentNode</code>. For each node <code>child</code>:
<ul>
<li>Push each <code>child</code> onto <code>nodeStack</code> to ensure they are processed in the subsequent iterations.</li>
</ul>
</li>
</ul>
</li>
<li>While <code>reverseStack</code> is not empty:
<ul>
<li>Pop a node from <code>reverseStack</code> and assign it to <code>currentNode</code>.</li>
<li>Add the value of <code>currentNode</code> to <code>result</code>.</li>
</ul>
</li>
<li>Return the <code>result</code> list.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/29SXBMBk/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The first loop iterates over each node in the tree exactly once. Each node is pushed onto <code>nodeStack</code> and then moved to <code>reverseStack</code>. Since each node is processed exactly once, the time complexity for this loop is <span class="math inline">\(O(m)\)</span>.</p>
<p>The second loop also processes each node exactly once, adding their values to the <code>result</code> list. This loop has a time complexity of <span class="math inline">\(O(m)\)</span>.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m) + O(m) = O(m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The <code>nodeStack</code> and <code>reverseStack</code> can each hold up to <span class="math inline">\(m\)</span> nodes in the worst case. This makes the space complexity of the algorithm <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-iterative-without-reverse">Approach 4: Iterative (Without Reverse)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In this approach, we aim to closely mimic the natural flow of recursion using a single stack, avoiding the need to reverse the final result by carefully managing when nodes are added to the result list.</p>
<p>To replicate the recursive process, we need to simulate the behavior where each node is visited twice: first when we encounter it initially and later after all its children have been processed. The key idea here is to use a flag to track whether a node has been visited once before adding it to the result list.</p>
<p>We start by pushing the root node onto the stack with a <code>visited</code> flag set to <code>false</code>. This flag indicates whether the node has been fully processed (i.e., whether its children have been visited).</p>
<p>As we iterate, we pop the top element from the stack and check its <code>visited</code> flag:</p>
<ul>
<li>
<p>First Encounter (<code>visited</code> = <code>false</code>): If this is the first time we're seeing this node, we update its flag to <code>true</code> and push it back onto the stack. Then, we push all its children onto the stack from right to left. This ensures that when we revisit these nodes, they will be processed in left-to-right order.</p>
</li>
<li>
<p>Second Encounter (<code>visited</code> = <code>true</code>): When the node is encountered again (after its children have been processed), we add it to the result list. This step corresponds to the natural postorder sequence, where a node is added to the result after all its children have been visited.</p>
</li>
</ul>
<p>By the time the stack is empty, all nodes will have been processed in the correct postorder sequence, and the result list will reflect the correct traversal without the need for any additional reversal.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Create a list <code>result</code> to store the postorder traversal of the nodes' values.</li>
<li>If the input <code>root</code> node is <code>null</code>, return the empty <code>result</code> list immediately.</li>
<li>Create a stack <code>nodeStack</code> of type <code>NodeVisitPair</code> that will hold pairs of nodes and their visit status.</li>
<li>Push the <code>root</code> node onto the stack with <code>isVisited</code> set to <code>false</code>, indicating that the node has not yet been fully processed.</li>
<li>While <code>nodeStack</code> is not empty:
<ul>
<li>Pop a pair from the <code>nodeStack</code> and assign it to <code>currentPair</code>.</li>
<li>If <code>currentPair.isVisited</code> is <code>true</code>, add the node's value to <code>result</code>.</li>
<li>Else, set <code>currentPair.isVisited</code> to <code>true</code> and push <code>currentPair</code> back onto the stack.</li>
<li>Retrieve the children of the current node and set it to a list <code>children</code>.</li>
<li>Iterate over <code>children</code> in reverse order and push each child onto the stack.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/nW2cReWj/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m)\)</span></p>
<p>Each node is pushed onto the stack twice: once with <code>isVisited = false</code> and once with <code>isVisited = true</code>. Consequently, each node is popped from the stack twice. Overall, this makes the time complexity of the algorithm <span class="math inline">\(O(4 \cdot m) = O(m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The <code>nodeStack</code> will, in the worst case (for a skewed tree), contain all <code>m</code> nodes of the tree. Each entry in the stack takes constant space.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/n-ary-tree-preorder-traversal/description" target="_blank" rel="noopener noreferrer">N-ary Tree Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of an n-ary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>

<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" style="width: 100%; max-width: 300px;" /></p>

<pre>
<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]
<strong>Output:</strong> [1,3,5,6,2,4]
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" style="width: 296px; height: 241px;" /></p>

<pre>
<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>Output:</strong> [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>The height of the n-ary tree is less than or equal to <code>1000</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/nearest-smaller-tower--170647/1" target="_blank" rel="noopener noreferrer">Nearest smaller tower</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array where each element <strong>arr[i]</strong>&nbsp;represents the height of the tower. Find for each tower, the nearest possible tower that is shorter than it. You can look left or right on both sides.<br /><strong>Note :&nbsp;</strong></span></p>
<ul>
<li>
<p><span style="font-size: 18px;">If&nbsp;two smaller towers&nbsp;are at the same distance, pick the smallest tower.</span></p>
</li>
<li>
<p><span style="font-size: 18px;">If two towers have the same height then we choose the one with a smaller index.</span></p>
</li>
</ul>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 3, 2]</span>
<span style="font-size: 18px;"><strong>Output: </strong>[-1, 0, 0] </span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">For <strong>0th</strong> index : no tower is smallest, so <strong>-1</strong>.
For <strong>1st</strong> index : For 3, here 1 &amp; 2 both are 
small &amp; at a same distance, so we will pick 1, 
beacuse it has smallest value, so <strong>0(index)</strong>
For <strong>2nd</strong> Index : here 1 is smaller, so <strong>0(index)
</strong></span><span style="font-size: 18px;">So the final output will be which consistes 
indexes are [-1, 0, 0].</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">arr[] = [4, 8, 3, 5, 3]</span><strong><span style="font-size: 18px;"><br />Output =</span></strong><span style="font-size: 18px;"> [2, 2, -1, 2, -1]</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong> 
<span style="font-size: 18px;">For <strong>0th</strong> index : here 3 is the smaller, so <strong>2(index)</strong> 
For <strong>1st</strong> index : For 8, here 4 &amp; 3 both are
small &amp; at a same distance, so we will pick 3, so <strong>2(index)</strong>
For <strong>2nd</strong> index : no tower is smallest, so <strong>-1</strong>.
For <strong>3rd</strong> index : For 5, here 3 &amp; 3 both are
small &amp; at a same distance, so we will pick 
<strong>3</strong>(2nd Index) because it smaller Index, so <strong>2(index)
</strong>For <strong>4th</strong> index : no tower is smallest, so <strong>-1</strong>.</span>
<span style="font-size: 18px;">So the final output will be which consistes
Indexes are [2, 2, -1, 2, -1].</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= n&lt;= 10<sup>5</sup><br />1 &lt;= arr[i]&nbsp;&lt;= 10<sup>5</sup></span></p>
<p>&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/next-element-with-greater-frequency--170637/1" target="_blank" rel="noopener noreferrer">Next element with greater frequency</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an array&nbsp;<strong>arr[ ]</strong>&nbsp;of&nbsp;<strong>n</strong>&nbsp;integers, for every element, find the closest element on it&#39;s right that has a greater frequency than its own frequency.</span></p>

<blockquote>
<p><span style="font-size:18px">Frequency is the number of times the&nbsp;element appears in the array.</span></p>
</blockquote>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 6
arr[] = {2 1 1 3 2 1}<strong>
Output:</strong>
1 -1 -1 2 1 -1 
<strong>Explanation:
</strong>1 appears 3 times.
2 appears 2 times.
3 appears 1 time. 

For arr[0] ie, 2
arr[1] ie 1 is the closest element on its 
right which has greater frequency than the 
frequency of 2. For the arr[1] and arr[2] no element 
on the right has greater frequency than 1, 
so -1 will be printed. and so on. </span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>n = 10
arr[] = {5 1 2 3 2 5 5 4 5 2}
<strong>Output:</strong>
-1 2 5 2 5 -1 -1 5 -1 -1</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your task:</strong><br />
Your task is to complete the function&nbsp;<strong>print_next_greater_freq() </strong>which take two parameters <strong>arr</strong> and <strong>n</strong>.This function returns&nbsp;answer(as a list of integers)&nbsp;as explained above.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected time complexity:</strong> O(n)<br />
<strong>Expected space complexity: </strong>O(n)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n &lt;= 10<sup>4</sup><br />
1 &lt;= arr[i] &lt;=&nbsp;10<sup>4</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/next-larger-element-1587115620/1" target="_blank" rel="noopener noreferrer">Next Greater Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[ ]</strong> of integers, the task is to find the next greater element for each element of the array in order of their appearance in the array. Next greater element of an element in the array is the nearest element on the right which is greater than the current element.<br />If there does not exist next greater of current element, then next greater element for current element is -1. For example, next greater of the last element is always -1.</span></p>
<p><span style="font-size: 18px;"><strong>Examples<br /></strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [1, 3, 2, 4]
<strong>Output</strong>: [3, 4, 4, -1]
<strong>Explanation</strong>: The next larger element to 1 is 3, 3 is 4, 2 is 4 and for 4, since it doesn't exist, it is -1.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [6, 8, 0, 1, 3]
<strong>Output</strong>: [8, -1, 1, 3, -1]
<strong>Explanation</strong>: The next larger element to 6 is 8, for 8 there is no larger elements hence it is -1, for 0 it is 1 , for 1 it is 3 and then for 3 there is no larger element on right and hence -1.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [10, 20, 30, 50]
<strong>Output</strong>: [20, 30, 50, -1]
<strong>Explanation</strong>: For a sorted array, the next element is next greater element also except for the last element.</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input</strong><span style="font-size: 18px;">: arr[] = [50, 40, 30, 10]
</span><strong style="font-size: 18px;">Output</strong><span style="font-size: 18px;">: [-1, -1, -1, -1]
</span><strong style="font-size: 18px;">Explanation</strong><span style="font-size: 18px;">: There is no greater element for any of the elements in the array, so all are -1.</span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />0 &le; arr[i] &le; 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-i/description" target="_blank" rel="noopener noreferrer">Next Greater Element I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>next greater element</strong> of some element <code>x</code> in an array is the <strong>first greater</strong> element that is <strong>to the right</strong> of <code>x</code> in the same array.</p>

<p>You are given two <strong>distinct 0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.</p>

<p>For each <code>0 &lt;= i &lt; nums1.length</code>, find the index <code>j</code> such that <code>nums1[i] == nums2[j]</code> and determine the <strong>next greater element</strong> of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, then the answer for this query is <code>-1</code>.</p>

<p>Return <em>an array </em><code>ans</code><em> of length </em><code>nums1.length</code><em> such that </em><code>ans[i]</code><em> is the <strong>next greater element</strong> as described above.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,1,2], nums2 = [1,3,4,2]
<strong>Output:</strong> [-1,3,-1]
<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,<u>4</u>,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [<u>1</u>,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,<u>2</u>]. There is no next greater element, so the answer is -1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,4], nums2 = [1,2,3,4]
<strong>Output:</strong> [3,-1]
<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,<u>2</u>,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,<u>4</u>]. There is no next greater element, so the answer is -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>
	<li>All integers in <code>nums1</code> and <code>nums2</code> are <strong>unique</strong>.</li>
	<li>All the integers of <code>nums1</code> also appear in <code>nums2</code>.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you find an <code>O(nums1.length + nums2.length)</code> solution?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-ii/description" target="_blank" rel="noopener noreferrer">Next Greater Element II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a circular integer array <code>nums</code> (i.e., the next element of <code>nums[nums.length - 1]</code> is <code>nums[0]</code>), return <em>the <strong>next greater number</strong> for every element in</em> <code>nums</code>.</p>

<p>The <strong>next greater number</strong> of a number <code>x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&#39;t exist, return <code>-1</code> for this number.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1]
<strong>Output:</strong> [2,-1,2]
Explanation: The first 1&#39;s next greater number is 2; 
The number 2 can&#39;t find next greater number. 
The second 1&#39;s next greater number needs to search circularly, which is also 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,3]
<strong>Output:</strong> [2,3,4,-1,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-using-double-length-array-time-limit-exceeded">Approach 1: Brute Force (using Double Length Array) [Time Limit Exceeded]</h3>
<h4 id="algorithm">Algorithm</h4>
<p>In this method, we make use of an array <span class="math inline">\(doublenums\)</span> which is formed by concatenating two copies of the given <span class="math inline">\(nums\)</span> array one after the other. Now, when we need to find out the next greater element for <span class="math inline">\(nums[i]\)</span>, we can simply scan all the elements <span class="math inline">\(doublenums[j]\)</span>, such that <span class="math inline">\(i < j < length(doublenums)\)</span>. The first element found satisfying the given condition is the required result for <span class="math inline">\(nums[i]\)</span>. If no such element is found, we put a <span class="math inline">\(\text{-1}\)</span> at the appropriate position in the <span class="math inline">\(res\)</span> array.</p>
<p><a href="https://leetcode.com/playground/tRcR8Lx3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. The complete <span class="math inline">\(doublenums\)</span> array(of size <span class="math inline">\(\text{2n}\)</span>) is scanned for all the elements of <span class="math inline">\(nums\)</span> in the worst case.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(doublenums\)</span> array of size <span class="math inline">\(\text{2n}\)</span> is used. <span class="math inline">\(res\)</span> array of size <span class="math inline">\(\text{n}\)</span> is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force-accepted">Approach 2: Better Brute Force [Accepted]</h3>
<h4 id="algorithm-1">Algorithm</h4>
<p>Instead of making a double length copy of <span class="math inline">\(nums\)</span> array , we can traverse circularly in the <span class="math inline">\(nums\)</span> array by making use of the <span class="math inline">\( \text{modulus}\)</span> operator. For every element <span class="math inline">\(nums[i]\)</span>, we start searching in the <span class="math inline">\(nums\)</span> array(of length <span class="math inline">\(n\)</span>) from the index <span class="math inline">\((i+1)%n\)</span> and look at the next (circularly) <span class="math inline">\(n-1\)</span> elements. For <span class="math inline">\(nums[i]\)</span> we do so by scanning over <span class="math inline">\(nums[j]\)</span>, such that<br />
<span class="math inline">\((i+1)%n &leq; j &leq; (i+(n-1))%n\)</span>, and we look for the first greater element found. If no such element is found, we put a <span class="math inline">\(\text{-1}\)</span> at the appropriate position in the <span class="math inline">\(res\)</span> array.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LCG759JD/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. The complete <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> is scanned for all the elements of <span class="math inline">\(nums\)</span> in the worst case.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(res\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-stack-accepted">Approach 3: Using Stack [Accepted]</h3>
<h4 id="algorithm-2">Algorithm</h4>
<p>This approach makes use of a stack. This stack stores the indices of the appropriate elements from <span class="math inline">\(nums\)</span> array.  The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the <span class="math inline">\(nums\)</span> array. The description of the method will make the above statement clearer.</p>
<p>We start traversing the <span class="math inline">\(nums\)</span> array from right towards the left. For an element <span class="math inline">\(nums[i]\)</span> encountered, we pop all the elements<br />
<span class="math inline">\(stack[top]\)</span> from the stack such that <span class="math inline">\(nums\big[stack[top]\big] \le nums[i]\)</span>. We continue the popping till we encounter a <span class="math inline">\(stack[top]\)</span> satisfying <span class="math inline">\(nums\big[stack[top]\big] > nums[i]\)</span>. Now, it is obvious that the current <span class="math inline">\(stack[top]\)</span> only can act as the<br />
Next Greater Element for <span class="math inline">\(nums[i]\)</span>(right now, considering only the elements lying to the right of <span class="math inline">\(nums[i]\)</span>).</p>
<p>If no element remains on the top of the stack, it means no larger element than <span class="math inline">\(nums[i]\)</span> exists to its right. Along with this, we also push the index of the element just encountered(<span class="math inline">\(nums[i]\)</span>), i.e. <span class="math inline">\(i\)</span> over the top of the stack, so that <span class="math inline">\(nums[i]\)</span>(or <span class="math inline">\(stack[top]\)</span>) now acts as the Next Greater Element for the elements lying to its left.</p>
<p>We go through two such passes over the complete <span class="math inline">\(nums\)</span> array. This is done so as to complete a circular traversal over the <span class="math inline">\(nums\)</span> array. The first pass could make some wrong entries in the <span class="math inline">\(res\)</span> array since it considers only the elements lying to the right of <span class="math inline">\(nums[i]\)</span>, without a circular traversal. But, these entries are corrected in the second pass.</p>
<p>Further, to ensure the correctness of the method, let's look at the following cases.</p>
<p>Assume that <span class="math inline">\(nums[j]\)</span> is the correct Next Greater Element for <span class="math inline">\(nums[i]\)</span>, such that <span class="math inline">\(i < j &le; stack[top]\)</span>. Now, whenever we encounter <span class="math inline">\(nums[j]\)</span>, if <span class="math inline">\(nums[j] > nums\big[stack[top]\big]\)</span>, it would have already popped the previous <span class="math inline">\(stack[top]\)</span> and <span class="math inline">\(j\)</span> would have become the topmost element. On the other hand, if  <span class="math inline">\(nums[j] < nums\big[stack[top]\big]\)</span>, it would have become the topmost element by being pushed above the previous <span class="math inline">\(stack[top]\)</span>. In both the cases, if <span class="math inline">\(nums[j] > nums[i]\)</span>, it will be correctly determined to be the Next Greater Element.</p>
<p>The following example makes the procedure clear:</p>
<!--![Next_Greater_Element_II](../Figures/503_Next_Greater_Element_II.gif)-->
<p>!?!../Documents/503_Next_Greater2.json:1000,563!?!</p>
<p>As the animation above depicts, after the first pass, there are a number of wrong entries(marked as <span class="math inline">\(\text{-1}\)</span>) in the <span class="math inline">\(res\)</span> array, because only the elements lying to the corresponding right(non-circular) have been considered till now. But, after the second pass, the correct values are substituted.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/in37fqRd/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. Only two traversals of the <span class="math inline">\(nums\)</span> array are done. Further, at most <span class="math inline">\(\text{2n}\)</span> elements are pushed and popped from the stack.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. A stack of size <span class="math inline">\(n\)</span> is used. <span class="math inline">\(res\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/next-greater-element/1" target="_blank" rel="noopener noreferrer">Next Greater Element in Circular Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a circular integer array <strong>arr[]</strong>, the task is to determine the next greater element <strong>(NGE)</strong> for each element in the array.</span></p>
<p><span style="font-size: 18px;">The next greater element of an element <strong>arr[i]</strong> is the first element that is greater than <strong>arr[i]</strong> when traversing circularly. If no such element exists, return <strong>-1</strong> for that position.</span></p>
<p><strong><span style="font-size: 18px;">Circular Property:</span></strong></p>
<p><span style="font-size: 18px;">Since the array is circular, after reaching the last element, the search continues from the beginning until we have looked at all elements once</span></p>
<p><span style="font-size: 18px;"><strong>Examples:&nbsp;</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [1 3 2 4]
<strong>Output</strong>: [3 4 4 -1]
<strong>Explanation</strong>:<br /></span><span style="font-size: 18px;">The next greater element for 1 is 3.
The next greater element for 3 is 4.
The next greater element for 2 is 4.
The next greater element for 4 does not exist, so return -1.</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input</strong><span style="font-size: 18px;">: arr[] = [0 2 3 1 1]
</span><strong style="font-size: 18px;">Output</strong><span style="font-size: 18px;">: [2 3 -1 2 2]
<strong>Explanation:
</strong>The next greater element for 0 is 2.
The next greater element for 2 is 3.
The next greater element for 3 does not exist, so return -1.
The next greater element for 1 is 2 (from circular traversal).
The next greater element for 1 is 2 (from circular traversal). </span></span></pre>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>5</sup><sup><br /></sup></span></span><span style="font-size: 18px;"><span style="font-size: 18px;">0 &lt;= arr[i] &lt;= 10<sup>9</sup></span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-iv/description" target="_blank" rel="noopener noreferrer">Next Greater Element IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of non-negative integers <code>nums</code>. For each integer in <code>nums</code>, you must find its respective <strong>second greater</strong> integer.</p>

<p>The <strong>second greater</strong> integer of <code>nums[i]</code> is <code>nums[j]</code> such that:</p>

<ul>
	<li><code>j &gt; i</code></li>
	<li><code>nums[j] &gt; nums[i]</code></li>
	<li>There exists <strong>exactly one</strong> index <code>k</code> such that <code>nums[k] &gt; nums[i]</code> and <code>i &lt; k &lt; j</code>.</li>
</ul>

<p>If there is no such <code>nums[j]</code>, the second greater integer is considered to be <code>-1</code>.</p>

<ul>
	<li>For example, in the array <code>[1, 2, 4, 3]</code>, the second greater integer of <code>1</code> is <code>4</code>, <code>2</code> is <code>3</code>,&nbsp;and that of <code>3</code> and <code>4</code> is <code>-1</code>.</li>
</ul>

<p>Return<em> an integer array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the second greater integer of </em><code>nums[i]</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,0,9,6]
<strong>Output:</strong> [9,6,6,-1,-1]
<strong>Explanation:</strong>
0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.
1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.
2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.
3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.
4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.
Thus, we return [9,6,6,-1,-1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3]
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong>
We return [-1,-1] since neither integer has any integer greater than it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-node-in-linked-list/description" target="_blank" rel="noopener noreferrer">Next Greater Node In Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked-list</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list with <code>n</code> nodes.</p>

<p>For each node in the list, find the value of the <strong>next greater node</strong>. That is, for each node, find the value of the first node that is next to it and has a <strong>strictly larger</strong> value than it.</p>

<p>Return an integer array <code>answer</code> where <code>answer[i]</code> is the value of the next greater node of the <code>i<sup>th</sup></code> node (<strong>1-indexed</strong>). If the <code>i<sup>th</sup></code> node does not have a next greater node, set <code>answer[i] = 0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg" style="width: 304px; height: 133px;" />
<pre>
<strong>Input:</strong> head = [2,1,5]
<strong>Output:</strong> [5,5,0]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg" style="width: 500px; height: 113px;" />
<pre>
<strong>Input:</strong> head = [2,7,4,3,5]
<strong>Output:</strong> [7,0,5,5,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We start by copying the individual node values in the linked list <code>head</code> into an array (let's call it <code>values</code>), which is easier to access and makes the problem a bit more intuitive.</p>
<p><img src="../Figures/1019/1019-1.png" alt="img" /></p>
<p>Now the problem becomes, for each value in the array, we need to find the next larger element on its right side.</p>
<hr />
<h3 id="approach-1-monotonic-stack">Approach 1: Monotonic Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's start with the most straightforward approach: brute force. That is, to iterate over all elements after <code>values[i]</code> until finding the first larger element for <code>values[i]</code>. This approach has two nested loops, so it may not pass all test cases.</p>
<p>Instead of using one iteration for each value, can we finish finding all the first larger values in a single traverse? The answer is YES!</p>
<p>Note that we are looking for the <strong>next</strong> greater value. If the value we are currently visiting (<code>values[i]</code>) is larger than the value <code>values[smaller]</code> on the top of the stack, we can pop <code>smaller</code> from the stack to prevent it from being visited again later, and let <code>values[i]</code> be <code>values[smaller]</code>'s next greater value.</p>
<p><img src="../Figures/1019/1019-ex.png" alt="img" /></p>
<p>When will the above process stop? When the stack is empty, or <code>values[i]</code> is not larger than the top element of the stack, we can safely push <code>i</code> to stack and move on to the next index <code>i + 1</code>. Similarly, if we encounter any value that is larger than <code>values[i]</code>, we can use it to pop <code>i</code> from the stack.</p>
<p>Since we want to set the next greater value for each index, we would better push the index <code>i</code> instead of the value <code>values[i]</code> to the stack, so that every time we pop an index from the stack, we can directly update the next greater value for this index. After the iteration over the array stops, indexes left in the stack stand for values that don't have such next greater values, we can just set their next greater values as 0.</p>
<p>Refer to the following slides as an example:</p>
<p>!?!../Documents/1019/s1.json:601,301!?!</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Traverse through the linked list <code>head</code>, and use an array <code>values</code> to store the values of nodes.</li>
<li>Initialize an array <code>answer</code> with the same size as <code>values</code> and an empty stack <code>stack</code> to store the previous indexes.</li>
<li>Iterate over <code>values</code>, before we push each index <code>i</code> to <code>stack</code>:
<ul>
<li>If the value represented by the top element of <code>stack</code> (let's call it <code>values[smaller]</code>) is smaller than <code>values[i]</code>, it means that <code>values[i]</code> is <code>values[smaller]</code>'s larger value. So we pop <code>smaller</code> from the <code>stack</code>, update <code>answer[smaller] = values[i]</code> and repeat this step.</li>
<li>Otherwise, it means there is no value smaller than <code>values[i]</code>, we add <code>values[i]</code> to stack and repeat step 3.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8kCjQAdo/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the linked list <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We iterate over <code>head</code> to record all values in <code>values</code>, it takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>We then iterate over <code>values</code> which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>During the iteration, there may be multiple operations on the stack, however, each index is pushed to and popped from the stack at most once, so the total time in the worst-case scenario is <span class="math inline">\(O(n)\)</span>.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We used an array <code>values</code> to store the values of eery node in <code>head</code> which takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>We used a stack <code>stack</code> to maintain a non-increasing sequence, there may be up to <span class="math inline">\(n\)</span> elements in <code>stack</code> thus it also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack-1-pass">Approach 2: Monotonic Stack, 1 Pass</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can further reduce the number of iterations. In the previous approach, we store node values from the linked list <code>head</code> into <code>values</code> by the first iteration and find the next greater value in the second iteration. Here we only use one iteration by recording the value from the <code>head</code> and updating <code>stack</code> in the same iteration step!</p>
<p>Compared to approach 1, the differences are as follows:</p>
<ul>
<li>We don't know the size of the linked list <code>head</code>, thus we can't initialize an array of equal size. Instead, we start with an empty array <code>answer</code> and increment its size during the iteration.</li>
<li>We don't use the array <code>values</code> to store all values from <code>head</code>, so we should store both the index and the value of each node to <code>stack</code>. Then we can get the value of each node from the index without referring to <code>values</code>.</li>
</ul>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an empty <code>answer</code> and an empty stack <code>stack</code> to store the previous indexes.</li>
<li>Iterate over <code>head</code> starting with index <code>i = 0</code>, for each current node, and compare the value of <code>head.val</code> with the element <code>[i, val]</code> on the top of the stack, if <code>head.val &gt; val</code>, pop the top element <code>[top_i, val]</code> from the stack and update <code>answer[top_i] = head.val</code>.</li>
<li>Push the <code>[i, head.val]</code> to the top of <code>stack</code>.</li>
<li>Add <code>0</code> to <code>answer</code>, which is the default next larger value for <code>head.val</code>.</li>
<li>Repeat step 2 until we finish the iteration.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/iRUQDkZx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the linked list <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We iterate over <code>head</code>. During the iteration, there may be multiple operations on the stack, however, each index <code>cnt</code> is pushed to and popped from the stack at most once, so the total time in the worst-case scenario is <span class="math inline">\(O(n)\)</span>.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We only used a stack <code>stack</code>, there may be up to <span class="math inline">\(n\)</span> elements in <code>stack</code> thus it also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-atoms/description" target="_blank" rel="noopener noreferrer">Number of Atoms</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>formula</code> representing a chemical formula, return <em>the count of each atom</em>.</p>

<p>The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.</p>

<p>One or more digits representing that element&#39;s count may follow if the count is greater than <code>1</code>. If the count is <code>1</code>, no digits will follow.</p>

<ul>
	<li>For example, <code>&quot;H2O&quot;</code> and <code>&quot;H2O2&quot;</code> are possible, but <code>&quot;H1O2&quot;</code> is impossible.</li>
</ul>

<p>Two formulas are concatenated together to produce another formula.</p>

<ul>
	<li>For example, <code>&quot;H2O2He3Mg4&quot;</code> is also a formula.</li>
</ul>

<p>A formula placed in parentheses, and a count (optionally added) is also a formula.</p>

<ul>
	<li>For example, <code>&quot;(H2O2)&quot;</code> and <code>&quot;(H2O2)3&quot;</code> are formulas.</li>
</ul>

<p>Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than <code>1</code>), followed by the second name (in sorted order), followed by its count (if that count is more than <code>1</code>), and so on.</p>

<p>The test cases are generated so that all the values in the output fit in a <strong>32-bit</strong> integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> formula = &quot;H2O&quot;
<strong>Output:</strong> &quot;H2O&quot;
<strong>Explanation:</strong> The count of elements are {&#39;H&#39;: 2, &#39;O&#39;: 1}.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> formula = &quot;Mg(OH)2&quot;
<strong>Output:</strong> &quot;H2MgO2&quot;
<strong>Explanation:</strong> The count of elements are {&#39;H&#39;: 2, &#39;Mg&#39;: 1, &#39;O&#39;: 2}.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> formula = &quot;K4(ON(SO3)2)2&quot;
<strong>Output:</strong> &quot;K4N2O14S4&quot;
<strong>Explanation:</strong> The count of elements are {&#39;K&#39;: 4, &#39;N&#39;: 2, &#39;O&#39;: 14, &#39;S&#39;: 4}.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= formula.length &lt;= 1000</code></li>
	<li><code>formula</code> consists of English letters, digits, <code>&#39;(&#39;</code>, and <code>&#39;)&#39;</code>.</li>
	<li><code>formula</code> is always valid.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem, we are given a string <code>formula</code>, which represents a <strong>valid</strong> chemical formula. The <code>formula</code> follows certain rules, as mentioned in the problem description. We are supposed to return the count of each atom in the formula.</p>
<blockquote>
<p>An atom contains a UPPERCASE letter followed by zero or more lowercase letters.</p>
</blockquote>
<p>Since the problem revolves around <code>formula</code>, let's dissect the <code>formula</code> and understand what it contains.</p>
<p>A <code>formula</code> can contain the following</p>
<ul>
<li>
<p><strong>UPPERCASE LETTER</strong>: <code>A</code>, <code>B</code> ... <code>Z</code>. Let's denote the group as <strong>U</strong>.</p>
</li>
<li>
<p><strong>lowercase letter</strong>: <code>a</code>, <code>b</code> ... <code>z</code>. Let's denote the group as <strong>L</strong>.</p>
</li>
<li>
<p><strong>Digits</strong>: <code>0</code>, <code>1</code> ... <code>9</code>. Let's denote the group as <strong>D</strong>.</p>
</li>
<li>
<p><strong>Left Parenthesis</strong>: <code>(</code></p>
</li>
<li>
<p><strong>Right Parenthesis</strong>: <code>)</code></p>
</li>
</ul>
<p>Can we have <strong>L</strong> followed by <strong>D</strong>?<br />
Yes, the formula can contain a lowercase letter followed by a digit.</p>
<p>Can we have <strong>D</strong> followed by <strong>L</strong>?<br />
No, the formula cannot contain a digit followed by a lowercase letter. An atom begins with a UPPERCASE letter.</p>
<p>Hence, only certain groups can be followed by certain groups. Let's summarise it in a table. The (row, column) of this table comments on whether the group in the row can be followed by the group in the column, and further explains the significance of the combination.</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>U</strong></th>
<th><strong>L</strong></th>
<th><strong>D</strong></th>
<th><code>(</code></th>
<th><code>)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>U</strong></td>
<td>Yes. It will signify that the current atom has a one-character representation with an immediate count as 1</td>
<td>Yes. It will signify that the current atom has a multi-character representation</td>
<td>Yes. It will signify that the current atom has a one-character representation with a count greater than 1</td>
<td>Yes. It will signify that the current atom has a one-character representation with an immediate count as 1</td>
<td>Yes. It will signify that the current atom has a one-character representation with an immediate count as 1</td>
</tr>
<tr>
<td><strong>L</strong></td>
<td>Yes. It signifies that the atom of which this lowercase letter is a part has a multi-character representation with an immediate count as 1</td>
<td>Yes. It signifies that the atom of which this lowercase letter is a part has a multi-character representation</td>
<td>Yes. It signifies that the atom of which this lowercase letter is a part has a multi-character representation with a count greater than 1</td>
<td>Yes. It signifies that the atom of which this lowercase letter is a part has a multi-character representation with an immediate count as 1</td>
<td>Yes. It signifies that the atom of which this lowercase letter is a part has multi-character representation with immediate count as 1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>Yes. The immediate count of the current atom is greater than 1</td>
<td>No. A digit cannot be followed by a lowercase letter</td>
<td>Yes. The immediate count of the current atom is greater than or equal to 10</td>
<td>Yes. The immediate count of the current atom is greater than 1</td>
<td>Yes. The immediate count of the current atom is greater than 1</td>
</tr>
<tr>
<td><code>(</code></td>
<td>Yes. It signifies the beginning of a grouped formula</td>
<td>No. An atom begins with a UPPERCASE LETTER</td>
<td>No. Count cannot be allotted to a left parenthesis</td>
<td>Yes. It signifies the beginning of a grouped formula</td>
<td>No. A left parenthesis cannot be immediately followed by a right parenthesis</td>
</tr>
<tr>
<td><code>)</code></td>
<td>Yes. It signifies the end of a grouped formula</td>
<td>No. An atom begins with a UPPERCASE LETTER</td>
<td>Yes. It signifies the end of a grouped formula followed by the count</td>
<td>Yes. It signifies the end of a grouped formula, and the beginning of a new formula</td>
<td>Yes. It signifies the end of two nested grouped formulas</td>
</tr>
</tbody>
</table>
<p>The analysis might look a bit overwhelming, but it is important to understand the structure of a valid <code>formula</code>.</p>
<p>We can define the following <strong>skeleton</strong> to solve the problem.</p>
<blockquote>
<p>To find the count of each atom in the formula, we need to scan the string <code>formula</code>, and extract the atoms which may be followed by certain digits representing count. We need to extract those digits and save them as the count of the atom. If no digits are there, we will take the count as 1.</p>
<p>The parenthesis signifies the beginning of the nested formula, which we can analyze (and add) as mentioned in the above paragraph. The count of the nested formula will be multiplied by the count of atoms in the nested formula.</p>
</blockquote>
<p>Before moving further, let's emphasize the fact that for every character that we are going to scan, we need to check if it is in <strong>U</strong>, <strong>L</strong>, <strong>D</strong>, or equal to either of <code>(</code> or <code>)</code>.</p>
<details>
<summary>For this, we can define helper functions that will be helpful in the implementation. Click here to learn more about the helper functions.</summary>
<p>
<ul>
<li>
<p><code>is_upper(char)</code>: Returns <code>True</code> if <code>char</code> is an UPPERCASE LETTER, else <code>False</code>.</p>
<p>The logic can be as follows:</p>
<ul>
<li>
<p><code>char &gt;= 'A' and char &lt;= 'Z'</code></p>
</li>
<li>
<p><code>'A' &lt;= char &lt;= 'Z'</code></p>
</li>
<li>
<p>The ASCII value of <code>char</code> lies between <code>65</code> and <code>90</code> (inclusive).</p>
</li>
</ul>
<p>It is worth noting that many programming languages provide built-in functions to check if a character is a UPPERCASE LETTER.</p>
<ul>
<li>
<p>In Python, we can use <code>char.isupper()</code>. It is a method of the <code>str</code> class. More details can be found <a href="https://docs.python.org/3/library/stdtypes.html#str.isupper">here</a>.</p>
</li>
<li>
<p>In Java, we can use <code>Character.isUpperCase(char)</code>. It is a static method of the <code>Character</code> class. More details can be found <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#isUpperCase(char)">here</a>.</p>
</li>
<li>
<p>In C++, we can use <code>std::isupper(char)</code>. It is a function of the <code>cctype</code> library. More details can be found <a href="https://en.cppreference.com/w/cpp/string/byte/isupper">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><code>is_lower(char)</code>: Returns <code>True</code> if <code>char</code> is a lowercase letter, else <code>False</code>.</p>
<p>The logic can be as follows:</p>
<ul>
<li>
<p><code>char &gt;= 'a' and char &lt;= 'z'</code></p>
</li>
<li>
<p><code>'a' &lt;= char &lt;= 'z'</code></p>
</li>
<li>
<p>The ASCII value of <code>char</code> lies between <code>97</code> and <code>122</code> (inclusive).</p>
</li>
</ul>
<p>It is worth noting that many programming languages provide built-in functions to check if a character is a lowercase letter.</p>
<ul>
<li>
<p>In Python, we can use <code>char.islower()</code>. It is a method of the <code>str</code> class. More details can be found <a href="https://docs.python.org/3/library/stdtypes.html#str.islower">here</a>.</p>
</li>
<li>
<p>In Java, we can use <code>Character.isLowerCase(char)</code>. It is a static method of the <code>Character</code> class. More details can be found <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#isLowerCase(char)">here</a>.</p>
</li>
<li>
<p>In C++, we can use <code>std::islower(char)</code>. It is a function of the <code>cctype</code> library. More details can be found <a href="https://en.cppreference.com/w/cpp/string/byte/islower">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><code>is_digit(char)</code>: Returns <code>True</code> if <code>char</code> is a digit, else <code>False</code>.</p>
<p>The logic can be as follows:</p>
<ul>
<li>
<p><code>char &gt;= '0' and char &lt;= '9'</code></p>
</li>
<li>
<p><code>'0' &lt;= char &lt;= '9'</code></p>
</li>
<li>
<p>The ASCII value of <code>char</code> lies between <code>48</code> and <code>57</code> (inclusive).</p>
</li>
</ul>
<p>It is worth noting that many programming languages provide built-in functions to check if a character is a digit.</p>
<ul>
<li>
<p>In Python, we can use <code>char.isdigit()</code>. It is a method of the <code>str</code> class. More details can be found <a href="https://docs.python.org/3/library/stdtypes.html#str.isdigit">here</a>.</p>
</li>
<li>
<p>In Java, we can use <code>Character.isDigit(char)</code>. It is a static method of the <code>Character</code> class. More details can be found <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#isDigit(char)">here</a>.</p>
</li>
<li>
<p>In C++, we can use <code>std::isdigit(char)</code>. It is a function of the <code>cctype</code> library. More details can be found <a href="https://en.cppreference.com/w/cpp/string/byte/isdigit">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><code>str_to_int(string)</code>: Returns the integer representation of the string. It is assumed that the string contains only digits.</p>
<p>It is worth noting that many programming languages provide built-in functions to convert a string to an integer.</p>
<ul>
<li>
<p>In Python, we can use <code>int(string)</code>. More details can be found <a href="https://docs.python.org/3/library/functions.html#int">here</a>.</p>
</li>
<li>
<p>In Java, we can use <code>Integer.parseInt(string)</code>. More details can be found <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#parseInt(java.lang.String)">here</a>.</p>
</li>
<li>
<p>In C++, we can use <code>std::stoi(string)</code>. More details can be found <a href="https://en.cppreference.com/w/cpp/string/basic_string/stol">here</a>.</p>
</li>
</ul>
</li>
</ul>
</p>
<br>
</details>
<br/>
<p>With all tools in our hands, let's understand various ways to solve the problem.</p>
<hr />
<h3 id="approach-1-recursion">Approach 1: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's again focus on the <strong>skeleton</strong> that we defined in the <a href="#overview">Overview</a> section.</p>
<blockquote>
<p>To find the count of each atom in the formula, we need to scan the string <code>formula</code>, and extract the atoms which may be followed by certain digits representing count. We need to extract those digits and save them as the count of the atom. If no digits are there, we will take the count as 1.</p>
<p>The parenthesis signifies the beginning of the nested formula, which we can analyze (and add) as mentioned in the above paragraph. The count of the nested formula will be multiplied by the count of atoms in the nested formula.</p>
</blockquote>
<p>In the second paragraph, we are calling the methodology defined in the first paragraph. In other words, the skeleton uses the skeleton itself. Is there a programming paradigm that uses the same concept?<br />
Yes, it is called <strong>recursion</strong>.</p>
<blockquote>
<p><strong>Recursion</strong> is a programming paradigm where a function calls itself. The function solves a smaller instance of the same problem and then combines the result to solve the original problem. To avoid infinite recursion, there is a base case that stops the recursion.</p>
<p>To deeply understand recursion, it is advised to visit <a href="https://leetcode.com/explore/learn/card/recursion-i/">Recursion-I</a> and <a href="https://leetcode.com/explore/learn/card/recursion-ii/">Recursion-II</a> Explore Cards.</p>
</blockquote>
<p>Hence, we only need to narrow our attention to solve the <em>non-nested formula</em>. The <em>nested formula</em> will be solved using the same methodology.</p>
<p>Now, for parsing a <em>non-nested formula</em> (or recursively <em>nested formula</em>), we need information of the starting index of the formula. What can be the character at the starting index?</p>
<ul>
<li>
<p><strong>U</strong>: Yes, it should be a UPPERCASE LETTER.</p>
</li>
<li>
<p><strong>L</strong>: No, an atom cannot start with a lowercase letter.</p>
</li>
<li>
<p><strong>D</strong>: No, an atom cannot start with a digit.</p>
</li>
<li>
<p><code>(</code>: Yes, it can be a left parenthesis. However, in this case, we again need to recursively parse the formula inside the parenthesis, until the corresponding right parenthesis is found.</p>
</li>
<li>
<p><code>)</code>: No, a formula cannot start with a right parenthesis. However, it is important since it signifies the end of a nested formula.</p>
</li>
</ul>
<p>What should we return after parsing the formula?<br />
Any data structure that stores the (atom, count) as (key, value) pair. The data structure should be able to handle multiple atoms with their counts. A <code>dictionary</code> in Python, <code>HashMap</code> in Java, or <code>unordered_map</code> in C++ can be used.</p>
<p>Let's dive more into the nitty-gritty of the implementation. Since we are using the index as the input parameter, our entire decision-making will be based on the character at the index. The character can be of five types, as defined in the <a href="#overview">Overview</a>. Assuming our parsing is correct up to this index, the decision cases can be as follows.</p>
<ul>
<li>
<p><strong>U</strong>: It signifies the beginning of another atom. Thus, we need to reset our <code>curr_atom</code> variable in which we will save the current atom.</p>
<p>Before resetting, we need to check if the <code>curr_atom</code> is empty or not. If it is not empty, we need to save/add the count of the <code>curr_atom</code> in the local dictionary <code>curr_map</code> created for the current formula. If the variable <code>curr_count</code> is empty, we will take the count as 1. If it is not empty, we will take the count as <code>curr_count</code>.</p>
<p>After saving the <code>curr_atom</code> and <code>curr_count</code> in <code>curr_map</code>, we will reset the <code>curr_count</code> to an empty string and <code>curr_atom</code> to the current UPPERCASE LETTER.</p>
</li>
<li>
<p><strong>L</strong>: It is the continuation of the current atom. We will append the lowercase letter to the <code>curr_atom</code>.</p>
</li>
<li>
<p><strong>D</strong>: It signifies the count of the current atom. We will append the digit to the <code>curr_count</code>.</p>
</li>
<li>
<p><code>(</code>: It signifies the beginning of a nested formula. We will recursively parse the formula inside the parentheses. The result of the nested formula will be added to the <code>curr_map</code>.</p>
</li>
<li>
<p><code>)</code>: It signifies the end of a nested formula. The last saved <code>curr_atom</code> and <code>curr_count</code> should be saved in the <code>curr_map</code>.</p>
<p>Should we return <code>curr_map</code> right away?<br />
No, we need to multiply the multiplicity of the nested formula by the count of the atoms in the nested formula. For this, we will scan the digits after the right parentheses and save them in <code>multiplier</code>. If the <code>multiplier</code> is not empty, we will multiply the count of the atoms in the <code>curr_map</code> with the <code>multiplier</code> and return the <code>curr_map</code>.</p>
</li>
</ul>
<p>We are not returning the index in the recursive function. However, there is a workaround. We can use a global variable <code>index</code> which will be updated in the recursive function. Hence, at any point in time, the <code>index</code> will point to the character that we are currently parsing.</p>
<p>We are doing recursion, so we need a base case. What can be the base case?<br />
Well, the base case can be when the <code>index</code> is equal to the length of the <code>formula</code>. In this case, we need to save the <code>curr_atom</code> and <code>curr_count</code> in the <code>curr_map</code> and return the <code>curr_map</code>.</p>
<blockquote>
<p><strong>Additional Information:</strong> <em>Recursive Descent Parser</em> is a top-down parser that recursively parses the input. However, it may not be the best choice for parsing complex grammars.</p>
<p>If the grammar is unambiguous and the grammar is LL(1) (Left-to-right, Leftmost derivation, 1 lookahead), then a Recursive Descent Parser is a good choice.</p>
<p>For our <code>formula</code>, we can have the following grammar.</p>
<ul>
<li><span class="math inline">\(\mathcal{F} \rightarrow \mathcal{SF} \; \vert \; \epsilon\)</span></li>
<li><span class="math inline">\(\mathcal{S} \rightarrow (\mathcal{F})D \; \vert \; \mathcal{A} \mathcal{D}\)</span></li>
<li><span class="math inline">\(\mathcal{A} \rightarrow \mathcal{U} \; \vert \; \mathcal{UL}\)</span></li>
<li><span class="math inline">\(\mathcal{D} \rightarrow \mathcal{DD} \; \vert \; \epsilon\)</span></li>
<li><span class="math inline">\(\mathcal{U} \rightarrow A \; \vert \; B \; \vert \; C \; \vert \; \dots \; \vert \; Z\)</span></li>
<li><span class="math inline">\(\mathcal{L} \rightarrow a \; \vert \; b \; \vert \; c \; \vert \; \dots \; \vert \; z\)</span></li>
<li><span class="math inline">\(\mathcal{D} \rightarrow 0 \; \vert \; 1 \; \vert \; 2 \; \vert \; \dots \; \vert \; 9\)</span></li>
</ul>
<p>Here, terminals are <span class="math inline">\((\)</span>, <span class="math inline">\()\)</span>, <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>, <span class="math inline">\(\dots\)</span>, <span class="math inline">\(Z\)</span>, <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(\dots\)</span>, <span class="math inline">\(z\)</span>, <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, <span class="math inline">\(\dots\)</span>, <span class="math inline">\(9\)</span>.</p>
<p>The above grammar is Context Free Grammar (Type-2 in <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky Hierarchy</a>). It can be recognized by Pushdown Automata, which uses a stack to track nested parenthesis. This fact will be mildly used in <a href="#intuition-1">next approach</a>.</p>
</blockquote>
<p>We need to sort the map with respect to the atoms. This can be done using the built-in sorting functions of the programming language.</p>
<p>Finally, we need to generate the answer string. We will iterate over the sorted map and append the atom to the answer string. If the count of the atom is greater than 1, we will append the count of the atom to the answer string.</p>
<p>With all the information in hand, let's implement the solution.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Define a global variable <code>index</code> and set it to 0. It will be used to keep track of the current index in the <code>formula</code>.</p>
</li>
<li>
<p>Define a recursive function <code>parse_formula()</code> which will return a dictionary containing the count of atoms in the formula.</p>
<ul>
<li>
<p>Define a hashmap <code>curr_map</code> which will store the count of atoms in the current formula.</p>
</li>
<li>
<p>Define two strings <code>curr_atom</code> and <code>curr_count</code> which will store the current atom and count. Both will be initialized to an empty string.</p>
</li>
<li>
<p>Using the global variable <code>index</code>, iterate over the characters of the <code>formula</code>.</p>
<ul>
<li>
<p>If the character at the current <code>index</code> is an UPPERCASE LETTER:</p>
<ul>
<li>
<p>Save the previous atom and count in the <code>curr_map</code> if it exists.</p>
</li>
<li>
<p>Update the <code>curr_atom</code> to the current UPPERCASE LETTER and <code>curr_count</code> to an empty string.</p>
</li>
</ul>
</li>
<li>
<p>If the character at the current index is a lowercase letter, append the lowercase letter to the <code>curr_atom</code>.</p>
</li>
<li>
<p>If the character at the current index is a digit, append the digit to the <code>curr_count</code>.</p>
</li>
<li>
<p>If the character at the current index is a left parenthesis:</p>
<ul>
<li>
<p>Increment the <code>index</code>, and parse the formula inside the parenthesis by recursively calling the <code>parse_formula()</code> function. Store the result in a hashmap <code>nested_map</code>.</p>
</li>
<li>
<p>Add the count of atoms in the <code>nested_map</code> to the <code>curr_map</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the character at the current index is a right parenthesis:</p>
<ul>
<li>
<p>Save the previous atom and count in the <code>curr_map</code> if it exists.</p>
</li>
<li>
<p>Find the integer multiplier after the right parenthesis and store it in a string <code>multiplier</code>. If the <code>multiplier</code> is not empty, multiply the count of atoms in the <code>curr_map</code> with the <code>multiplier</code>.</p>
</li>
<li>
<p>Return the <code>curr_map</code>. Ensure that <code>index</code> points to the first non-digit character after the right parenthesis.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Before returning the <code>curr_map</code>, save the last atom and count in the <code>curr_map</code> if it exists. Return the <code>curr_map</code>.</p>
</li>
</ul>
</li>
<li>
<p>Parse the formula using the <code>parse_formula()</code> function and store the result in <code>final_map</code>.</p>
</li>
<li>
<p>Sort the <code>final_map</code> with respect to the atoms (which are the keys of the map).</p>
</li>
<li>
<p>Generate the answer string <code>ans</code> by iterating over the sorted map. Append the atom to the <code>ans</code>. If the count of the atom is greater than 1, append the count of the atom to the <code>ans</code>.</p>
</li>
<li>
<p>Return the <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/PinSnwXz/shared">code</a></p>
<p><strong>Implementation Note:</strong> Let's implement the above idea slightly differently. In the code, we can see that we return the <code>curr_map</code> if <code>formula[index]</code> is <code>')'</code>. This we can merge with the last return statement. Moreover, whenever we encounter a UPPERCASE LETTER, we can find corresponding lowercase letters and digits in one go.</p>
<p><a href="https://leetcode.com/playground/kAVQp4Ub/shared">code</a></p>
<p><strong>Task:</strong> Global variables are <em>not</em> recommended in programming. Readers are encouraged to implement and comment below their recursive solution without using global variables.</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>formula</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The recursive function <code>parse_formula()</code> will be called <span class="math inline">\(O(N)\)</span> times.</p>
<p>However, we are iterating over the atoms of the nested formula to add the count to the current formula. This will take time equal to the number of atoms in the nested formula. The number of atoms in the nested formula can be equal to <span class="math inline">\(O(N)\)</span>. Thus, the time complexity of the recursive function will be <span class="math inline">\(O(N^2)\)</span>.</p>
<blockquote>
<p>One such example of worst case is <code>(A(B(C(D(E(F(G(H(I(J(K(L(M(N(O(P(Q(R(S(T(U(V(W(X(Y(Z)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)2)</code>. In this case, whenever we encounter a right parenthesis, we will have to iterate over all the atoms in the nested formula to add the count to the current formula.</p>
</blockquote>
<blockquote>
<p>In actual it is <span class="math inline">\(O(PN)\)</span> where <span class="math inline">\(P\)</span> is the number of paranthese pairs. Here <span class="math inline">\(P\)</span> can be at most <span class="math inline">\(N/2\)</span>, or <span class="math inline">\(P = O(N)\)</span>. However, <span class="math inline">\(P\)</span> is not a function of input size. Hence, we shouldn't consider it in the time complexity.</p>
</blockquote>
<p>Sorting will take <span class="math inline">\(O(N \log N)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language. Generating the answer string will take <span class="math inline">\(O(N)\)</span> time.</p>
<p>Hence, the overall time complexity will be <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity will be <span class="math inline">\(O(N)\)</span> due to the space used by the recursive function call stack.</p>
<p>The space used by the <code>final_map</code> will be <span class="math inline">\(O(N)\)</span>. Moreover, we are sorting the <code>final_map</code>. In sorting, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language, but it will be <span class="math inline">\(O(N)\)</span>.</p>
<p>The space used by the answer string <code>ans</code> will be <span class="math inline">\(O(N)\)</span>.</p>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-stack">Approach 2: Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The <a href="#approach-1-recursion">Approach 1</a> uses recursion to parse the formula. The recursion is a powerful tool to solve problems where the structure of the input is recursive. Recursion internally uses a stack to keep track of the function calls.</p>
<blockquote>
<p>Unfolding a recursion can be done by replacing the role of the system call stack. At each occurrence of recursion, we push the parameters as a new element into the data structure that we created, instead of invoking a recursion. More details can be found in <a href="https://leetcode.com/explore/learn/card/recursion-ii/503/recursion-to-iteration/2693/">Recursion explore card</a></p>
</blockquote>
<blockquote>
<p><strong>Stack</strong> is a linear data structure that follows the Last In First Out (LIFO) principle. To understand the stack in depth, it is advised to visit <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/1369/">Stack explore card</a>.</p>
</blockquote>
<p>In this approach, we will unfold the recursion using a stack. Instead of making a recursive call to parse the formula inside the parenthesis, we will use a stack to keep track of the atoms and their counts of the nested formula. The result of the nested formula will be added to the current formula (which itself may be a nested formula for some other formula).</p>
<p>Hence, in the stack, our initial top element would be an empty hashmap. It will store the final count of atoms in the formula.</p>
<p>We will populate the hashmap as we parse the formula. When we encounter a left parenthesis, we will push another empty hashmap to the stack. It will store the count of atoms in the nested formula. When we encounter the corresponding right parenthesis, we will pop the top element from the stack, multiply the count with the multiplicity of the nested formula, and add the count to the current formula (which would then be on the top of the stack).</p>
<p>Since each left parenthesis will have a corresponding right parenthesis, in the end, the stack will have only one element (which we pushed initially). This element will contain the total count of atoms in the formula.</p>
<blockquote>
<p><strong>Additional Information:</strong> As mentioned in the <a href="#intuition">intuition of Approach 1</a>, the grammar of the <code>formula</code> can be recognized by Pushdown Automata, which uses a stack. Hence, this approach is inspired by pushdown automata.</p>
</blockquote>
<p>The following animation visualizes the intuition for the input <code>&quot;Na2ZnRb5(PuS11(SH)6W)2(H2S)Unu8Pu&quot;</code></p>
<p>!?!../Documents/726/726_slideshow_stack.json:960,540!?!<br />
<br/></p>
<p>Readers are encouraged to implement the solution on their own.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize a stack <code>stack</code>. The top element of the stack will be an empty hashmap. It will store the count of atoms in the <code>formula</code>.</p>
</li>
<li>
<p>Initialize the integer <code>index</code> to 0. It will keep track of the current character in the <code>formula</code>.</p>
</li>
<li>
<p>Iterate over the characters of the <code>formula</code> using the index <code>index</code>.</p>
<ul>
<li>
<p>If the character at the current index is a left parenthesis, push an empty hashmap to the stack. It will store the count of atoms in the nested formula.</p>
</li>
<li>
<p>If the character at the current index is a right parenthesis, pop the top element from the <code>stack</code>.</p>
<ul>
<li>
<p>Find the multiplier after the right parenthesis and store it in <code>multiplier</code>. If the <code>multiplier</code> is not empty, multiply the count of atoms in the popped hashmap with the <code>multiplier</code>.</p>
</li>
<li>
<p>Add the count of atoms in the popped hashmap to the hashmap which is on the top of the <code>stack</code>.</p>
</li>
</ul>
</li>
<li>
<p>Otherwise, it should be a UPPERCASE LETTER. Extract the complete atom with frequency and add it to the hashmap which is on the top of the <code>stack</code>.</p>
</li>
</ul>
</li>
<li>
<p>Sort the hashmap which is on the top of the <code>stack</code> using the keys.</p>
</li>
<li>
<p>Generate the answer string <code>ans</code> by iterating over the sorted hashmap. Append the atom to the <code>ans</code>. If the count of the atom is greater than 1, append the count of the atom to the <code>ans</code>.</p>
</li>
<li>
<p>Return the <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YkydLJc5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>formula</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The stack will have at most <span class="math inline">\(O(N)\)</span> elements. Each element will be popped and pushed at most once. However, since we need to revisit the atoms in the nested formula to add the count to the current formula, in the worst case, the time complexity of the stack operations will be <span class="math inline">\(O(N^2)\)</span>.</p>
<p>Sorting will take <span class="math inline">\(O(N \log N)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language. Generating the answer string will take <span class="math inline">\(O(N)\)</span> time.</p>
<p>Hence, the overall time complexity will be <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space used by the <code>stack</code> will be <span class="math inline">\(O(N)\)</span>.</p>
<p>The space used by the <code>final_map</code> will be <span class="math inline">\(O(N)\)</span>. Moreover, we are sorting the <code>final_map</code>. In sorting, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language. However, it will be <span class="math inline">\(O(N)\)</span>.</p>
<p>The space used by the answer string <code>ans</code> will be <span class="math inline">\(O(N)\)</span>.</p>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-regular-expression">Approach 3: Regular Expression</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this problem, we are parsing a string to extract the atoms and their counts. Parsing is often associated with regular expressions. Regular expressions are a powerful tool to match patterns in strings.</p>
<blockquote>
<p><strong>Regular Expression</strong> is a sequence of characters that define a search pattern. It is used to match character combinations in strings. To understand regular expressions in depth, readers can solve <a href="https://leetcode.com/problems/regular-expression-matching/description/">Regular Expression Matching</a> problem.</p>
<p>To understand the regular expression more formally, readers can visit <a href="https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory">Wikipedia</a></p>
</blockquote>
<p>Let's understand a few examples of regular expressions used in daily life.</p>
<ul>
<li>
<p><strong>Dates</strong> can be matched using regular expressions. For example, a date in the format <code>mm/dd/yyyy</code> can be matched using the regular expression <code>(0[1-9]|1[0-2])/(0[1-9]|[12][0-9]|3[01])/\d{4}</code>.</p>
<ul>
<li>
<p><code>(0[1-9] | 1[0-2])</code> signifies the month should be between 01 and 12. It briefly lists <code>01</code>, <code>02</code>, <code>03</code>, <code>04</code>, <code>05</code>, <code>06</code>, <code>07</code>, <code>08</code>, <code>09</code>, <code>10</code>, <code>11</code>, and <code>12</code>. The <code>|</code> signifies logical OR.</p>
</li>
<li>
<p><code>(0[1-9] | [12][0-9] | 3[01])</code> signifies the day should be between 01 and 31. It briefly lists <code>01</code>, <code>02</code>, <code>03</code>, <code>04</code>, <code>05</code>, <code>06</code>, <code>07</code>, <code>08</code>, <code>09</code>, <code>10</code>, <code>11</code>, <code>12</code>, <code>13</code>, <code>14</code>, <code>15</code>, <code>16</code>, <code>17</code>, <code>18</code>, <code>19</code>, <code>20</code>,</p>
</li>
<li>
<p><code>\d{4}</code> signifies the year should be a 4-digit number. The <code>\d</code> is used to match a digit, and <code>{4}</code> is used to convey that there should be exactly 4 digits.</p>
</li>
</ul>
</li>
<li>
<p><strong>Phone Numbers</strong> can be matched using regular expressions. For example, a phone number in the format <code>xxx-xxx-xxxx</code> can be matched using the regular expression <code>\d{3}-\d{3}-\d{4}</code>.</p>
</li>
<li>
<p><strong>Emails</strong> can be validated using <code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$</code></p>
</li>
<li>
<p>To <strong>ensure a strong password</strong> we can use <code>^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;])[A-Za-z\d@$!%*?&amp;]{8,}$</code>. It will ensure that the password should have at least 8 characters, one UPPERCASE letter, one lowercase letter, one digit, and one special character.</p>
</li>
</ul>
<blockquote>
<p>It is worth noting that in different programming languages, the syntax of regular expressions can vary. Hence, it is <strong>strongly advised</strong> to visit the official documentation of the programming language. Scroll down to <a href="#implementation-2">implementation</a> for language-specific notes.</p>
</blockquote>
<p><strong>How is regular expression relevant to this problem?</strong></p>
<p>The atom along with its count is a regular expression</p>
<ul>
<li>It begins with an UPPERCASE LETTER,</li>
<li>Followed by zero or more lowercase letters,</li>
<li>Followed by zero or more digits.</li>
</ul>
<p>The regular expression will be <span class="math inline">\(UL^*D^*\)</span>. In code, it will be <code>[A-Z][a-z]*\d*</code>. Hence, we can extract the atom and their count using this regular expression.</p>
<blockquote>
<p>Since we want atoms and count separately, we will use two tuples. The first tuple will contain the atom and the second tuple will contain the count. It will be <code>([A-Z][a-z]*)(\d*)</code>.</p>
</blockquote>
<p>However, we didn't take into account the nestedness. For that, let's extract the parenthesis as well.</p>
<ul>
<li>The regular expression for the left parenthesis will be <code>\(</code>.</li>
<li>The regular expression for the right parenthesis followed by the multiplier will be <code>(\))(\d*)</code>. The grouping ensures that we can extract the multiplier separately.</li>
</ul>
<p>Hence, we can scan these five entities (atom, count, left parenthesis, right parenthesis, and multiplier) in the <code>formula</code> using regular expressions.</p>
<p>As done in <a href="#approach-2-stack">stack approach</a>, whenever we encounter a left parenthesis, we will push an empty hashmap to the stack. Whenever we encounter a right parenthesis, we will pop the top element from the stack, multiply the count with the multiplicity of the nested formula, and add the count to the current formula (which would then be on the top of the stack).</p>
<blockquote>
<p><strong>Additional Information:</strong> In <a href="#intuition">Approach 1</a>, we mentioned that <code>formula</code> can be represented using Context Free Grammar (CFG).</p>
<p>In this approach we are using regular expressions to parse the <code>formula</code>. Regular expressions can be represented using Regular Grammar.</p>
<p>Regular Grammar (Type-3) is a subset of CFG (Type-2). It is less expressive than CFG. For CFG, we have <em>pushdown automata</em>, while for Regular Grammar, we have <em>finite automata</em>.</p>
</blockquote>
<p><strong>We are using stack, then how is it different from <a href="#approach-2-stack">Approach 2</a>?</strong><br />
In this approach, we won't be manually extracting atoms and counts, it will be done using regular expressions. We will be using stack only to ensure that the nested formula gets multiplied with the correct multiplicity.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Define a regular expression <code>regex</code> to extract the atom, count, left parenthesis, right parenthesis, and corresponding multiplier as quintuples. Deep dive into the documentation of your preferred programming language to formulate the required regular expression.</p>
</li>
<li>
<p>Using <code>regex</code>, find all the occurrences of the quintuples in the <code>formula</code>. Store the result in <code>matcher</code>.</p>
</li>
<li>
<p>Initialize a stack <code>stack</code> to keep track of the atoms and their counts. The top element of the stack will be an empty hashmap. It will store the count of atoms in the <code>formula</code>.</p>
<p>The more the distance of the top element is from the bottom element, the more nested the formula is.</p>
</li>
<li>
<p>Iterate over all the quintuples <code>(atom, count, left, right, multiplier)</code> in the parsed <code>formula</code> using the <code>matcher</code>.</p>
<ul>
<li>
<p>If the <code>atom</code> is not empty, then add it to the top hashmap of the <code>stack</code>. If the <code>count</code> is empty, the corresponding value will be incremented by 1. Otherwise, the corresponding value will be incremented by the <code>count</code>.</p>
</li>
<li>
<p>Else if the <code>left</code> is not empty, push an empty hashmap to the <code>stack</code>. It signifies the beginning of a nested formula.</p>
</li>
<li>
<p>Else if the <code>right</code> is not empty, pop the top element as <code>curr_map</code> from the <code>stack</code>. If the <code>multiplier</code> is not empty, multiply the count of atoms in the <code>curr_map</code> with the <code>multiplier</code>.</p>
<p>Add the count of atoms in the <code>curr_map</code> to the hashmap which is on the top of the stack.</p>
</li>
</ul>
</li>
<li>
<p>Sort the hashmap which is on the top of <code>stack</code> using the keys.</p>
</li>
<li>
<p>Generate the answer string <code>ans</code> by iterating over the sorted hashmap. Append the atom to the <code>ans</code>. If the count of the atom is greater than 1, append the count of the atom to the <code>ans</code>.</p>
</li>
<li>
<p>Return the <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/HEQduowX/shared">code</a></p>
<p><strong>Implementation Note:</strong> Ensure that the regular expression is correct, and doesn't include any extra spaces. Moreover, it is <strong>strongly advised</strong> to visit the official documentation to understand the nitty-gritty of regular expressions in the programming language.</p>
<ul>
<li>For Python, readers can visit the documentation of <a href="https://docs.python.org/3/library/re.html">re</a> module.</li>
<li>For Java, readers can visit the documentation of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a> class.</li>
<li>For C++, readers can visit documentation of <a href="https://en.cppreference.com/w/cpp/regex">regex</a> library.</li>
</ul>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>formula</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span></p>
<ul>
<li>
<p>Parsing the <code>regex</code> in the <code>formula</code> will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>There will be at most <span class="math inline">\(O(N)\)</span> quintuples in the <code>matcher</code>. Now, since for the right parenthesis, we need to revisit the atoms in the nested formula to add the count to the current formula, in the worst case, the time complexity of the stack operations will be <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Sorting will take <span class="math inline">\(O(N \log N)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
</li>
<li>
<p>Generating the answer string will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the overall time complexity will be <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<ul>
<li>
<p>There will be at most <span class="math inline">\(O(N)\)</span> quintuples in the <code>matcher</code>.</p>
</li>
<li>
<p>The space used by the stack will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>final_map</code> will be <span class="math inline">\(O(N)\)</span>. Moreover, we are sorting the <code>final_map</code>. In sorting, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language. However, it will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the answer string <code>ans</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-reverse-scanning">Approach 4: Reverse Scanning</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In all the approaches we have discussed so far, whenever we encounter a right parenthesis, we need to traverse backward (in a way) to ensure that multiplicity is applied to the atoms in the nested formula.</p>
<p>This is primarily because we get to know about the multiplicity of the nested formula only after the end of the nested formula. Hence, we need to revisit the atoms in the nested formula to apply the multiplicity.</p>
<p><strong>What if we could know the multiplicity of the nested formula in the beginning itself?</strong><br />
Then we can apply the multiplicity to the atoms as we parse them. This will eliminate the need to revisit the atoms in the nested formula.</p>
<p><strong>How can we know the multiplicity of the nested formula in the beginning itself?</strong><br />
By traversing right-to-left, we can know the multiplicity of the nested formula in the beginning itself.</p>
<p>As soon as we encounter a number followed by a right parenthesis, we can store the multiplicity.<br />
<em>(Note that number followed by lowercase letter will be count, and not multiplicity)</em></p>
<p><strong>However, what if we encounter a left parenthesis?</strong><br />
Then the most recent multiplicity will cease to exist. Accessing the most recent element can be done using the Last-in-First-Out (LIFO) principle. Hence, we can use a stack to store the multiplicity.</p>
<p>To fasten the process, we can use an integer <code>multiplier</code> to store the current multiplier, which will be the product of all the multipliers in the stack. Initially, the <code>multiplier</code> will be 1.</p>
<ul>
<li>On encountering <code>)</code>, we need to multiply the <code>multiplier</code> with the just scanned multiplier.</li>
<li>On encountering <code>(</code>, we need to divide the <code>multiplier</code> by the popped element from the stack.</li>
</ul>
<p>Readers are encouraged to implement the solution on their own. Plan all the cases that we need to take care of while scanning from right to left.</p>
<p>It is worth noting that for forming atoms and count, we won't &quot;append&quot; the characters. Instead, we will &quot;prepend&quot; the characters. This is because we are scanning the <code>formula</code> in reverse. Moreover, a UPPERCASE LETTER signifies the end of the scanning of the atom and not the beginning.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Initialize the integer <code>running_mul</code> to 1. It will store the valid multiplier for atoms to be scanned.</p>
</li>
<li>
<p>Initialize the stack <code>stack</code> to store the multipliers. Push <code>1</code> to the stack. The product of elements in the stack will be the valid multiplier for atoms to be scanned, which is also stored in <code>running_mul</code>.</p>
</li>
<li>
<p>Initialize the hashmap <code>final_map</code> to store the count of atoms.</p>
</li>
<li>
<p>Initialize the strings <code>curr_atom</code> and <code>curr_count</code> to store the current atom and count.</p>
</li>
<li>
<p>Traverse right-to-left in the <code>formula</code> using the iterator <code>index</code>.</p>
<ul>
<li>
<p>If the character at the current index is a digit, prepend it to the <code>curr_count</code>.</p>
</li>
<li>
<p>If the character at the current index is a lowercase letter, prepend it to the <code>curr_atom</code>.</p>
</li>
<li>
<p>If the character at the current index is an UPPERCASE LETTER, prepend it to the <code>curr_atom</code>. Now, the <code>curr_atom</code> is complete.</p>
<ul>
<li>
<p>Add the <code>curr_atom</code> to the <code>final_map</code>. If the <code>curr_count</code> is not empty, the value of the <code>curr_atom</code> will be the product of <code>curr_count</code> and <code>running_mul</code>. Otherwise, the value of the <code>curr_atom</code> will be <code>running_mul</code>.</p>
</li>
<li>
<p>Reset the <code>curr_atom</code> and <code>curr_count</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the character at the current index is a right parenthesis, the <code>curr_count</code>, if any, will be considered as <code>curr_multiplier</code>. If <code>curr_count</code> is empty, <code>curr_multiplier</code> will be 1.</p>
<ul>
<li>
<p>Push the <code>curr_multiplier</code> to the <code>stack</code>.</p>
</li>
<li>
<p>Multiply the <code>running_mul</code> by the <code>curr_multiplier</code>.</p>
</li>
<li>
<p>Reset the <code>curr_count</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the character at the current index is a left parenthesis, divide the <code>running_mul</code> by the popped element from the <code>stack</code>.</p>
</li>
</ul>
</li>
<li>
<p>Sort the <code>final_map</code> using the keys.</p>
</li>
<li>
<p>Generate the answer string <code>ans</code> by iterating over the sorted <code>final_map</code>. Append the atom to the <code>ans</code>. If the count of the atom is greater than 1, append the count of the atom to the <code>ans</code>.</p>
</li>
<li>
<p>Return the <code>ans</code>.</p>
</li>
</ol>
<p>The following animation visualizes the algorithm.</p>
<p>!?!../Documents/726/726_slideshow_reverse_scanning.json:960,540!?!<br />
<br/></p>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/hQeATxFn/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>formula</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span></p>
<ul>
<li>
<p>Declaring and Initializing the variables before the <code>while</code> loop will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>The <code>while</code> loop will run <span class="math inline">\(O(N)\)</span> times. The number of steps in one <code>while</code> loop depends on the character at the current index.</p>
<ul>
<li>
<p>In the case of a digit, lowercase letter, or UPPERCASE LETTER, we are prepending the characters. Appending is <span class="math inline">\(O(1)\)</span> operation, however, prepending is <span class="math inline">\(O(N)\)</span> operation.</p>
<blockquote>
<p><code>s = s + a</code> is different from <code>s = a + s</code>. The former can be augmented as <code>s += a</code>, while the latter can't be augmented.</p>
<p>Although it may vary with programming language, in general, inserting at the end is <span class="math inline">\(O(1)\)</span> operation, while inserting at the beginning is <span class="math inline">\(O(N)\)</span> operation.</p>
</blockquote>
<blockquote>
<p>The worst case example of this can be when the <code>formula</code> is <code>&quot;Qabcdefghij&quot;</code>.</p>
</blockquote>
</li>
<li>
<p>In the case of the left parenthesis, we are converting the string <code>curr_count</code> to integer <code>curr_multiplier</code>. This may take <span class="math inline">\(O(N)\)</span> time in the worst case. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>In the case of the right parenthesis, we are updating the <code>running_mul</code> and <code>stack</code>. This will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the time complexity of the <code>while</code> loop will be <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Sorting will take <span class="math inline">\(O(N \log N)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
</li>
<li>
<p>Generating the answer string will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the overall time complexity will be <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<ul>
<li>
<p>The <code>stack</code> may have at most <span class="math inline">\(O(N)\)</span> elements.</p>
</li>
<li>
<p>The space used by the <code>final_map</code> will be <span class="math inline">\(O(N)\)</span>. Moreover, we are sorting the <code>final_map</code>. In sorting, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language. However, it will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>ans</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>curr_atom</code> and <code>curr_count</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>running_mul</code> will be <span class="math inline">\(O(1)\)</span>, since it is of integer type, which allocates fixed space.</p>
</li>
</ul>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-preprocessing">Approach 5: Preprocessing</h3>
<h4 id="intuition-4">Intuition</h4>
<p>In <a href="#approach-4-reverse-scanning">previous approach</a>, the bottleneck in the <code>while</code> loop (as mentioned in the <a href="#complexity-analysis-3">complexity analysis</a> section) was</p>
<blockquote>
<p>Prepending the characters to <code>curr_atom</code> and <code>curr_count</code> was taking <span class="math inline">\(O(N)\)</span> time.</p>
</blockquote>
<p><em>The alternative is to NOT prepend the characters. Instead, we can append the characters and reverse the string before using it. Since there will be at most <span class="math inline">\(O(N)\)</span> characters in the string, reversing the string will take <span class="math inline">\(O(N)\)</span> time. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>. Readers are encouraged to implement the solution on their own and comment their implementation below.</em></p>
<p>In this approach, we will pre-process the <code>formula</code> to make the left-to-right parsing easier. For every index, we will store the valid multiplier beforehand.</p>
<blockquote>
<p>Pre-processing is a common technique to make the actual processing easier.</p>
</blockquote>
<p>As done in <a href="#approach-4-reverse-scanning">Approach 4</a>, we will use a stack to store the multipliers.<br />
We can use another array <code>muls</code> to store the valid multiplier for every index. After this pre-processing, we can traverse the <code>formula</code> left-to-right, and apply the multiplier to the atoms as we scan them. During left-to-right traversal, we can append the characters to <code>curr_atom</code> and <code>curr_count</code>, which is a constant time operation.</p>
<p>Let's see if it helps in optimizing the runtime.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ol>
<li>
<p>Initialize the array <code>muls</code> to store the valid multiplier for every index. Initialize the integer <code>running_mul</code> to 1. It will store the valid multiplier for atoms to be scanned.</p>
</li>
<li>
<p>Initialize the stack <code>stack</code> to store the multipliers. Push <code>1</code> to the stack. The product of elements in the stack will be the valid multiplier for atoms to be scanned, which is also stored in <code>running_mul</code>.</p>
</li>
<li>
<p>Initialize the empty string <code>curr_number</code> to store the current number.</p>
</li>
<li>
<p>Do the pre-processing by traversing right-to-left in the <code>formula</code> using the iterator <code>index</code>, which is initialized to the <code>formula.length() - 1</code>.</p>
<ul>
<li>
<p>If the character at the current index is a digit, append it to the <code>curr_number</code>.</p>
</li>
<li>
<p>If the character at the current index is a letter, it means the scanned number was count and not a multiplier. Discard the <code>curr_number</code>.</p>
</li>
<li>
<p>If the character at the current index is a right parenthesis, the scanned number was multiplier. However, it was scanned in reverse.</p>
<ul>
<li>
<p>If <code>curr_number</code> is not empty, reverse it and convert it to an integer in the variable <code>curr_multiplier</code>. If it was empty, <code>curr_multiplier</code> will be 1.</p>
</li>
<li>
<p>Multiply the <code>running_mul</code> by the <code>curr_multiplier</code>.</p>
</li>
<li>
<p>Push the <code>curr_multiplier</code> to the <code>stack</code>.</p>
</li>
<li>
<p>Reset the <code>curr_number</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the character at the current index is a left parenthesis, the most recent multiplier will cease to exist. Hence, divide the <code>running_mul</code> by the popped element from the <code>stack</code>. Moreover, reset the <code>curr_number</code>.</p>
</li>
<li>
<p>Append the <code>running_mul</code> to the <code>muls</code>.</p>
</li>
</ul>
</li>
<li>
<p>Reverse the <code>muls</code>.</p>
</li>
<li>
<p>Initialize the hashmap <code>final_map</code> to store the count of atoms.</p>
</li>
<li>
<p>Process the <code>formula</code> left-to-right using the iterator <code>index</code>, which is initialized to 0.</p>
<p>If the character at the current index is a UPPERCASE LETTER, extract the entire atom and count (which by default should be 1). Add into the <code>final_map</code> the atom and count, multiplied by the valid multiplier at the current index.</p>
</li>
<li>
<p>Sort the <code>final_map</code> using the keys.</p>
</li>
<li>
<p>Generate the answer string <code>ans</code> by iterating over the sorted <code>final_map</code>. Append the atom to the <code>ans</code>. If the count of the atom is greater than 1, append the count of the atom to the <code>ans</code>.</p>
</li>
<li>
<p>Return the <code>ans</code>.</p>
</li>
</ol>
<p>Here's how <code>muls</code> should look like for the input <code>&quot;K4(ON(SO3)2)2&quot;</code>. The only values of <code>muls</code> we ultimately care about are</p>
<ul>
<li>On the last letter of the atom, if there is no associated number.</li>
<li>On the last number of the digit followed by an atom.</li>
</ul>
<p>The remaining values are intermediate values that helped us in producing the values we care about.</p>
<p><img src="../Figures/726/726_slide_images_used/Slide1.PNG" alt="muls_array" /><br />
<br/></p>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/cxxwk3ND/shared">code</a></p>
<p><strong>Implementation Note:</strong> In the above implementation</p>
<ul>
<li>We are reversing a string <code>curr_number</code></li>
<li>We are converting variables <code>curr_number</code> and <code>curr_count</code> to integer.</li>
</ul>
<p>We can avoid both of these if we form integers from characters as we scan them. This will need a little bit of Mathematics. Readers are encouraged to implement the solution on their own and comment their implementation below.</p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>formula</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<ul>
<li>
<p>The while loop of pre-processing will have <span class="math inline">\(O(N)\)</span> iterations.</p>
<ul>
<li>
<p>When the current character is alphanumeric, or left parenthesis, the time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>When the current character is a right parenthesis, the time complexity can be <span class="math inline">\(O(N)\)</span> in the worst case, because of the string reversal and conversion to integer. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<p>Hence, the time complexity of pre-processing will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Reversing the <code>muls</code> will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>The while loop of the processing will have <span class="math inline">\(O(N)\)</span> iterations.</p>
<p>Every character will be processed at most twice, once during extracting, and other during storing.</p>
<p>Hence, the time complexity of the processing will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Sorting will take <span class="math inline">\(O(K \log K)\)</span> time, where <span class="math inline">\(K\)</span> is the number of unique atoms. In the worst case, <span class="math inline">\(K\)</span> can be equal to <span class="math inline">\(N\)</span>. It is worth noting that this may vary depending on the implementation of the sorting algorithm in the programming language.</p>
</li>
<li>
<p>Generating the answer string will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the overall time complexity will be <span class="math inline">\(O(N + N + N \log N + N)\)</span>, which is <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<ul>
<li>
<p>The space used by the <code>muls</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>stack</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>final_map</code> will be <span class="math inline">\(O(N)\)</span>. Moreover, we are sorting the <code>final_map</code>. In sorting, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language. However, it will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the answer string <code>ans</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-6-reverse-scanning-with-regex">Approach 6: Reverse Scanning with Regex</h3>
<h4 id="intuition-5">Intuition</h4>
<p>In <a href="#approach-4-reverse-scanning">Approach-4</a>, the bottleneck in the <code>while</code> loop (as mentioned in the <a href="#complexity-analysis-3">complexity analysis</a> section) was</p>
<blockquote>
<p>Prepending the characters to <code>curr_atom</code> and <code>curr_count</code> was taking <span class="math inline">\(O(N)\)</span> time.</p>
</blockquote>
<p>The purpose of prepending was to extract atoms and count. However, we have seen in <a href="#approach-3-regular-expression">Approach 3</a> that regular expressions can be used to extract atoms and counts.</p>
<p>After extracting the atoms and counts, we can do reverse scanning to ensure that in each nested formula, the atoms are multiplied by the correct multiplicity. This approach is inspired by the same thought process.</p>
<blockquote>
<p>We have achieved <span class="math inline">\(O(N \log N)\)</span> time complexity in <a href="#approach-5-preprocessing">Approach 5</a>. Can we do better than this?<br />
Practically, it is difficult to achieve better time complexity than <span class="math inline">\(O(N \log N)\)</span>, because sorting will take at least <span class="math inline">\(O(N \log N)\)</span> time. Since we have to sort the strings, the non-comparison based sorting algorithms (counting sort, radix sort, bucket sort) can't be used.</p>
</blockquote>
<p>Readers are encouraged to implement the solution on their own. It will be a combination of <a href="#approach-3-regular-expression">Approach 3</a> and <a href="#approach-4-reverse-scanning">Approach 4</a>, but somewhat concise and optimized.</p>
<h4 id="algorithm-5">Algorithm</h4>
<ol>
<li>
<p>Define a regular expression <code>regex</code> to extract the atom, count, left parenthesis, right parenthesis, and corresponding multiplier as quintuples. Deep dive into the documentation of your preferred programming language to formulate the required regular expression.</p>
</li>
<li>
<p>Using <code>regex</code>, find all the occurrences of the quintuples in the <code>formula</code>. Store the result in <code>matcher</code>, and reverse it.</p>
</li>
<li>
<p>Initialize the hashmap <code>final_map</code> to store the count of atoms.</p>
</li>
<li>
<p>Initialize the stack <code>stack</code> to keep track of the nested multiplicities. Push integer <code>1</code> to the stack.</p>
</li>
<li>
<p>Initialize the integer <code>running_mul</code> to 1. It will store the valid multiplier for atoms to be scanned.</p>
</li>
<li>
<p>Parse the formula by iterating over the <code>matcher</code>.</p>
<ul>
<li>
<p>If the current element is an atom, add it to the <code>final_map</code>.</p>
<p>The value will be the product of the count and the <code>running_mul</code>. If the count is not present, the value will be <code>1 * running_mul</code>.</p>
</li>
<li>
<p>If the current element is a right parenthesis.</p>
<ul>
<li>
<p>If the <code>multiplier</code> is present, multiply the <code>running_mul</code> by the <code>multiplier</code>. Push the <code>multiplier</code> to the <code>stack</code>.</p>
</li>
<li>
<p>If the <code>multiplier</code> is not present, push <code>1</code> to the <code>stack</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the current element is a left parenthesis, divide the <code>running_mul</code> by the popped element from the <code>stack</code>.</p>
</li>
</ul>
</li>
<li>
<p>Sort the <code>final_map</code> using the keys.</p>
</li>
<li>
<p>Generate the answer string <code>ans</code> by iterating over the sorted <code>final_map</code>. Append the atom to the <code>ans</code>. If the count of the atom is greater than 1, append the count of the atom to the <code>ans</code>.</p>
</li>
<li>
<p>Return the <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation-5">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ww8oR9Bp/shared">code</a></p>
<h4 id="complexity-analysis-5">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of the <code>formula</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<ul>
<li>
<p>The time complexity of finding all the quintuples using regular expression will depend on the programming language. In general, it will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The time complexity of the <code>for</code> loop will be <span class="math inline">\(O(N)\)</span>.</p>
<ul>
<li>
<p>If atom, adding it to the <code>final_map</code> will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>If the right parenthesis, multiplying the <code>running_mul</code> and pushing the multiplier to the <code>stack</code> will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>If left parenthesis, dividing the <code>running_mul</code> by the popped element from the <code>stack</code> will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Sorting will take <span class="math inline">\(O(K \log K)\)</span> time, where <span class="math inline">\(K\)</span> is the number of unique atoms. In the worst case, <span class="math inline">\(K\)</span> can be equal to <span class="math inline">\(N\)</span>. It is worth noting that this may vary depending on the implementation of the sorting algorithm in the programming language.</p>
</li>
<li>
<p>Generating the answer string will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the overall time complexity will be <span class="math inline">\(O(N + N + N \log N + N)\)</span>, which is <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<ul>
<li>
<p>The space used by the quintuples will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>final_map</code> will be <span class="math inline">\(O(N)\)</span>. Moreover, we are sorting the <code>final_map</code>. In sorting, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language. However, it will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the answer string <code>ans</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>The space used by the <code>stack</code> will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-students-unable-to-eat-lunch/description" target="_blank" rel="noopener noreferrer">Number of Students Unable to Eat Lunch</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">queue</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers <code>0</code> and <code>1</code> respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.</p>

<p>The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a <strong>stack</strong>. At each step:</p>

<ul>
	<li>If the student at the front of the queue <strong>prefers</strong> the sandwich on the top of the stack, they will <strong>take it</strong> and leave the queue.</li>
	<li>Otherwise, they will <strong>leave it</strong> and go to the queue&#39;s end.</li>
</ul>

<p>This continues until none of the queue students want to take the top sandwich and are thus unable to eat.</p>

<p>You are given two integer arrays <code>students</code> and <code>sandwiches</code> where <code>sandwiches[i]</code> is the type of the <code>i<sup>â€‹â€‹â€‹â€‹â€‹â€‹th</sup></code> sandwich in the stack (<code>i = 0</code> is the top of the stack) and <code>students[j]</code> is the preference of the <code>j<sup>â€‹â€‹â€‹â€‹â€‹â€‹th</sup></code> student in the initial queue (<code>j = 0</code> is the front of the queue). Return <em>the number of students that are unable to eat.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> students = [1,1,0,0], sandwiches = [0,1,0,1]
<strong>Output:</strong> 0<strong> 
Explanation:</strong>
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= students.length, sandwiches.length &lt;= 100</code></li>
	<li><code>students.length == sandwiches.length</code></li>
	<li><code>sandwiches[i]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>students[i]</code> is <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find the number of students who are unable to eat lunch at the school cafeteria.</p>
<p>We are given an array <code>sandwiches</code> that represents a stack of sandwiches, where <code>sandwiches[0]</code> is the sandwich at the top of the stack.</p>
<ul>
<li>Circular sandwiches are represented with a <code>0</code>.</li>
<li>Square sandwiches are represented with a <code>1</code>.</li>
</ul>
<p>We are also given an array <code>students</code> which represents a queue of students in line at the cafeteria, where <code>students[0]</code> is the first student in the queue.</p>
<ul>
<li>Students who prefer circular sandwiches are represented with a <code>0</code>.</li>
<li>Students who prefer square sandwiches are represented with a <code>1</code>.</li>
</ul>
<p>Lunch proceeds with the following process:</p>
<p>The first student takes the top sandwich if it matches their preference and leaves the queue, otherwise, they go to the back of the queue. This repeats until none of the students in the queue want to take the top sandwich.</p>
<p>After this, we return the number of students who are unable to eat, which will be the number of students remaining in the queue.</p>
<p><strong>Key Observations:</strong></p>
<ul>
<li>The number of students and the number of sandwiches are the same.</li>
<li>We cannot change the order of the sandwiches.</li>
<li>The only ways we can modify the order of the students is by giving them sandwiches, which removes them from the queue, or sending them to the back of the queue.</li>
</ul>
<hr />
<h3 id="approach-1-simulation-using-queue-and-stack">Approach 1: Simulation Using Queue and Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>We can simulate the lunch process by using a queue of students and a stack of sandwiches.</p>
<p>While there are unserved students in the queue, we check if the sandwich at the top of the sandwich stack meets the front student in the queue's preference. If so, we remove the sandwich from the stack and remove the student from the queue. Otherwise, we move the student to the back of the queue.</p>
<p><strong>How do we know when none of the students in the queue want to take the top sandwich?</strong></p>
<p>We can keep track of when we last served a student using the variable <code>lastServed</code>. If we are unable to serve a student, we increment <code>lastServed</code>. When we do serve a student, we reset <code>lastServed</code> to zero. When <code>lastServed</code> reaches the same size as the queue, we know we have offered the top sandwich to every student in the queue, so we stop the lunch process.</p>
<p>After serving all the sandwiches we can, the remaining students in the queue are the unserved students.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize a variable <code>len</code> to the length of <code>students</code>. <code>sandwiches</code> will be the same length.</p>
</li>
<li>
<p>Initialize a queue <code>studentQueue</code> for storing the students and a stack <code>sandwichStack</code> for storing the sandwiches.</p>
</li>
<li>
<p>Add the students and sandwiches to the queue and stack:</p>
<ul>
<li>Use a <code>for</code> loop to iterate from <code>i = 0</code> to <code>len</code>:
<ul>
<li>Add the next student, <code>student[i]</code>, to the back of <code>studentQueue</code>.</li>
<li>Add the next sandwich, <code>sandwich[len - i - 1]</code>, to the top of <code>sandwichStack</code>, which will build the stack so it is in the same order as the given <code>sandwiches</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize a variable <code>lastServed</code> to <code>0</code> to store how many students ago the most recent sandwich was served.</p>
</li>
<li>
<p>Simulate the lunch process by serving sandwiches and sending students to the back of the queue.</p>
<ul>
<li>While the size of <code>studentQueue</code> is greater than <code>0</code> and greater than <code>lastServed</code>:
<ul>
<li>If the first student in the queue's preference matches the top sandwich in the stack, remove the student from the queue and the sandwich from the stack, and reset <code>lastServed</code> to <code>0</code>.</li>
<li>Otherwise, move the first student to the back of the queue and increment <code>lastServed</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the number of remaining students in the queue.</p>
</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1700/1700slideshow1.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TCuU3AVS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>students</code> and <span class="math inline">\(m\)</span> be the length of <code>sandwiches</code>. Note that <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are equal.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>Populating <code>studentQueue</code> and <code>sandwichStack</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>In the worst case, each student may go through the queue up to <span class="math inline">\(m\)</span> times, being offered the wrong sandwich type each time. Therefore, the time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The main space we use is for <code>studentQueue</code> which is size <span class="math inline">\(n\)</span> and <code>sandwichStack</code> which is size <span class="math inline">\(m\)</span> so the space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-counting">Approach 2: Counting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>There are two main cases:</p>
<ol>
<li>Every student in the queue receives a sandwich, so the number of students unable to eat is <code>0</code>.</li>
</ol>
<blockquote>
<p>Input: students = [1,1,0,0], sandwiches = [0,1,0,1]<br />
Output: 0</p>
</blockquote>
<ol start="2">
<li>None of the remaining students in the queue want the top sandwich, so they are unable to eat lunch.</li>
</ol>
<blockquote>
<p>Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]<br />
Output: 3<br />
After the lunch process, students = [1,1,1] and sandwiches = [0,1,1]</p>
</blockquote>
<p><em><strong>Key Observation:</strong> If none of the students in the queue's preference matches the top sandwich, none of the remaining students can eat.</em></p>
<p>We can utilize this observation to develop a constant space solution.</p>
<p>First, we count the number of students who prefer circle sandwiches and the number of students who prefer square sandwiches.</p>
<p>Then, we iterate through the available sandwiches in the stack. If the top sandwich is a circle sandwich, we serve it to a student who prefers circle sandwiches by decrementing the number of students who prefer circle sandwiches. If the top sandwich is square, we serve it to a student who prefers square sandwiches by decrementing the number of students who prefer square sandwiches.</p>
<p>If the number of students who prefer a certain type of sandwich becomes zero, and the sandwich at the top of the stack is that same type of sandwich, none of the remaining students want that sandwich. We return the number of unserved students, which is the count of the students who prefer the other type of sandwich.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize <code>circleStudentCount</code> and <code>squareStudentCount</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate through the <code>students</code> array:</p>
<ul>
<li>If the current student prefers a circle sandwich (value is <code>0</code>), increment <code>circleStudentCount</code>.</li>
<li>Otherwise, the current student prefers a square sandwich (value is <code>1</code>), increment <code>squareStudentCount</code>.</li>
</ul>
</li>
<li>
<p>Iterate through the <code>sandwiches</code> array:</p>
<ul>
<li>If the current sandwich is a circle sandwich (value is <code>0</code>) and there are no students who want circle sandwiches (<code>circleStudentCount</code> is <code>0</code>), return <code>squareStudentCount</code>.</li>
<li>If the current sandwich is square (value is <code>1</code>) and there are no students who want square sandwiches (<code>squareStudentCount</code> is <code>0</code>), return <code>circleStudentCount</code>.</li>
<li>If the current sandwich matches a student's preference:
<ul>
<li>If the current sandwich is a circle sandwich (value is <code>0</code>), decrement <code>circleStudentCount</code>.</li>
<li>Otherwise, the current sandwich is square (value is <code>1</code>), decrement <code>squareStudentCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the loop completes without returning, it means that all students received a sandwich, return <code>0</code>.</p>
</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1700/1700slideshow2.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9gkKTjnv/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>students</code> and <span class="math inline">\(m\)</span> be the length of <code>sandwiches</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Counting the number of students who prefer each kind of sandwich takes <span class="math inline">\(O(n)\)</span>.</p>
<p>We loop through each sandwich in <code>sandwiches</code> to serve the sandwiches, which takes up to <span class="math inline">\(O(m)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Since <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are equal, we could alternatively represent the time complexity as <span class="math inline">\(O(n)\)</span>.</p>
</blockquote>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a couple of variables to count the students who want each type of sandwich, but we don't use any data structures that grow with input size, so the space complexity is constant, i.e. <span class="math inline">\(O(1)\)</span></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-visible-people-in-a-queue/description" target="_blank" rel="noopener noreferrer">Number of Visible People in a Queue</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> people standing in a queue, and they numbered from <code>0</code> to <code>n - 1</code> in <strong>left to right</strong> order. You are given an array <code>heights</code> of <strong>distinct</strong> integers where <code>heights[i]</code> represents the height of the <code>i<sup>th</sup></code> person.</p>

<p>A person can <strong>see</strong> another person to their right in the queue if everybody in between is <strong>shorter</strong> than both of them. More formally, the <code>i<sup>th</sup></code> person can see the <code>j<sup>th</sup></code> person if <code>i &lt; j</code> and <code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>.</p>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>n</code><em> where </em><code>answer[i]</code><em> is the <strong>number of people</strong> the </em><code>i<sup>th</sup></code><em> person can <strong>see</strong> to their right in the queue</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg" style="width: 600px; height: 247px;" /></p>

<pre>
<strong>Input:</strong> heights = [10,6,8,5,11,9]
<strong>Output:</strong> [3,1,2,1,1,0]
<strong>Explanation:</strong>
Person 0 can see person 1, 2, and 4.
Person 1 can see person 2.
Person 2 can see person 3 and 4.
Person 3 can see person 4.
Person 4 can see person 5.
Person 5 can see no one since nobody is to the right of them.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> heights = [5,1,2,3,10]
<strong>Output:</strong> [4,1,1,1,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == heights.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>
	<li>All the values of <code>heights</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-150">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/odd-even-jump/description" target="_blank" rel="noopener noreferrer">Odd Even Jump</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">ordered-set</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>arr</code>. From some starting index, you can make a series of jumps. The (1<sup>st</sup>, 3<sup>rd</sup>, 5<sup>th</sup>, ...) jumps in the series are called <strong>odd-numbered jumps</strong>, and the (2<sup>nd</sup>, 4<sup>th</sup>, 6<sup>th</sup>, ...) jumps in the series are called <strong>even-numbered jumps</strong>. Note that the <strong>jumps</strong> are numbered, not the indices.</p>

<p>You may jump forward from index <code>i</code> to index <code>j</code> (with <code>i &lt; j</code>) in the following way:</p>

<ul>
	<li>During <strong>odd-numbered jumps</strong> (i.e., jumps 1, 3, 5, ...), you jump to the index <code>j</code> such that <code>arr[i] &lt;= arr[j]</code> and <code>arr[j]</code> is the smallest possible value. If there are multiple such indices <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>
	<li>During <strong>even-numbered jumps</strong> (i.e., jumps 2, 4, 6, ...), you jump to the index <code>j</code> such that <code>arr[i] &gt;= arr[j]</code> and <code>arr[j]</code> is the largest possible value. If there are multiple such indices <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>
	<li>It may be the case that for some index <code>i</code>, there are no legal jumps.</li>
</ul>

<p>A starting index is <strong>good</strong> if, starting from that index, you can reach the end of the array (index <code>arr.length - 1</code>) by jumping some number of times (possibly 0 or more than once).</p>

<p>Return <em>the number of <strong>good</strong> starting indices</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [10,13,12,14,15]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.
From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.
From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.
From starting index i = 4, we have reached the end already.
In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of
jumps.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,3,1,1,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:
During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].
During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3
During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].
We can&#39;t jump from i = 3 to i = 4, so the starting index i = 0 is not good.
In a similar manner, we can deduce that:
From starting index i = 1, we jump to i = 4, so we reach the end.
From starting index i = 2, we jump to i = 3, and then we can&#39;t jump anymore.
From starting index i = 3, we jump to i = 4, so we reach the end.
From starting index i = 4, we are already at the end.
In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some
number of jumps.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,1,3,4,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can reach the end from starting indices 1, 2, and 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt; 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-151">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/online-stock-span/description" target="_blank" rel="noopener noreferrer">Online Stock Span</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">data-stream</span> <span class="topic-badge">design</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design an algorithm that collects daily price quotes for some stock and returns <strong>the span</strong> of that stock&#39;s price for the current day.</p>

<p>The <strong>span</strong> of the stock&#39;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p>

<ul>
	<li>For example, if the prices of the stock in the last four days is <code>[7,2,1,2]</code> and the price of the stock today is <code>2</code>, then the span of today is <code>4</code> because starting from today, the price of the stock was less than or equal <code>2</code> for <code>4</code> consecutive days.</li>
	<li>Also, if the prices of the stock in the last four days is <code>[7,34,1,2]</code> and the price of the stock today is <code>8</code>, then the span of today is <code>3</code> because starting from today, the price of the stock was less than or equal <code>8</code> for <code>3</code> consecutive days.</li>
</ul>

<p>Implement the <code>StockSpanner</code> class:</p>

<ul>
	<li><code>StockSpanner()</code> Initializes the object of the class.</li>
	<li><code>int next(int price)</code> Returns the <strong>span</strong> of the stock&#39;s price given that today&#39;s price is <code>price</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]
[[], [100], [80], [60], [70], [60], [75], [85]]
<strong>Output</strong>
[null, 1, 1, 1, 2, 1, 4, 6]

<strong>Explanation</strong>
StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // return 1
stockSpanner.next(80);  // return 1
stockSpanner.next(60);  // return 1
stockSpanner.next(70);  // return 2
stockSpanner.next(60);  // return 1
stockSpanner.next(75);  // return 4, because the last 4 prices (including today&#39;s price of 75) were less than or equal to today&#39;s price.
stockSpanner.next(85);  // return 6
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>next</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-152">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/operations-on-stack/1" target="_blank" rel="noopener noreferrer">Operations on Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>stack </strong>of <strong>integers </strong>and <strong>Q</strong> queries. The task is to perform the operation on stack according to the query.</span></p>
<p><span style="font-size: 18px;">The queries can be of 4 types:</span></p>
<blockquote>
<p><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>i x:</strong> (<strong>adds </strong>element x in the stack)</span>.<br /></span><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>r:</strong> (<strong>removes </strong>the topmost element from the stack).<br /></span></span><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>h:</strong> </span>Prints the topmost element.<br /></span><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>f y:</strong> (check if the <strong>element </strong>y is <strong>present or not </strong>in the stack).</span> Print "<strong>Yes</strong>" if present, else "<strong>No</strong>".</span>&nbsp;</p>
</blockquote>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>Q = 6, Queries = [[i, 2], [i, 4], [i, 3],[i, 5], [h], [f, 8]]
<strong>Output: 
</strong>5
No<strong>
Explanation: </strong>Inserting 2, 4, 3, and 5 onto the stack. Returning top element which is 5. Finding 8 will give No, as 8 is not in the stack.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> Q = 4, Queries = [[i, 3], [i, 4], [r], [f, 3]]
<strong>Output: 
</strong>Yes
<strong>Explanation: </strong>Inserting 3 and 4 onto the stack. Removing 4 from the stack. Finding 3 will give Yes as output because 3 is available in the stack.</span></pre>
<p dir="ltr"><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; Number of queries &le; 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-153">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/pairwise-consecutive-elements/1" target="_blank" rel="noopener noreferrer">Pairwise Consecutive Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a stack of integers of size <strong>N</strong>, your task is to complete the&nbsp;function <strong>pairWiseConsecutive(),</strong> that checks whether numbers in the stack are pairwise consecutive or not. The pairs can be increasing or decreasing, and if the stack has an odd number of elements, the element at the top is left out of a pair. The function should retain the original stack content.</span></p>

<p><span style="font-size:18px">Only following standard operations are allowed on </span><span style="font-size:18px">stack</span><span style="font-size:18px">.</span></p>

<ul>
	<li><span style="font-size:18px">push(X): Enter </span><span style="font-size:18px">a element</span><span style="font-size:18px"> X on top of </span><span style="font-size:18px">stack</span><span style="font-size:18px">.</span></li>
	<li><span style="font-size:18px">pop(): Removes top element of the stack.</span></li>
	<li><span style="font-size:18px">empty(): To check if stack is empty.</span></li>
</ul>

<p><span style="font-size:18px"><strong>Input Format:</strong><br />
The first line of input contains T denoting the number of testcases. T testcases follow. Each testcase contains two lines of input. The first line contains n denoting the number of elements to be inserted into the stack. The second line contains the elements to be inserted into the stack.</span></p>

<p><span style="font-size:18px"><strong>Output Format:</strong><br />
For each</span><span style="font-size:18px"> testcase, in a new line, print </span><span style="font-size:18px">&quot;<strong>Yes</strong>&quot;(without quote) if the elements of the stack </span><span style="font-size:18px">is</span><span style="font-size:18px"> pairwise consecutive, else print&nbsp;&quot;<strong>No</strong>&quot;.</span></p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
This is a function problem. You only need to complete the function <strong>pairWiseConsecutive </strong>that takes a stack as an <strong>argument </strong>and returns <strong>true </strong>if the stack is found to be pairwise consecutive, else it returns <strong>false</strong>. The printing is done by the <strong>driver </strong>code.</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt; =T &lt;= 100<br />
1 &lt; =N &lt;= 10<sup>3</sup></span></p>

<p><span style="font-size:18px"><strong>Example:<br />
Input:</strong><br />
2<br />
6<br />
1 2 3 4 5 6<br />
5<br />
1 5 3 9 7<br />
<strong>Output:</strong><br />
Yes</span><br />
<span style="font-size:20px">No</span></p>

<p><span style="font-size:20px"><strong>Explanation:</strong><br />
<strong>Testcase1: </strong>The number of elements are even and they are pairwise consecutive so we print Yes.<br />
<strong>Testcase2: </strong>The number of elements are odd so we remove the top element and check for pairwise consecutive. It is not so we print No.</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-154">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/palindrome-linked-list/description" target="_blank" rel="noopener noreferrer">Palindrome Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked-list</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, return <code>true</code><em> if it is a </em><span data-keyword="palindrome-sequence"><em>palindrome</em></span><em> or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" style="width: 422px; height: 62px;" />
<pre>
<strong>Input:</strong> head = [1,2,2,1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" style="width: 182px; height: 62px;" />
<pre>
<strong>Input:</strong> head = [1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-155">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/parenthesis-checker2744/1" target="_blank" rel="noopener noreferrer">Parenthesis Checker</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>s</strong>, composed of different combinations of '(' , ')', '{', '}', '[', ']', verify the validity of the arrangement.<br /></span><span style="font-size: 18px;">An input string is valid if:</span></p>
<p><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1. Open brackets must be closed by the same type of brackets.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. Open brackets must be closed in the correct order.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s = "[{()}]"
<strong>Output:</strong> true
<strong>Explanation: </strong>All the brackets are well-formed.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s = "[()()]{}"
<strong>Output:</strong> true
<strong>Explanation: </strong>All the brackets are well-formed.<br /></span></pre>
<pre><strong><span style="font-size: 18px;">Input:</span></strong><span style="font-size: 18px;"> s = "([]"<br /><strong>Output: </strong>False<br /><strong>Explanation: </strong>The expression is not balanced as there is a missing ')' at the end.<br /></span></pre>
<pre><strong><span style="font-size: 18px;">Input:</span></strong><span style="font-size: 18px;"> s = "([{]})"<br /><strong>Output: </strong>False<br /><strong>Explanation: </strong>The expression is not balanced as there is a closing ']' before the closing '}'.<br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; s.size() &le; 10<sup>6<br /></sup>s[i] &isin; {'{', '}', '(', ')', '[', ']'}</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-156">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/parse-lisp-expression/description" target="_blank" rel="noopener noreferrer">Parse Lisp Expression</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash-table</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string expression representing a Lisp-like expression to return the integer value of.</p>

<p>The syntax for these expressions is given as follows.</p>

<ul>
	<li>An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.</li>
	<li>(An integer could be positive or negative.)</li>
	<li>A let expression takes the form <code>&quot;(let v<sub>1</sub> e<sub>1</sub> v<sub>2</sub> e<sub>2</sub> ... v<sub>n</sub> e<sub>n</sub> expr)&quot;</code>, where let is always the string <code>&quot;let&quot;</code>, then there are one or more pairs of alternating variables and expressions, meaning that the first variable <code>v<sub>1</sub></code> is assigned the value of the expression <code>e<sub>1</sub></code>, the second variable <code>v<sub>2</sub></code> is assigned the value of the expression <code>e<sub>2</sub></code>, and so on sequentially; and then the value of this let expression is the value of the expression <code>expr</code>.</li>
	<li>An add expression takes the form <code>&quot;(add e<sub>1</sub> e<sub>2</sub>)&quot;</code> where add is always the string <code>&quot;add&quot;</code>, there are always two expressions <code>e<sub>1</sub></code>, <code>e<sub>2</sub></code> and the result is the addition of the evaluation of <code>e<sub>1</sub></code> and the evaluation of <code>e<sub>2</sub></code>.</li>
	<li>A mult expression takes the form <code>&quot;(mult e<sub>1</sub> e<sub>2</sub>)&quot;</code> where mult is always the string <code>&quot;mult&quot;</code>, there are always two expressions <code>e<sub>1</sub></code>, <code>e<sub>2</sub></code> and the result is the multiplication of the evaluation of e1 and the evaluation of e2.</li>
	<li>For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names <code>&quot;add&quot;</code>, <code>&quot;let&quot;</code>, and <code>&quot;mult&quot;</code> are protected and will never be used as variable names.</li>
	<li>Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;(let x 2 (mult x (let x 3 y 4 (add x y))))&quot;
<strong>Output:</strong> 14
<strong>Explanation:</strong> In the expression (add x y), when checking for the value of the variable x,
we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.
Since x = 3 is found first, the value of x is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;(let x 3 x 2 x)&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Assignment in let statements is processed sequentially.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;(let x 1 y 2 x (add x y) (add x y))&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> The first (add x y) evaluates as 3, and is assigned to x.
The second (add x y) evaluates as 3+2 = 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 2000</code></li>
	<li>There are no leading or trailing spaces in <code>expression</code>.</li>
	<li>All tokens are separated by a single space in <code>expression</code>.</li>
	<li>The answer and all intermediate calculations of that answer are guaranteed to fit in a <strong>32-bit</strong> integer.</li>
	<li>The expression is guaranteed to be legal and evaluate to an integer.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-157">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/parsing-a-boolean-expression/description" target="_blank" rel="noopener noreferrer">Parsing A Boolean Expression</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>boolean expression</strong> is an expression that evaluates to either <code>true</code> or <code>false</code>. It can be in one of the following shapes:</p>

<ul>
	<li><code>&#39;t&#39;</code> that evaluates to <code>true</code>.</li>
	<li><code>&#39;f&#39;</code> that evaluates to <code>false</code>.</li>
	<li><code>&#39;!(subExpr)&#39;</code> that evaluates to <strong>the logical NOT</strong> of the inner expression <code>subExpr</code>.</li>
	<li><code>&#39;&amp;(subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub>)&#39;</code> that evaluates to <strong>the logical AND</strong> of the inner expressions <code>subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub></code> where <code>n &gt;= 1</code>.</li>
	<li><code>&#39;|(subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub>)&#39;</code> that evaluates to <strong>the logical OR</strong> of the inner expressions <code>subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub></code> where <code>n &gt;= 1</code>.</li>
</ul>

<p>Given a string <code>expression</code> that represents a <strong>boolean expression</strong>, return <em>the evaluation of that expression</em>.</p>

<p>It is <strong>guaranteed</strong> that the given expression is valid and follows the given rules.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;&amp;(|(f))&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> 
First, evaluate |(f) --&gt; f. The expression is now &quot;&amp;(f)&quot;.
Then, evaluate &amp;(f) --&gt; f. The expression is now &quot;f&quot;.
Finally, return false.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;|(f,f,f,t)&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The evaluation of (false OR false OR false OR true) is true.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;!(&amp;(f,t))&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> 
First, evaluate &amp;(f,t) --&gt; (false AND true) --&gt; false --&gt; f. The expression is now &quot;!(f)&quot;.
Then, evaluate !(f) --&gt; NOT false --&gt; true. We return true.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li>expression[i] is one following characters: <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&amp;&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;!&#39;</code>, <code>&#39;t&#39;</code>, <code>&#39;f&#39;</code>, and <code>&#39;,&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to evaluate a boolean expression that follows specific rules. These rules allow for expressions that include literals for <code>true</code> ('t') and <code>false</code> ('f'), as well as logical operations like NOT ('!'), AND ('&amp;'), and OR ('|'). The goal is to reduce the expression by applying these operations step by step until we arrive at either <code>true</code> or <code>false</code>.</p>
<p>For example, consider the expression <code>&amp;(|(f))</code>. We first evaluate the OR expression inside the parentheses. Since it's <code>|(f)</code>, it results in <code>false</code>. Now, the expression becomes <code>&amp;(f)</code>, which is an AND operation. Since there's only one <code>f</code>, the result is <code>false</code>.</p>
<details> 
<summary> HINT </summary>
<p>Start by identifying the innermost expression enclosed in parentheses and work your way outward, applying the relevant logical operation each time.</p>
</details>
<hr />
<h3 id="approach-1-string-manipulation">Approach 1: String Manipulation</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find the deepest part of the expression, which is usually within the innermost parentheses. We search for the last operator in the string because it likely corresponds to the most nested part. Once we locate it, we grab everything between that operator and its closing parenthesis. This forms a subexpression that we can evaluate independently.</p>
<p>For example, in <code>&amp;(t, |(f, t))</code>, we first look inside the <code>|</code> operator since it is nested within the <code>&amp;</code>. Evaluating <code>|(f, t)</code> tells us that, because one of the values is <code>t</code>, the result of this subexpression is <code>t</code>. We then replace <code>|(f, t)</code> with <code>t</code>, reducing the problem to <code>&amp;(t, t)</code>. Finally, we evaluate the <code>&amp;</code>, which returns <code>t</code> since both values are true.</p>
<p>This makes sense in smaller steps, but since we are creating new strings each time we reduce an expression, it becomes slow as the expression grows. Each time we replace a subexpression, we are dealing with the entire string again, which is inefficient.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Start a loop that continues until the length of <code>expression</code> is greater than 1:</p>
<ul>
<li>Find the position of the last logical operator (<code>!</code>, <code>&amp;</code>, or <code>|</code>) in the <code>expression</code> and store it in <code>start</code>.</li>
<li>Find the position of the corresponding closing parenthesis <code>)</code> that matches the last operator, and store it in <code>end</code>.</li>
<li>Extract the substring <code>subExpr</code> from <code>expression</code> that includes the operator and the values enclosed in parentheses.</li>
</ul>
</li>
<li>
<p>Call <code>evaluateSubExpr(subExpr)</code> to evaluate the subexpression:</p>
<ul>
<li>In <code>evaluateSubExpr</code>, extract the operator from <code>subExpr</code>.</li>
<li>Get the values by taking the substring from index 2 to the second-to-last character.</li>
<li>Depending on the operator:
<ul>
<li>If itâ€™s <code>!</code>, return <code>'f'</code> if the first value is <code>'t'</code>, otherwise return <code>'t'</code>.</li>
<li>If itâ€™s <code>&amp;</code>, return <code>'f'</code> if any value is <code>'f'</code>, otherwise return <code>'t'</code>.</li>
<li>If itâ€™s <code>|</code>, return <code>'t'</code> if any value is <code>'t'</code>, otherwise return <code>'f'</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Replace the evaluated <code>subExpr</code> in <code>expression</code> with the result (either <code>'t'</code> or <code>'f'</code>).</p>
</li>
<li>
<p>After simplifying the expression completely, return <code>true</code> if the remaining character in <code>expression</code> is <code>'t'</code>; otherwise, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cgASQu5Z/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>expression</code> string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The while loop continues while the length of the <code>expression</code> is greater than 1. In the worst case, we might evaluate every subexpression multiple times, leading to a total of <span class="math inline">\(O(n)\)</span> iterations. Within each iteration, the operations <code>find_last_of</code>, <code>find</code>, and <code>substr</code> each can take up to <span class="math inline">\(O(n)\)</span> time in the worst case. Hence, the overall time complexity becomes <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity primarily comes from the storage of substrings created during the evaluation of subexpressions. The <code>subExpr</code> variable holds a substring of the <code>expression</code>, and the maximum length of <code>subExpr</code> can be up to <span class="math inline">\(O(n)\)</span>. Additionally, the recursive calls to <code>evaluateSubExpr</code> can lead to stack space usage, but since we don't have deep recursion (the depth is limited by the number of operations in the expression), it does not significantly affect the space complexity. Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursive">Approach 2: Recursive</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Similar to the previous approach, we check character by character. When we come across a boolean value (<code>t</code> or <code>f</code>), we can immediately return it as the result. However, when we see an operator like <code>!</code>, <code>&amp;</code>, or <code>|</code>, we know it controls what comes inside the parentheses following it. We skip the opening parenthesis and move into the subexpression.</p>
<p>For the <code>!</code> operator, we expect one boolean value. We simply negate this value and return the opposite. For <code>&amp;</code>, we know all values inside must be true for the result to be true, so we evaluate each one, stopping if we find an <code>f</code>. The <code>|</code> operator works similarly, but we stop as soon as we find a <code>t</code>.</p>
<p>Take the expression <code>&amp;(t, |(f, t))</code> as an example. We first encounter <code>&amp;</code>, which tells us we need to evaluate everything inside the parentheses. We then encounter <code>|</code>, which tells us to evaluate its inner subexpression. When we find that one of the values is <code>t</code>, we return <code>t</code> for the <code>|</code> part. Now the expression simplifies to <code>&amp;(t, t)</code>, which evaluates to <code>t</code>.</p>
<p>Here we donâ€™t repeat work or manipulate the string like in the previous approach, making it a little more efficient.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>index</code> to <code>0</code> and call the <code>evaluate</code> function with the current expression and index.</p>
</li>
<li>
<p>In the <code>evaluate</code> function:</p>
<ul>
<li>
<p>Read the current character from <code>expression</code> at <code>index</code>, and increment <code>index</code> by 1.</p>
</li>
<li>
<p>Base cases:</p>
<ul>
<li>If the character is 't' (true), return <code>true</code>.</li>
<li>If the character is 'f' (false), return <code>false</code>.</li>
</ul>
</li>
<li>
<p>Handle the NOT operation ('!(...)'):</p>
<ul>
<li>If the character is '!', increment <code>index</code> to skip the '('.</li>
<li>Recursively evaluate the inner expression and negate the result (using <code>!</code>), then increment <code>index</code> to skip the ')'.</li>
<li>Return the negated result.</li>
</ul>
</li>
<li>
<p>Handle the AND ('&amp;(...)') and OR ('|(...)') operations:</p>
<ul>
<li>Initialize an array <code>values</code> to store the results of subexpressions.</li>
<li>Increment <code>index</code> to skip the '('.</li>
<li>While the current character is not ')':
<ul>
<li>If the character is not a comma, recursively evaluate the subexpression and add the result to <code>values</code>.</li>
<li>If the character is a comma, increment <code>index</code> to skip it.</li>
</ul>
</li>
<li>After exiting the loop, increment <code>index</code> to skip the ')'.</li>
</ul>
</li>
<li>
<p>Manual AND operation:</p>
<ul>
<li>If the character is '&amp;', iterate through <code>values</code>.
<ul>
<li>If any value is <code>false</code>, return <code>false</code>.</li>
</ul>
</li>
<li>If all values are <code>true</code>, return <code>true</code>.</li>
</ul>
</li>
<li>
<p>Manual OR operation:</p>
<ul>
<li>If the character is '|', iterate through <code>values</code>.
<ul>
<li>If any value is <code>true</code>, return <code>true</code>.</li>
</ul>
</li>
<li>If all values are <code>false</code>, return <code>false</code>.</li>
</ul>
</li>
<li>
<p>Return <code>false</code> at the end of the function (this point should never be reached).</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Wd8HfyHL/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>expression</code> string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse the entire expression string at most once, as each character is processed sequentially. Each recursive call to <code>evaluate</code> processes one character and the calls return only when the entire expression is evaluated. Therefore, in the worst case, where all characters are involved in the expression, the time complexity is linear in terms of the size of the expression.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity arises from the recursion stack due to the depth of the recursive calls. In the worst case, if the expression is deeply nested, the recursion depth can reach up to <span class="math inline">\(n\)</span>, leading to a stack space usage of <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, the space used by the <code>values</code> can also contribute to the space complexity, but its size depends on the number of boolean values being evaluated at each level, which is bounded by the size of the expression. Thus, the overall space complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-stack">Approach 3: Using Stack</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of recursion, we can use a stack to simulate the nested structure of the expression. The stack will keep track of what we are currently evaluating, allowing us to process each part of the expression step by step without making recursive function calls.</p>
<p>Iterate from left to right and as we encounter operators, boolean values, and parentheses, we push them onto the stack. When we find a closing parenthesis <code>)</code>, we know weâ€™ve reached the end of a subexpression. At this point, we pop values off the stack until we reach the matching opening parenthesis <code>(</code>. These popped values form the subexpression, and we can now evaluate it.</p>
<p>For example, with the expression <code>&amp;(t, |(f, t))</code>, we first push <code>&amp;</code> onto the stack, followed by <code>t</code>. When we encounter <code>|</code>, we push it and continue with <code>f</code> and <code>t</code>. Once we find the closing parenthesis for the <code>|</code> subexpression, we pop <code>t</code> and <code>f</code> off the stack and evaluate <code>|</code>. Since one value is <code>t</code>, the result of this subexpression is <code>t</code>, which we push back onto the stack. Finally, we continue by evaluating the <code>&amp;</code> operator with the remaining values on the stack.</p>
<p>The internal working is extremely similar to <a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a> problem, if you haven't solved it, then it's recommended to solve it.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize a stack <code>st</code> to hold characters as we parse the expression.</p>
</li>
<li>
<p>Traverse the entire <code>expression</code>:</p>
<ul>
<li>
<p>If the current character is <code>')'</code>, it indicates the end of a subexpression:</p>
<ul>
<li>
<p>Initialize a array <code>values</code> to collect all values inside the parentheses.</p>
</li>
<li>
<p>While the top of the stack is not <code>'('</code>, pop characters from the stack into <code>values</code>.</p>
</li>
<li>
<p>Pop the <code>'('</code> from the stack.</p>
</li>
<li>
<p>Pop the operator from the top of the stack.</p>
</li>
<li>
<p>Call <code>evaluateSubExpr(op, values)</code> to evaluate the subexpression:</p>
<ul>
<li>Push the result back onto the stack.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the current character is not a comma, push it onto the stack.</p>
</li>
</ul>
</li>
<li>
<p>After traversing the expression, the final result will be on the top of the stack.</p>
</li>
<li>
<p>Return <code>true</code> if the top of the stack is <code>'t'</code>, indicating that the expression evaluates to <code>true</code>, otherwise return <code>false</code>.</p>
</li>
<li>
<p>The <code>evaluateSubExpr</code> function evaluates a subexpression based on the operator and the list of values:</p>
<ul>
<li>If the operator is <code>'!'</code>, return <code>'f'</code> if the first value is <code>'t'</code>, otherwise return <code>'t'</code>.</li>
<li>If the operator is <code>'&amp;'</code>, iterate through the values:
<ul>
<li>Return <code>'f'</code> if any value is <code>'f'</code>, otherwise return <code>'t'</code>.</li>
</ul>
</li>
<li>If the operator is <code>'|'</code>, iterate through the values:
<ul>
<li>Return <code>'t'</code> if any value is <code>'t'</code>, otherwise return <code>'f'</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/KJueFSYj/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>expression</code> string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse the <code>expression</code> string once, processing each character in <span class="math inline">\(O(1)\)</span> time. The only significant work happens when we encounter a closing parenthesis <code>)</code>, where we collect values from the stack until we reach the corresponding opening parenthesis <code>(</code>. In the worst case, all characters in the expression may contribute to these operations, but each character is processed only once. Thus, the overall time complexity is linear.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity primarily depends on the stack used to store the characters of the expression and the temporary storage for values inside parentheses. In the worst case, the stack can hold all characters of the expression, resulting in <span class="math inline">\(O(n)\)</span> space. Additionally, when processing nested operations, temporary storage might also hold up to <span class="math inline">\(n\)</span> characters, leading to the same <span class="math inline">\(O(n)\)</span> space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-optimized-stack">Approach 4: Optimized Stack</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of pushing every character onto the stack, we focus only on the meaningful elementsâ€”operators, boolean values, and parenthesesâ€”while ignoring commas, which donâ€™t affect the result.</p>
<p>We still push operators and boolean values onto the stack as we read the expression. But when we encounter a closing parenthesis, we start evaluating the subexpression immediately by popping values off the stack. The key improvement here is that we can stop early if the result becomes obvious. For instance, with the <code>&amp;</code> operator, if we find a <code>f</code> while popping values, we know the result of the subexpression is <code>f</code> and can stop without checking the rest. Similarly, for the <code>|</code> operator, finding a <code>t</code> allows us to stop early.</p>
<p>Consider the expression <code>&amp;(t, |(f, t))</code>. As before, we push <code>&amp;</code> and <code>t</code>, then <code>|</code>, followed by <code>f</code> and <code>t</code>. When we pop values for the <code>|</code> subexpression, we immediately know the result is <code>t</code> because one of the values is <code>t</code>. We push <code>t</code> back onto the stack and continue with the <code>&amp;</code> operator, which evaluates to <code>t</code> because both values are true.</p>
<p>!?!../Documents/1106/op_stack.json:1025,755!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty stack <code>st</code> to keep track of operators and boolean values.</p>
</li>
<li>
<p>Traverse through each character in the <code>expression</code>:</p>
<ul>
<li>
<p>If the current character is a comma <code>,</code> or an open parenthesis <code>(</code>, skip it (continue to the next character).</p>
</li>
<li>
<p>If the current character is a boolean value (<code>t</code> for true, <code>f</code> for false) or an operator (<code>!</code>, <code>&amp;</code>, <code>|</code>), push it onto the stack.</p>
</li>
<li>
<p>If the current character is a closing parenthesis <code>)</code>:</p>
<ul>
<li>
<p>Initialize two boolean flags: <code>hasTrue</code> and <code>hasFalse</code> to track the presence of true and false values within the parentheses.</p>
</li>
<li>
<p>Process the values inside the parentheses:</p>
<ul>
<li>While the top of the stack is not an operator (<code>!</code>, <code>&amp;</code>, <code>|</code>):
<ul>
<li>Pop the top value from the stack and check:
<ul>
<li>If it is <code>t</code>, set <code>hasTrue</code> to <code>true</code>.</li>
<li>If it is <code>f</code>, set <code>hasFalse</code> to <code>true</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After processing values, pop the operator from the top of the stack.</p>
</li>
<li>
<p>Evaluate the subexpression based on the operator:</p>
<ul>
<li>If the operator is <code>!</code>, push <code>f</code> if <code>hasTrue</code> is <code>true</code>; otherwise, push <code>t</code>.</li>
<li>If the operator is <code>&amp;</code>, push <code>f</code> if <code>hasFalse</code> is <code>true</code>; otherwise, push <code>t</code>.</li>
<li>If the operator is <code>|</code>, push <code>t</code> if <code>hasTrue</code> is <code>true</code>; otherwise, push <code>f</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After processing the entire expression, the final result will be at the top of the stack:</p>
<ul>
<li>Return <code>true</code> if the top of the stack is <code>t</code>, otherwise return <code>false</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/SarqEB82/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>expression</code> string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse each character in the <code>expression</code> string once. For each character, operations like pushing to and popping from the stack are <span class="math inline">\(O(1)\)</span> operations. Therefore, the overall time complexity is linear in terms of the length of the input string.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The maximum space used by the stack occurs when every character in the <code>expression</code> is a boolean value or an operator without any closing parentheses. In the worst case, all characters might be pushed onto the stack, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>. This includes the storage for the stack itself, which could potentially hold all the characters of the expression.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-158">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/evaluation-of-postfix-expression1735/1" target="_blank" rel="noopener noreferrer">Postfix Evaluation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an array of strings <strong>arr</strong> that represents a valid arithmetic expression written in <strong>Reverse Polish Notation (Postfix Notation)</strong>. Your task is to evaluate the expression and return an integer representing its value.</span></p>
<p><span style="font-size: 14pt;"><strong>Key Details</strong>:</span></p>
<ol>
<li><span style="font-size: 14pt;">The valid operators are <strong>'+'</strong>, <strong>'-'</strong>, <strong>'*'</strong>, and <strong>'/'</strong>.</span></li>
<li><span style="font-size: 14pt;">Each operand is guaranteed to be a valid integer or another expression.</span></li>
<li><span style="font-size: 14pt;">The division operation between two integers always rounds the result towards zero, discarding any fractional part.</span></li>
<li><span style="font-size: 14pt;">No division by zero will occur in the input.</span></li>
<li><span style="font-size: 14pt;">The input is a valid arithmetic expression in Reverse Polish Notation.</span></li>
<li><span style="font-size: 14pt;">The result of the expression and all intermediate calculations will fit in a 32-bit signed integer.</span></li>
</ol>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr = ["2", "3", "1", "*", "+", "9", "-"]</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> -4</span><br /><span style="font-size: 14pt;"><strong>Explanation:</strong> If the expression is converted into an infix expression, it will be 2 + (3 * 1) &ndash; 9 = 5 &ndash; 9 = -4.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr = ["100", "200", "+", "2", "/", "5", "*", "7", "+"]</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> 757</span><br /><span style="font-size: 14pt;"><strong>Explanation:</strong> If the expression is converted into an infix expression, it will be ((100 + 200) / 2) * 5 + 7  = 150 * 5 + 7 = 757.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 14pt;">1 &lt;= arr.size() &lt;= 10<sup>5</sup></span></li>
<li><span style="font-size: 14pt;">arr[i] is either an operator: "+", "-", "*", or "/", or an integer in the range [-10<sup>4</sup>, 10<sup>4</sup>]</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-159">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/preorder-to-postorder4423/1" target="_blank" rel="noopener noreferrer">Preorder to BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binarysearchtree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array arr[] of N nodes representing preorder traversal of some BST. You have to build the </span><strong style="font-size: 18px;">BST</strong><span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;"> from the given preorder traversal.&nbsp;</span></p>
<p><span style="font-size: 18px;">In Pre-Order traversal,&nbsp;<strong>the root node is visited before the left child and right child nodes</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 5
arr[]  = {40,30,35,80,100}
<strong>Output: </strong>35 30 100 80 40<strong>
Explanation:</strong>&nbsp;PreOrder: 40 30 35 80 100
Therefore, the BST will be:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 40
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; &nbsp;&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30&nbsp; &nbsp; &nbsp; &nbsp;80
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\&nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;35&nbsp; &nbsp; &nbsp; 100
Hence, the postOrder traversal will
be: 35 30 100 80 40</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 8
arr[]  = {40,30,32,35,80,90,100,120}
<strong>Output: </strong>35 32 30 120 100 90 80 40</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You need to complete the given function and<strong> return the root </strong>of the tree. The driver code will then use this root to print the post order traversal.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(N).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>3</sup><br />1 &lt;= arr[i] &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-160">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/preorder-traversal/1" target="_blank" rel="noopener noreferrer">Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a&nbsp;binary tree, find&nbsp;its&nbsp;preorder traversal.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
&nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp;
      /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
    4 &nbsp; &nbsp;
  /&nbsp; &nbsp; \ &nbsp; 
4&nbsp; &nbsp; &nbsp; &nbsp;2
<strong>Output: </strong>[1, 4, 4, 2</span><span style="font-size: 22px;">]</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
       6
&nbsp;    /   \
&nbsp;   3     2
&nbsp;    \   / 
&nbsp;     1 2
<strong>Output: </strong>[6, 3, 1, 2, 2] </span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input:<br /></strong><span style="font-size: 14pt;"> </span><span style="font-size: 18.6667px;">        8
       / \
      3   10
     / \    \
    1   6   14
       / \   /
      4   7 13
</span><strong style="font-size: 14pt;">Output:</strong><span style="font-size: 14pt;"> [</span><span style="font-size: 18.6667px;">8, 3, 1, 6, 4, 7, 10, 14, 13]</span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>5</sup><br />0 &lt;= node-&gt;data &lt;= 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-161">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/preorder-traversal-iterative/1" target="_blank" rel="noopener noreferrer">Preorder traversal (Iterative)</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Binary tree. Find the preorder traversal of the tree <strong>without using recursion</strong>.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
<strong>           </strong>1
<strong>         /   \</strong>
        2     3
      /  \
     4    5
<strong>Output: </strong>1 2 4 5 3
<strong>Explanation:</strong>
Preorder traversal (Root-&gt;Left-&gt;Right) of 
the tree is 1 2 4 5 3.
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
            8
          /   \
         1      5
          \    /  \
           7  10   6
            \  /
&nbsp;           10 6
<strong>Output: </strong>8 1 7 10 5 10 6 6&nbsp;
<strong>Explanation:</strong>
Preorder traversal (Root-&gt;Left-&gt;Right) 
of the tree is 8 1 7 10 5 10 6 6.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your task:</strong></span></p>
<p><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function <strong>preOrder() </strong>which takes the root of the tree as input and returns a list containing the preorder traversal of the tree, calculated<strong> without using recursion.</strong></span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected time complexity: </strong>O(N)</span><br /><span style="font-size: 18px;"><strong>Expected auxiliary space: </strong>O(N)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; Number of nodes &le; 10<sup>5</sup></span><br /><span style="font-size: 18px;">1 &le; Data of a node &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-162">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-bracket-number4058/1" target="_blank" rel="noopener noreferrer">Print Bracket Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">regularexpression</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>str</strong>, the task is to find the bracket numbers, i.e., for each bracket in str, return <strong>i</strong> if the bracket is the <strong>i<sup>th</sup></strong> opening or closing bracket&nbsp;to appear in the string.&nbsp;</span></p>
<p><strong><span style="font-size: 18px;">&nbsp;Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>  str = "(aa(bdc))p(dee)</span><span style="font-size: 18px;">"
<strong>Output:</strong> 1 2 2 1 3 3
<strong>Explanation:</strong> The highlighted brackets in
the given string <strong>(</strong>aa<strong>(</strong>bdc<strong>))</strong>p<strong>(</strong>dee<strong>)</strong> are
assigned the numbers as: 1 2 2 1 3 3.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>  str = "(((()("
<strong>Output:</strong> 1 2 3 4 4 5
<strong>Explanation:</strong> The highlighted brackets in
the given string <strong>(((()(</strong> are assigned
the numbers as: 1 2 3 4 4 5</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(|str|)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(|str|)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= |str| &lt;= 10<sup>5</sup></span><br /><span style="font-size: 18px;">str contains lowercase English alphabets, and '(', ')' characters<br />At any index, the number of opening brackets is greater than or equal to closing brackets</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-163">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-leaf-nodes-from-preorder-traversal-of-bst2657/1" target="_blank" rel="noopener noreferrer">Print leaf nodes from preorder traversal of BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binarysearchtree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>preorder</strong> traversal of a <strong>BST</strong>, find&nbsp;the <strong>leaf nodes</strong> of the tree without building the tree.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>preorder[] = [5, 2, 10]<strong><br /></strong><strong>Output:</strong> [2, 10]
<strong>Explaination:</strong> <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895564/Web/Other/blobid0_1747480179.jpg" width="196" height="140" /><br />2 and 10 are the leaf nodes as shown in the figure.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>preorder[] = [4, 2, 1, 3, 6, 5]
<strong>Output:</strong> [1, 3, 5]
<strong>Explaination:</strong> <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895564/Web/Other/blobid1_1747480193.jpg" width="223" height="187" /><br />1, 3 and 5 are the leaf nodes as shown in the figure.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>preorder[] = [8, 2, 5, 10, 12]<strong><br /></strong><strong>Output:</strong> [5, 12]
<strong>Explaination:</strong> <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/895564/Web/Other/blobid2_1747480202.jpg" width="206" height="200" /><br />5 and 12 are the leaf nodes as shown in the figure.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le;&nbsp;</span><span style="font-size: 18px;">preorder.size()</span><span style="font-size: 18px;">&nbsp;&le; 10</span><sup>3<br /></sup><span style="font-size: 18px;">1 &le;&nbsp;</span><span style="font-size: 18px;">preorder</span><span style="font-size: 18px;">[i]&nbsp;&le; 10</span><sup>3</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-164">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/queue-reversal/1" target="_blank" rel="noopener noreferrer">Queue Reversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a queue <span style="font-family: Arial;"><span style="white-space-collapse: preserve; background-color: #ffffff;"><strong>q </strong></span></span>containing integer elements, your task is to reverse the queue.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong><span style="font-family: Arial; text-wrap-mode: wrap; background-color: #ffffff;">q</span>[] = [4 3 1 10 2 6]
<strong>Output: </strong>[6, 2, 10, 1, 3, 4]
<strong>Explanation: </strong>After reversing the given elements of the queue, the resultant queue will be 6 2 10 1 3 4.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong><span style="font-family: Arial; text-wrap-mode: wrap; background-color: #ffffff;">q</span>[] = [4 3 2 1]
<strong>Output: </strong>[1, 2, 3, 4]
<strong>Explanation: </strong>After reversing the given elements of the queue, the resultant queue will be 1 2 3 4.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong><span style="font-family: Arial; text-wrap-mode: wrap; background-color: #ffffff;">q</span>[] = [7, 9, 5, 12, 8]
<strong>Output: </strong>[8, 12, 5, 9, 7]
<strong>Explanation: </strong>After reversing the given elements of the queue, the resultant queue will be 8, 12, 5, 9, 7.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; q.size() &le; 10<sup>6</sup><br />1 &le; q[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-165">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/queue-using-stack/1" target="_blank" rel="noopener noreferrer">Queue using stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">design-pattern</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Implement a Queue&nbsp;using two stack</span><span style="font-size: 18px;"><strong>&nbsp;s1</strong>&nbsp;and<strong>&nbsp;s2</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>enqueue(2)
enqueue(3)
dequeue()
enqueue(4)
dequeue()<strong>
Output: </strong>2 3
<strong>Explanation:
</strong>enqueue(2) the queue will be [2]
enqueue(3) the queue will be [2, 3]
dequeue() the poped element will be <strong>2</strong> 
the queue will be [3]
enqueue(4) the queue will be [3, 4]
dequeue() the poped element will be [<strong>3]</strong>. &nbsp;
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>enqueue(2)
dequeue()
dequeue()<strong>
Output: </strong>2 -1</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;=<strong>&nbsp;</strong>Number of queries&nbsp;&lt;= 100<br />1 &lt;= values of the stack&nbsp;&lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-166">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/queue-using-two-stacks/1" target="_blank" rel="noopener noreferrer">Queue using two Stacks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Implement a Queue using 2 stacks<strong> s1</strong> and<strong> s2</strong> .<br />A Query <strong>q </strong>is of 2 Types<br /><strong>(i)</strong> 1 x (a query of this type means&nbsp;&nbsp;pushing <strong>'x'</strong> into the queue)<br /><strong>(ii)</strong> 2 &nbsp; (a query of this type means to pop&nbsp;element from queue and print the poped element)</span></p>
<p><span style="font-size: 18px;"><strong>Note :</strong>&nbsp;If there is no element return -1 as answer while popping.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">q=5, queries[][]=[[1, 2], [1, 3], [2], [1, 4], [2]]
<strong>Output: </strong>[2, 3]<strong><br /></strong><strong>Explanation: 
</strong>In the first testcase
[1 2] the queue will be [2]
[1 3] the queue will be [2 3]
[2] &nbsp; poped element will be 2 the queue 
will be [3]
[1 4] the queue will be [3 4]
[2 ]&nbsp; poped element will be 3.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">q = 4, queries[][] = [[1, 2], [2], [2], [1, 4]]
<strong>Output: </strong>[2, -1]
<strong>Explanation: 
</strong>In the second testcase&nbsp;
[1, 2] the queue will be [2]
[2]&nbsp; &nbsp;poped element will be [2] and 
&nbsp;   then the queue will be empty
[2]&nbsp; &nbsp;the queue is empty and hence -1
[1, 4] the queue will be [4].</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;=<strong> </strong>q&nbsp;&lt;= 100<br />1 &lt;= x &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-167">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/redundant-parenthesis--170647/1" target="_blank" rel="noopener noreferrer">Redundant Parenthesis</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a valid expression containing only binary operators&nbsp;<strong>'+', '-', '*', '/' </strong>and operands,&nbsp;remove all the redundant parenthesis.</span></p>
<blockquote>
<p><span style="font-size: 18px;">A set of parenthesis is said to be redundant&nbsp;if,&nbsp;removing them, does not change the value of the expression.</span></p>
</blockquote>
<p><span style="font-size: 18px;"><strong>Note: </strong>The operators&nbsp;<strong>'+'</strong> and <strong>'-'</strong> have the same priority. <strong>'*'</strong> and <strong>'/'</strong> also have the same priority. <strong>'*'</strong> and <strong>'/'</strong> have more priority than <strong>'+'</strong> and <strong>'-'</strong>.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>:
Exp = (A*(B+C))
<strong>Output:</strong>&nbsp;A*(B+C)
<strong>Explanation</strong>: The outermost parenthesis
are redundant.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
Exp = A+(B+(C))
<strong>Output:&nbsp;</strong>A+B+C
<strong>Explanation</strong>: All the parenthesis
are redundant.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>removeBrackets()</strong>&nbsp;which takes the string <strong>Exp&nbsp;</strong>as input parameters&nbsp;and returns the updated expression.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N)<br /><strong>Expected Auxiliary Space:</strong> O(N)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 <u>&lt;</u> Length of Exp <u>&lt;</u>&nbsp;10<sup>5</sup><br />Exp contains uppercase english letters, '(' , ')', '+', '-', '*' and '/'.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-168">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description" target="_blank" rel="noopener noreferrer">Remove All Adjacent Duplicates In String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>adjacent</strong> and <strong>equal</strong> letters and removing them.</p>

<p>We repeatedly make <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p>

<p>Return <em>the final string after all such duplicate removals have been made</em>. It can be proven that the answer is <strong>unique</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abbaca&quot;
<strong>Output:</strong> &quot;ca&quot;
<strong>Explanation:</strong> 
For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;azxxzy&quot;
<strong>Output:</strong> &quot;ay&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-169">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/description" target="_blank" rel="noopener noreferrer">Remove All Adjacent Duplicates in String II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and an integer <code>k</code>, a <code>k</code> <strong>duplicate removal</strong> consists of choosing <code>k</code> adjacent and equal letters from <code>s</code> and removing them, causing the left and the right side of the deleted substring to concatenate together.</p>

<p>We repeatedly make <code>k</code> <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p>

<p>Return <em>the final string after all such duplicate removals have been made</em>. It is guaranteed that the answer is <strong>unique</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, k = 2
<strong>Output:</strong> &quot;abcd&quot;
<strong>Explanation: </strong>There&#39;s nothing to delete.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;deeedbbcccbdaa&quot;, k = 3
<strong>Output:</strong> &quot;aa&quot;
<strong>Explanation: 
</strong>First delete &quot;eee&quot; and &quot;ccc&quot;, get &quot;ddbbbdaa&quot;
Then delete &quot;bbb&quot;, get &quot;dddaa&quot;
Finally delete &quot;ddd&quot;, get &quot;aa&quot;</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;pbbcggttciiippooaais&quot;, k = 2
<strong>Output:</strong> &quot;ps&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> only contains lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-170">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-all-occurrences-of-a-substring/description" target="_blank" rel="noopener noreferrer">Remove All Occurrences of a Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>s</code> and <code>part</code>, perform the following operation on <code>s</code> until <strong>all</strong> occurrences of the substring <code>part</code> are removed:</p>

<ul>
	<li>Find the <strong>leftmost</strong> occurrence of the substring <code>part</code> and <strong>remove</strong> it from <code>s</code>.</li>
</ul>

<p>Return <code>s</code><em> after removing all occurrences of </em><code>part</code>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;daabcbaabcbc&quot;, part = &quot;abc&quot;
<strong>Output:</strong> &quot;dab&quot;
<strong>Explanation</strong>: The following operations are done:
- s = &quot;da<strong><u>abc</u></strong>baabcbc&quot;, remove &quot;abc&quot; starting at index 2, so s = &quot;dabaabcbc&quot;.
- s = &quot;daba<strong><u>abc</u></strong>bc&quot;, remove &quot;abc&quot; starting at index 4, so s = &quot;dababc&quot;.
- s = &quot;dab<strong><u>abc</u></strong>&quot;, remove &quot;abc&quot; starting at index 3, so s = &quot;dab&quot;.
Now s has no occurrences of &quot;abc&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;axxxxyyyyb&quot;, part = &quot;xy&quot;
<strong>Output:</strong> &quot;ab&quot;
<strong>Explanation</strong>: The following operations are done:
- s = &quot;axxx<strong><u>xy</u></strong>yyyb&quot;, remove &quot;xy&quot; starting at index 4 so s = &quot;axxxyyyb&quot;.
- s = &quot;axx<strong><u>xy</u></strong>yyb&quot;, remove &quot;xy&quot; starting at index 3 so s = &quot;axxyyb&quot;.
- s = &quot;ax<strong><u>xy</u></strong>yb&quot;, remove &quot;xy&quot; starting at index 2 so s = &quot;axyb&quot;.
- s = &quot;a<strong><u>xy</u></strong>b&quot;, remove &quot;xy&quot; starting at index 1 so s = &quot;ab&quot;.
Now s has no occurrences of &quot;xy&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>1 &lt;= part.length &lt;= 1000</code></li>
	<li><code>s</code>â€‹â€‹â€‹â€‹â€‹â€‹ and <code>part</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-iteration">Approach 1: Iteration</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a string <code>s</code> and a substring <code>part</code>, and we need to repeatedly remove the first occurrence of <code>part</code> from <code>s</code> until it no longer appears. Since the constraints are relatively small (<code>s.length &lt;= 1000</code> and <code>part.length &lt;= 1000</code>), we can try a brute force approach.</p>
<p>We can use a simple iterative approach which loops through <code>s</code> as long as <code>part</code> is present in it. Each time we find <code>part</code>, we need to remove its first occurrence. To do this, we first locate the leftmost occurrence of <code>part</code> in <code>s</code>. Once we know where it starts, we can break <code>s</code> into three sections: the part of the string before the occurrence of <code>part</code>, the occurrence of <code>part</code> itself, and the part of the string after <code>part</code>. By combining the first and third sections (effectively leaving out the middle section), we remove that occurrence of <code>part</code> from <code>s</code>.</p>
<p>When the loop finishes, <code>s</code> will no longer contain any occurrences of <code>part</code>, so we return it as the result.</p>
<blockquote>
<p>Itâ€™s worth noting that we can simplify this process by utilizing built-in string methods provided by the programming language.<br />
For instance, in Java, the <code>String.replaceFirst</code> method can be used to replace the first occurrence of a substring, in Python3 we can use <code>str.replace</code>, and in C++ we can use a combination of <code>std::string::erase</code> and <code>std::string::find</code>.<br />
Most of the time, it is beneficial to use these built-in functions since they are heavily optimized and tested, and will almost always perform better than our own implementations.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Run a <code>while</code> loop to repeatedly check if the string <code>s</code> contains the substring <code>part</code>.
<ul>
<li>Find the index of the leftmost occurrence of <code>part</code> in <code>s</code> and store it in a variable <code>partStartIndex</code>.</li>
<li>Use the substring method to extract the portion of <code>s</code> before <code>part</code> (<code>s.substring(0, partStartIndex)</code>) and the portion after <code>part</code> (<code>s.substring(partStartIndex + part.length())</code>).</li>
<li>Concatenate the first and last portions and assign it back to <code>s</code>.</li>
</ul>
</li>
<li>Return the updated string <code>s</code>, which no longer contains any occurrences of <code>part</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/mrwKgtYj/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span> and <span class="math inline">\(m\)</span> be the length of the substring <code>part</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a <code>while</code> loop to repeatedly remove the leftmost occurrence of <code>part</code> from <code>s</code>. Each iteration of the loop involves finding the index of <code>part</code>, which takes <span class="math inline">\(O(n \cdot m)\)</span> time, and then creating a new string by concatenating the segments before and after <code>part</code>, which takes <span class="math inline">\(O(n)\)</span> time. In the worst case, there are <span class="math inline">\(O(n/m)\)</span> such iterations (e.g., when <code>part</code> is non-overlapping and removed sequentially). The total time across all iterations is <span class="math inline">\(O((n \cdot m) \cdot (n/m)) = O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Although the algorithm does not explicitly use additional data structures, each iteration creates a new string by concatenating the segments before and after part. This results in the creation of intermediate strings, each of size up to <span class="math inline">\(O(n)\)</span>. The space required to store these intermediate strings dominates the space complexity, leading to <span class="math inline">\(O(n)\)</span> space usage.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-stack">Approach 2: Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the first approach, we relied on built-in methods to find and remove substrings. Letâ€™s explore how to implement this functionality entirely on our own.</p>
<p>One issue with repeatedly removing substrings from a string is that it requires recreating the entire string every time. We need a way such that removing the substring characters from a string at any point is as close to constant time as possible.</p>
<p>We can simulate this using a stack. A stack allows us to remove its topmost element in constant time. So, if we incrementally put the characters of <code>s</code> in the stack, the moment we find out that the last part of the stack forms <code>part</code>, we simply pop the entire substring out. This means we needed to only loop over the length of <code>part</code>, rather than the entire string <code>s</code>.</p>
<p>To implement this, we can loop over each character of <code>s</code> and add it to the stack. As we add characters, we constantly check if the most recent portion of the stack matches the substring <code>part</code>. If it does, we remove those characters from the stack. This approach avoids scanning the entire string repeatedly and only focuses on the portions of <code>s</code> that could potentially contain <code>part</code>.</p>
<p>However, if at any point the characters donâ€™t match, it means that the stack doesnâ€™t contain <code>part</code> at the top. In that case, any intermediate pops made during the check need to be undone, so the characters are pushed back onto the stack in the correct order. The process continues for the rest of the string.</p>
<p>When we finish processing all the characters in <code>s</code>, the stack will contain the modified version of <code>s</code> with all occurrences of <code>part</code> removed. At this point, the stackâ€™s contents are reversed compared to the original string, so we reverse them back to produce the final result, which is then returned.</p>
<blockquote>
<p>For a more comprehensive understanding of stacks, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/">Stack Explore Card ðŸ”—</a>. This resource provides an in-depth look at stacks, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a stack of characters <code>stk</code> to store the characters of the string as they are processed.</li>
<li>Calculate the lengths of the input string <code>s</code> and the substring <code>part</code>, storing them in <code>strLength</code> and <code>partLength</code>, respectively.</li>
<li>Use a <code>for</code> loop to iterate through each character in the string <code>s</code>, starting from index <code>0</code> and ending at <code>strLength - 1</code>.
<ul>
<li>Push the current character of the string onto the stack.</li>
<li>Check if the size of the stack is greater than or equal to <code>partLength</code>. If so:
<ul>
<li>Use the helper method <code>checkMatch</code> to check if the top of the stack matches <code>part</code>:
<ul>
<li>If a match is found, pop the top <code>partLength</code> characters from the stack.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>After processing the entire string, initialize a string <code>result</code> to construct the resulting string.</li>
<li>While the stack is not empty, pop each character from the stack and append it to the <code>result</code>.</li>
<li>Reverse the order of <code>result</code> to correct the sequence of characters and return it.</li>
</ul>
<p>Helper method <code>checkMatch(stk, part, partLength)</code>:</p>
<ul>
<li>Initialize a temporary stack <code>temp</code> and copy all characters from the original stack <code>stk</code> into <code>temp</code>.</li>
<li>Use a <code>for</code> loop to iterate over <code>part</code> in reverse order, starting from index <code>partLength - 1</code> and ending at <code>0</code>. For each character:
<ul>
<li>Compare the current character of <code>part</code> with the top character of <code>temp</code>:
<ul>
<li>If they do not match, return <code>false</code>.</li>
<li>Else, remove the top character from <code>temp</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If all characters of <code>part</code> match the top characters of the stack in reverse order, return <code>true</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/HL2DXsSB/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>, and <span class="math inline">\(m\)</span> be the length of the substring <code>part</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm iterates through each character of the string <code>s</code>, contributing <span class="math inline">\(O(n)\)</span> to the complexity. For each character pushed onto the stack, the algorithm checks if the top <span class="math inline">\(m\)</span> characters of the stack match <code>part</code>. This involves an <span class="math inline">\(O(m)\)</span> comparison for potential matches. Since this check can occur for each character in <code>s</code>, the worst-case time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The stack stores up to <span class="math inline">\(O(n)\)</span> characters in the worst case (e.g., when no <code>part</code> substrings are removed). The temporary stack <code>temp</code> in the <code>checkMatch</code> function also requires <span class="math inline">\(O(n)\)</span> space. Additionally, the <code>potentialMatch</code> string temporarily stores up to <span class="math inline">\(O(m)\)</span> characters during each iteration. So, the total space complexity is <span class="math inline">\(O(n)\)</span> (stacks) + <span class="math inline">\(O(m)\)</span> (temporary <code>potentialMatch</code>), which simplifies to <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-knuth-morris-pratt-kmp-algorithm">Approach 3: Knuth-Morris-Pratt (KMP) Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>So far, we have relied on a naive approach for pattern matching, where we slide the pattern (<code>part</code>) over the string (<code>s</code>) one character at a time and check for a match. For example, if <code>s = &quot;ABABDABACDABABCABAB&quot;</code> and <code>part = &quot;ABABCABAB&quot;</code>, the naive approach compares <code>part</code> with every substring of <code>s</code> of the same length, often rechecking characters unnecessarily. Consider the scenario where the first four characters, <code>&quot;ABAB&quot;</code>, match, but a mismatch occurs with the fifth character. In the naive approach, the pattern is shifted by just one character, and the comparison restarts from the beginning of <code>part</code>, rechecking <code>&quot;BAB&quot;</code> again. This results in redundant comparisons and inefficiency.</p>
<p>The Knuth-Morris-Pratt (KMP) algorithm optimizes this by using a longest prefix-suffix (LPS) array for the pattern. The LPS array helps determine how much of the pattern has been matched so far, allowing the algorithm to skip redundant comparisons. When a mismatch happens, instead of starting over from the beginning, we use the LPS array to shift the pattern by an appropriate amount.</p>
<p>For example, if weâ€™ve matched <code>&quot;ABABC&quot;</code> but encounter a mismatch at the 6th character, the LPS value for <code>&quot;ABABC&quot;</code> is 1. We then shift the pattern by 4 characters (5 â€“ 1) and continue matching. This avoids rechecking parts of the pattern weâ€™ve already matched.</p>
<p>For example, consider the pattern <code>part = &quot;ABABCABAB&quot;</code>. Let's see how we build up the LPS array in the slideshow below:</p>
<p>!?!../Documents/1910/p_slideshow.json:848,766!?!</p>
<p>The LPS array allows the KMP algorithm to skip unnecessary comparisons when a mismatch occurs. When a mismatch happens, instead of starting over from the beginning of the pattern, the algorithm uses the LPS array to determine how much of the pattern has already been matched. It then shifts the pattern by an appropriate amount and continues matching.</p>
<p>For example, letâ€™s say weâ€™re matching <code>part = &quot;ABABCABAB&quot;</code> against <code>s = &quot;ABABDABACDABABCABAB&quot;</code>. Suppose weâ€™ve matched the first 4 characters (<code>&quot;ABAB&quot;</code>) but encounter a mismatch at the 5th character. The LPS value for the prefix <code>&quot;ABAB&quot;</code> is <code>2</code>, so we know that the first 2 characters of the pattern are already matched. Instead of starting over, we shift the pattern by 2 characters (length of the matched prefix minus the LPS value: <code>4 - 2 = 2</code>) and continue matching. This skipping of unnecessary comparisons makes the KMP algorithm much more efficient.</p>
<p>The LPS array is built using a linear iterative approach. We initialize two pointers: <code>current</code> (to traverse <code>part</code>) and <code>prefixLength</code> (to track the length of the matching prefix-suffix). We then iterate through the pattern:</p>
<ul>
<li>If the characters at current and <code>prefixLength</code> match, we increment both pointers and set <code>lps[current] = prefixLength</code>.</li>
<li>If they donâ€™t match and <code>prefixLength</code> is not zero, we backtrack <code>prefixLength</code> to <code>lps[prefixLength - 1]</code>.</li>
<li>If they donâ€™t match and <code>prefixLength</code> is zero, we set <code>lps[current] = 0</code> and increment <code>current</code>.</li>
</ul>
<p>Here's a slideshow to visualize this process better:</p>
<p>!?!../Documents/1910/slideshow.json:762,826!?!</p>
<p>Finally, we process each character of <code>s</code> while using the LPS array to track how much of <code>part</code> has been matched. We iterate over <code>s</code> and when a complete match is found, we remove the matched substring from the stack. If a mismatch occurs, we use the LPS array to backtrack and continue matching.</p>
<p>After processing all characters of <code>s</code>, the stack contains the characters of <code>s</code> with all occurrences of part removed. We convert the stack into a string by popping characters and reversing the <code>result</code> (since stacks are last-in-first-out). We return this <code>result</code> as our answer.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Call the helper method <code>computeLongestPrefixSuffix</code> with the substring <code>part</code> to calculate the Longest Prefix Suffix (LPS) array.</li>
<li>Create a stack <code>charStack</code> to store characters of the string <code>s</code> as they are processed.</li>
<li>Declare an array <code>patternIndexes</code> of size <code>s.length() + 1</code> to keep track of the pattern index for each character in the stack.</li>
<li>Use a <code>for</code> loop to iterate through each character in the string <code>s</code>. Also, maintain a variable <code>patternIndex</code> to track the current position in the substring <code>part</code>.
<ul>
<li>Push the current character onto the stack.</li>
<li>If the current character matches the character at <code>patternIndex</code> in <code>part</code>:
<ul>
<li>Increment <code>patternIndex</code> and store it in <code>patternIndexes[charStack.size()]</code>.</li>
<li>If <code>patternIndex</code> equals the length of <code>part</code>, the pattern is fully matched:
<ul>
<li>Pop <code>part.length()</code> characters from the stack to remove the matched pattern.</li>
<li>Reset <code>patternIndex</code> to <code>patternIndexes[charStack.size()]</code> if the stack is not empty, otherwise set it to <code>0</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If the current character does not match the character at <code>patternIndex</code> in <code>part</code>:
<ul>
<li>If <code>patternIndex</code> is not 0, backtrack by setting <code>patternIndex</code> to <code>lps[patternIndex - 1]</code> and decrement <code>strIndex</code> to reprocess the current character.</li>
<li>If <code>patternIndex</code> is 0, set <code>patternIndexes[charStack.size()]</code> to <code>0</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>result</code> to construct the result string from the remaining characters in the stack.</li>
<li>Reverse the constructed string and return it as the output.</li>
</ul>
<p>Helper method <code>computeLongestPrefixSuffix(pattern)</code></p>
<ul>
<li>Create an array <code>lps</code> of size equal to the length of the pattern <code>part</code> to store the lengths of the longest proper prefix which is also a suffix.</li>
<li>Use a <code>for</code> loop to traverse the pattern <code>part</code> starting from index <code>1</code>. Maintain a variable <code>prefixLength</code> to track the length of the longest prefix-suffix.
<ul>
<li>If the character at the current position matches the character at <code>prefixLength</code>:
<ul>
<li>Increment <code>prefixLength</code> and store it in <code>lps[current]</code>.</li>
<li>Proceed to the next character.</li>
</ul>
</li>
<li>Else if the characters do not match and <code>prefixLength</code> is non-zero:
<ul>
<li>Backtrack to the previous longest prefix-suffix using the LPS array.</li>
</ul>
</li>
<li>If no match is found and <code>prefixLength</code> is zero, set <code>lps[current]</code> to zero and proceed to the next character.</li>
</ul>
</li>
<li>Return the fully constructed <code>lps</code> array.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/GsYagfpK/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>, and <span class="math inline">\(m\)</span> be the length of the substring <code>part</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span> for Java and Python3, <span class="math inline">\(O(n^2 + m)\)</span> for C++</p>
<p>The algorithm consists of two main components: the preprocessing step to compute the KMP longest prefix-suffix (<code>lps</code>) array and the traversal of the string <code>s</code>.</p>
<p>The preprocessing step takes <span class="math inline">\(O(m)\)</span> time, as the <code>lps</code> array is computed for the pattern <code>part</code>.</p>
<p>The traversal of <code>s</code> uses a stack and performs efficient pattern matching with the help of the <code>lps</code> array. Each character in <code>s</code> is processed once, and backtracking in the pattern matching is guided by the <code>lps</code> array, ensuring that each character is examined only a constant number of times. Thus, the traversal takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Combining these two components, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
<p>However, the result construction step in the C++ solution has a time complexity of <span class="math inline">\(O(n^2)\)</span> due to repeated string modifications. As a result, the overall time complexity of the C++ solution becomes <span class="math inline">\(O(n^2 + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The primary space usage comes from the stack, which can store up to <span class="math inline">\(n\)</span> characters in the worst case if no matches are removed. Additionally, the pattern matching indices array requires <span class="math inline">\(O(n)\)</span> space, and the <code>lps</code> array used for KMP preprocessing requires <span class="math inline">\(O(m)\)</span> space. These components together result in a total space complexity of <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-171">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-duplicate-letters/description" target="_blank" rel="noopener noreferrer">Remove Duplicate Letters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <span data-keyword="lexicographically-smaller-string"><strong>the smallest in lexicographical order</strong></span> among all possible results.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bcabc&quot;
<strong>Output:</strong> &quot;abc&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbacdcbc&quot;
<strong>Output:</strong> &quot;acdb&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1081: <a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/" target="_blank">https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-172">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/remove-friends-5/" target="_blank" rel="noopener noreferrer">Remove Friends</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">medium</span> <span class="topic-badge">open</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>After getting her PhD, Christie has become a celebrity at her university, and her facebook profile is full of friend requests. Being the nice girl she is, Christie has accepted all the requests.</p>
<p>Now Kuldeep is jealous of all the attention she is getting from other guys, so he asks her to delete some of the guys from her friend list. </p>
<p>To avoid a 'scene', Christie decides to remove some friends from her friend list, since she knows the popularity of each of the friend she has, she uses the following algorithm to delete a friend.</p>
<p><strong>Algorithm     </strong>
<strong>Delete(Friend):</strong><br />
Â Â Â Â DeleteFriend=false<br />
Â Â Â Â for i = 1 to Friend.length-1<br />
Â Â Â Â Â Â Â Â  if (Friend[i].popularity &lt; Friend[i+1].popularity)<br />
Â Â Â Â Â Â Â Â Â Â Â Â delete <strong>i</strong> th friend<br />
Â Â Â Â Â Â Â Â Â Â Â Â DeleteFriend=true<br />
Â Â Â Â Â Â Â Â Â Â Â Â break<br />
Â Â Â Â if(DeleteFriend == false)<br />
Â Â Â Â Â Â Â Â delete the last friend<br /></p>
<p><strong>Input:</strong> <br />
First line contains <strong>T</strong> number of test cases.
First line of each test case contains <strong>N</strong>, the number of friends Christie currently has and <strong>K</strong> ,the number of friends Christie decides to delete.
Next  lines contains <strong>popularity</strong> of her friends separated by space.  </p>
<p><strong>Output:</strong> <br />
For each test case print <strong>N-K</strong> numbers which represent popularity of Christie friend's after deleting <strong>K</strong> friends. </p>
<p><strong>Constraints</strong><br />
1&lt;=<strong>T</strong>&lt;=1000<br />
1&lt;=<strong>N</strong>&lt;=100000<br />
0&lt;=<strong>K</strong>&lt; N <br />
0&lt;=<strong>popularity_of_friend</strong>&lt;=100  </p>
<p><strong>NOTE:</strong><br />
Order of friends after deleting exactly <strong>K</strong> friends should be maintained as given in input.<br /></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-173">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-k-digits/description" target="_blank" rel="noopener noreferrer">Remove K Digits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given string num representing a non-negative integer <code>num</code>, and an integer <code>k</code>, return <em>the smallest possible integer after removing</em> <code>k</code> <em>digits from</em> <code>num</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;1432219&quot;, k = 3
<strong>Output:</strong> &quot;1219&quot;
<strong>Explanation:</strong> Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;10200&quot;, k = 1
<strong>Output:</strong> &quot;200&quot;
<strong>Explanation:</strong> Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;10&quot;, k = 2
<strong>Output:</strong> &quot;0&quot;
<strong>Explanation:</strong> Remove all the digits from the number and it is left with nothing which is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= num.length &lt;= 10<sup>5</sup></code></li>
	<li><code>num</code> consists of only digits.</li>
	<li><code>num</code> does not have any leading zeros except for the zero itself.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-174">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/remove-k-digits/1" target="_blank" rel="noopener noreferrer">Remove K Digits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a non-negative integer <strong>s</strong> represented as a string, remove<strong> k</strong>&nbsp;digits from the number so that the new number is the smallest possible.<br /><strong>Note :&nbsp;</strong>The given&nbsp;<em>number </em>does not contain any leading zero.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s<strong> = </strong>"149811",<strong> </strong>k = 3
<strong>Output:</strong> 111
<strong>Explanation</strong>: Remove the three digits 4, 9, and 8 to form the new number 111 which is smallest.<br /></span>
</pre>
<pre><span style="font-size: 18px;"><span style="font-size: 14pt;"><strong>Input</strong>: s = "1002991", k = 3 <br /></span></span><span style="font-size: 18px;"><span style="font-size: 14pt;"><strong>Output:</strong> 21
<strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</span></strong>: Remove the three digits 1(leading one), 9, and 9 to form the new number 21(Note that the output must not contain </span>leading zeroes) which is the smallest.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;= k</span><span style="font-size: 18px;">&lt;= </span><span style="font-size: 18px;">|s|&lt;=10</span><sup>6</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-175">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-nodes-from-linked-list/description" target="_blank" rel="noopener noreferrer">Remove Nodes From Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked-list</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list.</p>

<p>Remove every node which has a node with a greater value anywhere to the right side of it.</p>

<p>Return <em>the </em><code>head</code><em> of the modified linked list.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/02/drawio.png" style="width: 631px; height: 51px;" />
<pre>
<strong>Input:</strong> head = [5,2,13,3,8]
<strong>Output:</strong> [13,8]
<strong>Explanation:</strong> The nodes that should be removed are 5, 2 and 3.
- Node 13 is to the right of node 5.
- Node 13 is to the right of node 2.
- Node 8 is to the right of node 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1,1,1,1]
<strong>Output:</strong> [1,1,1,1]
<strong>Explanation:</strong> Every node has value 1, so no nodes are removed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the given list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given the head of a linked list, the task is to remove every node that has a node with a greater value anywhere on its right side. This means that after processing the linked list, every node will only have nodes with smaller values to their right, or the linked list should be in decreasing order.</p>
<p><strong>Key Observations</strong></p>
<ol>
<li>The nodes in the linked list have positive values.</li>
<li>There may be duplicate values.</li>
<li>We manipulate the list by deleting values, not by sorting it.</li>
</ol>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>A challenge associated with this problem is that, for a given node, we need to not only delete the node directly to the right if it has a larger value but also delete all other nodes to the right that have larger values. The brute force approach involves iterating through the linked list using nested loops, comparing the value of each node with the nodes that follow it, and deleting any nodes whose values are smaller than the following nodes. However, this approach is inefficient, with a quadratic time complexity.</p>
<p>The resultant linked list should be in decreasing order. We can leverage this fact to develop a more efficient solution.</p>
<p>A list in decreasing order, if reversed, is in increasing order.</p>
<p>If we reverse the list, the node values should be in increasing order after deleting nodes. We can delete any nodes whose values are smaller than the nodes before them. This strategy ensures efficient deletion of all nodes that have nodes with a greater value to their right (in the original order) without using nested loops.</p>
<p>The list we are given is a singly linked list, so we can't easily traverse it in reverse from tail to head.</p>
<p>Whenever a problem requires reversing a sequence, it is worth considering using a stack.</p>
<p>Stacks are a First-In-Last-Out (FILO) data structure, meaning that the first items added to the stack are the last ones removed. Consequently, if you push a sequence of items into a stack and then remove them, the sequence will be reversed. Learn more about stacks by reading our <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card</a>.</p>
<p>We start by adding all of the nodes to a stack.</p>
<p>Next, we create a new linked list to store the result. We keep track of the maximum node value encountered so far using the variable <code>maximum</code>.</p>
<p>Then, we pop each node from the stack. If the node's value is not smaller than the <code>maximum</code>, we create a new node with that value and add it to the <code>resultList</code>. Since the linked list is reversed, we build the <code>resultList</code> from back to front, continuously adding new nodes to the beginning.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an empty <code>stack</code> to be used for reversing the nodes.</li>
<li>Set a pointer <code>current</code> to <code>head</code>.</li>
<li>While <code>current</code> is not <code>Null</code>:
<ul>
<li>Add <code>current</code> to the <code>stack</code>.</li>
<li>Set <code>current</code> to <code>current.next</code>.</li>
</ul>
</li>
<li>Pop the node from the top of the <code>stack</code> and set <code>current</code> to that node.</li>
<li>Initialize a variable <code>maximum</code> to <code>current.val</code>.</li>
<li>Create a new ListNode <code>resultList</code> with <code>maximum</code> as its value.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop the node from the top of the <code>stack</code> and set <code>current</code> to that node.</li>
<li>If <code>current.val</code> &lt; <code>maximum</code>:
<ul>
<li>Continue; this node does not need to be added to the <code>resultList</code>.</li>
</ul>
</li>
<li>Otherwise, add a new node to the front of the <code>resultList</code>:
<ul>
<li>Create a new ListNode <code>newNode</code> with <code>current.val</code> as its value.</li>
<li>Set <code>newNode.next</code> to <code>resultList</code>.</li>
<li>Set <code>resultList</code> to <code>newNode</code>.</li>
<li>Update <code>maximum</code> to <code>current.val</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>resultList</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2487/2487_slideshow2.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/2CTMtkxy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Adding the nodes from the original linked list to the stack takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Removing nodes from the stack and adding them to the result takes <span class="math inline">\(O(n)\)</span>, as each node is popped from the stack exactly once.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(2n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We add each of the nodes from the original linked list to the <code>stack</code>, making its size <span class="math inline">\(n\)</span>.</p>
<p>We only use <code>resultList</code> to store the result, so it does not contribute to the space complexity.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The nodes we retain in the linked list must meet the following criteria: Each node's value is not smaller than the values of the following nodes.</p>
<p>Linked lists are often manipulated using recursion. This problem is an excellent candidate for recursion because it can be broken down into subproblems that collectively solve the main problem.</p>
<p>Consider a node <span class="math inline">\(B\)</span> situated in the middle of the linked list, where all subsequent nodes have values less than or equal to <span class="math inline">\(B\)</span>'s value. If node <span class="math inline">\(B\)</span> satisfies this criterion, its value is not smaller than the values of the following nodes. For the node <span class="math inline">\(A\)</span> directly preceding <span class="math inline">\(B\)</span>, if <span class="math inline">\(A\)</span> is not smaller than <span class="math inline">\(B\)</span>, then <span class="math inline">\(A\)</span> is also not smaller than any nodes following <span class="math inline">\(B\)</span>. This holds due to the transitive property: if <span class="math inline">\(a \geq b\)</span> and <span class="math inline">\(b \geq c\)</span>, then <span class="math inline">\(a \geq c\)</span>.</p>
<p>This means that if we've solved the subproblem for nodes to the right of a given node in the linked list, we can efficiently solve the problem for that node.</p>
<p>Let`s begin by discussing the base cases:</p>
<ol>
<li>
<p>The linked list is empty:</p>
<ul>
<li>An empty list meets the criteria, so we return the <code>head</code>.</li>
</ul>
</li>
<li>
<p>The linked list has only one node:</p>
<ul>
<li>A list with one node also meets the criteria, because there are no following nodes. Again, we return the <code>head</code>.</li>
</ul>
</li>
</ol>
<p>We can develop a strategy for handling longer lists by thinking about handling a linked list with two nodes.</p>
<p>For a linked list with two nodes, there are two cases for the <code>head</code> node:</p>
<ol>
<li>
<p>The <code>head</code> node's value is the same size or larger than the next node's value.</p>
<ul>
<li>This linked list meets the criteria. Return the list.</li>
</ul>
</li>
<li>
<p>The <code>head</code> node's value is smaller than the next node's value.</p>
<ul>
<li>We need to delete <code>head</code>. Return the next node.</li>
</ul>
</li>
</ol>
<p>For linked lists with more than two nodes, the main adjustment we need to make is to check the rest of the linked list.</p>
<p>The challenge we face is ensuring that <code>head.next</code> is set to the correct next node. Does the next node also need to be deleted? Are there other nodes later in the linked list that have values that are greater than <code>head</code>?</p>
<p>Instead of simply setting <code>head</code> to <code>head.next</code> to progress to the next node, we recursively call <code>removeNodes(head.next)</code>. This recursive function removes nodes with greater values anywhere to the right. This ensures that <code>head</code> is set to the correct node and that the rest of the linked list also meets the criteria.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Base Case: If <code>head</code> or <code>head.next</code> is <code>Null</code>, return <code>head</code>.</li>
<li>Recursive Call: Set <code>nextNode</code> to <code>removeNodes(head.next)</code>.</li>
<li>Comparison: If <code>head.val</code> is less than <code>nextNode.val</code>, we need to remove <code>head</code>. Return <code>nextNode</code>.</li>
<li>Otherwise, set <code>head</code> to <code>head.next</code> and then return <code>head</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/L2EFsxaF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We call <code>removeNodes()</code> once for each node in the original linked list. The other operations inside the function all take constant time, so the time complexity is dominated by the recursive calls. Thus, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since we make <span class="math inline">\(n\)</span> recursive calls to <code>removeNodes()</code>, the call stack can grow up to size <span class="math inline">\(n\)</span>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-reverse-twice">Approach 3: Reverse Twice</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The first approach used a stack to reverse the linked list, resulting in linear auxiliary space. However, instead of using a stack, we can write a function to reverse the nodes in place, avoiding the need for auxiliary space. This task is explored in the problem <a href="https://leetcode.com/problems/reverse-linked-list/description/">Reverse Linked List</a>. The basic idea is to set each node's next field to point to the previous node.</p>
<p>After reversing the linked list, the node values will be in increasing order, allowing us to delete any nodes whose values are smaller than the nodes preceding them.</p>
<p>To facilitate this process, we maintain the maximum node value found so far using the variable <code>maximum</code>.</p>
<p>We traverse each node, <code>current</code>, in the reversed linked list and update the <code>maximum</code> value accordingly. If the value of the <code>current</code> node is smaller than the <code>maximum</code>, we delete <code>current</code>. Deleting nodes in place requires us to track the previous node so that we can correctly link it to the next node if we delete the <code>current</code> node.</p>
<p>Once we have traversed the linked list to delete the nodes, we have a linked list that is in increasing order.</p>
<p>However, since the desired result should be in decreasing order, we reverse the modified linked list and then return it.</p>
<blockquote>
<p><strong>Interview Tip: In-place Algorithms</strong></p>
<p>This approach modifies the input. In-place algorithms overwrite the input to save space, but sometimes this can cause problems.</p>
<p>Here are a couple of situations where an in-place algorithm might not be suitable.</p>
<ol>
<li>
<p>The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.</p>
</li>
<li>
<p>Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.</p>
</li>
</ol>
<p>In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Define a function <code>reverseList</code> that takes the head of a linked list as input and reverses it, returning the new head.
<ul>
<li>Initialize three pointers, <code>prev</code> to <code>null</code>, <code>current</code> to <code>head</code>, and <code>nextTemp</code> to <code>null</code>.</li>
<li>While <code>current</code> is not <code>null</code>:
<ul>
<li>Set <code>nextTemp</code> to <code>current.next</code>.</li>
<li>Reverse the order of the nodes by setting <code>current.next</code> to <code>prev</code>.</li>
<li>Progress both pointers by setting <code>prev</code> to <code>current</code> and <code>current</code> to <code>nextTemp</code>.</li>
</ul>
</li>
<li>Return <code>prev</code>.</li>
</ul>
</li>
<li>Reverse the original linked list using <code>reverseList(head)</code>. Set <code>head</code> to the reversed linked list.</li>
<li>Initialize a variable <code>maximum</code> to <code>0</code>.</li>
<li>Initialize two pointers, <code>prev</code> to <code>null</code> and <code>current</code> to <code>head</code>.</li>
<li>Delete the nodes that are smaller than the node before them. While <code>current</code> is not <code>null</code>:
<ul>
<li>Update <code>maximum</code> to the max between <code>maximum</code> and <code>current.val</code>.</li>
<li>If <code>current.val</code> is less than <code>maximum</code>, delete <code>current</code>.
<ul>
<li>Skip the current node by setting <code>prev.next</code> to <code>current.next</code>.</li>
<li>Set a pointer <code>deleted</code> to <code>current</code>.</li>
<li>Move <code>current</code> to <code>current.next</code> to progress to the next node.</li>
<li>Set <code>deleted.next</code> to <code>null</code> to remove any additional pointers to the new <code>current</code> node.</li>
</ul>
</li>
<li>Otherwise, if <code>current.val</code> is not less than <code>maximum</code>, retain <code>current</code> and progress both pointers by setting <code>prev</code> to <code>current</code> and <code>current</code> to <code>current.next</code>.</li>
</ul>
</li>
<li>Reverse and return the modified linked list using <code>reverseList(head)</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2487/2487_slideshow3.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/aq46D8sp/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Reversing the original linked list takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Traversing the reversed original linked list and removing nodes takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Reversing the modified linked list takes an additional <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the total time complexity is <span class="math inline">\(O(3n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a few variables and pointers that use constant extra space. Since we don't use any data structures that grow with input size, the space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-176">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-outermost-parentheses/description" target="_blank" rel="noopener noreferrer">Remove Outermost Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A valid parentheses string is either empty <code>&quot;&quot;</code>, <code>&quot;(&quot; + A + &quot;)&quot;</code>, or <code>A + B</code>, where <code>A</code> and <code>B</code> are valid parentheses strings, and <code>+</code> represents string concatenation.</p>

<ul>
	<li>For example, <code>&quot;&quot;</code>, <code>&quot;()&quot;</code>, <code>&quot;(())()&quot;</code>, and <code>&quot;(()(()))&quot;</code> are all valid parentheses strings.</li>
</ul>

<p>A valid parentheses string <code>s</code> is primitive if it is nonempty, and there does not exist a way to split it into <code>s = A + B</code>, with <code>A</code> and <code>B</code> nonempty valid parentheses strings.</p>

<p>Given a valid parentheses string <code>s</code>, consider its primitive decomposition: <code>s = P<sub>1</sub> + P<sub>2</sub> + ... + P<sub>k</sub></code>, where <code>P<sub>i</sub></code> are primitive valid parentheses strings.</p>

<p>Return <code>s</code> <em>after removing the outermost parentheses of every primitive string in the primitive decomposition of </em><code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(()())(())&quot;
<strong>Output:</strong> &quot;()()()&quot;
<strong>Explanation:</strong> 
The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.
After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(()())(())(()(()))&quot;
<strong>Output:</strong> &quot;()()()()(())&quot;
<strong>Explanation:</strong> 
The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.
After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;()()&quot;
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> 
The input string is &quot;()()&quot;, with primitive decomposition &quot;()&quot; + &quot;()&quot;.
After removing outer parentheses of each part, this is &quot;&quot; + &quot;&quot; = &quot;&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>
	<li><code>s</code> is a valid parentheses string.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-177">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/remove-the-balls--170647/1" target="_blank" rel="noopener noreferrer">Remove the balls</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="103" data-end="184"><span style="font-size: 14pt;">You are given two arrays, <strong><code data-start="129" data-end="136">color</code></strong> and <strong><code data-start="141" data-end="149">radius</code></strong>, representing a sequence of balls:</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<ul>
<li><span style="font-size: 14pt;"><code data-start="188" data-end="198"><strong>color[i]</strong></code> is the color of the i-th ball.</span></li>
<li><strong style="font-size: 14pt;"><code data-start="234" data-end="245">radius[i]</code></strong><span style="font-size: 14pt;"> is the radius of the i-th ball.</span></li>
</ul>
<p><span style="font-size: 14pt;"> </span></p>
<p data-start="279" data-end="413"><span style="font-size: 14pt;">If two <strong data-start="286" data-end="301">consecutive</strong> balls have the <strong data-start="317" data-end="342">same color </strong>and <strong data-start="317" data-end="342">radius</strong>, remove them both. Repeat this process until no more such pairs exist.</span></p>
<p class="" data-start="166" data-end="269"><span style="font-size: 14pt;"> </span></p>
<p data-start="415" data-end="484"><span style="font-size: 14pt;">Return the <strong data-start="426" data-end="455">number </strong>of<strong data-start="426" data-end="455"> </strong>balls <strong data-start="426" data-end="455">remaining</strong> after all possible removals.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: color[] = [2, 3, 5], radius[] = [3, 3, 5]
<strong>Output: </strong>3
<strong>Explanation</strong>: All the 3 balls have different colors and radius.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>color[] = [2, 2, 5], radius[] = [3, 3, 5]<strong><br />Output:</strong> 1
<strong>Explanation</strong>: </span><span style="font-size: 18.6667px;">First ball and second ball have same color 2 and same radius 3. So, after removing only one ball is left. It cannot be removed from the array. Hence, the final array has length 1.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; color.size() = radius.size() &le; 10<sup>5</sup><br />1 &le; color[i] &le; 10<sup>9</sup></span><span style="font-size: 18px;"><sup> <br /></sup></span><span style="font-size: 18px;">1 &le; radius[i] &le; 10<sup>9</sup></span><span style="font-size: 18px;"><sup> &nbsp;</sup></span><sup>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-178">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/removing-consecutive-duplicates-2-1587115621/1" target="_blank" rel="noopener noreferrer">Removing consecutive duplicates - 2</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given string <strong>s</strong>. You need to remove the pair of duplicates.<br /><strong>Note:&nbsp;</strong>The pair should be of adjacent elements and after removing a pair the remaining string is joined together.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: s = "aaabbaaccd"
<strong>Output</strong>: ad
<strong>Explanation</strong>: 
Remove (aa)abbaaccd =&gt;abbaaccd
Remove a(bb)aaccd =&gt; aaaccd
Remove (aa)accd =&gt; accd
Remove a(cc)d =&gt; ad</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: s = "aaaa"
<strong>Output</strong>: Empty String
<strong>Explanation</strong>: 
Remove (aa)aa =&gt; aa
Again removing pair of duplicates then (aa) 
will be removed and we will get 'Empty String'.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= |s| &lt;= 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-179">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/removing-consecutive-elements/1" target="_blank" rel="noopener noreferrer">Removing Consecutive Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr[]&nbsp;</strong>of positive<strong>&nbsp;</strong>elements and two special numbers<strong>&nbsp;x and y</strong>. Remove all consecutive same special numbers. The final array should be free from any consecutive same special elements.<br /><strong>Note:</strong>&nbsp;The final array may be empty.</span></p>
<p><span style="font-size: 18px;"><strong>Examples&nbsp;</strong>:</span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [2, 1, 2, 2, 2, 5], x = 1, y = 2
<strong>Output: </strong>2 1 2 5</span>
<span style="font-size: 18px;"><strong>Explanation: </strong>x = 1 and y = 2. Now, we traverse the array from left to right and remove all consecutive 1s and 2s. 
First, we remove 2 1 <strong>2 2</strong> 2 5. 
Now we are left with 2 1 2 5. 
Now,there is no consecutive 1 or 2.
We are left with 2 1 2 5.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>5</sup><br />1 &lt;= arr[i] &lt;= 10<sup>5</sup><br />1 &lt;= x, y &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-180">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/removing-stars-from-a-string/description" target="_blank" rel="noopener noreferrer">Removing Stars From a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>, which contains stars <code>*</code>.</p>

<p>In one operation, you can:</p>

<ul>
	<li>Choose a star in <code>s</code>.</li>
	<li>Remove the closest <strong>non-star</strong> character to its <strong>left</strong>, as well as remove the star itself.</li>
</ul>

<p>Return <em>the string after <strong>all</strong> stars have been removed</em>.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>The input will be generated such that the operation is always possible.</li>
	<li>It can be shown that the resulting string will always be unique.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leet**cod*e&quot;
<strong>Output:</strong> &quot;lecoe&quot;
<strong>Explanation:</strong> Performing the removals from left to right:
- The closest character to the 1<sup>st</sup> star is &#39;t&#39; in &quot;lee<strong><u>t</u></strong>**cod*e&quot;. s becomes &quot;lee*cod*e&quot;.
- The closest character to the 2<sup>nd</sup> star is &#39;e&#39; in &quot;le<strong><u>e</u></strong>*cod*e&quot;. s becomes &quot;lecod*e&quot;.
- The closest character to the 3<sup>rd</sup> star is &#39;d&#39; in &quot;leco<strong><u>d</u></strong>*e&quot;. s becomes &quot;lecoe&quot;.
There are no more stars, so we return &quot;lecoe&quot;.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;erase*****&quot;
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> The entire string is removed, so we return an empty string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters and stars <code>*</code>.</li>
	<li>The operation above can be performed on <code>s</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-181">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reorder-list/description" target="_blank" rel="noopener noreferrer">Reorder List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked-list</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the head of a singly linked-list. The list can be represented as:</p>

<pre>
L<sub>0</sub> &rarr; L<sub>1</sub> &rarr; &hellip; &rarr; L<sub>n - 1</sub> &rarr; L<sub>n</sub>
</pre>

<p><em>Reorder the list to be on the following form:</em></p>

<pre>
L<sub>0</sub> &rarr; L<sub>n</sub> &rarr; L<sub>1</sub> &rarr; L<sub>n - 1</sub> &rarr; L<sub>2</sub> &rarr; L<sub>n - 2</sub> &rarr; &hellip;
</pre>

<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg" style="width: 422px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [1,4,2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [1,5,2,4,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-182">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/replace-non-coprime-numbers-in-array/description" target="_blank" rel="noopener noreferrer">Replace Non-Coprime Numbers in Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code>. Perform the following steps:</p>

<ol>
	<li>Find <strong>any</strong> two <strong>adjacent</strong> numbers in <code>nums</code> that are <strong>non-coprime</strong>.</li>
	<li>If no such numbers are found, <strong>stop</strong> the process.</li>
	<li>Otherwise, delete the two numbers and <strong>replace</strong> them with their <strong>LCM (Least Common Multiple)</strong>.</li>
	<li><strong>Repeat</strong> this process as long as you keep finding two adjacent non-coprime numbers.</li>
</ol>

<p>Return <em>the <strong>final</strong> modified array.</em> It can be shown that replacing adjacent non-coprime numbers in <strong>any</strong> arbitrary order will lead to the same result.</p>

<p>The test cases are generated such that the values in the final array are <strong>less than or equal</strong> to <code>10<sup>8</sup></code>.</p>

<p>Two values <code>x</code> and <code>y</code> are <strong>non-coprime</strong> if <code>GCD(x, y) &gt; 1</code> where <code>GCD(x, y)</code> is the <strong>Greatest Common Divisor</strong> of <code>x</code> and <code>y</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,4,3,2,7,6,2]
<strong>Output:</strong> [12,7,6]
<strong>Explanation:</strong> 
- (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [<strong><u>12</u></strong>,3,2,7,6,2].
- (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [<strong><u>12</u></strong>,2,7,6,2].
- (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [<strong><u>12</u></strong>,7,6,2].
- (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,<u><strong>6</strong></u>].
There are no more adjacent non-coprime numbers in nums.
Thus, the final modified array is [12,7,6].
Note that there are other ways to obtain the same resultant array.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,1,1,3,3,3]
<strong>Output:</strong> [2,1,1,3]
<strong>Explanation:</strong> 
- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,<u><strong>3</strong></u>,3].
- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,<u><strong>3</strong></u>].
- (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [<u><strong>2</strong></u>,1,1,3].
There are no more adjacent non-coprime numbers in nums.
Thus, the final modified array is [2,1,1,3].
Note that there are other ways to obtain the same resultant array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li>The test cases are generated such that the values in the final array are <strong>less than or equal</strong> to <code>10<sup>8</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-183">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/restrictive-candy-crush--141631/1" target="_blank" rel="noopener noreferrer">Restrictive Candy Crush</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a string <strong>s</strong>&nbsp;and an integer <strong>k</strong>, the task is to reduce the string by applying the following operation:<br />
Choose a group of <strong>k</strong>&nbsp;consecutive identical characters and remove them.</span></p>

<p><span style="font-size:18px">The operation can be performed any number of times until it is no longer possible.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>k = 2
s = &quot;geeksforgeeks&quot;
<strong>Output:</strong>
gksforgks
<strong>Explanation:</strong>
Modified String after each step: 
<strong>&quot;</strong>g<strong>ee</strong>ksforg<strong>ee</strong>ks&quot; -&gt; &quot;gksforgks&quot;</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>k = 2
s =<strong> &quot;</strong>geegsforgeeeks&quot; 
<strong>Output:</strong>
sforgeks
<strong>Explanation:</strong>
Modified String after each step:
<strong>&quot;</strong>g<strong>ee</strong>gsforg<strong>eee</strong>ks&quot; -&gt; &quot;<strong>gg</strong>sforgeks&quot; -&gt; &quot;sforgeks&quot;</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task: </strong>&nbsp;<br />
You don&#39;t need to read input or print anything. Complete the function <strong>Reduced_String()</strong> which takes integer <strong>k</strong> and string&nbsp;<strong>s</strong>&nbsp;as input parameters and returns the reduced string.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(|s|)<br />
<strong>Expected Auxiliary Space:</strong> O(|s|)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; |s|&nbsp;&le; 10<sup>5</sup><br />
1&nbsp;&le; k&nbsp;&le; |s|</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-184">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/resulting-string-after-adjacent-removals/description" target="_blank" rel="noopener noreferrer">Resulting String After Adjacent Removals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of lowercase English letters.</p>

<p>You <strong>must</strong> repeatedly perform the following operation while the string <code>s</code> has <strong>at least</strong> two <strong>consecutive </strong>characters:</p>

<ul>
	<li>Remove the <strong>leftmost</strong> pair of <strong>adjacent</strong> characters in the string that are <strong>consecutive</strong> in the alphabet, in either order (e.g., <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>, or <code>&#39;b&#39;</code> and <code>&#39;a&#39;</code>).</li>
	<li>Shift the remaining characters to the left to fill the gap.</li>
</ul>

<p>Return the resulting string after no more operations can be performed.</p>

<p><strong>Note:</strong> Consider the alphabet as circular, thus <code>&#39;a&#39;</code> and <code>&#39;z&#39;</code> are consecutive.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;c&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Remove <code>&quot;ab&quot;</code> from the string, leaving <code>&quot;c&quot;</code> as the remaining string.</li>
	<li>No further operations are possible. Thus, the resulting string after all possible removals is <code>&quot;c&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;adcb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Remove <code>&quot;dc&quot;</code> from the string, leaving <code>&quot;ab&quot;</code> as the remaining string.</li>
	<li>Remove <code>&quot;ab&quot;</code> from the string, leaving <code>&quot;&quot;</code> as the remaining string.</li>
	<li>No further operations are possible. Thus, the resulting string after all possible removals is <code>&quot;&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;zadb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;db&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Remove <code>&quot;za&quot;</code> from the string, leaving <code>&quot;db&quot;</code> as the remaining string.</li>
	<li>No further operations are possible. Thus, the resulting string after all possible removals is <code>&quot;db&quot;</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-185">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-array-using-stack--143151/1" target="_blank" rel="noopener noreferrer">Reverse Array Using Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an array&nbsp;<strong>arr[]</strong>, the task is to<strong>&nbsp;</strong>reverse the array elements in-place by using a&nbsp;<strong>stack</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> arr[] = [1, 2, 3, 4, 5]
<strong>Output:</strong> 5 4 3 2 1
<strong>Explanation:</strong> After the reverse, array will look like [5, 4, 3, 2, 1].</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> arr[] = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> After the reverse, array will look like [1].</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-186">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-a-stack/1" target="_blank" rel="noopener noreferrer">Reverse a Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a stack <strong>St</strong>. You have to reverse the stack using recursion.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">St = {3,2,1,7,6}</span>
<strong><span style="font-size: 18px;">Output:</span></strong>
<span style="font-size: 18px;">{6,7,1,2,3}<br /><strong>Explanation:</strong><br />Input stack after reversing will look like the stack in the output.</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">St = {4,3,9,6}</span>
<strong><span style="font-size: 18px;">Output:</span></strong>
<span style="font-size: 18px;">{6,9,3,4}<br /><strong style="font-family: sans-serif;">Explanation:<br /></strong>Input stack after reversing will look like the stack in the output.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function <strong>Reverse()</strong>&nbsp;which takes the stack&nbsp;<strong>St</strong><strong>&nbsp;</strong>as input and reverses the given stack.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(</span><span style="font-size: 18px;">N</span><sup>2</sup><span style="font-size: 18px;">)<br /></span><span style="font-size: 18px;"><strong>Expected Auxiliary Space:</strong> O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= size of the stack &lt;= 10<sup>4</sup></span><br /><span style="font-size: 18px;">-10</span><sup>9</sup><span style="font-size: 18px;"> &lt;= Each element of the stack &lt;= 10</span><sup>9</sup><br /><span style="font-size: 18px;">Sum of N over all test cases doesn't exceeds 10</span><sup>6</sup><br /><span style="font-size: 18px;">Array may contain duplicate elements.&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-187">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-each-word-in-a-given-string1001/1" target="_blank" rel="noopener noreferrer">Reverse each word in a given string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a string <strong>s</strong>. You need to reverse each word in it where the words are separated by spaces and return the modified string.</span></p>
<p><span style="font-size: 14pt;"><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: #1e2229; background-color: #ffffff; font-family: var(--gfg-font-secondary) !important;">Note:&nbsp;</span><span style="color: #1e2229; font-family: Nunito; background-color: #ffffff;">The string may contain leading or trailing spaces, or multiple spaces between two words. The returned string should only have a&nbsp;</span><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: #1e2229; background-color: #ffffff; font-family: var(--gfg-font-secondary) !important;">single space</span><span style="color: #1e2229; font-family: Nunito; background-color: #ffffff;">&nbsp;separating the words, and&nbsp;</span><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: #1e2229; background-color: #ffffff; font-family: var(--gfg-font-secondary) !important;">no extra spaces</span><span style="color: #1e2229; font-family: Nunito; background-color: #ffffff;"> should be included.</span></span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = " i like this program very much "
<strong>Output: </strong>"i ekil siht margorp yrev hcum"
<strong>Explanation</strong>: The words are reversed as follows:<br />"i" -&gt; "i","like"-&gt;"ekil",
"this"-&gt;"siht","program" -&gt; "margorp",
"very" -&gt; "yrev","much" -&gt; "hcum".</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: s = " pqr mno "
<strong>Output: </strong>"rqp onm"
<strong>Explanation</strong>: The words are reversed as follows:<br />"pqr" -&gt; "rqp" ,
"mno" -&gt; "onm"<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: s = "pqr"
<strong>Output: </strong>"rqp"
<strong>Explanation</strong>: The words are reversed as follows:</span><br /><span style="font-size: 14pt;">"pqr" -&gt; "rqp"</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= s.size() &lt;= 10<sup>5<br /></sup><span style="color: #1e2229; font-family: Nunito; background-color: #ffffff;">string&nbsp;</span><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: #1e2229; background-color: #ffffff; font-family: var(--gfg-font-secondary) !important;"><code style="box-sizing: border-box; line-height: 1.7em; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important; background-color: var(--background) !important;">s</code></span><span style="color: #1e2229; font-family: Nunito; background-color: #ffffff;">&nbsp;contains only lowercase English alphabets and spaces</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-188">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-first-k-elements-of-queue/1" target="_blank" rel="noopener noreferrer">Reverse first K of a Queue</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer<strong> k&nbsp;</strong>and a&nbsp;<a href="http://www.geeksforgeeks.org/queue-data-structure/">queue</a>&nbsp;of integers, we need to reverse the order of the first<strong> k</strong>&nbsp;elements of the queue, leaving the other elements in the same relative order.</span></p>
<p><span style="font-size: 18px;">Only following standard operations are allowed on queue.</span></p>
<ul>
<li><span style="font-size: 18px;">enqueue(x) : Add an item x to rear of queue</span></li>
<li><span style="font-size: 18px;">dequeue() : Remove an item from front of queue</span></li>
<li><span style="font-size: 18px;">size() : Returns number of elements in queue.</span></li>
<li><span style="font-size: 18px;">front() : Finds front item.<br /></span></li>
</ul>
<p><strong style="font-size: 18px;">Note:</strong><span style="font-size: 18px;">&nbsp;The above operations represent the general processings. In-built functions of the respective languages can be used to solve the problem.</span></p>
<p>"If the size of queue is smaller than the given k , then return the original queue."</p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input</span><span style="font-size: 18px;">: </span></strong><span style="font-size: 18px;">q</span><strong><span style="font-size: 18px;"> </span></strong><span style="font-size: 18px;">= [1, 2, 3, 4, 5], k = 3<br /><strong>Output: </strong>[3, 2, 1, 4, 5]<br /><strong>Explanation: </strong>After reversing the first 3 elements from the given queue the resultant queue will be 3 2 1 4 5</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>q<strong> </strong>= [4, 3, 2, 1], k = 4<br /><strong>Output: </strong>[1, 2, 3, 4] <br /><strong>Explanation: </strong>After reversing the first 4 elements from the given queue the resultant queue will be 1 2 3 4 </span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1&lt;=q[i]&lt;=10<sup>5<br /></sup>1&lt;=q.size()&lt;=10<sup>5</sup><br />1&lt;=k&lt;=10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-189">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-first-k-elements-of-queue--123903/1" target="_blank" rel="noopener noreferrer">Reverse First K of Queue</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer <strong>k </strong>and a&nbsp;<a href="http://www.geeksforgeeks.org/queue-data-structure/">queue</a>&nbsp;of integers, we need to reverse the order of the first<strong> k</strong> elements of the queue, leaving the other elements in the same relative order.</span></p>
<p><span style="font-size: 18px;">Only following standard operations are allowed on queue.</span></p>
<ul>
<li><span style="font-size: 18px;">enqueue(x) : Add an item x to rear of queue</span></li>
<li><span style="font-size: 18px;">dequeue() : Remove an item from front of queue</span></li>
<li><span style="font-size: 18px;">size() : Returns number of elements in queue.</span></li>
<li><span style="font-size: 18px;">front() : Finds front item.<br /></span></li>
</ul>
<p><strong style="font-size: 18px;">Note:</strong><span style="font-size: 18px;">&nbsp;The above operations represent the general processings. In-built functions of the respective languages can be used to solve the problem.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">k =</span><span style="font-size: 18px;"> 3, queue[] = [1, 2, 3, 4, 5]
<strong>Output: </strong>3 2 1 4 5
<strong>Explanation: </strong>After reversing the given input from the 3rd position the resultant output will be 3 2 1 4 5.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">k = 4, queue[] = [4, 3, 2, 1]
<strong>Output: </strong>1 2 3 4
<strong>Explanation: </strong>After reversing the given input from the 4th position the resultant output will be 1 2 3 4.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= k &lt;= queue.size() &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-190">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-prefix-of-word/description" target="_blank" rel="noopener noreferrer">Reverse Prefix of Word</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> string <code>word</code> and a character <code>ch</code>, <strong>reverse</strong> the segment of <code>word</code> that starts at index <code>0</code> and ends at the index of the <strong>first occurrence</strong> of <code>ch</code> (<strong>inclusive</strong>). If the character <code>ch</code> does not exist in <code>word</code>, do nothing.</p>

<ul>
	<li>For example, if <code>word = &quot;abcdefd&quot;</code> and <code>ch = &quot;d&quot;</code>, then you should <strong>reverse</strong> the segment that starts at <code>0</code> and ends at <code>3</code> (<strong>inclusive</strong>). The resulting string will be <code>&quot;<u>dcba</u>efd&quot;</code>.</li>
</ul>

<p>Return <em>the resulting string</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;<u>abcd</u>efd&quot;, ch = &quot;d&quot;
<strong>Output:</strong> &quot;<u>dcba</u>efd&quot;
<strong>Explanation:</strong>&nbsp;The first occurrence of &quot;d&quot; is at index 3. 
Reverse the part of word from 0 to 3 (inclusive), the resulting string is &quot;dcbaefd&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;<u>xyxz</u>xe&quot;, ch = &quot;z&quot;
<strong>Output:</strong> &quot;<u>zxyx</u>xe&quot;
<strong>Explanation:</strong>&nbsp;The first and only occurrence of &quot;z&quot; is at index 3.
Reverse the part of word from 0 to 3 (inclusive), the resulting string is &quot;zxyxxe&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abcd&quot;, ch = &quot;z&quot;
<strong>Output:</strong> &quot;abcd&quot;
<strong>Explanation:</strong>&nbsp;&quot;z&quot; does not exist in word.
You should not do any reverse operation, the resulting string is &quot;abcd&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 250</code></li>
	<li><code>word</code> consists of lowercase English letters.</li>
	<li><code>ch</code> is a lowercase English letter.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>word</code> and need to reverse the prefix that starts at index <code>0</code> and ends at the first occurrence of <code>ch</code>.</p>
<p>If the <code>word</code> does not contain <code>ch</code>, we return <code>word</code> unmodified.</p>
<p>In C++, we can use built-in functions to accomplish this:</p>
<p><a href="https://leetcode.com/playground/2YXAzPy2/shared">code</a></p>
<p>This is not the most universal solution, as many programming languages do not have built-in string reverse capabilities. Additionally, strings are immutable in many programming languages.</p>
<blockquote>
<p>Immutable means something cannot be changed once it has been created.</p>
</blockquote>
<p>This problem is intended to provide practice with string manipulation, so we focus on approaches that use string manipulation techniques.</p>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Whenever a problem requires reversing a sequence, it is worth considering using a stack.</p>
<p>Stacks are a First-In-Last-Out (FILO) data structure, which means that the first items added to the stack are the last items removed from the stack. This means that if you push a sequence of items into a stack, and then remove all of the items, the sequence of items will be reversed. Learn more about stacks by reading our <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card</a>.</p>
<p>Since strings are immutable in many programming languages, we cannot directly modify the original string. Instead, we need to build a new string incrementally. In C++, we can use a string <code>result</code> to store the answer. In Python, we can use a list, and in Java, we can use a StringBuilder.</p>
<p>To reverse <code>word</code>, we loop through the characters of <code>word</code> and push each character onto the stack until we reach the first occurrence of <code>ch</code>.</p>
<p>Once we reach the character <code>ch</code>, we can start popping the characters off the stack and appending them to the <code>result</code> string. This will reverse the prefix of the <code>word</code>.</p>
<p>After we have emptied the stack, we can append the remaining characters of the <code>word</code> (i.e., the part of the word that comes after the first occurrence of <code>ch</code>) to the <code>result</code> string, in their original order.</p>
<p>Finally, we return <code>result</code>, converting it to a string if necessary. If <code>ch</code> was not found in <code>word</code>, we return the original <code>word</code> instead.</p>
<p><img src="../Figures/2000/2000_Stack.png" alt="Stack Visualization" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize the following:</p>
<ul>
<li>A <code>stack</code> to store characters that need to be reversed.</li>
<li>A string or list <code>result</code> for building the reversed string.</li>
<li>A variable <code>index</code> for iterating through the characters in <code>word</code>.</li>
</ul>
</li>
<li>
<p>Loop through <code>word</code> until <code>index</code> reaches the end of <code>word</code>:</p>
<ul>
<li>Push the character <code>word[index]</code> onto the <code>stack</code>.</li>
<li>If the current character equals <code>ch</code>:
<ul>
<li>Pop each of the characters from the stack and add them to the <code>result</code></li>
<li>Increment <code>index</code> by <code>1</code> because we already added <code>ch</code> to the <code>result</code>.</li>
<li>Add the rest of the characters from <code>word</code> to <code>result</code>.</li>
<li>Return <code>result</code> and convert to a string if necessary.</li>
</ul>
</li>
<li>Increment <code>index</code> by <code>1</code>; we have not yet reached <code>ch</code>.</li>
</ul>
</li>
<li>
<p>Return <code>word</code>, which does not contain <code>ch</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3myFaghr/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>word</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Finding <code>ch</code> in <code>word</code> and adding the characters to the stack takes up to <span class="math inline">\(O(n)\)</span> when <code>ch</code> is the last character in <code>word</code>.</p>
<p>Adding the characters to <code>result</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(2n)\)</span>, which we can simplify to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use <code>stack</code> which can grow to contain up to <span class="math inline">\(n\)</span> elements, so the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-find-the-index-and-fill-result">Approach 2: Find the Index and Fill Result</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We usually read text from left to right. Reading right to left, the text will appear reversed.</p>
<p>To reverse the prefix, we can &quot;read&quot; the prefix in reverse order (end to beginning and right to left).</p>
<p>First, we need to find the end of the prefix. This will be the index in <code>word</code> of the first occurrence of <code>ch</code>. Most languages have a built-in function we can use to locate the index of a character in a string, which we will use to find <code>chIndex</code>.</p>
<p>If <code>ch</code> is not in <code>word</code>, we return <code>word</code> unaltered.</p>
<p>Similar to the previous solution, we will add characters to <code>result</code> one by one. To traverse <code>word</code> from the end of the prefix to the beginning while adding characters to <code>result</code>, we can use a standard <code>for</code> loop with <code>word[chIndex - i]</code>.</p>
<p>Once the prefix has been added to the <code>result</code>, we can then proceed with the <code>for</code> loop, appending <code>word[i]</code> to the result.</p>
<p>Finally, we return <code>result</code>, and if necessary, convert it to a string.</p>
<p><img src="../Figures/2000/2000_Find.png" alt="Find Visualization" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Find the index of <code>ch</code> in <code>word</code> and set the variable <code>chIndex</code> to this value.</p>
</li>
<li>
<p>If <code>chIndex</code> equals <code>-1</code>, <code>ch</code> is not in <code>word</code>, so return <code>word</code>.</p>
</li>
<li>
<p>Initialize a string or list <code>result</code> for building the string with the reversed prefix.</p>
</li>
<li>
<p>Loop through the characters of <code>word</code> using the iterator <code>i</code>:</p>
<ul>
<li>If <code>i</code> is less than or equal to <code>chIndex</code>, the character at this index of <code>result</code> should be the corresponding character from <code>word</code> but in reverse. Append <code>word[chIndex - i]</code> to <code>result</code>.</li>
<li>Otherwise, the character at this index of <code>result</code> should contain a character in the original order. Append <code>word[i]</code> to <code>result</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, converting it to a string if necessary.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/95qiEEDM/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>word</code>.</p>
<p>Certainly. I'll provide a more detailed explanation for each point:</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(n^2)\)</span></p>
<p>The time complexity varies across implementations:</p>
<ul>
<li>In Java, using <code>StringBuilder</code> results in <span class="math inline">\(O(n)\)</span>. The <code>append()</code> operation is <span class="math inline">\(O(1)\)</span>, and we perform it <span class="math inline">\(n\)</span> times.</li>
<li>In Python, string concatenation inside the loop leads to <span class="math inline">\(O(n^2)\)</span>. Each '+=' operation creates a new string, taking <span class="math inline">\(O(n)\)</span> time, and we do this <span class="math inline">\(n\)</span> times.</li>
<li>In C++, using <code>std::string</code> results in <span class="math inline">\(O(n)\)</span>. The concetanation(+=) is <span class="math inline">\(O(1)\)</span> as C++ strings are mutable, and we perform it <span class="math inline">\(n\)</span> times.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use <code>result</code>, which has a size of <span class="math inline">\(n\)</span>, to build the answer.</p>
<p>The space usage is consistent across implementations:</p>
<ul>
<li>In Java, using <code>StringBuilder</code> results in <span class="math inline">\(O(n)\)</span>. It preallocates space efficiently.</li>
<li>In Python, despite creating multiple strings, only one full-length string exists at any time, so <span class="math inline">\(O(n)\)</span>. However, it may use more memory during execution due to the creation of temporary strings.</li>
<li>In C++, using <code>std::string</code> results in <span class="math inline">\(O(n)\)</span>. C++ strings are mutable so the performance considerations of concatenation(+=) are less of a concern.</li>
</ul>
<p>Therefore, the space complexity is <span class="math inline">\(O(n)\)</span> for all implementations. While the actual memory usage may vary slightly, the asymptotic space complexity remains the same.</p>
</li>
</ul>
<blockquote>
<p>Note: The main difference in efficiency comes from how each language handles string manipulations. Java's StringBuilder and C++'s string are optimized for repeated concatenations, while Python's strings, being immutable, require more operations for the same task.</p>
</blockquote>
<h3 id="approach-3-two-pointer-swapping">Approach 3: Two-Pointer Swapping</h3>
<h4 id="intuition-2">Intuition</h4>
<p>When we reverse a string, the characters at the ends are swapped. Likewise, the characters one spot away from the ends are swapped.</p>
<p>This reversal strategy can be performed in place, as demonstrated in this problem: <a href="https://leetcode.com/problems/reverse-string/editorial/">344 Reverse String</a>. However, this problem differs from the one at hand since the input is provided as a character array instead of a string.</p>
<p>We can utilize this strategy by initially adding the characters from <code>word</code> to <code>result</code>, where <code>result</code> is a list or array of characters.</p>
<p>We iterate through <code>result</code> using <code>right</code> until it reaches the first occurrence of <code>ch</code>. If <code>ch</code> is not in <code>word</code>, we return <code>word</code>.</p>
<p>Subsequently, we traverse through the prefix of <code>result</code> with two pointers, <code>left</code> pointing to the beginning of the prefix and <code>right</code> pointing to the end of the prefix, until they meet in the middle. During each iteration, we swap the values at the indices <code>left</code> and <code>right</code>, then progress each pointer one step towards each other.</p>
<p>Finally, we return <code>result</code> and convert it to a string if necessary.</p>
<p><img src="../Figures/2000/2000_Two-Pointer.png" alt="Swapping Visualization" /></p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Initialize a string or list <code>result</code> for building the string with the reversed prefix.</p>
</li>
<li>
<p>Initialize a pointer <code>left</code> to <code>0</code>.</p>
</li>
<li>
<p>Use a <code>for</code> loop to iterate through <code>result</code>, using the iterator <code>right</code>:</p>
<ul>
<li>If <code>result[right]</code> is equal to <code>ch</code>:
<ul>
<li>While <code>left</code> is less than <code>right</code>, swap the characters of <code>result</code> at indices <code>left</code> and <code>right</code>, then increment <code>left</code> and decrement <code>right</code>.</li>
</ul>
</li>
<li>After the loop, return <code>result</code> and convert it to a string if needed.</li>
</ul>
</li>
<li>
<p>If the loop completes without finding <code>ch</code>, return the original <code>word</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/h7nii6YC/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>word</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Copying <code>word</code> to <code>result</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>In the worst case scenario, when <code>ch</code> is located at the last index of <code>word</code>, we traverse <code>result</code> once to find <code>ch</code>, and then we swap <span class="math inline">\(\frac{n}{2}\)</span> elements.</p>
<p>Therefore, the time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> (Python and Java) or <span class="math inline">\(O(1)\)</span> (C++)</p>
<p>We use the <code>result</code> array of size <span class="math inline">\(n\)</span> to store and reverse the letters from <code>word</code>.</p>
<blockquote>
<p><strong>Note:</strong> The C++ version uses <span class="math inline">\(O(1)\)</span> space because the characters are reversed in place instead of using an auxiliary data structure. It is recommended to check with your interviewer before modifying the input, as it might lead to issues in certain scenarios.</p>
</blockquote>
<hr />
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-191">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/description" target="_blank" rel="noopener noreferrer">Reverse Substrings Between Each Pair of Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that consists of lower case English letters and brackets.</p>

<p>Reverse the strings in each pair of matching parentheses, starting from the innermost one.</p>

<p>Your result should <strong>not</strong> contain any brackets.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(abcd)&quot;
<strong>Output:</strong> &quot;dcba&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(u(love)i)&quot;
<strong>Output:</strong> &quot;iloveu&quot;
<strong>Explanation:</strong> The substring &quot;love&quot; is reversed first, then the whole string is reversed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(ed(et(oc))el)&quot;
<strong>Output:</strong> &quot;leetcode&quot;
<strong>Explanation:</strong> First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 2000</code></li>
	<li><code>s</code> only contains lower case English characters and parentheses.</li>
	<li>It is guaranteed that all parentheses are balanced.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We start with a string <code>s</code> composed of lowercase English letters and parentheses. Our goal is to reverse the substrings enclosed within each pair of matching parentheses, starting from the innermost pair and working our way outward. Ultimately, we want to produce a string without any parentheses that reflects these reversals.</p>
<p>To tackle this problem, we need to simulate the process of reversing characters within the parentheses. This can be approached either iteratively or recursively, but the key challenge is to manage the parentheses and the elements between them effectively.</p>
<p>First, let's understand the role of each parenthesis:</p>
<ul>
<li>An opening parenthesis <code>(</code> signals the start of a section that will eventually be reversed.</li>
<li>A closing parenthesis <code>)</code> signals the end of such a section.</li>
</ul>
<p>Given that parentheses might be nested, we can't simply reverse the substrings as we encounter them. Instead, we need to start with the innermost pairs. This requires a mechanism to pair each opening parenthesis with its corresponding closing parenthesis and then reverse the substrings when we've identified the innermost pairs.</p>
<p>To achieve this, we use a stack to keep track of the indices of the opening parentheses. When we encounter a closing parenthesis, we pop the last index from the stack, which gives us the position of the matching opening parenthesis. By keeping track of these positions, we can navigate back and forth within the string.</p>
<hr />
<h3 id="approach-1-straightforward-way">Approach 1: Straightforward Way</h3>
<h4 id="intuition">Intuition</h4>
<p>To achieve the proper reversal, we use a stack data structure to keep track of the indices of the opening parentheses. Each time we encounter an opening parenthesis <code>(</code>, we push the current length of our result string onto the stack. This length serves as a marker, indicating the start position of the substring that will need to be reversed once we find its corresponding closing parenthesis <code>)</code>.</p>
<p>When we encounter a closing parenthesis <code>)</code>, we pop the last index from the stack. This index represents the position of the matching opening parenthesis for the current closing parenthesis. Using this index, we know exactly where the substring that needs to be reversed begins. We then proceed to reverse the substring in the result string from this start position (obtained from the stack) to the current end of the result string.</p>
<p>By keeping track of these positions using the stack, we can efficiently navigate back and forth within the string to perform the necessary reversals. This approach ensures that we correctly handle nested parentheses by always reversing the innermost pairs first before moving outward, ultimately producing the desired output string.</p>
<p>In a nutshell, we can summarize the approach into two parts:</p>
<ol>
<li>
<p>Traversal and Processing:</p>
<ul>
<li>As we iterate through the string <code>s</code>, we check each character:
<ul>
<li>For <code>(</code>: We push the current length of the result onto the stack.</li>
<li>For <code>)</code>: We pop the top of the stack to get the index of the corresponding <code>(</code>, then reverse the substring in the result from this index to the end.</li>
<li>For any other character: We append it to the result.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Handle Closing Parentheses:</p>
<ul>
<li>When we encounter a closing parenthesis, we pop the last index from the stack. This index marks the corresponding opening parenthesis.</li>
<li>We then reverse the substring in the result from this index to the current end. This reversal handles the innermost section of the string first.</li>
<li>After processing all characters in the string <code>s</code>, our result contains the desired string.</li>
</ul>
</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty stack <code>openParenthesesIndices</code> to track reversal start points and an empty string <code>result</code> to build the output.</p>
</li>
<li>
<p>For each character <code>currentChar</code> in the input string:</p>
<ul>
<li>If <code>'('</code>, push <code>result</code>'s length to <code>openParenthesesIndices</code> to mark a potential reversal start.</li>
<li>If <code>')'</code>, pop from <code>openParenthesesIndices</code> and reverse <code>result</code> from the popped index to perform the required reversal.</li>
<li>Otherwise, append <code>currentChar</code> to <code>result</code> to build the string.</li>
</ul>
</li>
<li>
<p>Return <code>result</code> as the final string with all reversals applied.</p>
</li>
</ul>
<blockquote>
<p>Note: Since this problem uses a stack, you can also try to solve the problem recursively. Recursion and stack-based solutions are often interchangeable because function call stacks can mimic the behavior of explicit stacks.</p>
</blockquote>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8RuEpGhA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm iterates through each character of the input string once. For each character, we have three cases:</p>
<ul>
<li>If it's <code>(</code>, we push its index or the starting position where the reversal takes place to the stack. This is <span class="math inline">\(O(1)\)</span>.</li>
<li>If it's <code>)</code>, we pop from the stack and reverse a portion of the <code>result</code> string. Popping is <span class="math inline">\(O(1)\)</span>.
<ul>
<li>The reverse operation can take up to <span class="math inline">\(O(n)\)</span> time in the worst case (when we reverse the entire string).</li>
</ul>
</li>
<li>For other characters, we append to the <code>result</code> string, which is typically <span class="math inline">\(O(1)\)</span> (amortized).</li>
</ul>
<p>The worst-case scenario occurs when we have to reverse large portions of the string multiple times. In the worst case, we might end up reversing the entire string for each closing parenthesis. Therefore, the overall time complexity is <span class="math inline">\(O(n^2)\)</span> in the worst case.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a stack to store the indices of opening parentheses. In the worst case (when all characters are opening parentheses), this could take <span class="math inline">\(O(n)\)</span> space. The reverse function typically doesn't use extra space proportional to the input size. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-wormhole-teleportation-technique">Approach 2: Wormhole Teleportation technique</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The previous approach used the reverse function, causing multiple reversals on the same string and resulting in <span class="math inline">\(O(n^2)\)</span> time complexity. To optimize this, we can rethink the problem using the concept of 'wormholes/jumping' for paired parentheses.</p>
<blockquote>
<p>According to Wikipedia, a <a href="https://en.wikipedia.org/wiki/Wormhole">wormhole</a> can be visualized as a tunnel with two ends at separate points in spacetime (i.e., different locations, different points in time, or both).</p>
</blockquote>
<p>To achieve this, we use two passes through the input string:</p>
<ol>
<li>
<p>Pairing Parentheses (First Pass):<br />
In the first pass, we use a stack (<code>opened</code>) to keep track of the indices of opening parentheses and a pair list to store the indices of matching parentheses.<br />
As we iterate through the string, we can come across two scenarios:</p>
<ul>
<li>When we encounter an opening parenthesis <code>'('</code>, we push its index onto the <code>opened</code> stack.</li>
<li>When we encounter a closing parenthesis <code>')'</code>, we:
<ul>
<li>Pop the top index from the <code>opened</code> stack (this is the index of the matching opening parenthesis).</li>
<li>Create bidirectional links in the pair list between the current closing parenthesis and its matching opening parenthesis.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Traversing and Building Result (Second Pass):<br />
Now, we can traverse the string as we know all the entry and exit points of parenthesis. So, we traverse using two variables:<br />
<code>currIndex</code>: the current position in the string<br />
<code>direction</code>: the direction of traversal (1 for forward, -1 for backward)</p>
</li>
</ol>
<p>As we iterate through the string:</p>
<ul>
<li>If the current character is a parenthesis (either <code>'('</code> or <code>')'</code>):
<ul>
<li>We &quot;teleport/jump&quot; to its matching parenthesis using the pair list.</li>
<li>We reverse the direction of traversal.</li>
</ul>
</li>
<li>If the current character is not a parenthesis:
<ul>
<li>We add it to our result string.</li>
</ul>
</li>
<li>We move to the next position by adding the current direction (<code>direction</code>) to our position (<code>currIndex</code>).</li>
</ul>
<p>The key concept in this approach is treating paired parentheses as 'wormholes'. When encountering a parenthesis, we imagine jumping through a wormhole to its match and reversing our direction. This effectively reverses the order of characters within each pair of parentheses without actually reversing the string.</p>
<pre><code>forward -&gt;  ( ... ( ... ) ... )  &lt;- backward
             ^     ^    ^     ^
             |     |    |     |
             A-----B----b-----a
                  wormholes
</code></pre>
<p>See the above art and observe: When we hit the opening parenthesis(<code>A</code>), we jump to its closing pair(<code>a</code>) and start moving backward. When we hit the closing parenthesis(<code>b</code>) while moving backward, we jump to its opening pair and start moving forward again(<code>B</code>). This motion will ultimately lead to our result string without using the reverse function. Reducing the time complexity to <span class="math inline">\(O(n)\)</span>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>First Pass: Pair up parentheses</p>
<ul>
<li>Initialize <code>openParenthesesIndices</code> stack and <code>pair</code> vector to establish &quot;wormhole&quot; connections.</li>
<li>For each character:
<ul>
<li>If <code>'('</code>, push its index to <code>openParenthesesIndices</code> to remember its position.</li>
<li>If <code>')'</code>, pop from <code>openParenthesesIndices</code> and link both indices in <code>pair</code> to create the &quot;wormhole&quot;.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Second Pass: Build the result string</p>
<ul>
<li>Initialize <code>result</code> string, <code>currIndex</code>, and <code>direction</code> to traverse and build the result.</li>
<li>While <code>currIndex</code> &lt; input length:
<ul>
<li>If <code>'('</code> or <code>')'</code>, jump through the &quot;wormhole&quot; using <code>pair</code> and reverse <code>direction</code> to simulate reversal.</li>
<li>Otherwise, append the character to <code>result</code> to build the result.</li>
<li>Move <code>currIndex</code> by <code>direction</code> to continue traversal.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code> as the final string with all reversals simulated.</p>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1190/approach2.json:975,652!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/WmYTuZxs/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the string once to pair up parentheses using a stack. Each character is processed once, resulting in <span class="math inline">\(O(n)\)</span> time complexity.</p>
<p>After pairing, we iterate through the string again to construct the final result string. During this pass, each character is processed once, and we navigate through pairs in constant time. This results in another <span class="math inline">\(O(n)\)</span> time complexity.</p>
<p>Converting a <code>StringBuilder</code> to a <code>String</code> in Java using <code>toString()</code> takes <span class="math inline">\(O(n)\)</span> time, where <code>n</code> is the length of the <code>StringBuilder</code>. Joining elements of a list into a string in Python using <code>''.join()</code> also takes <span class="math inline">\(O(n)\)</span> time. Combined, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use a stack to track indices of opening parentheses. In the worst case, the stack may hold up to <span class="math inline">\(O(n/2)\)</span> elements (when all are opening parentheses), resulting in <span class="math inline">\(O(n)\)</span> space complexity. An array <code>pair</code> of size <code>n</code> is used to store indices of matching parentheses. This contributes <span class="math inline">\(O(n)\)</span> space complexity.</p>
<p>Converting a <code>StringBuilder</code> to a <code>String</code> in Java generally does not increase space complexity beyond the size of the resulting string itself. However, <code>StringBuilder</code> internally manages a character array whose size might be slightly larger than the resulting string due to its capacity management strategy. The additional space complexity for <code>''.join()</code> in Python is <span class="math inline">\(O(n)\)</span>, accounting for the space needed to store the new string object.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-192">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-a-string-using-stack/1" target="_blank" rel="noopener noreferrer">Reverse Using Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a string<strong> s </strong>, the task is to reverse the string using stack.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span> <span style="font-size: 14pt;">s</span> <span style="font-size: 18px;">="GeeksforGeeks"</span>
<span style="font-size: 18px;"><strong>Output:</strong></span><span style="font-size: 18px;">&nbsp; skeeGrofskee<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span> <span style="font-size: 14pt;">s</span> <span style="font-size: 18px;">="Geek"</span>
<span style="font-size: 18px;"><strong>Output:</strong></span><span style="font-size: 18px;"> keeG</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; s.length() &le; 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-193">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reversing-the-equation2205/1" target="_blank" rel="noopener noreferrer">Reversing the equation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a mathematical equation that contains only numbers and +, -, *, /. Print the equation in reverse, such that the equation is reversed, but the numbers remain the same.<br />It is guaranteed that the given equation is valid, and there are no leading zeros.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
S = "20-3+5*2"
<strong>Output:</strong> 2*5+3-20
<strong>Explanation</strong>: The equation is reversed with
numbers remaining the same.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: 
S = "5+2*56-2/4"
<strong>Output:</strong> 4/2-56*2+5
<strong>Explanation</strong>: The equation is reversed with
numbers remaining the same.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>reverseEqn()&nbsp;</strong>which takes the string S representing the equation as input and returns the resultant string representing the equation in reverse.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(|S|).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(|S|).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=|S|&lt;=10<sup>5</sup><br />The string contains only the characters '0' - '9', '+', '-', '*', and '/'.</span></p>
<p>&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-194">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/robot-collisions/description" target="_blank" rel="noopener noreferrer">Robot Collisions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> <strong>1-indexed</strong> robots, each having a position on a line, health, and movement direction.</p>

<p>You are given <strong>0-indexed</strong> integer arrays <code>positions</code>, <code>healths</code>, and a string <code>directions</code> (<code>directions[i]</code> is either <strong>&#39;L&#39;</strong> for <strong>left</strong> or <strong>&#39;R&#39;</strong> for <strong>right</strong>). All integers in <code>positions</code> are <strong>unique</strong>.</p>

<p>All robots start moving on the line<strong> simultaneously</strong> at the <strong>same speed </strong>in their given directions. If two robots ever share the same position while moving, they will <strong>collide</strong>.</p>

<p>If two robots collide, the robot with <strong>lower health</strong> is <strong>removed</strong> from the line, and the health of the other robot <strong>decreases</strong> <strong>by one</strong>. The surviving robot continues in the <strong>same</strong> direction it was going. If both robots have the <strong>same</strong> health, they are both<strong> </strong>removed from the line.</p>

<p>Your task is to determine the <strong>health</strong> of the robots that survive the collisions, in the same <strong>order </strong>that the robots were given,<strong> </strong>i.e. final health of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.</p>

<p>Return <em>an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.</em></p>

<p><strong>Note:</strong> The positions may be unsorted.</p>

<div class="notranslate" style="all: initial;">&nbsp;</div>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img height="169" src="https://assets.leetcode.com/uploads/2023/05/15/image-20230516011718-12.png" width="808" /></p>

<pre>
<strong>Input:</strong> positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = &quot;RRRRR&quot;
<strong>Output:</strong> [2,17,9,15,10]
<strong>Explanation:</strong> No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img height="176" src="https://assets.leetcode.com/uploads/2023/05/15/image-20230516004433-7.png" width="717" /></p>

<pre>
<strong>Input:</strong> positions = [3,5,2,6], healths = [10,10,15,12], directions = &quot;RLRL&quot;
<strong>Output:</strong> [14]
<strong>Explanation:</strong> There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4&#39;s health is smaller, it gets removed, and robot 3&#39;s health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img height="172" src="https://assets.leetcode.com/uploads/2023/05/15/image-20230516005114-9.png" width="732" /></p>

<pre>
<strong>Input:</strong> positions = [1,2,5,6], healths = [10,10,11,11], directions = &quot;RLRL&quot;
<strong>Output:</strong> []
<strong>Explanation:</strong> Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= positions.length == healths.length == directions.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= positions[i], healths[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>directions[i] == &#39;L&#39;</code> or <code>directions[i] == &#39;R&#39;</code></li>
	<li>All values in <code>positions</code> are distinct</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have a set of robots on a line, each robot is described with three variables: a unique position on the line, health, and direction of movement (<code>L</code> for left and <code>R</code> for right).</p>
<p>All robots start moving simultaneously and at the same speed. If two robots collide, the one with lower health is destroyed, and the health of the surviving robot decreases by one. If both robots have the same health, they are both destroyed.</p>
<p>We aim to determine the health of the robots that survive all collisions and list it in the order of their initial positions.</p>
<hr />
<h3 id="approach-sorting--stack">Approach: Sorting &amp; Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve this problem, we need to simulate the robots' movements and handle collisions step by step. The key challenge is managing the collisions in the correct sequence.</p>
<p>Because all the robots move at the same speed, they will only collide if a robot with the lower position is moving to the right (<code>R</code>), and another robot with a higher position is moving to the left (<code>L</code>). Robots moving in the same direction or moving away from each other will never meet.</p>
<p>The crucial step here is to sort the robots by their position so we can simulate their potential collisions in the correct order, which starts from the leftmost robot to the rightmost robot.</p>
<p>Once we have the robots sorted by position, the next challenge is to handle the collisions as they occur. Let's break down the mechanism of what happens during collisions and why a stack is the right tool for this job.</p>
<p>When we encounter a robot moving to the left (<code>L</code>), it might collide with one or more robots moving to the right (<code>R</code>) that are located to the left of the current robot. We need to compare the health of the left-moving robot with the health of each right-moving robot it collides with, in the order they were encountered.</p>
<p>This comparison must continue until one of these scenarios happens:</p>
<ol>
<li>The left-moving robot is destroyed.</li>
<li>The right-moving robot(s) are destroyed.</li>
<li>Both are destroyed if their health is equal.</li>
</ol>
<p>A stack is highly effective for managing this sequence of comparisons and updates.</p>
<p>A stack operates on a last-in-first-out principle (<code>LIFO</code>), which aligns with how we need to manage the collisions. The most recent robot moving to the right (<code>R</code>) will be the first to potentially collide with a left-moving robot (<code>L</code>).</p>
<blockquote>
<p>Note: Every time you encounter a problem where recent elements need to be revisited or managed in reverse order, consider if a stack might be appropriate. Recognizing these patterns can help you identify the right data structure. In interviews, this approach can guide you to the correct solution when it isn't immediately clear.</p>
</blockquote>
<p>We push right-moving robots onto the stack to keep track of any that could potentially collide with a left-moving robot located a higher position. When we encounter a left-moving robot, we simply pop robots off the stack to handle each collision in the correct order.</p>
<p>More specifically, when a left-moving robot (<code>L</code>) is encountered, we start by popping the robot at the top of the stack, which represents the most recent right-moving robot (<code>R</code>). We compare the health of these two robots:</p>
<ul>
<li>
<p>If the health of the left-moving robot is greater, the right-moving robot is destroyed. The left-moving robot's health decreases by one, and we continue popping the next robot from the stack if there are any.</p>
</li>
<li>
<p>If the health of the right-moving robot is greater, the left-moving robot is destroyed, and the right-moving robot's health decreases by one. We push the right-moving robot back onto the stack with its updated health.</p>
</li>
<li>
<p>If both robots have the same health, both are destroyed and we do not push anything back onto the stack.</p>
</li>
</ul>
<p>This process continues until the left-moving robot is destroyed, all right-moving robots that could collide have been handled, or both robots are destroyed.</p>
<p>After processing all robots, the stack will contain only the right-moving robots that survived all collisions.</p>
<p>Any left-moving robots that survived will not have encountered further right-moving robots, so they are also added to the final result.</p>
<p>Consider a list of robots sorted by their position:</p>
<p><code>Positions: [1, 2, 3, 4]</code>, <code>Healths: [3, 2, 5, 4]</code>, <code>Directions: ['R', 'R', 'L', 'L']</code></p>
<ol>
<li>Start with an empty stack.</li>
<li>Process the first robot at position 1 (<code>R</code>): push onto the stack.</li>
<li>Process the second robot at position 2 (<code>R</code>): push onto the stack.</li>
<li>Process the third robot at position 3 (<code>L</code>):
<ul>
<li>Compare with the robot at position 2 (<code>R</code>). If the robot's health at position 3 is higher, it survives with decreased health. Otherwise, the robot at position 2 survives.</li>
</ul>
</li>
<li>Continue this process until either the left-moving robot is destroyed, all right-moving robots in the stack are handled, or both are destroyed.</li>
<li>Process the fourth robot at position 4 (<code>L</code>) similarly.</li>
</ol>
<p>Here are some popular questions that use the stack as their central idea:</p>
<ul>
<li>
<p><a href="https://leetcode.com/problems/valid-parentheses/editorial/">20. Valid Parentheses</a></p>
</li>
<li>
<p><a href="https://leetcode.com/problems/valid-parenthesis-string/editorial/">678. Valid Parenthesis String</a></p>
</li>
<li>
<p><a href="https://leetcode.com/problems/basic-calculator-ii/editorial/">227. Basic Calculator II</a></p>
</li>
</ul>
<p>This question in particular is very similar to our current one, albeit a little more straightforward:</p>
<ul>
<li><a href="https://leetcode.com/problems/asteroid-collision/description/">735. Asteroid Collision</a></li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialization:
<ul>
<li>Determine the number of robots and store it in <code>n</code>.</li>
<li>Create an array <code>indices</code> to keep track of the original indices of the robots.</li>
<li>Create a list <code>result</code> to store the health of the surviving robots.</li>
<li>Initialize an empty stack to manage right-moving robots.</li>
</ul>
</li>
<li>Sort Robots by Position:
<ul>
<li>Sort the <code>indices</code> array based on the positions of the robots to ensure they are processed from left to right.</li>
</ul>
</li>
<li>Process Each Robot:
<ul>
<li>Iterate through each <code>current_index</code> in the sorted <code>indices</code> array:
<ul>
<li>If the robot is moving to the right (<code>'R'</code>):
<ul>
<li>Push <code>current_index</code> onto the stack.</li>
</ul>
</li>
<li>If the robot is moving to the left (<code>'L'</code>):
<ul>
<li>While the stack is not empty and the current robot's health is greater than <code>0</code>:
<ul>
<li>Pop the top robot from the stack (this is the most recent right-moving robot).</li>
<li>Compare the health of the current left-moving robot and the top right-moving robot:
<ul>
<li>If the top right-moving robot has more health:
<ul>
<li>Decrease its health by <code>1</code> and push it back onto the stack.</li>
<li>Set the current left-moving robot's health to <code>0</code>.</li>
</ul>
</li>
<li>If the current left-moving robot has more health:
<ul>
<li>Decrease its health by <code>1</code>.</li>
<li>Set the top right-moving robot's health to <code>0</code>.</li>
</ul>
</li>
<li>If both robots have the same health:
<ul>
<li>Set both robots' health to <code>0</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Collect Surviving Robots:
<ul>
<li>Iterate through each robot index from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If the robot's health is greater than <code>0</code>:
<ul>
<li>Append the robot's health to the <code>result</code> list.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>result</code> list, which contains the health of the surviving robots.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/PWpq6xtA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of robots.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>Sorting the robots based on their positions takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Initializing the <code>indices</code> array takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The for loop that processes each robot runs in <span class="math inline">\(O(n)\)</span> time since each robot is processed once.</p>
<p>Therefore, the overall time complexity is dominated by the sorting step, making it <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In Python, the <code>sort</code> method uses Timsort, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span> due to the additional space used by the merge operations.</p>
<p>In Java, <code>Arrays.sort()</code> uses a variant of Quick Sort for primitive types, with a space complexity of <span class="math inline">\(O(\log n)\)</span>.</p>
<p>In C++, the <code>sort()</code> function typically uses a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</p>
<p>Apart from the sorting step, we use an additional space of <span class="math inline">\(O(n)\)</span> for the <code>indices</code> array.</p>
<p>The stack in the worst case holds <span class="math inline">\(O(n)\)</span> elements.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-195">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/score-of-parentheses/description" target="_blank" rel="noopener noreferrer">Score of Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a balanced parentheses string <code>s</code>, return <em>the <strong>score</strong> of the string</em>.</p>

<p>The <strong>score</strong> of a balanced parentheses string is based on the following rule:</p>

<ul>
	<li><code>&quot;()&quot;</code> has score <code>1</code>.</li>
	<li><code>AB</code> has score <code>A + B</code>, where <code>A</code> and <code>B</code> are balanced parentheses strings.</li>
	<li><code>(A)</code> has score <code>2 * A</code>, where <code>A</code> is a balanced parentheses string.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;()&quot;
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(())&quot;
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;()()&quot;
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 50</code></li>
	<li><code>s</code> consists of only <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>
	<li><code>s</code> is a balanced parentheses string.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-196">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/secret-cipher--141631/1" target="_blank" rel="noopener noreferrer">Secret Cipher</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geek wants to send an&nbsp;encrypted message in the form of string <strong>S</strong>&nbsp;to his friend Keeg&nbsp;along with instructions on how to decipher the message.&nbsp;To decipher the message, his friend&nbsp;needs to iterate over the message string from left to right, if he finds a <strong>&#39;*&#39;</strong>, he must remove it and add all the letters read so far to the string. He must keep on doing this till he gets rid of all the <strong>&#39;*&#39;</strong>.<br />
Can you help Geek encrypt his message string <strong>S</strong>?&nbsp;</span></p>

<p><span style="font-size:18px"><strong>Note:</strong> If the string can be encrypted in multiple ways, find&nbsp;the smallest encrypted string.&nbsp;</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> S = &quot;ababcababcd&quot;
<strong>Output:</strong> ab*c*d
<strong>Explanation: </strong>We can encrypt the string 
in following way : &quot;ababcababcd&quot;&nbsp;-&gt; 
&quot;ababc*d&quot; -&gt; &quot;ab*c*d&quot;</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>S = &quot;zzzzzzz&quot;
<strong>Output:</strong> z*z*z
<strong>Explanation: </strong>The string can be encrypted 
in 2 ways: &quot;z*z*z&quot; and &quot;z**zzz&quot;. Out of 
the two &quot;z*z*z&quot; is smaller in length.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>secretCipher()</strong> which takes the message string <strong>S</strong> as input parameter and returns the shortest possible encrypted&nbsp;string.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><span style="font-size:18px"><strong>Constraints:&nbsp;</strong><br />
1 &le; |S| &le; 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-197">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shopkeeper-profit/1" target="_blank" rel="noopener noreferrer">Shopkeeper Profit</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Ram makes a plan for the new year. He decides to sell the products and writes down the price for&nbsp;<strong>n</strong><strong>&nbsp;</strong>days. The prices are denoted by an array<strong> arr[] </strong>of&nbsp;<strong>n</strong> elements. Looking at the sequence he decides that for the <strong>i<sup>th&nbsp;</sup></strong>product, he is going to get a profit that equals to&nbsp;<strong>(arr<sub>j&nbsp;</sub>- arr<sub>i</sub>)</strong>, where&nbsp;<strong>j</strong>&nbsp;is the minimum index just greater than&nbsp;<strong>i</strong> and&nbsp;<strong>arr<sub>j&nbsp;</sub>&gt;= arr<sub>i</sub></strong>. If there is no such&nbsp;<strong>j</strong>, then his profit will be equal to <strong>arr<sub>i</sub></strong>. Find the total profit of Ram.&nbsp;</span></p>
<p><span style="font-size: 18px;">Calculate profit for all the products.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">arr[] = [</span><span style="font-size: 18px;">5, 4, 6, 2, 1]</span>
<strong><span style="font-size: 18px;">Output:</span> </strong><span style="font-size: 18px;">12<br /><strong>Explanation: </strong></span><span style="font-size: 14pt;">For the above test case, since there are no elements to the right of 6 , 2 , and 1 which are greater than them, they are added to the answer which is now 6 + 2 + 1 = 9. Furthur more, for 5 and 4, 6 is greater than both of them which adds (6 - 5) and (6 - 4) to the answer and makes it 9 + 1 + 2 = 12.</span></pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">arr[] = [</span><span style="font-size: 18px;">1, 2, 3, 4]</span>
<strong><span style="font-size: 18px;">Output:</span> </strong><span style="font-size: 18px;">7<br /><strong>Explanation: </strong></span><span style="font-size: 14pt;">For the above test case, since there are no elements to the right of 4 which are greater than them, they are added to the answer which is now 4. Furthur more, for the remaining elements, their immediate right is greater than them. Hence we add 1 + 1 + 1 to the answer and make it 7. Note than for the second addition, we always consider index difference.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>5</sup><br />1 &lt;= arr<sub>i</sub>&nbsp;&lt;= 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-198">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description" target="_blank" rel="noopener noreferrer">Shortest Subarray to be Removed to Make Array Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>arr</code>, remove a subarray (can be empty) from <code>arr</code> such that the remaining elements in <code>arr</code> are <strong>non-decreasing</strong>.</p>

<p>Return <em>the length of the shortest subarray to remove</em>.</p>

<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,10,4,2,3,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,4,3,2,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The array is already non-decreasing. We do not need to remove any elements.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an array <code>arr</code>, we want to return the size of the smallest possible subarray we can remove to make the remaining elements sorted in non-decreasing order. It's acceptable to return an empty subarray if the elements are already sorted correctly.</p>
<p><img src="../Figures/1574/shortest_subarray_to_be_removed.png" alt="Test cases split into 3 parts" /></p>
<p>We can think of <code>arr</code> as being composed of 3 parts. The first part is a block of numbers in sorted order (blue region in the image above), followed by a block of numbers that breaks the sorted order (yellow region), and then finally another block of numbers in sorted order (green region).</p>
<p>For the nontrivial cases depicted above, we know that the subarray to remove resides somewhere in the middle of the array. Here, there can be multiple possibilities for what the middle elements can be. For the first example in the image, one option is to remove the block <code>[2, 3, 10, 4]</code>, leaving the remaining sorted sequence <code>[1, 2, 3, 5]</code>. Another option is to remove the block <code>[10, 4, 2]</code>, leaving another valid sequence <code>[1, 2, 3, 3, 5]</code>. The question then boils down to how we can find the smallest middle block of numbers to remove.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find the shortest subarray that, if removed, would make the array sorted. To do this, we must understand the problem from a few perspectives and break it down logically.</p>
<h5 id="1-identifying-the-longest-non-decreasing-subarrays">1. Identifying the Longest Non-Decreasing Subarrays</h5>
<p>The first thing to consider is that the array might already be mostly sorted, but just have a small portion that disrupts the order. This means that if we could find the longest part of the array that is already non-decreasing from the left and from the right, we would be left with just a small part in the middle that needs to be removed to make the entire array sorted.</p>
<p>The concept is to iterate through the array, looking for the longest continuous subarray that follows the non-decreasing order. We start from the left and move right, stopping when we hit a decrease. This is the first natural choice because if we can identify the longest subarray from the left, we know the part from the right must complement it or be the part we need to focus on.</p>
<p>Similarly, we do the same thing from the right side. This parallelism helps us understand both ends of the array and figure out where the sorting breaks down. These steps build on each other, showing us the boundaries within which we need to find the subarray to remove.</p>
<h5 id="2-the-case-where-the-array-is-already-sorted">2. The Case Where the Array is Already Sorted</h5>
<p>Now that we know how to find the longest non-decreasing subarrays from both ends, we need to think about the case where the array is already sorted. In this case, thereâ€™s no need to remove anything. So, we check if the left and right pointers (or indices) overlap or meet. If they do, the entire array is already sorted, and our work is done. This is an important insight because it helps us immediately return 0 when thereâ€™s no need to remove any subarray, avoiding unnecessary work.</p>
<h5 id="3-the-core-problem-what-to-remove">3. The Core Problem: What to Remove?</h5>
<p>If the array is not sorted, we are left with the task of determining the shortest subarray that can be removed to make the array sorted. We could remove just the left part, just the right part, or try merging the two non-decreasing sections.</p>
<p>Now, this might seem a bit tricky at first, but if we look closely, we can use the fact that if a section on the left is non-decreasing and a section on the right is also non-decreasing, there may still be a possibility of merging these sections by removing the middle. The relationship between the two sections plays a critical role. Specifically, we want to find a point where elements in the right section are greater than or equal to elements in the left section after considering the removal of the middle portion.</p>
<h5 id="4-the-final-search">4. The Final Search</h5>
<p>This leads us to the next part on how do we efficiently find where the two sections can merge? A naive approach might involve checking all pairs of elements, but that could be inefficient. Instead, we use binary search to find the smallest index in the right part of the array where the element is greater than or equal to the last element of the left part. By doing this, we can quickly pinpoint where the array can be &quot;joined&quot; back together, minimizing the subarray to remove.</p>
<p>This binary search approach leverages the sorted nature of the two subarrays. Since we know both the left and right subarrays are sorted, binary search allows us to find this boundary in logarithmic time, which is much more efficient than checking each element.</p>
<p>Finally, the solution is to take the minimum length of the subarrays that can be removed, whether thatâ€™s the left part, the right part, or the middle part (which we find through binary search).</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of <code>arr</code>, <code>left</code> as 0, and <code>right</code> as <code>n - 1</code>.</p>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the left:</p>
<ul>
<li>While <code>left + 1 &lt; n</code> and <code>arr[left] &lt;= arr[left + 1]</code>, increment <code>left</code> to expand the left subarray.</li>
</ul>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the right:</p>
<ul>
<li>While <code>right - 1 &gt;= 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code> to expand the right subarray.</li>
</ul>
</li>
<li>
<p>If the entire array is already sorted (i.e., <code>left &gt;= right</code>), return <code>0</code> as no subarray removal is needed.</p>
</li>
<li>
<p>Initialize <code>ans</code> to the smaller of removing the left or right part completely:</p>
<ul>
<li><code>ans = min(n - (left + 1), right)</code></li>
</ul>
</li>
<li>
<p>Try to merge the left and right parts:</p>
<ul>
<li>For each index <code>i</code> from 0 to <code>left</code>, use binary search (<code>helperBinarySearch</code>) to find the smallest index <code>j</code> where <code>arr[j] &gt;= arr[i]</code>.</li>
<li>Update <code>ans</code> as the minimum of <code>ans</code> and the difference <code>j - (i + 1)</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>, the length of the shortest subarray that can be removed to make the array sorted.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/haaC2UUS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>The first two <code>while</code> loops each run in <span class="math inline">\(O(N)\)</span> time to find the longest non-decreasing subarrays from the left and right.</p>
<p>After that, the <code>for</code> loop iterates up to <code>N</code> times, where for each iteration, a binary search is performed. Since binary search runs in <span class="math inline">\(O(\log N)\)</span> time, the total time complexity for the loop is <span class="math inline">\(O(N \log N)\)</span>.</p>
<p>Therefore, the overall time complexity is dominated by the <span class="math inline">\(O(N \log N)\)</span> component.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is mainly determined by the space required to store the input array <code>arr</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can optimize the solution further by replacing binary search (<span class="math inline">\(O(N \log N)\)</span>) with a more efficient two-pointer approach, reducing the complexity to <span class="math inline">\(O(N)\)</span>.</p>
<p>A key insight in the diagram below is that the unsorted yellow region must always be part of the removed subarray, as it breaks the sorted order. In other words, the remaining sorted array will always consist of a prefix of the blue subarray (from the first element up to some index), followed by a suffix of the green subarray (from the last element down to some index).</p>
<p><img src="../Figures/1574/two_pointers.png" alt="2 pointers" /></p>
<p>To consider all possibilities, use two pointers, <code>left</code> and <code>right</code>. The pointers represent the prefix blue array <code>arr[0:left]</code> and suffix green array <code>arr[right:]</code> consisting of the remaining sorted array we are considering. Initially, <code>left</code> is set to 0, meaning weâ€™re considering keeping the first element of the blue array. <code>Right</code> is set to the index of the start of the green subarray, meaning we consider keeping the entirety of the green subarray.</p>
<p>Using this two-pointer method, for each position of <code>left</code>, we search for the smallest <code>right</code> where <code>arr[left] &lt;= arr[right]</code>. If this condition holds, then we have found a valid subarray candidate to removeâ€”the subarray between <code>arr[left]</code> and <code>arr[right]</code>, which has a length of <code>right - left - 1</code>. If <code>arr[left] &gt; arr[right]</code>, we increment <code>right</code> to find the next possible match. Once a valid <code>right</code> is found, we advance <code>left</code> to the next element, repeating the process.</p>
<details>
  <summary>Why <code>arr[left] <= arr[right]</code> is Important (Click Here!)</summary>
  </br>
  <p><strong>Sorted Left Portion:</strong> The elements before left (i.e.,  <code>arr[0:left]</code>) are already sorted. Therefore,  <code>arr[left-1]</code> is the largest element in this prefix.</p>
  <p><strong>Sorted Right Portion:</strong> The elements from right onwards (i.e., <code>arr[right:]</code>) are sorted as well. Thus, <code>arr[right]</code> is the smallest element in the suffix.</p>
  <p>For the two sorted sections to form one valid sorted sequence when combined, we need the largest element in the left portion (<code>arr[left-1]</code>) to be less than or equal to the smallest element in the right portion (<code>arr[right]</code>), because:</p>
  <ul>
    <li>If <code>arr[left-1]</code> is greater than <code>arr[right]</code>, it means that after removing the unsorted middle section, the combined array would not be sorted.</li>
    <li>If <code>arr[left-1] <= arr[right]</code>, it guarantees that the largest element from the left side is smaller than or equal to the smallest element from the right side, ensuring the merged sequence is still sorted.</li>
  </ul>
</details>
</br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize our <code>right</code> pointer to the last index of <code>arr</code>.</li>
<li>We want to start our two-pointer process with <code>right</code> pointing to the start of the green sorted subarray. So we want to update <code>right</code> to the right index:
<ul>
<li>While <code>right &gt; 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code></li>
</ul>
</li>
<li>We initialize our <code>ans = right</code>. We note that the biggest subarray that can be removed is the entire subarray preceding <code>right</code>. Thus, the maximum size subarray to be removed is <code>right</code>.</li>
<li>We initialize our <code>left</code> pointer to <code>0</code>, the start of the blue sorted subarray.</li>
<li>While <code>left &lt; right</code> and <code>left</code> is still in the blue region: <code>left == 0 || arr[left - 1] &lt;= arr[left]</code>:
<ul>
<li>Find the right number after arr[left]:
<ul>
<li>While <code>right &lt; arr.length</code> and <code>arr[left] &gt; arr[right]</code>, increment <code>right</code></li>
</ul>
</li>
<li>Save length of the removed subarray: <code>ans = min(ans, right - left - 1)</code></li>
<li>Increment <code>left</code></li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QgsqkvCG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>In the worst case for our two pointer algorithm, <code>left</code> will traverse through the entire blue sorted region once, and <code>right</code> will traverse through the entire <code>green</code> sorted region once. Thus, the time complexity grows linearly with the size of <code>arr</code>: <span class="math inline">\(O(N)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use two pointers to store indices and do not have any auxiliary data structures, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-199">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-unsorted-continuous-subarray/description" target="_blank" rel="noopener noreferrer">Shortest Unsorted Continuous Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, you need to find one <b>continuous subarray</b> such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.</p>

<p>Return <em>the shortest such subarray and output its length</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,6,4,8,10,9,15]
<strong>Output:</strong> 5
<strong>Explanation:</strong> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you solve it in <code>O(n)</code> time complexity?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-200">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/simplify-path/description" target="_blank" rel="noopener noreferrer">Simplify Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code>&#39;/&#39;</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</p>

<p>The <em>rules</em> of a Unix-style file system are as follows:</p>

<ul>
	<li>A single period <code>&#39;.&#39;</code> represents the current directory.</li>
	<li>A double period <code>&#39;..&#39;</code> represents the previous/parent directory.</li>
	<li>Multiple consecutive slashes such as <code>&#39;//&#39;</code> and <code>&#39;///&#39;</code> are treated as a single slash <code>&#39;/&#39;</code>.</li>
	<li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file </strong><strong>name</strong>. For example, <code>&#39;...&#39; </code>and <code>&#39;....&#39;</code> are valid directory or file names.</li>
</ul>

<p>The simplified canonical path should follow these <em>rules</em>:</p>

<ul>
	<li>The path must start with a single slash <code>&#39;/&#39;</code>.</li>
	<li>Directories within the path must be separated by exactly one slash <code>&#39;/&#39;</code>.</li>
	<li>The path must not end with a slash <code>&#39;/&#39;</code>, unless it is the root directory.</li>
	<li>The path must not have any single or double periods (<code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>) used to denote current or parent directories.</li>
</ul>

<p>Return the <strong>simplified canonical path</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">path = &quot;/home/&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;/home&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>The trailing slash should be removed.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">path = &quot;/home//foo/&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;/home/foo&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>Multiple consecutive slashes are replaced by a single one.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">path = &quot;/home/user/Documents/../Pictures&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;/home/user/Pictures&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>A double period <code>&quot;..&quot;</code> refers to the directory up a level (the parent directory).</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">path = &quot;/../&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;/&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>Going one level up from the root directory is not possible.</p>
</div>

<p><strong class="example">Example 5:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">path = &quot;/.../a/../b/c/../d/./&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;/.../b/d&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p><code>&quot;...&quot;</code> is a valid name for a directory in this problem.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= path.length &lt;= 3000</code></li>
	<li><code>path</code> consists of English letters, digits, period <code>&#39;.&#39;</code>, slash <code>&#39;/&#39;</code> or <code>&#39;_&#39;</code>.</li>
	<li><code>path</code> is a valid absolute Unix path.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-201">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/smallest-number-on-left3403/1" target="_blank" rel="noopener noreferrer">Smaller on Left</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong> of integers, for each element in the array, find the <strong data-start="209" data-end="248">nearest smaller element on its left</strong>. If there is no such smaller element, return <strong>-1</strong> for that position.</span></p>
<pre><span style="font-size: 20px;"><strong>Input:</strong> arr[] = [1, 6, 2]
<strong>Output:</strong> [-1, 1, 1]
<strong>Explaination:</strong> <br /><span style="font-size: 14pt;">There is no number to the left of 1, so we return -1. </span><br /><span style="font-size: 14pt;">After that, the number is 6, and the nearest smaller number on its left is 1. </span><br /><span style="font-size: 14pt;">Next, the number is 2, and the nearest smaller number on the left is also 1.</span></span></pre>
<pre><span style="font-size: 20px;"><strong>Input:</strong> arr[] = [1, 5, 0, 3, 4, 5]<br /><strong>Output</strong>: [-1, 1, -1, 0, 3, 4]
<strong>Explaination:</strong> <br /></span><span style="font-size: 14pt;">There is no number to the left of <strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="128" data-end="133">1</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">,  so we return </span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="148" data-end="154">-1</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. <br /></span>After that, the number is<span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="184" data-end="189">5</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">,  and the nearest smaller number on its left is</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="237" data-end="242">1</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. <br /> </span>Next, the number is&nbsp;<strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="266" data-end="271">0</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">, and there is no smaller number on the left, so we return&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="330" data-end="336">-1</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">.<br /></span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">Then comes&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;" data-start="351" data-end="356">3</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">, and the nearest smaller number on its left is&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;" data-start="404" data-end="409">0</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">.<br /></span>After that, the number is<span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="439" data-end="444">4</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">, and the nearest smaller number on the left is</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" data-start="492" data-end="497">3</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. <br /></span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">Finally, the number is&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;" data-start="524" data-end="529">5</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">, and the nearest smaller number on its left is&nbsp;</span><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;" data-start="577" data-end="582">4</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">.</span></span></pre>
<p><span style="font-size: 20px;"><strong>Constraints:</strong><br />1 &le; arr.size()&le; 10<sup>6</sup><br />1 &le; arr[i] &le; 10<sup>3</sup>&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-202">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/description" target="_blank" rel="noopener noreferrer">Smallest K-Length Subsequence With Occurrences of a Letter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>, an integer <code>k</code>, a letter <code>letter</code>, and an integer <code>repetition</code>.</p>

<p>Return <em>the <strong>lexicographically smallest</strong> subsequence of</em> <code>s</code><em> of length</em> <code>k</code> <em>that has the letter</em> <code>letter</code> <em>appear <strong>at least</strong></em> <code>repetition</code> <em>times</em>. The test cases are generated so that the <code>letter</code> appears in <code>s</code> <strong>at least</strong> <code>repetition</code> times.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>

<p>A string <code>a</code> is <strong>lexicographically smaller</strong> than a string <code>b</code> if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leet&quot;, k = 3, letter = &quot;e&quot;, repetition = 1
<strong>Output:</strong> &quot;eet&quot;
<strong>Explanation:</strong> There are four subsequences of length 3 that have the letter &#39;e&#39; appear at least 1 time:
- &quot;lee&quot; (from &quot;<strong><u>lee</u></strong>t&quot;)
- &quot;let&quot; (from &quot;<strong><u>le</u></strong>e<u><strong>t</strong></u>&quot;)
- &quot;let&quot; (from &quot;<u><strong>l</strong></u>e<u><strong>et</strong></u>&quot;)
- &quot;eet&quot; (from &quot;l<u><strong>eet</strong></u>&quot;)
The lexicographically smallest subsequence among them is &quot;eet&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="example-2" src="https://assets.leetcode.com/uploads/2021/09/13/smallest-k-length-subsequence.png" style="width: 339px; height: 67px;" />
<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, k = 4, letter = &quot;e&quot;, repetition = 2
<strong>Output:</strong> &quot;ecde&quot;
<strong>Explanation:</strong> &quot;ecde&quot; is the lexicographically smallest subsequence of length 4 that has the letter &quot;e&quot; appear at least 2 times.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bb&quot;, k = 2, letter = &quot;b&quot;, repetition = 2
<strong>Output:</strong> &quot;bb&quot;
<strong>Explanation:</strong> &quot;bb&quot; is the only subsequence of length 2 that has the letter &quot;b&quot; appear at least 2 times.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>letter</code> is a lowercase English letter, and appears in <code>s</code> at least <code>repetition</code> times.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-203">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-subsequence-of-distinct-characters/description" target="_blank" rel="noopener noreferrer">Smallest Subsequence of Distinct Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <em>the </em><span data-keyword="lexicographically-smaller-string"><em>lexicographically smallest</em></span> <span data-keyword="subsequence-string"><em>subsequence</em></span><em> of</em> <code>s</code> <em>that contains all the distinct characters of</em> <code>s</code> <em>exactly once</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bcabc&quot;
<strong>Output:</strong> &quot;abc&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbacdcbc&quot;
<strong>Output:</strong> &quot;acdb&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<strong>Note:</strong> This question is the same as 316: <a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank">https://leetcode.com/problems/remove-duplicate-letters/</a></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-204">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sort-a-stack/1" target="_blank" rel="noopener noreferrer">Sort a stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a stack, the task is to sort&nbsp;it such that the top of the stack has the greatest&nbsp;element.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>Stack: 3 2 1
<strong>Output: </strong>3 2 1</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>Stack: 11 2 32 3 41
<strong>Output: </strong>41 32 11 3 2</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;</strong><br />You don't have to read input or print anything. Your task is to complete the function&nbsp;<strong>sort()&nbsp;</strong>which sorts the elements present in the given stack. (The sorted stack is printed by the driver's code by popping the elements of the stack.)</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>: O(N*N)<br /><strong>Expected Auxilliary Space</strong>: O(N) recursive.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=N&lt;=100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-205">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/special-stack/1" target="_blank" rel="noopener noreferrer">Special Stack</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Design a data-structure<strong> </strong>SpecialStack<strong>&nbsp;</strong>that supports all the stack operations like <strong>push()</strong>, <strong>pop()</strong>,<strong> isEmpty()</strong>, <strong>isFull()</strong> and an additional operation <strong>getMin()</strong> which should return the <strong>minimum </strong>element from the SpecialStack. Your task is to complete all the functions, using a stack data structure.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;The output of the code will be the value returned by&nbsp;<strong>getMin()&nbsp;</strong>function.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>stack: 18 19 29 15 16<strong>
Output: </strong>15
<strong>Explanation: </strong>The minimum element of the stack is 15.<br /></span></pre>
<pre><strong>I<span style="font-size: 14pt;">nput: </span></strong><span style="font-size: 14pt;">stack: 34 335 1814 86<strong>
Output: </strong>34
<strong>Explanation: </strong>The minimum element of the stack is 34.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(n)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; stack.size() &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-206">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/staque-1-e790a29f/" target="_blank" rel="noopener noreferrer">Stack and Queue &lt;Nissan&gt;</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">easy</span> <span class="topic-badge">implementation</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a stack of <strong>N</strong> integers such that the first element represents the top of the stack and the last element represents the bottom of the stack. You need to pop at least one element from the stack. AtÂ any one moment, you can convert stack into a queue. The bottom of the stack represents the front of the queue. You cannot convert the queue back into a stack. Your task isÂ to remove exactly <strong>K</strong> elements such that theÂ sum of the <strong>K </strong>removed elements is maximised.</p>

<p><strong>Input format :Â  Â  Â </strong></p>

<ul>
	<li>The first line consists of two space-separated integers <strong>N</strong> and <strong>K</strong>.</li>
	<li>The second line consists of <strong>N</strong> space-separated integers denoting the elements of the stack.</li>
</ul>

<p><strong>Output format :</strong></p>

<ul>
	<li>Print the maximum possible sum of the <strong>K </strong>removedÂ elements</li>
</ul>

<p><strong>Constraints :</strong></p>

<ul>
	<li><span class="mathjax-latex">\(1 \le N \le 10^{5}\)</span></li>
	<li><span class="mathjax-latex">\(1 \le K \le N\)</span></li>
	<li><span class="mathjax-latex">\(1 \le A_{i} \le 10^{9}\)</span></li>
</ul></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Pop two elements from the stack. i.e {10,9}</p>

<p>Then convert the stack into queue and remove first three elements from the queue. i.e {8,7,6}.</p>

<p>The maximum possible sum is 10+9+8+7+6 = 40</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-207">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/stack-designer/1" target="_blank" rel="noopener noreferrer">Stack designer</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">stl</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an integer array <strong>arr[]</strong>. You need to push the elements of the array into a stack and then print them while popping.<br /><strong>Note:&nbsp;</strong>No need to print extra line after printing the stack elements.<br /></span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong><span style="font-size: 18px;"><strong> </strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr = [1, 2, 3, 4, 5]
<strong>Output: </strong>5 4 3 2 1<br /><strong>Explanation: </strong>Elements are pushed and then popped from the top of the stack in the order 5, 4, 3, 2, 1.<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> </span><span style="font-size: 18px;">arr = [1, 6, 43, 1, 2, 0, 5]</span>
<span style="font-size: 18px;"><strong>Output:</strong> </span><span style="font-size: 18px;">5 0 2 1 43 6 1</span></pre>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong><br /><span style="font-size: 18px;">1 &lt;= arr[i] &lt;= 10<sup>7</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-208">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/stakth-1-e6a76632/" target="_blank" rel="noopener noreferrer">Stack operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">easy</span> <span class="topic-badge">implementation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given aÂ stack of <strong>N</strong> integers. In one operation, you can either pop an element from the stack or push any popped element into the stack. You needÂ to maximize the top element of the stack after performing exactly <strong>K</strong>Â operations.Â If the stack becomes empty after performing K operations and there is no other way for the stack to be non-empty, print <strong>-1</strong>.</p>

<p><strong>Â Â </strong></p>

<p><strong>Input format :</strong></p>

<ul>
	<li>The first line of input consists of two space-separated integers <strong>N</strong> and <strong>K</strong>.</li>
	<li>The second line of input consists <strong>N</strong> space-separated integers denoting the elements of the stack. The first element represents the top of the stack and the last element represents the bottom of the stack.</li>
</ul>

<p><strong>Output format :</strong></p>

<ul>
	<li>Print the maximum possible top element of the stack after performing exactly <strong>K</strong>Â operations.</li>
</ul>

<p><strong>Constraints :Â </strong></p>

<ul>
	<li><span class="mathjax-latex">\(1 \le N \le 2*10^{6}\)</span></li>
	<li><span class="mathjax-latex">\(1 \le A_{i} \le 10^{18}\)</span></li>
	<li><span class="mathjax-latex">\(1 \le K \le 10^{9}\)</span></li>
</ul></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In 3 operations, we remove 1,2,4 and in the fourth operation, we push 4 back into the stack. Hence, 4 is the answer.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-209">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/stacks-operations/1" target="_blank" rel="noopener noreferrer">Stack Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><em><span style="font-size: 18px;">This Java module deals with Stacks, Queues, and ArrayLists. We'll perform various operations on them.</span></em></p>
<p><span style="font-size: 18px;">Given a <strong>stack </strong>of <strong>integers </strong>and <strong>Q</strong> queries. The task is to perform operation on stack according to the query.</span></p>
<p><span style="font-size: 18px;"><strong>Note</strong><span style="background-color: transparent; font-family: arial;">: use </span><a style="text-decoration: none;" href="https://www.geeksforgeeks.org/stack-push-method-in-java/"><u>push()</u></a><span style="background-color: transparent; font-family: arial;"> to add element in the stack, </span><a style="text-decoration: none;" href="https://www.geeksforgeeks.org/stack-peek-method-in-java/"><u>peek()</u></a><span style="background-color: transparent; font-family: arial;"> to get topmost element without removal, </span><a style="text-decoration: none;" href="https://www.geeksforgeeks.org/stack-pop-method-in-java/"><u>pop()</u></a><span style="background-color: transparent; font-family: arial;"> gives topmost element with removal, </span><a style="text-decoration: none;" href="https://www.geeksforgeeks.org/stack-search-method-in-java/"><u>search()</u></a><span style="background-color: transparent; font-family: arial;"> to return position if found else <strong>-1</strong>.</span></span></p>
<p><span style="font-size: 18px;"><strong>Input Format:</strong><br />First line of input contains nubmer of testcases <strong>T</strong>. For each testcase, first line of input contains Q, number of queries. Next line contains Q queries seperated by space. Queries are as:</span></p>
<ol>
<li dir="ltr">
<p dir="ltr"><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>i x :</strong> (<strong>adds </strong>element x in the stack)</span>.</span></p>
</li>
<li dir="ltr">
<p dir="ltr"><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>r :</strong> (<strong>returns </strong>and <strong>removes </strong>the topmost element from the stack).</span></span></p>
</li>
<li dir="ltr">
<p dir="ltr"><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>h :</strong> </span>Prints the topmost element.</span></p>
</li>
<li dir="ltr">
<p dir="ltr"><span style="font-size: 18px;"><span style="background-color: transparent; font-family: arial;"><strong>f y :</strong> (check if the <strong>element </strong>y is <strong>present or not </strong>in the stack).</span> Print "<strong>Yes</strong>" if present, else "<strong>No</strong>".</span></p>
</li>
</ol>
<p dir="ltr"><span style="font-size: 18px;"><strong>Output Format:</strong><br />For each testcase, perform Q queries and print the output wherever required.</span></p>
<p dir="ltr"><span style="font-size: 18px;"><strong>Your Task:</strong><br />Your task is to complete functions <strong>insert()</strong>, <strong>remove()</strong>, <strong>headOf_Stack()</strong> and <strong>find()</strong>, to insert, remove returning top element and finding the elment in stack respectively.</span></p>
<p dir="ltr"><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= T &lt;= 100<br />1 &lt;= Q &lt;= 10<sup>3</sup></span></p>
<p dir="ltr"><span style="font-size: 18px;"><strong>Example:<br />Input:</strong><br />2<br />6<br />i 2 i 4 i 3 i 5 h f 8<br />4<br />i 3 i 4 r f 3</span></p>
<p><span style="font-size: 18px;"><strong>Output:</strong><br />5<br />No<br />Yes</span></p>
<p><span style="font-size: 18px;"><strong>Explanation:<br />Testcase 1:</strong> Inserting 2, 4, 3, and 5 onto the stack. Returning top element which is 5. Finding 8 will give No, as 8 is not in the stack.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-210">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/stack-permutations/1" target="_blank" rel="noopener noreferrer">Stack Permutations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">implementation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given two arrays <strong>a[]</strong> and<strong> b[] </strong>of unique elements of&nbsp; same size . Check if&nbsp; array <strong>b[]</strong> is a stack permutation of the array <strong>a[] </strong>or not. Stack permutation means that array&nbsp;<strong>b[]</strong>&nbsp;can be created from array&nbsp;<strong>a[]&nbsp;</strong>using a stack and stack operations.<br /><br /></span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>a[] = [1, 2, 3], b[] = [2 ,1 ,3]
<strong>Output: </strong>True
<strong>Explanation:</strong>
1. push 1 from a to stack
2. push 2 from a to stack
3. pop 2 from stack to b
4. pop 1 from stack to b
5. push 3 from a to stack
6. pop 3 from stack to b</span></pre>
<pre><span style="font-size: 14pt;"><strong><br />Input: </strong>a[] = [1, 2, 3], b[] = [3 ,1 ,2]
<strong>Output: </strong>False
<strong>Explanation:</strong>Not Possible<br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1&nbsp;<span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;">&le;</span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;"> a.size()=b.size()</span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;">&le;</span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;"> </span>&nbsp;10<sup>5<br /></sup>0&nbsp;<span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;">&le;</span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;"> </span>&nbsp;a[i], b[i] <span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;">&le;</span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito;"> </span>&nbsp;2*10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-211">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/implement-stack-using-linked-list/1" target="_blank" rel="noopener noreferrer">Stack using Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">linkedlist</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Let's give it a try! You have a linked list and must implement the functionalities push and pop of stack using this given linked list. Your task is to use the class as shown in the comments in the code editor and complete the functions push() and pop() to implement a stack.&nbsp;<br /></span><span style="font-size: 18px;">The push() method takes one argument, an integer&nbsp;</span><strong style="font-size: 18px;">'x'</strong><span style="font-size: 18px;">&nbsp;to be pushed into the stack and&nbsp;</span><strong style="font-size: 18px;">pop()</strong><span style="font-size: 18px;">&nbsp;which returns an integer present at the top and popped out from the stack. If the stack is empty then return&nbsp;</span><strong style="font-size: 18px;">-1</strong><span style="font-size: 18px;">&nbsp;from the pop() method.<br /></span><strong><span style="font-size: 18px;">Note:&nbsp;</span></strong><span style="font-size: 18px;">The input is given in the form of queries. Since there are two operations push() and pop(), there is two types of queries as described below:<br /></span><span style="font-size: 18px;">(i) 1&nbsp;&nbsp; (a query of this type takes <strong>x</strong> as another parameter and pushes it into the stack)<br /></span><span style="font-size: 18px;">(ii) 2&nbsp; (a query of this type means to pop an element from the stack and return the popped element)<br /></span><span style="font-size: 18px;">Input is separated by space and as described above.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples </strong>:</span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: [[1,2], [1,3], [2], [1,4], [2]]
<strong>Output</strong>: [3, 4]
<strong>Explanation</strong>: 
push(2)  : the stack will be {2}
push(3)  : the stack will be {2 3}
pop()    : poped element will be 3,the stack will be {2}
push(4)  : the stack will be {2 4}
pop()    : poped element will be 4</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: [[2], [1,4], [1,5], [2]]
<strong>Output</strong>: [-1, 4]</span><br /><span style="font-size: 18px;"><strong>Explanation</strong>: 
pop()    : the stack is empty so its -1.
push(4)  : the stack will be {4}
push(5)  : the stack will be {4 5}
pop()    : poped element will be 5, the stack will be {4}</span></pre>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;"><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>: O(1)</span><br /><span style="font-size: 18px;"><strong>Expected Auxillary Space:</strong>&nbsp;O(1)</span></p>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;"><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= numbers of calls made to push, pop &lt;= 100<br />1 &lt;= x &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-212">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/stack-using-two-queues/1" target="_blank" rel="noopener noreferrer">Stack using two queues</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">design-pattern</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Implement a Stack&nbsp;using two queues<strong>&nbsp;q1</strong>&nbsp;and<strong>&nbsp;q2</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:
</strong>push(2)
push(3)
pop()
push(4)
pop()<strong>
Output: </strong>3 4
<strong>Explanation:
</strong>push(2) stack will be [2]
push(3) stack will be [2 3]
pop()   popped element will be 3 the stack will be [2] 
push(4) the stack will be [2 4]
pop() &nbsp; popped element will be 4  </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:
</strong>push(2)
pop()
pop()
push(3)<strong>
Output: </strong>2 -1<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation:<br /></strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">push( 2 ) stack will be [ 2 ]</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"><br />pop( ) popped element will be 2<br />pop( ) stack is empty so popped element will be -1<br />push( ) stack will be [ 3 ]</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1&lt;=Number of queries&lt;=100<br />1&lt;= size of stack&lt;=100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-213">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stamping-the-sequence/description" target="_blank" rel="noopener noreferrer">Stamping The Sequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>stamp</code> and <code>target</code>. Initially, there is a string <code>s</code> of length <code>target.length</code> with all <code>s[i] == &#39;?&#39;</code>.</p>

<p>In one turn, you can place <code>stamp</code> over <code>s</code> and replace every letter in the <code>s</code> with the corresponding letter from <code>stamp</code>.</p>

<ul>
	<li>For example, if <code>stamp = &quot;abc&quot;</code> and <code>target = &quot;abcba&quot;</code>, then <code>s</code> is <code>&quot;?????&quot;</code> initially. In one turn you can:

	<ul>
		<li>place <code>stamp</code> at index <code>0</code> of <code>s</code> to obtain <code>&quot;abc??&quot;</code>,</li>
		<li>place <code>stamp</code> at index <code>1</code> of <code>s</code> to obtain <code>&quot;?abc?&quot;</code>, or</li>
		<li>place <code>stamp</code> at index <code>2</code> of <code>s</code> to obtain <code>&quot;??abc&quot;</code>.</li>
	</ul>
	Note that <code>stamp</code> must be fully contained in the boundaries of <code>s</code> in order to stamp (i.e., you cannot place <code>stamp</code> at index <code>3</code> of <code>s</code>).</li>
</ul>

<p>We want to convert <code>s</code> to <code>target</code> using <strong>at most</strong> <code>10 * target.length</code> turns.</p>

<p>Return <em>an array of the index of the left-most letter being stamped at each turn</em>. If we cannot obtain <code>target</code> from <code>s</code> within <code>10 * target.length</code> turns, return an empty array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stamp = &quot;abc&quot;, target = &quot;ababc&quot;
<strong>Output:</strong> [0,2]
<strong>Explanation:</strong> Initially s = &quot;?????&quot;.
- Place stamp at index 0 to get &quot;abc??&quot;.
- Place stamp at index 2 to get &quot;ababc&quot;.
[1,0,2] would also be accepted as an answer, as well as some other answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stamp = &quot;abca&quot;, target = &quot;aabcaca&quot;
<strong>Output:</strong> [3,0,1]
<strong>Explanation:</strong> Initially s = &quot;???????&quot;.
- Place stamp at index 3 to get &quot;???abca&quot;.
- Place stamp at index 0 to get &quot;abcabca&quot;.
- Place stamp at index 1 to get &quot;aabcaca&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>
	<li><code>stamp</code> and <code>target</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-work-backwards">Approach 1: Work Backwards</h3>
<p><strong>Intuition</strong></p>
<p>Imagine we stamped the sequence with moves <span class="math inline">\(m_1, m_2, \cdots\)</span>.  Now, from the final position <code>target</code>, we will make those moves in reverse order.</p>
<p>Let's call the <code>i</code>th <em>window</em>, a subarray of <code>target</code> of length <code>stamp.length</code> that starts at <code>i</code>.  Each move at position <code>i</code> is possible if the <code>i</code>th window matches the stamp.  After, every character in the window becomes a wildcard that can match any character in the stamp.</p>
<p>For example, say we have <code>stamp = &quot;abca&quot;</code> and <code>target = &quot;aabcaca&quot;</code>.  Working backwards, we will reverse stamp at window <code>1</code> to get <code>&quot;a????ca&quot;</code>, then reverse stamp at window <code>3</code> to get <code>&quot;a??????&quot;</code>, and finally reverse stamp at position <code>0</code> to get <code>&quot;???????&quot;</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Let's keep track of every window.  We want to know how many cells initially match the stamp (our &quot;<code>made</code>&quot; list), and which ones don't (our <code>&quot;todo&quot;</code> list).  Any windows that are ready (ie. have no todo list), get enqueued.</p>
<p>Specifically, we enqueue the positions of each character.  (To save time, we enqueue by character, not by window.)  This represents that the character is ready to turn into a <code>&quot;?&quot;</code> in our working <code>target</code> string.</p>
<p>Now, how to process characters in our queue?  For each character, let's look at all the windows that intersect it, and update their todo lists.  If any todo lists become empty in this manner <code>(window.todo is empty)</code>, then we enqueue the characters in <code>window.made</code> that we haven't processed yet.</p>
<p><a href="https://leetcode.com/playground/UwjdAegP/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N(N-M))\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>stamp</code>, <code>target</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N(N-M))\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-214">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/steps-to-make-array-non-decreasing/description" target="_blank" rel="noopener noreferrer">Steps to Make Array Non-decreasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked-list</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one step, <strong>remove</strong> all elements <code>nums[i]</code> where <code>nums[i - 1] &gt; nums[i]</code> for all <code>0 &lt; i &lt; nums.length</code>.</p>

<p>Return <em>the number of steps performed until </em><code>nums</code><em> becomes a <strong>non-decreasing</strong> array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,4,4,7,3,6,11,8,5,11]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The following are the steps performed:
- Step 1: [5,<strong><u>3</u></strong>,4,4,7,<u><strong>3</strong></u>,6,11,<u><strong>8</strong></u>,<u><strong>5</strong></u>,11] becomes [5,4,4,7,6,11,11]
- Step 2: [5,<u><strong>4</strong></u>,4,7,<u><strong>6</strong></u>,11,11] becomes [5,4,7,11,11]
- Step 3: [5,<u><strong>4</strong></u>,7,11,11] becomes [5,7,11,11]
[5,7,11,11] is a non-decreasing array. Therefore, we return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,7,7,13]
<strong>Output:</strong> 0
<strong>Explanation:</strong> nums is already a non-decreasing array. Therefore, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-215">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/stock-span-problem-1587115621/1" target="_blank" rel="noopener noreferrer">Stock span problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">The stock span problem is a financial problem where we have a series of daily price quotes for a stock and we need to calculate the span of stock price for all days. The span&nbsp;<strong>arr[i]</strong>&nbsp;of the stocks price on a given day&nbsp;<strong>i</strong>&nbsp;is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the given day is less than or equal to its price on the current day.<br /></span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [100, 80, 60, 70, 60, 75, 85]
<strong>Output</strong>: [1, 1, 1, 2, 1, 4, 6]
<strong>Explanation</strong>: Traversing the given input span 100 is greater than equal to 100 and there are no more elements behind it so the span is 1, 80 is greater than equal to 80 and smaller than 100 so the span is 1, 60 is greater than equal to 60 and smaller than 80 so the span is 1, 70 is greater than equal to 60,70 and smaller than 80 so the span is 2 and so on.  Hence the output will be 1 1 1 2 1 4 6.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [10, 4, 5, 90, 120, 80]
<strong>Output</strong>: [1, 1, 2, 4, 5, 1]
<strong>Explanation</strong>: Traversing the given input span 10 is greater than equal to 10 and there are no more elements behind it so the span is 1, 4 is greater than equal to 4 and smaller than 10 so the span is 1, 5 is greater than equal to 4,5 and smaller than 10 so the span is 2,  and so on. Hence the output will be 1 1 2 4 5 1.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; arr.size()&le; 10<sup>5</sup><br />1 &le; arr[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-216">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/string-manipulation3706/1" target="_blank" rel="noopener noreferrer">String Manipulation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><div class="starwars-lab">
<p><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;">Tom is a string freak. He has got sequences of words <strong>arr[]</strong> to manipulate. If in a sequence, two same words come together then Tom destroys each other. Find the number of words left in the sequence after this pairwise destruction.</span></span>&nbsp;</p>
<div class="starwars-lab">
<p><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Examples:</strong></span></span></p>
<pre><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Input: </strong>arr[] = ["ab", "aa", "aa", "bcd", "ab"]
<strong>Output: </strong>3<strong>
Explanation: </strong>After the first iteration, we'll have: ab bcd ab. We can't further destroy more strings and hence we stop and the result is 3. </span></span></pre>
<pre><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Input: </strong>arr[] = ["tom", "jerry", "jerry", "tom"]
<strong>Output: </strong>0
<strong>Explanation: </strong>After the first iteration, we'll have: tom tom. After the second iteration: 'empty-array' .Hence, the result is 0.</span></span></pre>
</div>
<p><span style="font-size: 14pt;"><span style="font-family: arial, helvetica, sans-serif;"><strong>Expected Time Complexity: </strong>O(n)<br /><strong>Expected Auxiliary Space: </strong>O(n)<br /><br /><strong>Constraints:</strong><br />1 &le; arr.size() &le;10<sup>6</sup><br />1 &le; |arr<sub>i</sub>| &le; 50</span></span></p>
</div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-217">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/string-rp-or-pr--170647/1" target="_blank" rel="noopener noreferrer">String rp or pr</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a string S. In one operation, you can remove the substring &quot;pr&quot; from the string S and get amount X or you can remove the substring &quot;rp&quot; and get the amount Y.&nbsp;<br />
Find the maximum amount you can get if you perform zero or more such operations optimally.&nbsp;</span></p>

<p><span style="font-size:18px"><strong>Note :&nbsp;</strong></span></p>

<ul>
	<li><span style="font-size:18px">Substring of a string S is defined as a continuous sequence of characters in S.</span></li>
	<li><span style="font-size:18px">After removing pr or rp, the order of remaining letters should remain the same<strong>.</strong></span></li>
</ul>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px">X = 5, Y = 4
S = &quot;abppprrr&quot;</span>
<strong><span style="font-size:18px">Output:</span> </strong><span style="font-size:18px">15</span>
<span style="font-size:18px"><strong>Explanation: </strong></span>
<span style="font-size:18px">Here, S <strong>= &quot;</strong>abppprrr&quot; </span>
<span style="font-size:18px">X= 5, Y=4.</span>
<span style="font-size:18px">Remove &quot;pr&quot;, new string S = &quot;abpprr&quot;.</span>
<span style="font-size:18px">Remove &quot;pr&quot;, new string S = &quot;abpr&quot;.</span>
<span style="font-size:18px">Remove &quot;pr&quot;, new string S = &quot;ab&quot;.</span>
<span style="font-size:18px">In total, we removed &quot;pr&quot; 3 times, 
so total score is 3*X + 0*Y = 3*5 =15.</span>
</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px">X = 7, Y = 7
S = &quot;prpptppr&quot;</span>
<strong><span style="font-size:18px">Output:</span> </strong><span style="font-size:18px">14</span>
<span style="font-size:18px"><strong>Explanation: </strong></span>
<span style="font-size:18px">Here, S <strong>= &quot;</strong>prpptppr&quot; </span>
<span style="font-size:18px">X= 7, Y=7.
As both have the same amount we can first 
remove either pr or rp. Here we start with pr</span>
<span style="font-size:18px">Remove &quot;pr&quot;, new string S = &quot;pptppr&quot;.</span>
<span style="font-size:18px">Remove &quot;pr&quot;, new string S = &quot;pptp&quot;.</span>
<span style="font-size:18px">In total, we removed &quot;pr&quot; 2 times, 
so total score is 2*X + 0*Y = 2*7 =14.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function<strong>&nbsp;solve()</strong>&nbsp;which takes the X ,Y and string S&nbsp;as input parameters&nbsp;and&nbsp;returns the maximum amount you can get after performing the above operations.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(|S|)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(|S|)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints</strong>:<br />
1 &le; |S| &le; 10<sup>5</sup><br />
1 &le; X,Y &le; 10<sup>5</sup><br />
S contains&nbsp;lowercase English letters only.</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-218">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/description" target="_blank" rel="noopener noreferrer">Subarray With Elements Greater Than Varying Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>threshold</code>.</p>

<p>Find any subarray of <code>nums</code> of length <code>k</code> such that <strong>every</strong> element in the subarray is <strong>greater</strong> than <code>threshold / k</code>.</p>

<p>Return<em> the <strong>size</strong> of <strong>any</strong> such subarray</em>. If there is no such subarray, return <code>-1</code>.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,4,3,1], threshold = 6
<strong>Output:</strong> 3
<strong>Explanation:</strong> The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.
Note that this is the only valid subarray.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,5,6,5,8], threshold = 7
<strong>Output:</strong> 1
<strong>Explanation:</strong> The subarray [8] has a size of 1, and 8 &gt; 7 / 1 = 7. So 1 is returned.
Note that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. 
Similarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.
Therefore, 2, 3, 4, or 5 may also be returned.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], threshold &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-219">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-of-max-of-subarrays/1" target="_blank" rel="noopener noreferrer">Sum of Max of Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-family: arial, helvetica, sans-serif;"><span style="color: #273239; font-size: 18px; letter-spacing: 0.162px; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">Given an array&nbsp;</span><strong style="color: #273239; font-size: 18px; letter-spacing: 0.162px; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">arr[]</strong><span style="color: #273239; font-size: 18px; letter-spacing: 0.162px; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">, the task is to find the sum of the maximum <strong>elements</strong> of every possible non-empty sub-arrays of the given array <strong>arr[]</strong>.</span></span></p>
<p><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Note</strong>: The answer will always fit into <strong>32 bit integer</strong>.</span></p>
<p><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Examples:</strong></span></p>
<pre><span style="font-family: arial, helvetica, sans-serif;"><span style="box-sizing: border-box; line-height: 1.7em; font-size: 14pt; color: var(--text-color) !important; background-color: unset !important;"><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Input: </span><span style="color: #273239; letter-spacing: 0.162px; word-spacing: 0px; white-space-collapse: preserve; background-color: #f9f9f9;">arr[] = [1, 3, 2]<br /></span></span><span style="box-sizing: border-box; line-height: 1.7em; font-size: 14pt; color: var(--text-color) !important; background-color: unset !important;"><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Output: </span><span style="color: #273239; letter-spacing: 0.162px; word-spacing: 0px; white-space-collapse: preserve; background-color: #f9f9f9;">15<br /></span></span><span style="font-size: 14pt;"><span style="box-sizing: border-box; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;"><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Explanation: </span></span>All possible non-empty subarrays of [1, 3, 2] are [1], [3], [2], [1, 3], [3, 2] and [1, 3, 2]. The maximum elements of the subarrays are 1, 3, 2, 3, 3, 3 respectively. The sum will be 15.</span></span></pre>
<pre style="box-sizing: border-box; line-height: 1.7em; color: #1e2229; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; border: 1px solid var(--card-border); border-radius: 4px; white-space: break-spaces; word-spacing: 4px; font-family: var(--gfg-font-primary) !important;"><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><span style="box-sizing: border-box; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;"><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Input: </span><span style="color: #273239; letter-spacing: 0.162px; word-spacing: 0px; white-space-collapse: preserve; background-color: #f9f9f9;">arr[] = [3, 1]<br /></span><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Output: </span>7<br /><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Explanation: </span></span>All possible non-empty subarrays of [3, 1] are [3], [1] and [3, 1]. The maximum elements of the subarrays are 3, 1, 3 respectively. The sum will be 7.</span></pre>
<pre style="box-sizing: border-box; line-height: 1.7em; color: #1e2229; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; border: 1px solid var(--card-border); border-radius: 4px; white-space: break-spaces; word-spacing: 4px; font-family: var(--gfg-font-primary) !important;"><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><span style="box-sizing: border-box; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;"><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Input: </span><span style="color: #273239; letter-spacing: 0.162px; word-spacing: 0px; white-space-collapse: preserve; background-color: #f9f9f9;">arr[] = [8, 0, 1]</span>
<span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">Output: </span><span style="color: #273239; letter-spacing: 0.162px; word-spacing: 0px; white-space-collapse: preserve; background-color: #f9f9f9;">26</span><span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; background-color: unset !important;">
Explanation: </span></span>All possible non-empty subarrays of [8, 0, 1] are [8], [0], [1], [8, 0], [0, 1] and [8, 0, 1]. The maximum elements of the subarrays are 8, 0, 1, 8, 1, 8 respectively. The sum will be 26.</span></pre>
<p><span style="font-family: arial, helvetica, sans-serif;"><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong></span><span style="font-family: arial, helvetica, sans-serif;"><span style="box-sizing: border-box; line-height: 1.7em; font-size: 14pt; color: #1e2229; background-color: #ffffff;">1 &lt;= arr.size() &lt;= 10<sup>4<br /></sup>0 &lt;= arr[i] &lt;= 10<sup>9</sup></span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-220">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-of-subarray-minimum/1" target="_blank" rel="noopener noreferrer">Sum of subarray minimum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>a</strong><strong>rr</strong> containing positive integers, find the sum of the minimum element of all subarrays. Since the answer may be very large, return the answer modulo 10<sup>9</sup>&nbsp;+7.&nbsp;</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [3, 1, 2, 4]<br /><strong>Output: </strong>17<br /><strong>Explanation:</strong> subarrays are [3], [1], [2], [4], [3, 1], [1, 2], [2, 4], [3, 1, 2], [1, 2, 4], [3, 1, 2, 4]. Minimums are 3 , 1 , 2 , 4 , 1 , 1 , 2 , 1 , 1 , 1 ans sum of all these are 17.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [71, 55, 82, 55]<br /><strong>Output: </strong>593<br /><strong>Explanation: </strong>The sum of the minimum of all the subarrays are 593.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />0 &le; arr[i]<sub>&nbsp;&nbsp;</sub>&le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-221">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-subarray-minimums/description" target="_blank" rel="noopener noreferrer">Sum of Subarray Minimums</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers arr, find the sum of <code>min(b)</code>, where <code>b</code> ranges over every (contiguous) subarray of <code>arr</code>. Since the answer may be large, return the answer <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,1,2,4]
<strong>Output:</strong> 17
<strong>Explanation:</strong> 
Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
Sum is 17.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [11,81,94,43,3]
<strong>Output:</strong> 444
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-222">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-of-subarray-ranges/1" target="_blank" rel="noopener noreferrer">Sum of subarray ranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer array <strong>arr[]</strong>, the range of a subarray is defined as the difference between the <strong>largest</strong> and <strong>smallest</strong> elements within that subarray. Your task is to return the <strong>sum</strong> of the ranges of all possible subarrays in the array.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input :</strong>arr[] = [1 ,2 , 3]<strong><br />Output:</strong> 4<strong><br />Explanation: </strong>The 6 subarray of arr are the following :</span><br /><span style="font-size: 18px;">[1], range = largest - smallest = 1 - 1 = 0<br />[2], range = largest - smallest = 2 - 2 = 0<br />[3], range = largest - smallest = 3 - 3 = 0<br />[1, 2] range = largest - smallest = 2 - 1 = 1<br />[2, 3] range = largest - smallest = 3 - 2 = 1<br />[1, 2, 3] range = largest - smallest = 3 - 1 = 2<br />Sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2=4</span></pre>
<pre><span style="font-size: 18px;"><strong>Input :</strong> arr[] = [-32, 0, -2, 72]<strong><br />Output= </strong>318<strong><br />Explanation: <br /></strong>[-32], range = largest - smallest = -32- (-32) = 0<br />[-32, 0], range = largest - smallest = 0- (-32) = 32<br />[-32, 0, -2], range = largest - smallest = 0 - (-32) = 32<br />[-32, 0, -2, 72], range= largest - smallest = 72 - (-32) = 104<br />[0], range = largest - smallest = 0 - 0 = 0<br />[0, -2], range = largest - smallest = 0 - (-2) = 2<br />[0, -2, 72], range = largest - smallest = 72 - (-2) = 74<br />[-2], range = largest - smallest = -2 - (-2) = 0<br />[-2,72], range = largest - smallest = 72- (-2) = 74<br />[72], range = largest - smallest = 72 - 72 = 0<br />Sum of all ranges is 0 + 32 + 32 + 104 + 0 + 2 + 74 + 0 + 74 + 0 = 318</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br />10<sup>-9&nbsp;</sup>&le; arr[i]<sub>&nbsp;&nbsp;</sub>&le; 10<sup>-9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-223">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-subarray-ranges/description" target="_blank" rel="noopener noreferrer">Sum of Subarray Ranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. The <strong>range</strong> of a subarray of <code>nums</code> is the difference between the largest and smallest element in the subarray.</p>

<p>Return <em>the <strong>sum of all</strong> subarray ranges of </em><code>nums</code><em>.</em></p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0 
[2], range = 2 - 2 = 0
[3], range = 3 - 3 = 0
[1,2], range = 2 - 1 = 1
[2,3], range = 3 - 2 = 1
[1,2,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,3]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0
[3], range = 3 - 3 = 0
[3], range = 3 - 3 = 0
[1,3], range = 3 - 1 = 2
[3,3], range = 3 - 3 = 0
[1,3,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,-2,-3,4,1]
<strong>Output:</strong> 59
<strong>Explanation:</strong> The sum of all subarray ranges of nums is 59.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Could you find a solution with <code>O(n)</code> time complexity?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Define the <strong>range</strong> of a subarray as the difference between the largest and smallest element in the subarray:</p>
<p><img src="../Figures/2104/2104-ex.png" alt="img" /></p>
<p>The task is to find the sum of all subarray ranges of the given array <code>nums</code>.</p>
<hr />
<h3 id="approach-1-two-loops">Approach 1: Two Loops</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's start with a brute force solution, that is, to find and iterate over all subarrays of <code>nums</code>, and get the sum of their ranges.</p>
<ol>
<li>Set <code>answer = 0</code>.</li>
<li>Iterate over every left index of subarrays <code>left</code>.</li>
<li>With every fixed <code>left</code>, iterate over every right index <code>right</code> of subarrays.</li>
<li>For each subarray <code>[left, right]</code>, iterate over it to find its minimum value <code>minVal</code> and maximum value <code>maxVal</code>.</li>
<li>Increment <code>answer</code> by <code>maxVal - minVal</code>.</li>
</ol>
<p>This approach contains three nested loops which make the time complexity quite high, so it may not pass all test cases. But we can consider this as a prompt for better approaches!</p>
<p>Note that for a fixed <code>left</code> index, two adjacent arrays only differ by one element. Suppose the previous array is <code>[left, right]</code> and the new array is <code>[left, right + 1]</code>, we can get the <code>minVal, maxVal</code> for the new subarray, by updating <code>minVal, maxVal</code> of the previous array using <code>nums[right + 1]</code>.</p>
<ul>
<li><code>minVal = min(minVal, nums[right + 1])</code></li>
<li><code>maxVal = max(maxVal, nums[right + 1])</code></li>
</ul>
<p>Therefore, the average time for finding the range of one subarray is reduced to <span class="math inline">\(O(1)\)</span>. Please refer to the following picture.</p>
<p><img src="../Figures/2104/2104-s2.png" alt="img" /></p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Set <code>answer = 0</code>.</li>
<li>Iterate over every left index of subarrays <code>left</code>.</li>
<li>With every fixed <code>left</code>, initialize <code>minVal = maxVal = nums[left]</code>, iterate over every right index <code>right</code> of subarrays.</li>
<li>For each right index <code>right</code>, update <code>minVal</code> and <code>maxVal</code> by <code>nums[right]</code>. Then update <code>answer += maxVal - minVal</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fcRRFV5u/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>We have two nested iterations over <code>nums</code>.</li>
<li>In each step, we update <code>minVal, maxVal</code> and <code>answer</code>, it takes constant time.</li>
<li>To sum up, the overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>We only need to update three variables <code>minVal</code>, <code>maxVal</code> and <code>answer</code>.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>From the definition of the sum of all subarray ranges:</p>
<p><span class="math display">\[
> It implies that we can calculate these two partial sums separately.

Let's think of this problem differently, instead of finding each subarray and getting its `minVal` and `maxVal`, we focus on each number. If we can find that, for each number `nums[i]`, the number of subarrays having `nums[i]` as its **minimum value** is `minTime[i]`. Then the sum of `minVal` can be rewritten as:

$$\sum\limits_{k} minVal_{k} = \sum\limits_{i = 1}^{n} minTime[i]\ \cdot\ nums[i]$$

For example, we have found `minTime = [1, 4, 1]` for the array `[X, Y, Z]` by some means (which will be explained in detail soon), then the sum of `minVal` is `1 * X + 4 * Y + 1 * Z`. We don't need to know exactly which array holds which value as the minimum, but only the number of times each number is taken as the minimum!


> Now the task becomes finding `minTime[i]` for each index `i`.

Notice that `minTime[i]` depends on:

- The number of consecutive elements **larger than or equal to** `nums[i]` on its left side. In other words, to find the index `left` where the value is **less than** `nums[i]`.

- The number of consecutive elements **larger than or equal to** `nums[i]` on its right side. In other words, to find the index `right` where the value is **strictly less than** `nums[i]`.

Now we have (i - left) positions to put the starting position of the subarray, and (right - i) positions to put the ending position of the subarray. Therefore, we have (i - left) * (right - i) valid subarrays in total, so we can calculate `minTime[i]` as follows:

$$minTime[i] = (right - i) \cdot (i - left)$$
$$range_i = minTime[i] \cdot nums[i]$$

In the array shown below, `nums[3] = 4` has `left = 0` and `right = 6`, thus the number of subarrays having `nums[3]` as the minimum is `minTime[3] = (6 - 3) *  (3 - 0) = 9`, meaning that there are 9 subarays having `nums[3]` as the minimum.


![img](../Figures/2104/2104-stack1.png)



To calculate `minTime[i]` for every index, we can use a stack to maintain a monotonically increasing sequence during the iteration over `nums`:

- What is the left index `left`? The element on `nums[i]`'s left in the stack.

- What is the right index `right`? The element we are using to pop `nums[i]` from the stack. 

In other words, `minTime[i]` is not calculated when we add `nums[i]` to the stack, but when we **pop** `nums[i]` from the stack, because only then are the left and right indexes clear to us. Then we can calculate `minTime[i]` using: $$minTime[i] = (right - i) \cdot (i - left)$$. As shown in the picture below, when we encounter `nums[6] = 1`, we should pop `nums[3] = 4` from the stack, which is the time to calculate `minTime[3]`.

![img](../Figures/2104/2104-stack2.png)

> How to handle the edge cases?

- If the stack is empty after we pop `nums[i]` from it, we can't find the any index as the left boundary, so we set the left index as `-1`, which means that all the numbers on `nums[i]`'s left are within the range `[left, i]`.

- In order to pop the remaining elements from the stack after the iteration over `nums` stops, we set the right boundaries of all the remaining elements as `n`, which means that all the numbers on `nums[i]`'s right are within the range `[i, right]`. That's why we iterate from `i = 0` to `i = n`: to use `i = n` as the right boundary index to pop all the remaining elements from the stack.



> Will there by any duplicated calculation? 

One might think, what if there are identical values that are close or adjacent, do we double count any subarray? The answer is NO! Although several identical values `A` may be adjacent to each other, the subarrays of the previous `A` will never take the following `A` as their minimum. As shown in the picture below, subarrays using the first `4` as the minimum don't cross the second `4`, thus we won't double count any subarray!

![img](../Figures/2104/2104-edge.png)


> With each subproblem solved, we can move on to the results!

Please take the following slides as an example of getting the total sum of `minVal`. 

!?!../Documents/2104/s1.json:601,301!?!

Note that this iteration is to get the sum of `minVal`. We also need to find the sum of `maxVal` in a similar way, by reversing the comparison condition, then get the sum of ranges using the first equation in this chapter. The job is done!

> If you are not much familiar with stack, we suggest you read our [Leetcode Explore Card](https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/1369/) and have some knowledge of it beforehand.

<br>

#### Algorithm

1) Initialize an empty stack `stack`, get the size of `nums` as `n`.
2) Iterate over every index from `0` to `n` (inclusive). For each index `right`, if either of the following two condition is met: 
    - `index = n`
    - `stack` is not empty and `nums[mid] >= nums[right]`, where `mid` is its top value: 

    go to step 3.
    Otherwise, repeat step 2.
3) Calculate the number of subarrays with `nums[mid]` as its minimum value:
    - Pop `mid` from stack.
    - If `stack` is empty, set `left = -1`, otherwise, `left` equals the top element from `stack`.
    - Increment `answer` by `(right - mid) * (mid - left)`.
    - Repeat step 2.


#### Implementation

[code](https://leetcode.com/playground/2ENJNW6U/shared)


#### Complexity Analysis

Let $$n$$ be the size of the input array `nums`.

* Time complexity: $$O(n)$$

    - To find the total sum of `minVal`, we only need one iteration over `nums`, and each number will be added to and popped from `stack` once, these also apply for finding `maxVal`.
    - Therefore the overall time complexity is $$O(n)$$.
    

* Space complexity: $$O(n)$$

    - We use a (monotonic) stack to keep the increasing (decreasing) sequence, in the worst-case scenario, there may be $$O(n)$$ numbers in the stack, which takes $$O(n)$$ space. 


<br/>\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-224">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-total-strength-of-wizards/description" target="_blank" rel="noopener noreferrer">Sum of Total Strength of Wizards</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">prefix-sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>As the ruler of a kingdom, you have an army of wizards at your command.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>strength</code>, where <code>strength[i]</code> denotes the strength of the <code>i<sup>th</sup></code> wizard. For a <strong>contiguous</strong> group of wizards (i.e. the wizards&#39; strengths form a <strong>subarray</strong> of <code>strength</code>), the <strong>total strength</strong> is defined as the <strong>product</strong> of the following two values:</p>

<ul>
	<li>The strength of the <strong>weakest</strong> wizard in the group.</li>
	<li>The <strong>total</strong> of all the individual strengths of the wizards in the group.</li>
</ul>

<p>Return <em>the <strong>sum</strong> of the total strengths of <strong>all</strong> contiguous groups of wizards</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strength = [1,3,1,2]
<strong>Output:</strong> 44
<strong>Explanation:</strong> The following are all the contiguous groups of wizards:
- [1] from [<u><strong>1</strong></u>,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [3] from [1,<u><strong>3</strong></u>,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9
- [1] from [1,3,<u><strong>1</strong></u>,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [2] from [1,3,1,<u><strong>2</strong></u>] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4
- [1,3] from [<u><strong>1,3</strong></u>,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4
- [3,1] from [1,<u><strong>3,1</strong></u>,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4
- [1,2] from [1,3,<u><strong>1,2</strong></u>] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3
- [1,3,1] from [<u><strong>1,3,1</strong></u>,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
- [3,1,2] from [1,<u><strong>3,1,2</strong></u>] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
- [1,3,1,2] from [<u><strong>1,3,1,2</strong></u>] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strength = [5,4,6]
<strong>Output:</strong> 213
<strong>Explanation:</strong> The following are all the contiguous groups of wizards: 
- [5] from [<u><strong>5</strong></u>,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
- [4] from [5,<u><strong>4</strong></u>,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
- [6] from [5,4,<u><strong>6</strong></u>] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
- [5,4] from [<u><strong>5,4</strong></u>,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [4,6] from [5,<u><strong>4,6</strong></u>] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [5,4,6] from [<u><strong>5,4,6</strong></u>] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-225">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/tag-validator/description" target="_blank" rel="noopener noreferrer">Tag Validator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.</p>

<p>A code snippet is valid if all the following rules hold:</p>

<ol>
	<li>The code must be wrapped in a <b>valid closed tag</b>. Otherwise, the code is invalid.</li>
	<li>A <b>closed tag</b> (not necessarily valid) has exactly the following format : <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>. Among them, <code>&lt;TAG_NAME&gt;</code> is the start tag, and <code>&lt;/TAG_NAME&gt;</code> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is <b>valid</b> if and only if the TAG_NAME and TAG_CONTENT are valid.</li>
	<li>A <b>valid</b> <code>TAG_NAME</code> only contain <b>upper-case letters</b>, and has length in range [1,9]. Otherwise, the <code>TAG_NAME</code> is <b>invalid</b>.</li>
	<li>A <b>valid</b> <code>TAG_CONTENT</code> may contain other <b>valid closed tags</b>, <b>cdata</b> and any characters (see note1) <b>EXCEPT</b> unmatched <code>&lt;</code>, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the <code>TAG_CONTENT</code> is <b>invalid</b>.</li>
	<li>A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.</li>
	<li>A <code>&lt;</code> is unmatched if you cannot find a subsequent <code>&gt;</code>. And when you find a <code>&lt;</code> or <code>&lt;/</code>, all the subsequent characters until the next <code>&gt;</code> should be parsed as TAG_NAME (not necessarily valid).</li>
	<li>The cdata has the following format : <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>. The range of <code>CDATA_CONTENT</code> is defined as the characters between <code>&lt;![CDATA[</code> and the <b>first subsequent</b> <code>]]&gt;</code>.</li>
	<li><code>CDATA_CONTENT</code> may contain <b>any characters</b>. The function of cdata is to forbid the validator to parse <code>CDATA_CONTENT</code>, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as <b>regular characters</b>.</li>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> 
The code is wrapped in a closed tag : &lt;DIV&gt; and &lt;/DIV&gt;. 
The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. 
Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.
So TAG_CONTENT is valid, and then the code is valid. Thus return true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> code = &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong>
We first separate the code into : start_tag|tag_content|end_tag.
start_tag -&gt; <b>&quot;&lt;DIV&gt;&quot;</b>
end_tag -&gt; <b>&quot;&lt;/DIV&gt;&quot;</b>
tag_content could also be separated into : text1|cdata|text2.
text1 -&gt; <b>&quot;&gt;&gt;  ![cdata[]] &quot;</b>
cdata -&gt; <b>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;</b>, where the CDATA_CONTENT is <b>&quot;&lt;div&gt;]&gt;&quot;</b>
text2 -&gt; <b>&quot;]]&gt;&gt;]&quot;</b>
The reason why start_tag is NOT <b>&quot;&lt;DIV&gt;&gt;&gt;&quot;</b> is because of the rule 6.
The reason why cdata is NOT <b>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot;</b> is because of the rule 7.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> code = &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> Unbalanced. If &quot;&lt;A&gt;&quot; is closed, then &quot;&lt;B&gt;&quot; must be unmatched, and vice versa.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= code.length &lt;= 500</code></li>
	<li><code>code</code> consists of English letters, digits, <code>&#39;&lt;&#39;</code>, <code>&#39;&gt;&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;!&#39;</code>, <code>&#39;[&#39;</code>, <code>&#39;]&#39;</code>, <code>&#39;.&#39;</code>, and <code>&#39; &#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<p>Summarizing the given problem, we can say that we need to determine whether a tag is valid or not, by checking the following properties.</p>
<ol>
<li>
<p>The code should be wrapped in a valid closed tag.</p>
</li>
<li>
<p>The <code>TAG_NAME</code> should be valid.</p>
</li>
<li>
<p>The <code>TAG_CONTENT</code> should be valid.</p>
</li>
<li>
<p>The <strong>cdata</strong> should be valid.</p>
</li>
<li>
<p>All the tags should be closed. i.e. each start-tag should have a corresponding end-tag and vice-versa and the order of the tags should be correct as well.</p>
</li>
</ol>
<p>In order to check the validity of all these, firstly, we need to identify which parts of the given <span class="math inline">\(code\)</span> string act as which part from the above-mentioned categories. To understand how it's done, we'll go through the implementation and the reasoning behind it step by step.</p>
<p>We iterate over the given <span class="math inline">\(code\)</span> string. Whenever a <code>&lt;</code> is encountered(unless we are currently inside <code>&lt;![CDATA[...]]&gt;</code>), it indicates the beginning of either a <code>TAG_NAME</code>(start tag or end tag) or the beginning of cdata as per the conditions given in the problem statement.</p>
<p>If the character immediately following this <code>&lt;</code> is an <code>!</code>, the characters following this <code>&lt;</code> can't be a part of a valid <code>TAG_NAME</code>, since only upper-case letters(in case of a start tag) or <code>/</code> followed by upper-case letters(in the case of an end tag). Thus, the choice now narrows down to only <strong>cdata</strong>. Thus, we need to check if the current bunch of characters following <code>&lt;!</code>(including it) constitute a valid <strong>cdata</strong>. To do this, firstly we find out the first matching <code>]]&gt;</code> following the current <code>&lt;!</code> to mark the ending of <strong>cdata</strong>. If no such matching <code>]]&gt;</code> exists, the <span class="math inline">\(code\)</span> string is considered as invalid. Apart from this, the <code>&lt;!</code> should also be immediately followed by <code>CDATA[</code> for the <strong>cdata</strong> to be valid. The characters lying inside the  <code>&lt;![CDATA[</code> and <code>]]&gt;</code> do not have any constraints on them.</p>
<p>If the character immediately following the <code>&lt;</code> encountered isn't an <code>!</code>, this <code>&lt;</code> can only mark the beginning of <code>TAG_NAME</code>. Now, since a valid start tag can't contain anything except upper-case letters if a <code>/</code> is found after <code>&lt;</code>, the <code>&lt;/</code> pair indicates the beginning of an end tag. Now, when a <code>&lt;</code> refers to the beginning of a <code>TAG_NAME</code>(either start-tag or end-tag), we find out the first closing <code>&gt;</code> following the <code>&lt;</code> to find out the substring(say <span class="math inline">\(s\)</span>), that constitutes the <code>TAG_NAME</code>. This <span class="math inline">\(s\)</span> should satisfy all the criteria to constitute a valid <code>TAG_NAME</code>. Thus, for every such <span class="math inline">\(s\)</span>, we check if it contains all upper-case letters and also check its length(It should be between 1 to 9). If any of the criteria isn't fulfilled, <span class="math inline">\(s\)</span> doesn't constitute a valid <code>TAG_NAME</code>. Hence, the <span class="math inline">\(code\)</span> string turns out to be invalid as well.</p>
<p>Apart from checking the validity of the <code>TAG_NAME</code>, we also need to ensure that the tags always exist in pairs. i.e. for every start-tag, a corresponding end-tag should always exist. Further, we can note that in case of multiple <code>TAG_NAME</code>'s, the <code>TAG_NAME</code> whose start-tag comes later than the other ones, should have its end-tag appearing before the end-tags of those other <code>TAG_NAME</code>'s. i.e. the tag that starts later should end first.</p>
<p>From this, we get the intuition that we can make use of a <span class="math inline">\(stack\)</span> to check the existence of matching start and end-tags. Thus, whenever we find out a valid start-tag, as mentioned above, we push its <code>TAG_NAME</code> string onto a <span class="math inline">\(stack\)</span>. Now, whenever an end-tag is found, we compare its <code>TAG_NAME</code> with the <code>TAG_NAME</code> at the top of the <span class="math inline">\(stack\)</span> and remove this element from the <span class="math inline">\(stack\)</span>. If the two don't match, this implies that either the current end-tag has no corresponding start-tag or there is a problem with the ordering of the tags. The two need to match for the tag-pair to be valid since there can't exist an end-tag without a corresponding start-tag and vice-versa. Thus, if a match isn't found, we can conclude that the given <span class="math inline">\(code\)</span> string is invalid.</p>
<p>Now, after the complete <span class="math inline">\(code\)</span> string has been traversed, the <span class="math inline">\(stack\)</span> should be empty if all the start-tags have their corresponding end-tags as well. If the <span class="math inline">\(stack\)</span> isn't empty, this implies that some start-tag doesn't have the corresponding end-tag, violating the closed-tag's validity condition.</p>
<p>Further, we also need to ensure that the given <span class="math inline">\(code\)</span> is completely enclosed within closed tags. For this, we need to ensure that the first <strong>cdata</strong> found is also inside the closed tags. Thus, when we find a possibility of the presence of <strong>cdata</strong>, we proceed further only if we've already found a start tag, indicated by a non-empty stack. Further, to ensure that no data lies after the last end-tag, we need to ensure that the <span class="math inline">\(stack\)</span> doesn't become empty before we reach the end of the given <span class="math inline">\(code\)</span> string since an empty <span class="math inline">\(stack\)</span> indicates that the last end-tag has been encountered.</p>
<p>The following animation depicts the process.</p>
<p>!?!../Documents/Tag_Validator_Stack.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/akLDftNr/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We traverse over the given <span class="math inline">\(code\)</span> string of length <span class="math inline">\(n\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The stack can grow upto a size of <span class="math inline">\(n/3\)</span> in the worst case. e.g. In case of <code>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;D&gt;</code>, <span class="math inline">\(n\)</span>=12 and number of tags = 12/3 = 4.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-2-regex">Approach 2: Regex</h3>
<p>Instead of manually checking the given <span class="math inline">\(code\)</span> string for checking the validity of <code>TAG_NAME</code>, <code>TAG_CONTENT</code> and <strong>cdata</strong>, we can make use of an inbuilt java functionality known as regular expressions.</p>
<p>A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data. The most common quantifiers used in regular expressions are listed below. A quantifier after a token (such as a character) or group specifies how often that preceding element is allowed to occur.</p>
<p><code>?</code>	The question mark indicates zero or one occurrence of the preceding element. For example, colou?r matches both &quot;color&quot; and &quot;colour&quot;.</p>
<p><code>*</code>	The asterisk indicates zero or more occurrences of the preceding element. For example, ab*c matches &quot;ac&quot;, &quot;abc&quot;, &quot;abbc&quot;, &quot;abbbc&quot;, and so on.</p>
<p><code>+</code>	The plus sign indicates one or more occurrences of the preceding element. For example, ab+c matches &quot;abc&quot;, &quot;abbc&quot;, &quot;abbbc&quot;, and so on, but not &quot;ac&quot;.</p>
<p><code>{n}</code> The preceding item is matched exactly <strong>n</strong> times.</p>
<p><code>{min,}</code> The preceding item is matched <strong>min</strong> or more times.</p>
<p><code>{min,max}</code>	The preceding item is matched at least <strong>min</strong> times, but not more than <strong>max</strong> times.</p>
<p><code>|</code> A vertical bar separates alternatives. For example, gray|grey can match &quot;gray&quot; or &quot;grey&quot;.</p>
<p><code>()</code> Parentheses are used to define the scope and precedence of the operators (among other uses). For example, gray|grey and gr(a|e)y are equivalent patterns that both describe the set of &quot;gray&quot; or &quot;grey&quot;.</p>
<p><code>[...]</code>	Matches any single character in brackets.</p>
<p><code>[^...]</code>	Matches any single character not in brackets.</p>
<p>Thus, by making use of regex, we can directly check the validity of the <span class="math inline">\(code\)</span> string directly(except the nesting of the inner tags) by using the regex expression below:</p>
<p><code>&lt;([A-Z]{1,9})&gt;([^&lt;]*((&lt;\/?[A-Z]{1,9}&gt;)|(&lt;!\[CDATA\[(.*?)]]&gt;))?[^&lt;]*)*&lt;\/\1&gt;</code></p>
<p>The image below shows the portion of the string that each part of the expression helps to match:</p>
<p><img src="../Figures/591/591_Tag_Validator.PNG" alt="Regex" /></p>
<p>But, if we make use of back-referencing as mentioned above, the matching process takes a very large amount of CPU time. Thus, we use the regex only to check the validity of the <code>TAG_CONTENT</code>, <code>TAG_NAME</code> and the <strong>cdata</strong>. We check the presence of the outermost closed tags by making use of a <span class="math inline">\(stack\)</span> as done in the last approach.</p>
<p>The rest of the process remains the same as in the last approach, except that we need not manually check the validity of <code>TAG_CONTENT</code>, <code>TAG_NAME</code>, and the <strong>cdata</strong>, since it is already done by the regex expression. We only need to check the presence of inner closed tags.</p>
<p>Check <a href="http://regexr.com/">this</a> link for testing any regular expression on a sample text.</p>
<p><a href="https://leetcode.com/playground/Pzdftc9z/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: Regular Expressions are/can be implemented in the form of finite-state machines. Thus, the time complexity is dependent on the internal representation. In the case of any suggestions, please comment below.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>. The stack can grow up to a size of <span class="math inline">\(n/3\)</span> in the worst case. e.g. In case of <code>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;D&gt;</code>, <span class="math inline">\(n\)</span>=12 and number of tags = 12/3 = 4.<br />
<br><br />
<br></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-226">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/the-celebrity-problem/1" target="_blank" rel="noopener noreferrer">The Celebrity Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">A celebrity is a person who is known to all but&nbsp;<strong>does not know</strong>&nbsp;anyone at a party. A party is being organized by some people. A square matrix&nbsp;<strong>mat[][]&nbsp;</strong>(n*n)&nbsp;is used to represent people at the party such that if an element of <strong>row i and column j is set to 1</strong> it means <strong>ith person knows jth person</strong>.&nbsp;You need to return the <strong>index of the celebrity</strong> in the party, if the celebrity does not exist, return&nbsp;<strong>-1</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;Follow <strong>0-based </strong>indexing.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 1, 0], [0, 1, 0], [0, 1, 1]]
<strong>Output:</strong> 1
<strong>Explanation: </strong>0th and 2nd person both know 1st person. Therefore, 1 is the celebrity person. </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 1], [1, 1]]
<strong>Output:</strong> -1
<strong>Explanation: </strong>Since both the people at the party know each other. Hence none of them is a celebrity person.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1]]
<strong>Output:</strong> 0</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= mat.size()&lt;= 1000<br />0 &lt;= mat[i][j]&lt;= 1<br />mat[i][i] == 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-227">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-number-of-weak-characters-in-the-game/description" target="_blank" rel="noopener noreferrer">The Number of Weak Characters in the Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are playing a game that contains multiple characters, and each of the characters has <strong>two</strong> main properties: <strong>attack</strong> and <strong>defense</strong>. You are given a 2D integer array <code>properties</code> where <code>properties[i] = [attack<sub>i</sub>, defense<sub>i</sub>]</code> represents the properties of the <code>i<sup>th</sup></code> character in the game.</p>

<p>A character is said to be <strong>weak</strong> if any other character has <strong>both</strong> attack and defense levels <strong>strictly greater</strong> than this character&#39;s attack and defense levels. More formally, a character <code>i</code> is said to be <strong>weak</strong> if there exists another character <code>j</code> where <code>attack<sub>j</sub> &gt; attack<sub>i</sub></code> and <code>defense<sub>j</sub> &gt; defense<sub>i</sub></code>.</p>

<p>Return <em>the number of <strong>weak</strong> characters</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> properties = [[5,5],[6,3],[3,6]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> No character has strictly greater attack and defense than the other.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> properties = [[2,2],[3,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The first character is weak because the second character has a strictly greater attack and defense.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> properties = [[1,5],[10,4],[4,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The third character is weak because the second character has a strictly greater attack and defense.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= properties.length &lt;= 10<sup>5</sup></code></li>
	<li><code>properties[i].length == 2</code></li>
	<li><code>1 &lt;= attack<sub>i</sub>, defense<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-228">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-score-of-students-solving-math-expression/description" target="_blank" rel="noopener noreferrer">The Score of Students Solving Math Expression</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that contains digits <code>0-9</code>, addition symbols <code>&#39;+&#39;</code>, and multiplication symbols <code>&#39;*&#39;</code> <strong>only</strong>, representing a <strong>valid</strong> math expression of <strong>single digit numbers</strong> (e.g., <code>3+5*2</code>). This expression was given to <code>n</code> elementary school students. The students were instructed to get the answer of the expression by following this <strong>order of operations</strong>:</p>

<ol>
	<li>Compute <strong>multiplication</strong>, reading from <strong>left to right</strong>; Then,</li>
	<li>Compute <strong>addition</strong>, reading from <strong>left to right</strong>.</li>
</ol>

<p>You are given an integer array <code>answers</code> of length <code>n</code>, which are the submitted answers of the students in no particular order. You are asked to grade the <code>answers</code>, by following these <strong>rules</strong>:</p>

<ul>
	<li>If an answer <strong>equals</strong> the correct answer of the expression, this student will be rewarded <code>5</code> points;</li>
	<li>Otherwise, if the answer <strong>could be interpreted</strong> as if the student applied the operators <strong>in the wrong order</strong> but had <strong>correct arithmetic</strong>, this student will be rewarded <code>2</code> points;</li>
	<li>Otherwise, this student will be rewarded <code>0</code> points.</li>
</ul>

<p>Return <em>the sum of the points of the students</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png" style="width: 678px; height: 109px;" />
<pre>
<strong>Input:</strong> s = &quot;7+3*1*2&quot;, answers = [20,13,42]
<strong>Output:</strong> 7
<strong>Explanation:</strong> As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,<u><strong>13</strong></u>,42]
A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [<u><strong>20</strong></u>,13,42]
The points for the students are: [2,5,0]. The sum of the points is 2+5+0=7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;3+5*2&quot;, answers = [13,0,10,13,13,16,16]
<strong>Output:</strong> 19
<strong>Explanation:</strong> The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [<strong><u>13</u></strong>,0,10,<strong><u>13</u></strong>,<strong><u>13</u></strong>,16,16]
A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,<strong><u>16</u></strong>,<strong><u>16</u></strong>]
The points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;6+0*1&quot;, answers = [12,9,6,4,8,6]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The correct answer of the expression is 6.
If a student had incorrectly done (6+0)*1, the answer would also be 6.
By the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.
The points for the students are: [0,0,5,0,0,5]. The sum of the points is 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 31</code></li>
	<li><code>s</code> represents a valid expression that contains only digits <code>0-9</code>, <code>&#39;+&#39;</code>, and <code>&#39;*&#39;</code> only.</li>
	<li>All the integer operands in the expression are in the <strong>inclusive</strong> range <code>[0, 9]</code>.</li>
	<li><code>1 &lt;=</code> The count of all operators (<code>&#39;+&#39;</code> and <code>&#39;*&#39;</code>) in the math expression <code>&lt;= 15</code></li>
	<li>Test data are generated such that the correct answer of the expression is in the range of <code>[0, 1000]</code>.</li>
	<li><code>n == answers.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= answers[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-229">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/thief-and-warehouses-6ebf4e07/" target="_blank" rel="noopener noreferrer">Thief and Warehouses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">medium</span> <span class="topic-badge">one-dimensional</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <strong><em>N</em></strong> warehouses. The warehouses are located in a straight line and are indexed from <strong>1</strong> to <strong>N</strong>. Each warehouse contains some number of sacks.</p>
<p>A thief decides to rob these warehouses. Thief figured out that he can escape the police if and only if he follows both the following 2 constraints: </p>
<ul>
<li>He will rob only one continuous segment of warehouses.</li>
<li>He will rob same number of sacks from each warehouse.</li>
</ul>
<p>Thief wants to calculate the maximum number of sacks he can steal without getting caught by the police. </p>
<p><strong>Input Format:</strong></p>
<p>The first line contains an integer <strong><em>T</em></strong>  denoting number test cases.</p>
<p>The first line of each test case contains a single integer <strong><em>N</em></strong> denoting number of warehouses.</p>
<p>The second line of each test case contains <em>N</em> space-separated integers :<strong><span class="mathjax-latex">\(a[1],a[2],a[3]...a[n]. a[i]\)</span></strong>  denotes number of sacks in <strong><span class="mathjax-latex">\(i_{th}\)</span></strong> warehouse.   </p>
<p><strong>Constraints:</strong></p>
<ul>
<li><span class="mathjax-latex">\(1 &lt;= T &lt;= 5\)</span></li>
<li><span class="mathjax-latex">\(1 &lt;= N  &lt;= 10^6\)</span></li>
<li><span class="mathjax-latex">\(0 &lt;= A[i] &lt;= 10^{12}\)</span>  </li>
</ul>
<p><strong>Output Format:</strong></p>
<p>Output exactly <strong>T</strong> lines.</p>
<p>The <strong><span class="mathjax-latex">\(i_{th}\)</span></strong>    line should contain a single integer, i.e the answer for <strong><span class="mathjax-latex">\(i_{th}\)</span></strong>   testcase(maximum number of sacks thief can steal without getting caught).</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In first test case thief will steal 2 sacks from each warehouse from 1 to 4.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-230">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/trapping-rain-water/description" target="_blank" rel="noopener noreferrer">Trapping Rain Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" style="width: 412px; height: 161px;" />
<pre>
<strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> height = [4,2,0,3,2,5]
<strong>Output:</strong> 9
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == height.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-231">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1" target="_blank" rel="noopener noreferrer">Trapping Rain Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">two-pointer-algorithm</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[] </strong>with non-negative integers representing the height of blocks. If the width of each block is 1, compute how much water can be trapped between the blocks during the rainy season.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [3, 0, 1, 0, 4, 0 2]
<strong>Output: </strong>10<strong>
Explanation: </strong>Total water trapped = 0 + 3 + 2 + 3 + 0 + 2 + 0 = 10 units.<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701211/Web/Other/blobid0_1741784862.png" alt="" /></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [3, 0, 2, 0, 4]
<strong>Output: </strong>7<strong>
Explanation: </strong>Total water trapped = 0 + 3 + 1 + 3 + 0 = 7 units.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 2, 3, 4]
<strong>Output: </strong>0<strong>
Explanation: </strong>We cannot trap water as there is no height bound on both sides.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [2, 1, 5, 3, 1, 0, 4]
<strong>Output: </strong>9<strong>
Explanation: </strong>Total water trapped = 0 + 1 + 0 + 1 + 3 + 4 + 0 = 9 units.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 <u>&lt;</u> arr.size() <u>&lt;</u> 10<sup>5</sup><br />0 <u>&lt;</u> arr[i] <u>&lt;</u> 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-232">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/implement-two-stacks-in-an-array/1" target="_blank" rel="noopener noreferrer">Two Stacks in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-size: 18px;">Your task is to implement&nbsp;&nbsp;2 stacks in one array efficiently. You need to implement 4 methods.</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="font-size: 18px;">twoStacks :&nbsp;</span></strong><span style="font-size: 18px;">Initialize the data structures and variables to be used to </span><span style="font-size: 18px;">implement&nbsp;&nbsp;2 stacks in one array.</span><br /><strong style="font-size: 18px;">push1 </strong><span style="font-size: 18px;">: pushes element into the first stack.</span><br /><strong style="font-size: 18px;">push2 </strong><span style="font-size: 18px;">: pushes element into the second stack.</span><br /><strong style="font-size: 18px;">pop1 </strong><span style="font-size: 18px;">: pops an element from the first stack and returns the popped element. If the first stack is empty, it should return -1.</span><br /><strong style="font-size: 18px;">pop2 </strong><span style="font-size: 18px;">: pops an element from the second stack and returns the popped element. If the second stack is empty, it should return -1.</span><br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>push1(2)
push1(3)
push2(4)
pop1()
pop2()
pop2()
<strong>Output: </strong>[3, 4, -1]<strong>
Explanation:
</strong>push1(2) the stack1 will be {2}
push1(3) the stack1 will be {2,3}
push2(4) the stack2 will be {4}
pop1() &nbsp; the poped element will be 3 from stack1 and stack1 will be {2}
pop2() &nbsp; the poped element will be 4 from stack2 and now stack2 is empty
pop2()&nbsp;  the stack2 is now empty hence returned -1.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>push1(1)
push2(2)<br /></span><span style="font-size: 18px;">pop1()
push1(3)
pop1()
pop1()
<strong>Output: </strong>[1, 3, -1]<strong>
Explanation:
</strong>push1(1) the stack1 will be {1}
push2(2) the stack2 will be {2}<br />pop1()   the poped element will be 1 from stack1 and stack1 will be empty<br />push1(3) the stack1 will be {3}
pop1() &nbsp; the poped element will be 3 from stack1 and stack1 will be empty<br />pop1()&nbsp;  the stack1 is now empty hence returned -1.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:
</strong>push1(2)
push1(3)
push1(4)
pop2()
pop2()
pop2()
<strong>Output: </strong>[-1, -1, -1]<strong>
Explanation:
</strong>push1(2) the stack1 will be {2}
push1(3) the stack1 will be {2,3}
push1(4) the stack1 will be {2,3,4}
pop2() &nbsp; the stack2 is empty hence returned -1.</span><br /><span style="font-size: 14pt;">pop2() &nbsp; the stack2 is empty hence returned -1.</span><br /><span style="font-size: 14pt;">pop2()&nbsp;  the stack2 is empty hence returned -1.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= number of queries &lt;= 10<sup>4</sup><br />1 &lt;= number of elements in the stack</span><span style="font-size: 18px;"> &lt;= 100</span><br /><span style="font-size: 18px;">The sum of the count of elements in both the stacks &lt; size of the given array</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-233">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/description" target="_blank" rel="noopener noreferrer">Using a Robot to Print the Lexicographically Smallest String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a robot that currently holds an empty string <code>t</code>. Apply one of the following operations until <code>s</code> and <code>t</code> <strong>are both empty</strong>:</p>

<ul>
	<li>Remove the <strong>first</strong> character of a string <code>s</code> and give it to the robot. The robot will append this character to the string <code>t</code>.</li>
	<li>Remove the <strong>last</strong> character of a string <code>t</code> and give it to the robot. The robot will write this character on paper.</li>
</ul>

<p>Return <em>the lexicographically smallest string that can be written on the paper.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;zza&quot;
<strong>Output:</strong> &quot;azz&quot;
<strong>Explanation:</strong> Let p denote the written string.
Initially p=&quot;&quot;, s=&quot;zza&quot;, t=&quot;&quot;.
Perform first operation three times p=&quot;&quot;, s=&quot;&quot;, t=&quot;zza&quot;.
Perform second operation three times p=&quot;azz&quot;, s=&quot;&quot;, t=&quot;&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bac&quot;
<strong>Output:</strong> &quot;abc&quot;
<strong>Explanation:</strong> Let p denote the written string.
Perform first operation twice p=&quot;&quot;, s=&quot;c&quot;, t=&quot;ba&quot;. 
Perform second operation twice p=&quot;ab&quot;, s=&quot;c&quot;, t=&quot;&quot;. 
Perform first operation p=&quot;ab&quot;, s=&quot;&quot;, t=&quot;c&quot;. 
Perform second operation p=&quot;abc&quot;, s=&quot;&quot;, t=&quot;&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bdda&quot;
<strong>Output:</strong> &quot;addb&quot;
<strong>Explanation:</strong> Let p denote the written string.
Initially p=&quot;&quot;, s=&quot;bdda&quot;, t=&quot;&quot;.
Perform first operation four times p=&quot;&quot;, s=&quot;&quot;, t=&quot;bdda&quot;.
Perform second operation four times p=&quot;addb&quot;, s=&quot;&quot;, t=&quot;&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of only English lowercase letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-greedy--stack">Approach: Greedy + Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>We are provided a push sequence of a stack and we need to find the smallest lexicographical pop sequence. Consider the top element <span class="math inline">\(c\)</span> of the stack and the smallest character <span class="math inline">\(\textit{minCharacter}\)</span> remaining in the string <span class="math inline">\(s\)</span>:</p>
<ul>
<li>If <span class="math inline">\(c < \textit{minCharacter}\)</span>, then the top element of the stack must be popped to ensure the smallest possible pop sequence.</li>
<li>If <span class="math inline">\(c > \textit{minCharacter}\)</span>, then the top element should be retained, and we should continue pushing characters until we encounter <span class="math inline">\(\textit{minCharacter}\)</span>, ensuring the minimum lexicographical sequence.</li>
<li>If <span class="math inline">\(c = \textit{minCharacter}\)</span>, then the top element must also be popped to achieve the smallest sequence. This is because we can pop <span class="math inline">\(c\)</span> now, and later push and pop <span class="math inline">\(\textit{minCharacter}\)</span>, resulting in two consecutive minimal characters in the output. Otherwise, if we wait and only pop <span class="math inline">\(\textit{minCharacter}\)</span> later, weâ€™ll end up with just one occurrence, and subsequent characters will be greater than or equal to it.</li>
</ul>
<p>Following this greedy approach, we push characters onto the stack one by one. After each push, we update <span class="math inline">\(\textit{minCharacter}\)</span> to be the smallest character remaining in the string and compare it with the stackâ€™s top. If the condition allows, we pop from the stack; otherwise, we continue the loop. Finally, we return the resulting string.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Rh72Ugq9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span>, and let <span class="math inline">\(|\Sigma|\)</span> denote the size of the character set.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + |\Sigma|)\)</span>.</p>
<p>We first count the frequency of each character in the string, which takes <span class="math inline">\(O(n)\)</span> time. Then, we iterate through the string once, performing constant-time stack operations and updating the minimum character tracker, which involves at most <span class="math inline">\(|\Sigma|\)</span> steps across the entire process. Therefore, the total time complexity is <span class="math inline">\(O(n + |\Sigma|)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We use a hash map to store character frequencies and a stack to simulate the operations. Both the hash map and the stack require at most <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-234">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/validate-stack-sequences/description" target="_blank" rel="noopener noreferrer">Validate Stack Sequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>pushed</code> and <code>popped</code> each with distinct values, return <code>true</code><em> if this could have been the result of a sequence of push and pop operations on an initially empty stack, or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
<strong>Output:</strong> true
<strong>Explanation:</strong> We might do the following sequence:
push(1), push(2), push(3), push(4),
pop() -&gt; 4,
push(5),
pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
<strong>Output:</strong> false
<strong>Explanation:</strong> 1 cannot be popped before 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pushed.length &lt;= 1000</code></li>
	<li><code>0 &lt;= pushed[i] &lt;= 1000</code></li>
	<li>All the elements of <code>pushed</code> are <strong>unique</strong>.</li>
	<li><code>popped.length == pushed.length</code></li>
	<li><code>popped</code> is a permutation of <code>pushed</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-235">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-parentheses/description" target="_blank" rel="noopener noreferrer">Valid Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>

<p>An input string is valid if:</p>

<ol>
	<li>Open brackets must be closed by the same type of brackets.</li>
	<li>Open brackets must be closed in the correct order.</li>
	<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;()&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;()[]{}&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;(]&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;([])&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-236">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-parenthesis-string/description" target="_blank" rel="noopener noreferrer">Valid Parenthesis String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> containing only three types of characters: <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> and <code>&#39;*&#39;</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is <strong>valid</strong></em>.</p>

<p>The following rules define a <strong>valid</strong> string:</p>

<ul>
	<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.</li>
	<li>Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.</li>
	<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.</li>
	<li><code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string <code>&quot;&quot;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "()"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "(*)"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> s = "(*))"
<strong>Output:</strong> true
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s[i]</code> is <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> or <code>&#39;*&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code>, and the task is to check whether the string consisting of only <code>'('</code>, <code>')'</code> and <code>'*'</code> characters forms a valid sequence of parentheses. We consider <code>'*'</code> as a wildcard that can represent either <code>'('</code>, <code>')'</code> or an empty string.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>While traversing the string, the order of parentheses matters. <code>'('</code> must come before <code>')'</code> for a valid sequence.</li>
<li>The number of left parentheses <code>'('</code> and right parentheses <code>')'</code> must be the same, including considering <code>'*'</code>.</li>
<li>Using <code>'*'</code> optimally can help maintain the balance between open and closed parentheses.</li>
</ol>
<blockquote>
<p>Note: The term &quot;opening bracket&quot; refers to the left parenthesis <code>'('</code> and &quot;closing bracket&quot; refers to the right parenthesis <code>')'</code>.</p>
</blockquote>
<hr />
<h3 id="approach-1-top-down-dynamic-programming---memoization">Approach 1: Top-Down Dynamic Programming - Memoization</h3>
<h4 id="intuition">Intuition</h4>
<p>One way to check if a given string of parentheses is valid is to use a stack. Whenever we encounter an opening bracket, we push it onto the stack. Whenever we encounter a closing bracket, we pop an opening bracket from the stack. If the stack is empty at the end of the string, then the string is valid. This is similar to problem <a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a>.</p>
<p>However, the introduction of the wildcard character (<code>'*'</code>) complicates this approach. When dealing with the wildcard character (<code>'*'</code>), each <code>'*'</code> can represent an opening bracket, a closing bracket, or an empty string, leading to multiple branching possibilities.</p>
<p>We can explore all possible combinations in branching scenarios by applying recursive solutions.</p>
<p>We can track whether a string is valid by counting opening brackets:</p>
<ul>
<li>When we encounter an opening bracket, we increment the count of opening brackets by 1.</li>
<li>Conversely, for a closing bracket, we decrement the count by 1.</li>
<li>After processing a valid string, the count of opening brackets is 0, indicating proper closure by corresponding closing brackets.</li>
</ul>
<p>Now, let's adapt our recursive solution based on these insights:</p>
<ul>
<li>The base case occurs when the index reaches the end of the string. At this point, we return true if the count of opening brackets is 0, indicating a valid string, otherwise, we return false.</li>
<li>If the character at <code>s[index]</code> is not <code>'*'</code>, we adjust the count of opening brackets accordingly:
<ul>
<li>If <code>s[index]</code> is <code>'('</code>, we increment the count of opening brackets by 1 and move to <code>index + 1</code>.</li>
<li>If <code>s[index]</code> is <code>')'</code>, we decrement the count of opening brackets by 1 if it is positive, then move to <code>index + 1</code>.</li>
</ul>
</li>
<li>If <code>s[index]</code> is <code>'*'</code>, we explore all possible scenarios:
<ul>
<li>We can add an opening bracket (increment the count of opening brackets by 1) and move to <code>index + 1</code>.</li>
<li>We can add a closing bracket (decrement the count of opening brackets by 1), if the count is positive, then move to <code>index + 1</code>.</li>
<li>We can add an empty string and keep the count of opening brackets the same, then move to <code>index + 1</code>.</li>
</ul>
</li>
</ul>
<p>The recursive approach will result in Time Limit Exceeded (TLE) issues due to the exponential nature of possibilities (<span class="math inline">\(3^{100}\)</span> is a huge number).</p>
<p>To tackle this issue, we'll use dynamic programming (DP) with a two-dimensional table.</p>
<p>The DP table caches the results of subproblems, with rows representing different indices of the string <code>s</code> and columns representing different counts of opening brackets. Each cell stores a boolean value indicating whether the string from the current index with the given count of opening brackets is valid or not.</p>
<p>By caching the calculated states in the dp table, we can avoid recalculating the result for the same combination of index and opening bracket count. When encountering a state that has already been computed and stored in the dp table, instead of recursively exploring further, we can directly retrieve the cached result, significantly reducing the time complexity of the algorithm.</p>
<h4 id="algorithm">Algorithm</h4>
<p><strong><code>checkValidString</code> main function:</strong></p>
<ul>
<li>Initialize a 2D vector <code>memo</code> of size <code>s.size() x s.size() - 1</code>, representing an uninitialized state.</li>
<li>Call the helper function <code>isValidString</code> with initial parameters <code>index = 0</code>, <code>openCount = 0</code>, and the given string <code>s</code>.</li>
<li>Return the result of <code>isValidString</code>.</li>
</ul>
<p><strong><code>isValidString</code> helper function:</strong></p>
<ul>
<li>Base case: If <code>index</code> reaches the end of the string (<code>index == s.size()</code>), return true if <code>openCount</code> is 0 (all brackets are balanced), and false otherwise.</li>
<li>Check if the result for the current <code>index</code> and <code>openCount</code> has already been computed (memoized) in <code>memo</code>. If so, return the memoized result.</li>
<li>Initialize <code>isValid</code> to false.</li>
<li>If the current character <code>s[index]</code> is <code>'*'</code>:
<ul>
<li>Try treating <code>'*'</code> as <code>'('</code>:
<ul>
<li>Call <code>isValidString</code> recursively with <code>index + 1</code> and <code>openCount + 1</code>.</li>
<li>If the recursive call returns true, update <code>isValid</code> to true.</li>
</ul>
</li>
<li>If <code>openCount</code> is non-zero, try treating <code>'*'</code> as <code>')'</code>:
<ul>
<li>Call <code>isValidString</code> recursively with <code>index + 1</code> and <code>openCount - 1</code>.</li>
<li>If the recursive call returns true, update <code>isValid</code> to true.</li>
</ul>
</li>
<li>Try treating <code>'*'</code> as an empty character:
<ul>
<li>Call <code>isValidString</code> recursively with <code>index + 1</code> and the same <code>openCount</code>.</li>
<li>If the recursive call returns true, update <code>isValid</code> to true.</li>
</ul>
</li>
</ul>
</li>
<li>If the current character <code>s[index]</code> is <code>'('</code>:
<ul>
<li>Call <code>isValidString</code> recursively with <code>index + 1</code> and <code>openCount + 1</code>.</li>
<li>Update <code>isValid</code> with the result of the recursive call.</li>
</ul>
</li>
<li>If the current character <code>s[index]</code> is <code>')'</code>:
<ul>
<li>If <code>openCount</code> is non-zero (there are open parentheses):
<ul>
<li>Call <code>isValidString</code> recursively with <code>index + 1</code> and <code>openCount - 1</code>.</li>
<li>Update <code>isValid</code> with the result of the recursive call.</li>
</ul>
</li>
</ul>
</li>
<li>Memoize the result of <code>isValid</code> in <code>memo[index][openCount]</code>.</li>
<li>Return <code>isValid</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/76A7zEs3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>The time complexity of the <code>isValidString</code> function can be analyzed by considering the number of unique subproblems that need to be solved. Since there are at most <span class="math inline">\(n \cdot n\)</span> unique subproblems (indexed by <code>index</code> and <code>openCount</code>), where <code>n</code> is the length of the input string, and each subproblem is computed only once (due to memoization), the time complexity is bounded by the number of unique subproblems. Therefore, the time complexity can be stated as <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>The space complexity of the algorithm is primarily determined by two factors: the auxiliary space used for memoization and the recursion stack space. The memoization table, denoted as <code>memo</code>, consumes <span class="math inline">\(O(n \cdot n)\)</span> space due to its size being proportional to the square of the length of the input string. Additionally, the recursion stack space can grow up to <span class="math inline">\(O(n)\)</span> in the worst case, constrained by the length of the input string, as each recursive call may add a frame to the stack. Therefore, the overall space complexity is the sum of these two components, resulting in <span class="math inline">\(O(n \cdot n) + O(n)\)</span>, which simplifies to <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bottom-up-dynamic-programming---tabulation">Approach 2: Bottom-Up Dynamic Programming - Tabulation</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Tabulation is a dynamic programming technique that involves systematically iterating through all possible combinations of changing parameters. Since tabulation operates iteratively, rather than recursively, it does not require overhead for the recursive stack space, making it more efficient than memoization. We have two variables that change as we progress through the string: the current index we're considering and the count of open brackets encountered so far. To thoroughly explore the combinations, we use two nested loops to iterate through these variables.</p>
<p>First, let's establish the base case:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>index <span style="color:#000;font-weight:bold">==</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">(</span>openingBracket <span style="color:#000;font-weight:bold">==</span> 0<span style="color:#000;font-weight:bold">);</span>
</span></span></code></pre><p>We represent this base case in our tabulation matrix as <code>dp[s.size()][0] = true</code>, indicating that a string with no brackets is valid.</p>
<p>Our ultimate goal is to determine whether a valid parenthesis sequence can be achieved, and this information will be stored in <code>dp[0][0]</code>. To accomplish this, we traverse through every combination of index and open bracket count using the two nested loops. The outer loop iterates over the index, while the inner loop iterates over the count of open brackets (<code>openBracket</code>).</p>
<p>Throughout this traversal, we evaluate each state and update our tabulation matrix accordingly. Upon completing the traversal of the entire string, if <code>dp[0][0]</code> evaluates to true, it signifies that there exists a valid parenthesis sequence.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 2D boolean vector <code>dp</code> of size <code>(n + 1) x (n + 1)</code>, where <code>n</code> is the length of the input string <code>s</code>. The <code>dp[index][openBracket]</code> represents whether the substring starting from index <code>i</code> is valid with <code>j</code> opening brackets.</li>
<li>Set the base case <code>dp[n][0]</code> as true, as an empty string with no opening brackets is always valid.</li>
<li>Iterate through the string from the end to the beginning (reverse order) using a nested loop:
<ul>
<li>Outer loop: Iterate over the indices of the string from <code>n - 1</code> to <code>0</code>.</li>
<li>Inner loop: Iterate over the number of opening brackets from <code>0</code> to <code>n</code>.</li>
<li>For each character at index <code>index</code> and the current number of opening brackets <code>openBracket</code>, determine if the substring starting from <code>index</code> is valid with <code>openBracket</code> opening brackets:
<ul>
<li>If the character is <code>'*'</code>:
<ul>
<li>Try treating <code>'*'</code> as <code>'('</code>: Check if the substring starting from <code>index + 1</code> is valid with <code>openBracket + 1</code> opening brackets (<code>dp[index + 1][openBracket + 1]</code>).</li>
<li>Try treating <code>'*'</code> as <code>')'</code>: If <code>openBracket &gt; 0</code>, check if the substring starting from <code>index + 1</code> is valid with <code>openBracket - 1</code> opening brackets (<code>dp[index + 1][openBracket - 1]</code>).</li>
<li>Try ignoring <code>'*'</code>: Check if the substring starting from <code>index + 1</code> is valid with the same number of opening brackets (<code>dp[index + 1][openBracket]</code>).</li>
</ul>
</li>
<li>If the character is <code>'('</code>:
<ul>
<li>Try treating <code>'('</code> as an opening bracket: Check if the substring starting from <code>index + 1</code> is valid with <code>openBracket + 1</code> opening brackets (<code>dp[index + 1][openBracket + 1]</code>).</li>
</ul>
</li>
<li>If the character is <code>')'</code>:
<ul>
<li>Try treating <code>')'</code> as a closing bracket: If <code>openBracket &gt; 0</code>, check if the substring starting from <code>index + 1</code> is valid with <code>openBracket - 1</code> opening brackets (<code>dp[index + 1][openBracket - 1]</code>).</li>
</ul>
</li>
<li>Update the <code>dp[index][openBracket]</code> value based on the result of the above checks.</li>
</ul>
</li>
</ul>
</li>
<li>After completing the nested loops, the <code>dp[0][0]</code> value represents whether the entire input string is valid with no excess opening brackets.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/652HyVYi/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>This is due to the nested loop structure, where the outer loop iterates over each character of the string, and the inner loop iterates over all possible counts of opening brackets.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>This is primarily due to the 2D array dp, which has dimensions <span class="math inline">\((n + 1) \cdot (n + 1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-two-stacks">Approach 3: Using Two Stacks</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In Approach 1, we discussed how stacks can be used to solve brackets matching problems, but the wildcard <code>'*'</code> complicates this problem. We can tweak the stack method by creating two stacks: one for open brackets and another for the wildcard <code>'*'</code>.</p>
<p>This way, we maintain two stacks to process the string. The first stack keeps track of the indices of encountered open brackets, while the second stack is dedicated to storing the indices of asterisks.</p>
<p>As we traverse through the input string, every time we encounter an open bracket or an asterisk, we record its index by pushing it onto the respective stack.</p>
<p>When we encounter a right bracket, we first attempt to balance this right bracket with an open bracket. To do so, we peek into our open bracket stack. If it's not empty, indicating that there's a matching open bracket available, we pop the index from this stack and proceed.</p>
<p>However, if the open bracket stack is empty, we resort to using an asterisk. In this scenario, we peek into our asterisk stack and check if it contains any available asterisks. If so, we pop the index from this stack and proceed. This dynamic selection process ensures that we exhaust all possible options for balancing the right bracket.</p>
<p>If both the open bracket and asterisk stacks are empty, we return false, as this indicates an unmatched right bracket.</p>
<p>Once we've processed the whole string, our attention shifts to the remaining elements in the open bracket and asterisk stacks. Here, we check their positions relative to each other. We recognize that if an open bracket appears after the last encountered asterisk, there's no viable way to balance it because we have no available right brackets. Therefore, we return false. However, if no such mismatch is detected, we proceed to empty both stacks.</p>
<p>Here we used a greedy strategy, prioritizing the use of open brackets over asterisks whenever possible to balance the right brackets. This ensures that we exhaust all available options for balancing before resorting to using asterisks.</p>
<p>The following is an illustration demonstrating the stack solution:</p>
<p>!?!../Documents/678/stack_solution.json:961,446!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize two stacks: <code>openBrackets</code> to store indices of open brackets <code>'('</code>, and <code>asterisks</code> to store indices of asterisks <code>'*'</code>.</li>
<li>Iterate through the string <code>s</code> character by character:
<ul>
<li>If the current character is <code>'('</code>, push its index onto the <code>openBrackets</code> stack.</li>
<li>If the current character is <code>'*'</code>, push its index onto the <code>asterisks</code> stack.</li>
<li>If the current character is <code>')'</code>:
<ul>
<li>If <code>openBrackets</code> is not empty, pop an element from it (removing the matching open bracket).</li>
<li>If <code>asterisks</code> is not empty, pop an element from <code>asterisks</code> (using an asterisk to balance the closing bracket).</li>
<li>If neither an open bracket nor an asterisk is available, return false.</li>
</ul>
</li>
</ul>
</li>
<li>After iterating through the entire string, check if any remaining open brackets and asterisks can balance each other:
<ul>
<li>While both <code>openBrackets</code> and <code>asterisks</code> are not empty:
<ul>
<li>If the top element of <code>openBrackets</code> (representing an open bracket index) is greater than the top element of <code>asterisks</code> (representing an asterisk index), it means the open bracket appears after the asterisk, which cannot be balanced, so return false.</li>
<li>Otherwise, pop elements from both <code>openBrackets</code> and <code>asterisks</code> stacks (matching an open bracket with an asterisk).</li>
</ul>
</li>
</ul>
</li>
<li>If after the above step, <code>openBrackets</code> is empty, it means all open brackets have been matched or balanced, so return true. Otherwise, return false (unmatched open brackets are remaining).</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/FMuDohBp/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the entire string once, taking <span class="math inline">\(O(n)\)</span> time. Additionally, in the worst case, it may need to traverse both the <code>openBrackets</code> and <code>asterisks</code> stacks simultaneously to check for balanced parentheses, which also takes <span class="math inline">\(O(n)\)</span> time. Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses two stacks, <code>openBrackets</code>, and <code>asterisks</code>, which could potentially hold up to <span class="math inline">\(O(n)\)</span> elements combined in the worst case. Additionally, there are a few extra variables and loop counters, which require constant space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-two-pointer">Approach 4: Two Pointer</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The above approaches all use significant extra space to solve the problem. Let's develop an approach that uses constant space.</p>
<p>We can use a two-pointer greedy approach, which checks the balance between open and closed brackets from both ends of the array simultaneously, ensuring that no surplus or deficit of brackets occurs at any point during the iteration.</p>
<p>We initiate two pointers, one starting from the left and the other from the right of the array.</p>
<p>Starting from the left, we iterate through the array, counting the occurrences of open brackets <code>'('</code> and asterisks <code>'*'</code>. Whenever we encounter a closed bracket <code>')'</code>, we decrement the count of open brackets. This decrement operation mimics the process of matching an open bracket with a closed one.</p>
<p>Simultaneously, we traverse from the right of the array, counting the occurrences of closed brackets <code>')'</code> and asterisks <code>'*'</code>. Whenever we encounter an open bracket <code>'('</code>, we decrement the count of closed brackets. This simulates the process of matching a closed bracket with an open one.</p>
<p>Throughout this process, if either the count of open brackets or the count of closed brackets falls below zero (i.e., becomes negative), we immediately conclude that the sequence is invalid, as it indicates a surplus of closed brackets without corresponding open ones, or vice versa.</p>
<p>If neither of the counters becomes negative throughout the iteration, the sequence is valid, and we return true.</p>
<p>The following is an illustration demonstrating the two pointer solution:</p>
<p>!?!../Documents/678/twopointer.json:960,352!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize two variables, <code>openCount</code> and <code>closeCount</code>, to keep track of the number of open and close parentheses (or asterisks) encountered so far.</li>
<li>Calculate the length of the input string <code>s</code> and store it in the variable <code>length</code>.</li>
<li>Traverse the string from both ends simultaneously using a single loop:
<ul>
<li>Iterate over the indices <code>i</code> from 0 to <code>length</code> (inclusive).</li>
<li>For each index <code>i</code>:
<ul>
<li>If the character at index <code>i</code> is <code>'('</code> or <code>'*'</code>, increment <code>openCount</code>.</li>
<li>Otherwise, decrement <code>openCount</code>.</li>
<li>If the character at index <code>length - i</code> is <code>')'</code> or <code>'*'</code>, increment <code>closeCount</code>.</li>
<li>Otherwise, decrement <code>closeCount</code>.</li>
</ul>
</li>
<li>If at any point during the loop, either <code>openCount</code> or <code>closeCount</code> becomes negative, it means there are more closing parentheses than open parentheses (or asterisks), which makes the string invalid. In this case, return false.</li>
</ul>
</li>
<li>After the loop finishes traversing the entire string without returning, <code>openCount</code> and <code>closeCount</code> are non-negative, which means that the string is valid, so return true.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/UGc495d9/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The time complexity is <span class="math inline">\(O(n)\)</span>, as we iterate through the string once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(1)\)</span>, as we use a constant amount of extra space to store the <code>openCount</code> and <code>closeCount</code> variables.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-237">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/valid-substring0624/1" target="_blank" rel="noopener noreferrer">Valid Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">strings</span> <span class="topic-badge">two-pointer-algorithm</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a string <code>s</code> consisting only of opening and closing parentheses <code>(</code> and <code>)</code>, find the length of the longest valid (well-formed) parentheses substring.</span></p>
<p><span style="font-size: 14pt;"><strong>Note: </strong>The length of the smallest valid substring <code>()</code> is 2.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "(()("
<strong>Output:</strong> 2
<strong>Explanation: </strong>The longest valid substring is <code>()</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. Its length is 2.</span> </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "()(())("
<strong>Output:</strong> 6
<strong>Explanation: </strong>The longest valid substring is <code>()(())</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. Its length is 6.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "(()())"
<strong>Output:</strong> 6
<strong>Explanation: </strong>The longest valid substring is <code>(()())</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. Its length is 6.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= s.size() &lt;= 10<sup>5</sup><br />s[i] = { '(' , ')' }</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-238">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Verify Preorder Serialization of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-tree</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>One way to serialize a binary tree is to use <strong>preorder traversal</strong>. When we encounter a non-null node, we record the node&#39;s value. If it is a null node, we record using a sentinel value such as <code>&#39;#&#39;</code>.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg" style="width: 362px; height: 293px;" />
<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>&#39;#&#39;</code> represents a null node.</p>

<p>Given a string of comma-separated values <code>preorder</code>, return <code>true</code> if it is a correct preorder traversal serialization of a binary tree.</p>

<p>It is <strong>guaranteed</strong> that each comma-separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing null pointer.</p>

<p>You may assume that the input format is always valid.</p>

<ul>
	<li>For example, it could never contain two consecutive commas, such as <code>&quot;1,,3&quot;</code>.</li>
</ul>

<p><strong>Note:&nbsp;</strong>You are not allowed to reconstruct the tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> preorder = "1,#"
<strong>Output:</strong> false
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> preorder = "9,#,#,1"
<strong>Output:</strong> false
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>
	<li><code>preorder</code> consist of integers in the range <code>[0, 100]</code> and <code>&#39;#&#39;</code> separated by commas <code>&#39;,&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-239">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zuma-game/description" target="_blank" rel="noopener noreferrer">Zuma Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are playing a variation of the game Zuma.</p>

<p>In this variation of Zuma, there is a <strong>single row</strong> of colored balls on a board, where each ball can be colored red <code>&#39;R&#39;</code>, yellow <code>&#39;Y&#39;</code>, blue <code>&#39;B&#39;</code>, green <code>&#39;G&#39;</code>, or white <code>&#39;W&#39;</code>. You also have several colored balls in your hand.</p>

<p>Your goal is to <strong>clear all</strong> of the balls from the board. On each turn:</p>

<ul>
	<li>Pick <strong>any</strong> ball from your hand and insert it in between two balls in the row or on either end of the row.</li>
	<li>If there is a group of <strong>three or more consecutive balls</strong> of the <strong>same color</strong>, remove the group of balls from the board.
	<ul>
		<li>If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.</li>
	</ul>
	</li>
	<li>If there are no more balls on the board, then you win the game.</li>
	<li>Repeat this process until you either win or do not have any more balls in your hand.</li>
</ul>

<p>Given a string <code>board</code>, representing the row of balls on the board, and a string <code>hand</code>, representing the balls in your hand, return <em>the <strong>minimum</strong> number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;WRRBBW&quot;, hand = &quot;RB&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to clear all the balls. The best you can do is:
- Insert &#39;R&#39; so the board becomes WRR<u>R</u>BBW. W<u>RRR</u>BBW -&gt; WBBW.
- Insert &#39;B&#39; so the board becomes WBB<u>B</u>W. W<u>BBB</u>W -&gt; WW.
There are still balls remaining on the board, and you are out of balls to insert.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;WWRRBBWW&quot;, hand = &quot;WRBRW&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> To make the board empty:
- Insert &#39;R&#39; so the board becomes WWRR<u>R</u>BBWW. WW<u>RRR</u>BBWW -&gt; WWBBWW.
- Insert &#39;B&#39; so the board becomes WWBB<u>B</u>WW. WW<u>BBB</u>WW -&gt; <u>WWWW</u> -&gt; empty.
2 balls from your hand were needed to clear the board.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;G&quot;, hand = &quot;GGGGG&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> To make the board empty:
- Insert &#39;G&#39; so the board becomes G<u>G</u>.
- Insert &#39;G&#39; so the board becomes GG<u>G</u>. <u>GGG</u> -&gt; empty.
2 balls from your hand were needed to clear the board.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= board.length &lt;= 16</code></li>
	<li><code>1 &lt;= hand.length &lt;= 5</code></li>
	<li><code>board</code> and <code>hand</code> consist of the characters <code>&#39;R&#39;</code>, <code>&#39;Y&#39;</code>, <code>&#39;B&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;W&#39;</code>.</li>
	<li>The initial row of balls on the board will <strong>not</strong> have any groups of three or more consecutive balls of the same color.</li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>
