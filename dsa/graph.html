<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>graph - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>graph</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">258</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Account Merge</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-1" class="toc-link">Add Edges to Make Degrees of All Nodes Even</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Alex Travelling</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-3" class="toc-link">Alien Dictionary</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-4" class="toc-link">All Ancestors of a Node in a Directed Acyclic Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">All Paths From Source to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Articulation Point - I</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-7" class="toc-link">Articulation Point - II</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-8" class="toc-link">Assignment Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-9" class="toc-link">Avoid Explosion</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-10" class="toc-link">Bellman-Ford</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-11" class="toc-link">BFS of graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-12" class="toc-link">Biconnected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-13" class="toc-link">Bipartite Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-14" class="toc-link">Bridge edge in a graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-15" class="toc-link">Build a Matrix With Conditions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Cat and Mouse</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Cat and Mouse II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Cheapest Flights Within K Stops</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-19" class="toc-link">Cheapest Flights Within K Stops</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Checking Existence of Edge Length Limited Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Chinese Postman</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-22" class="toc-link">Circle of strings</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-23" class="toc-link">City With the Smallest Number of Neighbors at a Threshold Distance</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-24" class="toc-link">Clone an Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-25" class="toc-link">Clone Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Collect Coins in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Connected Components in an Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-28" class="toc-link">Connecting the graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-29" class="toc-link">Connecting the special nodes</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-30" class="toc-link">Construct 2D Grid Matching Graph Layout</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Construct binary palindrome by repeated appending and trimming</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-32" class="toc-link">Count Lucky Permutations</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-33" class="toc-link">Count Pairs Of Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Count the Number of Complete Components</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Count the Number of Houses at a Certain Distance I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Count the Number of Houses at a Certain Distance II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Count the paths</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-38" class="toc-link">Count Unreachable Pairs of Nodes in an Undirected Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Count Visited Nodes in a Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Count Ways to Build Rooms in an Ant Colony</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Couples Holding Hands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Course Schedule</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-43" class="toc-link">Course Schedule</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Course Schedule II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Course Schedule IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Covid Spread</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-47" class="toc-link">Cracking the Safe</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Critical Connections in a Network</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Design Graph With Shortest Path Calculator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Detect Cycle using DSU</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-51" class="toc-link">Detonate the Maximum Bombs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">DFS of Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-53" class="toc-link">Digit Operations to Make Two Integers Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Dijkstra Algorithm</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-55" class="toc-link">Directed Graph Cycle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-56" class="toc-link">Distance of nearest cell having 1</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-57" class="toc-link">Divide Nodes Into the Maximum Number of Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Divisibility tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-59" class="toc-link">Euler circuit and Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-60" class="toc-link">Euler Circuit in an Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-61" class="toc-link">Eulerian Path in an Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-62" class="toc-link">Evaluate Division</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Eventual Safe States</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-64" class="toc-link">Fill the Tank</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-65" class="toc-link">Find all Critical Connections in the Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-66" class="toc-link">Find All People With Secret</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Find All Possible Recipes from Given Supplies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Find a Safe Walk Through a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Find Center of Star Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Find Champion II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Find Closest Node to Given Two Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Find Edges in Shortest Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Find Eventual Safe States</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Find if Path Exists in Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Find Minimum Diameter After Merging Two Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Find minimum s-t cut in a flow network</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-78" class="toc-link">Find Minimum Time to Reach Last Room I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Find Minimum Time to Reach Last Room II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Find number of closed islands</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-81" class="toc-link">Find shortest safe route in a matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-82" class="toc-link">Find the City With the Smallest Number of Neighbors at a Threshold Distance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Find the Maximum Flow</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-84" class="toc-link">Find the number of islands</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-85" class="toc-link">Find the String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-86" class="toc-link">Find the Town Judge</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Find whether path exist</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-88" class="toc-link">Flood fill Algorithm</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-89" class="toc-link">Flower Planting With No Adjacent</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Floyd Warshall</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-91" class="toc-link">Frequencies of Shortest Supersequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">Frog Position After T Seconds</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Geek in a Maze</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-94" class="toc-link">Get Watched Videos by Your Friends</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Good Stones</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-96" class="toc-link">Graph is Tree or Not</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-97" class="toc-link">Hamiltonian Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-98" class="toc-link">Holiday decorations</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-99" class="toc-link">Is Graph Bipartite?</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-100" class="toc-link">Keys and Rooms</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Kill Captain America</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-102" class="toc-link">Knight Walk</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-103" class="toc-link">Largest Color Value in a Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Largest Sum Cycle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-105" class="toc-link">Level of Nodes</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-106" class="toc-link">Lexicographical Smallest String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-107" class="toc-link">Longest Cycle in a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Longest Increasing Path in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Longest Palindromic Path in Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Longest Path With Different Adjacent Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Loud and Rich</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Maximal Network Rank</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Maximize Amount After Two Days of Conversions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Maximize Spanning Tree Stability with Upgrades</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Maximum Bipartite Matching</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-116" class="toc-link">Maximum Candies You Can Get from Boxes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Maximum Connected group</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-118" class="toc-link">Maximum Employees to Be Invited to a Meeting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Maximum Path Quality of a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">Maximum Profit from Valid Topological Order in DAG</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Maximum Score of a Node Sequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-122" class="toc-link">Maximum Star Sum of a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Maximum Sum of Edge Values in a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Maximum Total Importance of Roads</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Maximum Weighted K-Edge Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Maximum Weight Node</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-127" class="toc-link">Min Cost to Connect All Points</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Minimize Malware Spread</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-129" class="toc-link">Minimize Malware Spread II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Minimize Maximum Component Cost</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Minimize the Maximum Edge Weight of Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Minimize the Total Price of the Trips</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Minimum Cost of a Path With Special Roads</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Minimum Cost Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-135" class="toc-link">Minimum Cost to Convert String I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Minimum Cost to Convert String II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">Minimum Cost to Make at Least One Valid Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-138" class="toc-link">Minimum Cost to Reach Destination in Time</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-139" class="toc-link">Minimum Cost Walk in Weighted Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-140" class="toc-link">Minimum Degree of a Connected Trio in a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-141" class="toc-link">Minimum Edge Reversals So Every Node Is Reachable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-142" class="toc-link">Minimum Edge Weight Equilibrium Queries in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-143" class="toc-link">Minimum Fuel Cost to Report to the Capital</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-144" class="toc-link">Minimum Height Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-145" class="toc-link">Minimum Multiplications to reach End</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-146" class="toc-link">Minimum Number of Vertices to Reach All Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-147" class="toc-link">Minimum Obstacle Removal to Reach Corner</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Minimum Score of a Path Between Two Cities</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-149" class="toc-link">Minimum Spanning Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-150" class="toc-link">Minimum Spanning Tree - Kruskal&#39;s Algorithm</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-151" class="toc-link">Minimum Swaps to Sort</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-152" class="toc-link">Minimum Time for K Connected Components</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-153" class="toc-link">Minimum Time to Reach Destination in Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-154" class="toc-link">Minimum Time to Transport All Individuals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-155" class="toc-link">Minimum Time to Visit a Cell In a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-156" class="toc-link">Minimum Time to Visit Disappearing Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-157" class="toc-link">Minimum Weighted Subgraph With the Required Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-158" class="toc-link">Modify Graph Edge Weights</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-159" class="toc-link">Most Profitable Path in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-160" class="toc-link">Most Stones Removed with Same Row or Column</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-161" class="toc-link">Mother Vertex</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-162" class="toc-link">Neeman&#39;s Shoes</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-163" class="toc-link">Negative weight cycle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-164" class="toc-link">Network Delay Time</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-165" class="toc-link">Network Recovery Pathways</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-166" class="toc-link">Nodes at even distance</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-167" class="toc-link">Node With Highest Edge Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-168" class="toc-link">Number of Distinct Islands</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-169" class="toc-link">Number Of Enclaves</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-170" class="toc-link">Number of Good Components</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-171" class="toc-link">Number of Good Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-172" class="toc-link">Number of Increasing Paths in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-173" class="toc-link">Number of Operations to Make Network Connected</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-174" class="toc-link">Number of pairs</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-175" class="toc-link">Number of Possible Sets of Closing Branches</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-176" class="toc-link">Number of Provinces</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-177" class="toc-link">Number of Provinces</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-178" class="toc-link">Number of Restricted Paths From First to Last Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-179" class="toc-link">Number of Ways to Arrive at Destination</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-180" class="toc-link">Number of Ways to Arrive at Destination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-181" class="toc-link">Number Of Ways To Reconstruct A Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-182" class="toc-link">Open the gates</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-183" class="toc-link">Pacific Atlantic Water Flow</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-184" class="toc-link">Parallel Courses II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-185" class="toc-link">Parallel Courses III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-186" class="toc-link">Path Existence Queries in a Graph I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-187" class="toc-link">Path Existence Queries in a Graph II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-188" class="toc-link">Path with Maximum Probability</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-189" class="toc-link">Path With Minimum Effort</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-190" class="toc-link">Possible Bipartition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-191" class="toc-link">Possible paths</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-192" class="toc-link">Possible paths between 2 vertices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-193" class="toc-link">Power Grid Maintenance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-194" class="toc-link">Prerequisite Tasks</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-195" class="toc-link">Print adjacency list</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-196" class="toc-link">Printing patterns</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-197" class="toc-link">Prison Break</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-198" class="toc-link">Process Restricted Friend Requests</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-199" class="toc-link">Project Manager</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-200" class="toc-link">Properties Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-201" class="toc-link">Rank Transform of a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-202" class="toc-link">Reachable Nodes In Subdivided Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-203" class="toc-link">Reachable Nodes With Restrictions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-204" class="toc-link">Reconstruct Itinerary</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-205" class="toc-link">Reduce the Array</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-206" class="toc-link">Redundant Connection</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-207" class="toc-link">Redundant Connection II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-208" class="toc-link">Remove Max Number of Edges to Keep Graph Fully Traversable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-209" class="toc-link">Remove Methods From Project</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-210" class="toc-link">Reorder Routes to Make All Paths Lead to the City Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-211" class="toc-link">Replace O&#39;s with X&#39;s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-212" class="toc-link">Reverse Delete Algorithm for Minimum Spanning Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-213" class="toc-link">Rotten Oranges</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-214" class="toc-link">Santa Banta</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-215" class="toc-link">Satisfiability of Equality Equations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-216" class="toc-link">Second Minimum Time to Reach Destination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-217" class="toc-link">Shortest Cycle in a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-218" class="toc-link">Shortest Distance After Road Addition Queries I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-219" class="toc-link">Shortest Distance After Road Addition Queries II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-220" class="toc-link">Shortest Distance in a Binary Maze</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-221" class="toc-link">Shortest path from 1 to n</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-222" class="toc-link">Shortest path in Directed Acyclic Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-223" class="toc-link">Shortest Path in Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-224" class="toc-link">Shortest Path in Weighted undirected graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-225" class="toc-link">Shortest Path Using Atmost One Curved Edge</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-226" class="toc-link">Shortest Path Visiting All Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-227" class="toc-link">Shortest Path with Alternating Colors</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-228" class="toc-link">Shortest Source to Destination Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-229" class="toc-link">Snake and Ladder Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-230" class="toc-link">Sort Items by Groups Respecting Dependencies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-231" class="toc-link">Spidey Sense</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-232" class="toc-link">Steps by Knight</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-233" class="toc-link">Strange Printer II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-234" class="toc-link">Strongly connected component (Tarjans&#39;s Algo)</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-235" class="toc-link">Sum of dependencies in a graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-236" class="toc-link">Sum of Distances in Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-237" class="toc-link">The Time When the Network Becomes Idle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-238" class="toc-link">Time Taken to Mark All Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-239" class="toc-link">Topological sort</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-240" class="toc-link">Transitive closure of a Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-241" class="toc-link">Travel diaries</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-242" class="toc-link">Traverse All Edges And Vertices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-243" class="toc-link">Tree Trips</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-244" class="toc-link">Undirected Graph Cycle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-245" class="toc-link">Union-Find</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-246" class="toc-link">Unit Area of largest region of 1&#39;s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-247" class="toc-link">Unit Conversion I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-248" class="toc-link">Valid Arrangement of Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-249" class="toc-link">Validate Binary Tree Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-250" class="toc-link">Villain Con</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-251" class="toc-link">Water Connection Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-252" class="toc-link">Word Boggle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-253" class="toc-link">Word Ladder I</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-254" class="toc-link">Word Ladder II</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-255" class="toc-link">Word Search</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-256" class="toc-link">X Total Shapes</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-257" class="toc-link">Your Social Network</a> <span class="toc-platform">GeeksForGeeks</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/account-merge/1" target="_blank" rel="noopener noreferrer">Account Merge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">hash</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a list&nbsp;of <strong>accounts</strong> of size <strong>n</strong> where each element <strong>accounts [ i ] </strong>is a list&nbsp;of strings, where the first element <strong>account [ i ][ 0 ]&nbsp;</strong> is a<strong> name</strong>, and the rest of the elements are<strong> emails</strong> representing emails of the account.<br />Geek wants you to merge these accounts. Two accounts belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts have the same name.<br />After merging the accounts, return the accounts in the following format: The first element of each account is the name, and the rest of the elements are emails <strong>in</strong> <strong>sorted order</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note</strong>: Accounts themselves can be returned in <strong>any order</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 4<br />accounts [ ] =<br />[["John","johnsmith@mail.com","john_newyork@mail.com"],<br />["John","johnsmith@mail.com","john00@mail.com"],<br />["Mary","mary@mail.com"],<br />["John","johnnybravo@mail.com"]]<br /><strong>Output:</strong><br />[["John","john00@mail.com","john_newyork@mail.com", "johnsmith@mail.com"],<br />["Mary","mary@mail.com"],<br />["John","johnnybravo@mail.com"]]<br /><strong>Explanation:</strong><br />The first and second John's are the same person as they have the common email "johnsmith@mail.com". The third John and Mary are different people as none of their email addresses are used by other accounts.We could return these arrays in any order, for example, the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 5<br />accounts [ ] =<br />[["Gabe","Gabe00@m.co","Gabe3@m.co","Gabe1@m.co"],<br />["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],<br />["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],<br />["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],<br />["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]<br /><strong>Output:</strong><br />[["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],<br />["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],<br />["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],<br />["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],<br />["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]<br /><strong>Explanation:</strong><br />We don't have any common emails in any of the users. We just sorted the emails of each person and we return a array of emails.(The details can be returned in any order).</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>accountsMerge</strong><strong>()&nbsp;</strong>which takes a list of lists of strings representing <strong>accounts[][]</strong> as a parameter and returns a list of lists of strings denoting the details after merging.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n*m*logn) - where n is the size of accounts and m is the size of the number of strings for a name.<br /><strong>Expected Auxiliary Space:</strong> O(n*m) - where n is the size of accounts and m is the size of the number of strings for a name.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1 &lt;= n &lt;= 1000<br /></span><span style="font-size: 18px;">2 &lt;= accounts[ i ].size&nbsp;&lt;= 10<br /></span><span style="font-size: 18px;">1 &lt;= accounts[ i ][ j ].size &lt;= 30<br /></span><span style="font-size: 18px;">accounts[i][0] consists of English letters.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/add-edges-to-make-degrees-of-all-nodes-even/description" target="_blank" rel="noopener noreferrer">Add Edges to Make Degrees of All Nodes Even</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <strong>undirected</strong> graph consisting of <code>n</code> nodes numbered from <code>1</code> to <code>n</code>. You are given the integer <code>n</code> and a <strong>2D</strong> array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. The graph can be disconnected.</p>

<p>You can add <strong>at most</strong> two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.</p>

<p>Return <code>true</code><em> if it is possible to make the degree of each node in the graph even, otherwise return </em><code>false</code><em>.</em></p>

<p>The degree of a node is the number of edges connected to it.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/26/agraphdrawio.png" style="width: 500px; height: 190px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram shows a valid way of adding an edge.
Every node in the resulting graph is connected to an even number of edges.
</pre>

<p><strong>Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/26/aagraphdrawio.png" style="width: 400px; height: 120px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[3,4]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram shows a valid way of adding two edges.</pre>

<p><strong>Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/26/aaagraphdrawio.png" style="width: 150px; height: 158px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[1,3],[1,4]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to obtain a valid graph with adding at most 2 edges.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/alex-travelling/1" target="_blank" rel="noopener noreferrer">Alex Travelling</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Alex is very fond of traveling. There are&nbsp;<strong>n </strong>cities, labeled from<strong> 1</strong> to<strong> n</strong>.&nbsp;&nbsp;You are also given flights, a list of travel flights as <strong>directed weighted</strong> edges<strong> flights[i] = (u<sub>i</sub>,v<sub>i</sub>,w<sub>i</sub>)</strong>&nbsp;where<strong> u<sub>i&nbsp;</sub></strong>is the source node,<strong> v<sub>i</sub>&nbsp;</strong>is the target node, and <strong>w<sub>i</sub></strong>&nbsp;is the price it takes for a person to travel from source to target.<br />Currently, Alex is in <strong>k</strong>'th city and wants to visit one city of his choice. Return&nbsp;the<strong>&nbsp;minimum&nbsp;</strong>money&nbsp;Alex should have so&nbsp;that he can visit any city of his choice from <strong>k</strong>'th&nbsp;city. If there is a city that has no path from&nbsp;<strong>k</strong>'th city, which means Alex can't visit that city,&nbsp;return <strong>-1</strong>.&nbsp;<br />Alex always takes the optimal path. He can any city via another city by taking multiple flights.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
n: 4
k: 2
flights size: 3
flights: [[2,1,1],[2,3,1],[3,4,1]]
<strong>Output:</strong>
2
<strong>Explanation:</strong>
to visit 1 from 2 takes cost 1
to visit 2 from 2 takes cost 0
to visit 3 from 2 takes cost 1
to visit 4 from 2 takes cost 2,
2-&gt;3-&gt;4
So if Alex wants to visit city 4
from 2, he needs 2 units of money
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711152/Web/Other/blobid0_1750669077.webp" width="245" height="275" /> &nbsp;</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
n: 4 
k: 3 
flights size: 3 
flights: [[2,1,1],[2,3,1],[3,4,1]] 
<strong>Output:</strong> -1
<strong>Explanation:</strong>
There is no direct or indirect path 
to visit city 2 and 1 from city 3
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711152/Web/Other/blobid1_1750669108.webp" width="200" height="224" /> &nbsp;</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">You don't need to print or input anything. Complete the function <strong>minimumCost()&nbsp;</strong>which takes a&nbsp; flights array, an integer n and an integer k<strong>&nbsp;</strong>as the input parameters and returns an integer, denoting&nbsp;the<strong> minimum&nbsp;</strong>money Alex should have so&nbsp;that he can visit any city of his choice from k'th city.<br /><br /><strong>Expected Time Complexity:</strong> O((V+E) log V), here V is number of cities and E is number of flights.&nbsp;<br /><strong>Expected Auxiliary Space</strong>: O(V+E), here V is number of cities and E is number of flights.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">2 &lt;= n &lt;= 500</span></li>
<li><span style="font-size: 18px;">1 &lt;= flights.length&nbsp;&lt;= 100000</span></li>
<li><span style="font-size: 18px;">flights[i].length == 3</span></li>
<li><span style="font-size: 18px;">1 &lt;= u<sub>i</sub>, v<sub>i</sub>, k&lt;= n</span></li>
<li><span style="font-size: 18px;">u<sub>i</sub>&nbsp;!= v<sub>i</sub></span></li>
<li><span style="font-size: 18px;">1 &lt;= w<sub>i</sub>&nbsp;&lt;= 100</span></li>
<li><span style="font-size: 18px;">All the pairs&nbsp;(u<sub>i</sub>, v<sub>i</sub>)&nbsp;are&nbsp;<strong>unique</strong>. (i.e., no multiple edges)</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/alien-dictionary/1" target="_blank" rel="noopener noreferrer">Alien Dictionary</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">A new alien language uses the English alphabet, but the order of letters is unknown. You are given a list of <strong>words[] </strong>from the alien language&rsquo;s dictionary, where the words are claimed to be <strong>sorted lexicographically</strong> according to the language&rsquo;s rules.</span></p>
<p><span style="font-size: 14pt;">Your task is to determine<strong> the correct order of letters</strong> in this alien language based on the given words. If the order is valid, return a string containing the unique letters in lexicographically increasing order as per the new language's rules. If there are multiple valid orders, return any one of them.</span></p>
<p><span style="font-size: 14pt;">However, if the given arrangement of words is inconsistent with any possible letter ordering, return an empty string<strong> ("")</strong>.</span></p>
<blockquote>
<p><span style="font-size: 14pt;">A string <strong>a</strong> is lexicographically smaller than a string <strong>b</strong> if, at the first position where they differ, the character in <strong>a</strong> appears earlier in the alien language than the corresponding character in <strong>b</strong>. If all characters in the shorter word match the beginning of the longer word, the shorter word is considered smaller.</span></p>
</blockquote>
<p><span style="font-size: 14pt;"><strong>Note:</strong> Your implementation will be tested using a driver code. It will print <strong>true </strong>if your returned order correctly follows the alien language&rsquo;s lexicographic rules; otherwise, it will print <strong>false</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> words[] = ["baa", "abcd", "abca", "cab", "cad"]</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> true</span><br /><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Explanation: </strong><span style="font-size: 14pt;">A possible corrct order of letters in the alien dictionary is "bdac".<br /></span><span style="font-size: 18.6667px;">The pair "baa" and "abcd" suggests 'b' appears before 'a' in the alien dictionary.
The pair "abcd" and "abca" suggests 'd' appears before 'a' in the alien dictionary.
The pair "abca" and "cab" suggests 'a' appears before 'c' in the alien dictionary.
The pair "cab" and "cad" suggests 'b' appears before 'd' in the alien dictionary.
So, 'b' &rarr; 'd' &rarr; 'a' &rarr; 'c' is a valid ordering.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>words[] = ["caa", "aaa", "aab"]</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> true</span><br /><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Explanation:</strong><span style="font-size: 14pt;"> A possible corrct order of letters in the alien dictionary is "cab".<br /></span><span style="font-size: 18.6667px;">The pair "caa" and "aaa" suggests 'c' appears before 'a'.<br /></span></span><span style="font-size: 14pt;"><span style="font-size: 18.6667px;">The pair "aaa" and "aab" suggests 'a' appear before 'b' in the alien dictionary. <br />So, 'c' &rarr; 'a' &rarr; 'b' is a valid ordering.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> words[] = ["ab", "cd", "ef", "ad"]</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> ""</span><br /><span style="font-size: 14pt;"><strong>Explanation:</strong> No valid ordering of letters is possible.<br /></span><span style="font-size: 14pt;">The pair "ab" and "ef" suggests "a" appears before "e".<br />The pair "ef" and "ad" suggests "e" appears before "a", which contradicts the ordering rules.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong></span><span style="font-size: 14pt;">1&nbsp;</span><span style="font-size: 18.6667px;">&le;</span><span style="font-size: 14pt;"> words.length&nbsp;</span><span style="font-size: 18.6667px;">&le;</span><span style="font-size: 14pt;">&nbsp;500<br /></span><span style="font-size: 14pt;">1&nbsp;</span><span style="font-size: 18.6667px;">&le;</span><span style="font-size: 14pt;"> words[i].length&nbsp;</span><span style="font-size: 18.6667px;">&le;</span><span style="font-size: 14pt;">&nbsp;100<br /></span><span style="font-size: 14pt;">words[i] consists only of lowercase English letters.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description" target="_blank" rel="noopener noreferrer">All Ancestors of a Node in a Directed Acyclic Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing the number of nodes of a <strong>Directed Acyclic Graph</strong> (DAG). The nodes are numbered from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>).</p>

<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> denotes that there is a <strong>unidirectional</strong> edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> in the graph.</p>

<p>Return <em>a list</em> <code>answer</code><em>, where </em><code>answer[i]</code><em> is the <strong>list of ancestors</strong> of the</em> <code>i<sup>th</sup></code> <em>node, sorted in <strong>ascending order</strong></em>.</p>

<p>A node <code>u</code> is an <strong>ancestor</strong> of another node <code>v</code> if <code>u</code> can reach <code>v</code> via a set of edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/12/e1.png" style="width: 322px; height: 265px;" />
<pre>
<strong>Input:</strong> n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
<strong>Output:</strong> [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
<strong>Explanation:</strong>
The above diagram represents the input graph.
- Nodes 0, 1, and 2 do not have any ancestors.
- Node 3 has two ancestors 0 and 1.
- Node 4 has two ancestors 0 and 2.
- Node 5 has three ancestors 0, 1, and 3.
- Node 6 has five ancestors 0, 1, 2, 3, and 4.
- Node 7 has four ancestors 0, 1, 2, and 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/12/e2.png" style="width: 343px; height: 299px;" />
<pre>
<strong>Input:</strong> n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
<strong>Output:</strong> [[],[0],[0,1],[0,1,2],[0,1,2,3]]
<strong>Explanation:</strong>
The above diagram represents the input graph.
- Node 0 does not have any ancestor.
- Node 1 has one ancestor 0.
- Node 2 has two ancestors 0 and 1.
- Node 3 has three ancestors 0, 1, and 2.
- Node 4 has four ancestors 0, 1, 2, and 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= edges.length &lt;= min(2000, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>The graph is <strong>directed</strong> and <strong>acyclic</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed acyclic graph of <code>n</code> nodes, and our task is to return a list where each sub-list contains the ancestors of the node at that index, sorted in ascending order.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph (DAG)</a> is a graph where each edge has a defined direction from one vertex to another and following these edges will never create a closed loop.</p>
<p>A prerequisite for solving this problem is knowledge of graph traversals, namely depth-first search and breadth-first search. If you are not familiar with popular graph traversal techniques, we strongly encourage you to check out this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/">Explore Card</a>.</p>
<hr />
<h3 id="approach-1-depth-first-search-reversed-graph">Approach 1: Depth First Search (Reversed Graph)</h3>
<h4 id="intuition">Intuition</h4>
<p>A node <code>u</code> is an ancestor of node <code>v</code> if we can reach <code>v</code> by following a series of directed edges from <code>u</code>. Thus, all nodes from which we can reach <code>v</code> are its ancestors. But how can we efficiently find all ancestors for each node?</p>
<p>The brute force strategy to determine if node <code>u</code> is an ancestor of node <code>v</code> involves performing a graph traversal from <code>u</code> to check if <code>v</code> can be reached. However, this approach has a time complexity of <span class="math inline">\(O(n^3)\)</span>, which is too slow for our constraints. We need a more optimized technique.</p>
<p>The key insight lies in reversing the traversal direction. By starting from each node and tracing back to all its ancestors directly, we can simplify our task. This is achieved by reversing the edges of the graph, flipping parent-child connections to child-parent. Consequently, nodes reachable from a given node in the reversed graph were its ancestors in the original graph. Have a look at the slides below:</p>
<p>!?!../Documents/2192/reversed_slideshow.json:1162,1142!?!</p>
<p>To find the descendants of a node <code>v</code>, we start a depth-first traversal from <code>v</code> in the reversed graph, using a <code>visited</code> set to track nodes. After the traversal, we collect all nodes in <code>visited</code> (except <code>v</code>) in a list, representing the ancestors of <code>v</code> in the original graph. Performing this traversal for each node provides the required ancestors for all nodes.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Main method <code>getAncestors</code>:</p>
<ul>
<li>Initialize <code>adjacencyList</code> to store the graph representation.</li>
<li>Add the edges to the <code>adjacencyList</code> but reverse their direction.</li>
<li>Initialize a list of lists <code>ancestorsList</code> to store the ancestors of each node.</li>
<li>Iterate through each node:
<ul>
<li>Initialize:
<ul>
<li>An empty list <code>ancestors</code> to store ancestors of the current node.</li>
<li>A set <code>visited</code> to store the nodes already visited in the traversal.</li>
</ul>
</li>
<li>Call the <code>findChildren</code> method to perform DFS and find all descendants of the current node.</li>
<li>Add all nodes present in the <code>visited</code> set to <code>ancestors</code>.</li>
<li>Add <code>ancestors</code> to <code>ancestorsList</code>.</li>
</ul>
</li>
<li>Return <code>ancestorsList</code> containing the ancestors for each node.</li>
</ul>
</li>
<li>
<p>Helper method <code>findChildren</code>:</p>
<ul>
<li>Define the <code>findChildren</code> method with parameters: <code>currentNode</code>, <code>adjacencyList</code> and the <code>visited</code> set for the current traversal.</li>
<li>Add <code>currentNode</code> to the <code>visited</code> set.</li>
<li>Iterate through the neighbors of <code>currentNode</code>. If <code>neighbor</code> has not been visited yet:
<ul>
<li>Recursively call <code>findChildren</code> on <code>neighbor</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TMApG9fd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + n \cdot m)\)</span></p>
<p>Initializing and populating the adjacency list requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The algorithm calls the the DFS method a total of <span class="math inline">\(n\)</span> times. The depth-first search has a worst-case time complexity of <span class="math inline">\(O(n + m)\)</span>. Thus, finding the ancestors take a total of <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
<p>Forming the list of ancestors requires <span class="math inline">\(O(n)\)</span> time, which also occurs <span class="math inline">\(n\)</span> times. This equates to a <span class="math inline">\(O(n^2)\)</span> complexity.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(n + m)\)</span> + <span class="math inline">\(O(n^2 + n \cdot m)\)</span> + <span class="math inline">\(O(n^2)\)</span>, which simplifies to <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list takes <span class="math inline">\(O(n + m)\)</span> space, while the <code>ancestors</code> list and the <code>visited</code> set each require <span class="math inline">\(O(n)\)</span> space. The recursion call stack can go as deep as <span class="math inline">\(O(n)\)</span> in the worst case. Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + m) + 3 \cdot O(n)\)</span>, which simplifies to <span class="math inline">\(O(n + m)\)</span>.</p>
<blockquote>
<p>Note: We are not considering the space required by <code>ancestorsList</code> in our analysis, since it is part of the output space. If we do consider it, <code>ancestorsList</code> would have a worst-case space complexity of <span class="math inline">\(O(n^2)\)</span>, making the space complexity of the algorithm <span class="math inline">\(O(n^2 + m)\)</span>.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-optimized">Approach 2: Depth First Search (Optimized)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can solve this problem without reversing the edges. Observe that a vertex <code>v</code> will be an ancestor for all nodes reachable from it. Therefore, we can initiate a depth-first traversal from each vertex and designate that vertex as an ancestor to all nodes it can reach.</p>
<p>Our depth-first search would be very similar to Approach 1; but with a key difference: we add the given node as an <code>ancestor</code> to all children of the node we're currently exploring. We then recursively call our depth-first search function on each child until all descendants of <code>ancestor</code> are marked with its presence.</p>
<p>Have a look at this slideshow to better understand this process:</p>
<p>!?!../Documents/2192/ancestors_slideshow.json:1742,1310!?!</p>
<p>Another optimization we can implement is eliminating the <code>visited</code> set. In each traversal, we add <code>ancestor</code> to the list of ancestors for each node. To determine if a node has been visited, we check if its last ancestor matches the current ancestor. If it does, the node has been visited and can be safely skipped from further exploration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Main method <strong>getAncestors</strong>:</p>
<ul>
<li>Initialize:
<ul>
<li>A list of lists <code>adjacencyList</code> to store the adjacency list of the graph.</li>
<li>A list of lists <code>ancestors</code> to store the ancestors of each node.</li>
</ul>
</li>
<li>Populate <code>adjacencyList</code> with edges from the input.</li>
<li>For each node, use depth-first search (DFS) to find all its ancestors.</li>
<li>Return <code>ancestors</code> containing the ancestors of each node.</li>
</ul>
</li>
<li>
<p>Helper method <strong>findAncestorsDFS</strong>:</p>
<ul>
<li>Define a method <code>findAncestorsDFS</code> that takes four parameters: the <code>ancestor</code> node, <code>adjacencyList</code>, the current node being visited, and <code>ancestors</code>.</li>
<li>Loop through each child node <code>childNode</code> of the current node in the adjacency list:
<ul>
<li>Check if <code>ancestor</code> is already added to the child node's ancestor list. If not:
<ul>
<li>Add <code>ancestor</code> to the child node's ancestor list.</li>
<li>Recursively call <code>findAncestorsDFS</code> for <code>childNode</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ejRveq7U/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + n \cdot m)\)</span></p>
<p>Initializing and populating the adjacency list requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The depth-first search (DFS) has a time complexity of <span class="math inline">\(O(n + m)\)</span> and is executed <span class="math inline">\(n\)</span> times. Therefore, the total time complexity of this section is <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
<p>The overall time complexity of the algorithm combines <span class="math inline">\(O(n + m)\)</span> for initialization and <span class="math inline">\(O(n^2 + n \cdot m)\)</span> for the DFS, resulting in <span class="math inline">\(O(n^2 + n \cdot m)\)</span> complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list representation of the graph takes <span class="math inline">\(O(n + m)\)</span> space. The call stack for the DFS could go as deep as the height of the graph, which in the worst case is <span class="math inline">\(O(n)\)</span>. Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + m) + O(n)\)</span>, simplifying to <span class="math inline">\(O(n + m)\)</span>.</p>
<blockquote>
<p>Note: We have not considered the space required by <code>ancestors</code> in our analysis, since it is part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort-bfs">Approach 3: Topological Sort (BFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The problem revolves around the nature of the graph as a Directed Acyclic Graph (DAG). In a DAG, cycles are absent, and each path progresses clearly from a starting point to an endpoint. This characteristic implies that by processing nodes in a specific order, we can systematically determine each node's ancestors.</p>
<p>The key to identifying this optimal processing order lies in topological sorting. In a DAG, topological sorting arranges nodes such that for every directed edge from node <code>u</code> to node <code>v</code>, <code>u</code> precedes <code>v</code> in the ordering. This arrangement is crucial because it ensures that when we process a node <code>v</code>, we have already considered all its potential ancestors. To achieve this ordering, we will use Kahn's algorithm.</p>
<p>Kahn's algorithm is a method for topologically sorting a directed acyclic graph. It starts by identifying all nodes without incoming edges and placing them in a queue. At each step, it removes a node from this queue, adds it to the sorted list, and eliminates its outgoing edges from the graph. This process may create new nodes without incoming edges, which are then added to the queue. The algorithm continues until the queue is empty. The resulting list provides a valid topological ordering of the graph. For a more detailed explanation of Kahn's algorithm and its implementation, refer to this <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">Explore Card</a>.</p>
<p>After establishing the topological order, we process each node sequentially. For each <code>node</code>, we iterate through its <code>neighbors</code>, designating both the node itself and its ancestors as ancestors of the <code>neighbor</code>. To efficiently track each node's ancestors, we use a list of sets. Sets, unlike lists, maintain unique elements, ensuring each ancestor appears only once in a node's ancestor set.</p>
<p>In the final step, we'll convert these sets of ancestors into lists, as required by the problem statement.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a list of lists <code>adjacencyList</code> to store the edges of the graph.</li>
<li>Initialize an array <code>indegree</code> to store the in-degree of each node.</li>
<li>Fill <code>adjacencyList</code> and the <code>indegree</code> array based on the given edges.</li>
<li>Initialize a queue <code>nodesWithZeroIndegree</code> and add all such nodes to the queue.</li>
<li>Initialize a list <code>topologicalOrder</code> to store the topological order of nodes and process nodes in the queue. For each node:
<ul>
<li>Reduce the in-degree of its neighbors.</li>
<li>Add neighbors with zero in-degree to the queue.</li>
</ul>
</li>
<li>Initialize a list <code>ancestorsList</code> to store the result and a list of sets <code>ancestorsSetList</code> to store the ancestors of each node.</li>
<li>For each <code>node</code> in the topological order:
<ul>
<li>Loop over all neighbors <code>neighbor</code> of <code>node</code>. For each <code>neighbor</code>:
<ul>
<li>Add <code>node</code> as the immediate parent of <code>neighbor</code> to the set <code>ancestorsSetList[neighbor]</code>.</li>
<li>Add all other ancestors of <code>node</code> to the set <code>ancestorsSetList[neighbor]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add the contents of each set to it's corresponding list in <code>ancestorsList</code> in ascending order.</li>
<li>Return <code>ancestorsList</code>, which contains the ancestors of each node in the graph.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/BGfz4pY8/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + m)\)</span></p>
<p>Creating and filling the adjacency list and in-degree array requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>Topological sort on the graph also needs <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>In the worst-case scenario, if the graph forms a chain, the time complexity could be <span class="math inline">\(O(n^2)\)</span>. This is because each node in the chain would have a growing number of ancestors. So, the sizes of the ancestor lists would be <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, ..., <span class="math inline">\(n-2\)</span>, <span class="math inline">\(n-1\)</span>. Forming these lists would take another <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n^2 + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2 + m)\)</span></p>
<p>We use an adjacency list which takes <span class="math inline">\(O(n + m)\)</span> space.</p>
<p>We store an array of size <span class="math inline">\(n\)</span> to keep track of the indegree of each node, taking <span class="math inline">\(O(n)\)</span> space.</p>
<p>All nodes are added to the queue once, requiring <span class="math inline">\(O(n)\)</span> space.</p>
<p>The topological order list requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Maintaining a list of sets to store the ancestors requires <span class="math inline">\(O(n^2)\)</span> space in the worst case.</p>
<p>Considering all individual components, the total space complexity comes out to be <span class="math inline">\(O(n^2 + m)\)</span>.</p>
<blockquote>
<p>Note: As stated in the previous approaches, the space taken by <code>ancestorsList</code> is not taken into consideration since it is part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-paths-from-source-to-target/description" target="_blank" rel="noopener noreferrer">All Paths From Source to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a directed acyclic graph (<strong>DAG</strong>) of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, find all possible paths from node <code>0</code> to node <code>n - 1</code> and return them in <strong>any order</strong>.</p>

<p>The graph is given as follows: <code>graph[i]</code> is a list of all nodes you can visit from node <code>i</code> (i.e., there is a directed edge from node <code>i</code> to node <code>graph[i][j]</code>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> graph = [[1,2],[3],[3],[]]
<strong>Output:</strong> [[0,1,3],[0,2,3]]
<strong>Explanation:</strong> There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" style="width: 423px; height: 301px;" />
<pre>
<strong>Input:</strong> graph = [[4,3,1],[3,2,4],[3],[4],[]]
<strong>Output:</strong> [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>2 &lt;= n &lt;= 15</code></li>
	<li><code>0 &lt;= graph[i][j] &lt; n</code></li>
	<li><code>graph[i][j] != i</code> (i.e., there will be no self-loops).</li>
	<li>All the elements of <code>graph[i]</code> are <strong>unique</strong>.</li>
	<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/articulation-point-1/1" target="_blank" rel="noopener noreferrer">Articulation Point - I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected connected graph&nbsp;with&nbsp;<strong>V&nbsp;</strong>vertices and adjacency list&nbsp;<strong>adj</strong>. You are required to find all the vertices removing which (and edges through it) disconnects the graph into 2 or more components and return it in sorted manner.<br /><strong>Note:&nbsp;</strong>Indexing is zero-based i.e nodes numbering from (0 to V-1). There might be loops present in the graph.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong><img src="https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/708502/Web/Other/a27f9040-9783-4386-92f9-b8684c75db07_1685087852.png" alt="" />
<strong>Output:</strong>{1,4}
<strong>Explanation: </strong>Removing the vertex 1 will
discconect the graph as-
<img src="https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/708502/Web/Other/7e12629a-ba31-411e-b6ac-ccf5a8baa6a3_1685087852.png" alt="" />
Removing the vertex 4 will disconnect the
graph as-
<img src="https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/708502/Web/Other/fb781bda-91d6-4920-96a8-c976412c3ada_1685087852.png" alt="" />
</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>articulationPoints</strong><strong>()&nbsp;</strong>which takes V and adj as input parameters and returns a list containing all the vertices removing which turn the graph into two or more disconnected components in sorted order. If there are no such vertices then returns a list containing -1.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(V + E)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(V)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; V &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/articulation-point2616/1" target="_blank" rel="noopener noreferrer">Articulation Point - II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p class="" data-start="109" data-end="329"><span style="font-size: 14pt;">You are given an <strong data-start="126" data-end="146">undirected graph</strong> with <code data-start="152" data-end="155"><strong>V</strong></code> vertices and <code data-start="169" data-end="172"><strong>E</strong></code> edges. The graph is represented as a 2D array <strong><code data-start="219" data-end="230">edges[][]</code></strong>, where each element <code data-start="251" data-end="270">edges[i] = [u, v]</code> indicates an undirected edge between vertices <code data-start="317" data-end="320">u</code> and <code data-start="325" data-end="328">v</code>.<br /></span><span style="font-size: 14pt;">Your task is to <strong data-start="347" data-end="405">return </strong>all the<strong data-start="347" data-end="405"> articulation points </strong>(or cut vertices) in the graph. <br /></span><span style="font-size: 18.6667px;">An <strong>articulation point</strong> is a vertex whose <strong>removal</strong>, along with all its <strong>connected edges</strong>, <strong>increases </strong>the number of connected components in the graph.</span></p>
<p class="" data-start="331" data-end="648"><span style="font-size: 14pt;"><strong>Note:&nbsp;</strong>The graph may be <strong data-start="773" data-end="789">disconnected</strong>, i.e., it may consist of more than one connected component.<br />If no such point exists, <strong>return {-1}.</strong></span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> V = 5, edges[][] = [[0, 1], [1, 4], [4, 3], [4, 2], [2, 3]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/892595/Web/Other/blobid3_1744109134.png" alt="" width="369" height="201" />
<strong>Output: </strong>[1, 4]
<strong>Explanation: </strong>Removing the vertex 1 or 4 will <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">disconnects </span>the graph as-
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/892595/Web/Other/blobid4_1744109133.png" alt="" width="249" height="217" />   </span><img style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;" src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/892595/Web/Other/blobid5_1744109133.png" alt="" width="270" height="231" /></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> V = 4, edges[][] = [[0, 1], [0, 2]]
<strong>Output: </strong>[0]
<strong>Explanation: </strong>Removing the vertex 0 will increase the number of disconnected<span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal; font-size: 14pt;">&nbsp;</span>components to 3.<span style="font-size: 14pt;">&nbsp;</span><span style="font-size: 14pt;">&nbsp;</span><br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; V, E &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/assignment-problem3016/1" target="_blank" rel="noopener noreferrer">Assignment Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You are the head of a firm and you have to assign jobs to people. You have <strong>N</strong> persons working under you and you have N jobs that are to be done by these persons. Each person has to do exactly one job and each job has to be done by exactly one person. Each person has his own capability (in terms of time taken) to do any particular job. Your task is to assign the jobs to the persons in such a way that the total time taken is minimum. A job can be assigned to only one person and a person can do only one job.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>N = </strong>2</span>
<span style="font-size:18px"><strong>Arr[] = </strong>{3, 5, 10, 1}</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">4</span>
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">The first person takes times 3 and 5
for jobs 1 and 2 respectively. The second
person takes times 10 and 1 for jobs 1 and
2 respectively. We can see that the optimal
assignment will be to give job 1 to person 1
and job 2 to person 2 for a total for 3+1 = 4.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>N = </strong>3</span>
<span style="font-size:18px"><strong>Arr[] = </strong>{</span><span style="font-size:18px">2, 1, 2,&nbsp;9, 8, 1, 1, 1, 1}</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">3 
<strong>Explanation: </strong>
The optimal arrangement would be to assign 
job 1 to person 3,job 2 to person 1 and job 
3 to person 2.</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>assignmentProblem()</strong> which takes an Integer N and an array Arr[] of size N<sup>2</sup> as input and returns the time taken for the best possible assignment.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>)<br />
<strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span><br />
<span style="font-size:18px">1 &lt;= N &lt;= 30<br />
1 &lt;= Arr[i] &lt;= 100</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/avoid-explosion--170647/1" target="_blank" rel="noopener noreferrer">Avoid Explosion</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geek is a chemical scientist who is performing an experiment to find an antidote to a poison. The experiment involves mixing some solutions in a flask. Based on the theoretical research Geek has done, he came up with an <strong>n&nbsp;*&nbsp;2</strong> array &#39;<strong>mix</strong>&#39;, where mix[i] = {X, Y} denotes solutions X and Y that needs to be mixed.<br />
<br />
Also, from his past experience, it has been known that <strong>mixing some solutions leads to an explosion</strong> and thereby completely ruining the experiment. The explosive solutions are also provided as a&nbsp;<strong>m * 2</strong> array &#39;<strong>danger</strong>&#39; where danger[i] = {P, Q}&nbsp;denotes that if somehow solutions P and Q get into the same flask it will result in an explosion.</span></p>

<p><span style="font-size:18px">Help the Geek by returning an array &#39;<strong>answer</strong>&#39; of size <strong>n</strong>, where answer[i] = &quot;<strong>Yes</strong>&quot;&nbsp;if it is safe to mix solutions in &#39;mix[i]&#39; or else answer[i] = &quot;<strong>No</strong>&quot;. </span></p>

<p><span style="font-size:18px"><strong>Note:</strong> Geek should follow the order of mixing of solutions as it is in &#39;mix&#39; otherwise the antidote will be ineffective. Also, Geek will not mix the&nbsp;solutions in &#39;mix[i]&#39; once he gets to know that mixing them will result in an explosion. Mixing a solution will effect the other solutions which will appear after it.&nbsp;</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
n = 5, m = 2
mix = {{1, 2}, {2, 3}, {4, 5}, {3, 5}, {2, 4}}
danger = {{1, 3}, {4, 2}}

<strong>Output</strong>:
answer = {&quot;Yes&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;}

<strong>Explanation</strong>:
Mixing the first solution(1 and 2) of &#39;mix&#39; do not result in any kind of explosion hence answer[0] is &quot;Yes&quot;, while mixing(2nd solution) 2 and 3 is not allowed because it will result in an explosion as 1 and 3 would be in same solution hence we have returned &quot;No&quot; as the answer for 2nd solution. Mixing the third solution(4 and 5) and 4th solution(3 and 5) of &#39;mix&#39; do not result in any kind of explosion hence answer[2] and answer[3] is &quot;Yes&quot;. While mixing 2 and 4 is not allowed because it will result in an explosion hence we have returned &quot;No&quot; as the answer for it.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
n = 3, m = 2
mix = {{1, 2}, {2, 3}, {1, 3}}
danger = {{1, 2}, {1, 3}}

<strong>Output</strong>:
answer = {&quot;No&quot;, &quot;Yes&quot;, &quot;No&quot;}

<strong>Explanation</strong>:
Mixing solutions 1 and 2 is dangerous hence 
answer[0] = &quot;No&quot;, but solutions 2 and 3 can 
be mixed without any problem therefore answer[1] 
= &quot;Yes&quot;. Again, mixing solutions 1 and 3 is 
dangerous due to which answer[2] = &quot;No&quot;.</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong></span></p>

<p><span style="font-size:18px">You don&#39;t need to read input or print anything. Complete the function&nbsp;<strong>avoidExplosion()</strong>&nbsp;which takes the mix array, its size, danger array, and its size as input parameters and&nbsp;returns the result&nbsp;array or list.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity: O(n*m*log(n))<br />
Expected Space Complexity: O(n)</strong></span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span></p>

<p><span style="font-size:18px">0 &lt; n &lt; 1000</span></p>

<p><span style="font-size:18px">0 &lt; m&nbsp;&lt; 1000</span></p>

<p><span style="font-size:18px">1 &lt;= mix[i][0], mix[i][1] &lt;= n</span></p>

<p><span style="font-size:18px">1 &lt;= danger[i][0], danger[i][1] &lt;= n</span></p>

<p><span style="font-size:18px">mix[i][0] != mix[i][1]</span></p>

<p><span style="font-size:18px">danger[i][0] != danger[i][1]</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/distance-from-the-source-bellman-ford-algorithm/1" target="_blank" rel="noopener noreferrer">Bellman-Ford</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">Given an weighted graph with <strong>V</strong> vertices numbered from 0 to V-1 and <strong>E</strong> edges, represented by a 2d array <strong>edges[][]</strong>, where <strong>edges[i] = [u, v, w]</strong> represents a direct edge from node <strong>u</strong> to <strong>v</strong> having <strong>w</strong> edge weight. You are also given a source vertex <strong>src</strong>.</span></span></p>
<p><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">Your task is to compute the <strong>shortest distances</strong> from the <strong>source</strong> to all other vertices. If a vertex is unreachable from the source, its distance should be marked as <strong>10<sup>8</sup></strong>. Additionally, if the graph contains a <strong>negative weight cycle</strong>, return <strong>[-1]</strong> to indicate that shortest paths cannot be reliably computed.</span></span></p>
<p><strong style="font-family: arial, helvetica, sans-serif; font-size: 14pt;">Examples:</strong></p>
<pre><span style="font-size: 14pt;"><strong style="font-family: arial, helvetica, sans-serif;">Input: </strong><span style="font-family: arial, helvetica, sans-serif;">V = 5, edges[][] = [[1, 3, 2], [4, 3, -1], [2, 4, 1], [1, 2, 1], [0, 1, 5]], src = 0
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893096/Web/Other/blobid0_1744455175.jpg" width="260" height="260" /><br /></span><strong style="font-family: arial, helvetica, sans-serif;">Output:</strong><span style="font-family: arial, helvetica, sans-serif;"> [0, 5, 6, 6, 7]
</span><strong style="font-family: arial, helvetica, sans-serif;">Explanation</strong><span style="font-family: arial, helvetica, sans-serif;">: Shortest Paths:<br />For 0 to 1 minimum distance will be 5. By following path 0 &rarr; 1
For 0 to 2 minimum distance will be 6. By following path 0 &rarr; 1  &rarr; 2
For 0 to 3 minimum distance will be 6. By following path 0 &rarr; 1  &rarr; 2 &rarr; 4 &rarr; 3 
For 0 to 4 minimum distance will be 7. By following path 0 &rarr; 1  &rarr; 2 &rarr; 4
</span></span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-family: arial, helvetica, sans-serif;">Input: </strong><span style="font-family: arial, helvetica, sans-serif;">V = 4, edges[][] = [[0, 1, 4], [1, 2, -6], [2, 3, 5], [3, 1, -2]], src = 0
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893096/Web/Other/blobid1_1744455218.jpg" width="257" height="257" /><br /></span><strong style="font-family: arial, helvetica, sans-serif;">Output: </strong><span style="font-family: arial, helvetica, sans-serif;">[-1]
</span><strong style="font-family: arial, helvetica, sans-serif;">Explanation</strong><span style="font-family: arial, helvetica, sans-serif;">: The graph contains a negative weight cycle formed by the path 1 &rarr; 2 &rarr; 3 &rarr; 1, where the total weight of the cycle is negative.
</span></span></pre>
<p><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Constraints:<br /></strong></span><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">1 &le; V &le; 100<br /></span></span><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">1 &le; E = edges.size() &le; V*(V-1)</span><br /></span><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">-1000 &le; w &le; 1000</span><br /></span><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">0 &le; src &lt; V</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bfs-traversal-of-graph/1" target="_blank" rel="noopener noreferrer">BFS of graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a&nbsp;<strong>connected undirected graph</strong> containing<strong> V </strong>vertices, <span style="font-size: 14pt;">represented by a 2-d&nbsp;</span>adjacency list&nbsp;<strong><code>adj[][]</code></strong>, where each&nbsp;<code>adj[i]</code>&nbsp;represents the list of vertices connected to vertex&nbsp;<code>i</code>. Perform a&nbsp;<strong>Breadth First Search (BFS)&nbsp;</strong>traversal&nbsp;starting from vertex&nbsp;<code>0</code>, visiting vertices from left to right according to the given adjacency list, and return a list containing the BFS traversal of the graph.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;Do traverse in the&nbsp;<strong>same order</strong>&nbsp;as they are in the given&nbsp;<strong>adjacency list</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>adj[][] = [[2, 3, 1], [0], [0, 4], [0], [2]]</span><br /><span style="font-size: 14pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700217/Web/Other/blobid0_1728648582.jpg" width="301" height="189" /><br /><strong>Output:</strong> [0, 2, 3, 1, 4]<br /><strong>Explanation:</strong> Starting from 0, the BFS traversal will follow these steps: <br />Visit 0 &rarr; Output: 0 <br />Visit 2 (first neighbor of 0) &rarr; Output: 0, 2 <br />Visit 3 (next neighbor of 0) &rarr; Output: 0, 2, 3 <br />Visit 1 (next neighbor of 0) &rarr; Output: 0, 2, 3, <br />Visit 4 (neighbor of 2) &rarr; Final Output: 0, 2, 3, 1, 4</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Input: </strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">adj[][] = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]]<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700217/Web/Other/blobid1_1728648604.jpg" width="301" height="189" /><br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Output:</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> [0, 1, 2, 3, 4]<br /><strong>Explanation: </strong></span><span style="font-family: -apple-system, system-ui, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif;">Starting from 0, the BFS traversal proceeds as follows: <br />Visit 0 &rarr; Output: 0 <br />Visit 1 (the first neighbor of 0) &rarr; Output: 0, 1 <br />Visit 2 (the next neighbor of 0) &rarr; Output: 0, 1, 2 <br />Visit 3 (the first neighbor of 2 that hasn't been visited yet) &rarr; Output: 0, 1, 2, 3 <br />Visit 4 (the next neighbor of 2) &rarr; Final Output: 0, 1, 2, 3, 4</span></span></pre>
<p><span style="font-size: 14pt;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Constraints:<br /></strong>1 &le; V = adj.size() &le; 10<sup>4<br /></sup>1 &le; adj[i][j] &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/biconnected-graph2528/1" target="_blank" rel="noopener noreferrer">Biconnected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a graph with <strong>n</strong> vertices, <strong>e</strong> edges and an array <strong>arr[] </strong>denoting the edges connected to each other, check whether it is <a href="https://en.wikipedia.org/wiki/Biconnected_graph">Biconnected</a> or not.<br /><strong>Note: </strong>The given graph is Undirected.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:</strong> </span><span style="font-size: 18px;"><strong>n = </strong>2, <strong>e = </strong>1</span><span style="font-size: 18px;">, </span><span style="font-size: 18px;"><strong>arr = </strong>{0, 1}</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">       0
      /
     1
The above graph is Biconnected.</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:</strong> </span><span style="font-size: 18px;"><strong>n = </strong>3, <strong>e = </strong>2</span><span style="font-size: 18px;">, </span><span style="font-size: 18px;"><strong>arr = </strong>{0, 1, 1, 2}</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">0</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">       0
      /
     1
      \
       2
The above graph is not Biconnected.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n+e)<br /><strong>Expected Auxiliary Space:</strong> O(n)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= e &lt;= 100<br />2 &lt;= n &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bipartite-graph/1" target="_blank" rel="noopener noreferrer">Bipartite Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Graph with <strong>V</strong>&nbsp;vertices (Numbered from&nbsp;<strong>0</strong>&nbsp;to&nbsp;<strong>V-1</strong>) and&nbsp;<strong>E</strong> edges.&nbsp;Check whether the graph is <strong>bipartite</strong> or not.</span></p>
<p dir="ltr" style="box-sizing: border-box; margin: 0px 0px 10px; padding: 0px; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">A</span><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">&nbsp;<a href="https://www.geeksforgeeks.org/what-is-bipartite-graph/" target="_blank" rel="noopener">bipartite graph</a>&nbsp;</strong><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">can be colored with two colors such that <strong>no two</strong> <strong>adjacent</strong> <strong>vertices</strong> share the <strong>same color</strong>. This means we can divide the graph&rsquo;s vertices into two distinct sets where:</span></p>
<ul>
<li dir="ltr" style="box-sizing: border-box; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">All edges connect vertices from one set to vertices in the other set.</span></li>
<li dir="ltr" style="box-sizing: border-box; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">No edges exist between vertices within the same set.</li>
</ul>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V = 3<strong>, </strong>edges[][] = [[0, 1], [1,2]]
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240926114602/Bipartite-Graph.webp" alt="Bipartite-Graph" width="254" height="226" />
<strong>Output: </strong>true
<strong>Explanation: </strong>The given graph can be colored in two colors so, it is a bipartite graph.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, edges[][] = [[0, 3], [1, 2], [3, 2], [0, 2]]<br /></span><br /><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700410/Web/Other/blobid0_1735020917.webp" width="319" height="212" /><br /><br /><span style="font-size: 18px;"><strong>Output: </strong>false <br /><strong>Explanation: </strong>The given graph cannot be colored in two colors such that color of adjacent vertices differs. </span></pre>
<p><span style="font-size: 18px;"><strong style="font-size: 18px;">Constraints:<br /></strong><span style="font-size: 18px;">1&nbsp;</span><span style="color: #1e2229; font-family: 'andale mono', monospace; font-size: 18.6667px; background-color: #ffffff;">&le; V&nbsp;</span><span style="color: #1e2229; font-family: 'andale mono', monospace; font-size: 18.6667px; background-color: #ffffff;">&le; 2 </span><span style="color: #1e2229; font-family: 'andale mono', monospace; font-size: 18.6667px; background-color: #ffffff;">* 10</span><span style="color: #1e2229; white-space: normal; background-color: #ffffff;"><sup>5</sup></span><br /><span style="font-family: 'andale mono', monospace; font-size: 14pt;"><span style="color: #1e2229; white-space: normal; background-color: #ffffff;">1 &le; edges.size() &le; 10</span><span style="box-sizing: border-box; line-height: 1.7em; position: relative; vertical-align: baseline; top: -0.5em; color: #1e2229; background-color: #ffffff; white-space: normal;">5<br style="box-sizing: border-box; line-height: 1.7em; color: var(--text-color) !important; background-color: var(--background) !important;" /></span><span style="color: #1e2229; white-space: normal; background-color: #ffffff;">1 &le; edges[i][j] &le; 10</span><span style="box-sizing: border-box; line-height: 1.7em; position: relative; vertical-align: baseline; top: -0.5em; color: #1e2229; background-color: #ffffff; white-space: normal;">5</span></span><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bridge-edge-in-graph/1" target="_blank" rel="noopener noreferrer">Bridge edge in a graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected graph with <strong>V</strong> vertices numbered from <strong>0 to V-1</strong> and <strong>E </strong>edges, represented by 2d array <strong>edges[][]</strong>, where edges[i]=[u,v] represents the edge between the vertices u and v. Determine whether a specific edge between two vertices (c, d) is a bridge.</span></p>
<p><strong><span style="font-size: 18px;">Note:</span></strong></p>
<ul>
<li><span style="font-size: 18px;">An edge is called a&nbsp;<strong>bridge</strong>&nbsp;if removing it increases the number of&nbsp;<strong>connected components</strong>&nbsp;of the graph.</span></li>
<li><span style="font-size: 18px;">if there&rsquo;s only one path between&nbsp;<strong>c</strong>&nbsp;and&nbsp;<strong>d</strong>&nbsp;(which is the edge itself), then that edge is a&nbsp;<strong>bridge</strong>.</span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, edges[][] = [[0, 1], [1, 2], [2, 3]], c = 1, d = 2<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700463/Web/Other/blobid1_1744198886.jpg" width="369" height="256" />
<span style="font-size: 18px;"><strong>Output: </strong>true
<strong>Explanation</strong>: </span><span style="font-size: 18px;">From the graph, we can clearly see that blocking the edge 1-2 will result in disconnection of the graph.<br />Hence, it is a Bridge.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V = 5, edges[][] = [[0, 1], [0, 3], [1, 2], [2, 0], [3, 4]], c = 0, d = 2</span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700463/Web/Other/blobid2_1744199181.jpg" width="371" height="254" /> <br /><span style="font-size: 18px;"><strong>Output: </strong>false
<strong>Explanation</strong>:
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700463/Web/Other/blobid3_1744199208.jpg" width="371" height="263" /> <br /><span style="font-size: 18px;">Blocking the edge between nodes 0 and 2 won't affect the connectivity of the graph.
So, it's not a Bridge Edge. All the Bridge Edges in the graph are marked with a green line in the above image.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> V, E </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> 10<sup>5</sup><br />0 </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> c, d </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> V-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/build-a-matrix-with-conditions/description" target="_blank" rel="noopener noreferrer">Build a Matrix With Conditions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>positive</strong> integer <code>k</code>. You are also given:</p>

<ul>
	<li>a 2D integer array <code>rowConditions</code> of size <code>n</code> where <code>rowConditions[i] = [above<sub>i</sub>, below<sub>i</sub>]</code>, and</li>
	<li>a 2D integer array <code>colConditions</code> of size <code>m</code> where <code>colConditions[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>.</li>
</ul>

<p>The two arrays contain integers from <code>1</code> to <code>k</code>.</p>

<p>You have to build a <code>k x k</code> matrix that contains each of the numbers from <code>1</code> to <code>k</code> <strong>exactly once</strong>. The remaining cells should have the value <code>0</code>.</p>

<p>The matrix should also satisfy the following conditions:</p>

<ul>
	<li>The number <code>above<sub>i</sub></code> should appear in a <strong>row</strong> that is strictly <strong>above</strong> the row at which the number <code>below<sub>i</sub></code> appears for all <code>i</code> from <code>0</code> to <code>n - 1</code>.</li>
	<li>The number <code>left<sub>i</sub></code> should appear in a <strong>column</strong> that is strictly <strong>left</strong> of the column at which the number <code>right<sub>i</sub></code> appears for all <code>i</code> from <code>0</code> to <code>m - 1</code>.</li>
</ul>

<p>Return <em><strong>any</strong> matrix that satisfies the conditions</em>. If no answer exists, return an empty matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png" style="width: 211px; height: 211px;" />
<pre>
<strong>Input:</strong> k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
<strong>Output:</strong> [[3,0,0],[0,0,1],[0,2,0]]
<strong>Explanation:</strong> The diagram above shows a valid example of a matrix that satisfies all the conditions.
The row conditions are the following:
- Number 1 is in row <u>1</u>, and number 2 is in row <u>2</u>, so 1 is above 2 in the matrix.
- Number 3 is in row <u>0</u>, and number 2 is in row <u>2</u>, so 3 is above 2 in the matrix.
The column conditions are the following:
- Number 2 is in column <u>1</u>, and number 1 is in column <u>2</u>, so 2 is left of 1 in the matrix.
- Number 3 is in column <u>0</u>, and number 2 is in column <u>1</u>, so 3 is left of 2 in the matrix.
Note that there may be multiple correct answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
<strong>Output:</strong> []
<strong>Explanation:</strong> From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.
No matrix can satisfy all the conditions, so we return the empty matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= k &lt;= 400</code></li>
	<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 10<sup>4</sup></code></li>
	<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>
	<li><code>1 &lt;= above<sub>i</sub>, below<sub>i</sub>, left<sub>i</sub>, right<sub>i</sub> &lt;= k</code></li>
	<li><code>above<sub>i</sub> != below<sub>i</sub></code></li>
	<li><code>left<sub>i</sub> != right<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer <code>k</code> and two 2D integer arrays <code>rowConditions</code> and <code>colConditions</code>. The constructed matrix's size should be <code>k x k</code> containing each value from <code>1</code> to <code>k</code> exactly once. <code>rowConditions</code> contains tuples of the form: <code>[above, below]</code> for every index <code>i</code>, which denotes that the integer <code>above</code> should appear in a row strictly above the integer <code>below</code>. Similarly, in <code>colConditions</code>, the tuples are of the form <code>[left, right]</code> and denote that <code>left</code> should appear in a column strictly to the left of <code>right</code>. We need to return any matrix that satisfies these conditions.</p>
<p>Let's say that <code>rowConditions</code> is given by <code>[1,2],[2,3],[3,4]</code> for <code>k=4</code>. This implies that 1 should appear above 2, 2 should appear above 3, and 3 should appear above 4 in the matrix. Therefore, <code>[1,2,3,4]</code> is the only solution possible for the row arrangement. Now, observe that any possible column arrangement can be used to create this row solution i.e. if we have found the solution arrays for rows and columns we can merge them to create the desired matrix.</p>
<p>Therefore, we can solve this problem for rows and columns, by calculating their solutions independently and then merging those solutions in a matrix as given above. Let's try to calculate the solution array for <code>rowConditions</code> first by representing the information in the form of a graph:</p>
<ul>
<li>Let <code>G(V,E)</code> represent directed, unweighted graphs.</li>
<li>Each value from <code>1</code> to <code>k</code> would represent a vertex in the graph.</li>
<li>The edges are modeled after the prerequisite relationship between the numbers. So, a pair <code>[a,b]</code> in the <code>rowConditions</code> array means <code>a</code> must appear before <code>b</code>. The graph represents this as a directed edge <code>a ➔ b</code>.</li>
<li>If the graph would be acyclic, then an ordering would always be possible. Since it's mentioned that such an ordering may not always be possible, we may have a cyclic graph.</li>
</ul>
<p>We are trying to order nodes based on the edges such that if <code>a-&gt;b</code> is an edge, <code>a</code> must appear before <code>b</code> in the ordering. Such an ordering of subjects is referred to as a <a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorted Order</a>. There are two approaches that we will be looking at in this article to solve this problem.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>During depth-first traversal in a graph, starting from node <code>A</code>, DFS explores all paths stemming from <code>A</code> before completing its recursion for <code>A</code> and moving to other nodes. Consequently, all nodes in these paths have <code>A</code> as an ancestor, making <code>A</code> a prerequisite for all paths originating from it.</p>
<p>Now, we know how to get all the integers that have a particular integer as a prerequisite. If a valid ordering of integers is possible, the node <code>A</code> would come before all the other sets of integers that have it as a prerequisite. This idea for solving the problem can be explored using a depth-first search.</p>
<p>Initialize a recursive function given by <code>dfs</code> where the recursive stack will contain the topologically sorted order of the nodes in our graph.</p>
<p>For each node in our graph, we will run a depth-first search in case that node was not already visited in some other node's DFS traversal. Once the processing of all the neighbors is done, we will add this node to the stack. We are using the recursion stack to simulate the ordering we need.</p>
<p>Once all the nodes have been processed, we will return the nodes as they are returned in the recursion stack from top to bottom.</p>
<p>Now that we have topologically sorted arrays for both <code>rowConditions</code> and <code>colConditions</code>, how can we utilize them to construct the matrix? Each row and column should correspond to their respective sorted arrays. Therefore, the value at position <code>matrix[i][j]</code> is derived from <code>rowConditions[i]</code> and <code>colConditions[j]</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p><strong>Main function - <code>buildMatrix(k, rowConditions, colConditions)</code></strong></p>
<ol>
<li>Create two arrays given by <code>orderRows</code> and <code>orderColumns</code> to store the topological sorted sequence.</li>
<li>Store the values of <code>topoSort(rowConditions,k)</code> and <code>topoSort(colConditions,k)</code> in them.</li>
<li>If either of the arrays is empty, return <code>{}</code>.</li>
<li>Create a <code>matrix</code> of size <code>k x k</code> and initialize all values with 0.</li>
<li>Iterate <code>i</code> through all values from <code>0</code> to <code>k</code>:
<ul>
<li>Iterate <code>j</code> through all values from <code>0</code> to <code>k</code>:
<ul>
<li>If <code>orderRows[i] == orderColumns[j]</code>, store <code>orderRows[i]</code> in <code>matrix[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>matrix</code>.</li>
</ol>
<p><strong><code>topoSort(edges,n)</code></strong></p>
<ol>
<li>Initialize an adjacency matrix <code>adj</code> with <code>n+1</code> rows, and an empty array <code>order</code>. Also, initialize a <code>visited</code> array and a boolean <code>hasCycle</code> variable with <code>false</code>.</li>
<li>Store all the <code>edges</code> in <code>adj</code> by pushing <code>b</code> in <code>adj[a]</code> denoting an edge from <code>a</code> to <code>b</code>.</li>
<li>For all nodes with an index from <code>1</code> to <code>n</code>:
<ul>
<li>If the current node is not visited, perform <code>dfs(i, adj, visited, order, hasCycle)</code>. If the <code>hasCycle</code> value is <code>true</code>, return an empty array.</li>
</ul>
</li>
<li>Reverse the <code>order</code> array.</li>
<li>Return <code>order</code>.</li>
</ol>
<p><strong><code>dfs(node, adj, visited, order, hasCycle)</code></strong></p>
<ol>
<li>Set <code>visited[node]</code> to <code>1</code>.</li>
<li>Iterate over all neighbors of <code>node</code>:
<ul>
<li>If <code>visited[neighbor] == 0</code>, perform <code>dfs(neighbor, adj, visited, order, hasCycle)</code>. If <code>hasCycle</code> is true, return.</li>
<li>If <code>visited[neighbor] == 1</code>, set <code>hasCycle</code> to true, return.</li>
</ul>
</li>
<li>Set <code>visited[node]</code> as <code>2</code>.</li>
<li>Push <code>node</code> in <code>order</code> array.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HcR3PUwv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>rowConditions</code> and <code>colConditions</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span> and all the nodes are visited exactly once, the time complexity of the depth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The time complexity of creating and filling the values of a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the time complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span>, the space complexity of the depth-first search operation is <span class="math inline">\(O(n)\)</span>. The space complexity of creating a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-kahns-algorithm">Approach 2: Kahn's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Kahn’s algorithm works by keeping track of the number of incoming edges into each node (in-degree). It works by repeatedly visiting the nodes with an in-degree of zero and deleting all the edges associated with it leading to a decrement of in-degree for the nodes whose incoming edges are deleted. This process continues until no elements with zero in-degree can be found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">LeetCode Explore Card</a>.</p>
<p>After constructing the graph, we can push all the nodes with in-degree 0 to a queue. These nodes represent integers that are not constrained by the position of other integers. In a queue, push these integers first, since they can be completed without any prerequisites.</p>
<p>Now, iterate over all the queue elements, push them in the topologically sorted array, and reduce the in-degree by 1 of each direct neighbor of the current node. If the in-degree of the direct neighbor becomes 0, push it in the queue. Repeat the process till you have visited all the nodes with zero in-degree.</p>
<p>For example, let's say the given graph has three edges: <code>1 -&gt; 2</code>, <code>2 -&gt; 3</code>, and <code>1 -&gt; 3</code>. In this graph, the in-degree of each node represents the number of prerequisites that must be completed before reaching that node:</p>
<ul>
<li>Node <code>1</code> has an in-degree of <code>0</code></li>
<li>Node <code>2</code> has an in-degree of <code>1</code></li>
<li>Node <code>3</code> has an in-degree of <code>2</code></li>
</ul>
<p>We start with node <code>1</code>, as it has no prerequisites. We add it to our queue and process it first. Node <code>1</code> is a direct prerequisite for both nodes <code>2</code> and <code>3</code>, so we decrement their in-degrees:</p>
<ul>
<li>Node <code>2</code>'s in-degree becomes <code>0</code></li>
<li>Node <code>3</code>'s in-degree becomes <code>1</code></li>
</ul>
<p>Now we can add node <code>2</code> to our queue, as its in-degree is <code>0</code>. Processing node <code>2</code>, we decrement the in-degree of its neighbor, node <code>3</code>:</p>
<ul>
<li>Node <code>3</code>'s in-degree becomes <code>0</code></li>
</ul>
<p>Finally, we add node <code>3</code> to our queue and process it.</p>
<p>The resulting topologically sorted order is <code>1 -&gt; 2 -&gt; 3</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong>Main function - <code>buildMatrix(k, rowConditions, colConditions)</code></strong></p>
<ol>
<li>Create two arrays given by <code>orderRows</code> and <code>orderColumns</code> to store the topological sorted sequence.</li>
<li>Store the values of <code>topoSort(rowConditions, k)</code> and <code>topoSort(colConditions, k)</code> in them.</li>
<li>If either of the arrays is empty, return <code>{}</code>.</li>
<li>Create <code>matrix</code> of size <code>k x k</code> and initialize all values with 0.</li>
<li>Iterate <code>i</code> through all values from <code>1</code> to <code>k</code>:
<ul>
<li>Iterate <code>j</code> through all values from <code>1</code> to <code>k</code>:
<ul>
<li>If <code>orderRows[i] = orderColumns[j]</code>, store <code>orderRows[i]</code> in <code>matrix[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>matrix</code>.</li>
</ol>
<p><strong><code>topoSort(edges, n)</code></strong></p>
<ol>
<li>Initialize an adjacency matrix <code>adj</code> with <code>n+1</code> rows, an array <code>deg</code> with size <code>n+1</code>, and an empty array <code>order</code>.</li>
<li>Store all the <code>edges</code> in <code>adj</code> by pushing <code>b</code> in <code>adj[a]</code> (denoting an edge from <code>a</code> to <code>b</code>). Also, increment the in-degree of <code>b</code> in the <code>deg</code> array.</li>
<li>Initialize a queue <code>q</code> and push all nodes with in-degree values 0 to the queue.</li>
<li>While <code>q</code> is not empty:
<ul>
<li>Store the front element of <code>q</code> in <code>f</code> and pop it.</li>
<li>Push <code>f</code> in <code>order</code>.</li>
<li>Decrement <code>n</code> by 1.</li>
<li>Iterate through each neighbor of <code>f</code>:
<ul>
<li>Decrement the in-degree of the neighbor. If the in-degree becomes 0, push it in <code>q</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>n</code> is not equal to 0, return an empty array.</li>
<li>Return <code>order</code>.</li>
</ol>
<p>!?!../Documents/2392/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7Ckf6TjR/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>rowConditions</code> and <code>colConditions</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span> and all the nodes are visited exactly once, the time complexity of the breadth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The time complexity of creating and filling the values of a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the time complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span>, the space complexity of the breadth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The space complexity of creating a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cat-and-mouse/description" target="_blank" rel="noopener noreferrer">Cat and Mouse</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">game-theory</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A game on an <strong>undirected</strong> graph is played by two players, Mouse and Cat, who alternate turns.</p>

<p>The graph is given as follows: <code>graph[a]</code> is a list of all nodes <code>b</code> such that <code>ab</code> is an edge of the graph.</p>

<p>The mouse starts at node <code>1</code> and goes first, the cat starts at node <code>2</code> and goes second, and there is a hole at node <code>0</code>.</p>

<p>During each player&#39;s turn, they <strong>must</strong> travel along one&nbsp;edge of the graph that meets where they are.&nbsp; For example, if the Mouse is at node 1, it <strong>must</strong> travel to any node in <code>graph[1]</code>.</p>

<p>Additionally, it is not allowed for the Cat to travel to the Hole (node <code>0</code>).</p>

<p>Then, the game can end in three&nbsp;ways:</p>

<ul>
	<li>If ever the Cat occupies the same node as the Mouse, the Cat wins.</li>
	<li>If ever the Mouse reaches the Hole, the Mouse wins.</li>
	<li>If ever a position is repeated (i.e., the players are in the same position as a previous turn, and&nbsp;it is the same player&#39;s turn to move), the game is a draw.</li>
</ul>

<p>Given a <code>graph</code>, and assuming both players play optimally, return</p>

<ul>
	<li><code>1</code>&nbsp;if the mouse wins the game,</li>
	<li><code>2</code>&nbsp;if the cat wins the game, or</li>
	<li><code>0</code>&nbsp;if the game is a draw.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> graph = [[1,3],[0],[3],[0,2]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= graph.length &lt;= 50</code></li>
	<li><code>1&nbsp;&lt;= graph[i].length &lt; graph.length</code></li>
	<li><code>0 &lt;= graph[i][j] &lt; graph.length</code></li>
	<li><code>graph[i][j] != i</code></li>
	<li><code>graph[i]</code> is unique.</li>
	<li>The mouse and the cat can always move.&nbsp;</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-minimax--percolate-from-resolved-states">Approach 1: Minimax / Percolate from Resolved States</h3>
<p><strong>Intuition</strong></p>
<p>The state of the game can be represented as <code>(m, c, t)</code> where <code>m</code> is the location of the mouse, <code>c</code> is the location of the cat, and <code>t</code> is <code>1</code> if it is the mouse's move, else <code>2</code>.  Let's call these states <em>nodes</em>.  These states form a directed graph: the player whose turn it is has various moves which can be considered as outgoing edges from this node to other nodes.</p>
<p>Some of these nodes are already resolved: if the mouse is at the hole <code>(m = 0)</code>, then the mouse wins; if the cat is where the mouse is <code>(c = m)</code>, then the cat wins.  Let's say that nodes will either be colored <span class="math inline">\(\small\text{MOUSE}\)</span>, <span class="math inline">\(\small\text{CAT}\)</span>, or <span class="math inline">\(\small\text{DRAW}\)</span> depending on which player is assured victory.</p>
<p>As in a standard minimax algorithm, the Mouse player will prefer <span class="math inline">\(\small\text{MOUSE}\)</span> nodes first, <span class="math inline">\(\small\text{DRAW}\)</span> nodes second, and <span class="math inline">\(\small\text{CAT}\)</span> nodes last, and the Cat player prefers these nodes in the opposite order.</p>
<p><strong>Algorithm</strong></p>
<p>We will color each <code>node</code> marked <span class="math inline">\(\small\text{DRAW}\)</span> according to the following rule.  (We'll suppose the <code>node</code> has <code>node.turn = Mouse</code>: the other case is similar.)</p>
<ul>
<li>
<p>(&quot;Immediate coloring&quot;):  If there is a child that is colored <span class="math inline">\(\small\text{MOUSE}\)</span>, then this node will also be colored <span class="math inline">\(\small\text{MOUSE}\)</span>.</p>
</li>
<li>
<p>(&quot;Eventual coloring&quot;):  If all children are colored <span class="math inline">\(\small\text{CAT}\)</span>, then this node will also be colored <span class="math inline">\(\small\text{CAT}\)</span>.</p>
</li>
</ul>
<p>We will repeatedly do this kind of coloring until no <code>node</code> satisfies the above conditions.  To perform this coloring efficiently, we will use a queue and perform a <em>bottom-up percolation</em>:</p>
<ul>
<li>
<p>Enqueue any node initially colored (because the Mouse is at the Hole, or the Cat is at the Mouse.)</p>
</li>
<li>
<p>For every <code>node</code> in the queue, for each <code>parent</code> of that <code>node</code>:</p>
<ul>
<li>
<p>Do an immediate coloring of <code>parent</code> if you can.</p>
</li>
<li>
<p>If you can't, then decrement the side-count of the number of children marked <span class="math inline">\(\small\text{DRAW}\)</span>.  If it becomes zero, then do an &quot;eventual coloring&quot; of this parent.</p>
</li>
<li>
<p>All <code>parents</code> that were colored in this manner get enqueued to the queue.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Proof of Correctness</strong></p>
<p>Our proof is similar to a proof that minimax works.</p>
<p>Say we cannot color any nodes any more, and say from any node colored <span class="math inline">\(\small\text{CAT}\)</span> or <span class="math inline">\(\small\text{MOUSE}\)</span> we need at most <span class="math inline">\(K\)</span> moves to win.  If say, some node marked <span class="math inline">\(\small\text{DRAW}\)</span> is actually a win for Mouse, it must have been with <span class="math inline">\(> K\)</span> moves.  Then, a path along optimal play (that tries to prolong the loss as long as possible) must arrive at a node colored <span class="math inline">\(\small\text{MOUSE}\)</span> (as eventually the Mouse reaches the Hole.)  Thus, there must have been some transition <span class="math inline">\(\small\text{DRAW} \rightarrow \small\text{MOUSE}\)</span> along this path.</p>
<p>If this transition occurred at a <code>node</code> with <code>node.turn = Mouse</code>, then it breaks our immediate coloring rule.  If it occured with <code>node.turn = Cat</code>, and all children of <code>node</code> have color <span class="math inline">\(\small\text{MOUSE}\)</span>, then it breaks our eventual coloring rule.  If some child has color <span class="math inline">\(\small\text{CAT}\)</span>, then it breaks our immediate coloring rule.  Thus, in this case <code>node</code> will have some child with <span class="math inline">\(\small\text{DRAW}\)</span>, which breaks our optimal play assumption, as moving to this child ends the game in <span class="math inline">\(> K\)</span> moves, whereas moving to the colored neighbor ends the game in <span class="math inline">\(\leq K\)</span> moves.</p>
<p><a href="https://leetcode.com/playground/TQVY6JML/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^3)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the graph.  There are <span class="math inline">\(O(N^2)\)</span> states, and each state has an outdegree of <span class="math inline">\(N\)</span>, as there are at most <span class="math inline">\(N\)</span> different moves.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N^2)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cat-and-mouse-ii/description" target="_blank" rel="noopener noreferrer">Cat and Mouse II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A game is played by a cat and a mouse named Cat and Mouse.</p>

<p>The environment is represented by a <code>grid</code> of size <code>rows x cols</code>, where each element is a wall, floor, player (Cat, Mouse), or food.</p>

<ul>
	<li>Players are represented by the characters <code>&#39;C&#39;</code>(Cat)<code>,&#39;M&#39;</code>(Mouse).</li>
	<li>Floors are represented by the character <code>&#39;.&#39;</code> and can be walked on.</li>
	<li>Walls are represented by the character <code>&#39;#&#39;</code> and cannot be walked on.</li>
	<li>Food is represented by the character <code>&#39;F&#39;</code> and can be walked on.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
</ul>

<p>Mouse and Cat play according to the following rules:</p>

<ul>
	<li>Mouse <strong>moves first</strong>, then they take turns to move.</li>
	<li>During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the <code>grid</code>.</li>
	<li><code>catJump, mouseJump</code> are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.</li>
	<li>Staying in the same position is allowed.</li>
	<li>Mouse can jump over Cat.</li>
</ul>

<p>The game can end in 4 ways:</p>

<ul>
	<li>If Cat occupies the same position as Mouse, Cat wins.</li>
	<li>If Cat reaches the food first, Cat wins.</li>
	<li>If Mouse reaches the food first, Mouse wins.</li>
	<li>If Mouse cannot get to the food within 1000 turns, Cat wins.</li>
</ul>

<p>Given a <code>rows x cols</code> matrix <code>grid</code> and two integers <code>catJump</code> and <code>mouseJump</code>, return <code>true</code><em> if Mouse can win the game if both Cat and Mouse play optimally, otherwise return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_111_1955.png" style="width: 580px; height: 239px;" />
<pre>
<strong>Input:</strong> grid = [&quot;####F&quot;,&quot;#C...&quot;,&quot;M....&quot;], catJump = 1, mouseJump = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> Cat cannot catch Mouse on its turn nor can it get the food before Mouse.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_2_1955.png" style="width: 580px; height: 175px;" />
<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 4
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == grid.length</code></li>
	<li><code>cols = grid[i].length</code></li>
	<li><code>1 &lt;= rows, cols &lt;= 8</code></li>
	<li><code>grid[i][j]</code> consist only of characters <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, <code>&#39;F&#39;</code>, <code>&#39;.&#39;</code>, and <code>&#39;#&#39;</code>.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
	<li><code>1 &lt;= catJump, mouseJump &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/cheapest-flights-within-k-stops/1" target="_blank" rel="noopener noreferrer">Cheapest Flights Within K Stops</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">queue</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are&nbsp;<code>n</code>&nbsp;cities and m edges connected by some number of flights. You are given an array&nbsp;<code>flights</code>&nbsp;where&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code>&nbsp;indicates that there is a flight from the city&nbsp;<code>from<sub>i</sub></code>&nbsp;to city&nbsp;<code>to<sub>i</sub></code>&nbsp;with cost&nbsp;<code>price<sub>i</sub></code>.</span></p>
<p><span style="font-size: 18px;">You are also given three integers&nbsp;<code>src</code>,&nbsp;<code>dst</code>, and&nbsp;<code>k</code>, return&nbsp;<em><strong>the cheapest price</strong>&nbsp;from&nbsp;</em><code>src</code><em>&nbsp;to&nbsp;</em><code>dst</code><em>&nbsp;with at most&nbsp;</em><code>k</code><em>&nbsp;stops.&nbsp;</em>If there is no such route, return<em>&nbsp;</em><code>-1</code>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note</strong>: The price from city A to B may be different From the price from city B to A. </span></p>
<pre><span style="font-size: 18px;"><strong>Example 1:</strong>
<strong>Input:</strong>
n = 4
flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]
src = 0
dst = 3
k = 1
<strong>Output:</strong>
700
Explanation:
</span><span style="font-size: 18px;">The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br /><code>1 &lt;= n &lt;= 100<br />
0 &lt;= flights.length &lt;= (n * (n - 1) / 2)<br />
flights[i].length == 3<br />
0 &lt;= from<sub>i</sub>, to<sub>i</sub>&nbsp;&lt; n<br />
from<sub>i</sub>&nbsp;!= to<sub>i</sub><br />
1 &lt;= price<sub>i</sub>&nbsp;&lt;= 10<sup>4</sup></code><br />There will not be any multiple flights between the two cities.<br /><code>0 &lt;= src, dst, k &lt; n<br />
src != dst</code></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cheapest-flights-within-k-stops/description" target="_blank" rel="noopener noreferrer">Cheapest Flights Within K Stops</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities connected by some number of flights. You are given an array <code>flights</code> where <code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> indicates that there is a flight from city <code>from<sub>i</sub></code> to city <code>to<sub>i</sub></code> with cost <code>price<sub>i</sub></code>.</p>

<p>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return <em><strong>the cheapest price</strong> from </em><code>src</code><em> to </em><code>dst</code><em> with at most </em><code>k</code><em> stops. </em>If there is no such route, return<em> </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-3drawio.png" style="width: 332px; height: 392px;" />
<pre>
<strong>Input:</strong> n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1
<strong>Output:</strong> 700
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-1drawio.png" style="width: 332px; height: 242px;" />
<pre>
<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
<strong>Output:</strong> 200
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-2drawio.png" style="width: 332px; height: 242px;" />
<pre>
<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
<strong>Output:</strong> 500
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>
	<li><code>flights[i].length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>There will not be any multiple flights between two cities.</li>
	<li><code>0 &lt;= src, dst, k &lt; n</code></li>
	<li><code>src != dst</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description" target="_blank" rel="noopener noreferrer">Checking Existence of Edge Length Limited Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An undirected graph of <code>n</code> nodes is defined by <code>edgeList</code>, where <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> denotes an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with distance <code>dis<sub>i</sub></code>. Note that there may be <strong>multiple</strong> edges between two nodes.</p>

<p>Given an array <code>queries</code>, where <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code>, your task is to determine for each <code>queries[j]</code> whether there is a path between <code>p<sub>j</sub></code> and <code>q<sub>j</sub></code><sub> </sub>such that each edge on the path has a distance <strong>strictly less than</strong> <code>limit<sub>j</sub></code> .</p>

<p>Return <em>a <strong>boolean array</strong> </em><code>answer</code><em>, where </em><code>answer.length == queries.length</code> <em>and the </em><code>j<sup>th</sup></code> <em>value of </em><code>answer</code> <em>is </em><code>true</code><em> if there is a path for </em><code>queries[j]</code><em> is </em><code>true</code><em>, and </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/08/h.png" style="width: 267px; height: 262px;" />
<pre>
<strong>Input:</strong> n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
<strong>Output:</strong> [false,true]
<strong>Explanation:</strong> The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.
For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.
For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/08/q.png" style="width: 390px; height: 358px;" />
<pre>
<strong>Input:</strong> n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
<strong>Output:</strong> [true,false]
<strong>Explanation:</strong> The above figure shows the given graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edgeList.length, queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edgeList[i].length == 3</code></li>
	<li><code>queries[j].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>
	<li><code>1 &lt;= dis<sub>i</sub>, limit<sub>j</sub> &lt;= 10<sup>9</sup></code></li>
	<li>There may be <strong>multiple</strong> edges between two nodes.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/chinese-postman/1" target="_blank" rel="noopener noreferrer">Chinese Postman</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a graph find the shortest cyclic path or circuity that visits every edge of the graph at least once.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N=3
M=3
edges[][]={{1,2,1},{2,3,1},{3,1,4}}
<strong>Output:</strong>
6
<strong>Explanation:</strong>
We can go from 1-&gt;2-&gt;3-&gt;1 visiting every 
edge at least once and hence the minimum 
cost is 6.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N=6
M=8
edges[][]={{1,2,3},{2,6,6},{2,4,1},{4,6,1}
,{6,5,4},{5,1,5},{5,3,2},{3,1,1}}
<strong>Output:</strong>
28
<strong>Explanation:</strong>
The path is 1-&gt;3-&gt;5-&gt;1-&gt;3-&gt;5-&gt;6-&gt;2-&gt;4-&gt;6-&gt;4
-&gt;2-&gt;1,which sum to 28.It can be shown that 
28 is the optimal answer.</span>

</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>chinesePostmanProblem()</strong>&nbsp;which takes the edge list e[][], number of nodes<strong>&nbsp;</strong>as input parameters&nbsp;and returns the length of the shortest path that visits each edge at least once. Return -1 if it is not possible to visit every edge once.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(sqrt(N!))<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N*N)</span><br /><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 15.<br />1&lt;=edges[I][0],edges[I][1]&lt;=N.<br />1&lt;=edges[I][2]&lt;=25.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/circle-of-strings4530/1" target="_blank" rel="noopener noreferrer">Circle of strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr </strong>of lowercase strings, determine if the strings can be chained together to form a circle.<br />A string <strong>X </strong>can be chained together with another string <strong>Y </strong>if the last character of <strong>X </strong>is the same as the first character of <strong>Y. </strong>If every string of the array can be chained with exactly two strings of the array(one with the first character and the second with the last character of the string), it will form a circle.</span></p>
<p><span style="font-size: 18px;"><strong>For example</strong>, for the array&nbsp;arr[] = {"for", "geek", "rig", "kaf"} the answer will be Yes as the given strings can be chained as&nbsp;"for", "rig", "geek"&nbsp;and "kaf"</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = ["abc", "bcd", "cdf"]
<strong>Output: </strong>0
<strong>Explaination: </strong>These strings can't form a circle because no string has 'd'at the starting index.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = ["ab" , "bc", "cd", "da"]
<strong>Output: </strong>1
<strong>Explaination: </strong>These strings can form a circle of strings.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n)<br /><strong>Expected Auxiliary Space:</strong> O(n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong>&nbsp;<br />1 &le; length of strings &le; 20</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/1" target="_blank" rel="noopener noreferrer">City With the Smallest Number of Neighbors at a Threshold Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are <strong>n</strong> cities labeled from 0 to n-1 with <strong>m </strong>edges connecting them. Given the array <strong>edges</strong>&nbsp;where <strong>edges[i] = [from<sub>i&nbsp;</sub>, to<sub>i ,</sub>weight<sub>i</sub>]<sub>&nbsp;</sub></strong>&nbsp;represents a <strong>bidirectional </strong>and <strong>weighted edge </strong>between cities <strong>from<sub>i</sub>&nbsp;</strong>and <strong>to<sub>i</sub></strong>, and given the integer <strong>distanceThreshold</strong>. You need to find out a city with the <strong>smallest number </strong>of cities that are reachable through some path and whose distance is&nbsp;<strong>at most</strong>&nbsp;<strong>Threshold Distance.</strong>&nbsp;If there are multiple such cities, our answer will&nbsp;be the city with the <strong>greatest label</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> The distance of a path connecting cities <em><strong>i</strong></em>&nbsp;and&nbsp;<em><strong>j</strong></em> is equal to the sum of the edge's weights along that path.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">n = 4, m = 4</span>
<span style="font-size: 18px;">edges = [[0, 1, 3],<br />         [1, 2, 1], <br />         [1, 3, 4],  <br />         [2, 3, 1]]</span>
<span style="font-size: 18px;">distanceThreshold = 4</span>
<strong><span style="font-size: 18px;">Output:<br /></span></strong><span style="font-size: 18px;">3</span>
<strong><span style="font-size: 18px;">Explaination:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid1_1745300064.jpg" width="278" height="278" /><br /></span></strong><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -&gt; [City 1, City 2]&nbsp;
City 1 -&gt; [City 0, City 2, City 3]&nbsp;
City 2 -&gt; [City 0, City 1, City 3]&nbsp;
City 3 -&gt; [City 1, City 2]&nbsp;
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input:&nbsp;</span></strong><span style="font-size: 18px;"><span style="font-size: 18px;"><br />n = 5, m = 6<br />edges = [[0, 1, 2],
         [0, 4, 8],<br />         [1, 2, 3], <br />         [1, 4, 2], <br />         [2, 3, 1],<br />         [3, 4, 1]]<br />distanceThreshold = 2.<br /></span></span><span style="font-size: 18px;"><strong style="font-size: 18px;">Output:<br /></strong><span style="font-size: 18px;">0<br /></span><strong style="font-size: 18px;">Explaination:<br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid2_1745300084.jpg" width="320" height="320" /><br /><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -&gt; [City 1] 
City 1 -&gt; [City 0, City 4] 
City 2 -&gt; [City 3, City 4] 
City 3 -&gt; [City 2, City 4]
City 4 -&gt; [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.<br /></span></span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong><br /><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>findCity( )&nbsp;</strong>which takes a number of nodes <strong>n, </strong>total number of edges <strong>m</strong>&nbsp;and vector of <strong>edges</strong> and <strong>distanceThreshold</strong>. and return the city with the smallest number of cities that are reachable through some path and whose distance is <strong>at most</strong> Threshold Distance. If there are multiple such cities, return the city with the greatest label.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup> + length(edges)*nlog(n) )</span><br /><span style="font-size: 18px;"><strong>Expected Auxiliary Space:&nbsp;&nbsp;</strong>O(n<sup>3</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&nbsp; &le;&nbsp; n &le;&nbsp; 100<br />1 &lt;= m &lt;= n*(n-1)/2<br />length(edges[i]) == 3<br />0 &lt;= from<sub>i&nbsp;</sub>&lt; to<sub>i</sub>&nbsp;&lt; n<br />1 &lt;= weight<sub>i </sub>distanceThreshold &lt;= 10<sup>4</sup><br />All pairs (from<sub>i</sub>, to<sub>i</sub>) are distinct</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/clone-graph/1" target="_blank" rel="noopener noreferrer">Clone an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>connected undirected graph </strong>represented by adjacency list, <strong>adjList[][] </strong>with <strong>n </strong>nodes,&nbsp;having a <strong>distinct label </strong>from <strong>0 to n-1</strong>, where </span><span style="font-size: 14pt;">each <strong>adj[i]</strong> represents the list of vertices connected to vertex i.</span></p>
<p><span style="font-size: 14pt;">Create a <strong>clone </strong>of the graph, where each node in the graph contains an integer <strong>val</strong> and an array (<strong>neighbors</strong>) of nodes,<strong>&nbsp;</strong>containing nodes that are adjacent to the current node.</span></p>
<pre><span style="font-size: 18.6667px;">class Node {
    val: integer
    neighbors: List[Node]
}</span></pre>
<p><span style="font-size: 14pt;">Your task is to complete the function <strong>cloneGraph( )&nbsp;</strong>which takes a starting node of the graph as input and returns the <strong>copy of the given node</strong> as a reference to the cloned graph.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:&nbsp;</strong>If you return a <strong>correct copy </strong>of the given graph, then the driver code will print <strong>true</strong>; and if an incorrect copy is generated or when you return the original node, the driver code will print <strong>false</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 4, adjList[][] = [[1, 2], [0, 2], [0, 1, 3], [2]]
<strong>Output: </strong>true
<strong>Explanation: <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893038/Web/Other/blobid0_1744464094.jpg" width="211" height="190" /><br /></strong>As the cloned graph is identical to the original one the driver code will print true.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 3, adjList[][] = [[1, 2], [0], [0]]
<strong>Output: </strong>true
<strong>Explanation: <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893038/Web/Other/blobid1_1744465861.jpg" width="233" height="206" /><br /></strong>As the cloned graph is identical to the original one the driver code will print true.<br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>4<br /></sup></span><span style="font-size: 14pt;">0&nbsp;</span><span style="font-size: 18.6667px;">&le; no. of edges&nbsp;</span><span style="font-size: 18.6667px;">&le; 10<sup>5</sup><br /></span><span style="font-size: 14pt;">0 &le; adjList[i][j] &lt; n</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/clone-graph/description" target="_blank" rel="noopener noreferrer">Clone Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph" target="_blank">connected</a></strong> undirected graph.</p>

<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank"><strong>deep copy</strong></a> (clone) of the graph.</p>

<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>

<pre>
class Node {
    public int val;
    public List&lt;Node&gt; neighbors;
}
</pre>

<p>&nbsp;</p>

<p><strong>Test case format:</strong></p>

<p>For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>

<p><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>

<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" style="width: 454px; height: 500px;" />
<pre>
<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]
<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]
<strong>Explanation:</strong> There are 4 nodes in the graph.
1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/07/graph.png" style="width: 163px; height: 148px;" />
<pre>
<strong>Input:</strong> adjList = [[]]
<strong>Output:</strong> [[]]
<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> adjList = []
<strong>Output:</strong> []
<strong>Explanation:</strong> This an empty graph, it does not have any nodes.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li><code>Node.val</code> is unique for each node.</li>
	<li>There are no repeated edges and no self-loops in the graph.</li>
	<li>The Graph is connected and all nodes can be visited starting from the given node.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/collect-coins-in-a-tree/description" target="_blank" rel="noopener noreferrer">Collect Coins in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exists an undirected and unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given an integer <code>n</code> and a 2D integer array edges of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given&nbsp;an array <code>coins</code> of size <code>n</code> where <code>coins[i]</code> can be either <code>0</code> or <code>1</code>, where <code>1</code> indicates the presence of a coin in the vertex <code>i</code>.</p>

<p>Initially, you choose to start at any vertex in&nbsp;the tree.&nbsp;Then, you can perform&nbsp;the following operations any number of times:&nbsp;</p>

<ul>
	<li>Collect all the coins that are at a distance of at most <code>2</code> from the current vertex, or</li>
	<li>Move to any adjacent vertex in the tree.</li>
</ul>

<p>Find <em>the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex</em>.</p>

<p>Note that if you pass an edge several times, you need to count it into the answer several times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/01/graph-2.png" style="width: 522px; height: 522px;" />
<pre>
<strong>Input:</strong> coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/02/graph-4.png" style="width: 522px; height: 522px;" />
<pre>
<strong>Input:</strong> coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == coins.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= coins[i] &lt;= 1</code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/connected-components-in-an-undirected-graph/1" target="_blank" rel="noopener noreferrer">Connected Components in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected graph with&nbsp;<strong>V&nbsp;</strong>vertices numbered from 0 to V-1 and&nbsp;<strong>E</strong> edges, represented as a 2D array <strong>edges[][]</strong>, where each entry&nbsp;<strong>edges[i] = [u, v]</strong>&nbsp;denotes an edge between vertices&nbsp;<strong>u</strong>&nbsp;and&nbsp;<strong>v</strong>.</span></p>
<p><span style="font-size: 18px;">Your task is to return a list of all connected components. Each connected component should be represented as a list of its vertices, with all components returned in a collection where each component is listed separately.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> You can return the components in any order, driver code will print the components in <strong>sorted </strong>order.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V = 5, edges[][] = [[0, 1], [2, 1], [3, 4]]
<strong>Output: </strong>[[0, 1, 2], [3, 4]]</span><strong><span style="font-size: 18px;">
Explanation:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893290/Web/Other/blobid1_1744798106.jpg" width="269" height="238" /><br /></span></strong></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 7,<strong> </strong></span><span style="font-size: 18px;">edges[][] <strong>= </strong>[[0, 1], [6, 0], [2, 4], [2, 3], [3, 4]]
<strong>Output: </strong>[[0, 1, 6], [2, 3, 4], [5]]<br /><strong>Explanation:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893290/Web/Other/blobid0_1744797809.jpg" width="360" height="228" /></strong></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1 &le; V &le; 10<sup>5</sup><br />1 &le; edges.size() &le; 10<sup>5</sup><br /></span><span style="font-size: 18px;">0 &lt;= edges[i][0], edges[i][1] &lt; V</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/connecting-the-graph/1" target="_blank" rel="noopener noreferrer">Connecting the graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a graph with <strong>n</strong> vertices (0 to n-1) and <strong>m</strong> edges. </span><span style="font-size: 18px;">You can remove <strong>one</strong> edge from anywhere and add that edge between&nbsp;<strong>any </strong>two vertices in <strong>one </strong>operation. </span><span style="font-size: 18px;">Find the <strong>minimum</strong> number of operations that will be required to connect the graph.<br /></span><span style="font-size: 18px;">If it is not possible to connect the graph, return -1.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong>&nbsp;</span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 4<br />m = 3<br />Edges = [ [0, 1] , [0, 2] , [1, 2] ]<br /><strong>Output:<br /></strong>1<strong><br />Explanation:</strong><br />Remove edge&nbsp;between vertices&nbsp;1 and 2 and add&nbsp;between vertices&nbsp;1 and 3.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 6<br />m = 5<br />Edges = [ [0,1] , [0,2] , [0,3] , [1,2] , [1,3] ]<br /><strong>Output:</strong><br />2<br /><strong>Explanation:</strong><br />Remove edge between (1,2) and(0,3) and add edge between (1,4) and (3,5)</span><br />&nbsp;</pre>
<p><strong>Your Task:<br /></strong><span style="font-size: 18px;">You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>Solve()</strong>&nbsp;which takes an integer<strong> n</strong> denoting a number of vertices and a 2d matrix denoting the edges of a graph and returns the<strong> minimum</strong> number of operations to connect a graph.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(m*n)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(m*n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1&lt;=n&lt;=10<sup>5</sup><br />0&lt;=m&lt;=10<sup>2</sup><br />1&lt;=edge[i][0],edge[i][1]&lt;=n-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/jenny-and-water-7-d0337cc3-ec2c1136/" target="_blank" rel="noopener noreferrer">Connecting the special nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">hard</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a graph of <span class="mathjax-latex">\(N\)</span> nodes. The graph consists of connected components. Some of the connected components contain a special node and each component contains at most one special node. You are required to maximize the number of edges in the given graph such that it follows these constraints: </p>

<ul>
	<li>No self-loop or multiple edges should be present </li>
	<li>No connected components with more than one special node should be present</li>
	<li>Each node in the graph should belong to a component with exactly one special node</li>
</ul>

<p>If you add an edge between two nodes that belong to the same component in the graph, then the total cost involved is <span class="mathjax-latex">\(0\)</span>. Whereas, if you connect two nodes that belong to different components, then the cost is equal to the product of the sizes of both the components. </p>

<p>Your task is to maximize the number of new edges in the graph and calculate the minimum cost that will be involved in performing the required task.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>First line: Three integers <span class="mathjax-latex">\(N,\ M,\ and\ K\)</span> representing the number of nodes, number of edges, and number of special nodes in the graph respectively</li>
	<li>Next <span class="mathjax-latex">\(M\)</span> lines: Two integers <span class="mathjax-latex">\(u\ and\ v\)</span> representing an undirected edge from the node <span class="mathjax-latex">\(u\)</span> to node <span class="mathjax-latex">\(v\)</span> </li>
	<li>Next line: An empty line</li>
	<li>Next line: <span class="mathjax-latex">\(K\)</span> space-separated integers each representing the special nodes in a connected component</li>
</ul>

<p><strong>Output format</strong></p>

<p>Print the maximum number of new edges that can be added to the graph and the minimum cost of doing so.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 ≤ N ≤ 10^{5}\)</span></p>

<p><span class="mathjax-latex">\(1 ≤ M ≤ 2 \times 10^{5}\)</span></p>

<ul>
	<li><span class="mathjax-latex">\(K \leq\)</span> the total number of connected components present in the graph.</li>
	<li>It is guaranteed that for any connected component at most one special node exists.</li>
	<li>The given graph does not contain any self-loops or multiple edges.</li>
</ul></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The given graph consist of 5 connected components.<span class="mathjax-latex">\( (1, 2, 3), (4, 5, 6, 7), (8), (9, 10), (11, 12)\)</span>.<br>
1 is the special node in <span class="mathjax-latex">\((1, 2, 3)\)</span> and 4 is the special node in <span class="mathjax-latex">\((4, 5, 6, 7)\)</span>.<br>
There is no special node in <span class="mathjax-latex">\((8), (9, 10), (11, 12)\)</span>.<br>
<br>
For <span class="mathjax-latex">\((1, 2, 3)\)</span>:-<br>
We can add 1 edge from 2 to 3,  cost = 0 (same component).<br>
For <span class="mathjax-latex">\((4, 5, 6, 7)\)</span>:-<br>
We will add 3 edges from 6 to 5, 6 to 7 and 4 to 7. Now we can't add more edges to this component, cost = 0 (same component).<br>
For the remaining nodes (without special nodes):-<br>
We will first connect $$8$$ and <span class="mathjax-latex">\((11, 12)\)</span> with cost 2 and 2 edges.<br>
Then <span class="mathjax-latex">\((8, 11, 12)\)</span> and <span class="mathjax-latex">\((9, 10)\)</span> with cost 6 and 6 edges. (product of their sizes).<br>
Now we have all the non special nodes completely connected.<br>
We can now connect all the 5 non special nodes to the component <span class="mathjax-latex">\((4, 5, 6, 7)\)</span> with cost 20 and 20 edges.<br>
Hence total cost is 28 and maximum number of edges that can be added are 32.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-2d-grid-matching-graph-layout/description" target="_blank" rel="noopener noreferrer">Construct 2D Grid Matching Graph Layout</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>edges</code> representing an <strong>undirected</strong> graph having <code>n</code> nodes, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>Construct a 2D grid that satisfies these conditions:</p>

<ul>
	<li>The grid contains <strong>all nodes</strong> from <code>0</code> to <code>n - 1</code> in its cells, with each node appearing exactly <strong>once</strong>.</li>
	<li>Two nodes should be in adjacent grid cells (<strong>horizontally</strong> or <strong>vertically</strong>) <strong>if and only if</strong> there is an edge between them in <code>edges</code>.</li>
</ul>

<p>It is guaranteed that <code>edges</code> can form a 2D grid that satisfies the conditions.</p>

<p>Return a 2D integer array satisfying the conditions above. If there are multiple solutions, return <em>any</em> of them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,1],[0,2],[1,3],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[3,1],[2,0]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/screenshot-from-2024-08-11-14-07-59.png" style="width: 133px; height: 92px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1],[1,3],[2,3],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[4,2,3,1,0]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/08/11/screenshot-from-2024-08-11-14-06-02.png" style="width: 325px; height: 50px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 9, edges = [[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[8,6,3],[7,4,2],[1,0,5]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/screenshot-from-2024-08-11-14-06-38.png" style="width: 198px; height: 133px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>
	<li>All the edges are distinct.</li>
	<li>The input is generated such that <code>edges</code> can form a 2D grid that satisfies the conditions.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/construct-binary-palindrome-by-repeated-appending-and-trimming1005/1" target="_blank" rel="noopener noreferrer">Construct binary palindrome by repeated appending and trimming</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">binaryrepresentation</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">palindrome</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given two integers <strong>n</strong> and <strong>k</strong>. Your task is to create a palindrome of length <strong>n</strong> using binary numbers (0s and 1s) of length <strong>k </strong>that starts with 1. You can repeat the binary number as many times as you need, and you are allowed to remove any zeros from the end of the final palindrome.</span></p>
<p><span style="font-size: 14pt;">The palindrome must always start with <strong>1</strong> and should have as many zeros as possible. If it is not possible to create such a palindrome of length <strong>n</strong> using any binary number of length <strong>k</strong>, return <strong>-1</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> n = 5, k = 3
<strong>Output:</strong> 11011
<strong>Explanation:</strong> Since only length of 3 binary digits are allowed, so the possible binary representations are 100, 110, 111, 101. Out of these, If we take the binary representation of 6(110), combine it twice &amp; trim a zero the final output will be 11011, which satisfy all the conditions</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 6, k = 1
<strong>Output: </strong>111111
<strong>Explanation:</strong> <br />The binary representation of 1 is 1 of length 1, it is combined six times to produce 111111.</span></pre>
<p><span style="font-size: 14pt;"><strong>Expected Time Complexity:</strong>&nbsp;O(n).<br /><strong>Expected Auxiliary Space:</strong> O(1).</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, k &le; 10<sup>6</sup><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-lucky-permutations--170645/1" target="_blank" rel="noopener noreferrer">Count Lucky Permutations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You are given an array <strong>arr[ ]&nbsp;</strong>of integers having <strong>N&nbsp;</strong>elements and a non-weighted&nbsp;undirected graph having <strong>N</strong> nodes and&nbsp;<strong>M&nbsp;</strong>edges. The details of each edge in the graph is given to you in the form of list of list.&nbsp;<br />
Your task is to find the number of lucky permutations of the&nbsp;given array.<strong>&nbsp;</strong></span></p>

<blockquote>
<p><span style="font-size:18px">An array permutation is said to be lucky if for every node <strong>V<sub>i&nbsp; </sub>[1 &lt;= i &lt;= N-1]</strong> in the array there exists an edge between the nodes&nbsp;<strong>V</strong><sub><strong>i</strong>&nbsp;</sub>and <strong>V<sub>i+1&nbsp;</sub></strong>in the given graph.</span></p>
</blockquote>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 3, M = 2
arr = {1, 2, 3}
graph = {{3, 1}, {1, 2}}
<strong>Output:
</strong>2
<strong>Explanation:
</strong>All possible permutations of the 
array are as follows-
{1,2,3}: There is an edge between 1 and 
2 in the graph but not betwen 2 and 3.

{2,1,3}: There is an edge between (2,1)
and (1,3) in the graph.

{3,1,2}: There is an edge between (3,1)
and (1,2) in the graph.

Out of the 3 possible permutations, 
2 are lucky. Therefore, answer is 2.</span>

</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 2, M = 1
arr = {1, 1}
graph = {{1, 2}}
<strong>Output :</strong>
0
<strong>Explanation:</strong>
There is no lucky permutation in the 
given graph. 
</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>luckyPermutations()</strong>&nbsp;which takes the two integers <strong>N </strong>and <strong>M,&nbsp;</strong>an array <strong>arr[ ]&nbsp;</strong>and a list of lists named <strong>graph&nbsp;</strong>of size <strong>M</strong>&nbsp;as input parameters and returns the count of lucky permutations.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>*2<sup>N</sup>)<br />
<strong>Expected Auxiliary Space:</strong> O(N*2<sup>N</sup>)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
2 &le; N &le; 15<br />
1 &le; M&nbsp;&le; (N*(N-1))/2<br />
1&nbsp;&le;&nbsp; arr[i], graph[i][j] &le; N&nbsp;<br />
There are no self-loops and repeated edges in the graph.</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-of-nodes/description" target="_blank" rel="noopener noreferrer">Count Pairs Of Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected graph defined by an integer <code>n</code>, the number of nodes, and a 2D integer array <code>edges</code>, the edges in the graph, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an <strong>undirected</strong> edge between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>. You are also given an integer array <code>queries</code>.</p>

<p>Let <code>incident(a, b)</code> be defined as the <strong>number of edges</strong> that are connected to <strong>either</strong> node <code>a</code> or <code>b</code>.</p>

<p>The answer to the <code>j<sup>th</sup></code> query is the <strong>number of pairs</strong> of nodes <code>(a, b)</code> that satisfy <strong>both</strong> of the following conditions:</p>

<ul>
	<li><code>a &lt; b</code></li>
	<li><code>incident(a, b) &gt; queries[j]</code></li>
</ul>

<p>Return <em>an array </em><code>answers</code><em> such that </em><code>answers.length == queries.length</code><em> and </em><code>answers[j]</code><em> is the answer of the </em><code>j<sup>th</sup></code><em> query</em>.</p>

<p>Note that there can be <strong>multiple edges</strong> between the same two nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/winword_2021-06-08_00-58-39.png" style="width: 529px; height: 305px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
<strong>Output:</strong> [6,5]
<strong>Explanation:</strong> The calculations for incident(a, b) are shown in the table above.
The answers for each of the queries are as follows:
- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.
- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
<strong>Output:</strong> [10,10,9,8,6]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>0 &lt;= queries[j] &lt; edges.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-complete-components/description" target="_blank" rel="noopener noreferrer">Count the Number of Complete Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> vertices, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>Return <em>the number of <strong>complete connected components</strong> of the graph</em>.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>A connected component is said to be <b>complete</b> if there exists an edge between every pair of its vertices.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png" style="width: 671px; height: 270px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> From the picture above, one can see that all of the components of this graph are complete.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png" style="width: 671px; height: 270px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Before diving into the solution, let’s clarify what a <strong>complete connected component</strong> is. A complete connected component is a set of nodes and edges in a graph (also known as a subgraph) that satisfies the following conditions:</p>
<ul>
<li>It is <strong>connected</strong>, meaning every pair of vertices in the subgraph is reachable through some path, and no vertex connects to another component.</li>
<li>It is <strong>complete</strong>, meaning every vertex in the component has a direct edge to every other vertex. Notice that every complete subgraph is also a connected subgraph, but the reverse is not always true.</li>
</ul>
<p>In simpler terms, we are looking for connected subgraphs that form perfect <a href="https://en.wikipedia.org/wiki/Clique_(graph_theory)">cliques</a> - where each vertex is directly connected to all others within the component.</p>
<p><img src="../Figures/2685/subgraphs.png" alt="types of subgraph" /></p>
<blockquote>
<p>A strong grasp of fundamental graph algorithms like Depth-First Search, Breadth-First Search, and Disjoint Set Union is essential for understanding the solutions ahead. If you need a refresher or want to explore these concepts further, check out the <a href="https://leetcode.com/explore/learn/card/graph/">Graph Explore Card</a>. This resource provides an in-depth look at key graph algorithms, their applications, and a variety of problems to reinforce the underlying patterns.</p>
</blockquote>
<hr />
<h3 id="approach-1-adjacency-list">Approach 1: Adjacency List</h3>
<h4 id="intuition">Intuition</h4>
<p>The most common way to represent a graph is through an adjacency list, where each node points to a list of all the nodes it is directly connected to.</p>
<p>For example, consider a graph where vertices <code>0</code>, <code>1</code>, and <code>2</code> form a complete component. Their adjacency lists would look like this:</p>
<ul>
<li>Vertex <code>0</code>’s neighbors: <code>[1, 2]</code></li>
<li>Vertex <code>1</code>’s neighbors: <code>[0, 2]</code></li>
<li>Vertex <code>2</code>’s neighbors: <code>[0, 1]</code></li>
</ul>
<p>Now, let’s take a moment to include each vertex as its own neighbor. This does not violate any constraints since every node is naturally reachable from itself. After this adjustment, the adjacency lists would look like:</p>
<ul>
<li>Vertex <code>0</code>’s neighbors: <code>[0, 1, 2]</code></li>
<li>Vertex <code>1</code>’s neighbors: <code>[0, 1, 2]</code></li>
<li>Vertex <code>2</code>’s neighbors: <code>[0, 1, 2]</code></li>
</ul>
<p>This leads to a key insight: in a complete connected component, every vertex must have the exact same set of neighbors (including itself). This forms a unique &quot;adjacency pattern&quot; that is shared by all vertices in the same component.</p>
<p>Let us create the adjacency list for the graph and include each vertex as a neighbor in its own list. Now, we need to identify all vertices that share the same neighbor pattern.</p>
<p>To do this, we can use a hash map where the key represents a unique neighbor pattern, and the value keeps track of how many times this pattern appears in the graph. However, there may be cases where two neighbor patterns are the same but appear differently in the adjacency list (for example, <code>0: [0, 1, 2]</code> and <code>2: [2, 1, 0]</code>). To ensure they are grouped together, we first sort each neighbor list before adding it to the map.</p>
<p>Next, we go through each entry in the map to count how many unique patterns were collected. But one final check is needed: the size of the adjacency list must match the number of vertices that share this pattern. In other words, the size of the list should be equal to its frequency of occurrence in the map.</p>
<p>Why? Because in a complete component with <code>k</code> vertices, each vertex must have exactly <code>k</code> neighbors (including itself). And exactly <code>k</code> vertices must share this pattern - one for each member of the component.</p>
<p>Finally, we count the number of entries in the map that pass this validation and return this count as our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>an array of adjacency lists called <code>graph</code> with size <code>n</code>.</li>
<li>a hash map <code>componentFreq</code> to track frequencies of unique adjacency lists.</li>
</ul>
</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Initialize the adjacency list for the current vertex and add the vertex itself (self-loop).</li>
</ul>
</li>
<li>Build the graph by looping through each <code>edge = [u, v]</code> in the <code>edges</code> array:
<ul>
<li>Push <code>v</code> into <code>u</code>'s adjacency list (<code>graph[u]</code>).</li>
<li>Push <code>u</code> into <code>v</code>'s adjacency list (<code>graph[v]</code>).</li>
</ul>
</li>
<li>For each vertex from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Get and sort its list of neighbors.</li>
<li>Increment the frequency count for this specific adjacency pattern in the <code>componentFreq</code> map.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Iterate through each entry in the <code>componentFreq</code> map:
<ul>
<li>If the size of the adjacency list equals its frequency count, increment <code>completeCount</code>.</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/g4GoucsF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \log n)\)</span></p>
<p>The solution's time complexity stems from several operations. Initializing the adjacency lists requires <span class="math inline">\(O(n)\)</span> time as we create a list for each vertex. When building the adjacency lists from the edges, we spend <span class="math inline">\(O(m)\)</span> time adding each edge to the lists of both vertices it connects.</p>
<p>The most expensive operation comes when we sort each vertex's adjacency list, which costs <span class="math inline">\(O(d_i \log d_i)\)</span> for a vertex with degree <span class="math inline">\(d_i\)</span>. Across all vertices, this sorting accounts for <span class="math inline">\(O(\sum_{i=0}^{n-1} d_i \log d_i)\)</span> time. Since <span class="math inline">\(\sum d_i = 2m\)</span> and the maximum degree is bounded by <span class="math inline">\(n\)</span>, this simplifies to <span class="math inline">\(O(m \log n)\)</span> in the worst case. The final operations of processing vertices and counting complete components take <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is dominated by the sorting step, giving us <span class="math inline">\(O(n + m \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m + S)\)</span></p>
<p>For space complexity, we use memory for the adjacency list array itself, which requires <span class="math inline">\(O(n)\)</span> space. The contents of all adjacency lists collectively require space proportional to the number of edges, contributing <span class="math inline">\(O(m)\)</span> to our space usage.</p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span> .</li>
</ul>
<p>While the hash map stores references to these same adjacency lists, it doesn't significantly increase the asymptotic space complexity. Each unique component pattern may be stored once in the hash map, but the total size of all stored patterns remains bounded by the total size of all adjacency lists, which is <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m + S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-dfs">Approach 2: Depth-First Search (DFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's now return to traditional graph traversal techniques to solve this problem. Depth-first search (DFS) is particularly well-suited for this task. Starting from an unvisited vertex, DFS explores as far as possible along a branch before backtracking, ensuring that every vertex reachable from the starting point is visited.</p>
<p>But how do we determine if a component is complete? One approach is to check every pair of vertices in the component to see if they share an edge, but this would be inefficient.</p>
<p>Instead, we can take advantage of a key property of complete graphs: in a complete graph with <span class="math inline">\(n\)</span> vertices, there must be exactly <span class="math inline">\(\frac{n \cdot (n-1)}{2}\)</span> unique edges - equal to the number of pairs of nodes in the graph. Since our graph is undirected but our adjacency list counts each edge twice (once from each endpoint), the total edge count from the adjacency lists should be <span class="math inline">\(n \cdot (n-1)\)</span>.</p>
<p>During our DFS traversal, we will track two crucial pieces of information for each component:</p>
<ol>
<li>The number of vertices in the component.</li>
<li>The total number of edges connected to vertices in the component.</li>
</ol>
<p>For each new vertex we visit, we increment the vertex count and add all its edges to the total edge count. Once the traversal is complete, we check if the gathered values match the expected count. We keep track of all components that meet this condition, and after visiting all vertices, we return this count as our final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an array of adjacency lists called <code>graph</code> with size <code>n</code> to represent the undirected graph.</li>
<li>Build the graph by looping through each edge in the <code>edges</code> array:
<ul>
<li>Add each vertex to the other's adjacency list.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Create a hash set <code>visited</code> to keep track of visited vertices.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Skip if the <code>vertex</code> has already been visited.</li>
<li>Initialize an array <code>componentInfo</code> with two elements to track: <code>[0]</code>: number of vertices and <code>[1]</code>: total edges.</li>
<li>Call the <code>dfs</code> function starting from the current <code>vertex</code>.</li>
<li>Check if the component is complete by comparing the number of edges to <code>vertices * (vertices - 1)</code>.</li>
<li>Increment <code>completeCount</code> if the condition is met.</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<p>Helper method <code>dfs(curr, graph, visited, componentInfo)</code>:</p>
<ul>
<li>Mark the current vertex as visited.</li>
<li>Increment the vertex count in <code>componentInfo[0]</code>.</li>
<li>Add the number of edges from the current vertex to <code>componentInfo[1]</code>.</li>
<li>Recursively explore all unvisited neighbors of the current vertex.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/keZDcvFS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The algorithm begins with graph initialization, where populating the adjacency list by processing <span class="math inline">\(m\)</span> edges requires <span class="math inline">\(O(m)\)</span>, since each edge is added to two lists.</p>
<p>The core of the solution is a DFS traversal, which visits each vertex once and explores all edges connected to it. Since each edge is considered at most twice (once from each endpoint), DFS runs in <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Summing these components, the overall time complexity remains <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list representation requires <span class="math inline">\(O(n)\)</span> for the array and <span class="math inline">\(O(m)\)</span> for the edge storage. The <code>visited</code> set stores at most <span class="math inline">\(O(n)\)</span> vertices, while the recursive DFS calls can create a call stack of size <span class="math inline">\(O(n)\)</span> in the worst case. The <code>componentInfo</code> array uses constant space.</p>
<p>Combining these, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>, dominated by the graph representation and recursion stack.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-breadth-first-search-bfs">Approach 3: Breadth-First Search (BFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The other quintessential graph traversal algorithm is the Breadth-First Search (BFS), which can also be used to solve this problem.</p>
<p>BFS explores each component using a queue. We maintain a <code>visited</code> array to track which vertices have been visited. When we encounter an unvisited vertex, we add it to the queue and begin exploring its connected component.</p>
<p>Along with the queue, we maintain a list called <code>component</code> to store all vertices belonging to the current component. Once the exploration is complete, we need to verify whether the component is fully connected. For a component with <code>k</code> vertices to be complete, every vertex must have exactly <code>k - 1</code> edges connecting it to the other vertices within the component.</p>
<p>After finishing the BFS traversal for a component, we iterate through the gathered vertices in <code>component</code>. If the size of the component is <code>k</code> and each vertex has exactly <code>k - 1</code> edges, we confirm that it is a complete component and increment our count.</p>
<p>Once all vertices in the graph have been explored, we return this count as our final answer.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize an array of adjacency lists called <code>graph</code> with size <code>n</code> to represent the undirected graph.</li>
<li>Build the graph by looping through each edge in the <code>edges</code> array:
<ul>
<li>Add each vertex to the other's adjacency list.</li>
</ul>
</li>
<li>Create a boolean array <code>visited</code> of size <code>n</code> to track visited vertices.</li>
<li>Initialize a counter variable <code>completeComponents</code> to zero.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Skip if the <code>vertex</code> has already been visited.</li>
<li>Create a list called <code>component</code> to store vertices in the current component.</li>
<li>Initialize a <code>queue</code> and add the current vertex to it.</li>
<li>Mark the current <code>vertex</code> as visited.</li>
<li>Perform BFS:
<ul>
<li>Poll the next vertex from the queue.</li>
<li>Add it to the component list.</li>
<li>Process all unvisited neighbors by adding them to the queue and marking them as visited.</li>
</ul>
</li>
<li>After BFS completes, check if the component is complete:
<ul>
<li>Initialize <code>isComplete</code> as <code>true</code>.</li>
<li>For each <code>node</code> in the component:
<ul>
<li>Check if the number of its neighbors equals <code>component.size - 1</code>.</li>
<li>If not, set <code>isComplete</code> to <code>false</code> and break.</li>
</ul>
</li>
</ul>
</li>
<li>If the component is complete, increment <code>completeComponents</code>.</li>
</ul>
</li>
<li>Return the final value of <code>completeComponents</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RgcCySnK/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The solution first builds an adjacency list representation, which takes <span class="math inline">\(O(n)\)</span> time for initialization and <span class="math inline">\(O(m)\)</span> time to add all edges. Then, for each unvisited vertex, we perform a BFS traversal that visits each vertex and edge exactly once across all components, taking <span class="math inline">\(O(n + m)\)</span> time in total.</p>
<p>For each component found, we check if it's complete by examining the degree of each vertex in the component, which cumulatively takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list requires <span class="math inline">\(O(n + m)\)</span> space: <span class="math inline">\(O(n)\)</span> for the array of lists and <span class="math inline">\(O(m)\)</span> for storing all edges. The visited array requires <span class="math inline">\(O(n)\)</span> space. The queue used in BFS and the list to store component vertices can each contain at most <span class="math inline">\(O(n)\)</span> vertices.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-disjoint-set-union-union-find">Approach 4: Disjoint Set Union (Union-Find)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>A complete connected component has a distinct property: it is a disjoint unit of the graph, meaning it does not share any connections with other parts of the graph. Our task is to identify these disjoint units and check whether their vertices and edges meet the criteria for completeness and connectivity.</p>
<p>One of the most effective ways to find separate groups in a graph is by using the Union-Find algorithm (also known as Disjoint Set Union). This method helps group vertices that belong together. Each group has a representative vertex, known as the leader, which serves as the group's identifier. To determine whether two vertices belong to the same group, we simply check if they share the same leader.</p>
<p>In our Union-Find implementation, we also track the size of each component. Maintaining size is not only useful for optimizing the merging of components - since attaching a smaller component to a larger one is more efficient - but also plays a crucial role in this problem: it tells us exactly how many vertices exist in each component. To verify whether a component is a valid complete connected component, we check if its edge count matches <span class="math inline">\(\frac{k \cdot (k - 1)}{2}\)</span>, where <span class="math inline">\(k\)</span> is the number of vertices in the component.</p>
<p>Now, let’s implement our solution. First, we initialize a Union-Find structure and perform the &quot;union&quot; operation for each edge in our input. Since an edge signifies that two vertices belong to the same component, applying &quot;union&quot; to all edges ensures that all vertices are grouped correctly.</p>
<p>Next, we count the number of edges in each component. To do this, we use a hash map that associates each component with its edge count. Since Union-Find assigns each component a unique representative (the root of its tree), we use these representatives as keys in the map.</p>
<p>Finally, we iterate through each group leader and check if the group forms a complete component. A group is complete if its edge count equals <span class="math inline">\(\frac{k \cdot (k - 1)}{2}\)</span>. If it does, we increment our final count. Once all components have been processed, we return the total number of complete components as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Create a <code>UnionFind</code> data structure <code>dsu</code> to track connected components in the graph.</li>
<li>Initialize a hash map <code>edgeCount</code> to track the number of edges in each component.</li>
<li>Loop through each edge in the <code>edges</code> array:
<ul>
<li>Join the two vertices using the <code>union</code> operation.</li>
</ul>
</li>
<li>Loop through the <code>edges</code> again:
<ul>
<li>Find the root of the component containing the first vertex of each edge.</li>
<li>Increment the edge count for that component in the <code>edgeCount</code> map.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If the <code>vertex</code> is a root (representative) of its component:
<ul>
<li>Calculate the expected number of edges for a complete component with that many vertices: <code>(size[vertex] * (size[vertex] - 1)) / 2</code>.</li>
</ul>
</li>
<li>Compare the actual edge count with the expected edge count.
<ul>
<li>If they match, increment <code>completeCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<p>Helper class <code>UnionFind</code>:</p>
<ul>
<li>
<p>Initialize a <code>UnionFind</code> class with two instance variables:</p>
<ul>
<li>An array <code>parent</code> to track the parent of each node.</li>
<li>An array <code>size</code> to track the size of each component.</li>
</ul>
</li>
<li>
<p>In the constructor <code>dsu(n)</code>:</p>
<ul>
<li>Initialize both arrays with size <code>n</code>.</li>
<li>Fill the <code>parent</code> array with <code>-1</code> to indicate each node is its own parent initially.</li>
<li>Fill the <code>size</code> array with <code>1</code> as each node starts in its own single-node component.</li>
</ul>
</li>
<li>
<p>In the <code>find(node)</code> method:</p>
<ul>
<li>Check if the node's parent is <code>-1</code> (indicating it's a root).</li>
<li>If it is a root, return the <code>node</code> itself.</li>
<li>Otherwise, recursively find the root and update the <code>node</code>'s parent (path compression).</li>
</ul>
</li>
<li>
<p>In the <code>union(node1, node2)</code> method:</p>
<ul>
<li>Find the roots of nodes <code>node1</code> and <code>node2</code> using the <code>find</code> method.</li>
<li>If both nodes already belong to the same component (same root), return early.</li>
<li>Apply union-by-size strategy:
<ul>
<li>If the component containing <code>node1</code> is larger:
<ul>
<li>Make <code>root1</code> the parent of <code>root2</code>.</li>
<li>Add the size of <code>root2</code>'s component to <code>root1</code>'s component size.</li>
</ul>
</li>
<li>Otherwise, make <code>root2</code> the parent of <code>root1</code> and alter size accordingly.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/RYozofJc/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m\alpha(n))\)</span></p>
<p>The solution uses a Union-Find data structure with path compression and union by size. Building the Union-Find structure takes <span class="math inline">\(O(n)\)</span> time for initialization. Processing all edges through union operations takes <span class="math inline">\(O(m\alpha(n))\)</span> time, where <span class="math inline">\(\alpha(n)\)</span> is the inverse Ackermann function, which grows extremely slowly and is practically constant.</p>
<p>Counting edges in each component requires iterating through all edges again, taking <span class="math inline">\(O(m)\)</span> time. Finally, checking if each component is complete involves iterating through all vertices once, taking <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n + m\alpha(n))\)</span>, which is essentially linear in practice.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The Union-Find data structure uses two arrays of size <span class="math inline">\(n\)</span> for parent pointers and component sizes, requiring <span class="math inline">\(O(n)\)</span> space. The edge count map stores at most <span class="math inline">\(n\)</span> entries (one for each potential component root), requiring <span class="math inline">\(O(n)\)</span> space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-i/description" target="_blank" rel="noopener noreferrer">Count the Number of Houses at a Certain Distance I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three <strong>positive</strong> integers <code>n</code>, <code>x</code>, and <code>y</code>.</p>

<p>In a city, there exist houses numbered <code>1</code> to <code>n</code> connected by <code>n</code> streets. There is a street connecting the house numbered <code>i</code> with the house numbered <code>i + 1</code> for all <code>1 &lt;= i &lt;= n - 1</code> . An additional street connects the house numbered <code>x</code> with the house numbered <code>y</code>.</p>

<p>For each <code>k</code>, such that <code>1 &lt;= k &lt;= n</code>, you need to find the number of <strong>pairs of houses</strong> <code>(house<sub>1</sub>, house<sub>2</sub>)</code> such that the <strong>minimum</strong> number of streets that need to be traveled to reach <code>house<sub>2</sub></code> from <code>house<sub>1</sub></code> is <code>k</code>.</p>

<p>Return <em>a <strong>1-indexed</strong> array </em><code>result</code><em> of length </em><code>n</code><em> where </em><code>result[k]</code><em> represents the <strong>total</strong> number of pairs of houses such that the <strong>minimum</strong> streets required to reach one house from the other is </em><code>k</code>.</p>

<p><strong>Note</strong> that <code>x</code> and <code>y</code> can be <strong>equal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example2.png" style="width: 474px; height: 197px;" />
<pre>
<strong>Input:</strong> n = 3, x = 1, y = 3
<strong>Output:</strong> [6,0,0]
<strong>Explanation:</strong> Let&#39;s look at each pair of houses:
- For the pair (1, 2), we can go from house 1 to house 2 directly.
- For the pair (2, 1), we can go from house 2 to house 1 directly.
- For the pair (1, 3), we can go from house 1 to house 3 directly.
- For the pair (3, 1), we can go from house 3 to house 1 directly.
- For the pair (2, 3), we can go from house 2 to house 3 directly.
- For the pair (3, 2), we can go from house 3 to house 2 directly.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example3.png" style="width: 668px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 5, x = 2, y = 4
<strong>Output:</strong> [10,8,2,0,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).
- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).
- For k == 3, the pairs are (1, 5), and (5, 1).
- For k == 4 and k == 5, there are no pairs.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example5.png" style="width: 544px; height: 130px;" />
<pre>
<strong>Input:</strong> n = 4, x = 1, y = 1
<strong>Output:</strong> [6,4,2,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).
- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).
- For k == 3, the pairs are (1, 4), and (4, 1).
- For k == 4, there are no pairs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= x, y &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-ii/description" target="_blank" rel="noopener noreferrer">Count the Number of Houses at a Certain Distance II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three <strong>positive</strong> integers <code>n</code>, <code>x</code>, and <code>y</code>.</p>

<p>In a city, there exist houses numbered <code>1</code> to <code>n</code> connected by <code>n</code> streets. There is a street connecting the house numbered <code>i</code> with the house numbered <code>i + 1</code> for all <code>1 &lt;= i &lt;= n - 1</code> . An additional street connects the house numbered <code>x</code> with the house numbered <code>y</code>.</p>

<p>For each <code>k</code>, such that <code>1 &lt;= k &lt;= n</code>, you need to find the number of <strong>pairs of houses</strong> <code>(house<sub>1</sub>, house<sub>2</sub>)</code> such that the <strong>minimum</strong> number of streets that need to be traveled to reach <code>house<sub>2</sub></code> from <code>house<sub>1</sub></code> is <code>k</code>.</p>

<p>Return <em>a <strong>1-indexed</strong> array </em><code>result</code><em> of length </em><code>n</code><em> where </em><code>result[k]</code><em> represents the <strong>total</strong> number of pairs of houses such that the <strong>minimum</strong> streets required to reach one house from the other is </em><code>k</code>.</p>

<p><strong>Note</strong> that <code>x</code> and <code>y</code> can be <strong>equal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example2.png" style="width: 474px; height: 197px;" />
<pre>
<strong>Input:</strong> n = 3, x = 1, y = 3
<strong>Output:</strong> [6,0,0]
<strong>Explanation:</strong> Let&#39;s look at each pair of houses:
- For the pair (1, 2), we can go from house 1 to house 2 directly.
- For the pair (2, 1), we can go from house 2 to house 1 directly.
- For the pair (1, 3), we can go from house 1 to house 3 directly.
- For the pair (3, 1), we can go from house 3 to house 1 directly.
- For the pair (2, 3), we can go from house 2 to house 3 directly.
- For the pair (3, 2), we can go from house 3 to house 2 directly.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example3.png" style="width: 668px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 5, x = 2, y = 4
<strong>Output:</strong> [10,8,2,0,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).
- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).
- For k == 3, the pairs are (1, 5), and (5, 1).
- For k == 4 and k == 5, there are no pairs.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example5.png" style="width: 544px; height: 130px;" />
<pre>
<strong>Input:</strong> n = 4, x = 1, y = 1
<strong>Output:</strong> [6,4,2,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).
- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).
- For k == 3, the pairs are (1, 4), and (4, 1).
- For k == 4, there are no pairs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= x, y &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-the-paths4332/1" target="_blank" rel="noopener noreferrer">Count the paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a Directed Acyclic Graph (DAG) with <strong><code>V</code></strong> nodes labeled from <strong><code>0</code></strong> to <strong><code>V-1</code></strong>, and a list of directed edges, count the total number of distinct paths from a given <strong><code>start</code></strong> node to a <code><strong>destination</strong></code> node. Each edge is represented as <strong><code>edges[i] = [u, v]</code></strong>, indicating a directed edge from <strong><code>u</code></strong> to <strong><code>v</code></strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>edges[][] = [[0,1], [0,3], [2,0], [2,1], [1,3]], V = 4, src = 2, dest = 3<br /><strong>Output: </strong>3
<strong>Explanation: </strong></span><span style="font-size: 14pt;">There are three ways to reach at 3 from 2. These are: 2 -&gt; 1 -&gt; 3, 2 -&gt; 0 -&gt; 3 and 2 -&gt; 0 -&gt; 1 -&gt; 3.<br /><img src="https://media.geeksforgeeks.org/wp-content/uploads/20250421154205101614/Print-all-paths-1.webp" alt="Print-all-paths-1" /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>edges[][] = [[0,1], [1,2], [1,3], [2,3]], V = 4, src = 0, dest = 3
<strong>Output: </strong>2
<strong>Explanation: </strong>There is two way to reach at 3 from 0 that is : 0 -&gt; 1 -&gt; 2 -&gt; 3 and 0 -&gt; 1 -&gt; 3.<br /><img src="https://media.geeksforgeeks.org/wp-content/uploads/20250524103856837397/Print-all-paths-2.webp" alt="Print-all-paths-2" /></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br /><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">2&nbsp;&nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">&le;</span><span style="color: #1e2229; font-family: Nunito; font-size: 17px; background-color: #ffffff;">&nbsp;&nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">V&nbsp;&nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">&le;</span><span style="color: #1e2229; font-family: Nunito; font-size: 17px; background-color: #ffffff;">&nbsp;&nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">10<span style="box-sizing: border-box; line-height: 0; position: relative; vertical-align: baseline; top: -0.5em; font-size: 17px !important;">3</span><br style="box-sizing: border-box; font-size: 17px !important;" />1&nbsp;&nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">&le;</span><span style="color: #1e2229; font-family: Nunito; font-size: 17px; background-color: #ffffff;"> &nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;"> E = </span><span style="box-sizing: border-box; font-family: Nunito; font-size: 14pt; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">edges.size()</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">&nbsp;&nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">&le;</span><span style="color: #1e2229; font-family: Nunito; font-size: 17px; background-color: #ffffff;">&nbsp;&nbsp;</span><span style="box-sizing: border-box; font-family: Nunito; color: #1e2229; background-color: #ffffff; line-height: 1.8em !important;">(V * (V - 1)) / 2</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description" target="_blank" rel="noopener noreferrer">Count Unreachable Pairs of Nodes in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> nodes, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>Return <em>the <strong>number of pairs</strong> of different nodes that are <strong>unreachable</strong> from each other</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/05/tc-3.png" style="width: 267px; height: 169px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[0,2],[1,2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/05/tc-2.png" style="width: 295px; height: 269px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
<strong>Output:</strong> 14
<strong>Explanation:</strong> There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-visited-nodes-in-a-directed-graph/description" target="_blank" rel="noopener noreferrer">Count Visited Nodes in a Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed</strong> graph consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and <code>n</code> directed edges.</p>

<p>You are given a <strong>0-indexed</strong> array <code>edges</code> where <code>edges[i]</code> indicates that there is an edge from node <code>i</code> to node <code>edges[i]</code>.</p>

<p>Consider the following process on the graph:</p>

<ul>
	<li>You start from a node <code>x</code> and keep visiting other nodes through edges until you reach a node that you have already visited before on this <strong>same</strong> process.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> where </em><code>answer[i]</code><em> is the number of <strong>different</strong> nodes that you will visit if you perform the process starting from node </em><code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/31/graaphdrawio-1.png" />
<pre>
<strong>Input:</strong> edges = [1,2,0,0]
<strong>Output:</strong> [3,3,3,4]
<strong>Explanation:</strong> We perform the process starting from each node in the following way:
- Starting from node 0, we visit the nodes 0 -&gt; 1 -&gt; 2 -&gt; 0. The number of different nodes we visit is 3.
- Starting from node 1, we visit the nodes 1 -&gt; 2 -&gt; 0 -&gt; 1. The number of different nodes we visit is 3.
- Starting from node 2, we visit the nodes 2 -&gt; 0 -&gt; 1 -&gt; 2. The number of different nodes we visit is 3.
- Starting from node 3, we visit the nodes 3 -&gt; 0 -&gt; 1 -&gt; 2 -&gt; 0. The number of different nodes we visit is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/31/graaph2drawio.png" style="width: 191px; height: 251px;" />
<pre>
<strong>Input:</strong> edges = [1,2,3,4,0]
<strong>Output:</strong> [5,5,5,5,5]
<strong>Explanation:</strong> Starting from any node we can visit every node in the graph in the process.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges[i] &lt;= n - 1</code></li>
	<li><code>edges[i] != i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/description" target="_blank" rel="noopener noreferrer">Count Ways to Build Rooms in an Ant Colony</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">combinatorics</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are an ant tasked with adding <code>n</code> new rooms numbered <code>0</code> to <code>n-1</code> to your colony. You are given the expansion plan as a <strong>0-indexed</strong> integer array of length <code>n</code>, <code>prevRoom</code>, where <code>prevRoom[i]</code> indicates that you must build room <code>prevRoom[i]</code> before building room <code>i</code>, and these two rooms must be connected <strong>directly</strong>. Room <code>0</code> is already built, so <code>prevRoom[0] = -1</code>. The expansion&nbsp;plan is given such that once all the rooms are built, every room will be reachable from room <code>0</code>.</p>

<p>You can only build <strong>one room</strong> at a time, and you can travel freely between rooms you have <strong>already built</strong> only if they are <strong>connected</strong>.&nbsp;You can choose to build <strong>any room</strong> as long as its <strong>previous room</strong>&nbsp;is already built.</p>

<p>Return <em>the <strong>number of different orders</strong> you can build all the rooms in</em>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/19/d1.JPG" style="width: 200px; height: 212px;" />
<pre>
<strong>Input:</strong> prevRoom = [-1,0,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong>&nbsp;There is only one way to build the additional rooms: 0 &rarr; 1 &rarr; 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/19/d2.JPG" style="width: 200px; height: 239px;" /></strong>

<pre>
<strong>Input:</strong> prevRoom = [-1,0,0,1,2]
<strong>Output:</strong> 6
<strong>Explanation:
</strong>The 6 ways are:
0 &rarr; 1 &rarr; 3 &rarr; 2 &rarr; 4
0 &rarr; 2 &rarr; 4 &rarr; 1 &rarr; 3
0 &rarr; 1 &rarr; 2 &rarr; 3 &rarr; 4
0 &rarr; 1 &rarr; 2 &rarr; 4 &rarr; 3
0 &rarr; 2 &rarr; 1 &rarr; 3 &rarr; 4
0 &rarr; 2 &rarr; 1 &rarr; 4 &rarr; 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == prevRoom.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>prevRoom[0] == -1</code></li>
	<li><code>0 &lt;= prevRoom[i] &lt; n</code> for all <code>1 &lt;= i &lt; n</code></li>
	<li>Every room is reachable from room <code>0</code> once all the rooms are built.</li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/couples-holding-hands/description" target="_blank" rel="noopener noreferrer">Couples Holding Hands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> couples sitting in <code>2n</code> seats arranged in a row and want to hold hands.</p>

<p>The people and seats are represented by an integer array <code>row</code> where <code>row[i]</code> is the ID of the person sitting in the <code>i<sup>th</sup></code> seat. The couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2n - 2, 2n - 1)</code>.</p>

<p>Return <em>the minimum number of swaps so that every couple is sitting side by side</em>. A swap consists of choosing any two people, then they stand up and switch seats.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> row = [0,2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We only need to swap the second (row[1]) and third (row[2]) person.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> row = [3,2,0,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All couples are already seated side by side.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2n == row.length</code></li>
	<li><code>2 &lt;= n &lt;= 30</code></li>
	<li><code>n</code> is even.</li>
	<li><code>0 &lt;= row[i] &lt; 2n</code></li>
	<li>All the elements of <code>row</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/course-schedule/1" target="_blank" rel="noopener noreferrer">Course Schedule</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are a total of <strong>n</strong> tasks you have to pick, labelled from <strong>0 to n-1</strong>. Some tasks may have <strong>prerequisites[][] </strong>tasks, for example to pick task <strong>0</strong> you have to first finish tasks <strong>1</strong>, which is expressed as a pair: <strong>[0, 1]</strong><br />Given the total number of <strong>n</strong> tasks and a list of prerequisite pairs of size <strong>m</strong>. Find a ordering of tasks you should pick to finish all tasks.</span><br /><span style="font-size: 18px;"><strong>Note: </strong>There may be multiple correct orders, you just need to return any one of them. If it is impossible to finish all tasks, return an empty array. </span><span style="font-size: 18px;">Returning any correct order will give the output as <strong>true</strong></span><span style="font-size: 18px;">, whereas any invalid order will give the output <strong>false</strong></span><span style="font-size: 18px;">.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, prerequisites[][] = [[1, 0]]
<strong>Output: </strong>true<strong>
Explanation: </strong></span><span style="font-size: 18px;">Only possible order is [0, 1].</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, prerequisites[][] = [[1, 0], [2, 0], [3, 1], [3, 2]]
<strong>Output: </strong>true<strong>
Explanation: </strong>There are a total of 4 tasks to pick. To pick task 3 you should have finished both tasks 1 and 2. Both tasks 1 and 2 should be pick after you finished task 0. So one correct task order is [0, 1, 2, 3]. Another correct ordering is [0, 2, 1, 3]. Returning any of these order will result in an output of true.</span>
</pre>
<div><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>5</sup></span>
<div><span style="font-size: 18px;">0 &le; prerequisites[i][0], prerequisites[i][1] &lt; n<br />All prerequisite pairs are unique</span></div>
<div><span style="font-size: 18px;">prerequisites[i][0] &ne; prerequisites[i][1]</span></div>
</div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule/description" target="_blank" rel="noopener noreferrer">Course Schedule</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>
	<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule-ii/description" target="_blank" rel="noopener noreferrer">Course Schedule II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
<strong>Output:</strong> [0,2,1,3]
<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 1, prerequisites = []
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule-iv/description" target="_blank" rel="noopener noreferrer">Course Schedule IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>a<sub>i</sub></code> first if you want to take course <code>b<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code> indicates that you have to take course <code>0</code> before you can take course <code>1</code>.</li>
</ul>

<p>Prerequisites can also be <strong>indirect</strong>. If course <code>a</code> is a prerequisite of course <code>b</code>, and course <code>b</code> is a prerequisite of course <code>c</code>, then course <code>a</code> is a prerequisite of course <code>c</code>.</p>

<p>You are also given an array <code>queries</code> where <code>queries[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>. For the <code>j<sup>th</sup></code> query, you should answer whether course <code>u<sub>j</sub></code> is a prerequisite of course <code>v<sub>j</sub></code> or not.</p>

<p>Return <i>a boolean array </i><code>answer</code><i>, where </i><code>answer[j]</code><i> is the answer to the </i><code>j<sup>th</sup></code><i> query.</i></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg" style="width: 222px; height: 62px;" />
<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
<strong>Output:</strong> [false,true]
<strong>Explanation:</strong> The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
<strong>Output:</strong> [false,false]
<strong>Explanation:</strong> There are no prerequisites, and each course is independent.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
<strong>Output:</strong> [true,true]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= numCourses &lt;= 100</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2)</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= numCourses - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>unique</strong>.</li>
	<li>The prerequisites graph has no cycles.</li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= numCourses - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed graph representing course dependencies. The graph consists of <code>numCourses</code> nodes (denoted as <code>N</code> for simplicity) and <code>E</code> directed edges, where each edge is represented as a pair <code>(u, v)</code>. An edge <code>(u, v)</code> indicates that course <code>u</code> is a prerequisite for course <code>v</code>.</p>
<p>Additionally, we are given <code>Q</code> queries. Each query is a pair <code>(u, v)</code>, and the goal is to determine if course <code>u</code> is a prerequisite for course <code>v</code>.  The answer to each query should be <code>true</code> if <code>u</code> is a prerequisite of <code>v</code>, and <code>false</code> otherwise.</p>
<hr />
<h3 id="approach-1-tree-traversal---on-demand">Approach 1: Tree Traversal - On Demand</h3>
<h4 id="intuition">Intuition</h4>
<p>We can simplify the problem by recognizing that the answer to the query <code>(u, v)</code> is <code>true</code> if there exists a path from node <code>u</code> to node <code>v</code>. This is because the edges are directed to represent dependencies, so if we can reach node <code>v</code> from node <code>u</code>, it indicates that node <code>u</code> is a prerequisite for node <code>v</code>.</p>
<p>This relationship is an example of <em>transitive closure</em>. For instance, consider a path with three nodes: <code>u -&gt; v -&gt; w</code>.  In this case:</p>
<ul>
<li>Node <code>u</code> is a prerequisite for node <code>v</code></li>
<li>Node <code>v</code> is a prerequisite for node <code>w</code>. By transitivity, we can conclude that node <code>u</code> is also a prerequisite for node <code>w</code>.</li>
</ul>
<p>Therefore, the problem reduces to determining whether there exists a path between two nodes. To solve this, we can use <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth-First Search (DFS)</a> to explore the graph. Alternatively, other traversal methods like <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth-First Search (BFS)</a> can also be used. In this approach, we begin at node <code>u</code> and explore its adjacent nodes recursively until we reach node <code>v</code>. If we find node <code>v</code> during the traversal, we return <code>true</code>. If we exhaust all possible paths without reaching node <code>v</code>, we return <code>false</code>.</p>
<p>To efficiently track visited nodes and prevent revisiting them, we maintain a <code>visited</code> array. This array is reset for each query to ensure that each DFS traversal starts with a clean slate, avoiding interference from previous queries.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Define a function <code>isPrerequisite</code> that takes the adjacency list of the graph, a <code>visited</code> array, and two nodes <code>src</code> and <code>target</code>, and returns whether a path exists from <code>src</code> to <code>target</code>:</p>
<ul>
<li>Mark the current node <code>src</code> as visited.</li>
<li>If <code>src</code> is the same as <code>target</code>, return <code>true</code> (we found the path).</li>
<li>For each neighboring node <code>adj</code> of <code>src</code>:
<ul>
<li>If <code>adj</code> has not been visited yet, recursively call the DFS to check if a path exists from <code>adj</code> to <code>target</code>.</li>
</ul>
</li>
<li>Return the <code>true</code> if the result of at least one recursive call is <code>true</code> and <code>false</code> otherwise.</li>
</ul>
</li>
<li>
<p>Create the adjacency list <code>adjList</code> using the prerequisite pairs <code>[u, v]</code>.</p>
</li>
<li>
<p>For each query <code>[u, v]</code>, check if there is a path from <code>u</code> to <code>v</code> using DFS:</p>
<ul>
<li>Initialize a visited array with all entries as <code>false</code></li>
<li>Call the i<code>sPrerequisite</code> function to check if there exists a path from <code>u</code> to <code>v</code>.</li>
<li>Store the result for each query in a result list <code>answer</code>.</li>
</ul>
</li>
<li>
<p>Return <code>answer</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/33jKrZ6q/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(Q \cdot N ^2)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> time as we need to iterate over the list <code>prerequisites</code>. Then we iterate over queries and for each we perform DFS that can take <span class="math inline">\(O(V + E)\)</span> which is equivalent to <span class="math inline">\(O(N^2)\)</span>. Hence, the total time complexity equals <span class="math inline">\(O(Q \cdot N ^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The adjacency list requires <span class="math inline">\(O(N^2)\)</span> as it stores every edge in the list <code>prerequisites</code>. For the DFS traversal, we need a visited array of size <span class="math inline">\(O(N)\)</span> and the recursive stack for DFS calls requires <span class="math inline">\(O(N)\)</span> space in the worsts case. Therefore, the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-tree-traversal---preprocessed">Approach 2: Tree Traversal - Preprocessed</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This approach is similar to the previous one, where we traverse the graph to determine if there is a path from node <code>u</code> to node <code>v</code>. However, the key difference here is that instead of performing DFS/BFS for each query, we precompute the reachability for all nodes. Specifically, for each node <code>i</code> in the range from <code>0</code> to <code>N - 1</code>, we perform BFS (can do DFS as well) to identify all nodes that can be reached from <code>i</code> and store this information in a 2D array <code>isPrerequisite</code>.</p>
<p>A value of <code>isPrerequisite[u][v] = true</code> indicates that node <code>u</code> is a prerequisite for node <code>v</code>. During the BFS, starting from node <code>i</code>, we mark all nodes <code>adj</code> in the path as <code>isPrerequisite[i][adj] = true</code>, signifying that <code>i</code> is a prerequisite for <code>adj</code>. In the BFS process, instead of using a separate visited array, we will just use an <code>isPrerequisite</code> array. This is because if <code>isPrerequisite[i][adj]</code> is <code>true</code>, then we can deduce that <code>adj</code> is already visited and skip it.</p>
<p>This method is particularly useful when the number of queries is much larger than the number of nodes. In contrast to the previous approach, where we performed DFS/BFS for each query, this method allows for constant-time query answers since the reachability information has already been preprocessed and stored.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Construct an adjacency list <code>adjList</code> from the prerequisites list where each course points to the courses that depend on it.</p>
</li>
<li>
<p>Preprocessing (BFS from each node):</p>
<ul>
<li>For each node<code> i</code> (from <code>0</code> to <code>N - 1</code>):
<ul>
<li>
<p>Start a BFS from <code>i</code> to explore all reachable nodes.</p>
</li>
<li>
<p>Repeat the following while the queue is not empty:</p>
<ul>
<li>Pop the front in the queue as <code>node</code>.</li>
<li>Iterate over the adjacent <code>node</code> and if the node <code>i</code> is not already marked as its prerequisite, mark it and add <code>node</code> to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For each query <code>[u, v]</code> return <code>isPrerequisite[u][v]</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ycdpa23U/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> requires <span class="math inline">\(O(N^2)\)</span> time, as we need to iterate over the <code>prerequisites</code> list. Next, we perform BFS starting from each of the <span class="math inline">\(N\)</span> nodes. Each BFS traversal takes <span class="math inline">\(O(N^2)\)</span> in the worst case, as the time complexity of BFS is <span class="math inline">\(O(V + E)\)</span>. Therefore, the total preprocessing is <span class="math inline">\(O(N \cdot N^2) = O(N^3)\)</span>.</p>
<p>To answer each query, we can retrieve results in constant time from a precomputed map, so answering all <span class="math inline">\(Q\)</span> queries takes <span class="math inline">\(O(Q)\)</span> time. Thus, the total time complexity will be <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The adjacency list takes <span class="math inline">\(O(N^2)\)</span> space as it will store every edge in the list <code>prerequisites</code>. For BFS, we need a 2D array <code>isPrerequisite</code> with size <span class="math inline">\(O(N^2)\)</span> to store the answer for every pair of nodes. The queue required for the BFS will take <span class="math inline">\(O(N)\)</span> size for each node, hence the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort---kahns-algorithm">Approach 3: Topological Sort - Kahn's Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We need to find a way to process nodes in the correct order, ensuring that each node is processed only after its dependencies are handled. This is where <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/">topological sorting</a> comes into play. Kahn’s algorithm is a great fit for this task because it respects the dependencies of each node, ensuring nodes are only visited once their prerequisites are completed.</p>
<blockquote>
<p>Topological sorting is an algorithm used in directed graphs to arrange nodes such that for every directed edge from node <code>u</code> to node <code>v</code>, node <code>u</code> comes before <code>v</code>. This is a natural approach when dealing with dependencies, like in project scheduling, task ordering, or handling prerequisites.</p>
</blockquote>
<p>Now, to adapt Kahn's algorithm to our needs, we need to keep track of a node’s prerequisites. Instead of just processing nodes in topological order, we'll modify the algorithm to maintain a list of dependencies for each node. As we move from node <code>u</code> to node <code>v</code>, we’ll add all of <code>u</code>'s prerequisites to <code>v</code>'s prerequisites. This is important because it computes the transitive closure, meaning we’re not just tracking immediate dependencies, but also indirect ones.</p>
<p>By the end of this process, each node will have a complete list of all nodes that must be visited before it. With this setup, when we need to answer a query <code>(u, v)</code>, all we have to do is check if <code>u</code> is in the list of prerequisites for <code>v</code>.</p>
<p>The general structure of Kahn’s algorithm stays the same. We start by calculating the indegree of each node, which tells us how many nodes depend on it. Nodes with an indegree of zero are independent and can be processed first, so we enqueue them. Then, using a queue, we dequeue nodes, process their neighbors, update the prerequisite lists, and enqueue any neighbors whose indegree drops to zero. This continues until we’ve processed all nodes, ensuring the correct order of traversal.</p>
<p>!?!../Documents/1462/1462_Course_Schedule_IV.json:960,720!?! <br></p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Create an adjacency list (<code>adjList</code>) to store the directed graph representing course dependencies.</p>
</li>
<li>
<p>Initialize an array (<code>indegree</code>) to track the number of prerequisites (in-degree) for each course.</p>
</li>
<li>
<p>Iterate over the prerequisites array to populate the adjacency list and update the indegree for each course.</p>
</li>
<li>
<p>Initialize a queue (<code>q</code>) to process courses with zero in-degree (no prerequisites).</p>
</li>
<li>
<p>While the queue is not empty:</p>
<ul>
<li>Dequeue a course (<code>node</code>).</li>
<li>For each adjacent course (<code>adj</code>) in the adjacency list of nodes, add the prerequisites of <code>node</code> to the list <code>nodePrerequisites[adj]</code>.</li>
<li>Decrement the in-degree of the node <code>adj</code>, and if the in-degree becomes zero, enqueue it for further processing.</li>
</ul>
</li>
<li>
<p>For each query <code>(u, v)</code>, check if course <code>u</code> is in the prerequisite list of course <code>v</code> by checking <code>nodePrerequisites[v]</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/76eFh22K/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> time as we need to iterate over the list <code>prerequisites</code>. The array <code>indegree</code>  will be of size <span class="math inline">\(O(N)\)</span>. In Kahn's algorithm, we iterate over each node and edge of the vertex which is <span class="math inline">\(O(N^2)\)</span> and for each edge traversed we will also add the prerequisites to the next node which is another <span class="math inline">\(O(N)\)</span>. To answer each query we need constant time to retrieve from the map and hence it's <span class="math inline">\(O(Q)\)</span> to answer all queries. Hence, the total time complexity equals <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>List <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> as it will store every edge in the list <code>prerequisites</code>. Array <code>indegree</code> will take <span class="math inline">\(O(N)\)</span> space and the queue for Kahn's algorithm will also be <span class="math inline">\(O(N)\)</span> size. Map <code>nodePrerequisites</code> will be from the node to its prerequisites and thus the total number of entries can be equal to <span class="math inline">\(O(N^2)\)</span>. Hence the total space complexity equals <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-floyd-warshall-algorithm">Approach 4: Floyd Warshall Algorithm</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In the first approach, we discussed the concept of transitive closure, which simplified the problem. The key insight was that the transitive closure allows us to determine if a path exists between two nodes, even indirectly. This concept is central to solving the All-Pairs Shortest Path (APSP) problem, for which the Floyd-Warshall algorithm is commonly used. This algorithm works by systematically considering every possible intermediate node and checking if a path between two nodes can be improved by going through that intermediate node. It then updates the shortest distance between the nodes.</p>
<p>For our problem, however, we don't need to calculate the shortest path, just whether a path exists. This leads us to a simple modification of the Floyd-Warshall algorithm: instead of keeping track of distances, we’ll use boolean values to represent whether a path exists between two nodes.</p>
<p>The main idea is to check if there’s a path from <code>src</code> to <code>target</code> by looking at all possible intermediate nodes. For each intermediate node, we check if there’s a path from <code>src</code> to that node and a path from that node to <code>target</code>. If both conditions hold, then we can confirm that a path exists between <code>src</code> and <code>target</code>. We then set <code>isPrerequisite[src][target]</code> to <code>true</code>.</p>
<p>At the end of this process, we’ll have a 2D array, <code>isPrerequisite</code>, where each entry <code>isPrerequisite[u][v]</code> tells us whether <code>u</code> is a prerequisite for <code>v</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Initialize a 2D boolean array <code>isPrerequisite</code> of size <code>numCourses x numCourses</code> to track direct prerequisite relationships between courses.</p>
</li>
<li>
<p>Populate the <code>isPrerequisite</code> matrix based on the <code>prerequisites</code>:</p>
</li>
</ol>
<ul>
<li>For each pair in <code>prerequisites</code>, mark <code>isPrerequisite[edge[0]][edge[1]]</code> as <code>true</code> to indicate that <code>edge[0]</code> is a prerequisite for <code>edge[1]</code>.</li>
</ul>
<ol start="3">
<li>Compute transitive closure of the prerequisite relationships using the Floyd-Warshall algorithm:</li>
</ol>
<ul>
<li>For each possible intermediate course <code>intermediate</code>:
<ul>
<li>For each source course <code>src</code>:
<ul>
<li>For each target course <code>target</code>:
<ul>
<li>Update <code>isPrerequisite[src][target]</code> to include indirect relationships:
<ul>
<li>If <code>src</code> can reach <code>intermediate</code> and <code>intermediate</code> can reach <code>target</code>, then <code>src</code> can reach <code>target</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<p>Initialize an empty list <code>answer</code> to store the results of the queries.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
</li>
</ol>
<ul>
<li>Add the value of <code>isPrerequisite[query[0]][query[1]]</code> to the <code>answer</code> list, indicating whether <code>query[0]</code> is a prerequisite for <code>query[1]</code>.</li>
</ul>
<ol start="6">
<li>Return the <code>answer</code> list containing the results for all queries.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/LU6eyzQL/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>We iterate over each node in three nested loops, so this step takes <span class="math inline">\(O(N^3)\)</span>. To answer each query we need constant time to retrieve from the map and hence it's <span class="math inline">\(O(Q)\)</span> to answer all queries. Hence, the total time complexity equals <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>We need a 2D array <code>isPrerequisite</code> with size <span class="math inline">\(O(N^2)\)</span> to store the answer for every pair of nodes, hence the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/covid-spread--141631/1" target="_blank" rel="noopener noreferrer">Covid Spread</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Aterp is the head nurse at a city hospital. City hospital contains R*C&nbsp;number of wards and the structure of a hospital is in the form of a 2-D matrix.<br />Given a matrix of dimension <strong>R</strong>*<strong>C</strong> where each cell in the matrix can have values 0, 1, or 2 which has the following meaning:<br /><strong>0</strong>: Empty ward<br /><strong>1</strong>: Cells have uninfected patients<br /><strong>2</strong>: Cells have infected patients</p>
<p>An infected patient at ward [i,j] can infect other uninfected patient at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (<strong>up</strong>, <strong>down</strong>, <strong>left</strong> and <strong>right</strong>) in unit time. Help Aterp&nbsp;determine the minimum units of time after which there won't remain any uninfected patient i.e all patients would be infected.&nbsp;If all patients are not infected after infinite units of time then simply return -1.</p>
<p>&nbsp;</p>
<p><br /><strong>Example 1:</strong></p>
<pre><strong>Input:</strong>
3 5
2 1 0 2 1
1 0 1 2 1
1 0 0 2 1 
<strong>Output:</strong>
2
<strong>Explanation:
</strong>Patients at positions {0,0}, {0, 3}, {1, 3}
and {2, 3} will infect patient at {0, 1}, 
{1, 0},{0, 4}, {1, 2}, {1, 4}, {2, 4} during 1st 
unit time. And, during 2nd unit time, patient at 
{1, 0} will get infected and will infect patient 
at {2, 0}. Hence, total 2 unit of time is
required to infect all patients.</pre>
<p><strong>Example 2:</strong></p>
<pre><strong>Input:</strong>
3 5
2 1 0 2 1
0 0 1 2 1
1 0 0 2 1
<strong>Output:</strong>
-1
<strong>Explanation:</strong>
All patients will not be infected.</pre>
<p>&nbsp;</p>
<p><strong>Your Task:</strong>&nbsp;&nbsp;<br />You don't need to read input or print anything. Your task is to complete the function <strong>helpaterp</strong>()&nbsp;which takes a 2-D Matrix <strong>hospital&nbsp;</strong>as input parameter&nbsp;and returns the minimum units of time in which all patients will be infected or -1 if it is impossible.</p>
<p><br /><strong>Constraints:</strong><br />1 &le; R,C&nbsp;&le; 1000<br />0 &le; mat[i][j]&nbsp;&le; 2</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cracking-the-safe/description" target="_blank" rel="noopener noreferrer">Cracking the Safe</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">eulerian-circuit</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a safe protected by a password. The password is a sequence of <code>n</code> digits where each digit can be in the range <code>[0, k - 1]</code>.</p>

<p>The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the <strong>most recent </strong><code>n</code><strong> digits</strong> that were entered each time you type a digit.</p>

<ul>
	<li>For example, the correct password is <code>&quot;345&quot;</code> and you enter in <code>&quot;012345&quot;</code>:

	<ul>
		<li>After typing <code>0</code>, the most recent <code>3</code> digits is <code>&quot;0&quot;</code>, which is incorrect.</li>
		<li>After typing <code>1</code>, the most recent <code>3</code> digits is <code>&quot;01&quot;</code>, which is incorrect.</li>
		<li>After typing <code>2</code>, the most recent <code>3</code> digits is <code>&quot;012&quot;</code>, which is incorrect.</li>
		<li>After typing <code>3</code>, the most recent <code>3</code> digits is <code>&quot;123&quot;</code>, which is incorrect.</li>
		<li>After typing <code>4</code>, the most recent <code>3</code> digits is <code>&quot;234&quot;</code>, which is incorrect.</li>
		<li>After typing <code>5</code>, the most recent <code>3</code> digits is <code>&quot;345&quot;</code>, which is correct and the safe unlocks.</li>
	</ul>
	</li>
</ul>

<p>Return <em>any string of <strong>minimum length</strong> that will unlock the safe <strong>at some point</strong> of entering it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1, k = 2
<strong>Output:</strong> &quot;10&quot;
<strong>Explanation:</strong> The password is a single digit, so enter each digit. &quot;01&quot; would also unlock the safe.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, k = 2
<strong>Output:</strong> &quot;01100&quot;
<strong>Explanation:</strong> For each possible password:
- &quot;00&quot; is typed in starting from the 4<sup>th</sup> digit.
- &quot;01&quot; is typed in starting from the 1<sup>st</sup> digit.
- &quot;10&quot; is typed in starting from the 3<sup>rd</sup> digit.
- &quot;11&quot; is typed in starting from the 2<sup>nd</sup> digit.
Thus &quot;01100&quot; will unlock the safe. &quot;10011&quot;, and &quot;11001&quot; would also unlock the safe.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 4</code></li>
	<li><code>1 &lt;= k &lt;= 10</code></li>
	<li><code>1 &lt;= k<sup>n</sup> &lt;= 4096</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/critical-connections-in-a-network/description" target="_blank" rel="noopener noreferrer">Critical Connections in a Network</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">biconnected-component</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> servers numbered from <code>0</code> to <code>n - 1</code> connected by undirected server-to-server <code>connections</code> forming a network where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a connection between servers <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Any server can reach other servers directly or indirectly through the network.</p>

<p>A <em>critical connection</em> is a connection that, if removed, will make some servers unable to reach some other server.</p>

<p>Return all critical connections in the network in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png" style="width: 198px; height: 248px;" />
<pre>
<strong>Input:</strong> n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
<strong>Output:</strong> [[1,3]]
<strong>Explanation:</strong> [[3,1]] is also accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, connections = [[0,1]]
<strong>Output:</strong> [[0,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>n - 1 &lt;= connections.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated connections.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-graph-with-shortest-path-calculator/description" target="_blank" rel="noopener noreferrer">Design Graph With Shortest Path Calculator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed weighted</strong> graph that consists of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The edges of the graph are initially represented by the given array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, edgeCost<sub>i</sub>]</code> meaning that there is an edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with the cost <code>edgeCost<sub>i</sub></code>.</p>

<p>Implement the <code>Graph</code> class:</p>

<ul>
	<li><code>Graph(int n, int[][] edges)</code> initializes the object with <code>n</code> nodes and the given edges.</li>
	<li><code>addEdge(int[] edge)</code> adds an edge to the list of edges where <code>edge = [from, to, edgeCost]</code>. It is guaranteed that there is no edge between the two nodes before adding this one.</li>
	<li><code>int shortestPath(int node1, int node2)</code> returns the <strong>minimum</strong> cost of a path from <code>node1</code> to <code>node2</code>. If no path exists, return <code>-1</code>. The cost of a path is the sum of the costs of the edges in the path.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png" style="width: 621px; height: 191px;" />
<pre>
<strong>Input</strong>
[&quot;Graph&quot;, &quot;shortestPath&quot;, &quot;shortestPath&quot;, &quot;addEdge&quot;, &quot;shortestPath&quot;]
[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
<strong>Output</strong>
[null, 6, -1, null, 6]

<strong>Explanation</strong>
Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -&gt; 0 -&gt; 1 -&gt; 2 with a total cost of 3 + 2 + 1 = 6.
g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.
g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -&gt; 1 -&gt; 3 with a total cost of 2 + 4 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>
	<li><code>edges[i].length == edge.length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, from, to, node1, node2 &lt;= n - 1</code></li>
	<li><code>1 &lt;= edgeCost<sub>i</sub>, edgeCost &lt;= 10<sup>6</sup></code></li>
	<li>There are no repeated edges and no self-loops in the graph at any point.</li>
	<li>At most <code>100</code> calls will be made for <code>addEdge</code>.</li>
	<li>At most <code>100</code> calls will be made for <code>shortestPath</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Imagine you're tasked with navigating a complex web of interconnected locations, each with its unique path and cost associated with traveling from one place to another. This is precisely the challenge presented in this problem.</p>
<p>You're given a directed weighted graph, represented by an array of edges. Each edge signifies a one-way connection between two locations, complete with a cost. Your mission is to create a &quot;Graph&quot; class that can efficiently manage this network and provide two essential services.</p>
<ol>
<li>
<p><strong>Setting Up the Map (<code>Graph(int n, int[][] edges)</code>):</strong> Just like preparing a map for a journey, you initialize the graph with &quot;n&quot; locations and the given edges. This step lays out the foundation for your navigation.</p>
</li>
<li>
<p><strong>Plotting New Routes (<code>addEdge(int[] edge)</code>):</strong> As your journey unfolds, you'll come across new routes. The &quot;addEdge&quot; method allows you to add these paths to your map. It's worth noting that this method ensures no duplicate paths between locations.</p>
</li>
<li>
<p><strong>Finding the Optimal Path (<code>int shortestPath(int node1, int node2)</code>):</strong> The core of this adventure lies in discovering the shortest and most cost-effective path from one location to another. This method calculates the minimum cost required to travel from &quot;node1&quot; to &quot;node2.&quot; If a path doesn't exist, it signals your GPS to return -1.</p>
</li>
</ol>
<p>Solving this problem involves creating a powerful navigation tool (the &quot;Graph&quot; class) that not only builds and updates the map as new routes are discovered but also efficiently guides you to your destination, ensuring that you reach your target location with the least possible cost.</p>
<p>This problem mirrors real-world scenarios where you might be navigating transportation networks, optimizing data flow in networks, or even finding the shortest connections in social networks. So, crafting a robust solution here not only solves the immediate challenge but can also have practical applications in various fields.</p>
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>If you are not familiar with Dijkstra's Algorithm, please refer to our explore cards <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
<p>We first use Dijkstra's algorithm, a well-known method for finding the shortest path in weighted graphs, which is particularly effective for this type of problem. The algorithm maintains a priority queue of nodes to explore, prioritizing those with the lowest tentative distances.</p>
<p>We begin by setting the cost of the source node to 0 and enqueue it in a priority queue. Simultaneously, we initialize an array to store the cost associated with each node when starting from the source node. While there are nodes remaining in the queue, we dequeue the node with the lowest cost, examine whether it corresponds to the destination node, and return its cost if it does. If not, we explore its neighboring nodes, compute new costs for the neighboring nodes, and if these new costs are lower than the previously recorded costs in our node cost array, we enqueue the neighboring nodes into the priority queue. In the event that the destination node cannot be reached, we return -1 to indicate the absence of a viable path.</p>
<p>We implement this approach by creating a <code>Graph</code> class with methods for initialization, adding edges, and finding the shortest path using Dijkstra's algorithm. This approach logically addresses the problem's requirements while leveraging a well-established algorithm for efficiency and correctness.</p>
<p>!?!../Documents/2642/design_graph_with_shortest_path_calculator.json:3000,1687!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p><strong>Initialization:</strong></p>
<ul>
<li>When we initialize the <code>Graph</code> class with <code>n</code> nodes and a list of <code>edges</code>, we create an adjacency list representation for the directed weighted graph.</li>
<li>We initialize an empty adjacency list <code>adj_list</code>, where each node's outgoing edges will be stored along with their cost.</li>
</ul>
</li>
<li>
<p><strong>Adding Edges:</strong></p>
<ul>
<li>When we call the <code>addEdge</code> method to add an edge to the graph, we provide an <code>edge</code> in the form of a list <code>[from, to, edgeCost]</code>.</li>
<li>We extract the <code>from_node</code>, <code>to_node</code>, and <code>cost</code> from the input edge.</li>
<li>We append a tuple/pair <code>(to_node, cost)</code> to the adjacency list entry for <code>from_node</code>. This represents a directed edge from <code>from_node</code> to <code>to_node</code> with the specified cost.</li>
</ul>
</li>
<li>
<p><strong>Shortest Path Calculation:</strong></p>
<ul>
<li>When we call the <code>shortestPath</code> method to find the minimum cost path from <code>node1</code> to <code>node2</code>, we use Dijkstra's algorithm.</li>
<li>We initialize an array <code>costForNode</code> to keep track of the minimum costs to reach each node when starting from <code>node1</code> and a priority queue <code>pq</code> to explore nodes in ascending order of their accumulated cost from <code>node1</code>.</li>
<li>We set <code>costForNode[node1]</code> to 0 since we are starting here.</li>
<li>We start by adding <code>(0, node1)</code> to <code>pq</code> with an initial cost of 0 for <code>node1</code>.</li>
<li>While <code>pq</code> is not empty, we continue exploring nodes.</li>
<li>For each iteration:
<ul>
<li>We pop the node with the smallest accumulated cost (<code>curr_cost</code>) from <code>pq</code>.</li>
<li>If <code>curr_node</code> is equal to <code>node2</code>, we have found the shortest path, and we return <code>curr_cost</code>.</li>
<li>We iterate through the neighbors of <code>curr_node</code> stored in the adjacency list.</li>
<li>For each neighbor, we calculate the new cost (<code>new_cost</code>) by adding the cost of the current edge to the <code>curr_cost</code>.</li>
<li>If the neighbor's <code>new_cost</code> is less than its cost in <code>costForNode</code> (<code>costForNode[node1]</code>), we add <code>(new_cost, neighbor)</code> to <code>pq</code>, which means we will explore this neighbor with the updated cost. We additionally assign the value of <code>new_cost</code> to <code>costForNode[node1]</code>.</li>
</ul>
</li>
<li>If the priority queue is empty and we have not found <code>node2</code>, it means there is no path from <code>node1</code> to <code>node2</code>, so we return -1.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/RnYjN5Sw/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(E\)</span> be number of edges in the graph when the call to any method is made.<br />
Let <span class="math inline">\(V\)</span> be the number of vertices in the graph when the call to any method is made.<br />
Let <span class="math inline">\(N\)</span> be the maximum number of calls made to <code>addEdge</code>.<br />
Let <span class="math inline">\(M\)</span> be the maximum number of calls made to <code>shortestPath</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + M\cdot (V + E\cdot logV))\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(E + V)\)</span>. Initializing a list to the size of <span class="math inline">\(V\)</span> costs <span class="math inline">\(O(V)\)</span> and iterating over all the edges costs <span class="math inline">\(O(E)\)</span></li>
<li>addEdge: <span class="math inline">\(O(N)\)</span>. Appending an element to a list costs <span class="math inline">\(O(1)\)</span>, and when this operation is performed <span class="math inline">\(N\)</span> times, it results in a linear time complexity of <span class="math inline">\(O(N)\)</span>.</li>
<li>shortestPath: <span class="math inline">\(O(M\cdot (V + E\cdot logV))\)</span>. Initializing the <code>costForNode</code> list will incur a time complexity of <span class="math inline">\(O(V)\)</span>. The time complexity for Dijkstra's algorithm is <span class="math inline">\((E\cdot logV)\)</span>. Calling <code>shortestPath</code> <span class="math inline">\(M\)</span> times leads to a combined time complexity of <span class="math inline">\(O(M\cdot (V + E\cdot logV))\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(E + V + N)\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(E + V)\)</span>. This is the cost to initialize the adjacency list.</li>
<li>addEdge: <span class="math inline">\(O(N)\)</span>. Adding an element in the adjacency list will incur a space complexity of <span class="math inline">\(O(1)\)</span>, and when this operation is performed <span class="math inline">\(N\)</span> times, it results in a linear space complexity of <span class="math inline">\(O(N)\)</span>.</li>
<li>shortestPath: <span class="math inline">\(O(E + V)\)</span>. The <code>costForNode</code> list will incur a space complexity of <span class="math inline">\(O(V)\)</span>. The priority queue will will incur a space complexity of <span class="math inline">\(O(E)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-floydwarshall-algorithm">Approach 2: Floyd–Warshall algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We start by considering how to represent the graph. Given that it's a weighted directed graph, we opt for an adjacency matrix to store the edge costs between nodes. This matrix, <code>adj_matrix</code>, will be initialized with a very large value (infinity) to signify that there's no direct edge between two nodes.</p>
<p>In the constructor, we take the number of nodes <code>n</code> and the initial <code>edges</code> as input. We initialize the adjacency matrix with infinity values for all pairs of nodes. Then, we iterate through the given edges and update the corresponding positions in the adjacency matrix with the edge costs. To maintain consistency, we also set the diagonal entries to 0 since the cost from a node to itself is zero.</p>
<p><strong>Floyd-Warshall Algorithm:</strong> We recognize the need to find the shortest paths between all pairs of nodes efficiently. To achieve this, we implement the Floyd-Warshall algorithm. We use nested loops to iterate through all possible intermediate nodes (<code>k</code>), source nodes (<code>i</code>), and destination nodes (<code>j</code>). For each pair of nodes (<code>i, j</code>), we update the minimum cost if there's a shorter path through the intermediate node (<code>k</code>).</p>
<p>In the <code>addEdge</code> method, we address the requirement to add a new edge to the graph. We take the edge information as input (from_node, to_node, and cost). To update the adjacency matrix efficiently, we iterate through all pairs of nodes (<code>i, j</code>) and check if the path from <code>i</code> to <code>j</code> can be improved by going through the newly added edge. If there's an improvement, we update the cost accordingly. This is commonly known as the &quot;relaxation&quot; step.</p>
<p><strong>Finding Shortest Path:</strong> In the <code>shortestPath</code> method, we provide a simple interface for users to find the shortest path between two nodes. We return the cost stored in the adjacency matrix for the given pair of nodes (node1, node2). Since we have already relaxed all paths in the <code>addEdge</code> method, the adjacent matrix is guaranteed to store the cost of the shortest path. If the cost is still infinite, it indicates there's no path between those nodes, and we return -1.</p>
<p>The key insight here is that the Floyd-Warshall algorithm efficiently computes the shortest paths between all pairs of nodes, making the <code>shortestPath</code> method fast and time-constant.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p><strong>Initialization:</strong></p>
<ul>
<li>When we initialize the <code>Graph</code> class with <code>n</code> nodes and a list of <code>edges</code>, we create an adjacency matrix representation for the directed weighted graph.</li>
<li>We initialize an empty adjacency matrix <code>adj_matrix</code> of size <code>n x n</code>, where <code>n</code> is the number of nodes.</li>
<li>For each edge in the input <code>edges</code>, we update the corresponding entry in the adjacency matrix with the provided cost.</li>
<li>We set the diagonal elements of the adjacency matrix to 0 because the cost to reach a node from itself is always 0.</li>
</ul>
</li>
<li>
<p><strong>Floyd-Warshall Algorithm:</strong></p>
<ul>
<li>After initializing the adjacency matrix, we apply the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes.</li>
<li>We use three nested loops:
<ul>
<li>The outermost loop iterates over all intermediate nodes (indexed by <code>i</code>).</li>
<li>The middle loop iterates over all source nodes (indexed by <code>j</code>).</li>
<li>The innermost loop iterates over all destination nodes (indexed by <code>k</code>).</li>
</ul>
</li>
<li>During each iteration, we update the entry <code>adj_matrix[j][k]</code> by taking the minimum of its current value and the sum of the values <code>adj_matrix[j][i]</code> and <code>adj_matrix[i][k]</code>. This represents the minimum cost to reach node <code>k</code> from node <code>j</code> via an intermediate node <code>i</code>.</li>
</ul>
</li>
<li>
<p><strong>Adding Edges:</strong></p>
<ul>
<li>When we call the <code>addEdge</code> method to add an edge to the graph, we provide an <code>edge</code> in the form of a list <code>[from, to, edgeCost]</code>.</li>
<li>We iterate over all pairs of nodes in the adjacency matrix and update the entry <code>adj_matrix[i][j]</code> by taking the minimum of its current value and the sum of the values <code>adj_matrix[i][from_node]</code>, <code>adj_matrix[to_node][j]</code>, and <code>cost</code>. This represents the updated minimum cost considering the new edge.</li>
</ul>
</li>
<li>
<p><strong>Shortest Path Calculation:</strong></p>
<ul>
<li>When we call the <code>shortestPath</code> method to find the minimum cost path from <code>node1</code> to <code>node2</code>, we check if the value at <code>adj_matrix[node1][node2]</code> is still equal to infinity(<code>inf</code>). If it is, there is no path between the two nodes, so we return -1.</li>
<li>Otherwise, we return <code>adj_matrix[node1][node2]</code>, which represents the minimum cost to reach <code>node2</code> from <code>node1</code> based on the computed shortest paths.</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QNyfnDS3/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(E\)</span> be number of edges in the graph when the call to any method is made.<br />
Let <span class="math inline">\(V\)</span> be the number of vertices in the graph when the call to any method is made.<br />
Let <span class="math inline">\(N\)</span> be the maximum number of calls made to <code>addEdge</code>.<br />
Let <span class="math inline">\(M\)</span> be the maximum number of calls made to <code>shortestPath</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M + N\cdot V^2 + V^3)\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(V^3)\)</span>. The Floyd-Warshall Algorithm incurs a cost of <span class="math inline">\(O(V^3)\)</span> to find the minimum cost between all pairs of vertices.</li>
<li>addEdge: <span class="math inline">\(O(N\cdot V^2)\)</span>. When adding an edge, we iterate over the whole matrix to check if the new edge lowers the cost between any of the vertices. This operation costs <span class="math inline">\(O(V^2)\)</span>. When this operation is performed <span class="math inline">\(N\)</span> times, it results in a time complexity of <span class="math inline">\(O(N\cdot V^2)\)</span>.</li>
<li>shortestPath: <span class="math inline">\(O(M)\)</span>. Finding the <code>shortestPath</code> doesn't require any additional computation. Hence, it incurs a constant time complexity of <span class="math inline">\(O(1)\)</span>. When this operation is performed <span class="math inline">\(M\)</span> times, it results in a linear time complexity of <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity:  <span class="math inline">\(O(V^2)\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(V^2)\)</span>. We initialize a 2-D adjacency matrix that stores the minimum cost between all vertices. This matrix incurs a cost of <span class="math inline">\(O(V^2)\)</span>.</li>
<li>addEdge: <span class="math inline">\(O(1)\)</span>. We will not need any extra space to add an edge.</li>
<li>shortestPath: <span class="math inline">\(O(1)\)</span>. We will not need any extra space to return the cost of the shortest path.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="notes">Notes:</h3>
<p>If there is a significant imbalance between the frequency of <code>shortestPath</code> calls compared to the frequency of <code>addEdge</code> calls, the choice between using the Floyd-Warshall algorithm and Dijkstra's algorithm should be based on the number of times these two operations are performed:</p>
<ul>
<li>When <code>shortestPath</code> is called much more often than <code>addEdge</code>, it is more efficient to utilize the Floyd-Warshall algorithm.</li>
<li>Conversely, if <code>addEdge</code> is called significantly more often than <code>shortestPath</code>, it is more practical to employ Dijkstra's algorithm for this problem.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/detect-cycle-using-dsu/1" target="_blank" rel="noopener noreferrer">Detect Cycle using DSU</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an <strong>undirected graph</strong> with <strong>no self loops</strong> with <strong>V (from 0 to V-1)</strong> nodes and <strong>E</strong> edges, the task is to check if there is any <strong>cycle </strong>in the <strong>undirected graph</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> Solve the problem using <strong>disjoint set union (DSU).</strong></span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701410/Web/Other/blobid0_1745299580.jpg" width="303" height="268" /><br /><span style="font-size: 18px;"><strong>Output:</strong><strong>&nbsp;</strong>1
<strong>Explanation: </strong>There is a cycle between 0-&gt;2-&gt;4-&gt;0</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701410/Web/Other/blobid1_1745299616.jpg" width="307" height="272" /><br /><span style="font-size: 18px;"><strong>Output: </strong>0
<strong>Explanation: </strong>The graph doesn't contain any cycle</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anyhting. Your task is to complete the function&nbsp;<strong>detectCycle()&nbsp;</strong>which takes number of vertices in the graph denoting as <strong>V</strong> and adjacency list <strong>adj </strong>and returns <strong>1</strong> if graph contains any <strong>cycle </strong>otherwise returns <strong>0</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(V + E)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(V)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">2 &le; V &le; 10<sup>4<br /></sup></span><span style="font-size: 18px;">1 &le; E &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/detonate-the-maximum-bombs/description" target="_blank" rel="noopener noreferrer">Detonate the Maximum Bombs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">geometry</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a list of bombs. The <strong>range</strong> of a bomb is defined as the area where its effect can be felt. This area is in the shape of a <strong>circle</strong> with the center as the location of the bomb.</p>

<p>The bombs are represented by a <strong>0-indexed</strong> 2D integer array <code>bombs</code> where <code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>. <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> denote the X-coordinate and Y-coordinate of the location of the <code>i<sup>th</sup></code> bomb, whereas <code>r<sub>i</sub></code> denotes the <strong>radius</strong> of its range.</p>

<p>You may choose to detonate a <strong>single</strong> bomb. When a bomb is detonated, it will detonate <strong>all bombs</strong> that lie in its range. These bombs will further detonate the bombs that lie in their ranges.</p>

<p>Given the list of <code>bombs</code>, return <em>the <strong>maximum</strong> number of bombs that can be detonated if you are allowed to detonate <strong>only one</strong> bomb</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> bombs = [[2,1,3],[6,1,4]]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
The above figure shows the positions and ranges of the 2 bombs.
If we detonate the left bomb, the right bomb will not be affected.
But if we detonate the right bomb, both bombs will be detonated.
So the maximum bombs that can be detonated is max(1, 2) = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> bombs = [[1,1,5],[10,10,5]]
<strong>Output:</strong> 1
<strong>Explanation:
</strong>Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
<strong>Output:</strong> 5
<strong>Explanation:</strong>
The best bomb to detonate is bomb 0 because:
- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.
- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.
- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.
Thus all 5 bombs are detonated.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>
	<li><code>bombs[i].length == 3</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1" target="_blank" rel="noopener noreferrer">DFS of Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>connected undirected graph&nbsp;</strong>containing <strong>V </strong>vertices represented by a 2-d </span><span style="font-size: 18.6667px;">adjacency list&nbsp;</span><strong style="font-size: 18.6667px;"><code>adj[][]</code></strong><span style="font-size: 14pt;">, where each </span><code style="font-size: 14pt;">adj[i]</code><span style="font-size: 14pt;">&nbsp;represents the list of vertices connected to vertex&nbsp;</span><code style="font-size: 14pt;">i</code><span style="font-size: 14pt;">. Perform a </span><strong style="font-size: 14pt;">Depth First Search (DFS)</strong><span style="font-size: 14pt;"> traversal starting from vertex 0, visiting vertices from left to right as per the given adjacency list, and return a list containing the DFS traversal of the graph.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong> Do traverse in the <strong>same order</strong> as they are in the given <strong>adjacency list</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>adj[][] = [[2, 3, 1], [0], [0, 4], [0], [2]]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700203/Web/Other/blobid0_1728647807.jpg" width="301" height="189" /></span><br /><span style="font-size: 14pt;"><strong>Output:</strong> [0, 2, 4, 3, 1]<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">: Starting from 0, the DFS traversal proceeds as follows:<br /></span>Visit 0 &rarr; Output: 0 </span><br /><span style="font-size: 14pt;">Visit 2 (the first neighbor of 0) &rarr; Output: 0, 2 </span><br /><span style="font-size: 14pt;">Visit 4 (the first neighbor of 2) &rarr; Output: 0, 2, 4 </span><br /><span style="font-size: 14pt;">Backtrack to 2, then backtrack to 0, and visit 3 &rarr; Output: 0, 2, 4, 3 </span><br /><span style="font-size: 14pt;">Finally, backtrack to 0 and visit 1 &rarr; Final Output: 0, 2, 4, 3, 1</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> adj[][] = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700203/Web/Other/blobid1_1728648013.jpg" width="300" height="189" /><br /><strong>Output:</strong> [0, 1, 2, 3, 4]
<strong>Explanation</strong>: Starting from 0, the DFS traversal proceeds as follows: <br />Visit 0 &rarr; Output: 0 <br />Visit 1 (the first neighbor of 0) &rarr; Output: 0, 1 <br />Visit 2 (the first neighbor of 1) &rarr; Output: 0, 1, 2 <br />Visit 3 (the first neighbor of 2) &rarr; Output: 0, 1, 2, 3 <br />Backtrack to 2 and visit 4 &rarr; Final Output: 0, 1, 2, 3, 4</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; V = adj.size() &le; 10<sup>4<br /></sup>1 &le; adj[i][j] &le; 10<sup>4</sup><sup><br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/digit-operations-to-make-two-integers-equal/description" target="_blank" rel="noopener noreferrer">Digit Operations to Make Two Integers Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>n</code> and <code>m</code> that consist of the <strong>same</strong> number of digits.</p>

<p>You can perform the following operations <strong>any</strong> number of times:</p>

<ul>
	<li>Choose <strong>any</strong> digit from <code>n</code> that is not 9 and <strong>increase</strong> it by 1.</li>
	<li>Choose <strong>any</strong> digit from <code>n</code> that is not 0 and <strong>decrease</strong> it by 1.</li>
</ul>

<p>The integer <code>n</code> must not be a <span data-keyword="prime-number">prime</span> number at any point, including its original value and after each operation.</p>

<p>The cost of a transformation is the sum of <strong>all</strong> values that <code>n</code> takes throughout the operations performed.</p>

<p>Return the <strong>minimum</strong> cost to transform <code>n</code> into <code>m</code>. If it is impossible, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 10, m = 12</span></p>

<p><strong>Output:</strong> <span class="example-io">85</span></p>

<p><strong>Explanation:</strong></p>

<p>We perform the following operations:</p>

<ul>
	<li>Increase the first digit, now <code>n = <u><strong>2</strong></u>0</code>.</li>
	<li>Increase the second digit, now <code>n = 2<strong><u>1</u></strong></code>.</li>
	<li>Increase the second digit, now <code>n = 2<strong><u>2</u></strong></code>.</li>
	<li>Decrease the first digit, now <code>n = <strong><u>1</u></strong>2</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, m = 8</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>It is impossible to make <code>n</code> equal to <code>m</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 6, m = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>Since 2 is already a prime, we can&#39;t make <code>n</code> equal to <code>m</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, m &lt; 10<sup>4</sup></code></li>
	<li><code>n</code> and <code>m</code> consist of the same number of digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1" target="_blank" rel="noopener noreferrer">Dijkstra Algorithm</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an undirected, weighted graph with <strong>V&nbsp;</strong>vertices numbered from 0 to V-1 and <strong>E&nbsp;</strong>edges, represented by 2d array <strong>edges[][]</strong>, where edges[i]=[u, v, w] represents the <strong>edge</strong> between the nodes u and v having w <strong>edge weight</strong>.<br /><span style="font-size: 18.6667px;">You have to find the <strong>shortest distance </strong>of all the vertices from the source vertex&nbsp;</span><strong style="font-size: 18.6667px;">src</strong><span style="font-size: 18.6667px;">, </span></span><span style="font-size: 18.6667px;">and return an array of integers where the <strong>ith</strong> element denotes the shortest distance between <strong>ith</strong> node</span><span style="font-size: 18.6667px;">&nbsp;and source vertex</span><strong style="font-size: 18.6667px;">&nbsp;src</strong><span style="font-size: 18.6667px;">.</span></p>
<p><span style="font-size: 14pt;"><strong>Note: </strong>The Graph is connected and doesn't contain any negative weight edge.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">V = 3, edges[][] = [[0, 1, 1], [1, 2, 3], [0, 2, 6]], src = 2
</span><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">[4, 3, 0]
</span><strong style="font-size: 14pt;">Explanation</strong><span style="font-size: 14pt;">:
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/892538/Web/Other/blobid0_1744201836.jpg" width="317" height="236" /><br /></span><span style="font-size: 18.6667px;">Shortest Paths:
For 2 to 0 minimum distance will be 4. By following path 2 -&gt; 1 -&gt; 0
For 2 to 1 minimum distance will be 3. By following path 2 -&gt; 1
For 2 to 2 minimum distance will be 0. By following path 2 -&gt; 2</span><span style="font-size: 14pt;"><br /></span></span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">V = 5, edges[][] = [[0, 1, 4], [0, 2, 8], [1, 4, 6], [2, 3, 2], [3, 4, 10]], src = 0
</span><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">[0, 4, 8, 10, 10]
</span><strong style="font-size: 14pt;">Explanation</strong><span style="font-size: 14pt;">: <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/892538/Web/Other/blobid1_1744202046.jpg" width="336" height="273" /><br /></span><span style="font-size: 18.6667px;">Shortest Paths: <br />For 0 to 1 minimum distance will be 4. By following path 0 -&gt; 1
For 0 to 2 minimum distance will be 8. By following path 0 -&gt; 2
For 0 to 3 minimum distance will be 10. By following path 0 -&gt; 2 -&gt; 3 
For 0 to 4 minimum distance will be 10. By following path 0 -&gt; 1 -&gt; 4</span></span></pre>
<div><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; V &le; 10<sup>5</sup></span></div>
<div><span style="font-size: 14pt;">1 &le; E = edges.size() &le; 10<sup>5</sup><br />0 &le; edges[i][j] &le; 10<sup>4</sup></span></div>
<div><span style="font-size: 14pt;">0 &le; src &lt; V</span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1" target="_blank" rel="noopener noreferrer">Directed Graph Cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Directed Graph with&nbsp;<strong>V</strong>&nbsp;vertices (Numbered from&nbsp;<strong>0</strong>&nbsp;to&nbsp;<strong>V-1</strong>) and&nbsp;<strong>E</strong>&nbsp;edges, check whether it contains any&nbsp;<strong>cycle&nbsp;</strong>or not.<br />The graph is&nbsp;</span><span style="font-size: 18.6667px;">represented as a 2D vector&nbsp;</span><strong style="font-size: 18.6667px;">edges[][]</strong><span style="font-size: 18.6667px;">, where each entry&nbsp;</span><strong style="font-size: 18.6667px;">edges[i] = [u, v]</strong><span style="font-size: 18.6667px;">&nbsp;denotes an edge from verticex&nbsp;</span><strong style="font-size: 18.6667px;">u</strong><span style="font-size: 18.6667px;">&nbsp;to&nbsp;</span><strong style="font-size: 18.6667px;">v.</strong></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, edges[][] = [[0, 1], [0, 2], [1, 2], [2, 0], [2, 3]]</span>
<span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700218/Web/Other/blobid0_1744197297.jpg" width="299" height="264" /></span>
<span style="font-size: 18px;"><strong>Output:</strong> true
<strong>Explanation</strong>: The diagram clearly shows a cycle 0 &rarr; 2 &rarr; 0</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, edges[][] = [[0, 1], [0, 2], [1, 2], [2, 3]</span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700218/Web/Other/blobid1_1744197327.jpg" width="298" height="264" /><br /><span style="font-size: 18px;"><strong>Output:</strong> false
<strong>Explanation</strong>: no cycle in the graph</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; V, E &le; 10<sup>5</sup><br />u &ne; v</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/distance-of-nearest-cell-having-1-1587115620/1" target="_blank" rel="noopener noreferrer">Distance of nearest cell having 1</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary grid of <strong>n*m</strong>. Find the distance of the nearest 1 in the grid&nbsp;for each cell.<br />The distance is calculated as&nbsp;<strong>|i<sub>1</sub>&nbsp; - i<sub>2</sub>| + |j<sub>1</sub>&nbsp;- j<sub>2</sub>|</strong>, where i<sub>1</sub>, j<sub>1</sub>&nbsp;are the row number and column number of the current cell, and i<sub>2</sub>, j<sub>2</sub>&nbsp;are the row number and column number of the nearest cell having value 1.</span>&nbsp;<span style="font-size: 18px;">There should be atleast one 1 in the grid.</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = [[0,1,1,0], [1,1,0,0], [0,0,1,1]]
<strong>Output: <br /></strong>[[1,0,0,1], [0,0,1,1], [1,1,0,0]]
<strong>Explanation: <br /></strong>The grid is-
0 1 1 0&nbsp;
1 1 0 0&nbsp;
0 0 1 1&nbsp;
- 0's at (0,0), (0,3), (1,2), (1,3), (2,0) and (2,1) are at a distance of 1 from 1's at (0,1), (0,2), (0,2), (2,3), (1,0) and (1,1) respectively.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701275/Web/Other/blobid0_1745302650.jpg" width="183" height="162" /> </pre>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = [[1,0,1], [1,1,0], [1,0,0]]
<strong>Output: <br /></strong>[[0,1,0], [0,0,1], [0,1,2]]
<strong>Explanation:</strong></span><span style="font-size: 18px;">&nbsp;<br />The grid is-
1 0 1
1 1 0
1 0 0
- 0's at (0,1), (1,2), (2,1) and (2,2) are at a  distance of 1, 1, 1 and 2 from 1's at (0,0), (0,2), (2,0) and (1,1) respectively.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701275/Web/Other/blobid1_1745302675.jpg" width="196" height="173" /> </pre>
<p><span style="font-size: 18px;"><strong>Yout Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;<strong>nearest()&nbsp;</strong>which takes the grid as an input parameter and returns a matrix of the same dimensions where the value at index (i, j) in the resultant matrix signifies the <strong>minimum distance</strong> of 1 in the matrix from grid[i][j].</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/description" target="_blank" rel="noopener noreferrer">Divide Nodes Into the Maximum Number of Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing the number of nodes in an <strong>undirected</strong> graph. The nodes are labeled from <code>1</code> to <code>n</code>.</p>

<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code> indicates that there is a <strong>bidirectional</strong> edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. <strong>Notice</strong> that the given graph may be disconnected.</p>

<p>Divide the nodes of the graph into <code>m</code> groups (<strong>1-indexed</strong>) such that:</p>

<ul>
	<li>Each node in the graph belongs to exactly one group.</li>
	<li>For every pair of nodes in the graph that are connected by an edge <code>[a<sub>i, </sub>b<sub>i</sub>]</code>, if <code>a<sub>i</sub></code> belongs to the group with index <code>x</code>, and <code>b<sub>i</sub></code> belongs to the group with index <code>y</code>, then <code>|y - x| = 1</code>.</li>
</ul>

<p>Return <em>the maximum number of groups (i.e., maximum </em><code>m</code><em>) into which you can divide the nodes</em>. Return <code>-1</code> <em>if it is impossible to group the nodes with the given conditions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/13/example1.png" style="width: 352px; height: 201px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> As shown in the image we:
- Add node 5 to the first group.
- Add node 1 to the second group.
- Add nodes 2 and 4 to the third group.
- Add nodes 3 and 6 to the fourth group.
We can see that every edge is satisfied.
It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[1,2],[2,3],[3,1]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.
It can be shown that no grouping is possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There is at most one edge between any pair of vertices.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a graph with <code>n</code> nodes, represented by a 2D array edges, where <code>edges[i] = [u, v]</code> means there is a bidirectional edge between nodes <code>u</code> and <code>v</code>. Our task is to divide the nodes into the largest number of numbered groups (1, 2, 3, ...) such that:</p>
<ul>
<li>Each node belongs to exactly one group.</li>
<li>If there is an edge <code>[u, v]</code>, and <code>u</code> is in group <code>x</code>, then <code>v</code> must be in either group <code>x - 1</code> or <code>x + 1</code>.</li>
</ul>
<p>Sometimes, this kind of split is not possible. For example, consider this graph:</p>
<p><img src="../Figures/2493/2493_impossible_split.png" alt="Impossible Split" /></p>
<p>Here, no valid split exists. In such cases, we return <code>-1</code>.</p>
<p>A key observation is that if it’s possible to divide the nodes into <code>x</code> groups (<code>x &gt; 2</code>), we can also divide them into <code>x - 1</code> groups. Intuitively, this works because the nodes in the first and third groups can’t be directly connected, but they must all connect to nodes in the second group. By combining groups <code>1</code> and <code>3</code>, we get a valid split with <code>x - 1</code> groups.</p>
<p><img src="../Figures/2493/2493_combine_node_groups.png" alt="Combining Node Groups to Get A Valid Split With One Less Group" /></p>
<p>So, to check if a valid split is possible, we just need to see if the graph can be split into two groups—in other words, whether it is <em>bipartite</em>.</p>
<blockquote>
<p>A graph is <strong>bipartite</strong> when we can divide its nodes into two distinct sets where:</p>
<ul>
<li>All edges connect vertices from one set to vertices in the other set.</li>
<li>No edges exist between vertices within the same set.</li>
</ul>
</blockquote>
<p>Another key detail to consider is that the given graph is not always connected. In this case, we calculate the largest number of groups for each connected part of the graph, and then take the sum of these numbers.</p>
<p>To sum up, the problem boils down to these two steps:</p>
<ol>
<li>Check if the graph is bipartite to see if a valid split exists.</li>
<li>For each connected part of the graph, find the largest number of groups we can divide the nodes into and return their sum.</li>
</ol>
<hr />
<h3 id="approach-1-graph-coloring--longest-shortest-path">Approach 1: Graph Coloring + Longest Shortest Path</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve the first part of the problem, note that once we assign a single node to one of the two groups, the rest of the assignments are automatically determined. Nodes directly connected to the first node must go in the second group, their neighbors must return to the first group, and so on.</p>
<p>To check if the graph is bipartite, we &quot;color&quot; the nodes using two colors (one for each group), ensuring that any two connected nodes have different colors. If this coloring fails, the graph is not bipartite, and we can immediately return <code>-1</code>.</p>
<p><img src="../Figures/2493/2493_graph_coloring.png" alt="Impossible Graph Coloring" /></p>
<p>If the graph is bipartite, we calculate the maximum number of groups we can divide the nodes into for each connected component separately. Intuitively, to achieve the largest number of groups, we spread the nodes as far apart as possible. This means that instead of simply assigning a neighboring node to the same group as the one it was previously associated with, we always try to assign it to a new group.</p>
<p>An important observation here is that the maximum number of groups in a component is determined by the longest shortest path between any pair of nodes in that component. This is similar to finding the &quot;height&quot; of the component if it were structured like a tree, with different nodes as potential roots. The longest shortest path essentially tells us how many layers or groups can be created based on the distances between the nodes.</p>
<p>Finally, we repeat this for all connected components in the graph and sum up the results to get the answer.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="isbipartiteadjlist-node-colors-function"><code>isBipartite(adjList, node, colors)</code> function</h5>
<ul>
<li>Iterate over the neighbors of <code>node</code> and attempt to assign them the opposite color of <code>node</code>:
<ul>
<li>If <code>neighbor</code> already has the same color as <code>node</code> (i.e., <code>colors[neighbor] == colors[node]</code>), return <code>false</code>.</li>
<li>If <code>neighbor</code> has already been assigned a color (i.e., <code>colors[neighbor] != -1</code>), skip to the next <code>neighbor</code>.</li>
<li>Assign <code>colors[neighbor] = (colors[node] + 1) % 2</code>.</li>
<li>Recursively call <code>isBipartite(adjList, neighbor, colors)</code> and return <code>false</code> if the call returns <code>false</code>.</li>
</ul>
</li>
<li>If all neighbors are successfully assigned the opposite color without conflicts, return <code>true</code>.</li>
</ul>
<h5 id="getlongestshortestpathadjlist-srcnode-n-function"><code>getLongestShortestPath(adjList, srcNode, n)</code> function</h5>
<ul>
<li>Initialize a queue, <code>nodesQueue</code> and a <code>visited</code> array of size <code>n</code>.</li>
<li>Push<code>srcNode</code> into the queue and mark it as visited.</li>
<li>Initialize <code>distance</code> to <code>0</code>.</li>
<li>While the <code>nodesQueue</code> is not empty:
<ul>
<li>Initialize <code>numOfNodesInLayer</code> to the size of the queue.</li>
<li>Process all nodes in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>numOfNodesInLayer - 1</code>:
<ul>
<li>Pop out the first element from the queue as <code>currentNode</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:</li>
<li>If the <code>neighbor</code> is visited, skip it.</li>
<li>Otherwise, mark it as visited and push it into the <code>nodesQueue</code>.</li>
</ul>
</li>
<li>Increment <code>distance</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>distance</code>.</li>
</ul>
<h5 id="getnumberofgroupsforcomponentadjlist-node-distances-visited-function"><code>getNumberOfGroupsForComponent(adjList, node, distances, visited)</code> function</h5>
<ul>
<li>Initialize <code>maxNumberOfGroups</code> to <code>distances[node]</code>.</li>
<li>Mark the current node as visited.</li>
<li>Explore the rest of the nodes in the component, i.e. for each <code>neighbor</code> of <code>node</code>:
<ul>
<li>If the <code>neighbor</code> is visited, skip it.</li>
<li>Otherwise, set <code>maxNumberOfGroups</code> to the maximum of its current value and <code>getNumberOfComponentsInGroup(adjList, neighbor, distances, visited)</code>.</li>
</ul>
</li>
<li>Return <code>maxNumberOfGroups</code>.</li>
</ul>
<h5 id="in-the-main-magnificentsetsn-edges-function">In the main <code>magnificentSets(n, edges)</code> function:</h5>
<ul>
<li>Create the <code>adjList</code> of the graph.</li>
<li>Create a <code>colors</code> array of size <code>n</code> with all elements initially set to <code>-1</code>.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>If the <code>node</code> have not been assigned a color, i.e. (<code>colors[node] == -1</code>):
<ul>
<li>Fix the color of the first node of the component, i.e. set <code>colors[node] = 0</code>.</li>
<li>Call <code>isBipartite(adjList, node, colors)</code> to determine if the current component is bipartite. If not, return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an array <code>distances</code> to store the length of the longest shortest path from any node to any other.</li>
<li>Fill the <code>distances</code> array using the <code>getLongestShortestPath</code> function.</li>
<li>Initialize <code>maxNumberOfGroups</code> to <code>0</code> and a <code>visited</code> array with all elements set to <code>false</code>.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>If <code>node</code> has not been visited:
<ul>
<li>Get the number of groups for its component and add it to the total number of groups, i.e. <code>maxNumberOfGroups += getNumberOfGroupsForComponent(adjList, node, distances, visited)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxNumberOfGroups</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/BbpVEPXV/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph and <span class="math inline">\(m\)</span> the size of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (n + m))\)</span></p>
<p>To check whether the graph is bipartite, we perform a DFS traversal, assigning a color to each node exactly once and visiting each edge exactly once. Thus, this step has a time complexity of <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Next, calculating the longest shortest path for each node involves <span class="math inline">\(n\)</span> BFS traversals (one for each node as the source), resulting in a time complexity of <span class="math inline">\(O(n \times (n + m))\)</span>.</p>
<p>Finally, another DFS is performed to compute the sum of the longest shortest paths across all components, which adds an additional <span class="math inline">\(O(n + m)\)</span> to the total.</p>
<p>Overall, the total time complexity is <span class="math inline">\(O(n + m) + O(n \times (n + m)) + O(n + m) = O(n \times (n + m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Constructing the adjacency list from the list of edges requires <span class="math inline">\(O(n + m)\)</span> space, which is an additional space requirement rather than part of the input itself. Therefore, the total auxiliary space complexity is determined by both the adjacency list and the additional data structures (<code>visited</code>, <code>nodesQueue</code>, <code>colors</code>), all of which take <span class="math inline">\(O(n)\)</span> space. As a result, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bfs--union-find">Approach 2: BFS + Union-Find</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, instead of checking bipartiteness to find if there is a valid split, we attempt to directly maximize the number of groups the graph can be partitioned into. Let's first consider the strategy for a single component:</p>
<p>We begin by assigning each node in the component to the first group. From there, we attempt to propagate this group assignment to the neighboring nodes, creating a new group for each &quot;layer&quot; of neighbors. This means that nodes at the same distance from the starting node would belong to the same group, while nodes at different distances would belong to different groups.</p>
<p>However, if we ever come across a neighbor that has already been assigned the same group as the current node, it means that it's not possible to partition the graph in the way we're attempting. In that case, the graph is not partitionable, and we return <code>-1</code>.</p>
<p>Once we explore all possible groups for the component by starting the process at each node in the component, we find the maximum number of groups that can be formed. This maximum value will be the largest number of groups we can use to partition the nodes of that particular component.</p>
<p>Finally, to compute the answer for the entire graph, we repeat this process for each connected component, summing the maximum number of groups from all components. To efficiently track the connected nodes and perform the necessary computations, we use the Union-Find data structure, which helps us manage and combine the connected components as we progress through the graph.</p>
<blockquote>
<p>For a more comprehensive understanding of Union-Find / Disjoint Set, check out the <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union-Find/Disjoint Set Explore Card</a>. This resource provides an in-depth look at union-find, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h4 id="getnumberofgroupsadjlist-srcnode-n"><code>getNumberOfGroups(adjList, srcNode, n)</code></h4>
<ul>
<li>Initialize a queue, <code>nodesQueue</code>, and an array, <code>layerSeen</code> of size <code>n</code> with all values set to <code>-1</code>.</li>
<li>Push<code>srcNode</code> into the queue and set <code>layerSeen[srcNode]</code> to <code>0</code>.</li>
<li>Initialize <code>deepestLayer</code> to <code>0</code>.</li>
<li>While the <code>nodesQueue</code> is not empty:
<ul>
<li>Initialize <code>numOfNodesInLayer</code> to the size of the queue.</li>
<li>Process all nodes in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>numOfNodesInLayer - 1</code>:
<ul>
<li>Pop out the first element from the queue as <code>currentNode</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:
<ul>
<li>If the <code>neighbor</code> is not visited, i.e. <code>layerSeen[neighbor] == -1</code>:
<ul>
<li>Set <code>layerSeen[neighbor] = deepestLayer + 1</code>.</li>
<li>Push <code>neighbor</code> into the queue.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>If the <code>neighbor</code> is seen in the current layer (<code>deepestLayer</code>), then the split is invalid; return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>deepestLayer</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>deepestLayer</code>.</li>
</ul>
<h5 id="findnode-parent-function"><code>find(node, parent)</code> function</h5>
<ul>
<li>While <code>node</code> is not the root of its subtree, i.e. <code>parent[node] != -1</code>:
<ul>
<li>Set <code>node = parent[node]</code>.</li>
</ul>
</li>
<li>Return <code>node</code>.</li>
</ul>
<h5 id="unionnode1-node2-parent-depth-function"><code>Union(node1, node2, parent, depth)</code> function</h5>
<ul>
<li>Replace <code>node1</code> and <code>node2</code> by the roots of their subtrees, by setting <code>node1 = find(node1, parent)</code> and <code>node2 = find(node2, parent)</code>.</li>
<li>If <code>node1 == node2</code>, the two nodes already belong in the same set, so simply return.</li>
<li>If <code>node1</code> has a smaller depth than <code>node2</code>, swap the two nodes.</li>
<li>Set <code>node1</code> to be the parent of <code>node2</code>.</li>
<li>If the depths of the two nodes are equal, increment <code>depth[node1]</code> by <code>1</code>.</li>
</ul>
<h5 id="in-the-main-magnificentsetsn-edges-function-1">In the main <code>magnificentSets(n, edges)</code> function:</h5>
<ul>
<li>Create a 2D array, <code>adjList</code>.</li>
<li>Initialize two arrays of size <code>n</code>, <code>parent</code>, and <code>depth</code> for the Union-Find. Set the parent of each node to <code>-1</code> and its depth to <code>0</code>.</li>
<li>For each <code>edge = [node1, node2]</code> in <code>edges</code>:
<ul>
<li>Push <code>node1 - 1</code> to <code>adjList[node2 - 1]</code> (transitioning to 0-index).</li>
<li>Push <code>node2 - 1</code> to <code>adjList[node1 - 1]</code>.</li>
<li>Call <code>Union(node1 - 1, node2 - 1, parent, depth)</code>.</li>
</ul>
</li>
<li>Initialize a map, <code>numOfGroupsForComponent</code> to store the greatest number of groups that can be achieved for each component of the graph.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>Calculate the number of groups the nodes of its component will be split into, if we assign <code>node</code> to the first group: <code>numberOfGroups = getNumberOfGroups(adjList, node, n)</code>.</li>
<li>If <code>numberOfGroups = -1</code>, then a split is impossible for that component, so return <code>-1</code>.</li>
<li>Find the <code>rootNode</code> of <code>node</code>s component, <code>root = find(node, parent)</code>.</li>
<li>Update the greatest number of groups that can be achieved for this component (<code>numOfGroupsForComponent[rootNode]</code>) to the maximum of its current value and <code>numberOfGroups</code>.</li>
</ul>
</li>
<li>Initialize <code>totalNumberOfGroups</code> to <code>0</code>.</li>
<li>For every <code>[rootNode, numberOfGroups]</code> in <code>numOfGroupsForComponent</code>:
<ul>
<li>Add <code>numberOfGroups</code> to <code>totalNumberOfGroups</code>.</li>
</ul>
</li>
<li>Return <code>totalNumberOfGroups</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7q5R733V/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph and <span class="math inline">\(m\)</span> the size of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (n + m))\)</span></p>
<p>We use the Union-Find method to detect the connected components of the graph. Each call to the find function traverses the nodes in the component of the given node until it reaches the root. By using the <code>depth</code> array, we maintain balanced sets, ensuring that the find operation has a time complexity of <span class="math inline">\(O(\log n)\)</span>. As a result, the process of identifying the connected components takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Next, we perform a BFS traversal starting from each node. Since the time complexity of BFS is <span class="math inline">\(O(m + n)\)</span>, the total time for this operation is <span class="math inline">\(O(n \times (m + n))\)</span>.</p>
<p>Since <span class="math inline">\(n \log n = O(n \times (m + n))\)</span>, the overall time complexity is dominated by the BFS traversals, giving us a final time complexity of <span class="math inline">\(O(n \times (n + m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>As in the previous approach, representing the graph using an adjacency list requires <span class="math inline">\(O(n + m)\)</span> space. This is an additional space requirement rather than part of the input itself. The auxiliary space complexity is determined by both the adjacency list and the additional data structures used (<code>parent</code>, <code>depth</code>, <code>numberOfGroupsForComponent</code>), which can grow up to <span class="math inline">\(O(n)\)</span> in size. Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/divisibility-tree1902/1" target="_blank" rel="noopener noreferrer">Divisibility tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a tree with n nodes where <strong>n</strong> is <strong>even</strong>. The tree is numbered from 1 to n, has n - 1 edges and is rooted at node 1. </span><span style="font-size: 18px;">Your task is to eliminate the <strong>maximum </strong>number of edges resulting in a set of disjoint trees where the number of nodes in each tree is divisible by <strong>2</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">n = 10, edges = [[2,1],[3,1],[4,3],[5,2],[6,1],[7,2],[8,6],[9,8],[10,8]]
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">2
</span><strong style="font-size: 18px;">Explanation:<br /></strong><span style="font-size: 18px;">Original tree:<br /></span></span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880846/Web/Other/blobid0_1732601788.png" width="432" height="428" /><br />After removing edge 1-3 and 1-6, each remaining component consists of even number of nodes. <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880846/Web/Other/blobid1_1732601873.png" width="430" height="426" /><br /></span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">n = 4, edges = [[2,1],[4,2],[1,3]]
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">1
</span><span style="font-size: 18px;"><strong style="font-size: 18px;">Explanation: <br /></strong><span style="font-size: 18px;">Original tree:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880846/Web/Other/blobid2_1732602037.png" width="424" height="420" /></span><strong style="font-size: 18px;"><br /></strong></span><span style="font-size: 18px;">After removing 1-2, each remaining component consists of even number of nodes.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/880846/Web/Other/blobid3_1732602310.png" width="421" height="417" /><br /></span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 10<sup>5</sup><br />edges.size() = n - 1<br />1 &lt;= edges[i][0], </span><span style="font-size: 18px;">edges[i][1] &lt;= n</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/euler-circuit-and-path/1" target="_blank" rel="noopener noreferrer">Euler circuit and Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><strong>An Eulerian Path</strong> is a path in graph that visits every edge exactly once. <strong>An Eulerian Circuit </strong>is <strong>an Eulerian Path </strong>which starts and ends on the same vertex. Given an <strong>undirected graph</strong> with <strong>V</strong> nodes, and <strong>E</strong> edges, with adjacency list <strong>adj,&nbsp;</strong>return 2 if the graph contains an <strong>eulerian circuit</strong>, else if the graph contains an <strong>eulerian path,&nbsp;</strong>return 1, otherwise, return 0.</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700537/Web/Other/blobid0_1745469108.jpg" width="226" height="200" /><br /><strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">2
<strong>Explanation: <br /></strong>Following is an eulerian circuit in the mentioned graph<strong><br /></strong></span><span style="font-size: 14pt;">1 -&gt; 2 -&gt; 0 -&gt; 1</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><br /><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700537/Web/Other/blobid4_1745469310.jpg" width="221" height="196" /></span><br /><strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">1
<strong>Explanation: <br /></strong></span><span style="font-size: 14pt;">Following is an eulerian path in the mentioned graph<br />1 -&gt; 0 -&gt; 2</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function <strong>isEulerCircuilt()&nbsp;</strong>which takes number of vertices in the graph denoted as <strong>V</strong> and an adjacency list of graph denoted as <strong>adj </strong>and&nbsp;</span><span style="font-size: 18px;">returns 2 if the graph contains an&nbsp;</span><strong style="font-size: 18px;">eulerian circuit</strong><span style="font-size: 18px;">, else if the graph contains an&nbsp;</span><strong style="font-size: 18px;">eulerian path, </strong><span style="font-size: 18px;">it returns 1, otherwise, it will return 0.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(V+E) where E is the number of edges in graph.<br /><strong>Expected Space Complexity:&nbsp;</strong>O(V)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; V, E &le; 10<sup>4<br /></sup>1 &le; adj[i][j] &le; V-1<sup><br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/euler-circuit-in-a-directed-graph/1" target="_blank" rel="noopener noreferrer">Euler Circuit in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="text-decoration: underline;"><strong><a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian Path</a>&nbsp;</strong></span>is a path in a graph that visits <strong>every edge exactly once</strong>. Eulerian Circuit is an Eulerian Path that <strong>starts</strong> and <strong>ends</strong> on the <strong>same vertex</strong>. Given the number of vertices <strong>v</strong> and adjacency list <strong>adj</strong> denoting the graph. Find that there exists the Euler circuit or not. Return <strong>1</strong> if there exist&nbsp; <strong>alteast one</strong> eulerian circuit else <strong>0.</strong></span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>v = 4, edges[][] = [[0, 1], [0, 2], [1, 3], [2, 3]]
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700536/Web/Other/blobid0_1745469597.jpg" width="278" height="246" /> <br /><span style="font-size: 18px;"><strong>Output: </strong>1
<strong>Explanation: </strong>corresponding adjacency list will be {{1, 2},{0, 3},{0, 3},{1, 2}}<br />One of the Eularian circuit 
starting from vertex 0 is as follows:
0-&gt;1-&gt;3-&gt;2-&gt;0</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>v = 3, edges[][] = [[0, 1], [0, 2]]    
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700536/Web/Other/blobid1_1745469684.jpg" width="280" height="248" /><br /><span style="font-size: 18px;"><strong>Output: </strong>0<br /><strong>Explanation: </strong>corresponding adjacency list will be {{1, 2}}<strong><br /></strong>No Eulerian path is found.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>isEularCircuitExist()</strong> which takes&nbsp;<strong>v</strong> and array of edges <strong>adj[]</strong>&nbsp;as input parameter and returns boolean value <strong>1</strong> if Eular circuit exists otherwise returns <strong>0</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(v + e)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(v)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= v &lt;= 10<sup>5</sup><br />1 &lt;= edges &lt;= 2*10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/eulerian-path-in-an-undirected-graph5052/1" target="_blank" rel="noopener noreferrer">Eulerian Path in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an adjacency matrix representation of an unweighted undirected graph named&nbsp;<strong>graph</strong>, which has <strong>N</strong> vertices. You have to find out if there is an <a href="https://en.wikipedia.org/wiki/Eulerian_path">eulerian path</a> present in the graph&nbsp;or not.<br /><strong>Note:</strong> The graph consists of a single component</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> N = 5
graph = {{0, 1, 0, 0, 1}, 
&nbsp;        {1, 0, 1, 1, 0}, 
&nbsp;        {0, 1, 0, 1, 0}, 
&nbsp;        {0, 1, 1, 0, 0}, 
&nbsp;        {1, 0, 0, 0, 0}}
<strong>Output:</strong> 1
<strong>Explaination:</strong> There is an eulerian path. 
The path is 5-&gt;1-&gt;2-&gt;4-&gt;3-&gt;2.</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> N = 5
graph = {{0, 1, 0, 1, 1}, 
&nbsp;        {1, 0, 1, 0, 1}, 
&nbsp;        {0, 1, 0, 1, 1}, 
&nbsp;        {1, 0, 1, 0, 0}, 
&nbsp;        {1, 1, 1, 0, 0}}
<strong>Output:</strong> 0
<strong>Explaination:</strong> There is no eulerian path in 
the graph.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You do not need to read input or print anything. Your task is to complete the function <strong>eulerPath()</strong> which takes N and graph as input parameters and returns 1 if there is an eulerian path. Otherwise returns 0.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 50&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/evaluate-division/description" target="_blank" rel="noopener noreferrer">Evaluate Division</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>

<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>

<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>

<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>

<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]
<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]
<strong>Explanation:</strong> 
Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>
queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined =&gt; -1.0</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]
<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]
<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= equations.length &lt;= 20</code></li>
	<li><code>equations[i].length == 2</code></li>
	<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>
	<li><code>values.length == equations.length</code></li>
	<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>
	<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/eventual-safe-states/1" target="_blank" rel="noopener noreferrer">Eventual Safe States</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">A directed graph of <strong>V</strong> vertices and <strong>E</strong> edges is given in the form of an adjacency list <strong>adj</strong>. Each node of the graph is labelled with a distinct integer in the range <strong>0</strong> to <strong>V - 1</strong>.</span></p>
<p><span style="font-size: 18px;">A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong>.</span></p>
<p><span style="font-size: 18px;">You have to return an array containing all the <strong>safe nodes</strong> of the graph. The answer should be sorted in <strong>ascending</strong> order.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711095/Web/Other/blobid0_1745299307.jpg" width="355" height="314" /><br /><span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">2 4 5 6</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">The given graph is shown above.</span>
<span style="font-size: 18px;">Nodes 5 and 6 are terminal nodes as there are no 
outgoing edges from either of them. </span>
<span style="font-size: 18px;">Every path starting at nodes 2, 4, 5, and 6 all 
lead to either node 5 or 6.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711095/Web/Other/blobid1_1745299371.jpg" width="361" height="237" /><br /><strong><span style="font-size: 18px;">Output:</span> </strong><span style="font-size: 18px;">3</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">Only node 3 is a terminal node, and every path 
starting at node 3 leads to node 3.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>eventualSafeNodes</strong><strong>()&nbsp;</strong>which takes an integer&nbsp;<strong>V</strong> denoting no. of vertices and <strong>adj</strong> denoting adjacency list of the graph and returns an array of <strong>safe nodes</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(V + E)</span></p>
<p><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(V)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= V &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">0 &lt;= E &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">The graph won't contain self loops.</span></li>
<li><span style="font-size: 18px;">Each node in the graph has a distinct value in the range 0 to V - 1.</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/fill-the-tank3026/1" target="_blank" rel="noopener noreferrer">Fill the Tank</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">In a city,&nbsp;<strong>N</strong> water tanks are connected by pipeline(As a tree) where the <strong>ith</strong> tank has a capacity <strong>cap[i]</strong>. The <strong>ith </strong>element of the given <strong>Edge</strong> array of length <strong>N-1</strong> represents that there is a pipeline between <strong>Edge[i][0]</strong> and <strong>Edge[i][1]</strong> tank.&nbsp;Since people working at the city corporation are lazy they usually select one of the tank and pour complete amount of water into it, <strong>when the tank is filled, the excess water evenly flows to the connected tanks.</strong> The head of city corporation has instructed to <strong>pour minimum amount of water into the selected tank so that all other tank is filled</strong>. As the labours of the corporation are not intelligent enough to figure out the minimum amount of water required to fill all the tanks they have asked your help. Also Maximum amount of water available with city corporation is 10<sup>18</sup>.</span></p>

<p><span style="font-size:18px"><strong>NOTE</strong>: If the tank if full, the water flows to all of its connected tanks except the tank from which the water had come to it. i.e, to all tanks except the source for that particular tank. If it has no option to flow the water is considered to be wasted.<strong> S</strong> is the source tank.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
N = 4 and S = 1
Edges = [[1, 2], [1, 3], [2, 4]]
Cap = [1, 1, 1, 1]
<strong>Output:</strong>&nbsp;5
<strong>Explanation</strong>:
Initially 5 unit of water is poured into 
tank 1. 2 unit of it flows to tank 2 <strong>and</strong> 
2 unit of it flows into tank 3. From 2 
unit of water in tank 2, 1 unit flows into 
tank 4 <strong>and</strong> 1 unit from tank 3 is wasted.
<img alt="" src="https://contribute.geeksforgeeks.org/wp-content/uploads/fill-the-tank.jpg" style="height:500px; width:667px" />

</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 3 and S = 2
Edges = [[1, 2], [2, 3]]
Cap = [1, 1, 1]
<strong>Output: </strong>3
</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>minimum_amount()</strong>&nbsp;which takes an integer <strong>N</strong>, an&nbsp;integer&nbsp;<strong>S</strong>, 2-d array <strong>Edges</strong>, and an array <strong>Cap</strong>&nbsp;of length&nbsp;N as input parameters and returns the minimum amount of water required to fill all the tanks. If it is not possible to fill all the tanks print -1.<br />
<br />
<strong>Expected Time Complexity:</strong> O(N*log(S))<br />
<strong>Expected Auxiliary Space:</strong> O(1)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n &le; 100000<br />
1&nbsp;&le; s,u,v &le; n<br />
1 &le; capacity of each tank &le; 1000000007</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/critical-connections/1" target="_blank" rel="noopener noreferrer">Find all Critical Connections in the Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">A <strong>critical connection </strong>refers to an edge that, upon removal, will make it impossible for certain nodes to reach each other through any path. You are given an <strong>undirected connected graph </strong>with <strong>v</strong> vertices and <strong>e</strong> edges where each vertex is distinct and ranges from <strong>0 to v-1</strong>, and you have to find all <strong>critical connections </strong>in the graph. It is ensured that there is at least one such edge present.</span></p>
<p><span style="font-size: 18px;">Note: Return the connections in sorted order.</span></p>
<p><strong style="font-size: 18px;">Examples:</strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706303/Web/Other/blobid0_1745300798.jpg" width="309" height="309" /><br /><strong>Output: </strong>
0 1
0 2
<strong>Explanation</strong>: 
On removing edge (0, 1), you will not be able to reach node 0 and 2 from node 1. Also, on removing edge (0, 2), you will not be able to reach node 0<br />and 1 from node 2.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706303/Web/Other/blobid1_1745300819.jpg" width="305" height="305" /><br /><strong>Output:</strong>
2 3
<strong>Explanation</strong>:
The edge between nodes 2 and 3 is the only Critical connection in the given graph.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; v, e &le; 10<sup>4<br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-people-with-secret/description" target="_blank" rel="noopener noreferrer">Find All People With Secret</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> indicating there are <code>n</code> people numbered from <code>0</code> to <code>n - 1</code>. You are also given a <strong>0-indexed</strong> 2D integer array <code>meetings</code> where <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> indicates that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> have a meeting at <code>time<sub>i</sub></code>. A person may attend <strong>multiple meetings</strong> at the same time. Finally, you are given an integer <code>firstPerson</code>.</p>

<p>Person <code>0</code> has a <strong>secret</strong> and initially shares the secret with a person <code>firstPerson</code> at time <code>0</code>. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person <code>x<sub>i</sub></code> has the secret at <code>time<sub>i</sub></code>, then they will share the secret with person <code>y<sub>i</sub></code>, and vice versa.</p>

<p>The secrets are shared <strong>instantaneously</strong>. That is, a person may receive the secret and share it with people in other meetings within the same time frame.</p>

<p>Return <em>a list of all the people that have the secret after all the meetings have taken place. </em>You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,5]
<strong>Explanation:
</strong>At time 0, person 0 shares the secret with person 1.
At time 5, person 1 shares the secret with person 2.
At time 8, person 2 shares the secret with person 3.
At time 10, person 1 shares the secret with person 5.​​​​
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>Output:</strong> [0,1,3]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 3.
At time 2, neither person 1 nor person 2 know the secret.
At time 3, person 3 shares the secret with person 0 and person 1.
Thus, people 0, 1, and 3 know the secret after all the meetings.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,4]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 1.
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
Note that person 2 can share the secret at the same time as receiving it.
At time 2, person 3 shares the secret with person 4.
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
	<li><code>meetings[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem,</p>
<ul>
<li>
<p>We have <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and</p>
</li>
<li>
<p>Initially (at time <code>t = 0</code>), person <code>0</code> and <code>firstPerson</code> know the secret.</p>
</li>
<li>
<p>Multiple <code>meetings</code> take place between people. Each meeting is characterized by an array <code>[x, y, t]</code>, where <code>x</code> and <code>y</code> are the labels of the two people that meet, and <code>t</code> is the time of the meeting. If any one of the two people who meet knows the secret at a time <code>t</code>, then both of them will know the secret instantly at the time <code>t</code>.</p>
<p>More than one meeting can take place at the same time <code>t</code></p>
<p>A person can attend multiple meetings at the same time <code>t</code></p>
<blockquote>
<p>If at a time <code>t</code>, we are given the following meetings:</p>
<ul>
<li><code>x</code> and <code>y</code></li>
<li><code>x</code> and <code>z</code></li>
<li><code>z</code> and <code>w</code></li>
<li><code>a</code> and <code>b</code></li>
</ul>
<p>Then we can deduce that all <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code> are in the same meeting at the time <code>t</code>.</p>
</blockquote>
<p>Thus, given fixed time <code>t</code>, meetings evolve as <a href="https://en.wikipedia.org/wiki/Equivalence_relation">Equivalence Relation</a>. Particularly meetings are <a href="https://en.wikipedia.org/wiki/Transitive_relation"><strong>transitive</strong></a> in nature.</p>
<p>It's worth noting that it is <strong>NOT</strong> necessary that all participants of the meeting happening at a time <code>t</code>  are in the same meeting. Meetings can be disjoint even if they are happening at the same time <code>t</code>.</p>
<blockquote>
<p>For example, there are two meetings in the above-mentioned example. In the first meeting, we have <code>(x, y, z, w)</code> and in the second meeting, we have <code>(a, b)</code>. Both meetings are happening at the same time <code>t</code> but they are disjoint.</p>
</blockquote>
</li>
</ul>
<p>We are supposed to find and return the labels of all the people who know the secret after all the meetings have taken place.</p>
<p>The editorial systematically solves the problem using multiple approaches.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given that person <code>0</code> and <code>firstPerson</code> know the secret at time <code>t = 0</code>.</p>
<p>Let's restrict our attention to person <code>0</code> only.<br />
<em>(We may generalize our solution for <code>firstPerson</code> similarly)</em></p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_1.PNG" alt="p0" /></p>
<p><code>0</code> knows the secret at time <code>t = 0</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_2.PNG" alt="t0" /></p>
<p>Assume person <code>0</code> takes part in following meetings <code>[0, 1, 3]</code>, <code>[0, 2, 5]</code>, <code>[0, 3, 6]</code>, sorted in ascending order of time.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_3.PNG" alt="m0" /></p>
<p>Highlighted meetings take place <strong>after or at time <code>t = 0</code></strong>, the time at which person <code>0</code> learned the secret.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide2_1.PNG" alt="mt0" /></p>
<p>Hence we can say that all those persons corresponding to highlighted meetings will know the secret at the time of the meeting.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide2_2.PNG" alt="mp0" /></p>
<p>Now let's assume that person <code>1</code> takes part in the following meetings <code>[1, 4, 2]</code>, <code>[1, 9, 4]</code>. There is also a meeting <code>[1, 0, 3]</code>, but it has been processed already.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide3.PNG" alt="m1" /></p>
<p>Out of these two, only one meeting <code>[1, 9, 4]</code> takes place <strong>after or at time <code>t = 3</code></strong>, the time at which person <code>1</code> learned the secret, as per the current state of knowledge. Hence, we can say that only person <code>9</code> will know the secret after meeting <code>1</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide4.PNG" alt="mp1" /></p>
<p>Can we now say that person <code>4</code> will NEVER know the secret?<br />
No, we can't. Person <code>4</code> may know the secret in the future.</p>
<p>Hence, we can draft the following approach:</p>
<ul>
<li>
<p>We will start with person <code>0</code> and person <code>firstPerson</code>. They both know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Process people whom they meet after the time at which they learned the secret. All these people will know the secret at the time of the meeting.</p>
<p>Moreover, they will propagate the secret to people they meet after the time they learn the secret. Hence, process these individuals in the same manner as <code>0</code> and <code>firstPerson</code> were processed, except they learned the secret at a different time.</p>
</li>
<li>
<p>Repeat the above step until we have processed all the meetings.</p>
</li>
</ul>
<blockquote>
<p>We are processing persons in a <strong>level-by-level</strong> manner. Whenever we realize that a person knows the secret, we make sufficient efforts to process all the people whom he/she meets after the time at which he/she learned the secret, since we know that they will ultimately know the secret.</p>
<p><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/"><strong>Breadth First Search (BFS)</strong></a> is a natural choice to explore level by level, usually implemented with the help of the queue.<br />
It is a graph traversal algorithm that explores the neighbor nodes first, before moving to the next level neighbors. If readers are not familiar with the BFS, they are strongly encouraged to dive into our <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/"><strong>Queue Explore Card</strong></a> and <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/"><strong>Graph Explore Card</strong></a></p>
</blockquote>
<p>Readers are encouraged to implement the above approach. It is worth mentioning that in <code>meetings</code> we are given meetings in the form of <code>[x, y, t]</code>. However, we are interested that given <code>x</code>, we should be able to find the <code>(y, t)</code> pair for all the meetings in which <code>x</code> participated. Hence, we should use an appropriate data structure to store the information.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create a queue <code>q</code> to store the people whom we need to process. It will store <code>(person, time of knowing the secret)</code>.</p>
<p>Initially, we will add <code>(0, 0)</code> and <code>(firstPerson, 0)</code> to the queue since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create an <code>earliest</code> array of size <code>n</code>. It will store the earliest time at which a person learned the secret as per the current state of knowledge. It will be initialized with <code>INT.MAX</code> for all the people indicating that no one knows the secret.</p>
<p>However, for person <code>0</code> and <code>firstPerson</code>, we will update the <code>earliest</code> array with <code>0</code> since they know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Do the following while the <code>q</code> is not empty:</p>
<ol>
<li>
<p>Deque the front of <code>q</code> and store it in <code>(person, time)</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>earliest[nextPerson] &gt; t</code>, then update <code>earliest[nextPerson] = t</code> and add <code>(nextPerson, t)</code> to the queue.</p>
<blockquote>
<p>We are adding <code>(nextPerson, t)</code> to the queue because we have updated <code>earliest[nextPerson]</code> and we need to process all the people whom <code>nextPerson</code> meets after time <code>t</code>.</p>
</blockquote>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>earliest[nextPerson] &gt; t</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>earliest[nextPerson] &lt;= t</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>Iterate over the <code>earliest</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>earliest[i] != INT.MAX</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EpvjQ4P4/shared">code</a></p>
<p><strong>Implementation Note:</strong> The above implementation is slightly different from the standard <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth First Search</a>. In standard Breadth First Search, we never process a node twice, and we facilitate this by maintaining a separate <code>visited</code> array.</p>
<p>However, in the above implementation, we may process a node again if we get to know that the earliest time at which a person learns the secret decreases. To facilitate this we are maintaining the <code>earliest</code> array.</p>
<p>Let's assume we will NOT revisit a node.</p>
<pre><code class="language-testcase">4
[[0,1,4],[1,3,3],[2,1,2]]
2
</code></pre>
<p>This can be represented in the graph as follows. The green-colored people are those who initially know the secret.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_1.PNG" alt="graph" /></p>
<p>The front of the queue <code>(0, 0)</code> will be processed first. We will process person <code>0</code>, and will add its neighbors to the queue. Hence, <code>(1, 4)</code> will be added to the queue.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_2.PNG" alt="q0" /></p>
<p>Next in the queue is <code>(2, 2)</code>. We will process person <code>2</code>. However, all its neighbors are already processed. Hence, we will not add any new person to the queue.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_3.PNG" alt="q1" /></p>
<p>Next in the queue is <code>(1, 4)</code>. We will process person <code>1</code>, and due to state information, we will assume that it was informed of the secret at time <code>t = 4</code>. Hence, it can inform the secret only to those people it meets after time <code>t = 4</code>. However, it meets person <code>3</code> at time <code>t = 3</code>, hence we will not add person <code>3</code> to the queue.</p>
<p>Turns out we are incorrect. Person <code>1</code> was informed of the secret at time <code>t = 2</code>, because of meeting <code>[2, 1, 2]</code>. Hence, <code>1</code> can inform the secret to person <code>3</code> at time <code>t = 3</code>.</p>
<p>We are arriving at an incorrect answer because of the incorrect assumption that we will not revisit a node. Hence, we need to revisit a node if we realize that the earliest time at which a person learns the secret decreases.</p>
<blockquote>
<p><strong>Connecting the Dots:</strong> <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's algorithm</a> is used for finding shortest path in a graph. It works when the weights of edges are non-negative.</p>
<p>However, we can modify the algorithm to work for graphs where the weights of edges can be negative, but no negative cycle is present. The above algorithm captures the essence of the <strong>modified Dijkstra's algorithm</strong>. The key idea is to revisit a node if we realize that the shortest distance to a node decreases.</p>
<p>However, readers must note that this problem, ideally <strong>cannot</strong> be modeled as the shortest path problem, particularly because meeting time is not the weight of edges. What we have done is to use the idea of modified Dijkstra's algorithm to solve the problem.</p>
</blockquote>
<p>Readers should also note that since the initial queue contains more than one element, the process is often called <strong>Multi-Source BFS</strong></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \cdot (M + N) )\)</span></p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we are initializing <code>q</code> by enqueuing two people. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>earliest</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are dequeuing one element from <code>q</code>. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we iterate over neighbors of the dequeued element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and enqueuing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(1 + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was enqueued because of meeting with some other person. Hence, there will be at most <span class="math inline">\(M + N\)</span> iterations of the <code>while</code> loop.</p>
<p>Thus, the <code>while</code> loop takes <span class="math inline">\(O( (M + N) \cdot M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>earliest</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, total time complexity will be <span class="math inline">\(O(M + 1 + N + (M + N) \cdot M + N)\)</span>, which is <span class="math inline">\(O( M \cdot (M + N) )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>earliest</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>q</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the queue. It is worth noting that there can be multiple instances of person <code>x</code> in the queue, with multiple times of knowing the secret</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In <a href="#approach-1-breadth-first-search">previous approach</a>, we were essentially traversing the graph, keeping in mind the condition that we can visit a node only if we are confident that the person will know the secret at the time of the meeting. After traversal, we were returning indices of all the people who were visited.</p>
<p>The graph can be traversed primarily in two ways:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth First Search</a> using <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Queue</a></li>
<li><a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth First Search</a> using <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/">Stack</a></li>
</ul>
<p>In this approach, let's try to solve the problem using Depth First Search. It can be implemented using Recursion or Stack. It is worth noting that Recursion implicitly uses Call Stack.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create an <code>earliest</code> array of size <code>n</code>. It will store the earliest time at which a person learned the secret as per the current state of knowledge. It will be initialized with <code>INT.MAX</code> for all the people indicating that no one knows the secret.</p>
<p>However, for person <code>0</code> and <code>firstPerson</code>, we will update the <code>earliest</code> array with <code>0</code> since they know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create a stack <code>stack</code> to store the people whom we need to process. It will store <code>(person, time of knowing the secret)</code>.</p>
<p>Initially, we will add <code>(0, 0)</code> and <code>(firstPerson, 0)</code> to the stack since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Do the following while the <code>stack</code> is not empty:</p>
<ul>
<li>
<p>Pop the top of <code>stack</code> and store it in <code>(person, time)</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>earliest[nextPerson] &gt; t</code>, then update <code>earliest[nextPerson] = t</code> and add <code>(nextPerson, t)</code> to the stack.</p>
<blockquote>
<p>We are adding <code>(nextPerson, t)</code> to the stack because we have updated <code>earliest[nextPerson]</code> and we need to process all the people whom <code>nextPerson</code> meets after time <code>t</code>.</p>
</blockquote>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>earliest[nextPerson] &gt; t</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>earliest[nextPerson] &lt;= t</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Iterate over the <code>earliest</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>earliest[i] != INT.MAX</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ctKAU7Bo/shared">code</a></p>
<p><strong>Implementation Note:</strong> The above implementation is slightly different from the standard <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth First Search</a>. In standard Depth First Search, we never process a node twice, and we facilitate this by maintaining a separate <code>visited</code> array.</p>
<p>However, in the above implementation, we may process a node again if we get to know that the earliest time at which a person learns the secret decreases. To facilitate this, we are maintaining the <code>earliest</code> array. We are doing this for the same reason mentioned in <a href="#implementation">previous approach</a>.</p>
<p>Here is the implementation using Recursion.</p>
<p><a href="https://leetcode.com/playground/8yJEFXxD/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \cdot (M + N) )\)</span></p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>earliest</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are popping one element from <code>stack</code>. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we iterate over neighbors of the popped element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and pushing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(1 + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was pushed because of meeting with some other person. Hence, there will be at most <span class="math inline">\(M + N\)</span> iterations of the <code>while</code> loop.</p>
<p>Thus, the <code>while</code> loop takes <span class="math inline">\(O( (M + N) \cdot M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>earliest</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M + N + (M + N) \cdot M + N)\)</span>, which is <span class="math inline">\(O( M \cdot (M + N) )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>earliest</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>stack</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the stack. It is worth noting that there can be multiple instances of person <code>x</code> in the stack, with multiple times of knowing the secret.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-earliest-informed-first-traversal">Approach 3: Earliest Informed First Traversal</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's revisit the <a href="#approach-1-breadth-first-search">Approach 1</a>, and particularly the test case discussed in <a href="#implementation">Implementation Note</a>.</p>
<pre><code class="language-testcase">4
[[0,1,4],[1,3,3],[2,1,2]]
2
</code></pre>
<p>If we process each node exactly once, then we will arrive at the incorrect answer. The reason was that person <code>1</code> could know the secret through two different meetings.<br />
<strong>(a)</strong> <code>[0, 1, 4]</code>, from person <code>0</code> at time <code>t = 4</code><br />
<strong>(b)</strong> <code>[2, 1, 2]</code>, from person <code>2</code> at time <code>t = 2</code></p>
<p>If we process the meeting <strong>(a)</strong> before meeting <strong>(b)</strong>, then we will arrive at the incorrect answer.</p>
<p>What if we process the meeting <strong>(b)</strong> before meeting <strong>(a)</strong>? Will we arrive at the correct answer?<br />
Yes, we will, at least for this test case.</p>
<p>In general, we must process that person in the queue whose time of knowing the secret is the minimum. We will dequeue the person with the minimum time of knowing the secret. Moreover, <strong>the person should be marked as visited after it is dequeued from the queue (and not when it is enqueued) because the time the person is enqueued might not be the earliest time the person learned the secret, but the time the person is dequeued will be the earliest time a person learned the secret</strong>. This way, we are ensuring that given a person, if he/she learned the secret through multiple meetings, then we will process the earliest meeting first.</p>
<p>For efficiently dequeuing the person with the minimum time of knowing the secret, we may use <a href="https://leetcode.com/explore/learn/card/heap/">Binary Heap</a> with Min Heap property.</p>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/heap/"><strong>Binary Heap</strong></a> is a specialized binary tree-based data structure that is a complete tree that satisfies the heap property.</p>
<p>In a Min-Heap, the key at the root must be minimum among all keys present in the Binary Heap. The same property must be recursively true for all nodes in the Binary Tree. We can pop and push elements in time proportional to the logarithm of the number of elements present in the heap.</p>
</blockquote>
<blockquote>
<p>The approach is similar to <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's algorithm</a> with a notable difference that the weight of edges represents absolute time and not the time difference.</p>
</blockquote>
<p>Readers are encouraged to implement this approach.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create a priority queue (min-heap) <code>pq</code> to store the people whom we need to process. It will store <code>(time of knowing the secret, person)</code>.</p>
<p>The <code>time of knowing the secret</code> will be used to maintain the Min Heap property. The person with minimum <code>time of knowing the secret</code> will be at the top of the heap.</p>
</li>
<li>
<p>Push <code>(0, 0)</code> and <code>(0, firstPerson)</code> to the queue since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create a <code>visited</code> array of size <code>n</code>. It will store if a person is visited or not. Initially, all the people are not visited.</p>
<p>We will mark a person as visited after it is popped from the queue. This will be the earliest time at which a person learns the secret because we are processing the person with the minimum time of knowing the secret.</p>
</li>
<li>
<p>Do the following while the <code>pq</code> is not empty:</p>
<ol>
<li>
<p>Deque the front of <code>pq</code> and store it in <code>(time, person)</code>.</p>
</li>
<li>
<p>If <code>visited[person]</code> is <code>True</code>, then continue to the next iteration of the <code>while</code> loop. We have already processed <code>person</code> at an earlier time, and we don't need to process it again.</p>
</li>
<li>
<p>Mark <code>visited[person]</code> as <code>True</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>visited[nextPerson]</code> is <code>False</code>, then push <code>(t, nextPerson)</code> to the queue.</p>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>visited[nextPerson]</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>visited[nextPerson]</code> is <code>True</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>Iterate over the <code>visited</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>visited[i]</code> is <code>True</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/W6xzxQjv/shared">code</a></p>
<p><strong>Implementation Note:</strong> In <code>for</code> loop under <code>while</code>, we are checking every <code>(t, nextPerson)</code> pair of <code>graph[person]</code> to find all those <code>t &gt;= time</code>, where <code>time</code> is earliest time person learned the secret.</p>
<p>However, if <code>graph[person]</code> was sorted in increasing order of <code>t</code>, then instead of starting from the very beginning of <code>graph[person]</code>, we can start from the index where <code>t &gt;= time</code>. This index can be found using <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search</a> because <code>graph[person]</code> is sorted. This will reduce the number of iterations of the <code>for</code> loop. Readers are encouraged to implement this optimization and comment on their implementation.</p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( (N + M) \log (N + M) + N M )\)</span>.</p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we are initializing min-heap <code>pq</code> by enqueuing two people. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>visited</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are popping one element from <code>pq</code>. It will take <span class="math inline">\(O(\log (N + M))\)</span> time because, at any instance, there can be at most <span class="math inline">\(N + M\)</span> elements in the heap.</p>
</li>
<li>
<p>Then we iterate over neighbors of the popped element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and pushing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(\log (N + M) + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was enqueued because of meeting with some other person. Hence, there will be at most <span class="math inline">\(N + M\)</span> iterations of the <code>while</code> loop.</p>
<p>However, we will process the <code>for</code> loop only for those neighbors of a person who has not been visited. Hence, the <code>for</code> loop of time complexity <span class="math inline">\(O(M)\)</span> will run for at most <span class="math inline">\(N\)</span> iterations of the <code>while</code> loop.</p>
<ul>
<li>
<p>Thus, for <span class="math inline">\(N\)</span> iterations of the <code>while</code> loop, it will take <span class="math inline">\(O( \log (N + M) + M )\)</span> time.</p>
</li>
<li>
<p>For <span class="math inline">\(M\)</span> iterations of the <code>while</code> loop, it will take <span class="math inline">\(O( \log (N + M))\)</span> time. The <code>for</code> loop will not run for these iterations.</p>
</li>
</ul>
<p>Thus, <code>while</code> loop takes <span class="math inline">\(O( N \cdot ( \log (N + M) + M )  + M \cdot \log (N + M) )\)</span> time, which is <span class="math inline">\(O( N \cdot \log (N + M) + N \cdot M + \log (N + M) \cdot M )\)</span> time. This can be rearranged as <span class="math inline">\(O(  (N + M) \log (N + M) + N M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>visited</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, total time complexity will be <span class="math inline">\(O(M + 1 + N + (N + M) \log (N + M) + N M + N)\)</span>, which is <span class="math inline">\(O( (N + M) \log (N + M) + N M )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>pq</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the queue. It is worth noting that there can be multiple instances of person <code>x</code> in the queue, with multiple times of knowing the secret.</p>
</li>
<li>
<p>The <code>visited</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-breadth-first-search-on-time-scale">Approach 4: Breadth First Search on Time Scale</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let's minutely analyze an arbitrary meeting <code>[x, y, t]</code>:</p>
<ul>
<li>
<p>If any one of <code>x</code> or <code>y</code> were informed the secret <strong>before or at time <code>t</code></strong>, then both <code>x</code> and <code>y</code> will know the secret at time <code>t</code>.</p>
<blockquote>
<p>This will be true for all participants of all transitive meetings happening at time <code>t</code> as well.</p>
</blockquote>
<blockquote>
<p>However, for disjoint meetings happening at the time <code>t</code>, this may or may not be true. To decide on disjoint meetings, we need to separately analyze each disjoint meeting at the time <code>t</code>.</p>
</blockquote>
</li>
<li>
<p>If none of <code>x</code> and <code>y</code> <em>(or as a general case, no participant of transitive meeting)</em> were informed the secret <strong>before or at time <code>t</code></strong>, then none of <code>x</code> and <code>y</code> <em>(or as a general case, no participant of transitive meeting)</em> will know the secret at time <code>t</code>.</p>
<blockquote>
<p>However, for disjoint meetings happening at the time <code>t</code>, this may or may not be true. To decide on disjoint meetings, we need to separately analyze each disjoint meeting at the time <code>t</code>.</p>
</blockquote>
<p>Let's assume that one participant of a transitive meeting gets to know the secret <strong>after time <code>t</code></strong>. It is worth noting that knowing after time <code>t</code> will not affect meetings happening at the time <code>t</code>.</p>
<p>More particularly, if none of <code>x</code> and <code>y</code> knew the secret <strong>before or at the time <code>t</code></strong>, and assume one of them gets to know the secret <strong>after time <code>t</code></strong>, then it will not affect meeting <code>[x, y, t]</code>.</p>
</li>
</ul>
<p>From minutely analyzing, we can agree on the fact that processing <code>meetings</code> in ascending order of <code>t</code> will be helpful.<br />
<em>We also incorporated this fact in <a href="#approach-3-earliest-informed-first-traversal">previous approach</a></em>.</p>
<p>Moreover, we should consider all meetings happening at the same time <code>t</code> together.</p>
<p>Assume at a time <code>t</code>, we have <code>[x, y], [y, z], [z, w], [a, b], [c, d], [d, e]</code> meetings taking place. We can form the following three groups of people meeting each other at the time <code>t</code>.</p>
<ul>
<li><code>[x, y, z, w]</code>: If any one of these four knows the secret, then all of them will get to know the secret.</li>
<li><code>[a, b]</code>: If any one of these two knows the secret, then both of them will get to know the secret.</li>
<li><code>[c, d, e]</code>: If any one of these three knows the secret, then all of them will get to know the secret.</li>
</ul>
<p>Thus at every timestamp <code>t</code>, we can do graph traversal to <strong>find all those people to whom the secret can propagate</strong>. The traversal will be started by people who already know the secret at the time <code>t</code>. We need to do so in increasing order of time <code>t</code>.</p>
<p>For traversal, we can do either BFS or DFS. The purpose of traversal is to find the connectedness of the graph at a particular time.</p>
<p>We, in this approach, will use BFS to find the connectedness of the graph at a particular time and leave DFS as an exercise for readers.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Sort <code>meetings</code> in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a HashMap <code>sameTimeMeetings</code> for grouping meetings happening at the same time <code>t</code>. The key of HashMap will be time <code>t</code>, and the value will be a list of <code>(x, y)</code> pairs.</p>
<p>Make sure that <code>sameTimeMeetings</code> remembers the order of insertion, since we are inserting meetings in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a Boolean Array <code>knowsSecret</code> of size <code>n</code>. It will tell if a person knows the secret or not.</p>
<p>Initially, only person <code>0</code> and <code>firstPerson</code> knows the secret. Hence, mark <code>knowsSecret[0]</code> and <code>knowsSecret[firstPerson]</code> as <code>True</code>.</p>
</li>
<li>
<p>Iterate over <code>sameTimeMeetings</code> in increasing order of <code>t</code>. Let's say <code>t</code> is the time.</p>
<ul>
<li>
<p>For each person, save all the people whom he/she meets at the time <code>t</code> in a HashMap <code>meet</code>. The key of HashMap will be person, and value will be a list of people whom he/she meets at the time <code>t</code>.</p>
</li>
<li>
<p>Create a set <code>q</code>. Add to <code>q</code> those people who have some meeting scheduled at time <code>t</code>, and who already know the secret at time <code>t</code>.</p>
<blockquote>
<p>We are using <code>set</code> to avoid redundancy. A person can be in multiple meetings, so to avoid adding the same person multiple times, we are using <code>set</code>.</p>
</blockquote>
</li>
<li>
<p>Convert set <code>q</code> to queue <code>q</code> to do BFS.</p>
</li>
<li>
<p>While <code>q</code> is not empty, do the following:</p>
<ul>
<li>
<p>Dequeue the front of <code>q</code> and store it in <code>person</code>.</p>
</li>
<li>
<p>Iterate over all those persons whom <code>person</code> meets at the time <code>t</code>. Let's say the person is <code>nextPerson</code>.</p>
<p>If <code>knowsSecret[nextPerson]</code> is <code>False</code>, then mark <code>knowsSecret[nextPerson]</code> as <code>True</code> and enqueue <code>nextPerson</code> to <code>q</code>.</p>
<p>This is because after meeting <code>person</code> at a time <code>t</code>, <code>nextPerson</code> will know the secret at the time <code>t</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate over the <code>knowsSecret</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>knowsSecret[i]</code> is <code>True</code>.</p>
</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/FGJS7GCK/shared">code</a></p>
<p><strong>Implementation Note:</strong> For every <code>t</code>, the initial queue is created using <code>set</code> to avoid redundancy. We are populating the initial queue using meetings. A person can be in multiple meetings, so to avoid adding the same person multiple times, we are using <code>set</code>.</p>
<p>Afterward, the queue is populated only when the person doesn't know the secret, and as soon as we populate, we mark the person as known. Hence, there won't be redundancy in the queue.</p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \log M + N )\)</span></p>
<ul>
<li>
<p>Sorting <code>meetings</code> will take <span class="math inline">\(O(M \log M)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and takes <span class="math inline">\(O(M \log M)\)</span> time in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Populating <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>knowsSecret</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Then there is a <code>for</code> loop. The number of iterations of the <code>for</code> loop depends on the number of unique meeting times. It will be at most <span class="math inline">\(M\)</span>. Let's narrow our analysis to one iteration of the <code>for</code> loop.</p>
<ul>
<li>
<p>Creating <code>meet</code> and initiating <code>q</code> may vary from <span class="math inline">\(O(1)\)</span> time to <span class="math inline">\(O(M)\)</span> time, depending on the number of meetings happening at the time <code>t</code>. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
<p>(<strong>Amortized time complexity</strong> is the time taken per operation averaged over all operations)</p>
<blockquote>
<ul>
<li>If one iteration of creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(1)\)</span> time (when a single meeting is happening at the time <code>t</code>), then there may be the next iteration of the <code>for</code> loop. However, it will be limited to <span class="math inline">\(M\)</span> iterations.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>If one iteration of creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(M)\)</span> time, then there will be no next iteration of the <code>for</code> loop because all meetings happening will get processed in the current iteration.</li>
</ul>
</blockquote>
<blockquote>
<p>Hence, when creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(1)\)</span> time, the number of <code>for</code> loop iterations will be <span class="math inline">\(O(M)\)</span>. When creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(M)\)</span> time, the number of <code>for</code> loop iterations will be <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
<p>Thus, the amortized time complexity for creating <code>meet</code> and initiating <code>q</code> per iteration of the <code>for</code> loop will be <span class="math inline">\(O(1)\)</span></p>
</li>
<li>
<p>The BFS may take <span class="math inline">\(O(N)\)</span> time in the worst case because, at any instance, there can be at most <span class="math inline">\(N\)</span> nodes in the queue. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
<blockquote>
<ul>
<li>If every meeting time has only <span class="math inline">\(2\)</span> participants, then there will be <span class="math inline">\(O(M)\)</span> unique meeting times deciding the number of iterations of the <code>for</code> loop. In each iteration of the <code>for</code> loop, there will be <span class="math inline">\(O(2)\)</span> people in the queue. Hence, the time complexity will be <span class="math inline">\(O(2 \cdot M)\)</span> which is <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>If every meeting time has <span class="math inline">\(N\)</span> participants, then there will be <span class="math inline">\(O(\frac{M}{N})\)</span> unique meeting times deciding the number of iterations of the <code>for</code> loop. In each iteration of the <code>for</code> loop, there will be <span class="math inline">\(O(N)\)</span> people in the queue. Hence, the time complexity will be <span class="math inline">\(O(N \cdot \frac{M}{N})\)</span> which is <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</blockquote>
<p>Thus, the amortized time complexity of BFS per iteration of the <code>for</code> loop will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Thus, each iteration of the <code>for</code> loop will take amortized <span class="math inline">\(O(1)\)</span> time for creating <code>meet</code>, initiating <code>q</code>, and BFS.</p>
</li>
</ul>
</li>
<li>
<p>Finally, we are iterating over the <code>knowsSecret</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M \log M + M + N + M \cdot 1 + N)\)</span>, which is <span class="math inline">\(O( M \log M + N )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>We are sorting the <code>meetings</code> array in place. When we sort an array in place, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(M)\)</span> space in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>The <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>knowsSecret</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>meet</code> HashMap will take <span class="math inline">\(O(M)\)</span> space per iteration of <code>for</code> loop. After iteration, it will be empty. Hence, the total space complexity will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
<li>
<p>The <code>q</code> may grow up to <span class="math inline">\(O(N)\)</span> per iteration of the <code>for</code> loop because any person can be in the queue at most once. After iteration, it will be empty. Hence, the total space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-union-find-with-reset">Approach 5: Union-Find with Reset</h3>
<h4 id="intuition-4">Intuition</h4>
<p>In the <a href="#intuition-3">intuition of the previous approach</a>, we noted the following.</p>
<blockquote>
<p>The purpose of traversal is to find the connectedness of the graph at a particular time.</p>
</blockquote>
<p>We initiated traversal from people who already knew the secret at the time <code>t</code>.</p>
<p>Instead of doing traversal, we can use <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union-Find</a> to find the connectedness of the graph at a particular time. For each person taking part in a meeting, we can union the person with the other person taking part in the meeting, and check if they are connected to any person who already knows the secret, one such person being <code>0</code>.</p>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/"><strong>Union-Find</strong></a>, also known as <strong>Disjoint Set</strong>, is a data structure that keeps track of elements that are split into one or more disjoint sets. It provides near-constant-time operations to add new sets, merge existing sets, and determine whether elements are in the same set.</p>
<p>If readers are not familiar with Union-Find, then they are encouraged to visit <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/"><strong>Union-Find Explore Card</strong></a> to learn about it. It includes the heuristics to optimize the Union-Find data structure.</p>
<ul>
<li><em>union by rank</em> (height) or <em>union by size</em>. We can use either of these.</li>
<li><em>path compression</em></li>
</ul>
<p>We, in this approach, will use <strong>Union by Rank</strong> and <strong>Path Compression</strong> heuristics to optimize the Union-Find data structure.</p>
</blockquote>
<p>Thus, in this approach, we will process meetings in increasing order of time <code>t</code>, and for each meeting <code>[x, y]</code>, we will unite the two persons.</p>
<p>After performing all the unions, we will again visit all <code>[x, y]</code>, and check if any one of them is connected to <code>0</code> or not <em>(if any of them is connected to <code>0</code>, then both of them will be connected to <code>0</code> because we united them)</em>. If yes, then both of them will end up knowing the secret.</p>
<p>At the end, we will return indices of all the people who know the secret.</p>
<p>Is that enough? Let's try to find out through an example.</p>
<pre><code class="language-testcase">6
[[2, 3, 1], [1, 2, 2], [3, 4, 3], [5, 4, 4], [5, 0, 4]]
1
</code></pre>
<p>The <code>meetings</code> are already sorted in increasing order of <code>t</code>. Initially, our graph looks like the following. <code>1</code> is connected to <code>0</code>, because <code>1</code> is the <code>firstPerson</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_1.PNG" alt="t0" /></p>
<p>After meeting <code>[2, 3, 1]</code>, one more connection is added to the graph. However, both of them are not connected to <code>0</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_2.PNG" alt="t1" /></p>
<p>Let's process the next meeting <code>[1, 2, 2]</code>. After this meeting, <code>2</code> will get connected to <code>0</code>, because <code>1</code> is already connected to <code>0</code>. Thus, <code>2</code> will know the secret.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_3.PNG" alt="t2" /></p>
<p>The third meeting <code>[3, 4, 3]</code> will add a connection between <code>3</code> and <code>4</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_4.PNG" alt="t3" /></p>
<p>Now <code>3</code> was already connected to <code>0</code>, but <code>3</code> doesn't know the secret yet. However, it got connected to <code>0</code> because <code>2</code> got connected to <code>0</code> after the second meeting, and <code>3</code> had met <code>2</code> in the first meeting. However, this is incorrect. <code>3</code> technically doesn't know the secret yet.</p>
<p>Hence, it seems connection with <code>0</code> is not enough. We may need to maintain a flag array <code>knowsSecret</code> to mark if a person knows the secret or not, which is indicated by the green color in the above figures.</p>
<p>Let's process further to see if it will work or not!</p>
<p>We have two meetings taking place at time <code>t = 4</code>. Their union is represented by red color in the following figure.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_5.PNG" alt="t4" /></p>
<p>Now, we will revisit every meeting at time <code>t = 4</code> again. The first one being <code>[5, 4, 4]</code>. Both of them are connected to <code>0</code>, but none of them knows the secret. Hence, we will not mark them as known. However, this is incorrect. Ideally, both of them should know the secret.</p>
<p>If we had visited <code>[5, 0, 4]</code> first, then we would have marked <code>5</code> as known, and then we would have visited <code>[5, 4, 4]</code>, and marked <code>4</code> as known.</p>
<p>However, given the fixed time, we don't have devised any strategy to visit meetings in a particular order.</p>
<p>We can overcome this by doing two passes after uniting, at least for this test case. However, to guarantee it to work every time, we must do as many passes as the number of meetings at that fixed time. This isn't efficient!</p>
<p>Thus, introducing the <code>knowsSecret</code> flag array doesn't seem to lead to an efficient solution.</p>
<p><strong>We need to proceed only with the fact that if a person is connected to <code>0</code>, then he/she knows the secret.</strong></p>
<p>In <a href="#intuition-3">intuition of the previous approach</a>, we noted the following.</p>
<blockquote>
<p>Let's assume that one participant of a transitive meeting gets to know the secret <strong>after time <code>t</code></strong>. It is worth noting that knowing after time <code>t</code> will not affect meetings happening at the time <code>t</code>.</p>
<p>More particulary, if none of <code>x</code> and <code>y</code> knew the secret <strong>before or at time <code>t</code></strong>, and assume one of them gets to know the secret <strong>after time <code>t</code></strong>, then it will have no effect on meeting <code>[x, y, t]</code>.</p>
</blockquote>
<p>Let's focus more on the last sentence of the above quote. If none of them knew the secret, then meeting <code>[x, y, t]</code> will not have any effect on them. To trigger the effect of the meeting, we united <code>x</code> and <code>y</code> using the Union-Find data structure.</p>
<p><strong>What to do to dissolve the effect?</strong><br />
Well, we can do the opposite of uniting them. We can disunite <code>x</code> and <code>y</code> into single components.</p>
<p>Since even after doing all the unions, they weren't able to receive the secret, all the meetings happening at or before the time <code>t</code> were not able to propagate the secret to them. Hence, we can safely disunite them.</p>
<p>Now to disunite them into single components, we just need to reset the initial properties of Union-Find. We need to do this only for these two persons.</p>
<p>After processing all the <code>meetings</code>, all those persons who are connected to <code>0</code> will know the secret.</p>
<p>Here is the animation explaining the approach for the following input.</p>
<pre><code class="language-input">6
[[2, 3, 1], [1, 2, 2], [3, 4, 3], [5, 4, 4], [5, 0, 4]]
1
</code></pre>
<p>!?!../Documents/2092/2092_slideshow_union_find.json:960,540!?!<br />
<br/></p>
<p>It is worth noting that we don't need a separate flag array <code>knowsSecret</code>. Connection with <code>0</code> is enough to conclude that a person knows the secret. That's why the above animation doesn't highlight with green color.</p>
<p>With this intuition, let's discuss the implementable algorithm.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ol>
<li>
<p>Define a class <code>UnionFind</code> to implement the Union-Find data structure.</p>
<p>The <strong>constructor</strong> of <code>UnionFind</code> will take <code>n</code> as input, and initialize <code>parent</code> and <code>rank</code> arrays of size <code>n</code>. The <code>parent</code> array will store the parent of each node, and the <code>rank</code> array will store the rank of each node.</p>
<p>Initially, every node is the parent of itself, and the rank of every node is <code>0</code>.</p>
<p>It will have the following <strong>methods</strong>:</p>
<ul>
<li>
<p><code>find(x)</code>: Find the parent of node <code>x</code>. It will use the <em>Path Compression</em> heuristic.</p>
</li>
<li>
<p><code>unite(x, y)</code>: Unite two nodes <code>x</code> and <code>y</code>. It will use the <em>Union by Rank</em> heuristic.</p>
</li>
<li>
<p><code>connected(x, y)</code>: Check if two nodes <code>x</code> and <code>y</code> are connected or not.</p>
</li>
<li>
<p><code>reset(x)</code>: Reset the initial properties of node <code>x</code>. It will set the parent of node <code>x</code> to <code>x</code>, and the rank of node <code>x</code> to <code>0</code>.</p>
</li>
</ul>
</li>
<li>
<p>Sort <code>meetings</code> in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a HashMap <code>sameTimeMeetings</code> for grouping meetings happening at the same time <code>t</code>. The key of HashMap will be time <code>t</code>, and the value will be a list of <code>(x, y)</code> pairs.</p>
<p>Make sure that <code>sameTimeMeetings</code> remembers the order of insertion, since we are inserting meetings in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a <code>graph</code>. It will be an instance of the <code>UnionFind</code> class and will have <code>n</code> nodes.</p>
</li>
<li>
<p>Unite <code>firstPerson</code> with <code>0</code> in <code>graph</code>.</p>
</li>
<li>
<p>Process <code>sameTimeMeetings</code> in increasing order of <code>t</code>. Let's say <code>t</code> is the time.</p>
<ul>
<li>
<p>Unite all two persons taking part in a meeting.</p>
</li>
<li>
<p>If any one of them is connected to <code>0</code>, then both of them will be connected to <code>0</code>.</p>
<p>Similarly, if any one of them is NOT connected to <code>0</code>, then both of them will be NOT connected to <code>0</code>, since they were united among themselves. In this case, we need to reset them.</p>
</li>
</ul>
</li>
<li>
<p>Return indices of all those people who are connected to <code>0</code> in the <code>graph</code>.</p>
</li>
</ol>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/b4ZMoceH/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Before analyzing the time complexity, let's first understand the time complexity of Union-Find. If an instance of Union-Find is created with <span class="math inline">\(\text{nodes}\)</span>, then the following are the time complexities of Union-Find methods:</p>
<blockquote>
<ul>
<li><strong>Constructor</strong>: <span class="math inline">\(O(\text{nodes})\)</span>, because we are initializing <code>parent</code> and <code>rank</code> arrays of size <span class="math inline">\(\text{nodes}\)</span>. However, the constructor is called only once.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>find(x)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>unite(x, y)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>connected(x, y)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>In actuality, the time complexity of the above three methods after using <em>Path Compression</em> and <em>Union by Rank</em> heuristics is <span class="math inline">\(O\left( \boldsymbol{\alpha}(\text{nodes}) \right)\)</span> time, where <span class="math inline">\(\boldsymbol{\alpha}\)</span> is <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse">Inverse Ackermann Function</a>. However, <span class="math inline">\(\boldsymbol{\alpha}(\text{nodes})\)</span> is less than <span class="math inline">\(5\)</span> for all practical purposes. More <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3843/">here</a></p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li><code>reset(x)</code>: It is <span class="math inline">\(O(1)\)</span> time because we are just resetting the initial properties of node <code>x</code>.</li>
</ul>
</blockquote>
<p>For analyzing the time complexity of our algorithm, let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \log M + N)\)</span></p>
<ul>
<li>
<p>Sorting <code>meetings</code> will take <span class="math inline">\(O(M \log M)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and takes <span class="math inline">\(O(M \log M)\)</span> time in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Populating <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Creating <code>graph</code> will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Uniting <code>firstPerson</code> with <code>0</code> will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Upon looking at the <code>for</code> loop, we can observe that we will process each meeting exactly twice, once for uniting, and once while checking if any one of them is connected to <code>0</code> or not.</p>
<ul>
<li>
<p>For uniting, it will be amortized <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>For checking if any one of them is connected to <code>0</code> or not, it will be amortized <span class="math inline">\(O(1)\)</span> time. Resetting, if required, will be <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity of the <code>for</code> loop will be <span class="math inline">\(O(2 \cdot M \cdot 1)\)</span>, which is <span class="math inline">\(O(M)\)</span>.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>graph</code> to find indices that are connected to <code>0</code>. It will take <span class="math inline">\(O(N \cdot 1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M \log M + M + N + M + N)\)</span>, which is <span class="math inline">\(O( M \log M + N )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>We are sorting the <code>meetings</code> array in place. When we sort an array in place, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(M)\)</span> space in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>The <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(N)\)</span> space for <code>parent</code> and <code>rank</code> arrays.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<p>As a challenge, try to implement the <a href="#implementation-4">Union-Find approach</a> <em>without</em> using the <code>sameTimeMeetings</code> HashMap! We perhaps may need some iterators to process all the meetings happening at the same time. Readers can comment their code below.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-possible-recipes-from-given-supplies/description" target="_blank" rel="noopener noreferrer">Find All Possible Recipes from Given Supplies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have information about <code>n</code> different recipes. You are given a string array <code>recipes</code> and a 2D string array <code>ingredients</code>. The <code>i<sup>th</sup></code> recipe has the name <code>recipes[i]</code>, and you can <strong>create</strong> it if you have <strong>all</strong> the needed ingredients from <code>ingredients[i]</code>. A recipe can also be an ingredient for <strong>other </strong>recipes, i.e., <code>ingredients[i]</code> may contain a string that is in <code>recipes</code>.</p>

<p>You are also given a string array <code>supplies</code> containing all the ingredients that you initially have, and you have an infinite supply of all of them.</p>

<p>Return <em>a list of all the recipes that you can create. </em>You may return the answer in <strong>any order</strong>.</p>

<p>Note that two recipes may contain each other in their ingredients.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> recipes = [&quot;bread&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;corn&quot;]
<strong>Output:</strong> [&quot;bread&quot;]
<strong>Explanation:</strong>
We can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> recipes = [&quot;bread&quot;,&quot;sandwich&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;],[&quot;bread&quot;,&quot;meat&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;meat&quot;]
<strong>Output:</strong> [&quot;bread&quot;,&quot;sandwich&quot;]
<strong>Explanation:</strong>
We can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.
We can create &quot;sandwich&quot; since we have the ingredient &quot;meat&quot; and can create the ingredient &quot;bread&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> recipes = [&quot;bread&quot;,&quot;sandwich&quot;,&quot;burger&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;],[&quot;bread&quot;,&quot;meat&quot;],[&quot;sandwich&quot;,&quot;meat&quot;,&quot;bread&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;meat&quot;]
<strong>Output:</strong> [&quot;bread&quot;,&quot;sandwich&quot;,&quot;burger&quot;]
<strong>Explanation:</strong>
We can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.
We can create &quot;sandwich&quot; since we have the ingredient &quot;meat&quot; and can create the ingredient &quot;bread&quot;.
We can create &quot;burger&quot; since we have the ingredient &quot;meat&quot; and can create the ingredients &quot;bread&quot; and &quot;sandwich&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == recipes.length == ingredients.length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li>
	<li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li>
	<li><code>recipes[i], ingredients[i][j]</code>, and <code>supplies[k]</code> consist only of lowercase English letters.</li>
	<li>All the values of <code>recipes</code> and <code>supplies</code>&nbsp;combined are unique.</li>
	<li>Each <code>ingredients[i]</code> does not contain any duplicate values.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Let's first try to equate our problem to a real-world cooking scenario. Imagine you have a kitchen stocked with basic ingredients and a cookbook filled with recipes. Each recipe specifies the exact ingredients needed to prepare it. Some recipes are simple, requiring only basic ingredients, while others are more complex, needing not just raw ingredients but also other prepared dishes as part of their recipe. Our goal is to determine which recipes can be made using the given set of available ingredients.</p>
<p>At first glance, this might seem straightforward. If we have all the ingredients listed for a recipe, we can make it. However, the problem becomes more complex when recipes depend on other recipes. Suppose Recipe A requires Recipe B, but Recipe B itself needs Recipe C, and Recipe C, in turn, depends on Recipe A. This creates a circular dependency, making it unclear where to begin. If we do not account for these dependencies properly, we could end up in an infinite loop, never determining which recipes can actually be made. Our approach needs to handle these interdependencies properly.</p>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth-First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>One straightforward way to solve this problem is to make new recipes in rounds using our available ingredients. During each round, we check every recipe and ask, &quot;Can we make this recipe with what we have?&quot; If we can, we make it; if we can't, we'll try again later.</p>
<p>Let's break down how to write code for this approach. First, we need to track all our available ingredients. Since we'll frequently check if we have specific ingredients, we should use a data structure that allows quick lookups. A hash set is perfect for this because it lets us check and add ingredients almost instantly.</p>
<p>Next, we need a way to manage the recipes we want to attempt. We can use a queue to keep track of the recipes that we still need to process. Initially, the queue contains all the recipes since none have been prepared yet.</p>
<p>Now, we start processing the recipes. For each recipe in the queue, we check if all its required ingredients are available. If they are, we mark the recipe as completed and add it to our list of available ingredients, making it usable for other recipes. If we can't make a recipe yet, we put it back in the queue and try again in the next round.</p>
<p>But how do we know when to stop? Before each round, we note how many ingredients we have. If, after processing all recipes in the queue, the ingredient count has increased, it means we’ve made progress and should continue. However, if the ingredient count remains unchanged, it means no more recipes can be made, and we return the list of completed recipes.</p>
<p>Notice how this approach handles dependencies. If Recipe A depends on Recipe B, but we haven't made Recipe B yet, Recipe A remains in the queue. Later, once we successfully prepare Recipe B, Recipe A will have all the required ingredients and can be processed. This natural progression handles even complex dependency chains.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Create a hash set <code>available</code> to track all available items.</li>
<li>Add each supply from the <code>supplies</code> array into the <code>available</code> set.</li>
<li>Create a Queue <code>recipeQueue</code> to store recipe indices.</li>
<li>Add indices from <code>0</code> to <code>recipes.length-1</code> into the <code>recipeQueue</code>.</li>
<li>Initialize:
<ul>
<li>a list <code>createdRecipes</code> to store the final result.</li>
<li>a variable <code>lastSize</code> to <code>-1</code>.</li>
</ul>
</li>
<li>While the size of <code>available</code> is greater than <code>lastSize</code>:
<ul>
<li>Set <code>lastSize</code> to the current size of <code>available</code>.</li>
<li>Set a variable <code>queueSize</code> to the size of <code>recipeQueue</code>.</li>
<li>While <code>queueSize</code> is greater than <code>0</code>:
<ul>
<li>Decrement <code>queueSize</code>.</li>
<li>Remove the front element from <code>recipeQueue</code> and put it in a variable <code>recipeIdx</code>.</li>
<li>Set a boolean <code>canCreate</code> to <code>true</code>.</li>
<li>For each <code>ingredient</code> in <code>ingredients[recipeIdx]</code>:
<ul>
<li>If <code>ingredient</code> is not present in the <code>available</code> set:
<ul>
<li>Set <code>canCreate</code> to <code>false</code> and break out of the loop.</li>
</ul>
</li>
<li>If <code>canCreate</code> is <code>false</code>:
<ul>
<li>Add <code>recipeIdx</code> back to <code>recipeQueue</code>.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Add <code>recipes[recipeIdx]</code> to the <code>available</code> set and the <code>createdRecipes</code> list.</li>
</ul>
</li>
<li>Decrease <code>count</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>createdRecipes</code> as the answer.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/hHVZHDUF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of recipes, <span class="math inline">\(m\)</span> be the total number of ingredients across all recipes, and <span class="math inline">\(s\)</span> be the number of supplies.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m + s)\)</span></p>
<p>Initially, all supplies are inserted into a set in <span class="math inline">\(O(s)\)</span> time.</p>
<p>In the worst case, a recipe may be reprocessed up to <span class="math inline">\(O(n)\)</span> times—each time it’s checked, it might still be uncreatable and gets added back to the queue. Since there are <span class="math inline">\(n\)</span> recipes, and checking whether a recipe is creatable involves scanning all its ingredients (which takes up to <span class="math inline">\(O(m)\)</span> per recipe), this leads to a worst-case bound of <span class="math inline">\(O(n^2 \cdot m)\)</span> for repeatedly checking recipe feasibility.</p>
<p>Additionally, set insertion and membership checks are <span class="math inline">\(O(1)\)</span> on average and do not significantly impact the total complexity.</p>
<p>Therefore, the total time complexity is <span class="math inline">\(O(n^2 \cdot m + s)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + s)\)</span></p>
<p>The algorithm maintains a set to store available ingredients, which can grow up to <span class="math inline">\(O(n + s)\)</span>. The queue holds up to <span class="math inline">\(O(n)\)</span> elements, and we use no additional structures beyond these. Thus, the overall space complexity is <span class="math inline">\(O(n + s)\)</span>. We do not consider the output space as part of our analysis.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-dfs">Approach 2: Depth-First Search (DFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In our previous approach, we gathered as many recipes as we could make with the current set of ingredients in each iteration and then proceeded to find further recipes in the next iteration, mimicking a BFS approach. Let's try a different way.</p>
<p>Think about how you would actually make a recipe in real life. When you check your ingredients, you might find that one of them is actually another recipe you need to make first. Naturally, you'd pause your main recipe to figure out how to make this sub-recipe. This thought process matches perfectly with a depth-first search (DFS) solution.</p>
<p>Since our task is to find the number of recipes we can make from the given list, let's create a function <code>checkRecipe</code> which returns <code>true</code> if we can make the recipe. To check if we can, we go over the list of ingredients. Let's say we come across an ingredient that is itself another recipe. We can now use the <code>checkRecipe</code> function recursively to check if the recipe can be made, and then in turn, used as an ingredient to make the parent recipe.</p>
<p>However, there's a challenging aspect to this problem: circular dependencies. Here's a simple example:</p>
<ul>
<li>Recipe A requires Recipe B to make it.</li>
<li>Recipe B requires Recipe C to make it.</li>
<li>Recipe C requires Recipe A to make it.</li>
</ul>
<p>Without proper safeguards, our code could get stuck in an endless loop. To prevent this, we keep track of which recipes we're currently checking in a <code>visited</code> set. As we explore each recipe's dependencies, we mark it as visited. If we encounter a recipe that's already in our <code>visited</code> set, we know we've found a cycle and can immediately determine that the recipe isn't possible to make.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a list <code>possibleRecipes</code> to store the recipes that can be made.</li>
<li>a hash map <code>canMake</code> to track if an ingredient/recipe can be made, mapping from the name to a boolean value.</li>
<li>a hash map <code>recipeToIndex</code> to store the mapping from a recipe name to its index in the ingredients list.</li>
</ul>
</li>
<li>Loop through all the initial <code>supplies</code> and mark each one as available (<code>true</code>) in the <code>canMake</code> map.</li>
<li>Loop through all the <code>recipes</code> and create a mapping from each recipe name to its index in the <code>recipeToIndex</code> map.</li>
<li>For each <code>recipe</code> in the <code>recipes</code> array:
<ul>
<li>Call the <code>checkRecipe</code> function with the current <code>recipe</code>.</li>
<li>If the <code>recipe</code> can be made (<code>true</code> in <code>canMake</code>), add it to the <code>possibleRecipes</code> list.</li>
</ul>
</li>
<li>Return the list of possible recipes.</li>
</ul>
<p>Helper method <code>checkRecipe(recipe, ingredients, visited, canMake, recipeToIndex)</code>:</p>
<ul>
<li>If the recipe is already marked as makeable (<code>true</code>) in <code>canMake</code>, return immediately.</li>
<li>If the recipe doesn't exist in the <code>recipeToIndex</code> map or is already in the <code>visited</code> set (indicating a cycle), mark it as unmakeable (<code>false</code>) and return.</li>
<li>Add the current <code>recipe</code> to the <code>visited</code> set.</li>
<li>Get the list of required ingredients for the current recipe using its index.</li>
<li>For each <code>ingredient</code> in the required ingredients:
<ul>
<li>Recursively call <code>checkRecipe</code> on the <code>ingredient</code>.</li>
<li>If the ingredient cannot be made (<code>false</code> in <code>canMake</code>), mark the current <code>recipe</code> as unmakeable (<code>false</code>) and return.</li>
</ul>
</li>
<li>After checking all ingredients successfully, mark the current <code>recipe</code> as makeable (<code>true</code>).</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/WjdwJagJ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of recipes, <span class="math inline">\(m\)</span> be the total number of ingredients across all recipes, and <span class="math inline">\(s\)</span> be the number of supplies.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + s)\)</span></p>
<p>The algorithm uses DFS to check each recipe's ingredients. Initially, we process supplies and create recipe mappings in <span class="math inline">\(O(s)\)</span> and <span class="math inline">\(O(n)\)</span> time, respectively. For each recipe, we perform DFS through its ingredients, visiting each ingredient exactly once due to the <code>visited</code> set preventing cycles. Since we memoize results in the <code>canMake</code> map, each ingredient and recipe is processed at most once across all DFS calls. Therefore, the total number of operations is proportional to the number of recipes plus the total number of ingredients, giving us <span class="math inline">\(O(n + m + s)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + s)\)</span></p>
<p>The solution utilizes several key data structures that contribute to its space requirements. The hash map <code>canMake</code> initially stores supply information, requiring <span class="math inline">\(O(s)\)</span> space. The dictionary <code>recipeToIndex</code> maps recipes to indices, using <span class="math inline">\(O(n)\)</span> space. For cycle detection, the <code>visited</code> set and the result list <code>possibleRecipes</code> each take <span class="math inline">\(O(n)\)</span> space. The recursion stack depth in the worst case is bounded by the number of recipes rather than all ingredients, contributing at most <span class="math inline">\(O(n)\)</span> space. Since all operations and structures operate primarily on recipes, the total auxiliary space complexity is <strong><span class="math inline">\(O(n + s)\)</span></strong>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort-kahns-algorithm">Approach 3: Topological Sort (Kahn's Algorithm)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Our previous solutions had some drawbacks. The BFS approach kept trying recipes repeatedly until we couldn't make any more, which could be slow when recipes had complex dependencies. While the DFS solution handled dependencies well, it needed careful tracking to avoid infinite loops. Let's explore a more organized approach using something called topological sorting.</p>
<p>Making recipes is really about the order we make them, since some recipes must be created before others. We can think of this like a map where arrows point from one recipe to another, showing what needs to be made first. Topological sorting is perfect for solving this kind of problem because it's designed to handle these &quot;what comes first&quot; relationships.</p>
<p>Instead of constantly checking which ingredients a recipe needs, we can reverse our perspective. Instead of focusing on what each recipe depends on, we track which recipes depend on a given ingredient. This shift in thinking allows us to process recipes in an optimal order i.e., whenever a new recipe is made, we immediately know which other recipes can now be completed.</p>
<p>The most important component of the topological sorting algorithm is the <code>inDegree</code> array. For each recipe, this array counts how many ingredients we still need to find. Here's what that means:</p>
<ol>
<li>If a recipe has an in-degree of zero, it means all of its required ingredients are already available, and we can make it immediately.</li>
<li>Each time we complete a recipe, it becomes available as an ingredient for other recipes, so we decrease the in-degree of all recipes that depend on it.</li>
<li>When a recipe’s in-degree reaches zero, it becomes the next recipe we can make.</li>
</ol>
<p>Here's how the <code>inDegree</code> array would look for Example 3 of the problem description:</p>
<p><img src="../Figures/2115/indegree.png" alt="indegree array" /></p>
<p>To implement the algorithm, we first create the dependency graph and populate the <code>inDegree</code> array. For each recipe, we iterate over its ingredients and add a directed edge from each ingredient to the recipe, but only if the ingredient is not already available in the initial supplies. This ensures that the in-degree of a recipe reflects only the number of unavailable ingredients it depends on.</p>
<p>Then, we iterate over each recipe using a queue and try to resolve the dependencies. Initially, we add to the queue all recipes that have an in-degree of zero, meaning they only require ingredients from our supplies and don't depend on any other recipes. As we complete each recipe, it becomes available as an ingredient for other recipes, so decrease the in-degree of all its dependent recipes by one. When all required ingredients for a recipe become available (its in-degree reaches zero), we can make that recipe too. It also becomes an ingredient by itself, so we add it to the queue.</p>
<p>We keep track of each recipe we make in a list called <code>createdRecipes</code>. When the queue is empty and all dependencies have been resolved, we return this list as our answer.</p>
<blockquote>
<p>For a more comprehensive understanding of Topological Sorting, check out the <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">Topological Sort Explore Card</a>. This resource provides an in-depth look at topological sorting, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a hash set <code>availableSupplies</code> to store the initial supplies.</li>
<li>a hash map <code>recipeToIndex</code> to store the mapping from recipe names to their indices.</li>
<li>a hash map <code>dependencyGraph</code> to store which recipes depend on each ingredient.</li>
</ul>
</li>
<li>Loop through all the supplies and add each one to the <code>availableSupplies</code> set.</li>
<li>Loop through all the recipes and create a mapping from each recipe to its corresponding index.</li>
<li>Initialize an array <code>inDegree</code> to track the count of remaining ingredients needed for each recipe.</li>
</ul>
<p>To build the dependency graph:</p>
<ul>
<li>For each recipe:
<ul>
<li>For each <code>ingredient</code> in the current recipe:
<ul>
<li>If the <code>ingredient</code> is not in the available supplies, add it to the <code>dependencyGraph</code> if not present.</li>
<li>Add the current recipe to the list of recipes that need this ingredient.</li>
<li>Increment the <code>inDegree</code> count for the current recipe.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For finding makeable recipes:</p>
<ul>
<li>Initialize a <code>queue</code> to store the indices of recipes that can be made immediately.</li>
<li>Loop through all the <code>recipes</code>:
<ul>
<li>If a recipe's <code>inDegree</code> is zero (only needs available supplies), add it to the <code>queue</code>.</li>
</ul>
</li>
<li>Initialize a list <code>createdRecipes</code> to store the result</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Get the next recipe index from the <code>queue</code>.</li>
<li>Get the recipe name using the index.</li>
<li>Add the recipe to the <code>createdRecipes</code> list.</li>
<li>If no other recipes depend on this recipe, continue to the next iteration.</li>
<li>For each recipe that depends on the current recipe:
<ul>
<li>Decrease its <code>inDegree</code> count by one.</li>
<li>If the <code>inDegree</code> becomes zero, add it to the queue.</li>
</ul>
</li>
</ul>
</li>
<li>Return the list of created recipes.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/dUEVdEvN/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of recipes, <span class="math inline">\(m\)</span> be the total number of ingredients across all recipes, and <span class="math inline">\(s\)</span> be the number of supplies.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + s)\)</span></p>
<p>Initially, we process all supplies to mark them as available, taking <span class="math inline">\(O(s)\)</span> time. Then we create recipe mappings in <span class="math inline">\(O(n)\)</span> time. Building the dependency graph requires examining each ingredient for each recipe once, taking <span class="math inline">\(O(m)\)</span> time. When processing recipes in topological order, we visit each recipe once and process its dependencies. Since each ingredient-to-recipe edge in the dependency graph is processed exactly once, and the total number of such edges is bounded by <span class="math inline">\(m\)</span>, the queue processing takes <span class="math inline">\(O(n + m)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n + m + s)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m + s)\)</span></p>
<p>The algorithm uses several auxiliary data structures to track the recipe creation process. We use a hash set to store available supplies and a hash map to maintain recipe indices taking <span class="math inline">\(O(s)\)</span> and <span class="math inline">\(O(n)\)</span> space respectively. The core of our space usage comes from the dependency graph, which stores ingredient-to-recipe relationships and could grow up to <span class="math inline">\(O(m)\)</span> size. Additional structures include an array for tracking ingredient counts per recipe (<span class="math inline">\(O(n)\)</span>), a queue for our topological sort (<span class="math inline">\(O(n)\)</span>), and a list for storing our final results (<span class="math inline">\(O(n)\)</span>). When we combine all these components, our total auxiliary space requirement becomes <span class="math inline">\(O(n + m + s)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-safe-walk-through-a-grid/description" target="_blank" rel="noopener noreferrer">Find a Safe Walk Through a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code> and an integer <code>health</code>.</p>

<p>You start on the upper-left corner <code>(0, 0)</code> and would like to get to the lower-right corner <code>(m - 1, n - 1)</code>.</p>

<p>You can move up, down, left, or right from one cell to another adjacent cell as long as your health <em>remains</em> <strong>positive</strong>.</p>

<p>Cells <code>(i, j)</code> with <code>grid[i][j] = 1</code> are considered <strong>unsafe</strong> and reduce your health by 1.</p>

<p>Return <code>true</code> if you can reach the final cell with a health value of 1 or more, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png" style="width: 301px; height: 121px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>A minimum of 4 health points is needed to reach the final cell safely.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png" style="width: 361px; height: 161px;" /></div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png" style="width: 181px; height: 121px;" /></p>

<p>Any path that does not go through the cell <code>(1, 1)</code> is unsafe since your health will drop to 0 when reaching the final cell.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code><font face="monospace">2 &lt;= m * n</font></code></li>
	<li><code>1 &lt;= health &lt;= m + n</code></li>
	<li><code>grid[i][j]</code> is either 0 or 1.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-center-of-star-graph/description" target="_blank" rel="noopener noreferrer">Find Center of Star Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected <strong>star</strong> graph consisting of <code>n</code> nodes labeled from <code>1</code> to <code>n</code>. A star graph is a graph where there is one <strong>center</strong> node and <strong>exactly</strong> <code>n - 1</code> edges that connect the center node with every other node.</p>

<p>You are given a 2D integer array <code>edges</code> where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between the nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>. Return the center of the given star graph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/24/star_graph.png" style="width: 331px; height: 321px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[4,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> As shown in the figure above, node 2 is connected to every other node, so 2 is the center.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> edges = [[1,2],[5,1],[1,3],[1,4]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i,</sub> v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>The given <code>edges</code> represent a valid star graph.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-degree-count">Approach 1: Degree Count</h3>
<h4 id="intuition">Intuition</h4>
<p>We have a graph with N nodes connected by <code>N-1</code> edges in a star formation. Our task is to find the center node of this star.</p>
<p>The center node has a unique property: it's connected to every other node. This means it has <code>N-1</code> connections, while all other nodes have only one connection each.</p>
<p>In graph theory, we call the number of connections a node has its &quot;degree&quot;. The center node has a degree of <code>N-1</code>, and all other nodes have a degree of <code>1</code>.</p>
<p>To find the center, we can count the degree of each node. We'll iterate through all edges, incrementing a degree counter for both nodes each edge connects. We'll store these counts in an array or map. After iterating all edges, we find the node with a degree of <code>N-1</code>. This node is our center.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an empty unordered hashmap <code>degree</code> to store the degree of all nodes.</li>
<li>Iterate over the edges in the list <code>edges</code> and, for each edge, increment the degree of nodes this edge connects in the map <code>degree</code>.</li>
<li>Iterate over the hash map <code>degree</code> and check if the degree is equal to <span class="math inline">\(N - 1\)</span>, i.e., <code>edges.size()</code>.</li>
<li>Return the node that satisfies the above condition.</li>
<li>Return <code>-1</code>, although this is an unreachable part of the code as the input is always valid.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/H7hgLeKM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>To find the degree of each node, we iterate over each of the <span class="math inline">\(N - 1\)</span> edges. Then we check the degree of each of the <span class="math inline">\(N\)</span> nodes. Hence, the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>The hash map <code>degree</code> stores the degree of all <span class="math inline">\(N\)</span> nodes and hence the space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-greedy">Approach 2: Greedy</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We're given that the input is always a star graph, with a center node connected to all others. This simplifies our approach.</p>
<p>In a star graph, the center node appears on every edge, as it's connected to all other nodes. Instead of counting degrees, we can find the node present in all edges. This node must be the center.</p>
<p>We only need to check any two edges in the list. The common node between these edges is guaranteed to be the center. This works because, in a star graph with <code>N-1</code> edges, only the center node has a degree greater than 1.</p>
<p>For simplicity, we can just check the first two edges in the list. The node common to both is our center.</p>
<p>This approach is more efficient than counting degrees, as we only need to examine two edges regardless of the graph's size.</p>
<p><img src="../Figures/1791/1791A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Declare the <code>firstEdge</code> and <code>secondEdge</code> as the first two edges in the list <code>edges</code> respectively.</li>
<li>Check if the first node in the <code>firstEdge</code> is equal to any of the two nodes in the <code>secondEdge</code>, if yes return the first node in <code>firstEdge</code>. Otherwise, return the second node in the <code>secondEdge</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VG8T6UPi/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>We only compare the two nodes in the <code>firstEdge</code> with the nodes in the <code>secondEdge</code>. This is a constant operation and hence the time complexity is constant.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>We don't need any extra space. Note that two edges <code>firstEdge</code> and <code>secondEdge</code> will only have two nodes irrespective of the number of nodes in the graph, and even these two declarations can be avoided but are added for better readability. Hence the space complexity is also constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-champion-ii/description" target="_blank" rel="noopener noreferrer">Find Champion II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> teams numbered from <code>0</code> to <code>n - 1</code> in a tournament; each team is also a node in a <strong>DAG</strong>.</p>

<p>You are given the integer <code>n</code> and a <strong>0-indexed</strong> 2D integer array <code>edges</code> of length <code><font face="monospace">m</font></code> representing the <strong>DAG</strong>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is a directed edge from team <code>u<sub>i</sub></code> to team <code>v<sub>i</sub></code> in the graph.</p>

<p>A directed edge from <code>a</code> to <code>b</code> in the graph means that team <code>a</code> is <strong>stronger</strong> than team <code>b</code> and team <code>b</code> is <strong>weaker</strong> than team <code>a</code>.</p>

<p>Team <code>a</code> will be the <strong>champion</strong> of the tournament if there is no team <code>b</code> that is <strong>stronger</strong> than team <code>a</code>.</p>

<p>Return <em>the team that will be the <strong>champion</strong> of the tournament if there is a <strong>unique</strong> champion, otherwise, return </em><code>-1</code><em>.</em></p>

<p><strong>Notes</strong></p>

<ul>
	<li>A <strong>cycle</strong> is a series of nodes <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, a<sub>n+1</sub></code> such that node <code>a<sub>1</sub></code> is the same node as node <code>a<sub>n+1</sub></code>, the nodes <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code> are distinct, and there is a directed edge from the node <code>a<sub>i</sub></code> to node <code>a<sub>i+1</sub></code> for every <code>i</code> in the range <code>[1, n]</code>.</li>
	<li>A <strong>DAG</strong> is a directed graph that does not have any <strong>cycle</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img height="300" src="https://assets.leetcode.com/uploads/2023/10/19/graph-3.png" width="300" /></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2]]
<strong>Output:</strong> 0
<strong>Explanation: </strong>Team 1 is weaker than team 0. Team 2 is weaker than team 1. So the champion is team 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img height="300" src="https://assets.leetcode.com/uploads/2023/10/19/graph-4.png" width="300" /></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[0,2],[1,3],[1,2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> Team 2 is weaker than team 0 and team 1. Team 3 is weaker than team 1. But team 1 and team 0 are not weaker than any other teams. So the answer is -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>m == edges.length</code></li>
	<li><code>0 &lt;= m &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= edge[i][j] &lt;= n - 1</code></li>
	<li><code>edges[i][0] != edges[i][1]</code></li>
	<li>The input is generated such that if team <code>a</code> is stronger than team <code>b</code>, team <code>b</code> is not stronger than team <code>a</code>.</li>
	<li>The input is generated such that if team <code>a</code> is stronger than team <code>b</code> and team <code>b</code> is stronger than team <code>c</code>, then team <code>a</code> is stronger than team <code>c</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-in-degree-count">Approach: In-degree Count</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given <code>n</code> teams labeled from <code>0</code> to <code>n - 1</code>, with some teams being stronger than others. Directed edges represent comparisons between teams: if there is a directed edge from team <code>u</code> to team <code>v</code>, it indicates that team <code>u</code> is stronger than team <code>v</code>.</p>
<p>This problem builds upon <a href="https://leetcode.com/problems/find-champion-i/description/">Find Champion I</a>, where a boolean matrix indicates the strength relationships between teams. In that problem, the goal is to identify the champion by finding the team for which all entries in its row (except the diagonal) are <code>1</code>, signifying that it is stronger than all other teams.</p>
<p>In this problem, we aim to determine the champion team, defined as a team that is not weaker than any other team. Formally, the champion team has no incoming edges, meaning its indegree is zero. Additionally, there must be exactly one such team with zero indegree. If there are multiple teams with zero indegree, we should return <code>-1</code> to indicate the absence of a unique champion.</p>
<p>Thus, the problem boils down to counting the number of edges directed towards each team (indegree). A team with zero indegrees is a potential champion for which we will return the team index. In case of multiple such teams, we will return <code>-1</code>.</p>
<p><img src="../Figures/2924/2924A.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize an Indegree Array:</p>
<ul>
<li>Create an array indegree of size <code>n</code> (the number of teams) and initialize all elements to <code>0</code>. This array will store the number of incoming edges for each team.</li>
</ul>
</li>
<li>
<p>Calculate the Indegree of each team:</p>
<ul>
<li>Loop through each edge in the given edges list.
<ul>
<li>Each edge is a pair <code>[u, v]</code> where team <code>u</code> is a stronger team than <code>v</code>.</li>
<li>Increment the indegree of team <code>v</code> by 1 for every edge <code>(u, v)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Identify Potential Champions:</p>
<ul>
<li>Initialize <code>champ</code>  to <code>-1</code> and <code>champCount</code> (number of potential champions) to <code>0</code>.</li>
<li>Loop through all teams from <code>0</code> to <code>n -1</code>:
<ul>
<li>For each team <code>i</code>, check if its indegree is <code>0</code></li>
<li>If the indegree is <code>0</code>, increment <code>champCount</code> by <code>1</code> and set champ to<code> i</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Determine the Final Champion:</p>
<ul>
<li>After the loop, check the value of <code>champCount</code>:
<ul>
<li>If <code>champCount</code> is greater than <code>1</code>, it means there are multiple teams with indegree <code>0</code>, and thus no unique champion. Return <code>-1</code>.</li>
<li>If <code>champCount</code> is exactly <code>1</code>, return the value of <code>champ</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/QCxudrrV/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of teams given, and <span class="math inline">\(M\)</span> is the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + M)\)</span></p>
<p>We iterate over each edge to store the indegree of each team, this takes <span class="math inline">\(O(M)\)</span> time. Then we iterate over each team to find the teams with zero indegree to get the champion which will take <span class="math inline">\(O(N)\)</span> time. Hence, the total time complexity is equal to <span class="math inline">\(O(N + M)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need a list <code>indegree</code> to store the indegree of each of the <span class="math inline">\(N\)</span> teams. Hence, the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-closest-node-to-given-two-nodes/description" target="_blank" rel="noopener noreferrer">Find Closest Node to Given Two Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>directed</strong> graph of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, where each node has <strong>at most one</strong> outgoing edge.</p>

<p>The graph is represented with a given <strong>0-indexed</strong> array <code>edges</code> of size <code>n</code>, indicating that there is a directed edge from node <code>i</code> to node <code>edges[i]</code>. If there is no outgoing edge from <code>i</code>, then <code>edges[i] == -1</code>.</p>

<p>You are also given two integers <code>node1</code> and <code>node2</code>.</p>

<p>Return <em>the <strong>index</strong> of the node that can be reached from both </em><code>node1</code><em> and </em><code>node2</code><em>, such that the <strong>maximum</strong> between the distance from </em><code>node1</code><em> to that node, and from </em><code>node2</code><em> to that node is <strong>minimized</strong></em>. If there are multiple answers, return the node with the <strong>smallest</strong> index, and if no possible answer exists, return <code>-1</code>.</p>

<p>Note that <code>edges</code> may contain cycles.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png" style="width: 321px; height: 161px;" />
<pre>
<strong>Input:</strong> edges = [2,2,3,-1], node1 = 0, node2 = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.
The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png" style="width: 195px; height: 161px;" />
<pre>
<strong>Input:</strong> edges = [1,2,-1], node1 = 0, node2 = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.
The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-1 &lt;= edges[i] &lt; n</code></li>
	<li><code>edges[i] != i</code></li>
	<li><code>0 &lt;= node1, node2 &lt; n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem presents a directed unweighted graph with <code>n</code> nodes. Each node can have at most one outgoing edge. Our task is to find the closest node from two given nodes, <code>node1</code> and <code>node2</code> so that the maximum between the distances from <code>node1</code> and <code>node2</code> to that node is minimized over all the nodes. If there are multiple answers, we need to return the node with the smallest index, and if no possible answer exists, we need to return <code>-1</code>.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see intuitively that if we have the distances from <code>node1</code> and <code>node2</code> to all the nodes, then we can iterate over all the nodes and choose a node that has the smallest maximum value between the distances from <code>node1</code> to that node and from  <code>node2</code> to that node.</p>
<p>A breadth-first search (BFS) is a good algorithm to use if we want to find the shortest path in an unweighted graph. The path used in BFS traversal always has the least number of edges. The BFS algorithm does a level-wise iteration of the graph. As a result, it first finds all paths that are one edge away from the source node, followed by all paths that are two edges away from the source node, and so on. This allows BFS to find the shortest path in terms of steps from the source node to any other node. It is implemented with a queue.</p>
<p>Here is an example with steps:</p>
<p><img src="../Figures/2359/2359-bfs.png" alt="img" /></p>
<p>In this approach, we begin BFS traversals for both <code>node1</code> and <code>node2</code> to compute the shortest distances from <code>node1</code> and <code>node2</code> to all other nodes. We store the results in arrays labeled <code>dist1</code> and <code>dist2</code>, respectively. We also set two variables: <code>minDistNode = -1</code>, which is the answer to our problem, and <code>minDistTillNow</code>, which is the maximum between the distances from <code>node1</code> to <code>minDistNode</code> and from <code>node2</code> to <code>minDistNode</code>.</p>
<p>Now, we iterate over all of the nodes from <code>0</code> to <code>n - 1</code>. For each node, say <code>currNode</code> we check if the maximum distance from <code>node1</code> and <code>node2</code> is smaller than the other nodes previously seen. If <code>minDistTillNow &gt; max(dist1[currNode], dist2[currNode])</code>, we have a node <code>currNode</code> with a smaller maximum value between the distances from <code>node1</code> to <code>currNode</code> and from <code>node2</code> to <code>currNode</code>. In this case, we update the <code>minDistTillNow</code> to <code>minDistTillNow = max(dist1[currNode], dist2[currNode])</code> and update the <code>minDistNode</code> to <code>minDistNode = currNode</code>.</p>
<p>Otherwise, if <code>minDistTillNow &lt;= max(dist1[currNode], dist2[currNode])</code> we do not do anything. We return <code>minDistNode</code> at the end of all the iterations over every node. We would never update the variable <code>currNode</code> if we couldn't reach any node that is reachable from <code>node1</code> and <code>node2</code>. In that case, we'd return the <code>currNode</code> variable with its original value of <code>-1</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize two arrays, <code>dist1</code> and <code>dist2</code> storing the shortest distances from <code>node1</code> and <code>node2</code> to all the nodes. Initialize them with large values.</li>
<li>Start a BFS traversal.
<ul>
<li>We use a function <code>bfs</code> to perform the traversal. It requires <code>startNode, edges, dist</code> as the parameters, where <code>dist</code> is the array that stores the shortest distances from <code>startNode</code> to all the nodes.</li>
<li>Start with <code>node1, edges, dist1</code>.</li>
<li>Initialize a queue with <code>startNode</code> in the queue.</li>
</ul>
</li>
<li>Initialize an array <code>visit</code>, storing a boolean for each node to indicate if a node is visited. Initialize it with <code>false</code> for all the nodes.</li>
<li>Then, while the queue is not empty:
<ul>
<li>Dequeue the first <code>node</code> from the queue. If it has not been visited, mark it as visited. Otherwise, if it has been visited, repeat step 4.</li>
<li>Check if <code>node</code> has an outgoing edge. If there is no outgoing edge, we don't do anything.</li>
<li>If the <code>node</code> has an outgoing edge to another node called <code>neighbor</code>, and <code>neighbor</code> has not yet been visited, update the <code>dist[neighbor]</code> to <code>dist[neighbor] = 1 + dist[node]</code> and push the <code>neighbor</code> into the queue.</li>
</ul>
</li>
<li>Perform another BFS traversal with <code>node2, edges, dist2</code> to get the shortest distances from <code>node2</code> to every other node in <code>dist2</code>.</li>
<li>Initialize two variables: <code>minDistNode = -1</code>, which is the answer to our problem, and <code>minDistTillNow</code>, which is the maximum between the distances from <code>node1</code> to <code>minDistNode</code> and from <code>node2</code> to <code>minDistNode</code>.</li>
<li>Run a loop over all the nodes and check each node called <code>currNode</code>.
<ul>
<li>If <code>minDistTillNow &gt; max(dist1[currNode], dist2[currNode])</code>, update <code>minDistTillNow</code> to <code>minDistTillNow = max(dist1[currNode], dist2[currNode])</code> and update <code>minDistNode</code> to <code>minDistNode = currNode</code>.</li>
<li>Otherwise, we do not update anything.</li>
</ul>
</li>
<li>Return <code>minDistNode</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8dxTbBWd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<ul>
<li>The complexity would be similar to the standard BFS algorithm since we are performing the BFS traversal twice.</li>
<li>For the BFS algorithm, each node is only queued once, which takes <span class="math inline">\(O(1)\)</span> time for each node. We also iterate over the edge of every node once (since we only visit each node once, we won't iterate over a node's edge multiple times), which adds <span class="math inline">\(O(n)\)</span> time since we have at most <span class="math inline">\(n\)</span> edges.</li>
<li>We also require <span class="math inline">\(O(n)\)</span> time to initialize each <code>dist1</code>, the <code>dist2</code> and the <code>visit</code> arrays.</li>
<li>We also require <span class="math inline">\(O(n)\)</span> time to run a loop over all the nodes in the end to compute the answer.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>Because each node only has one outgoing edge, the queue size will never exceed <code>1</code>. As such, we don't actually need the queue, but we've used it here to show the template code implementation for BFS.</li>
<li>However, we still require <span class="math inline">\(O(n)\)</span> space each for the <code>dist1</code>, the <code>dist2</code> and the <code>visit</code> arrays.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An interesting property of the graph mentioned in the problem is that each node can have at most one outgoing edge. We can see intuitively that if every node has at most one outgoing edge, there can only be one path from a node to any other node. This is because we only have one way to proceed from one node to another node by using the outgoing edge, if one exists. If there is no outgoing edge or the node has a self-loop (an edge that connects a node to itself), we cannot move ahead. So, if we are able to move, we can only move in one direction. Due to this property, we would be able to use the depth-first search (DFS) algorithm to find the shortest path from a node to all the other nodes in this scenario.</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring. Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>Here is an example with steps:</p>
<p><img src="../Figures/2359/2359-dfs.png" alt="img" /></p>
<p>We can only have one branch as per our problem. So, DFS works for our use case to find the shortest distance from a node to all other nodes.</p>
<p>Note that, we cannot use DFS in a standard unweighted graph to find the shortest distance from a node to any other node. For example, let's take a graph with three edges: <code>1 -&gt; 2</code>, <code>1 -&gt; 3</code> and <code>2 -&gt; 3</code>. Let's say we start with node <code>1</code> and mark its distance as <code>0</code>. We move forward, visit node <code>2</code> and mark its distance as <code>1</code>. As mentioned in DFS, we explore nodes as far as possible along the branch, so from node <code>2</code> we will go to node <code>3</code>. We will mark its distance as <code>2</code>, which is incorrect. We can visit node <code>3</code> via <code>1 -&gt; 3</code> with a distance of <code>1</code>.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<p>In this approach, we begin DFS traversals for both <code>node1</code> and <code>node2</code> to compute the shortest distances from <code>node1</code> and <code>node2</code> to all other nodes. We will store the results in arrays labelled <code>dist1</code> and <code>dist2</code>, respectively.</p>
<p>Then, we will iterate over all the nodes and find a node <code>minDistNode</code> with the smallest maximum value between the distances from <code>node1</code> to <code>minDistNode</code> and <code>node2</code> to <code>minDistNode</code> similar to the BFS approach.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize two arrays, <code>dist1</code> and <code>dist2</code> storing the shortest distances from <code>node1</code> and <code>node2</code> to all the nodes. Initialize them with large values. Set <code>dist1[node1] = 0</code> and <code>dist2[node2] = 0</code>.</li>
<li>Initialize two boolean arrays, <code>visit1</code> and <code>visit2</code> to indicate if a node is visited or not in a DFS traversal, starting from <code>node1</code> and <code>node2</code> respectively. Initialize them with false.</li>
<li>Start a DFS traversal.
<ul>
<li>We use a function <code>dfs</code> to perform the traversal. For each call, pass the <code>node, edges, dist, visit</code> as the parameters.</li>
<li>Start with <code>node1, edges, dist, visit1</code> to get the shortest distances from <code>node1</code> to every node in <code>dist1</code>.</li>
<li>Mark <code>node</code> as visited.</li>
<li>If the <code>node</code> has an outgoing edge to another node called <code>neighbor</code>, and <code>neighbor</code> has not yet been visited, update the <code>dist[neighbor]</code> to <code>dist[neighbor] = 1 + dist[node]</code>. We also recursively call the dfs with <code>neighbor, dges, dist, visit</code>.</li>
</ul>
</li>
<li>Perform another DFS traversal with <code>node2, edges, dist2, visit2</code> to get the shortest distances from <code>node2</code> to every node. The distances will be stored in <code>dist2</code>.</li>
<li>Initialize two variables: <code>minDistNode = -1</code>, which is the answer to our problem, and <code>minDistTillNow</code>, which is the maximum between the distances from <code>node1</code> to <code>minDistNode</code> and from <code>node2</code> to <code>minDistNode</code>.</li>
<li>Run a loop over all the nodes and check each node called <code>currNode</code>.
<ul>
<li>If <code>minDistTillNow &gt; max(dist1[currNode], dist2[currNode])</code>, update <code>minDistTillNow</code> to <code>minDistTillNow = max(dist1[currNode], dist2[currNode])</code> and update <code>minDistNode</code> to <code>minDistNode = currNode</code>.</li>
<li>Otherwise, we do not update anything.</li>
</ul>
</li>
<li>Return <code>minDistNode</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/kQKyWEuV/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The complexity would be similar to the standard DFS algorithm since we’re performing the DFS traversal twice.</li>
<li>Each node is visited by the <code>dfs</code> function once, which takes <span class="math inline">\(O(n)\)</span> time in total. We also iterate over the edge of every node once (since we only visit each node once, we won't iterate over a node's edge multiple times), which adds <span class="math inline">\(O(n)\)</span> time since we have at most <span class="math inline">\(n\)</span> edges.</li>
<li>We also require <span class="math inline">\(O(n)\)</span> time to initialize each <code>dist1</code>, the <code>dist2</code> and the <code>visit</code> arrays.</li>
<li>We also require <span class="math inline">\(O(n)\)</span> time to run a loop over all the nodes in the end to compute the answer.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
<li>We also require <span class="math inline">\(O(n)\)</span> space each for the <code>dist1</code>, the <code>dist2</code> and the <code>visit</code> arrays.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description" target="_blank" rel="noopener noreferrer">Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">sorting</span> <span class="topic-badge">strongly-connected-component</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a weighted undirected connected graph with <code>n</code>&nbsp;vertices numbered from <code>0</code> to <code>n - 1</code>,&nbsp;and an array <code>edges</code>&nbsp;where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, weight<sub>i</sub>]</code> represents a bidirectional and weighted edge between nodes&nbsp;<code>a<sub>i</sub></code>&nbsp;and <code>b<sub>i</sub></code>. A minimum spanning tree (MST) is a subset of the graph&#39;s edges that connects all vertices without cycles&nbsp;and with the minimum possible total edge weight.</p>

<p>Find <em>all the critical and pseudo-critical edges in the given graph&#39;s minimum spanning tree (MST)</em>. An MST edge whose deletion from the graph would cause the MST weight to increase is called a&nbsp;<em>critical edge</em>. On&nbsp;the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.</p>

<p>Note that you can return the indices of the edges in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/06/04/ex1.png" style="width: 259px; height: 262px;" /></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
<strong>Output:</strong> [[0,1],[2,3,4,5]]
<strong>Explanation:</strong> The figure above describes the graph.
The following figure shows all the possible MSTs:
<img alt="" src="https://assets.leetcode.com/uploads/2020/06/04/msts.png" style="width: 540px; height: 553px;" />
Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.
The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/06/04/ex2.png" style="width: 247px; height: 253px;" /></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
<strong>Output:</strong> [[],[0,1,2,3]]
<strong>Explanation:</strong> We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= weight<sub>i</sub>&nbsp;&lt;= 1000</code></li>
	<li>All pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-edges-in-shortest-paths/description" target="_blank" rel="noopener noreferrer">Find Edges in Shortest Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected weighted graph of <code>n</code> nodes numbered from 0 to <code>n - 1</code>. The graph consists of <code>m</code> edges represented by a 2D array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>Consider all the shortest paths from node 0 to node <code>n - 1</code> in the graph. You need to find a <strong>boolean</strong> array <code>answer</code> where <code>answer[i]</code> is <code>true</code> if the edge <code>edges[i]</code> is part of <strong>at least</strong> one shortest path. Otherwise, <code>answer[i]</code> is <code>false</code>.</p>

<p>Return the array <code>answer</code>.</p>

<p><strong>Note</strong> that the graph may not be connected.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/05/graph35drawio-1.png" style="height: 129px; width: 250px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,true,true,false,true,true,true,false]</span></p>

<p><strong>Explanation:</strong></p>

<p>The following are <strong>all</strong> the shortest paths between nodes 0 and 5:</p>

<ul>
	<li>The path <code>0 -&gt; 1 -&gt; 5</code>: The sum of weights is <code>4 + 1 = 5</code>.</li>
	<li>The path <code>0 -&gt; 2 -&gt; 3 -&gt; 5</code>: The sum of weights is <code>1 + 1 + 3 = 5</code>.</li>
	<li>The path <code>0 -&gt; 2 -&gt; 3 -&gt; 1 -&gt; 5</code>: The sum of weights is <code>1 + 1 + 2 + 1 = 5</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/05/graphhhh.png" style="width: 185px; height: 136px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,false,false,true]</span></p>

<p><strong>Explanation:</strong></p>

<p>There is one shortest path between nodes 0 and 3, which is the path <code>0 -&gt; 2 -&gt; 3</code> with the sum of weights <code>1 + 2 = 3</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= m &lt;= min(5 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-eventual-safe-states/description" target="_blank" rel="noopener noreferrer">Find Eventual Safe States</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a <strong>0-indexed</strong> 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes adjacent to node <code>i</code>, meaning there is an edge from node <code>i</code> to each node in <code>graph[i]</code>.</p>

<p>A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong> (or another safe node).</p>

<p>Return <em>an array containing all the <strong>safe nodes</strong> of the graph</em>. The answer should be sorted in <strong>ascending</strong> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="Illustration of graph" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" style="height: 171px; width: 600px;" />
<pre>
<strong>Input:</strong> graph = [[1,2],[2,3],[5],[0],[5],[],[]]
<strong>Output:</strong> [2,4,5,6]
<strong>Explanation:</strong> The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
<strong>Output:</strong> [4]
<strong>Explanation:</strong>
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= graph[i].length &lt;= n</code></li>
	<li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li>
	<li><code>graph[i]</code> is sorted in a strictly increasing order.</li>
	<li>The graph may contain self-loops.</li>
	<li>The number of edges in the graph will be in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes that have an incoming edge from node <code>i</code>.</p>
<p>The problem states that a node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a terminal node (or another safe node).</p>
<p>Our task is to return a sorted array of all the safe nodes of the graph.</p>
<hr />
<h3 id="approach-1-topological-sort-using-kahns-algorithm">Approach 1: Topological Sort Using Kahn's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve the problem, we must first consider when a node is safe or unsafe. If we begin at any node and proceed along any path from that node, we will eventually reach either a terminal node or enter a cycle and continue to loop in it without ever reaching a terminal node.</p>
<p>If there is no path from the node that enters a cycle, we will always be able to reach a terminal node. As a result, such a node is a safe node and should be added to our answer array.</p>
<blockquote>
<p>The problem is reduced to finding the nodes that do not have any paths that lead to a cycle.</p>
</blockquote>
<p>Intuitively, we can realize that a node is safe if all of its outgoing edges are to nodes that are also safe. This is due to the fact that if no neighbor leads to a cycle, no path from the node can either.</p>
<p>We know the terminal nodes are safe. As a result, nodes that solely have outgoing edges to terminal nodes are eventually safe nodes. Then we may check the nodes that have just outgoing edges to safe nodes again and keep updating until no new safe node is discovered.</p>
<p>The question is, how do we efficiently traverse from terminal nodes to nodes that only have outgoing edges to terminal nodes? We can reverse the edges of the graph to create a new graph with reversed edges. After we have visited all of the terminal nodes, we can use this new graph to go to the nodes that have edges to the terminal nodes in the original graph by using the reverse edges that we added.</p>
<p>Let's put this new graph to use now. A node is a safe node if all of its incoming edges come from previously identified safe nodes in the graph. If we erase the edges outgoing from the safe node and discover a node with no incoming edges, it is a new safe node. This gives us hints for thinking about Kahn's method, which does a topological sort by removing the edges in the exact way we want.</p>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge <code>u -&gt; v</code> from vertex <code>u</code> to vertex <code>v</code>, <code>u</code> comes before <code>v</code> in the ordering.</p>
<p>In a directed acyclic graph, we can use Kahn's algorithm to get the topological ordering. Kahn’s algorithm works by keeping track of the number of incoming edges into each node (indegree). It works by repeatedly visiting the nodes with an indegree of zero and deleting all the edges associated with it leading to a decrement of indegree for the nodes whose incoming edges are deleted. This process continues until no elements with zero indegree can be found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">LeetCode Explore Card</a>.</p>
<p>The advantage of using Kahn's technique is that it also aids in the discovery of graph cycles. The Kahn's method does not visit any node in a cycle. As a result, nodes with outgoing edges from nodes in the cycle (in this reversed graph) will never be visited and so will never be marked safe. Nodes with outgoing edges from these unsafe nodes will never be visited as well, and so on. Basically, every node in the original network that has a path to the cycle will never be visited by Kahn's algorithm, which is exactly what we want.</p>
<p>Let's perform Kahn's algorithm on a directed graph having a cycle. Here's a visual step-by-step representation of how it would work:</p>
<p><img src="../Figures/802/802-1.png" alt="img" /></p>
<p>We can see that if there is a cycle, the indegree of nodes in the cycle cannot be set to <code>0</code> due to cyclic dependency. We are unable to visit the cycle's nodes. We are also unable to visit any node with an incoming edge from any node in the cycle. Similarly, realize that any node with an incoming edge from nodes <code>3</code> or <code>5</code> would not have been visited as well.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer <code>n</code> equal to the length of <code>graph</code> to get the number of nodes in the given graph.</li>
<li>Create an array <code>indegree</code> of length <code>n</code> where <code>indegree[x]</code> stores the number of edges entering node <code>x</code>.</li>
<li>We create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all the nodes with an incoming edge from node <code>x</code>, i.e., neighbors of node <code>x</code>. We create this adjacency list by iterating over <code>graph</code> and adding the <strong>reverse edges</strong>. For a node <code>i</code> which originally has outgoing edges to nodes in <code>graph[i]</code>, we push <code>i</code> into <code>adj[node]</code> to add a reverse edge from <code>node</code> to <code>i</code>.</li>
<li>Initialize a queue of integers <code>q</code> and start a BFS algorithm moving from the leaf nodes to the parent nodes.</li>
<li>Begin the BFS traversal by pushing all of the leaf nodes (<code>indegree</code> equal to <code>0</code>) in the queue.</li>
<li>Create a boolean array <code>safe</code> of size <code>n</code> to track the safe nodes in the graph.</li>
<li>While the queue is not empty;
<ul>
<li>Dequeue the first <code>node</code> from the queue.</li>
<li>Mark <code>node</code> as safe.</li>
<li>For each <code>neighbor</code> (nodes that have an incoming edge from <code>node</code>) of <code>node</code>, we decrement <code>indegree[neighbor]</code>by <code>1</code> to delete the <code>node -&gt; neighbor</code> edge.</li>
<li>If <code>indegree[neighbor] == 0</code>, it means that <code>neighbor</code> behaves as a leaf node, so we push <code>neighbor</code> in the queue.</li>
</ul>
</li>
<li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>.</li>
<li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FWjfs3PY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes and <span class="math inline">\(m\)</span> is number of edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Initializing the <code>adj</code> list takes <span class="math inline">\(O(m)\)</span> time as we go through all the edges. The <code>indegree</code> array take <span class="math inline">\(O(n)\)</span> time.</li>
<li>Initializing the boolean <code>safe</code> array also takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Each queue operation takes <span class="math inline">\(O(1)\)</span> time, and a single node will be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. We iterate over the neighbors of each node that is popped out of the queue iterating over all the edges once. Since there are total of <code>m</code> edges, it would take <span class="math inline">\(O(m)\)</span> time to iterate over the edges.</li>
<li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>The <code>adj</code> arrays takes <span class="math inline">\(O(m)\)</span> space. The <code>indegree</code> array takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The <code>safe</code> array also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The queue can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also use a depth-first search (DFS) traversal to detect the nodes that lead to a cycle, i.e., unsafe nodes.</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>A node remains in the DFS recursion stack until all of its branches (all nodes in its subtree) have not been explored. When we have examined all of a node's branches, i.e. visited all of the nodes in its subtree, the node is removed from the DFS recursive stack.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<p>To find the unsafe nodes, we must first recognize a cycle in the graph. If we find a cycle, we will mark all of the nodes in the cycle as unsafe and then go back and mark all of the nodes that led to this cycle as unsafe. Let's find a cycle first.</p>
<p>If the graph has a cycle, we must have a <strong>back edge</strong> connecting a node to one of its ancestors while traversing nodes in the DFS manner.</p>
<p>Let's think how we can establish whether or not a node's neighbor is an ancestor when navigating from one node to another.</p>
<p>If the neighboring node has not yet been visited, it cannot be an ancestor (it is a child node).</p>
<p>Otherwise, if a neighboring node is visited, it may or may not be an ancestor. If the neighboring node is an ancestor, i.e. there is a back edge, it means that we visited this ancestor node first in the DFS traversal, then visited and explored some other nodes, and eventually visited a node that connects back to the ancestor node. As we are still exploring the ancestor node's subtree while iterating over this path, hence this node must be in the current DFS recursive stack.</p>
<p>However, if a neighboring node is visited but not in the recursion stack, it signifies we have previously explored that node in a different branch, and it does not form a cycle in the current branch.</p>
<p>As a result, to detect the cycle we must keep track of the visited nodes (like in a normal DFS) and also the nodes in the function's recursion call stack for DFS traversal. The nodes in the stack store the current path that we are on. There is a cycle in the graph if a node is reached that is already in the recursion stack. We use a boolean array <code>inStack</code> of length <code>n</code> to track which nodes are in the call stack so we can check if a node exists in <span class="math inline">\(O(1)\)</span>. Note that this <code>inStack</code> array is emulating the call stack that the computer is using under the hood to execute recursion. We mark an unvisited node in <code>inStack</code> when we make a recursive call to it and then unmark it when we return from that call.</p>
<p>Now that we've identified the cycle, let's look for the unsafe nodes. When we get a cycle, all of the nodes in the recursion stack either form or lead to a cycle. If we start a DFS traversal from node <code>1</code> in a graph <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 2</code>, nodes <code>2</code>, <code>3</code>, and <code>4</code> form a cycle. When we discovered this cycle, node <code>1</code> was also in the stack. So, when we have a cycle, all the nodes in the recursion stack are unsafe since they form or lead to a loop.</p>
<p>In addition to detecting cycles, we can use the same <code>inStack</code> array to store the unsafe nodes. We do not unmark any of the unsafe nodes from <code>inStack</code> to keep track of them. When any <code>node</code> has an outgoing edge to any of the unsafe nodes, we can immediately return the DFS call for <code>node</code> without unmarking it from <code>inStack</code>, i.e, we do not perform <code>inStack[node] = false</code>. This is because if any <code>neighbor</code> of <code>node</code> is marked <code>inStack</code>, it signifies that either <code>neighbor</code> and <code>node</code> are part of a cycle or <code>neighbor</code> is a previously detected unsafe node. In both the cases, <code>node</code> is also an unsafe node and hence we return the DFS call without unmarking <code>node</code> from <code>inStack</code>.</p>
<p>We only unmark a node from <code>inStack</code>, if we have explored all of its branches and no branch leads to an unsafe node.</p>
<h4 id="algorithm-1">Algorithm</h4>
<blockquote>
<p>Here, we can use the input graph as the adjacency list <code>adj</code></p>
</blockquote>
<ol>
<li>Create two boolean arrays, <code>visit</code> and <code>inStack</code>, each of size <code>n</code>. The <code>visit</code> array keeps track of visited nodes and <code>inStack</code> keeps track of nodes that are currently in the ongoing DFS stack. It will help us to detect a cycle in the graph and the unsafe nodes.</li>
<li>For each node we begin a DFS traversal. We implement the <code>dfs</code> method which takes four parameters: an integer <code>node</code> from which the current traversal begins, <code>adj</code>, <code>visit</code>, and <code>inStack</code>. It returns a boolean indicating whether <code>node</code> is unsafe. We perform the following in this method:
<ul>
<li>If <code>node</code> is already present in <code>inStack</code>, either we just got a cycle or a previously detected unsafe node. We return <code>true</code> in this case as the <code>node</code> is unsafe.</li>
<li>If <code>node</code> is already visited (but not in <code>inStack</code>), we return <code>false</code> because we already visited this <code>node</code> and didn't find it as unsafe node. It is a safe node.</li>
<li>We mark <code>node</code> as visited and also mark it in <code>inStack</code> (<code>inStack[node] = true</code>).</li>
<li>We iterate over all the outgoing edges of <code>node</code> and for each <code>neighbor</code>, we recursively call <code>dfs(neighbor, adj, visit, inStack)</code>. If we get a cycle from <code>neighbor</code> (or <code>neighbor</code> is a previously detected unsafe node), we return <code>true</code> without unmarking <code>node</code> in <code>inStack</code>.</li>
<li>After we have processed all the outgoing edges of <code>node</code>, we mark <code>inStack[node] = false</code> to mark <code>node</code> as safe. We return <code>false</code>.</li>
</ul>
</li>
<li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>, i.e., the nodes with <code>inStack[node] == false</code>.</li>
<li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/V99UanNc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes and <span class="math inline">\(m\)</span> is number of edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> and <code>inStack</code> arrays take <span class="math inline">\(O(n)\)</span> time each.</li>
<li>The <code>dfs</code> function handles each node once, which takes <span class="math inline">\(O(n)\)</span> time in total. From each node, we iterate over all the outgoing edges, which further takes <span class="math inline">\(O(m)\)</span> time to iterate over all the edges as there are a total of <code>m</code> edges.</li>
<li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The <code>visit</code> and <code>inStack</code> arrays take <span class="math inline">\(O(n)\)</span> space each.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-if-path-exists-in-graph/description" target="_blank" rel="noopener noreferrer">Find if Path Exists in Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>bi-directional</strong> graph with <code>n</code> vertices, where each vertex is labeled from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>). The edges in the graph are represented as a 2D integer array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a bi-directional edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by <strong>at most one</strong> edge, and no vertex has an edge to itself.</p>

<p>You want to determine if there is a <strong>valid path</strong> that exists from vertex <code>source</code> to vertex <code>destination</code>.</p>

<p>Given <code>edges</code> and the integers <code>n</code>, <code>source</code>, and <code>destination</code>, return <code>true</code><em> if there is a <strong>valid path</strong> from </em><code>source</code><em> to </em><code>destination</code><em>, or </em><code>false</code><em> otherwise</em><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png" style="width: 141px; height: 121px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> There are two paths from vertex 0 to vertex 2:
- 0 &rarr; 1 &rarr; 2
- 0 &rarr; 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png" style="width: 281px; height: 141px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no path from vertex 0 to vertex 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= source, destination &lt;= n - 1</code></li>
	<li>There are no duplicate edges.</li>
	<li>There are no self edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/description" target="_blank" rel="noopener noreferrer">Find Minimum Diameter After Merging Two Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exist two <strong>undirected </strong>trees with <code>n</code> and <code>m</code> nodes, numbered from <code>0</code> to <code>n - 1</code> and from <code>0</code> to <code>m - 1</code>, respectively. You are given two 2D integer arrays <code>edges1</code> and <code>edges2</code> of lengths <code>n - 1</code> and <code>m - 1</code>, respectively, where <code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the first tree and <code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the second tree.</p>

<p>You must connect one node from the first tree with another node from the second tree with an edge.</p>

<p>Return the <strong>minimum </strong>possible <strong>diameter </strong>of the resulting tree.</p>

<p>The <strong>diameter</strong> of a tree is the length of the <em>longest</em> path between any two nodes in the tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example11-transformed.png" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>We can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example211.png" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>We can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>edges1.length == n - 1</code></li>
	<li><code>edges2.length == m - 1</code></li>
	<li><code>edges1[i].length == edges2[i].length == 2</code></li>
	<li><code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; m</code></li>
	<li>The input is generated such that <code>edges1</code> and <code>edges2</code> represent valid trees.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two trees: one with <code>n</code> nodes and the other with <code>m</code> nodes. Our goal is to add an edge between a node from the first tree and a node from the second tree, in such a way that the <em>diameter</em> of the resulting tree is minimized.</p>
<blockquote>
<p>The <em>diameter</em> of a tree is the longest path between any two nodes in the tree.</p>
</blockquote>
<p>Let us consider the two ways that the longest path can be formed:</p>
<ol>
<li>
<p>The path starts and ends at nodes within the same tree.</p>
 <img src="../Figures/3203/3203_overview2.png" alt="Second way to form longest path" width="400px">
<p>In this case, the problem reduces to finding the maximum diameter of the two original trees.</p>
</li>
<li>
<p>The path starts at a node in the first tree and ends at a node in the second.</p>
 <img src="../Figures/3203/3203_overview1.png" alt="First way to form longest path" width="400px">
<p>In this case, the selection of the nodes to connect is crucial for minimizing the overall diameter. Intuitively, we aim to select these nodes so that, if chosen as roots, the heights of their respective trees are minimized. In practice, this often involves selecting nodes near the &quot;center&quot; of each tree, ensuring their subtrees are as balanced as possible.</p>
 <details>
 <summary>Click here for a formal proof</summary>
<p>Specifically, for the node that is in the middle of the diameter, the following holds:</p>
<ol>
<li>Its maximum distance to any node of the tree is equal to <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.<br />
This is because its maximum distance is determined by the farthest endpoint of the diameter. We can prove this by contradiction. Suppose the maximum distance were to some other node outside the diameter path. This would require the existence of a longer path than the diameter, contradicting the definition of the diameter as the longest path in the tree. Therefore:
<ul>
<li>If the <span class="math inline">\(\text{diameter}\)</span> is even, the middle node is equidistant from both endpoints of the diameter, with a distance of <span class="math inline">\(\frac{\text{diameter}}{2}\)</span> to each.</li>
<li>If the <span class="math inline">\(\text{diameter}\)</span> is odd, each of the two middle nodes has distances <span class="math inline">\(\frac{\text{diameter} - 1}{2}\)</span> to one endpoint and <span class="math inline">\(\frac{\text{diameter} + 1}{2}\)</span> to the other. In this case, the maximum distance is <span class="math inline">\(\frac{\text{diameter} + 1}{2}\)</span> = <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.</li>
</ul>
</li>
<li>For any other node in the tree, its maximum distance to another node is greater than or equal to <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.<br />
Again, the maximum distance for any node is towards one of the endpoints of the diameter, denoted as <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Consider a node <span class="math inline">\(u\)</span>, and assume <span class="math inline">\(u\)</span> is closer to <span class="math inline">\(a\)</span> than <span class="math inline">\(b\)</span>. The distance of <span class="math inline">\(u\)</span> to <span class="math inline">\(b\)</span> can be lower-bounded as follows:</li>
</ol>
<ul>
<li>Let <span class="math inline">\(m\)</span> be the midpoint of the diameter, located at a distance of at least <span class="math inline">\(\lfloor \frac{\text{diameter}}{2} \rfloor\)</span> to <span class="math inline">\(b\)</span>.</li>
<li>Since <span class="math inline">\(u\)</span> is closer to <span class="math inline">\(a\)</span>, it lies either on the path between <span class="math inline">\(a\)</span> and <span class="math inline">\(m\)</span>, or off the diameter in a subtree connected to this path.</li>
<li>In either case, the shortest path from <span class="math inline">\(u\)</span> to <span class="math inline">\(b\)</span> must pass through <span class="math inline">\(m\)</span> or a point even farther from <span class="math inline">\(b\)</span>. Thus, the distance from <span class="math inline">\(u\)</span> to <span class="math inline">\(b\)</span> is at least the distance from <span class="math inline">\(m\)</span> to <span class="math inline">\(b\)</span> plus 1, or <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.</li>
</ul>
 </details>
<p>By adding an edge between the two centers of the trees, the maximum distance between each of them and a node within the same tree is at most <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>. Thus, the combined diameter of the tree is the sum of the halves of the original diameters plus one for the extra edge:</p>
<p><span class="math display">\[\begin{aligned}
    \lceil \frac{\text{diameter}_1}{2} \rceil + \lceil \frac{\text{diameter}_2}{2} \rceil + 1.
\end{aligned}
\]</span></p>
<p>Therefore, the problem simplifies to returning the maximum among the diameter of each tree and the above value.</p>
</li>
</ol>
<p>Feel free to try solving these problems first as great prerequisites to this one:<br />
1. <a href="https://leetcode.com/problems/minimum-height-trees/description/">Minimum Height Trees</a>.<br />
2. <a href="https://leetcode.com/problems/tree-diameter/description/">Tree Diameter</a></p>
<hr />
<h3 id="approach-1-farthest-of-farthest-bfs">Approach 1: Farthest of Farthest (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's break down the problem of calculating the diameter of a tree. First of all, we observe that any tree can be seen as:</p>
<ul>
<li>The sequence of nodes on the diameter itself, plus</li>
<li>Additional subtrees branching out from nodes along the diameter.</li>
</ul>
<img alt="Tree = sequence of nodes on the diameter + subtrees" src="../Figures/3203/3203_first_approach.png" width="400px" />
<p>For any node in the tree, its minimum distance to one of the diameter's endpoints (say <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>) is always less than or equal to the diameter. This can be proven via contradiction. If one endpoint of the diameter (<span class="math inline">\(a\)</span>) is known, the other endpoint (<span class="math inline">\(b\)</span>) is simply the farthest node from <span class="math inline">\(a\)</span>.</p>
<p>Based on that, one naive way to find the diameter is:</p>
<ol>
<li>Assume each node is one endpoint of the diameter.</li>
<li>Calculate the farthest node from it.</li>
<li>Record the longest path found.</li>
</ol>
<p>However, this approach involves computing the farthest node for all nodes, leading to a time complexity of <span class="math inline">\(O(n^2)\)</span>, which will result in a TLE (Time Limit Exceeded) for the given constraints.</p>
<p>For the optimized approach, we observe that we only need to find the farthest node of a single arbitrary node <span class="math inline">\(u\)</span> and that node would be one of the endpoints of the diameter. Why does this work? Let's consider the following cases:</p>
<ul>
<li>
<p>Case 1: <span class="math inline">\(u\)</span> lies on the diameter<br />
Running a BFS for the longest path from <span class="math inline">\(u\)</span> will find an endpoint of the diameter.</p>
  <details>
  <summary>Click here for a formal proof</summary>
  <br>
<p>We will prove this statement by contradiction. Let <span class="math inline">\(v\)</span> (<span class="math inline">\(v \neq a, b\)</span>) be the farthest node from <span class="math inline">\(u\)</span>, implying <span class="math inline">\(\text{dist}(u, b) < \text{dist}(u, v)\)</span>. Assume <span class="math inline">\(u\)</span> is closer to <span class="math inline">\(a\)</span> than <span class="math inline">\(b\)</span>, so <span class="math inline">\(\text{dist}(u, a) \leq \text{dist}(u, b)\)</span>. Combining these inequalities gives us:</p>
<p><span class="math display">\[\begin{aligned}
\text{dist}(u, b) + \text{dist}(u, a) &< \text{dist}(u, v) + \text{dist}(u, b)  \\
\text{dist}(a, b) &< \text{dist}(v, b),
\end{aligned}
\]</span></p>
<p>which is a contradiction, since the diameter (<span class="math inline">\(a \rightarrow b\)</span>) is the longest path in the tree.</p>
  </details>
</li>
<li>
<p>Case 2: <span class="math inline">\(u\)</span> does not lie on the diameter<br />
The path from <span class="math inline">\(u\)</span> to the farthest node passes through the diameter so the problem reduces to Case 1.</p>
  <details>
  <summary>Click here for a formal proof</summary>
  <br>
<p>Let <span class="math inline">\(v\)</span> (<span class="math inline">\(v \neq a, b\)</span>) be the farthest node from <span class="math inline">\(u\)</span>, and <span class="math inline">\(u^*\)</span> the root of <span class="math inline">\(u\)</span>'s subtree. The path <span class="math inline">\(u \to v\)</span> avoids the diameter only if <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are within the same subtree. In this case:</p>
<p><span class="math display">\[\begin{aligned}
\text{dist}(u, v) &> \text{dist}(u, b) \\
\text{dist}(u, u^*) + \text{dist}(u^*, v) \geq \text{dist}(u, v) &> \text{dist}(u, u^*) + \text{dist}(u^*, b) \\
\text{dist}(u^*, v) &> \text{dist}(u^*, b) \\
\text{dist}(a, u^*) + \text{dist}(u^*, v) &> \text{dist}(a, u^*) + \text{dist}(u^*, b) \\
\text{dist}(a, v) &> \text{dist}(a, b) \\
\end{aligned}
\]</span></p>
<pre><code>which is a contradiction, since the diameter ($a \rightarrow b$) is the longest path in the tree.
</code></pre>
  </details>
</li>
</ul>
<p>Therefore, to calculate the diameter of a tree, only two BFS calls are needed:</p>
<ol>
<li>First BFS starting from any arbitrary node to find the <em>farthest</em> node from it, which is also an endpoint of the diameter.</li>
<li>Second BFS starting from this <em>farthest</em> node to find the <em>farthest node</em> from it, which is equal to the second endpoint of the diameter.</li>
</ol>
<blockquote>
<p><strong>Breadth-First Search (BFS)</strong>: For a more comprehensive understanding of breadth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<h5 id="main-function-minimumdiameteraftermerge">Main Function: <code>minimumDiameterAfterMerge</code></h5>
<ul>
<li>
<p>Calculate the number of nodes for each tree:</p>
<ul>
<li><code>n</code> is the number of nodes in Tree 1.</li>
<li><code>m</code> is the number of nodes in Tree 2.</li>
</ul>
</li>
<li>
<p>Build adjacency lists for both trees:</p>
<ul>
<li>Call <code>buildAdjList(n, edges1)</code> to construct the adjacency list for the first tree.</li>
<li>Call <code>buildAdjList(m, edges2)</code> to construct the adjacency list for the second tree.</li>
</ul>
</li>
<li>
<p>Calculate the diameters of both trees:</p>
<ul>
<li>Call <code>findDiameter(n, adjList1)</code> to find the diameter of the first tree.</li>
<li>Call <code>findDiameter(m, adjList2)</code> to find the diameter of the second tree.</li>
</ul>
</li>
<li>
<p>Calculate the longest path that spans across both trees:</p>
<ul>
<li>Calculate <code>combinedDiameter</code> as the sum of half the diameters of both trees, plus 1 (rounded up).</li>
</ul>
</li>
<li>
<p>Return the maximum of the three possibilities:</p>
<ul>
<li>Return the maximum of <code>diameter1</code>, <code>diameter2</code>, and <code>combinedDiameter</code>.</li>
</ul>
</li>
</ul>
<h5 id="buildadjlist-function"><code>buildAdjList</code> function:</h5>
<ul>
<li>Create an adjacency list of size <code>size</code>.</li>
<li>For each edge in <code>edges</code>, add the nodes to each other's adjacency list.</li>
</ul>
<h5 id="finddiameter-function"><code>findDiameter</code> function:</h5>
<ul>
<li>Call <code>findFarthestNode(n, adjList, 0)</code> to find the farthest node from an arbitrary starting node (e.g., node 0).</li>
<li>Call <code>findFarthestNode(n, adjList, farthestNode)</code> from the previously found farthest node to determine the tree diameter.</li>
</ul>
<h5 id="findfarthestnode-function"><code>findFarthestNode</code> function:</h5>
<ul>
<li>Initialize a queue and a visited array to perform BFS starting from <code>sourceNode</code>.</li>
<li>Traverse the graph, updating the farthest node each time a node is dequeued.</li>
<li>Return the farthest node and the distance (diameter).</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4boc29Fs/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the first tree and <span class="math inline">\(m\)</span> the number of nodes in the second tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>To calculate the diameter of a tree, we perform two BFS calls using the <code>findFarthestNode</code> function. Each BFS visits every node and edge exactly once, and since the number of edges is <span class="math inline">\(k - 1 = O(k)\)</span> for a tree of size <span class="math inline">\(k\)</span>, the time complexity of one BFS is <span class="math inline">\(O(k)\)</span>. Thus, finding the diameter of the first tree takes <span class="math inline">\(O(n)\)</span>, and for the second tree, it takes <span class="math inline">\(O(m)\)</span>, as each involves two BFS calls.</p>
<p>The combined diameter of the tree is calculated using constant-time operations like addition and comparison, contributing <span class="math inline">\(O(1)\)</span> to the overall time complexity of <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>All the data structures used in the algorithm, including the adjacency lists, the <code>visited</code> array, and the <code>nodesQueue</code>, have linear space complexity in terms of the size of the tree being processed. Therefore, the total space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let’s start with a simple observation based on the definition of the diameter:</p>
<ul>
<li>For each node in the tree, we calculate the length of the longest path passing through it. The longest of these paths represents the diameter of the tree.</li>
</ul>
<p>To determine the longest path that passes through a node <span class="math inline">\(u\)</span>, we perform a DFS to calculate the two longest distances from <span class="math inline">\(u\)</span> to any leaf nodes in the tree. The sum of these two distances gives the length of the longest path through <span class="math inline">\(u\)</span>.</p>
<p>During the recursive calls, each node returns two values:</p>
<ol>
<li>The diameter of its subtree.</li>
<li>The longest path to a leaf in its subtree, or its <em>depth</em>. This avoids redundant calculations, reusing previously computed values.</li>
</ol>
<blockquote>
<p><strong>Depth-First Search (DFS)</strong>: For a more comprehensive understanding of depth-first search, check out the <a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/">DFS Explore Card</a>. This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="main-function-minimumdiameteraftermerge-1">Main Function: <code>minimumDiameterAfterMerge</code></h5>
<ul>
<li>
<p>Calculate the number of nodes for each tree:</p>
<ul>
<li><code>n</code> is the number of nodes in Tree 1.</li>
<li><code>m</code> is the number of nodes in Tree 2.</li>
</ul>
</li>
<li>
<p>Build adjacency lists for both trees:</p>
<ul>
<li>Use the <code>buildAdjList</code> function to construct the adjacency list for both trees (<code>adjList1</code> and <code>adjList2</code>).</li>
</ul>
</li>
<li>
<p>Find the diameter of Tree 1:</p>
<ul>
<li>Call <code>findDiameter(adjList1, 0, -1)</code> to start a DFS from node 0 in Tree 1.</li>
<li>Store the diameter of Tree 1 in <code>diameter1</code>.</li>
</ul>
</li>
<li>
<p>Find the diameter of Tree 2:</p>
<ul>
<li>Call <code>findDiameter(adjList2, 0, -1)</code> to start a DFS from node 0 in Tree 2.</li>
<li>Store the diameter of Tree 2 in <code>diameter2</code>.</li>
</ul>
</li>
<li>
<p>Calculate the diameter of the combined tree:</p>
<ul>
<li>The combined diameter accounts for the longest path spanning both trees.</li>
<li>It is calculated as <code>ceil(diameter1 / 2.0) + ceil(diameter2 / 2.0) + 1</code>.</li>
</ul>
</li>
<li>
<p>Return the maximum diameter:</p>
<ul>
<li>Return the maximum of the three values: <code>diameter1</code>, <code>diameter2</code>, and <code>combinedDiameter</code>.</li>
</ul>
</li>
</ul>
<h5 id="helper-function-buildadjlist">Helper Function: <code>buildAdjList</code></h5>
<ul>
<li>Given the number of nodes <code>size</code> and an edge list <code>edges</code>, build an adjacency list (<code>adjList</code>):
<ul>
<li>Iterate through each edge and add the corresponding nodes to the adjacency list.</li>
</ul>
</li>
</ul>
<h5 id="helper-function-finddiameter">Helper Function: <code>findDiameter</code></h5>
<ul>
<li>
<p>Given the adjacency list <code>adjList</code>, the current <code>node</code>, and its <code>parent</code>, calculate the diameter of the tree:</p>
<ul>
<li>Initialize two variables <code>maxDepth1</code> and <code>maxDepth2</code> to track the two largest depths from the current node.</li>
<li>Initialize <code>diameter</code> to track the diameter of the subtree.</li>
</ul>
</li>
<li>
<p>For each neighbor of the current node:</p>
<ul>
<li>Skip the parent node to avoid cycles.</li>
<li>Recursively calculate the diameter and depth of the neighbor’s subtree.</li>
<li>Update <code>diameter</code> with the maximum of the current diameter and the child’s diameter.</li>
<li>Increment the depth and update the two largest depths (<code>maxDepth1</code> and <code>maxDepth2</code>).</li>
</ul>
</li>
<li>
<p>The diameter of the current node is updated as <code>maxDepth1 + maxDepth2</code>.</p>
</li>
<li>
<p>Return the <code>diameter</code> and <code>maxDepth1</code> (to be used by the parent).</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/BB9kPcpo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the first tree and <span class="math inline">\(m\)</span> the number of nodes in the second tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The <code>findDiameter</code> function uses Depth-First Search (DFS) on the tree, with a time complexity of <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> is the tree's size. The diameter calculation itself takes <span class="math inline">\(O(n + m)\)</span> time. Since combining the diameters involves only constant-time operations, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The space complexity depends on the size of the data structures and the recursion depth. Using an adjacency list representation of the trees requires <span class="math inline">\(O(n + m)\)</span> space. Additionally, the recursion depth can reach <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> is the number of nodes in the processed tree. Thus, the total space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<h3 id="approach-3-topological-sorting">Approach 3: Topological Sorting</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this approach, we will again calculate the diameter of each tree separately and then apply the method described in <a href="#overview">the overview section</a> to determine the diameter of the resulting tree.</p>
<p>First, observe that the diameter endpoints must be leaves, as any non-leaf endpoints would allow the diameter to extend further in the opposite direction, contradicting the definition of the diameter.</p>
<p>Therefore, removing all leaves reduces the diameter by 2, and the remaining diameter becomes the diameter of the reduced tree. As a result, the remaining part of the diameter will still be the diameter of the reduced tree.</p>
<p>If we continue removing the leaves, the remaining diameter will get progressively smaller until only one or two nodes are left.</p>
<ul>
<li>If one node is left, the diameter equals the number of nodes removed during the reduction.</li>
<li>If two nodes remain, we count the edge connecting them as part of the diameter.</li>
</ul>
<p>To track the current leaves of the reduced tree, we will update the counters of their neighboring nodes, also known as the <em>degree</em> of each node. Once a node's degree reaches 1, we will enqueue that node in the <code>nodesQueue</code> for further processing.</p>
<h4 id="algorithm-2">Algorithm</h4>
<h5 id="main-function-minimumdiameteraftermerge-2">Main Function: <code>minimumDiameterAfterMerge</code></h5>
<ul>
<li>
<p>Calculate the number of nodes for each tree:</p>
<ul>
<li><code>n</code> is the number of nodes in Tree 1.</li>
<li><code>m</code> is the number of nodes in Tree 2.</li>
</ul>
</li>
<li>
<p>Build adjacency lists for both trees:</p>
<ul>
<li>Use the <code>buildAdjList</code> function to construct the adjacency list for each tree (<code>adjList1</code> for Tree 1 and <code>adjList2</code> for Tree 2).</li>
</ul>
</li>
<li>
<p>Calculate the diameters of both trees:</p>
<ul>
<li>Call <code>findDiameter(n, adjList1)</code> to find the diameter of Tree 1 (<code>diameter1</code>).</li>
<li>Call <code>findDiameter(m, adjList2)</code> to find the diameter of Tree 2 (<code>diameter2</code>).</li>
</ul>
</li>
<li>
<p>Calculate the longest path that spans both trees:</p>
<ul>
<li>Compute <code>combinedDiameter</code> as the sum of half of <code>diameter1</code>, half of <code>diameter2</code>, and an additional 1 to account for the merging edge.</li>
<li>The formula is: <code>combinedDiameter = ceil(diameter1 / 2.0) + ceil(diameter2 / 2.0) + 1</code>.</li>
</ul>
</li>
<li>
<p>Return the maximum value among <code>diameter1</code>, <code>diameter2</code>, and <code>combinedDiameter</code>.</p>
</li>
</ul>
<h5 id="buildadjlist-function-1"><code>buildAdjList</code> function:</h5>
<ul>
<li>Initialize an empty adjacency list <code>adjList</code> of the given size (<code>size</code>).</li>
<li>Iterate through the edges and populate the adjacency list by adding neighbors for each node.</li>
</ul>
<h5 id="finddiameter-function-1"><code>findDiameter</code> function:</h5>
<ul>
<li>Initialize a queue <code>leavesQueue</code> to hold leaves (nodes with degree 1) and a <code>degrees</code> vector to track the degree (number of neighbors) of each node.</li>
<li>Add all leaves (nodes with degree 1) to the <code>leavesQueue</code>.</li>
<li>Process the leaves iteratively, removing them and updating the degrees of their neighbors.</li>
<li>Continue until only 2 or fewer nodes remain:
<ul>
<li>For each leaf, reduce the degree of its neighbors, and if a neighbor becomes a leaf, add it to the queue.</li>
</ul>
</li>
<li>If exactly two nodes remain, return the diameter as twice the number of layers of leaves removed + 1 (final connecting edge).</li>
<li>If only one node remains, return twice the number of layers of leaves removed.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YdcDg6AS/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the first tree and <span class="math inline">\(m\)</span> the number of nodes in the second tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>In the <code>findDiameter</code> function, each node is added and removed from the <code>leavesQueue</code> once. Each edge is processed once when updating the degrees of neighboring nodes. Therefore, the time complexity is <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> is the size of the input tree. Consequently, calculating the diameter for both trees takes <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The calculation of the diameter of the combined tree involves only a few constant-time operations, such as adding and comparing values. This step contributes <span class="math inline">\(O(1)\)</span> to the total time complexity, which is still <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Similar to the first approach, all the data structures used (adjacency lists, <code>leavesQueue</code> and,the <code>degrees</code> array), have a linear space complexity in terms of the size of the tree being processed. Therefore, the total space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-minimum-s-t-cut-in-a-flow-network2902/1" target="_blank" rel="noopener noreferrer">Find minimum s-t cut in a flow network</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a weighted graph of <strong>N</strong> vertices numbered from <strong>0</strong>&nbsp;to<strong> N-1</strong> in the form of&nbsp;adjacency matrix <strong>A[ ][ ]</strong> and two&nbsp;integers<strong> S </strong>denoting the number of source vertex and<strong> T</strong> denoting the number of sink vertex. The task is to find minimum capacity s-t cut of the given network.&nbsp;An s-t cut is a cut that requires the source node &lsquo;<strong>S</strong>&rsquo; and the sink node &lsquo;<strong>T</strong>&rsquo; to be in different subsets, and it consists of edges going from the source&rsquo;s side to the sink&rsquo;s side.&nbsp;The capacity of an s-t cut is defined by the sum of the capacity of each edge in the cut-set. In other words,&nbsp;you have to find out all the edges which has to be removed to make it impossible to reach the sink node from source node, and the edges you select should have a&nbsp;minimum sum of weights. You have to return all the edges included in the&nbsp;minimum capacity s-t cut and if there are no edges in&nbsp;minimum capacity s-t cut, return &quot;-1&quot;.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 2
A[][] = [[0, 3],
&nbsp;        [0, 0]]
S = 0
T = 1
<strong>Output:</strong>
0 1
<strong>Explanation: </strong>We have to remove the edge going
from 0<sup>th</sup> vertex to 1<sup>st</sup> vertex.</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 5
A[][] = [[0, 0, 0, 0, 0],
&nbsp;        [0, 0, 2, 3, 0],
&nbsp;        [0, 0, 0, 0, 0],
&nbsp;        [0, 0, 0, 0, 0],
&nbsp;        [0, 0, 0, 0, 0]]
S = 0
T = 4
<strong>Output:</strong>
-1
<strong>Explanation: </strong>There are no edges in 
minimum capacity s-t cut.</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function<strong>&nbsp;minimumCut()</strong>&nbsp;which takes the adjacency matrix <strong>A[ ][ ]</strong>,&nbsp;source node number <strong>S</strong>, sink node number <strong>T</strong> and number of vertices&nbsp;<strong>N</strong>&nbsp;and returns a list of integers <strong>res[ ]</strong> where <strong>res[2*i-1]</strong> and <strong>res[2*i]</strong> denotes an edge in&nbsp;minimum capacity s-t cut where <strong>1 &le; i &le;&nbsp;length(res)/2</strong>, if there are no edges in&nbsp;minimum capacity s-t cut, return only one integer &quot;<strong>-1</strong>&quot; in <strong>res[ ]</strong>.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(max_flow * N<sup>2</sup>)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N<sup>2</sup>)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le;&nbsp;N &le;&nbsp;50<br />
0 &le; S, T&nbsp;&lt;&nbsp;N</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-reach-last-room-i/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Reach Last Room I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a dungeon with <code>n x m</code> rooms arranged as a grid.</p>

<p>You are given a 2D array <code>moveTime</code> of size <code>n x m</code>, where <code>moveTime[i][j]</code> represents the <strong>minimum</strong> time in seconds <strong>after</strong> which the room opens and can be moved to. You start from the room <code>(0, 0)</code> at time <code>t = 0</code> and can move to an <strong>adjacent</strong> room. Moving between adjacent rooms takes <em>exactly</em> one second.</p>

<p>Return the <strong>minimum</strong> time to reach the room <code>(n - 1, m - 1)</code>.</p>

<p>Two rooms are <strong>adjacent</strong> if they share a common wall, either <em>horizontally</em> or <em>vertically</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,4],[4,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 6 seconds.</p>

<ul>
	<li>At time <code>t == 4</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 5</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in one second.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,0,0],[0,0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 3 seconds.</p>

<ul>
	<li>At time <code>t == 0</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 1</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in one second.</li>
	<li>At time <code>t == 2</code>, move from room <code>(1, 1)</code> to room <code>(1, 2)</code> in one second.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == moveTime.length &lt;= 50</code></li>
	<li><code>2 &lt;= m == moveTime[i].length &lt;= 50</code></li>
	<li><code>0 &lt;= moveTime[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-shortest-path--dijkstra">Approach: Shortest Path + Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a two-dimensional array of size <span class="math inline">\(n \times m\)</span>, and the task is to find the shortest time required to move from position <span class="math inline">\((0, 0)\)</span> to position <span class="math inline">\((n - 1, m - 1)\)</span>. While moving, one can go to any of the four adjacent positions (up, down, left, right), and each position has an associated earliest move time, meaning one can only move to that position after that time.</p>
<p>Therefore, the two-dimensional array can be regarded as an undirected graph of size <span class="math inline">\(n \times m\)</span>, where the position <span class="math inline">\((i, j)\)</span> has undirected edges connecting it to <span class="math inline">\((i - 1, j)\)</span>, <span class="math inline">\((i + 1, j)\)</span>, <span class="math inline">\((i, j - 1)\)</span>, and <span class="math inline">\((i, j + 1)\)</span>. We are required to find the shortest path from <span class="math inline">\((0, 0)\)</span> to <span class="math inline">\((n - 1, m - 1)\)</span>.</p>
<p>There are many algorithms for finding the shortest path, and here we choose Dijkstra's algorithm. You can refer to the editorial of <a href="https://leetcode.com/problems/network-delay-time/editorial/">743. Network Delay Time</a> to understand the basic process of Dijkstra's algorithm.</p>
<p>Unlike the standard Dijkstra algorithm, in this problem we define <span class="math inline">\(d[i][j]\)</span> to represent the shortest time required to reach <span class="math inline">\((i, j)\)</span> from <span class="math inline">\((0, 0)\)</span>. The time to move from <span class="math inline">\((i, j)\)</span> to an adjacent coordinate <span class="math inline">\((u, v)\)</span> is given by <span class="math inline">\(\max(d[i][j], \textit{moveTime}[u][v]) + 1\)</span>. The rest of the process is consistent with Dijkstra's algorithm.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3gwDjz6F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in <span class="math inline">\(\textit{moveTime}\)</span>, respectively.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(nm \log(nm))\)</span>.</li>
</ul>
<p>There are <span class="math inline">\(nm\)</span> points and <span class="math inline">\(O(nm)\)</span> edges. We implement Dijkstra's algorithm using a min-heap, performing at most <span class="math inline">\(O(nm)\)</span> insertions and deletions. Each heap operation takes <span class="math inline">\(O(\log(nm))\)</span> time, so the overall time complexity is <span class="math inline">\(O(nm \log(nm))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(nm)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Reach Last Room II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a dungeon with <code>n x m</code> rooms arranged as a grid.</p>

<p>You are given a 2D array <code>moveTime</code> of size <code>n x m</code>, where <code>moveTime[i][j]</code> represents the <strong>minimum</strong> time in seconds when you can <strong>start moving</strong> to that room. You start from the room <code>(0, 0)</code> at time <code>t = 0</code> and can move to an <strong>adjacent</strong> room. Moving between <strong>adjacent</strong> rooms takes one second for one move and two seconds for the next, <strong>alternating</strong> between the two.</p>

<p>Return the <strong>minimum</strong> time to reach the room <code>(n - 1, m - 1)</code>.</p>

<p>Two rooms are <strong>adjacent</strong> if they share a common wall, either <em>horizontally</em> or <em>vertically</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,4],[4,4]]</span></p>

<p><strong>Output:</strong> 7</p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 7 seconds.</p>

<ul>
	<li>At time <code>t == 4</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 5</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,0,0,0],[0,0,0,0]]</span></p>

<p><strong>Output:</strong> 6</p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 6 seconds.</p>

<ul>
	<li>At time <code>t == 0</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 1</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li>
	<li>At time <code>t == 3</code>, move from room <code>(1, 1)</code> to room <code>(1, 2)</code> in one second.</li>
	<li>At time <code>t == 4</code>, move from room <code>(1, 2)</code> to room <code>(1, 3)</code> in two seconds.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> 4</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == moveTime.length &lt;= 750</code></li>
	<li><code>2 &lt;= m == moveTime[i].length &lt;= 750</code></li>
	<li><code>0 &lt;= moveTime[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-shortest-path--dijkstra">Approach: Shortest Path + Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem is an extended version of <a href="https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/description/">3341. Find Minimum Time to Reach Last Room I</a>. The key difference is that the time required for each move alternate: the first move takes 1 second, the second move takes 2 seconds, the third move takes 1 second, and so on.</p>
<p>Since the movement occurs on a two-dimensional grid, each move changes the coordinates <span class="math inline">\((i, j)\)</span> by exactly 1 in one of the four directions. As a result, the parity of <span class="math inline">\((i + j)\)</span> changes with every move. This allows us to determine the move's parity directly based on the current coordinates.</p>
<p>Let <span class="math inline">\(d[i][j]\)</span> represent the shortest time required to reach <span class="math inline">\((i, j)\)</span> from <span class="math inline">\((0, 0)\)</span>. Then, the time to move from <span class="math inline">\((i, j)\)</span> to an adjacent cell <span class="math inline">\((u, v)\)</span> is given by:</p>
<p><span class="math display">\[\max(d[i][j], \textit{moveTime}[u][v]) + (i + j) \bmod 2 + 1.
\]</span></p>
<p>Additionally, since reaching <span class="math inline">\((n - 1, m - 1)\)</span> is guaranteed, we can optimize the algorithm by checking within the main loop whether the current point is <span class="math inline">\((n - 1, m - 1)\)</span>. If it is, we can exit early to avoid unnecessary computations for other cells.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ar24ZbDa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in <span class="math inline">\(\textit{moveTime}\)</span>, respectively.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(nm \log(nm))\)</span>.</li>
</ul>
<p>There are <span class="math inline">\(nm\)</span> points and <span class="math inline">\(O(nm)\)</span> edges. We implement Dijkstra's algorithm using a min-heap, performing at most <span class="math inline">\(O(nm)\)</span> insertions and deletions. Since each heap operation takes <span class="math inline">\(O(\log(nm))\)</span> time, the overall time complexity is <span class="math inline">\(O(nm \log(nm))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(nm)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-number-of-closed-islands/1" target="_blank" rel="noopener noreferrer">Find number of closed islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <a href="https://www.geeksforgeeks.org/program-to-check-if-a-matrix-is-binary-matrix-or-not/">binary matrix</a> <strong>mat[][]</strong> of dimensions <strong>NxM</strong> such that 1 denotes land and <strong>0</strong> denotes water. Find the number of closed islands in the given matrix.<br />An island is a 4-directional(up,right,down and left) connected part of 1's.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> A closed island is a group of <strong>1s</strong> surrounded by only <strong>0s</strong> on all the boundaries <strong>(except diagonals)</strong>. In simple words, a closed island is an island whose none of the <strong>1s</strong> lie on the edges of the matrix.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 5, M = 8
mat[][] =</span> <span style="font-size: 18px;">{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 0, 1},&nbsp;
           {0, 1, 0, 1, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 1, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output:</strong>
2
<strong>Explanation</strong>:
</span><span style="font-size: 18px;">mat[][] =&nbsp;{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, 0, 1},&nbsp;
           {0, <strong>1</strong>, 0, <strong>1</strong>, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, <strong>1</strong>, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}&nbsp;
There are 2 closed islands. The islands in dark are closed because they are completely surrounded by 0s (water). There are two more islands in the last column of the matrix, but they are not completely surrounded by 0s. Hence they are not closed islands. </span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 3, M = 3
mat[][] = {{1, 0, 0},
           {0, 1, 0},
           {0, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output: <br /></strong></span><span style="font-size: 18px;">1<strong><br />Explanation:<br /></strong>mat[][] = {{1, 0, 0},<br />          {0, <strong>1</strong>, 0},<br />          {0, 0, 1}}<br />There is just a one closed island.</span></pre>
<p><span style="font-size: 18px;"><strong>Your task:</strong></span><br /><span style="font-size: 18px;">You dont need to read input or print anything. Your task is to complete the function <strong>closedIslands()</strong>&nbsp;which takes two integers N and M, and a 2D binary matrix mat as input parameters and returns the number of closed islands.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(N*M)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*M)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N,M &le; 500<br /><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-shortest-safe-route-in-a-matrix/1" target="_blank" rel="noopener noreferrer">Find shortest safe route in a matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix <strong>mat[][] with r </strong>rows and <strong>c </strong>columns, where some cells are landmines <strong>(marked as 0)</strong> and others are safe to traverse. Your task is to <strong>find the shortest safe route</strong> from <strong>any cell</strong> in the leftmost column to <strong>any cell</strong> in the rightmost column of the <strong>mat</strong>. <strong>You cannot move diagonally</strong>, and you must <strong>avoid both the landmines</strong> and <strong>their adjacent</strong> cells (up, down, left, right), as they are also <strong>unsafe</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">mat = [1, 0, 1, 1, 1],
      [1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1],
      [1, 1, 1, 0, 1],
      [1, 1, 1, 1, 0]</span>
<strong><span style="font-size: 18px;">Output: <br /></span></strong><span style="font-size: 18px;">6</span>
<strong><span style="font-size: 18px;">Explanation: </span></strong>
<span style="font-size: 18px;">We can see that length of shortest</span>
<span style="font-size: 18px;">safe route is 6</span>
<span style="font-size: 14pt;">[1 0 1 1 1]<br />[1 1 <span style="color: #236fa1;"><strong>1</strong> <strong>1</strong> <strong>1</strong></span>]<span style="color: #236fa1;"><br /></span>[<span style="color: #236fa1;"><strong>1</strong></span> <span style="color: #236fa1;"><strong>1</strong></span> <span style="color: #236fa1;"><strong>1</strong></span> 1 1]
[1 1 1 0 1] 
[1 1 1 1 0]
</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong><span style="font-size: 18px;">
mat = [1, 1, 1, 1, 1],
      [1, 1, 0, 1, 1],
      [1, 1, 1, 1, 1]</span><strong><span style="font-size: 18px;">
Output: <br /></span></strong><span style="font-size: 18px;">-1</span><strong><span style="font-size: 18px;">
Explanation: </span></strong><span style="font-size: 18px;">There is no possible path from
first column to last column.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>findShortestPath()&nbsp;</strong>which takes the matrix as an input parameter and returns an integer denoting the shortest safe path from <strong>any cell</strong> in the leftmost column to <strong>any cell </strong>in the rightmost column of <strong>mat</strong>. If there is no possible path, return <strong>-1</strong>.&nbsp;<br /></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(r * c)<br /><strong>Expected Auxiliary Space:</strong> O(</span><span style="font-size: 18px;">r * c</span><span style="font-size: 18px;">)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= r, c &lt;= 10</span><sup><span style="font-size: 15px;">3<br />0 &lt;= mat[][] &lt;= 1</span></sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description" target="_blank" rel="noopener noreferrer">Find the City With the Smallest Number of Neighbors at a Threshold Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities numbered from <code>0</code> to <code>n-1</code>. Given the array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> represents a bidirectional and weighted edge between cities <code>from<sub>i</sub></code> and <code>to<sub>i</sub></code>, and given the integer <code>distanceThreshold</code>.</p>

<p>Return the city with the smallest number of cities that are reachable through some path and whose distance is <strong>at most</strong> <code>distanceThreshold</code>, If there are multiple such cities, return the city with the greatest number.</p>

<p>Notice that the distance of a path connecting cities <em><strong>i</strong></em> and <em><strong>j</strong></em> is equal to the sum of the edges&#39; weights along that path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/23/problem1334example1.png" style="width: 300px; height: 224px;" /></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
<strong>Output:</strong> 3
<strong>Explanation: </strong>The figure above describes the graph.&nbsp;
The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -&gt; [City 1, City 2]&nbsp;
City 1 -&gt; [City 0, City 2, City 3]&nbsp;
City 2 -&gt; [City 0, City 1, City 3]&nbsp;
City 3 -&gt; [City 1, City 2]&nbsp;
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/23/problem1334example0.png" style="width: 300px; height: 224px;" /></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
<strong>Output:</strong> 0
<strong>Explanation: </strong>The figure above describes the graph.&nbsp;
The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -&gt; [City 1]&nbsp;
City 1 -&gt; [City 0, City 4]&nbsp;
City 2 -&gt; [City 3, City 4]&nbsp;
City 3 -&gt; [City 2, City 4]
City 4 -&gt; [City 1, City 2, City 3]&nbsp;
The city 0 has 1 neighboring city at a distanceThreshold = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= weight<sub>i</sub>,&nbsp;distanceThreshold &lt;= 10^4</code></li>
	<li>All pairs <code>(from<sub>i</sub>, to<sub>i</sub>)</code> are distinct.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Imagine we're city planners analyzing the connectivity of cities in a region. We have:</p>
<ol>
<li>A network of <code>n</code> cities, numbered from <code>0</code> to <code>n-1</code>.</li>
<li>A list of roads (edges) connecting these cities, with each road having a certain length (weight).</li>
<li>A maximum travel distance (<code>distanceThreshold</code>) we're willing to consider.</li>
</ol>
<p>Our goal is to find the most isolated city — the one that can reach the fewest other cities within the <code>distanceThreshold</code>. If there's a tie, we choose the city with the highest number.</p>
<p>This is a graph problem where we calculate the reachability of each city within the given distance constraint and then select the optimal city accordingly.</p>
<p>In this article, we'll cover applications of four different graph algorithms to provide a comprehensive guide on the main traversal techniques used in <a href="https://leetcode.com/explore/featured/card/graph/">graphs for finding the shortest path</a>. If you are completely unaware of these algorithms, it is recommended to check them out first. Users can treat this as a template and refer back whenever they need clarification on shortest path algorithms. We will maintain a consistent main function throughout the article, changing only the specific algorithm logic. This article will help keep the focus on the dynamic parts that vary according to different algorithms, without overwhelming you with a wall of text.</p>
<p>The four algorithms we'll discuss are:</p>
<ol>
<li>Dijkstra's Algorithm</li>
<li>Bellman-Ford Algorithm</li>
<li>Shortest Path First Algorithm (SPFA)</li>
<li>Floyd-Warshall Algorithm</li>
</ol>
<hr />
<h3 id="approach-1-dijkstra-algorithm">Approach 1: Dijkstra Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>Dijkstra's algorithm is a graph search algorithm that finds the shortest paths between nodes in a graph. It is particularly effective for finding the shortest path from a single source node to all other nodes in graphs with non-negative edge weights.</p>
<p>The algorithm uses a greedy strategy, maintaining a set of vertices whose shortest distance from the source is known. At each step, it selects the vertex with the minimum distance value from the set of unvisited vertices.</p>
<p>We initialize distances to all vertices as infinity, except for the source vertex, which is set to zero. A priority queue is used to efficiently select the vertex with the minimum distance in each iteration, ensuring that the most promising paths are processed first and saving unnecessary computations.</p>
<p>For each neighbor of the current vertex, we calculate the distance through the current vertex. If this calculated distance is less than the previously known distance to that neighbor, the distance is updated — a process known as relaxation. Dijkstra's algorithm performs relaxation efficiently by always processing the most promising vertex next.</p>
<p>After computing all shortest paths, we count reachable cities and select the most isolated ones.</p>
<p>In summary, the algorithm involves three main steps:</p>
<ol>
<li>
<p><strong>Initialization:</strong> Set the distance to the source city as zero and all others as infinity. Use a priority queue to process cities based on their shortest distance.</p>
</li>
<li>
<p><strong>Relaxation:</strong> Extract the city with the smallest distance from the priority queue. Update the distances to their neighboring cities, adding them back to the queue if their distances are updated.</p>
</li>
<li>
<p><strong>Result Computation:</strong> Compute the shortest paths from each city. Count the number of reachable cities within the distance threshold. Choose the city with the fewest reachable cities or, in case of ties, the city with the greatest number.</p>
</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create an adjacency list <code>adjacencyList</code> to store the graph.</p>
</li>
<li>
<p>Create a 2D array <code>shortestPathMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Set all distances in <code>shortestPathMatrix[i]</code> to the maximum integer value.</li>
<li>Set the distance from the city <code>i</code> to itself (<code>shortestPathMatrix[i][i]</code>) to <code>0</code>.</li>
<li>Initialize <code>adjacencyList[i]</code> as an empty list.</li>
</ul>
</li>
<li>
<p>Iterate through each edge in <code>edges</code>:</p>
<ul>
<li>Extract <code>start</code>, <code>end</code>, and <code>weight</code> from each edge.</li>
<li>Add <code>(end, weight)</code> to <code>adjacencyList[start]</code>.</li>
<li>Add <code>(start, weight)</code> to <code>adjacencyList[end]</code>.</li>
</ul>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Call <code>dijkstra(n, adjacencyList, shortestPathMatrix[i], i)</code>, where <code>i</code> is the source city and <code>shortestPathMatrix[i]</code> is the array that will hold the shortest path distances from city <code>i</code>.</li>
</ul>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>dijkstra(n, adjacencyList, shortestPathDistances, source)</code> Function:</strong></p>
<ul>
<li>
<p>Use a priority queue to process nodes with the smallest distance first:</p>
<ul>
<li>Initialize the priority queue with the <code>source</code> city.</li>
<li>Set all distances in <code>shortestPathDistances</code> to <code>Integer.MAX_VALUE</code>.</li>
<li>Set the distance to the <code>source</code> city itself (<code>shortestPathDistances[source]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Process nodes in priority order:</p>
<ul>
<li>For each node, update distances to neighboring cities if a shorter path is found.</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from the city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1334/approach1.json:975,490!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/We2utpec/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3 \log n)\)</span></p>
<p>For one source, Dijkstra's algorithm using a priority queue runs in <span class="math inline">\(O(m \cdot \log n)\)</span>. With the maximum number of edges <code>m</code>, this becomes <span class="math inline">\(O(n \cdot (n - 1) / 2 \cdot \log n) = O(n^2 \log n)\)</span>. Running Dijkstra's algorithm for each city (source), the overall time complexity is <span class="math inline">\(O(n \cdot n^2 \log n) = O(n^3 \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n^2)\)</span> for the <code>shortestPathMatrix</code> and <span class="math inline">\(O(m + n)\)</span> for the adjacency list and auxiliary data structures. Since <span class="math inline">\(m = O(n^2)\)</span> in the worst case, the overall space complexity simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bellman-ford-algorithm">Approach 2: Bellman-Ford Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The Bellman-Ford algorithm is a graph search algorithm that finds the shortest paths from a single source vertex to all other vertices in a weighted graph. Unlike Dijkstra's algorithm, Bellman-Ford can handle graphs with negative edge weights, making it more versatile but potentially slower.</p>
<p>We start by initializing distances to all vertices as infinity, except the source vertex, which is set to zero. This initialization represents our initial state of knowledge - we don't know any paths yet, so we assume they're infinitely long, except for the trivial path from a vertex to itself.</p>
<p>Next, we perform the key operation, relaxation. For each edge in the graph, we check if the distance to the destination vertex can be improved by going through the source vertex of that edge. We repeat this relaxation step for V-1 times, where V is the number of vertices. In the worst case, where vertices form a line, it might take V-1 steps for changes to propagate from one end to the other.</p>
<p>In our implementation, we apply Bellman-Ford from each city as a source, giving us the shortest paths from every city to every other city. We could have used a single source and run Bellman-Ford once, then repeated for other sources, but running it independently for each source simplifies our code structure.</p>
<p>After computing all shortest paths, we count how many cities are reachable from each city within the distance threshold, and then select the city that can reach the fewest others, breaking ties by choosing the higher-numbered city.</p>
<p>This approach guarantees correctness even with negative edge weights (though we don't have those here). Its simplicity makes Bellman-Ford a good algorithm, even if it's not the most efficient for our specific problem. We don't need to implement cycle detection or early termination, keeping our code straightforward at the cost of potentially unnecessary computations.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Create a 2D array <code>shortestPathMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Call <code>bellmanFord(n, edges, shortestPathMatrix[i], i)</code>, where <code>i</code> is the source city and <code>shortestPathMatrix[i]</code> is the array that will hold the shortest path distances from the city <code>i</code>.</li>
</ul>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>bellmanFord(n, edges, shortestPathDistances, source)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize the distances from the <code>source</code> city:</p>
<ul>
<li>Set all distances in <code>shortestPathDistances</code> (initially set to <code>Integer.MAX_VALUE</code>, which represents <code>INF</code>) to a large value, indicating that the shortest distance is unknown at the start.</li>
<li>Set the distance to the <code>source</code> city itself (<code>shortestPathDistances[source]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Relax edges up to <code>n-1</code> times:</p>
<ul>
<li>Iterate through all edges in <code>edges</code>:
<ul>
<li>For each edge, extract <code>start</code>, <code>end</code>, and <code>weight</code>.</li>
<li>Update the shortest path distances if a shorter path is found. Specifically:
<ul>
<li>If the distance from <code>start</code> to <code>end</code> can be reduced by taking the current edge, update <code>shortestPathDistances[end]</code>.</li>
<li>Similarly, update <code>shortestPathDistances[start]</code> if a shorter path is found through the <code>end</code> city.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p>Note: We have introduced an <code>updated</code> flag to break out of the loop early (relaxation of edges) if no updates are made in an iteration. This optimization can reduce the number of iterations in some cases, addressing the Time Limit Exceeded (TLE) issues that occur when the algorithm is run without this adjustment in Python implementations. For those implementing this algorithm in C++ or Java, refer to the Python code to see how this simple <code>updated</code> flag has been integrated.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/gTrh989H/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^4)\)</span></p>
<p>For one source, Bellman-Ford runs in <span class="math inline">\(O(n \cdot m)\)</span>, where <code>m</code> is the number of edges. In the worst case, <code>m</code> is <span class="math inline">\(n \cdot (n - 1) / 2\)</span> (checkout the constraints), so the time complexity for one source becomes <span class="math inline">\(O(n \cdot (n \cdot (n - 1) / 2)) = O(n^3)\)</span>. Since Bellman-Ford must be run for each city (source), the overall time complexity is <span class="math inline">\(O(n \cdot n^3) = O(n^4)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is dominated by the <code>shortestPathMatrix</code>, which stores the shortest path distances between each pair of cities. This matrix requires <span class="math inline">\(O(n^2)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-shortest-path-first-algorithm-spfa">Approach 3: Shortest Path First Algorithm (SPFA)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman-Ford algorithm, designed to work faster on average, especially for sparse graphs, while still handling negative edge weights.</p>
<p>SPFA starts similarly to Bellman-Ford by initializing all distances to infinity except for the source vertex. However, instead of blindly relaxing all edges in each iteration, SPFA uses a queue to keep track of which vertices need to be processed. We begin by adding the source vertex to the queue, then enter a loop that continues as long as the queue is not empty. In each iteration, we remove a vertex from the queue and relax its outgoing edges. If relaxing an edge updates the distance to a neighbor, we add that neighbor to the queue if it's not already there.</p>
<p>This queue-based approach allows SPFA to focus on the parts of the graph where improvements are still possible, potentially skipping large portions of the graph that won't lead to better paths. This targeted processing often makes SPFA faster than Bellman-Ford in practice.</p>
<p>Our implementation includes a cycle detection mechanism. We keep track of how many times each vertex has been processed. If any vertex is processed more than V times (where V is the number of vertices), it indicates a negative weight cycle. While not strictly necessary for our problem (as we're guaranteed no negative weights), this showcases SPFA's ability to handle more general graphs and could be useful if the algorithm is repurposed for other problems.</p>
<p>Like in previous approaches, we run SPFA from each city as a source to build our complete shortest path matrix. After computing all shortest paths, we perform the same counting and selection process to find the most isolated city.</p>
<p>SPFA offers a middle ground between Bellman-Ford and Dijkstra's algorithm. It can handle negative edge weights like Bellman-Ford, but it's often much faster in practice, sometimes approaching the efficiency of Dijkstra's algorithm. It allows for more efficient processing, especially in graphs where only a few edges contribute to the shortest paths. However, it's worth noting that SPFA's worst-case time complexity is still O(VE) like Bellman-Ford, so it's not guaranteed to be faster in all cases.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Create an adjacency list <code>adjacencyList</code> to store the graph.</p>
</li>
<li>
<p>Create a 2D array <code>shortestPathMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Set all distances in <code>shortestPathMatrix[i]</code> to <code>Integer.MAX_VALUE</code>.</li>
<li>Set the distance from city <code>i</code> to itself (<code>shortestPathMatrix[i][i]</code>) to <code>0</code>.</li>
<li>Initialize <code>adjacencyList[i]</code> as an empty list.</li>
</ul>
</li>
<li>
<p>Iterate through each edge in <code>edges</code>:</p>
<ul>
<li>Extract <code>start</code>, <code>end</code>, and <code>weight</code> from each edge.</li>
<li>Add <code>(end, weight)</code> to <code>adjacencyList[start]</code>.</li>
<li>Add <code>(start, weight)</code> to <code>adjacencyList[end]</code>.</li>
</ul>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Call <code>spfa(n, adjacencyList, shortestPathMatrix[i], i)</code>, where <code>i</code> is the source city and <code>shortestPathMatrix[i]</code> is the array that will hold the shortest path distances from city <code>i</code>.</li>
</ul>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>spfa(n, adjacencyList, shortestPathDistances, source)</code> Function:</strong></p>
<ul>
<li>
<p>Use a queue to process nodes with updated shortest path distances:</p>
<ul>
<li>Initialize the queue with the <code>source</code> city.</li>
<li>Set all distances in <code>shortestPathDistances</code> to <code>Integer.MAX_VALUE</code>.</li>
<li>Set the distance to the <code>source</code> city itself (<code>shortestPathDistances[source]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Process nodes in queue:</p>
<ul>
<li>For each node, update distances to neighboring cities if a shorter path is found.</li>
<li>Track the number of updates for each node.</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/Wc3cKduH/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^4)\)</span></p>
<p>The average time complexity of SPFA is <span class="math inline">\(Θ(m)\)</span> per source, which is <span class="math inline">\(Θ(n^2)\)</span> in the worst case per source. Running SPFA for each city (source), the overall average time complexity is <span class="math inline">\(Θ(n \cdot m) = Θ(n \cdot n^2) = Θ(n^3)\)</span>, and the worst-case time complexity is <span class="math inline">\(O(n \cdot n^3) = O(n^4)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n^2)\)</span> for the <code>shortestPathMatrix</code> and <span class="math inline">\(O(m + n)\)</span> for the adjacency list and auxiliary data structures. Since <span class="math inline">\(m = O(n^2)\)</span> in the worst case, the overall space complexity simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-floyd-warshall-algorithm">Approach 4: Floyd-Warshall Algorithm</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The Floyd-Warshall algorithm finds the shortest paths in a weighted graph with positive or negative edge weights, as long as there are no negative cycles. Unlike algorithms that compute shortest paths from a single source, Floyd-Warshall computes the shortest paths between all pairs of vertices in the graph.</p>
<p>This algorithm takes a fundamentally different approach by computing all-pairs shortest paths in one go, rather than separately for each source. We start by initializing a distance matrix where direct connections between cities are filled with their edge weights, and all other distances are set to infinity. The distance from a city to itself is set to zero. This matrix serves both as our working space and our final result.</p>
<p>The core of the our algorithm involves three nested loops. The outermost loop iterates through all vertices, considering each as a potential intermediate point on the shortest path between every other pair of vertices. For each pair of vertices <code>(i, j)</code>, we check if passing through the current intermediate vertex <code>k</code> offers a shorter path than we currently know. If it does, we update the distance.</p>
<p>This iterative process gradually refines our shortest paths. By the time all vertices have been considered as intermediates, we have determined all shortest paths. After running Floyd-Warshall, our distance matrix contains all the information needed. We can directly count reachable cities for each source and select our answer, similar to previous approaches.</p>
<p>Floyd-Warshall has several advantages: it solves the all-pairs shortest path problem directly with a simple and elegant one-pass implementation. For dense graphs, its time complexity of O(V^3) can be more efficient than running algorithms like Dijkstra’s or SPFA multiple times. However, for sparse graphs or when only a few sources are involved, other algorithms might be more efficient.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Define <code>INF</code> as a large constant value (e.g., <code>1e9 + 7</code>) to represent an infinite distance for initial comparisons.</p>
</li>
<li>
<p>Create a 2D array <code>distanceMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Set all distances in <code>distanceMatrix[i]</code> to <code>INF</code>.</li>
<li>Set the distance from city <code>i</code> to itself (<code>distanceMatrix[i][i]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Iterate through each edge in <code>edges</code>:</p>
<ul>
<li>Extract <code>start</code>, <code>end</code>, and <code>weight</code> from each edge.</li>
<li>Update <code>distanceMatrix[start][end]</code> and <code>distanceMatrix[end][start]</code> with <code>weight</code>.</li>
</ul>
</li>
<li>
<p>Call <code>floyd(n, distanceMatrix)</code> to compute shortest paths between all pairs of cities.</p>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, distanceMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>floyd(n, distanceMatrix)</code> Function:</strong></p>
<ul>
<li>
<p>Use three nested loops to update the <code>distanceMatrix</code>:</p>
<ul>
<li>Outer Loop: Iterate over each intermediate city <code>k</code>.</li>
<li>Middle Loop: Iterate over each source city <code>i</code>.</li>
<li>Inner Loop: Iterate over each destination city <code>j</code>.</li>
</ul>
</li>
<li>
<p>For each combination of cities <code>(i, j)</code> and intermediate city <code>k</code>, update the distance if a shorter path is found through <code>k</code>:</p>
<ul>
<li>Condition: If <code>distanceMatrix[i][j] &gt; distanceMatrix[i][k] + distanceMatrix[k][j]</code>, then update:
<ul>
<li>Update: <code>distanceMatrix[i][j] = distanceMatrix[i][k] + distanceMatrix[k][j]</code></li>
<li>Explanation: This means that if the path from city <code>i</code> to city <code>j</code> is longer than the path from city <code>i</code> to city <code>k</code> plus the path from city <code>k</code> to city <code>j</code>, update the shortest distance from <code>i</code> to <code>j</code> to be the sum of distances <code>i</code> to <code>k</code> and <code>k</code> to <code>j</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from the city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1334/approach4_re.json:980,485!?!</p>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/nbkKWfMR/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3)\)</span></p>
<p>The Floyd-Warshall algorithm directly computes the shortest paths between all pairs of cities in <span class="math inline">\(O(n^3)\)</span>, regardless of the number of edges. This comes from the three nested loops, each iterating <code>n</code> times.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is dominated by the <code>distanceMatrix</code>, which requires <span class="math inline">\(O(n^2)\)</span> space to store the shortest path distances between each pair of cities.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-maximum-flow2126/1" target="_blank" rel="noopener noreferrer">Find the Maximum Flow</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a graph&nbsp;which represents a flow network</span>&nbsp;<span style="font-size:18px">with N vertices numbered 1 to N and M edges.Find the maximum flow from vertex numbered 1 to vertex numbered N.</span></p>

<p><span style="font-size:18px">In a flow network,every edge has a flow&nbsp;capacity&nbsp;and the maximum flow of a path can&#39;t exceed the flow-capacity of an edge in the path.<br />
<br />
<strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 5, M =  4
Edges[]= {{1,2,1},{3,2,2},{4,2,3},{2,5,5}}
<strong>Output: </strong>1 
<strong>Explanation: </strong>
1 - 2 - 3
   / \
  4   5 
1 unit can flow from 1 -&gt; 2 - &gt;5 </span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 4, M = 4
Edges[] = {{1,2,8},{1,3,10},{4,2,2},{3,4,3}}
<strong>Output: </strong>5 
<strong>Explanation:</strong>
  1 - 2 
  |   |
  3 - 4
3 unit can flow from 1 -&gt; 3 -&gt; 4
2 unit can flow from 1 -&gt; 2 -&gt; 4
Total max flow from 1 to N = 3+2=5</span></pre>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function<strong>&nbsp;solve()</strong>&nbsp;which takes the <strong>N&nbsp;</strong>(the number of vertices) ,<strong>M </strong>(the number of Edges) and the array <strong>Edges</strong>[]&nbsp;(Where Edges[i]&nbsp;denoting an undirected edge between&nbsp;Edges[i][0] and&nbsp;Edges[i][1]&nbsp;with a flow capacity of Edges[i][2]),&nbsp;and returns the&nbsp;integer&nbsp;denoting the maximum flow from 1 to N.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(max_flow*M)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N+M)</span></p>

<p><span style="font-size:18px">Where max_flow is the maximum flow from&nbsp;1 to N</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N,M,Edges[i][2] &lt;= 1000</span><br />
<span style="font-size:18px">1 &lt;= Edges[i][0],Edges[i][1] &lt;= N</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-number-of-islands/1" target="_blank" rel="noopener noreferrer">Find the number of islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a grid of size <strong>n*m</strong> (n is the number of rows and m is the number of columns in the grid) consisting of <strong>'W'</strong>s (Water) and <strong>'L'</strong>s (Land). Find the <strong>number of islands</strong>.</span><br /><br /><span style="font-size: 14pt;"><strong>Note:&nbsp;</strong>An island is either surrounded by water or the boundary of a grid and is formed by connecting adjacent lands <strong>horizontally </strong>or<strong> vertically</strong> or <strong>diagonally</strong> i.e., in all <strong>8</strong> directions.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>grid[][] = [['L', 'L', 'W', 'W', 'W'], ['W', 'L', 'W', 'W', 'L'], ['L', 'W', 'W', 'L', 'L'], ['W', 'W', 'W', 'W', 'W'], ['L', 'W', 'L', 'L', 'W']]
<strong>Output: </strong>4
<strong>Explanation:
</strong>The image below shows all the 4 islands in the grid.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/891756/Web/Other/blobid1_1743509451.jpg" width="186" height="183" /> </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>grid[][] = [['W', 'L', 'L', 'L', 'W', 'W', 'W'], ['W', 'W', 'L', 'L', 'W', 'L', 'W']]
<strong>Output: </strong>2
<strong>Expanation:
</strong>The image below shows 2 islands in the grid.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/891756/Web/Other/blobid2_1743509488.jpg" height="100" /> </span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, m &le; 500<br /><span style="background-color: #ffffff; font-family: Arial; white-space-collapse: preserve;">grid[i][j] = {'L'</span>, 'W'}</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-string/1" target="_blank" rel="noopener noreferrer">Find the String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two integers<strong> N</strong> and <strong>K, </strong>the task is to find the string <strong>S</strong> of <strong>minimum </strong>length such that it contains <strong>all possible strings </strong>of size <strong>N</strong> as a <strong>substring</strong>. The characters of the string should be from integers ranging from <strong>0 to K-1</strong>.&nbsp;&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 2, K = 2
<strong>Output:</strong> 
00110
<strong>Explanation: 
</strong>Allowed characters are from 0 to k-1 (i.e., 0 and 1).<br /></span><span style="font-size: 18px;">There are 4 string possible of size N=2 
(i.e "00", "01","10","11")
"00110" contains all possible string as a 
substring. It also has the minimum length.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 2, K = 3
<strong>Output: 
</strong>0010211220
<strong>Explanation: <br /></strong></span><span style="font-size: 18px;">Allowed characters are from 0 to k-1 (i.e., 0, 1 and 2).<strong><br /></strong>There are total 9 strings possible
of size N, given output string has the minimum
length that contains all those strings as substring.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;</strong><br />You don't need to read input or print anything. Complete the function<strong>&nbsp;findString( )</strong>&nbsp;which takes the integer <strong>N</strong> and the integer <strong>K</strong>&nbsp;as input parameters and returns the string.<br /><strong>Note:</strong> In case of multiple answers, return <strong>any string of minimum length </strong>which satisfies above condition. The driver will print the <strong>length</strong> of the&nbsp;string. In case of wrong answer it will print <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(K<sup>N</sup>K)<br /><strong>Expected Space Complexity: </strong>O(K<sup>N</sup>N)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N&nbsp;&le; 4<br />1 <u>&lt;</u> K <u>&lt;</u> 10<br />1&nbsp;<u>&lt;</u> K<sup>N</sup>N &lt; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-town-judge/description" target="_blank" rel="noopener noreferrer">Find the Town Judge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a town, there are <code>n</code> people labeled from <code>1</code> to <code>n</code>. There is a rumor that one of these people is secretly the town judge.</p>

<p>If the town judge exists, then:</p>

<ol>
	<li>The town judge trusts nobody.</li>
	<li>Everybody (except for the town judge) trusts the town judge.</li>
	<li>There is exactly one person that satisfies properties <strong>1</strong> and <strong>2</strong>.</li>
</ol>

<p>You are given an array <code>trust</code> where <code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> representing that the person labeled <code>a<sub>i</sub></code> trusts the person labeled <code>b<sub>i</sub></code>. If a trust relationship does not exist in <code>trust</code> array, then such a trust relationship does not exist.</p>

<p>Return <em>the label of the town judge if the town judge exists and can be identified, or return </em><code>-1</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2, trust = [[1,2]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, trust = [[1,3],[2,3]]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3, trust = [[1,3],[2,3],[3,1]]
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= trust.length &lt;= 10<sup>4</sup></code></li>
	<li><code>trust[i].length == 2</code></li>
	<li>All the pairs of <code>trust</code> are <strong>unique</strong>.</li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-whether-path-exist5238/1" target="_blank" rel="noopener noreferrer">Find whether path exist</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a grid of size <strong>n</strong>*<strong>n</strong>&nbsp;filled with 0, 1, 2, 3. Check whether there is a path possible from the source to destination.&nbsp;You can traverse up, down, right and left.<br />The description of cells is as follows:</span></p>
<ul>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>1</strong>&nbsp;means Source.</span></li>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>2</strong>&nbsp;means Destination.</span></li>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>3</strong>&nbsp;means Blank cell.</span></li>
<li><span style="font-size: 18px;">A value of cell <strong>0&nbsp;</strong>means Wall (blocked cell which we cannot traverse).</span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Note</strong>: There are only a single source and a single destination.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{3,0,3,0,0},{3,0,0,0,3},{3,3,3,3,3},{0,2,3,0,0},{3,0,0,1,3}}
<strong>Output: </strong>0
<strong>Explanation: </strong>The grid is-
3 0 3 0 0&nbsp;
3 0 0 0 3&nbsp;
3 3 3 3 3&nbsp;
0 2 3 0 0&nbsp;
3 0 0 1 3&nbsp;
There is no path to reach at (3,1) i,e at destination from (4,3) i,e source.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{1,3},{3,2}}
<strong>Output: </strong>1
<strong>Explanation: </strong>The grid is-
<span style="color: #000000;">1 3
3 2
</span>There is a path from (0,0) i,e source to (1,1) i,e destination.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(n<sup>2</sup>)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/flood-fill-algorithm1856/1" target="_blank" rel="noopener noreferrer">Flood fill Algorithm</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a 2D grid <strong>image[][] </strong>of size n*m, where each <strong>image[i][j]</strong> represents the color of a pixel in the image. Also provided a coordinate<strong>(sr, sc) </strong>representing the <strong>starting pixel</strong> (row and column) and a <strong>new color</strong> value <strong>newColor</strong>.</span></p>
<p><span style="font-size: 14pt;">Your task is to perform a <strong>flood fill</strong> starting from the pixel <strong>(sr, sc)</strong>, changing its color to <strong>newColor</strong> and the color of all the connected pixels that have the same <strong>original color</strong>. Two pixels are considered connected if they are adjacent <strong>horizontally or vertically</strong> (not diagonally) and have the <strong>same original color</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong style="font-size: 18.6667px;">Input: </strong><span style="font-size: 18.6667px;">image[][] = [[1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1]], sr = 1, sc = 2, newColor = 2<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/705720/Web/Other/blobid0_1744378665.jpg" width="258" height="228" /><br /><strong>Output:</strong> [[2, 2, 2, 0], [0, 2, 2, 2], [1, 0, 2, 2]]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/705720/Web/Other/blobid1_1744378699.jpg" width="253" height="224" /><br /><strong>Explanation:</strong> Starting from pixel (1, 2) with value 1, flood fill updates all connected pixels (up, down, left, right) with value 1 to 2, resulting in [[2, 2, 2, 0], [0, 2, 2, 2], [1, 0, 2, 2]].</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>image[][] = [[1, 1, 1], [1, 1, 0], [1, 0, 1]], sr = 1, sc = 1, newColor = 2
<strong>Output: </strong>[[2, 2, 2], [2, 2, 0], [2, 0, 1]]
<strong>Explanation: </strong>From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>image[][] = [[0, 1, 0], [0, 1, 0]], sr = 0, sc = 1, newColor = 0
<strong>Output: </strong>[[0, 0, 0], [0, 0, 0]]
<strong>Explanation: </strong>Starting from pixel (0, 1) with value 1, flood fill changes all 4-directionally connected pixels with value 1 to 0, resulting in [[0, 0, 0], [0, 0, 0]]</span><span style="font-size: 14pt;"><br /></span></pre>
<div><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n &le; m &le; 500<br />0 &le; image[i][j] &le; 10</span></div>
<div><span style="font-size: 14pt;">0 &le; newColor &le; 10</span></div>
<div><span style="font-size: 14pt;">0 &le; sr &le; (n-1)</span></div>
<div><span style="font-size: 14pt;">0 &le; sc &le; (m-1)</span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flower-planting-with-no-adjacent/description" target="_blank" rel="noopener noreferrer">Flower Planting With No Adjacent</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> gardens, labeled from <code>1</code> to <code>n</code>, and an array <code>paths</code> where <code>paths[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> describes a bidirectional path between garden <code>x<sub>i</sub></code> to garden <code>y<sub>i</sub></code>. In each garden, you want to plant one of 4 types of flowers.</p>

<p>All gardens have <strong>at most 3</strong> paths coming into or leaving it.</p>

<p>Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.</p>

<p>Return <em><strong>any</strong> such a choice as an array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the type of flower planted in the </em><code>(i+1)<sup>th</sup></code><em> garden. The flower types are denoted </em><code>1</code><em>, </em><code>2</code><em>, </em><code>3</code><em>, or </em><code>4</code><em>. It is guaranteed an answer exists.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, paths = [[1,2],[2,3],[3,1]]
<strong>Output:</strong> [1,2,3]
<strong>Explanation:</strong>
Gardens 1 and 2 have different types.
Gardens 2 and 3 have different types.
Gardens 3 and 1 have different types.
Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, paths = [[1,2],[3,4]]
<strong>Output:</strong> [1,2,1,2]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
<strong>Output:</strong> [1,2,3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>paths[i].length == 2</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li>Every garden has <strong>at most 3</strong> paths coming into or leaving it.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/implementing-floyd-warshall2042/1" target="_blank" rel="noopener noreferrer">Floyd Warshall</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an weighted<strong> directed</strong> graph, represented by an adjacency matrix, <strong>dist[][] </strong>of size <strong>n x n</strong>, where <strong>dist[i][j] </strong>represents the weight of the edge from <strong>node i to node j</strong>.&nbsp;If there is no direct edge, <strong>dist[i][j] </strong>is set to a large value (i.e., <strong>10<sup>8</sup></strong>) to represent infinity.</span><br /><span style="font-size: 14pt;">The graph may contain <strong>negative edge weights</strong>, but it does not contain any <strong>negative weight cycles</strong>.</span></p>
<p><span style="font-size: 14pt;">Your task is to find the <strong>shortest distance</strong> between every pair of nodes <strong>i </strong>and<strong> j</strong> in the graph.</span></p>
<p><span style="font-size: 14pt;">Note: Modify the distances for every pair <strong>in place</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>dist[][] = [[0, 4, 10<sup>8</sup>, 5, 10<sup>8</sup>], [10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>, 0, 1, 10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>, 6], [2, 10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>, 0, 3, 10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>], [10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>, 10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>, 1, 0, 2], [1, 10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>, 10<sup style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">8</sup>, 4, 0]]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893245/Web/Other/blobid0_1744701272.jpg" width="311" height="270" /><br /><strong>Output: </strong>[[0, 4, 5, 5, 7], [3, 0, 1, 4, 6], [2, 6, 0, 3, 5], [3, 7, 1, 0, 2], [1, 5, 5, 4, 0]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893245/Web/Other/blobid1_1744701370.jpg" width="308" height="324" /><br /><strong>Explanation: </strong>Each cell dist[i][j] in the output shows the shortest distance from node i to node j, computed by considering all possible intermediate nodes. 
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>dist[][] = [[0, -1, 2], [1, 0, 10<sup>8</sup>], [3, 1, 0]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893245/Web/Other/blobid2_1744701698.jpg" width="221" height="230" /><br /><strong>Output: </strong>[[0, -1, 2], [1, 0, 3], [2, 1, 0]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893245/Web/Other/blobid3_1744701713.jpg" width="218" height="229" /><br /><strong>Explanation: </strong>Each cell dist[i][j] in the output shows the shortest distance from node i to node j, computed by considering all possible intermediate nodes.<br />From 2 to 0 shortest distance should be 2 by following path 2 -&gt; 1 -&gt; 0</span><br /><span style="font-size: 14pt;">From 1 to 2 shortest distance should be 3 by following path 1 -&gt; 0 -&gt; 2</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; dist.size() &le; 100<br />-1000 &le; dist[i][j] &le; 1000<br />dist[i][j] can be&nbsp;</span><strong style="font-size: 18.6667px;">10<sup>8</sup></strong><span style="font-size: 18.6667px;">&nbsp;to represent infinity.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/frequencies-of-shortest-supersequences/description" target="_blank" rel="noopener noreferrer">Frequencies of Shortest Supersequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code>. Find all <strong>shortest common supersequences (SCS)</strong> of <code><font face="monospace">words</font></code> that are not <span data-keyword="permutation-string">permutations</span> of each other.</p>

<p>A <strong>shortest common supersequence</strong> is a string of <strong>minimum</strong> length that contains each string in <code>words</code> as a <span data-keyword="subsequence-string-nonempty">subsequence</span>.</p>

<p>Return a 2D array of integers <code>freqs</code> that represent all the SCSs. Each <code>freqs[i]</code> is an array of size 26, representing the frequency of each letter in the lowercase English alphabet for a single SCS. You may return the frequency arrays in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;ab&quot;,&quot;ba&quot;]</span></p>

<p><strong>Output: </strong>[[1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]</p>

<p><strong>Explanation:</strong></p>

<p>The two SCSs are <code>&quot;aba&quot;</code> and <code>&quot;bab&quot;</code>. The output is the letter frequencies for each one.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;aa&quot;,&quot;ac&quot;]</span></p>

<p><strong>Output: </strong>[[2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]</p>

<p><strong>Explanation:</strong></p>

<p>The two SCSs are <code>&quot;aac&quot;</code> and <code>&quot;aca&quot;</code>. Since they are permutations of each other, keep only <code>&quot;aac&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = </span>[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</p>

<p><strong>Output: </strong>[[2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]</p>

<p><strong>Explanation:</strong></p>

<p><code>&quot;aabbcc&quot;</code> and all its permutations are SCSs.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 256</code></li>
	<li><code>words[i].length == 2</code></li>
	<li>All strings in <code>words</code> will altogether be composed of no more than 16 unique lowercase letters.</li>
	<li>All strings in <code>words</code> are unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/frog-position-after-t-seconds/description" target="_blank" rel="noopener noreferrer">Frog Position After T Seconds</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an undirected tree consisting of <code>n</code> vertices numbered from <code>1</code> to <code>n</code>. A frog starts jumping from <strong>vertex 1</strong>. In one second, the frog jumps from its current vertex to another <strong>unvisited</strong> vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.</p>

<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p><em>Return the probability that after <code>t</code> seconds the frog is on the vertex <code>target</code>. </em>Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg" style="width: 338px; height: 304px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
<strong>Output:</strong> 0.16666666666666666 
<strong>Explanation:</strong> The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after <strong>second 1</strong> and then jumping with 1/2 probability to vertex 4 after <strong>second 2</strong>. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg" style="width: 304px; height: 304px;" /></strong>

<pre>
<strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
<strong>Output:</strong> 0.3333333333333333
<strong>Explanation: </strong>The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after <strong>second 1</strong>. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>1 &lt;= t &lt;= 50</code></li>
	<li><code>1 &lt;= target &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/geek-in-a-maze--170637/1" target="_blank" rel="noopener noreferrer">Geek in a Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geek is in a maze of size N * M. Each cell in the maze is made of either &#39;.&#39; or &#39;#&#39;. An empty cell is represented by &#39;.&#39; and an obstacle is represented by &#39;#&#39;. If Geek starts at cell (R, C), find how many different empty cells&nbsp;he can pass through while avoiding the obstacles. He can move in any of the four directions but he can move up at most U times and he can move down atmost D times. </span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
N = 3, M = 3
R = 1, C = 0
U = 1, D = 1
mat = {{&#39;.&#39;, &#39;.&#39;, &#39;.&#39;},
       {&#39;.&#39;, &#39;#&#39;, &#39;.&#39;},
       {&#39;#&#39;, &#39;.&#39;, &#39;.&#39;}}
<strong>Output:</strong> 5
<strong>Explanation:</strong> Geek can reach 
(1, 0), (0, 0), (0, 1), (0, 2), (1, 2) 

</span></pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
N = 3, M = 4
R = 1, C = 0
U = 1, D = 2 
mat = {{&#39;.&#39;, &#39;.&#39;, &#39;.&#39;}, 
       {&#39;.&#39;, &#39;#&#39;, &#39;.&#39;}, 
       {&#39;.&#39;, &#39;.&#39;, &#39;.&#39;},
       {&#39;#&#39;, &#39;.&#39;, &#39;.&#39;}} 
<strong>Output:</strong> 10
<strong>Explanation:</strong> Geek can reach all the 
cells except for the obstacles.
</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task: &nbsp;</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>numberOfCells()&nbsp;</strong>which takes&nbsp;<strong>N, M, R, C, U, D</strong> and the&nbsp;two dimensional character array&nbsp;<strong>mat[][]</strong> as input parameters and returns the number of cells geek can visit( If he is standing on obstacle he can not move). </span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N*M &le; 10<sup>6</sup><br />
mat[i][j] = &#39;#&quot; or &#39;.&#39;<br />
0 &le; R &le; N-1<br />
0 &le; C &le; M-1</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/get-watched-videos-by-your-friends/description" target="_blank" rel="noopener noreferrer">Get Watched Videos by Your Friends</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> people, each person has a unique <em>id</em> between <code>0</code> and <code>n-1</code>. Given the arrays <code>watchedVideos</code> and <code>friends</code>, where <code>watchedVideos[i]</code> and <code>friends[i]</code> contain the list of watched videos and the list of friends respectively for the person with <code>id = i</code>.</p>

<p>Level <strong>1</strong> of videos are all watched videos by your&nbsp;friends, level <strong>2</strong> of videos are all watched videos by the friends of your&nbsp;friends and so on. In general, the level <code>k</code> of videos are all&nbsp;watched videos by people&nbsp;with the shortest path <strong>exactly</strong> equal&nbsp;to&nbsp;<code>k</code> with you. Given your&nbsp;<code>id</code> and the <code>level</code> of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.&nbsp;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_1.png" style="width: 144px; height: 200px;" /></strong></p>

<pre>
<strong>Input:</strong> watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1
<strong>Output:</strong> [&quot;B&quot;,&quot;C&quot;] 
<strong>Explanation:</strong> 
You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):
Person with id = 1 -&gt; watchedVideos = [&quot;C&quot;]&nbsp;
Person with id = 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;]&nbsp;
The frequencies of watchedVideos by your friends are:&nbsp;
B -&gt; 1&nbsp;
C -&gt; 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_2.png" style="width: 144px; height: 200px;" /></strong></p>

<pre>
<strong>Input:</strong> watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2
<strong>Output:</strong> [&quot;D&quot;]
<strong>Explanation:</strong> 
You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == watchedVideos.length ==&nbsp;friends.length</code></li>
	<li><code>2 &lt;= n&nbsp;&lt;= 100</code></li>
	<li><code>1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100</code></li>
	<li><code>1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8</code></li>
	<li><code>0 &lt;= friends[i].length &lt; n</code></li>
	<li><code>0 &lt;= friends[i][j]&nbsp;&lt; n</code></li>
	<li><code>0 &lt;= id &lt; n</code></li>
	<li><code>1 &lt;= level &lt; n</code></li>
	<li>if&nbsp;<code>friends[i]</code> contains <code>j</code>, then <code>friends[j]</code> contains <code>i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/good-stones--170647/1" target="_blank" rel="noopener noreferrer">Good Stones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Geek is in a geekland which have a river and some stones in it. Initially geek can step on any stone. Each stone has a number on it representing the value of exact step geek can move. If the number is +ve then geeks can move right and if the number is -ve then geeks can move left. Bad Stones are defined as the stones in which if geeks steps, will reach a never ending loop whereas good stones are the stones which are safe from never ending loops. Return the number of <strong>good stones</strong> in river.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> [2, 3, -1, 2, -2, 4, 1]</span>
<span style="font-size: 18px;"><strong>Output: </strong>3
<strong>Explanation: </strong>Index 3, 5 and 6 are safe only. As index 1, 4, 2 forms a cycle and from index 0 you can go to index 2 which is part of cycle.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/713990/Web/Other/blobid0_1745470372.jpg" width="464" height="232" /> </pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> [1, 0, -3, 0, -5, 0]</span>
<span style="font-size: 18px;"><strong>Output:</strong> 2
<strong>Explanation: </strong>Index 2 and 4 are safe only. As index 0, 1, 3, 5 form cycle.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/713990/Web/Other/blobid1_1745470413.jpg" width="374" height="187" /> &nbsp;</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span><br /><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function badStones() which takes integer <strong>n</strong> and&nbsp;an&nbsp;array <strong>arr </strong>as input, and return an interger value as the number of good stones. Here n is the lenght of arr.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>&nbsp;: O(N), N is the number of stones<br /><strong>Expected Auxiliary Space</strong>&nbsp;: O(N),&nbsp;N is the number of stones</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />&nbsp;&nbsp;&nbsp;1 &lt;= n&nbsp;&lt;&nbsp;10^5 (where n is the length of the array)<br />&nbsp; -1000 &lt;= arr[i] &lt; 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/is-it-a-tree/1" target="_blank" rel="noopener noreferrer">Graph is Tree or Not</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an undirected graph of <strong>N</strong> nodes (numbered from 0 to N-1) and <strong>M</strong> edges. Return 1 if the graph is a tree, else return 0.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> The input graph can have self-loops and multiple edges.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 4, M = 3</span>
<span style="font-size: 18px;">G = [[0, 1], [1, 2], [1, 3]]</span>
<span style="font-size: 18px;"><strong>Output:</strong> <br />1</span>
<span style="font-size: 18px;"><strong>Explanation: <br /></strong>Every node is reachable and the graph has no loops, so it is a tree</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong></span><span style="font-size: 18px;">N = 4, M = 3</span>
<span style="font-size: 18px;">G = [[0, 1], [1, 2], [2, 0]]</span>
<span style="font-size: 18px;"><strong>Output:</strong> <br />0</span>
<span style="font-size: 18px;"><strong>Explanation:</strong> <br />3 is not connected to any </span><span style="font-size: 18px;">node and there is a loop 0-&gt;1-&gt;2-&gt;0, so</span> <span style="font-size: 18px;">it is not a tree.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>isTree()</strong> which takes the integer N (the number nodes in the input graph) and the edges representing the graph as input parameters and returns 1 if the input graph is a tree, else 0.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N+M)<br /><strong>Expected Auxiliary Space:</strong> O(N)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 2*10<sup>5</sup><br />0 &lt;= M &lt;= 2*10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/hamiltonian-path2522/1" target="_blank" rel="noopener noreferrer">Hamiltonian Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="24" data-end="245"><span style="font-size: 14pt;">Given an undirected graph with <strong>n</strong> vertices and <strong>m</strong> edges, your task is to determine if a Hamiltonian path exists in the graph. </span></p>
<p data-start="24" data-end="245"><span style="font-size: 14pt;">A<a href="https://www.geeksforgeeks.org/hamiltonian-cycle/"> <strong data-start="154" data-end="174">Hamiltonian path</strong></a> is a path in an undirected graph that visits each vertex exactly once.</span></p>
<p data-start="247" data-end="278"><span style="font-size: 14pt;">You are provided the following:</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<ul data-start="280" data-end="498">
<li data-start="280" data-end="325"><span style="font-size: 14pt;"><strong data-start="282" data-end="287">n</strong>: The number of vertices in the graph.</span></li>
<li data-start="326" data-end="368"><span style="font-size: 14pt;"><strong data-start="328" data-end="333">m</strong>: The number of edges in the graph.</span></li>
<li data-start="369" data-end="498"><span style="font-size: 14pt;"><strong data-start="371" data-end="384">edges[][]</strong>: A 2D list where each element edges[i] represents an edge between two vertices edges[i][0] and edges[i][1].&nbsp;</span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, m = 4
edges[][]= { {1,2}, {2,3}, {3,4}, {2,4} }
<strong>Output: </strong>1 
<strong>Explanation: </strong>There is a hamiltonian path: 1 -&gt; 2 -&gt; 3 -&gt; 4 </span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, m = 3 
edges[][] = { {1,2}, {2,3}, {2,4} } 
<strong>Output: </strong>0 
<strong>Explanation: </strong>It can be proved that there is no hamiltonian path in the given graph.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; n &le; 10</span><br /><span style="font-size: 18px;">1 &le; m &le; 15</span><br /><span style="font-size: 18px;">Size of edges[i] is 2</span><br /><span style="font-size: 18px;">1 &le; edges[i][0],edges[i][1] &le; n</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/holiday-decorations-b53daa12/" target="_blank" rel="noopener noreferrer">Holiday decorations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicsofimplementation</span> <span class="topic-badge">basicsofqueues</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">implementation</span> <span class="topic-badge">queue</span> <span class="topic-badge">structureddata</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Recently, the first model of decoration was assembled from multi-colored glowing light bulbs at the holiday jewelry factory. The prototype of the decoration was assembled as follows:</p>

<ul>
	<li>First, two light bulbs were taken and connected with a wire.</li>
	<li>Then, a light bulb was taken for <span class="mathjax-latex">\( N-2\)</span> times and it was connected with a wire to one of the previously added to the garland light bulbs.</li>
</ul>

<p>The result was a decoration of <span class="mathjax-latex">\(N\)</span> colored light bulbs. The factory has <span class="mathjax-latex">\(K\)</span> bulbs of different colors. When the prototype was ready, it was handed over to the Beauty Department. In this department, it was decided to consider the beauty of jewelry the number of pairs of light bulbs of the same color, connected by a wire.<br>
Employees of the Beauty Department <span class="mathjax-latex">\(M\)</span> repaint some of the light bulbs in one of the <span class="mathjax-latex">\( K\)</span> colors for some reason known only to them. All they need to produce the perfect jewelry is to quickly determine the beauty of the product, after repainting the next light bulb.<br>
The staff of the beauty department asks you, the best programmer, to write a program that will determine the beauty of jewelry according to the given prototype of jewelry and the sequence of repainting light bulbs.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains three integers <span class="mathjax-latex">\(N\)</span>, <span class="mathjax-latex">\(M\)</span>, <span class="mathjax-latex">\( K\)</span> denoting the number of bulbs in the product prototype, the number of repaints, and the number of different colors of bulbs available at the factory.</li>
	<li>The second line contains <span class="mathjax-latex">\(N\)</span> positive integers <span class="mathjax-latex">\(A_i\)</span> denoting the colors of the bulbs in the order of addition to the product.</li>
	<li>The third line contains <span class="mathjax-latex">\(N-2\)</span> positive integers <span class="mathjax-latex">\(P_j\)</span> denoting the number of the light bulb to which the <span class="mathjax-latex">\((j + 2)\)</span> light bulb was connected.</li>
	<li>The next <span class="mathjax-latex">\(M\)</span> lines contain two integers <span class="mathjax-latex">\(X\)</span> and <span class="mathjax-latex">\(Y\)</span> denoting the number of the repainted lamp and the color in which it is repainted, respectively. The numbers in the lines are separated by single spaces.</li>
</ul>

<p><strong>Output format</strong></p>

<p>Print <span class="mathjax-latex">\(M\)</span> lines. The <span class="mathjax-latex">\(i^{th}\)</span> line should contain a single integer denoting the number of pairs of light bulbs of the same color, connected by a wire, after execution and repainting.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(2 ≤ N ≤ 3*10^5\)</span></p>

<p><span class="mathjax-latex">\(1 ≤ M ≤ 3*10^5\)</span></p>

<p><span class="mathjax-latex">\(1 ≤ K ≤ 10^9\)</span></p>

<p><span class="mathjax-latex">\(1 ≤ A_i ≤ K\)</span></p>

<p><span class="mathjax-latex">\(1 ≤ P_j ≤ j + 1\)</span></p>

<p><span class="mathjax-latex">\(1 ≤ X ≤ N \)</span></p>

<p><span class="mathjax-latex">\(1 ≤ Y ≤ K\)</span></p>

<p> </p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the first case, all bulbs are connected in a chain (first-second-third) and have different colors. Then they are repainted in the same color. First, a pair of light bulbs 1 2 becomes a single color (the second light bulb is repainted in color 1), and then 2 3 (the third light bulb is repainted in color 1). After repainting the second bulb in the color of 2 single-color pairs of bulbs connected by a wire, does not remain.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/is-graph-bipartite/description" target="_blank" rel="noopener noreferrer">Is Graph Bipartite?</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p>

<ul>
	<li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li>
	<li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li>
	<li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li>
	<li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li>
</ul>

<p>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p>

<p>Return <code>true</code><em> if and only if it is <strong>bipartite</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>graph.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= graph[u].length &lt; n</code></li>
	<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>
	<li><code>graph[u]</code>&nbsp;does not contain&nbsp;<code>u</code>.</li>
	<li>All the values of <code>graph[u]</code> are <strong>unique</strong>.</li>
	<li>If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/keys-and-rooms/description" target="_blank" rel="noopener noreferrer">Keys and Rooms</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code>&nbsp;and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>

<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>

<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> rooms = [[1],[2],[3],[]]
<strong>Output:</strong> true
<strong>Explanation:</strong> 
We visit room 0 and pick up key 1.
We then visit room 1 and pick up key 2.
We then visit room 2 and pick up key 3.
We then visit room 3.
Since we were able to visit every room, we return true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]
<strong>Output:</strong> false
<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == rooms.length</code></li>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
	<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>
	<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>
	<li>All the values of <code>rooms[i]</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>When visiting a room for the first time, look at all the keys in that room.  For any key that hasn't been used yet, add it to the todo list (<code>stack</code>) for it to be used.</p>
<p>See the comments of the code for more details.</p>
<p><a href="https://leetcode.com/playground/dRqvjiWp/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N + E)\)</span>, where <span class="math inline">\(N\)</span> is the number of rooms, and <span class="math inline">\(E\)</span> is the total number of keys.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span> in additional space complexity, to store <code>stack</code> and <code>seen</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/kill-captain-america0228/1" target="_blank" rel="noopener noreferrer">Kill Captain America</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Captain America is hiding from Thanos in a maze full of <strong>n</strong> rooms connected by <strong>m</strong> gates. The maze is designed in such a way that each room leads to another room via gates. All connecting gates are unidirectional. Captain America is hiding only in those rooms which are accessible directly/indirectly through every other room in the maze.<br />Help Thanos find the number of rooms in which Captain America can hide.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: n = 5, gates[][] = [[1, 2], [2, 3], [3, 4], [4, 3], [5, 4]]
<strong>Output:</strong>&nbsp;2
<strong>Explanation</strong>:
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/704857/Web/Other/blobid0_1745301369.jpg" width="420" height="186" /> <br />We can look closesly after forming graph than captain america only can hide in a room 3 and 4 because they are the only room which have gates through them. So, answer is 2.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, gates[][] = [[1, 2]]
</span><span style="font-size: 18px;"><strong>Output: </strong>1<br /></span><strong style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">:  <span style="font-size: 14pt;">Room 2 is the only room that can be visited from other rooms</span></span><span style="font-size: 14pt;">.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 30000<br />1 &le; m &le; 200000<br />1 &le; gates[i][0], gates[i][1] &le; n</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/knight-walk4521/1" target="_blank" rel="noopener noreferrer">Knight Walk</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square chessboard, the initial position of Knight and position of a target. Find out the minimum steps a Knight will take to reach the target position.If it cannot reach the target position return -1.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong><br />The initial and the target position co-ordinates of&nbsp;Knight have been given accoring to 1-base indexing.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N=6
knightPos[ ] = {4, 5}
targetPos[ ] = {1, 1}
<strong>Output:</strong>
3
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/KnightChess.jpg" />
Knight takes 3 step to reach from
(4, 5) to (1, 1):
(4, 5) -&gt; (5, 3) -&gt; (3, 2) -&gt; (1, 1). </span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N=8
knightPos[ ] = {7, 7}
targetPos[ ] = {1, 5}
<strong>Output:</strong>
4
<strong>Explanation:</strong></span>
<span style="font-size: 18px;">Knight takes 4 steps to reach from
(7, 7) to (1, 5):
(4, 5) -&gt; (6, 5) -&gt; (5, 3) -&gt; (7, 2) -&gt; (1, 5).</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>minStepToReachTarget()</strong>&nbsp;which takes the inital position of Knight (KnightPos), the target position of Knight (TargetPos) and the size of the chess board (N) as an input parameters&nbsp;and returns the minimum number of steps required by the knight to reach from its current position to the given target position.If it cannot reach the target position return -1.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N<sup>2</sup>).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N<sup>2</sup>).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 1000<br />1 &lt;= Knight_pos(X, Y), Targer_pos(X, Y)&nbsp;&lt;= N</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-color-value-in-a-directed-graph/description" target="_blank" rel="noopener noreferrer">Largest Color Value in a Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">graph</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i<sup>th</sup></code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> indicates that there is a <strong>directed edge</strong> from node <code>a<sub>j</sub></code> to node <code>b<sub>j</sub></code>.</p>

<p>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> such that there is a directed edge from <code>x<sub>i</sub></code> to <code>x<sub>i+1</sub></code> for every <code>1 &lt;= i &lt; k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.</p>

<p>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or </em><code>-1</code><em> if the graph contains a cycle</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet1.png" style="width: 400px; height: 182px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored <code>&quot;a&quot; (red in the above image)</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet2.png" style="width: 85px; height: 85px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;a&quot;, edges = [[0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is a cycle from 0 to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == colors.length</code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>colors</code> consists of lowercase English letters.</li>
	<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub>&nbsp;&lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-sum-cycle--170645/1" target="_blank" rel="noopener noreferrer">Largest Sum Cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a maze with&nbsp;<strong>N</strong>&nbsp;cells. Each cell may have multiple entry points but not more than one exit(i.e entry/exit points are unidirectional doors like valves).<br />
You are given an array&nbsp;<strong>Edge[]</strong>&nbsp;of&nbsp;<strong>N&nbsp;</strong>integers,&nbsp;where Edge[i] contains the cell number that can be reached from of&nbsp;cell&nbsp;i in one step. Edge[i] is -1 if the ith cell doesn&#39;t have an exit.&nbsp;<br />
The task is to find the&nbsp;largest sum of a cycle in the maze(Sum of a cycle is the sum of the cell indexes of all cells present in that cycle).</span></p>

<p><span style="font-size:18px"><strong>Note:</strong>The cells are named with an integer value from 0 to N-1. <strong>If there is no cycle in the graph then return -1.</strong></span></p>

<p><span style="font-size:18px"><strong><strong>Example 1:</strong></strong></span></p>

<pre>
<span style="font-size:18px"><strong><strong>Input:</strong>
</strong>N = 4
Edge[] = {1, 2, 0, -1}<strong>
<strong>Output:</strong> </strong>3<strong>
<strong>Explanation</strong>: 
</strong>There is only one cycle in the graph.
(i.e 0-&gt;1-&gt;2-&gt;0)
Sum of the cell index in that cycle 
= 0 + 1 + 2 = 3.
</span></pre>

<p><span style="font-size:18px"><strong><strong>Example 2:</strong></strong></span></p>

<pre>
<span style="font-size:18px"><strong><strong>Input:</strong>
</strong>N = 4 
Edge[] = {2, 0, -1, 2}<strong>
<strong>Output:</strong> </strong>-1<strong>
<strong>Explanation</strong>:
</strong>1 -&gt; 0 -&gt; 2 &lt;- 3
There is no cycle in the graph.
</span></pre>

<p><br />
<span style="font-size:18px"><strong><strong>Your task:</strong></strong><br />
You dont need to read input or print anything. Your task is to complete the function&nbsp;<strong>largestSumCycle</strong>()&nbsp;which takes the integer N&nbsp;denoting the number of cells&nbsp;and the array Edge[]&nbsp;as input parameters and returns the sum of the&nbsp;largest sum cycle in the maze.</span></p>

<p><span style="font-size:18px"><strong><strong>Expected Time Complexity:</strong></strong>&nbsp;O(N)<br />
<strong><strong>Expected Auxiliary Space:&nbsp;</strong></strong>O(N)</span></p>

<p><span style="font-size:18px"><strong><strong>Constraints:</strong></strong><br />
1 &le; N&nbsp;&le; 10<sup>5</sup><br />
-1&nbsp;<u>&lt;</u>&nbsp;Edge[i] &lt; N<br />
Edge[i] != i</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/level-of-nodes-1587115620/1" target="_blank" rel="noopener noreferrer">Level of Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer <strong>x</strong> and an undirected acyclic graph with <strong>v nodes</strong>, labeled from <strong>0 </strong>to <strong>v-1</strong>, and <strong>e </strong>edges, return the <strong>level </strong>of node labeled as <strong>x</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Level </strong>is the <strong>minimum </strong>number of edges you must travel from the node 0 to some target.</span></p>
<p><span style="font-size: 18px;">If there doesn't exists such a node that is labeled as <strong>x</strong>, <strong>return -1</strong>.<br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">x</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> = 4</span></span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701248/Web/Other/blobid0_1745299763.jpg" width="414" height="366" /><br /><span style="font-size: 18px;"><strong>Output: </strong>2
<strong>Explanation</strong>:
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701248/Web/Other/blobid1_1745299817.jpg" width="461" height="307" /><br /><span style="font-size: 18px;">We can clearly see that Node 4 lies at Level 2.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">x</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> = 1</span></span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701248/Web/Other/blobid2_1745299852.jpg" width="314" height="209" /> <br /><span style="font-size: 18px;"><strong>Output: </strong>1
<strong>Explanation</strong>: Node 1 lies at level 1, immediate after Node 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(v)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(v)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />2 </span> <span style="font-size: 18px;">&le;</span> v<span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> 10<sup>4<br /></sup></span><span style="font-size: 18px;">1 &le;<span style="font-size: medium;"> e</span>&nbsp;&le;<span style="font-size: medium;">&nbsp;</span>10<sup>4</sup><br />0 </span> <span style="font-size: 18px;">&le;</span> adj<span style="font-size: 18px;"><sub>i, j</sub> &lt; v</span><br /><span style="font-size: 18px;">1 </span> <span style="font-size: 18px;">&le;</span> x<span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;">&lt;</span> <span style="font-size: 14pt;">v</span><span style="font-size: 18px;"><br /></span></p>
<p><span style="font-size: 18px;"><strong>Note : </strong>Graph doesn't contain multiple edges and self loops.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/lexicographical-smallest-string/1" target="_blank" rel="noopener noreferrer">Lexicographical Smallest String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string<strong>&nbsp;s </strong>of length <strong>N</strong>, the task is to find the lexicographically smallest string&nbsp;of minimum characters that do not exist as a substring&nbsp;in <strong>s</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">s = "aabacdefghijklmnopqrstuvwxyz"</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">ad</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">All the single digit strings from [a-z] occur in the 
given string and in two character strings, strings 
{aa, ab, ac} occur but ad is not present in the given 
string.</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">s = "geeksforgeeks"</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">a</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">Single digit string "a" is not present in the given 
string.</span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">Your task is to complete the function <strong>lexicographicalSmallestString()</strong> which takes a string <strong>s</strong> as the only argument and returns the lexicographically smallest string which is not present as the substring in the string <strong>s</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>&nbsp;* log(N))</span></p>
<p><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(N<sup>2</sup>)</span></p>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= N &lt;= 10<sup>3</sup></span></li>
<li><span style="font-size: 18px;">String s consists of lowercase English alphabets.</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-cycle-in-a-graph/description" target="_blank" rel="noopener noreferrer">Longest Cycle in a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>directed</strong> graph of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, where each node has <strong>at most one</strong> outgoing edge.</p>

<p>The graph is represented with a given <strong>0-indexed</strong> array <code>edges</code> of size <code>n</code>, indicating that there is a directed edge from node <code>i</code> to node <code>edges[i]</code>. If there is no outgoing edge from node <code>i</code>, then <code>edges[i] == -1</code>.</p>

<p>Return <em>the length of the <strong>longest</strong> cycle in the graph</em>. If no cycle exists, return <code>-1</code>.</p>

<p>A cycle is a path that starts and ends at the <strong>same</strong> node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png" style="width: 335px; height: 191px;" />
<pre>
<strong>Input:</strong> edges = [3,3,4,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest cycle in the graph is the cycle: 2 -&gt; 4 -&gt; 3 -&gt; 2.
The length of this cycle is 3, so 3 is returned.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png" style="width: 171px; height: 161px;" />
<pre>
<strong>Input:</strong> edges = [2,-1,3,1]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no cycles in this graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-1 &lt;= edges[i] &lt; n</code></li>
	<li><code>edges[i] != i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-increasing-path-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Longest Increasing Path in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>

<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-palindromic-path-in-graph/description" target="_blank" rel="noopener noreferrer">Longest Palindromic Path in Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an <strong>undirected</strong> graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code> and a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>You are also given a string <code>label</code> of length <code>n</code>, where <code>label[i]</code> is the character associated with node <code>i</code>.</p>

<p>You may start at any node and move to any adjacent node, visiting each node <strong>at most</strong> once.</p>

<p>Return the <strong>maximum</strong> possible length of a <strong><span data-keyword="palindrome-string">palindrome</span></strong> that can be formed by visiting a set of <strong>unique</strong> nodes along a valid path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1],[1,2]], label = &quot;aba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Exp</strong><strong>lanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/13/screenshot-2025-06-13-at-230714.png" style="width: 250px; height: 85px;" /></p>

<ul>
	<li>The longest palindromic path is from node 0 to node 2 via node 1, following the path <code>0 &rarr; 1 &rarr; 2</code> forming string <code>&quot;aba&quot;</code>.</li>
	<li>This is a valid palindrome of length 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1],[0,2]], label = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/13/screenshot-2025-06-13-at-230017.png" style="width: 200px; height: 150px;" /></p>

<ul>
	<li>No path with more than one node forms a palindrome.</li>
	<li>The best option is any single node, giving a palindrome of length 1.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,2],[0,3],[3,1]], label = &quot;bbac&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/13/screenshot-2025-06-13-at-230508.png" style="width: 200px; height: 200px;" /></p>

<ul>
	<li>The longest palindromic path is from node 0 to node 1, following the path <code>0 &rarr; 3 &rarr; 1</code>, forming string <code>&quot;bcb&quot;</code>.</li>
	<li>This is a valid palindrome of length 3.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 14</code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>label.length == n</code></li>
	<li><code>label</code> consists of lowercase English letters.</li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-path-with-different-adjacent-characters/description" target="_blank" rel="noopener noreferrer">Longest Path With Different Adjacent Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>tree</strong> (i.e. a connected, undirected graph that has no cycles) <strong>rooted</strong> at node <code>0</code> consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The tree is represented by a <strong>0-indexed</strong> array <code>parent</code> of size <code>n</code>, where <code>parent[i]</code> is the parent of node <code>i</code>. Since node <code>0</code> is the root, <code>parent[0] == -1</code>.</p>

<p>You are also given a string <code>s</code> of length <code>n</code>, where <code>s[i]</code> is the character assigned to node <code>i</code>.</p>

<p>Return <em>the length of the <strong>longest path</strong> in the tree such that no pair of <strong>adjacent</strong> nodes on the path have the same character assigned to them.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png" style="width: 201px; height: 241px;" />
<pre>
<strong>Input:</strong> parent = [-1,0,0,1,1,2], s = &quot;abacbe&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -&gt; 1 -&gt; 3. The length of this path is 3, so 3 is returned.
It can be proven that there is no longer path that satisfies the conditions. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png" style="width: 201px; height: 221px;" />
<pre>
<strong>Input:</strong> parent = [-1,0,0,0], s = &quot;aabc&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest path where each two adjacent nodes have different characters is the path: 2 -&gt; 0 -&gt; 3. The length of this path is 3, so 3 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == parent.length == s.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for all <code>i &gt;= 1</code></li>
	<li><code>parent[0] == -1</code></li>
	<li><code>parent</code> represents a valid tree.</li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/loud-and-rich/description" target="_blank" rel="noopener noreferrer">Loud and Rich</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a group of <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> where each person has a different amount of money and a different level of quietness.</p>

<p>You are given an array <code>richer</code> where <code>richer[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that <code>a<sub>i</sub></code> has more money than <code>b<sub>i</sub></code> and an integer array <code>quiet</code> where <code>quiet[i]</code> is the quietness of the <code>i<sup>th</sup></code> person. All the given data in richer are <strong>logically correct</strong> (i.e., the data will not lead you to a situation where <code>x</code> is richer than <code>y</code> and <code>y</code> is richer than <code>x</code> at the same time).</p>

<p>Return <em>an integer array </em><code>answer</code><em> where </em><code>answer[x] = y</code><em> if </em><code>y</code><em> is the least quiet person (that is, the person </em><code>y</code><em> with the smallest value of </em><code>quiet[y]</code><em>) among all people who definitely have equal to or more money than the person </em><code>x</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
<strong>Output:</strong> [5,5,2,5,4,5,6,7]
<strong>Explanation:</strong> 
answer[0] = 5.
Person 5 has more money than 3, which has more money than 1, which has more money than 0.
The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.
answer[7] = 7.
Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.
The other answers can be filled out with similar reasoning.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> richer = [], quiet = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == quiet.length</code></li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>0 &lt;= quiet[i] &lt; n</code></li>
	<li>All the values of <code>quiet</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt;= richer.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i </sub>!= b<sub>i</sub></code></li>
	<li>All the pairs of <code>richer</code> are <strong>unique</strong>.</li>
	<li>The observations in <code>richer</code> are all logically consistent.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-cached-depth-first-search-accepted">Approach #1: Cached Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Consider the directed graph with edge <code>x -&gt; y</code> if <code>y</code> is richer than <code>x</code>.</p>
<p>For each person <code>x</code>, we want the quietest person in the subtree at <code>x</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Construct the graph described above, and say <code>dfs(person)</code> is the quietest person in the subtree at <code>person</code>.   Notice because the statements are logically consistent, the graph must be a DAG - a directed graph with no cycles.</p>
<p>Now <code>dfs(person)</code> is either <code>person</code>, or <code>min(dfs(child) for child in person)</code>.  That is to say, the quietest person in the subtree is either the <code>person</code> itself, or the quietest person in some subtree of a child of <code>person</code>.</p>
<p>We can cache values of <code>dfs(person)</code> as <code>answer[person]</code>, when performing our <em>post-order traversal</em> of the graph.  That way, we don't repeat work.  This technique reduces a quadratic time algorithm down to linear time.</p>
<p><a href="https://leetcode.com/playground/UXq5wv8E/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: <span class="math inline">\(\mathcal{O}(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the number of people.<br />
We are iterating here over array <code>richer</code>. It could contain up to</li>
</ul>
<p><span class="math display">\[when each new person is richer than the previous one.  

* Space Complexity: $$\mathcal{O}(N^2)$$, to keep the graph with $$N^2$$ edges.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximal-network-rank/description" target="_blank" rel="noopener noreferrer">Maximal Network Rank</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an infrastructure of <code>n</code> cities with some number of <code>roads</code> connecting these cities. Each <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is a bidirectional road between cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>The <strong>network rank</strong><em> </em>of <strong>two different cities</strong> is defined as the total number of&nbsp;<strong>directly</strong> connected roads to <strong>either</strong> city. If a road is directly connected to both cities, it is only counted <strong>once</strong>.</p>

<p>The <strong>maximal network rank </strong>of the infrastructure is the <strong>maximum network rank</strong> of all pairs of different cities.</p>

<p>Given the integer <code>n</code> and the array <code>roads</code>, return <em>the <strong>maximal network rank</strong> of the entire infrastructure</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/ex1.png" style="width: 292px; height: 172px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/ex2.png" style="width: 292px; height: 172px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> There are 5 roads that are connected to cities 1 or 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>roads[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n-1</code></li>
	<li><code>a<sub>i</sub>&nbsp;!=&nbsp;b<sub>i</sub></code></li>
	<li>Each&nbsp;pair of cities has <strong>at most one</strong> road connecting them.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-amount-after-two-days-of-conversions/description" target="_blank" rel="noopener noreferrer">Maximize Amount After Two Days of Conversions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>initialCurrency</code>, and you start with <code>1.0</code> of <code>initialCurrency</code>.</p>

<p>You are also given four arrays with currency pairs (strings) and rates (real numbers):</p>

<ul>
	<li><code>pairs1[i] = [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code> denotes that you can convert from <code>startCurrency<sub>i</sub></code> to <code>targetCurrency<sub>i</sub></code> at a rate of <code>rates1[i]</code> on <strong>day 1</strong>.</li>
	<li><code>pairs2[i] = [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code> denotes that you can convert from <code>startCurrency<sub>i</sub></code> to <code>targetCurrency<sub>i</sub></code> at a rate of <code>rates2[i]</code> on <strong>day 2</strong>.</li>
	<li>Also, each <code>targetCurrency</code> can be converted back to its corresponding <code>startCurrency</code> at a rate of <code>1 / rate</code>.</li>
</ul>

<p>You can perform <strong>any</strong> number of conversions, <strong>including zero</strong>, using <code>rates1</code> on day 1, <strong>followed</strong> by any number of additional conversions, <strong>including zero</strong>, using <code>rates2</code> on day 2.</p>

<p>Return the <strong>maximum</strong> amount of <code>initialCurrency</code> you can have after performing any number of conversions on both days <strong>in order</strong>.</p>

<p><strong>Note: </strong>Conversion rates are valid, and there will be no contradictions in the rates for either day. The rates for the days are independent of each other.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">initialCurrency = &quot;EUR&quot;, pairs1 = [[&quot;EUR&quot;,&quot;USD&quot;],[&quot;USD&quot;,&quot;JPY&quot;]], rates1 = [2.0,3.0], pairs2 = [[&quot;JPY&quot;,&quot;USD&quot;],[&quot;USD&quot;,&quot;CHF&quot;],[&quot;CHF&quot;,&quot;EUR&quot;]], rates2 = [4.0,5.0,6.0]</span></p>

<p><strong>Output:</strong> <span class="example-io">720.00000</span></p>

<p><strong>Explanation:</strong></p>

<p>To get the maximum amount of <strong>EUR</strong>, starting with 1.0 <strong>EUR</strong>:</p>

<ul>
	<li>On Day 1:
	<ul>
		<li>Convert <strong>EUR </strong>to <strong>USD</strong> to get 2.0 <strong>USD</strong>.</li>
		<li>Convert <strong>USD</strong> to <strong>JPY</strong> to get 6.0 <strong>JPY</strong>.</li>
	</ul>
	</li>
	<li>On Day 2:
	<ul>
		<li>Convert <strong>JPY</strong> to <strong>USD</strong> to get 24.0 <strong>USD</strong>.</li>
		<li>Convert <strong>USD</strong> to <strong>CHF</strong> to get 120.0 <strong>CHF</strong>.</li>
		<li>Finally, convert <strong>CHF</strong> to <strong>EUR</strong> to get 720.0 <strong>EUR</strong>.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">initialCurrency = &quot;NGN&quot;, pairs1 = </span>[[&quot;NGN&quot;,&quot;EUR&quot;]]<span class="example-io">, rates1 = </span>[9.0]<span class="example-io">, pairs2 = </span>[[&quot;NGN&quot;,&quot;EUR&quot;]]<span class="example-io">, rates2 = </span>[6.0]</p>

<p><strong>Output:</strong> 1.50000</p>

<p><strong>Explanation:</strong></p>

<p>Converting <strong>NGN</strong> to <strong>EUR</strong> on day 1 and <strong>EUR</strong> to <strong>NGN</strong> using the inverse rate on day 2 gives the maximum amount.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">initialCurrency = &quot;USD&quot;, pairs1 = [[&quot;USD&quot;,&quot;EUR&quot;]], rates1 = [1.0], pairs2 = [[&quot;EUR&quot;,&quot;JPY&quot;]], rates2 = [10.0]</span></p>

<p><strong>Output:</strong> <span class="example-io">1.00000</span></p>

<p><strong>Explanation:</strong></p>

<p>In this example, there is no need to make any conversions on either day.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= initialCurrency.length &lt;= 3</code></li>
	<li><code>initialCurrency</code> consists only of uppercase English letters.</li>
	<li><code>1 &lt;= n == pairs1.length &lt;= 10</code></li>
	<li><code>1 &lt;= m == pairs2.length &lt;= 10</code></li>
	<li><code>pairs1[i] == [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code><!-- notionvc: c31b5bb8-4df6-4987-9bcd-6dff8a5f7cd4 --></li>
	<li><code>pairs2[i] == [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code><!--{C}%3C!%2D%2D%20notionvc%3A%20c31b5bb8-4df6-4987-9bcd-6dff8a5f7cd4%20%2D%2D%3E--></li>
	<li><code>1 &lt;= startCurrency<sub>i</sub>.length, targetCurrency<sub>i</sub>.length &lt;= 3</code></li>
	<li><code>startCurrency<sub>i</sub></code> and <code>targetCurrency<sub>i</sub></code> consist only of uppercase English letters.</li>
	<li><code>rates1.length == n</code></li>
	<li><code>rates2.length == m</code></li>
	<li><code>1.0 &lt;= rates1[i], rates2[i] &lt;= 10.0</code></li>
	<li>The input is generated such that there are no contradictions or cycles in the conversion graphs for either day.</li>
	<li>The input is generated such that the output is <strong>at most</strong> <code>5 * 10<sup>10</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-spanning-tree-stability-with-upgrades/description" target="_blank" rel="noopener noreferrer">Maximize Spanning Tree Stability with Upgrades</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, representing <code>n</code> nodes numbered from 0 to <code>n - 1</code> and a list of <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, s<sub>i</sub>, must<sub>i</sub>]</code>:</p>

<ul>
	<li><code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> indicates an undirected edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</li>
	<li><code>s<sub>i</sub></code> is the strength of the edge.</li>
	<li><code>must<sub>i</sub></code> is an integer (0 or 1). If <code>must<sub>i</sub> == 1</code>, the edge <strong>must</strong> be included in the<strong> </strong><strong>spanning tree</strong>. These edges <strong>cannot</strong> be <strong>upgraded</strong>.</li>
</ul>

<p>You are also given an integer <code>k</code>, the <strong>maximum</strong> number of upgrades you can perform. Each upgrade <strong>doubles</strong> the strength of an edge, and each eligible edge (with <code>must<sub>i</sub> == 0</code>) can be upgraded <strong>at most</strong> once.</p>

<p>The <strong>stability</strong> of a spanning tree is defined as the <strong>minimum</strong> strength score among all edges included in it.</p>

<p>Return the <strong>maximum</strong> possible stability of any valid spanning tree. If it is impossible to connect all nodes, return <code>-1</code>.</p>

<p><strong>Note</strong>: A <strong>spanning tree</strong> of a graph with <code>n</code> nodes is a subset of the edges that connects all nodes together (i.e. the graph is <strong>connected</strong>) <em>without</em> forming any cycles, and uses <strong>exactly</strong> <code>n - 1</code> edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2,1],[1,2,3,0]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Edge <code>[0,1]</code> with strength = 2 must be included in the spanning tree.</li>
	<li>Edge <code>[1,2]</code> is optional and can be upgraded from 3 to 6 using one upgrade.</li>
	<li>The resulting spanning tree includes these two edges with strengths 2 and 6.</li>
	<li>The minimum strength in the spanning tree is 2, which is the maximum possible stability.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,4,0],[1,2,3,0],[0,2,1,0]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Since all edges are optional and up to <code>k = 2</code> upgrades are allowed.</li>
	<li>Upgrade edges <code>[0,1]</code> from 4 to 8 and <code>[1,2]</code> from 3 to 6.</li>
	<li>The resulting spanning tree includes these two edges with strengths 8 and 6.</li>
	<li>The minimum strength in the tree is 6, which is the maximum possible stability.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,1,1],[1,2,1,1],[2,0,1,1]], k = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>All edges are mandatory and form a cycle, which violates the spanning tree property of acyclicity. Thus, the answer is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, s<sub>i</sub>, must<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= s<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>must<sub>i</sub></code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>0 &lt;= k &lt;= n</code></li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-bipartite-matching--170646/1" target="_blank" rel="noopener noreferrer">Maximum Bipartite Matching</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are M job applicants and N jobs.&nbsp; Each applicant has a subset of jobs that he/she is interested in. Each job opening can only accept one applicant and a job applicant can be appointed for only one job. Given a matrix <strong>G</strong> with <strong>M</strong>&nbsp;rows and <strong>N</strong> columns&nbsp;where G(i,j) denotes i<sup>th&nbsp;</sup>applicant is interested in the j<sup>th&nbsp;</sup>job. Find the maximum number of applicants who can get the job.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>M = 3, N = 5
G = {{1,1,0,1,1},{0,1,0,0,1},
{1,1,0,1,1}}
<strong>Output: </strong>3
<strong>Explanation: </strong>There is one of the possible
assignment-
First applicant gets the 1st job.
Second applicant gets the 2nd job.
Third applicant gets the 4th job.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>M = 6, N = 2
G = {{1,1},{0,1},{0,1},{0,1},
{0,1},{1,0}}
<strong>Output: </strong>2
<strong>Explanation: </strong>There is one of the possible
assignment-
First applicant gets the 1st job.
Second applicant gets the 2nd job.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read to print anything. Your task is to complete the function&nbsp;<strong>maximumMatch()&nbsp;</strong>which takes matrix G as input parameter and returns the maximum number of applicants who can get the job.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N<sup>3</sup>).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N, M &le; 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-candies-you-can-get-from-boxes/description" target="_blank" rel="noopener noreferrer">Maximum Candies You Can Get from Boxes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> boxes labeled from <code>0</code> to <code>n - 1</code>. You are given four arrays: <code>status</code>, <code>candies</code>, <code>keys</code>, and <code>containedBoxes</code> where:</p>

<ul>
	<li><code>status[i]</code> is <code>1</code> if the <code>i<sup>th</sup></code> box is open and <code>0</code> if the <code>i<sup>th</sup></code> box is closed,</li>
	<li><code>candies[i]</code> is the number of candies in the <code>i<sup>th</sup></code> box,</li>
	<li><code>keys[i]</code> is a list of the labels of the boxes you can open after opening the <code>i<sup>th</sup></code> box.</li>
	<li><code>containedBoxes[i]</code> is a list of the boxes you found inside the <code>i<sup>th</sup></code> box.</li>
</ul>

<p>You are given an integer array <code>initialBoxes</code> that contains the labels of the boxes you initially have. You can take all the candies in <strong>any open box</strong> and you can use the keys in it to open new boxes and you also can use the boxes you find in it.</p>

<p>Return <em>the maximum number of candies you can get following the rules above</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
<strong>Output:</strong> 16
<strong>Explanation:</strong> You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.
Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.
In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.
Total number of candies collected = 7 + 4 + 5 = 16 candy.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
<strong>Output:</strong> 6
<strong>Explanation:</strong> You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.
The total number of candies will be 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == status.length == candies.length == keys.length == containedBoxes.length</code></li>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>status[i]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= candies[i] &lt;= 1000</code></li>
	<li><code>0 &lt;= keys[i].length &lt;= n</code></li>
	<li><code>0 &lt;= keys[i][j] &lt; n</code></li>
	<li>All values of <code>keys[i]</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt;= containedBoxes[i].length &lt;= n</code></li>
	<li><code>0 &lt;= containedBoxes[i][j] &lt; n</code></li>
	<li>All values of <code>containedBoxes[i]</code> are unique.</li>
	<li>Each box is contained in one box at most.</li>
	<li><code>0 &lt;= initialBoxes.length &lt;= n</code></li>
	<li><code>0 &lt;= initialBoxes[i] &lt; n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-breadth-first-search">Approach: Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can solve this problem using <strong>breadth-first search</strong> combined with a <strong>queue</strong>.</p>
<p>For the <span class="math inline">\(\textit{i}\)</span>-th box, we can only obtain the candies inside if we own the box (either from the beginning or from some other box) and can open it (either it is already open from the beginning or we have obtained the key to it). We use the array <span class="math inline">\(\text{hasBox}\)</span> to indicate whether each box is owned, and the array <span class="math inline">\(\text{canOpen}\)</span> to indicate whether each box can be opened. Before the search begins, we only have the boxes listed in the array <span class="math inline">\(\textit{initialBoxes}\)</span>, and can open those boxes corresponding to <span class="math inline">\(\textit{status}\)</span> array values of <span class="math inline">\(\textit{1}\)</span>. Any box that meets these two conditions before the search starts is placed into the queue.</p>
<p>During the breadth-first search, in each iteration, we take the box at the front of the queue, <span class="math inline">\(\textit{k}\)</span>, open it, and obtain the candies inside, the boxes in <span class="math inline">\(\textit{containedBoxes}[\textit{k}]\)</span>, and the keys in <span class="math inline">\(\textit{keys}[\textit{k}]\)</span>. We add the candies to the answer and then iterate over each box and each key. When enumerating boxes, if a box can be opened, we add it to the end of the queue; similarly, when enumerating keys, if the corresponding box is already owned, we add that box to the end of the queue. When the queue is empty, the search ends, and we have obtained the maximum number of candies possible.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JTrKBp4c/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The problem does not guarantee that each key appears no more than once across all boxes. While each list of keys is unique per box, the same key can appear in multiple boxes. Similarly, boxes in <code>containedBoxes</code> can also repeat. Therefore, during the breadth-first search, we may process up to <span class="math inline">\(O(n^2)\)</span> total keys and contained boxes, resulting in a worst-case time complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We need to use several arrays and queues, each of length <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-connected-group/1" target="_blank" rel="noopener noreferrer">Maximum Connected group</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a square&nbsp;binary grid. A grid is considered binary if every value in the grid is either&nbsp;<strong>1 or 0.&nbsp;</strong></span><span style="font-size: 18px;">You can change&nbsp;<strong>at most one</strong>&nbsp;cell in the grid from&nbsp;<strong>0 to 1</strong>.&nbsp;</span><span style="font-size: 18px;">You need to find the largest group of connected&nbsp;&nbsp;<strong>1's</strong>.&nbsp;</span><span style="font-size: 18px;">Two cells are said to be connected if both are&nbsp;<strong>adjacent</strong>(top, bottom, left, right)&nbsp;to each other and both have the same value.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">grid = [1, 1]
             [0, 1]
<strong>Output</strong>: 4
<strong>Explanation</strong>: By changing cell (2,1), we can obtain a connected group of 4 1's
[1, 1]
[<strong>1,</strong> 1]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: grid = [1, 0, 1]<br /></span><span style="font-size: 18px;">             [1, 0, 1]
             [1, 0, 1]
<strong>Output</strong>: 7
<strong>Explanation</strong>: By changing cell (3,2), we can obtain a connected group of 7 1's
[1, 0, 1]<br />[1, 0, 1]
[1, <strong>1,</strong> 1]</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>: O(n<sup>2</sup>)<br /><strong>Expected Auxiliary Space</strong>: O(</span><span style="font-size: 18px;">n</span><sup>2</sup><span style="font-size: 18px;">)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints</strong>:<br />1 &lt;= size of the grid&lt;= 500<br />0 &lt;= grid[i][j] &lt;= 1<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/description" target="_blank" rel="noopener noreferrer">Maximum Employees to Be Invited to a Meeting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A company is organizing a meeting and has a list of <code>n</code> employees, waiting to be invited. They have arranged for a large <strong>circular</strong> table, capable of seating <strong>any number</strong> of employees.</p>

<p>The employees are numbered from <code>0</code> to <code>n - 1</code>. Each employee has a <strong>favorite</strong> person and they will attend the meeting <strong>only if</strong> they can sit next to their favorite person at the table. The favorite person of an employee is <strong>not</strong> themself.</p>

<p>Given a <strong>0-indexed</strong> integer array <code>favorite</code>, where <code>favorite[i]</code> denotes the favorite person of the <code>i<sup>th</sup></code> employee, return <em>the <strong>maximum number of employees</strong> that can be invited to the meeting</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex1.png" style="width: 236px; height: 195px;" />
<pre>
<strong>Input:</strong> favorite = [2,2,1,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.
All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.
Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.
The maximum number of employees that can be invited to the meeting is 3. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> favorite = [1,2,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.
The seating arrangement will be the same as that in the figure given in example 1:
- Employee 0 will sit between employees 2 and 1.
- Employee 1 will sit between employees 0 and 2.
- Employee 2 will sit between employees 1 and 0.
The maximum number of employees that can be invited to the meeting is 3.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex2.png" style="width: 219px; height: 220px;" />
<pre>
<strong>Input:</strong> favorite = [3,0,1,4,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.
Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.
So the company leaves them out of the meeting.
The maximum number of employees that can be invited to the meeting is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == favorite.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= favorite[i] &lt;=&nbsp;n - 1</code></li>
	<li><code>favorite[i] != i</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>A company is planning a round table meeting for a group of employees who will only come if they can sit next to their favorite coworker at the circular table. Given the number of people the company hopes will attend and each employee's favorite coworker, we must return the largest number of people who can attend while sticking to the requirement that each person must be seated next to their favorite coworker.</p>
<p>At this point, we can observe that the problem can be seen as a directed graph where each employee points to their favorite person. The key observation here is that this graph has cycles, and those cycles are important because any group of employees in a cycle can sit next to each other in the meeting. So, detecting these cycles will be central to solving the problem.</p>
<p>However, we also need to account for the fact that there might be chains of employees, not forming cycles by themselves, but who are connected in such a way that they can potentially be linked to form a larger cycle. This gives us the idea that even if a group of employees doesn’t form a cycle initially, they might still be part of a larger group that can be arranged in a circle.</p>
<p>A final thing to note is that the circular nature of the seating arrangement may influence how you connect the employees, especially when identifying 'groups' or 'cycles' that can sit next to each other.</p>
<p>We have two main types of structures that can form when we try to seat employees based on their favorite people:</p>
<ol>
<li>
<p><strong>A one-way connected cycle</strong>: This is where employees form a directed chain, like <code>a -&gt; b -&gt; c -&gt; d -&gt; a</code>. This means each person’s favorite is part of a larger cycle, and everyone must sit next to someone else in the cycle. These cycles will only be able to seat as many employees as the cycle's size.</p>
</li>
<li>
<p><strong>A mutual two-way cycle</strong>: In this case, two people like each other mutually, meaning <code>a &lt;-&gt; b</code>. This is a two-way connection, forming a 2-cycle group. These types of cycle groups allow us to put more people on the table because we can treat them as a smaller unit that can connect to other parts of the graph.</p>
</li>
</ol>
<p>Let’s go over two examples to break this down more clearly.</p>
<h5 id="example-1-1-0-3-2-5-6-7-4-9-8-11-10-11-12-10">Example 1: <code>[1, 0, 3, 2, 5, 6, 7, 4, 9, 8, 11, 10, 11, 12, 10]</code></h5>
<p>We can visualize this as a graph where each node has an edge pointing to their favorite person.</p>
<p>If person A likes B, we construct an edge of A -&gt; B. Then we can construct a graph like below:</p>
<p><img src="../Figures/2127/diff_cases.png" alt="alt text" /></p>
<ol>
<li>
<p><strong>Cycle with size &gt; 2 (green cycle)</strong>:</p>
<ul>
<li>For cycles like this, no additional employees can be added to the cycle because everyone must sit next to their favorite person, and adding others would disrupt that. For instance, in the cycle <code>(4, 5, 6, 7)</code>, no one else can sit in that cycle unless we break it, which is not allowed.</li>
</ul>
</li>
<li>
<p><strong>Cycle with size == 2 (red cycle)</strong>:</p>
<ul>
<li>For these types of cycles, we can have multiple 2-cycles sitting next to each other. These cycles can connect with extended paths (chains of employees) as long as they don’t disrupt the seating order.</li>
<li>For example, we can allocate the employees like <code>[(0, 1), (2, 3), (8, 9), [13, 12, (11, 10), 14]]</code></li>
<li>Notice that we can also put extended paths (like the blue circles in the diagram) next to the two endpoints of the 2-cycle. This allows us to extend the cycle by adding more people without violating the seating constraints.</li>
</ul>
</li>
</ol>
<h5 id="example-2-9-14-15-8-22-15-12-11-10-7-1-12-15-6-5-12-10-21-4-1-16-3-7">Example 2: <code>[9, 14, 15, 8, 22, 15, 12, 11, 10, 7, 1, 12, 15, 6, 5, 12, 10, 21, 4, 1, 16, 3, 7]</code></h5>
<p>Check out the below diagram, as we will be referring to it in the future for explanation:</p>
<p><img src="../Figures/2127/mutual_2nd_testcase.png" alt="alt text" /></p>
<p>In this example, there are more complex cycles and paths to consider. We need to find the longest possible extended paths for each endpoint of a 2-cycle and combine them efficiently.</p>
<p><strong>Extended Path for 2-Cycles</strong>:</p>
<ul>
<li>For instance, for the 2-cycle <code>(12, 15)</code> (blue rectangle), we need to find the longest paths from each of these employees. Starting from <code>12</code>, we can trace a path: <code>[18, 4, 22, 7, 11, 12]</code>, and from <code>15</code>, we trace a path: <code>[17, 21, 3, 8, 10, 1, 14, 5, 15]</code>.</li>
</ul>
<p>The idea is that these paths can be connected to the cycle, forming larger groups of people that can sit together.</p>
<p>So our core solution consists of three parts:</p>
<ol>
<li>
<p><strong>Cycle Detection</strong>:</p>
<ul>
<li>Since every node points to exactly one other node (the favorite person), the graph is simple. We can detect cycles by walking through the graph from unexplored nodes and stopping when we revisit an already visited node. This works well because each node has at most one outgoing edge, simplifying the process.</li>
</ul>
</li>
<li>
<p><strong>Finding the Longest Path</strong>:</p>
<ul>
<li>Once we have detected all the cycles, we need to handle two cases:
<ul>
<li>Single cycle with size &gt; 2: We treat it as a unit and cannot add more people.</li>
<li>Multiple 2-cycles: We look for the longest extended path for each endpoint of a 2-cycle, using <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS</a> or <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">DFS</a> to find the longest path starting from each of the two mutual-favoriting people. The maximum possible length for any group is the sum of the longest paths from both endpoints plus 2 (for the mutual-favoriting people themselves).</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="../Figures/2127/mutual_favs.png" alt="mutual_favs" /></p>
<ol start="3">
<li><strong>Final Comparison</strong>:
<ul>
<li>Once we have the maximum length from extended paths and the size of the largest cycle, we simply compare these two values. The answer is the larger of the two, as that represents the maximum number of employees that can be seated together.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="approach-1-cycle-detection-with-extended-paths">Approach 1: Cycle Detection with Extended Paths</h3>
<h4 id="intuition">Intuition</h4>
<p>From the overview, the problem boils down to identifying cycles in the directed graph, determining how chains can be connected, and ensuring that employees are seated next to their favorites.</p>
<p>To implement this, we first need to create a graph that represents the relationships between people based on their favorite person. This is done by constructing a reversed graph where each person points to the people who have them as their favorite. This structure allows us to easily trace back to the people that lead into each person’s chain.</p>
<p>Next, we iterate through the graph nodes. If a node hasn’t been visited, we start a traversal, tracking visited nodes and the distance from the start using a map.</p>
<ul>
<li>If a node is visited during the traversal, we've detected a cycle. The cycle length is the difference in the distances at which we first encounter and revisit the node.</li>
<li>A cycle length greater than 2 forms a self-contained group, which we compare with the largest cycle found.</li>
</ul>
<p>When we detect a two-node cycle (mutual favorites), the approach changes slightly. In this case, the cycle itself only accounts for two people, so we look for the longest chains that lead into both people of the cycle. This is done by implementing a <strong>BFS</strong> function that explores the reversed graph and finds the maximum path leading into each of the two nodes forming the cycle. The length of the chain for each node is determined by how far we can trace back in the graph.</p>
<ul>
<li>Once we know the longest chain for each of the two nodes, we calculate the total size of the group by adding the two chain lengths plus 2 (for the two people in the cycle itself). This extended group size is then added to the total count of two-node cycle groups.</li>
</ul>
<p>Finally, the result is the larger of the largest standalone cycle or the largest extended group from the two-node cycle. This ensures the largest valid seating arrangement is found.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize a variable <code>n</code> to store the size of the <code>favorite</code> array, and create a <code>reversedGraph</code> to store the reversed edges (in this case, favorite relationships).</p>
</li>
<li>
<p>Build the reversed graph:</p>
<ul>
<li>Iterate through each person in the <code>favorite</code> array, and for each person, add them to the reversed graph using <code>favorite[person]</code> as the key.</li>
</ul>
</li>
<li>
<p>Define a helper function <code>bfs</code> to perform breadth-first search:</p>
<ul>
<li>Initialize a queue to hold the node and its distance.</li>
<li>Process each node in the queue and explore its neighbors (reverse of the favorite relationship).</li>
<li>Track the maximum distance during BFS and return this value after all nodes have been visited.</li>
</ul>
</li>
<li>
<p>Initialize <code>longestCycle</code> to keep track of the length of the longest cycle found.</p>
</li>
<li>
<p>Initialize <code>twoCycleInvitations</code> to store the count of invitations for cycles of length 2.</p>
</li>
<li>
<p>Iterate through each person in the <code>favorite</code> array:</p>
<ul>
<li>If the person hasn't been visited, start detecting a cycle from that person:
<ul>
<li>Use a map <code>visitedPersons</code> to track the distance from the current node.</li>
<li>Traverse through the favorite relationships to detect cycles.</li>
<li>If a cycle is detected, calculate its length and update <code>longestCycle</code>.</li>
<li>If the cycle length is 2, calculate invitations from both nodes of the cycle by performing BFS from each node, ensuring that both nodes are marked as visited.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum of <code>longestCycle</code> and <code>twoCycleInvitations</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kYoqLnsm/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>favorite</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We build a reversed graph where each node points to its favorite. This involves iterating over all <span class="math inline">\(n\)</span> elements and adding edges, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The outer loop iterates over all <span class="math inline">\(n\)</span> people, and the inner while loop processes each person in the cycle exactly once. This ensures that each node is visited at most once, resulting in <span class="math inline">\(O(n)\)</span> time for cycle detection.</p>
<p>For cycles of length 2, we perform a BFS to calculate the maximum distance from each node in the cycle. Since each node is visited at most once during the BFS, and the BFS is performed only for 2-length cycles, the total time for this step is also <span class="math inline">\(O(n)\)</span>.</p>
<p>Since all these steps are sequential and each takes <span class="math inline">\(O(n)\)</span> time, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The reversed graph is stored as an adjacency list, which requires <span class="math inline">\(O(n)\)</span> space. The <code>visited</code> array tracks whether a node has been processed, requiring <span class="math inline">\(O(n)\)</span> space. The <code>visitedPersons</code> map stores the distance of each node in the current cycle, which can take up to <span class="math inline">\(O(n)\)</span> space in the worst case. The BFS queue and the <code>visitedNodes</code> set used for 2-length cycle processing can store up to <span class="math inline">\(O(n)\)</span> nodes in total.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-topological-sort-to-reduce-non-cyclic-nodes">Approach 2: Topological Sort to Reduce Non-Cyclic Nodes</h3>
<h4 id="intuition-1">Intuition</h4>
<p><a href="https://leetcode.com/explore/featured/card/graph/623/kahns-algorithm-for-topological-sorting/">Topological sort</a> is an algorithm traditionally used in DAGs (Directed Acyclic Graphs) to order nodes in a way that for every directed edge <code>u</code> to <code>v</code>, node <code>u</code> comes before node <code>v</code>. This ordering allows us to process nodes one by one, ensuring that we handle dependencies before processing dependent nodes.</p>
<p>However, in this context, we don't have a pure DAG because of the cycles. But we can still use topological sorting to help with eliminating non-cycle nodes and focusing on cycles that we need to handle more carefully. In fact, identifying and processing these cycles is key to finding the solution.</p>
<p>The idea is to first process nodes in topological order to remove non-cycle nodes and focus on the cycles that need further examination.</p>
<p>To implement this, we begin by calculating the in-degree for each node. The in-degree of a node indicates how many nodes point to it. In this case, the &quot;favorite&quot; relationship can be seen as a directed edge from one person to another. After populating the in-degree array, we initialize a queue that will help us with the topological sort. The queue initially contains all nodes that have an in-degree of zero (i.e., nodes with no incoming edges). These are the nodes that do not form part of any cycle and can be processed in topological order.</p>
<p>Next, we start the process of topologically sorting the nodes while calculating the depth of each node. The depth represents the longest path from any starting node to that particular node. As we process each node, we decrement the in-degree of its neighbor (as we &quot;remove&quot; the edge), and if any neighbor's in-degree becomes zero, it is added to the queue. During this process, we also update the depth of each node, ensuring that it reflects the longest path leading to that node.</p>
<p>Once the topological sort is completed and we have processed all non-cycle nodes, we move on to detect cycles. For each node that remains in the graph (i.e., nodes with a non-zero in-degree), we trace the cycle by following the favorite links. As we trace the cycle, we mark the nodes as visited by setting their in-degree to zero, and count the length of the cycle.</p>
<ul>
<li>
<p>If the cycle length is 2, we know it’s a two-person mutual favorite cycle. In this case, we add the combined depths of both nodes in the cycle to the total invitation count for two-cycles. This is because both nodes can invite the maximum number of people based on their depths.</p>
</li>
<li>
<p>For longer cycles, we simply update the longest cycle length, since a longer cycle can accommodate more people in the seating arrangement.</p>
</li>
</ul>
<p>At the end, the result is the maximum of the longest cycle length and the total size of the two-cycle groups.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a variable <code>n</code> to store the size of the <code>favorite</code> array and create an <code>inDegree</code> array to store the in-degree of each node.</p>
</li>
<li>
<p>Calculate the in-degree for each node:</p>
<ul>
<li>For each person, increment the in-degree of their favorite node.</li>
</ul>
</li>
<li>
<p>Perform topological sorting to process non-cycle nodes:</p>
<ul>
<li>Use a queue <code>q</code> to store nodes with in-degree 0 (no incoming edges).</li>
<li>For each node in the queue, update the depth of its favorite node and reduce its in-degree. If the in-degree of the favorite node becomes 0, add it to the queue.</li>
</ul>
</li>
<li>
<p>Initialize <code>longestCycle</code> and <code>twoCycleInvitations</code> to 0.</p>
</li>
<li>
<p>Detect cycles:</p>
<ul>
<li>For each person, if their in-degree is non-zero (indicating they are part of a cycle):
<ul>
<li>Track the cycle length while marking each node in the cycle as visited by setting its in-degree to <code>0</code>.</li>
<li>If the cycle length is 2, add the depth of both nodes involved in the cycle to <code>twoCycleInvitations</code>.</li>
<li>If the cycle length is greater than 2, update <code>longestCycle</code> with the maximum cycle length found.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum of <code>longestCycle</code> and <code>twoCycleInvitations</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GAkEKqjf/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>favorite</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates over all <span class="math inline">\(n\)</span> elements to calculate the in-degree of each node. This takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The second loop iterates over all <span class="math inline">\(n\)</span> elements to initialize the queue with nodes that have an in-degree of 0. The subsequent BFS-like traversal processes each node and edge exactly once, which also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The final loop iterates over all <span class="math inline">\(n\)</span> elements to detect cycles. Each node is visited at most once, and the inner while loop processes each node in the cycle exactly once. This also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Since all these steps are sequential and each takes <span class="math inline">\(O(n)\)</span> time, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>inDegree</code> array stores the in-degree of each node, which requires <span class="math inline">\(O(n)\)</span> space. The <code>depth</code> array stores the depth of each node, which also requires <span class="math inline">\(O(n)\)</span> space. The queue used for topological sorting can store up to <span class="math inline">\(O(n)\)</span> nodes in the worst case. The variables used for cycle detection and other operations require constant space, which is negligible compared to the arrays and queue.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-path-quality-of-a-graph/description" target="_blank" rel="noopener noreferrer">Maximum Path Quality of a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <strong>undirected</strong> graph with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>). You are given a <strong>0-indexed</strong> integer array <code>values</code> where <code>values[i]</code> is the <strong>value </strong>of the <code>i<sup>th</sup></code> node. You are also given a <strong>0-indexed</strong> 2D integer array <code>edges</code>, where each <code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>, time<sub>j</sub>]</code> indicates that there is an undirected edge between the nodes <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code>,<sub> </sub>and it takes <code>time<sub>j</sub></code> seconds to travel between the two nodes. Finally, you are given an integer <code>maxTime</code>.</p>

<p>A <strong>valid</strong> <strong>path</strong> in the graph is any path that starts at node <code>0</code>, ends at node <code>0</code>, and takes <strong>at most</strong> <code>maxTime</code> seconds to complete. You may visit the same node multiple times. The <strong>quality</strong> of a valid path is the <strong>sum</strong> of the values of the <strong>unique nodes</strong> visited in the path (each node&#39;s value is added <strong>at most once</strong> to the sum).</p>

<p>Return <em>the <strong>maximum</strong> quality of a valid path</em>.</p>

<p><strong>Note:</strong> There are <strong>at most four</strong> edges connected to each node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex1drawio.png" style="width: 269px; height: 170px;" />
<pre>
<strong>Input:</strong> values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
<strong>Output:</strong> 75
<strong>Explanation:</strong>
One possible path is 0 -&gt; 1 -&gt; 0 -&gt; 3 -&gt; 0. The total time taken is 10 + 10 + 10 + 10 = 40 &lt;= 49.
The nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex2drawio.png" style="width: 269px; height: 170px;" />
<pre>
<strong>Input:</strong> values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
<strong>Output:</strong> 25
<strong>Explanation:</strong>
One possible path is 0 -&gt; 3 -&gt; 0. The total time taken is 10 + 10 = 20 &lt;= 30.
The nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex31drawio.png" style="width: 236px; height: 170px;" />
<pre>
<strong>Input:</strong> values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
<strong>Output:</strong> 7
<strong>Explanation:</strong>
One possible path is 0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0. The total time taken is 10 + 13 + 13 + 10 = 46 &lt;= 50.
The nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == values.length</code></li>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= values[i] &lt;= 10<sup>8</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2000</code></li>
	<li><code>edges[j].length == 3 </code></li>
	<li><code>0 &lt;= u<sub>j </sub>&lt; v<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>10 &lt;= time<sub>j</sub>, maxTime &lt;= 100</code></li>
	<li>All the pairs <code>[u<sub>j</sub>, v<sub>j</sub>]</code> are <strong>unique</strong>.</li>
	<li>There are <strong>at most four</strong> edges connected to each node.</li>
	<li>The graph may not be connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-profit-from-valid-topological-order-in-dag/description" target="_blank" rel="noopener noreferrer">Maximum Profit from Valid Topological Order in DAG</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>Directed Acyclic Graph (DAG)</strong> with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates a directed edge from node <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code>. Each node has an associated <strong>score</strong> given in an array <code>score</code>, where <code>score[i]</code> represents the score of node <code>i</code>.</p>

<p>You must process the nodes in a <strong>valid topological order</strong>. Each node is assigned a <strong>1-based position</strong> in the processing order.</p>

<p>The <strong>profit</strong> is calculated by summing up the product of each node&#39;s score and its position in the ordering.</p>

<p>Return the <strong>maximum </strong>possible profit achievable with an optimal topological order.</p>

<p>A <strong>topological order</strong> of a DAG is a linear ordering of its nodes such that for every directed edge <code>u &rarr; v</code>, node <code>u</code> comes before <code>v</code> in the ordering.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1]], score = [2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-021131.png" style="width: 200px; height: 89px;" /></p>

<p>Node 1 depends on node 0, so a valid order is <code>[0, 1]</code>.</p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Node</th>
			<th style="border: 1px solid black;">Processing Order</th>
			<th style="border: 1px solid black;">Score</th>
			<th style="border: 1px solid black;">Multiplier</th>
			<th style="border: 1px solid black;">Profit Calculation</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1st</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2 &times; 1 = 2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2nd</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3 &times; 2 = 6</td>
		</tr>
	</tbody>
</table>

<p>The maximum total profit achievable over all valid topological orders is <code>2 + 6 = 8</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1],[0,2]], score = [1,6,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">25</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-023558.png" style="width: 200px; height: 124px;" /></p>

<p>Nodes 1 and 2 depend on node 0, so the most optimal valid order is <code>[0, 2, 1]</code>.</p>

<table data-end="1197" data-start="851" node="[object Object]" style="border: 1px solid black;">
	<thead data-end="920" data-start="851">
		<tr data-end="920" data-start="851">
			<th data-end="858" data-start="851" style="border: 1px solid black;">Node</th>
			<th data-end="877" data-start="858" style="border: 1px solid black;">Processing Order</th>
			<th data-end="885" data-start="877" style="border: 1px solid black;">Score</th>
			<th data-end="898" data-start="885" style="border: 1px solid black;">Multiplier</th>
			<th data-end="920" data-start="898" style="border: 1px solid black;">Profit Calculation</th>
		</tr>
	</thead>
	<tbody data-end="1197" data-start="991">
		<tr data-end="1059" data-start="991">
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1st</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1 &times; 1 = 1</td>
		</tr>
		<tr data-end="1128" data-start="1060">
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2nd</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3 &times; 2 = 6</td>
		</tr>
		<tr data-end="1197" data-start="1129">
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">3rd</td>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">6 &times; 3 = 18</td>
		</tr>
	</tbody>
</table>

<p>The maximum total profit achievable over all valid topological orders is <code>1 + 6 + 18 = 25</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == score.length &lt;= 22</code></li>
	<li><code>1 &lt;= score[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a directed edge from <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code>.</li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-of-a-node-sequence/description" target="_blank" rel="noopener noreferrer">Maximum Score of a Node Sequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>scores</code> of length <code>n</code> where <code>scores[i]</code> denotes the score of node <code>i</code>. You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>A node sequence is <b>valid</b> if it meets the following conditions:</p>

<ul>
	<li>There is an edge connecting every pair of <strong>adjacent</strong> nodes in the sequence.</li>
	<li>No node appears more than once in the sequence.</li>
</ul>

<p>The score of a node sequence is defined as the <strong>sum</strong> of the scores of the nodes in the sequence.</p>

<p>Return <em>the <strong>maximum score</strong> of a valid node sequence with a length of </em><code>4</code><em>. </em>If no such sequence exists, return<em> </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png" style="width: 290px; height: 215px;" />
<pre>
<strong>Input:</strong> scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
<strong>Output:</strong> 24
<strong>Explanation:</strong> The figure above shows the graph and the chosen node sequence [0,1,2,3].
The score of the node sequence is 5 + 2 + 9 + 8 = 24.
It can be shown that no other node sequence has a score of more than 24.
Note that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.
The sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/17/ex2.png" style="width: 333px; height: 151px;" />
<pre>
<strong>Input:</strong> scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The figure above shows the graph.
There are no valid node sequences of length 4, so we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == scores.length</code></li>
	<li><code>4 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= scores[i] &lt;= 10<sup>8</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-star-sum-of-a-graph/description" target="_blank" rel="noopener noreferrer">Maximum Star Sum of a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected graph consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. You are given a <strong>0-indexed</strong> integer array <code>vals</code> of length <code>n</code> where <code>vals[i]</code> denotes the value of the <code>i<sup>th</sup></code> node.</p>

<p>You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i.</sub></code></p>

<p>A <strong>star graph</strong> is a subgraph of the given graph having a center node containing <code>0</code> or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.</p>

<p>The image below shows star graphs with <code>3</code> and <code>4</code> neighbors respectively, centered at the blue node.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-descdrawio.png" style="width: 400px; height: 179px;" />
<p>The <strong>star sum</strong> is the sum of the values of all the nodes present in the star graph.</p>

<p>Given an integer <code>k</code>, return <em>the <strong>maximum star sum</strong> of a star graph containing <strong>at most</strong> </em><code>k</code><em> edges.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-example1drawio.png" style="width: 300px; height: 291px;" />
<pre>
<strong>Input:</strong> vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
<strong>Output:</strong> 16
<strong>Explanation:</strong> The above diagram represents the input graph.
The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.
It can be shown it is not possible to get a star graph with a sum greater than 16.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> vals = [-5], edges = [], k = 0
<strong>Output:</strong> -5
<strong>Explanation:</strong> There is only one possible star graph, which is node 0 itself.
Hence, we return -5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == vals.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= vals[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2</code><code>, 10<sup>5</sup>)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>0 &lt;= k &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-of-edge-values-in-a-graph/description" target="_blank" rel="noopener noreferrer">Maximum Sum of Edge Values in a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <strong>undirected connected</strong> graph of <code>n</code> nodes, numbered from <code>0</code> to <code>n - 1</code>. Each node is connected to <strong>at most</strong> 2 other nodes.</p>

<p>The graph consists of <code>m</code> edges, represented by a 2D array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p data-end="502" data-start="345">You have to assign a <strong>unique</strong> value from <code data-end="391" data-start="388">1</code> to <code data-end="398" data-start="395">n</code> to each node. The value of an edge will be the <strong>product</strong> of the values assigned to the two nodes it connects.</p>

<p data-end="502" data-start="345">Your score is the sum of the values of all edges in the graph.</p>

<p>Return the <strong>maximum</strong> score you can achieve.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/05/12/screenshot-from-2025-05-13-01-27-52.png" style="width: 411px; height: 123px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges =&nbsp;</span>[[0,1],[1,2],[2,3]]</p>

<p><strong>Output:</strong> 23</p>

<p><strong>Explanation:</strong></p>

<p>The diagram above illustrates an optimal assignment of values to nodes. The sum of the values of the edges is: <code>(1 * 3) + (3 * 4) + (4 * 2) = 23</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/23/graphproblemex2drawio.png" style="width: 220px; height: 255px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 6, edges = [[0,3],[4,5],[2,0],[1,3],[2,4],[1,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">82</span></p>

<p><strong>Explanation:</strong></p>

<p>The diagram above illustrates an optimal assignment of values to nodes. The sum of the values of the edges is: <code>(1 * 2) + (2 * 4) + (4 * 6) + (6 * 5) + (5 * 3) + (3 * 1) = 82</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= m &lt;= n</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
	<li>The graph is connected.</li>
	<li>Each node is connected to at most 2 other nodes.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-importance-of-roads/description" target="_blank" rel="noopener noreferrer">Maximum Total Importance of Roads</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> denoting the number of cities in a country. The cities are numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are also given a 2D integer array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists a <strong>bidirectional</strong> road connecting cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>You need to assign each city with an integer value from <code>1</code> to <code>n</code>, where each value can only be used <strong>once</strong>. The <strong>importance</strong> of a road is then defined as the <strong>sum</strong> of the values of the two cities it connects.</p>

<p>Return <em>the <strong>maximum total importance</strong> of all roads possible after assigning the values optimally.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/07/ex1drawio.png" style="width: 290px; height: 215px;" />
<pre>
<strong>Input:</strong> n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
<strong>Output:</strong> 43
<strong>Explanation:</strong> The figure above shows the country and the assigned values of [2,4,5,3,1].
- The road (0,1) has an importance of 2 + 4 = 6.
- The road (1,2) has an importance of 4 + 5 = 9.
- The road (2,3) has an importance of 5 + 3 = 8.
- The road (0,2) has an importance of 2 + 5 = 7.
- The road (1,3) has an importance of 4 + 3 = 7.
- The road (2,4) has an importance of 5 + 1 = 6.
The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.
It can be shown that we cannot obtain a greater total importance than 43.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/07/ex2drawio.png" style="width: 281px; height: 151px;" />
<pre>
<strong>Input:</strong> n = 5, roads = [[0,3],[2,4],[1,3]]
<strong>Output:</strong> 20
<strong>Explanation:</strong> The figure above shows the country and the assigned values of [4,3,2,5,1].
- The road (0,3) has an importance of 4 + 5 = 9.
- The road (2,4) has an importance of 2 + 1 = 3.
- The road (1,3) has an importance of 3 + 5 = 8.
The total importance of all roads is 9 + 3 + 8 = 20.
It can be shown that we cannot obtain a greater total importance than 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= roads.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>roads[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no duplicate roads.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-sorting">Approach: Sorting</h3>
<h4 id="intuition">Intuition</h4>
<p>We have <code>N</code> cities (nodes) numbered <code>0</code> to <code>N-1</code>, connected by bidirectional roads (edges). Our task is to assign unique values from <code>1</code> to <code>N</code> to each node, maximizing the total importance of all edges.</p>
<p>Edge importance is defined as the sum of the values of the nodes it connects.</p>
<p>Key observation: A node's value contributes to importance once for each connected edge. This means that nodes with more connections (higher degree) should be assigned higher values.</p>
<p>We can solve the problem in three steps:</p>
<ol>
<li>Calculate the degree of each node (number of connected edges).</li>
<li>Sort nodes by degree in ascending order.</li>
<li>Assign values <code>1</code> to <code>N</code> to nodes, starting with the lowest degree.</li>
</ol>
<p>Note that there might be a case where two or more nodes have the same degree; in such cases, the values assigned to the nodes can be swapped. This is because the importance sum of all the edges will remain the same, as shown in the figure below:</p>
<p><img src="../Figures/2285/2285A.png" alt="fig" /></p>
<p>If we notice now the entire approach we just translated the graph structure into a numerical assignment problem, leveraging the relationship between node connectivity and edge importance.</p>
<p><img src="../Figures/2285/2285A.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array <code>degree</code> of size <code>N</code> to store the degree of each node. Initially, all values are <code>0</code>.</li>
<li>Iterate over the list of edges <code>roads</code> and increment the degree for each of the nodes the road connects, i.e. <code>edge[0]</code> and <code>edge[1]</code>.</li>
<li>Sort the array <code>degree</code> in the ascending order.</li>
<li>Initialize the variable <code>value</code> to <code>1</code>, this will be the value we assign to the nodes.</li>
<li>Initialize the variable <code>totalImportance</code> to <code>0</code> to store the maximum importance of all edges.</li>
<li>Iterate over the array <code>degree</code> and keep adding the importance as <code>node degree * assigned value</code> to the variable <code>totalImportance</code>. Also, increment the value <code>value</code> to assign it to the next node.</li>
<li>Return <code>totalImportance</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8ETbhAuN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span>.</p>
<p>We iterate over the edges list <code>roads</code> to find the degree of each node. In the worst case, the number of edges in the graph could reach <span class="math inline">\(N^2\)</span>, assuming an edge exists between every pair of nodes. Assigning degrees thus requires <span class="math inline">\(O(N^2)\)</span> operations.<br />
Next, sorting the degrees in ascending order takes <span class="math inline">\(O(N \log N)\)</span>. Iterating through the degree array to calculate the total importance is an <span class="math inline">\(O(N)\)</span> operation. Therefore, the overall time complexity remains <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need an array of size <span class="math inline">\(N\)</span>, <code>degree</code>, to keep the edge count of each node.</p>
<p>Some additional space is required for sorting. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>Thus, the inbuilt <code>sort()</code> function might add up to <span class="math inline">\(O(\log⁡⁡ N)\)</span> or <span class="math inline">\(O(N)\)</span> to the space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-weighted-k-edge-path/description" target="_blank" rel="noopener noreferrer">Maximum Weighted K-Edge Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and a <strong>Directed Acyclic Graph (DAG)</strong> with <code>n</code> nodes labeled from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> indicates a directed edge from node <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>You are also given two integers, <code>k</code> and <code>t</code>.</p>

<p>Your task is to determine the <strong>maximum</strong> possible sum of edge weights for any path in the graph such that:</p>

<ul>
	<li>The path contains <strong>exactly</strong> <code>k</code> edges.</li>
	<li>The total sum of edge weights in the path is <strong>strictly</strong> less than <code>t</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> possible sum of weights for such a path. If no such path exists, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,1],[1,2,2]], k = 2, t = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/04/09/screenshot-2025-04-10-at-061326.png" style="width: 180px; height: 162px;" /></p>

<ul>
	<li>The only path with <code>k = 2</code> edges is <code>0 -&gt; 1 -&gt; 2</code> with weight <code>1 + 2 = 3 &lt; t</code>.</li>
	<li>Thus, the maximum possible sum of weights less than <code>t</code> is 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[0,2,3]], k = 1, t = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/04/09/screenshot-2025-04-10-at-061406.png" style="width: 180px; height: 164px;" /></p>

<ul>
	<li>There are two paths with <code>k = 1</code> edge:

	<ul>
		<li><code>0 -&gt; 1</code> with weight <code>2 &lt; t</code>.</li>
		<li><code>0 -&gt; 2</code> with weight <code>3 = t</code>, which is not strictly less than <code>t</code>.</li>
	</ul>
	</li>
	<li>Thus, the maximum possible sum of weights less than <code>t</code> is 2.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,6],[1,2,8]], k = 1, t = 6</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/04/09/screenshot-2025-04-10-at-061442.png" style="width: 180px; height: 154px;" /></p>

<ul>
	<li>There are two paths with k = 1 edge:
	<ul>
		<li><code>0 -&gt; 1</code> with weight <code>6 = t</code>, which is not strictly less than <code>t</code>.</li>
		<li><code>1 -&gt; 2</code> with weight <code>8 &gt; t</code>, which is not strictly less than <code>t</code>.</li>
	</ul>
	</li>
	<li>Since there is no path with sum of weights strictly less than <code>t</code>, the answer is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 300</code></li>
	<li><code>0 &lt;= edges.length &lt;= 300</code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10</code></li>
	<li><code>0 &lt;= k &lt;= 300</code></li>
	<li><code>1 &lt;= t &lt;= 600</code></li>
	<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-weight-node--170645/1" target="_blank" rel="noopener noreferrer">Maximum Weight Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a maze with <strong>n</strong> cells. Each cell may have <strong>multiple entry points</strong> but <strong>not more than one exit point</strong> (i.e entry/exit points are unidirectional doors like valves).</span></p>
<p><span style="font-size: 18px;">You are given an array <strong>exits[]</strong>,&nbsp;where<strong> exits[i] </strong>contains the exit point of the ith cell.<br />If <strong>exits[i]</strong> is <strong>-1,</strong> then ith cell doesn't have an exit. </span></p>
<p><span style="font-size: 18px;">The task is to find the cell with&nbsp;<strong>maximum weight </strong>(The <strong>weight</strong> of a cell <strong>i</strong> is the <strong>sum of all the cell indexes</strong> that have <strong>exit point</strong> as <strong>i </strong>). If there are multiple cells with the maximum weight return the cell with highest index.</span></p>
<p><span style="font-size: 18px;"><strong>Note:&nbsp;</strong>The cells are indexed with an integer value from 0 to n-1.<br />A cell <strong>i</strong> has <strong>weight 0</strong> if <strong>no cell</strong> has <strong>exit point</strong> as <strong>i.</strong></span></p>
<p><span style="font-size: 18px;"><strong><strong>Examples:</strong></strong></span></p>
<pre><span style="font-size: 18px;"><strong><strong>Input: </strong></strong>exits[] = [2, 0, -1, 2}<strong>
<strong>Output:</strong> </strong>2<strong>
<strong>Explanation</strong>: 
</strong>1 -&gt; 0 -&gt; 2 &lt;- 3
weight of 0th cell = 1
weight of 1st cell = 0 (because there is no cell pointing to the 1st cell)
weight of 2nd cell = 0+3 = 3
weight of 3rd cell = 0
There is only one cell which has maximum weight (i.e 2)<br />So, cell 2 is the output.</span></pre>
<pre><span style="font-size: 18px;"><strong><strong>Input: </strong></strong>exits[] = [-1]<strong>
<strong>Output:</strong> </strong>0<strong>
<strong>Explanation</strong>:
</strong>weight of 0<sup>th</sup> cell is 0.
There is only one cell so cell 0 has maximum weight.
</span></pre>
<p><span style="font-size: 18px;"><strong><strong>Constraints:</strong></strong><br />1 &nbsp;&le; &nbsp;n &nbsp;&le; &nbsp;10<sup>5</sup><br />-1 &nbsp;<u>&lt;</u>&nbsp; exits[i] &nbsp;&lt; &nbsp;N<br />exits[i] &nbsp;&ne; &nbsp;i</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/min-cost-to-connect-all-points/description" target="_blank" rel="noopener noreferrer">Min Cost to Connect All Points</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>points</code> representing integer coordinates of some points on a 2D-plane, where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p>

<p>The cost of connecting two points <code>[x<sub>i</sub>, y<sub>i</sub>]</code> and <code>[x<sub>j</sub>, y<sub>j</sub>]</code> is the <strong>manhattan distance</strong> between them: <code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>, where <code>|val|</code> denotes the absolute value of <code>val</code>.</p>

<p>Return <em>the minimum cost to make all points connected.</em> All points are connected if there is <strong>exactly one</strong> simple path between any two points.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/d.png" style="width: 214px; height: 268px;" />
<pre>
<strong>Input:</strong> points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
<strong>Output:</strong> 20
<strong>Explanation:</strong> 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/c.png" style="width: 214px; height: 268px;" />
We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> points = [[3,12],[-2,5],[-4,1]]
<strong>Output:</strong> 18
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= points.length &lt;= 1000</code></li>
	<li><code>-10<sup>6</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>All pairs <code>(x<sub>i</sub>, y<sub>i</sub>)</code> are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-malware-spread/description" target="_blank" rel="noopener noreferrer">Minimize Malware Spread</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>

<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>

<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove <strong>exactly one node</strong> from <code>initial</code>.</p>

<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>

<p>Note that if a node was removed from the <code>initial</code> list of infected nodes, it might still be infected later due to the malware spread.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;= n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<p><strong>Intuition</strong></p>
<p>First, let's color (the nodes of) each component of the graph.  We can do this using a depth first search.</p>
<p>Afterwards, notice that if two nodes in <code>initial</code> have the same color (ie., belong to the same component), then removing them from <code>initial</code> won't decrease <code>M(initial)</code>.  This is because the malware will spread to reach every node in this component no matter what.</p>
<p>So, among nodes with a unique color in <code>initial</code>, we will remove the node with the largest component size.  (If there's a tie, we return the smallest index.  Also, if there aren't any nodes with a unique color, we'll just return the smallest index node.)</p>
<p><strong>Algorithm</strong></p>
<p>This algorithm has a few parts:</p>
<ul>
<li>
<p><strong>Coloring each component:</strong>  For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.</p>
</li>
<li>
<p><strong>Size of each color:</strong>  Count the number of occurrences of each color.</p>
</li>
<li>
<p><strong>Find unique colors:</strong>  Look at the colors of nodes in <code>initial</code> to see which nodes have unique colors.</p>
</li>
<li>
<p><strong>Choose answer:</strong>  For each node with a unique color, find the size of that color.  The largest size is selected, with ties broken by lowest node number.</p>
<ul>
<li>If there is no node with a unique color, the answer is <code>min(initial)</code>.</li>
</ul>
</li>
</ul>
<p><a href="https://leetcode.com/playground/cW9BUkVC/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-union-find">Approach 2: Union-Find</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>As in <em>Approach 1</em>, it is clear that we will need to consider components of the graph.  A &quot;Disjoint Set Union&quot; (DSU) data structure is ideal for this.</p>
<p>We will skip the explanation of how a DSU structure is implemented.  Please refer to <a href="https://leetcode.com/problems/redundant-connection/solution/">https://leetcode.com/problems/redundant-connection/solution/</a> for a tutorial on DSU.</p>
<p>To our DSU, we can keep a side count of the size of each component.  Whenever we union two components together, the size of those components are added.</p>
<p>With these details neatly handled by our DSU structure, we can continue in a similar manner to <em>Approach 1</em>: for each node in <code>initial</code> with a unique color, we will consider it as a candidate answer.  If no node in <code>initial</code> have a unique color, then we will take <code>min(initial)</code> as the answer.</p>
<p>Note that for brevity, our <code>DSU</code> implementation does not use union-by-rank.  This makes the asymptotic time complexity larger.</p>
<p><a href="https://leetcode.com/playground/ZQNiCZd5/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-malware-spread-ii/description" target="_blank" rel="noopener noreferrer">Minimize Malware Spread II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>

<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>

<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>

<p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>

<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-maximum-component-cost/description" target="_blank" rel="noopener noreferrer">Minimize Maximum Component Cost</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="331" data-start="85">You are given an undirected connected graph with <code data-end="137" data-start="134">n</code> nodes labeled from 0 to <code data-end="171" data-start="164">n - 1</code> and a 2D integer array <code data-end="202" data-start="195">edges</code> where <code data-end="234" data-start="209">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> denotes an undirected edge between node <code data-end="279" data-start="275">u<sub>i</sub></code> and node <code data-end="293" data-start="289">v<sub>i</sub></code> with weight <code data-end="310" data-start="306">w<sub>i</sub></code>, and an integer <code data-end="330" data-start="327">k</code>.</p>

<p data-end="461" data-start="333">You are allowed to remove any number of edges from the graph such that the resulting graph has <strong>at most</strong> <code data-end="439" data-start="436">k</code> connected components.</p>

<p data-end="589" data-start="463">The <strong>cost</strong> of a component is defined as the <strong>maximum</strong> edge weight in that component. If a component has no edges, its cost is 0.</p>

<p data-end="760" data-start="661">Return the <strong>minimum</strong> possible value of the <strong>maximum</strong> cost among all components <strong data-end="759" data-start="736">after such removals</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minimizemaximumm.jpg" style="width: 535px; height: 225px;" /></p>

<ul>
	<li data-end="1070" data-start="1021">Remove the edge between nodes 3 and 4 (weight 6).</li>
	<li data-end="1141" data-start="1073">The resulting components have costs of 0 and 4, so the overall maximum cost is 4.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minmax2.jpg" style="width: 315px; height: 55px;" /></p>

<ul>
	<li data-end="1315" data-start="1251">No edge can be removed, since allowing only one component (<code>k = 1</code>) requires the graph to stay fully connected.</li>
	<li data-end="1389" data-start="1318">That single component&rsquo;s cost equals its largest edge weight, which is 5.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li>The input graph is connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/description" target="_blank" rel="noopener noreferrer">Minimize the Maximum Edge Weight of Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers, <code>n</code> and <code>threshold</code>, as well as a <strong>directed</strong> weighted graph of <code>n</code> nodes numbered from 0 to <code>n - 1</code>. The graph is represented by a <strong>2D</strong> integer array <code>edges</code>, where <code>edges[i] = [A<sub>i</sub>, B<sub>i</sub>, W<sub>i</sub>]</code> indicates that there is an edge going from node <code>A<sub>i</sub></code> to node <code>B<sub>i</sub></code> with weight <code>W<sub>i</sub></code>.</p>

<p>You have to remove some edges from this graph (possibly <strong>none</strong>), so that it satisfies the following conditions:</p>

<ul>
	<li>Node 0 must be reachable from all other nodes.</li>
	<li>The <strong>maximum</strong> edge weight in the resulting graph is <strong>minimized</strong>.</li>
	<li>Each node has <strong>at most</strong> <code>threshold</code> outgoing edges.</li>
</ul>

<p>Return the <strong>minimum</strong> possible value of the <strong>maximum</strong> edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s-1.png" style="width: 300px; height: 233px;" /></p>

<p>Remove the edge <code>2 -&gt; 0</code>. The maximum weight among the remaining edges is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>It is impossible to reach node 0 from node 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s2-1.png" style="width: 300px; height: 267px;" /></p>

<p>Remove the edges <code>1 -&gt; 3</code> and <code>1 -&gt; 4</code>. The maximum weight among the remaining edges is 2.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= threshold &lt;= n - 1</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2).</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= A<sub>i</sub>, B<sub>i</sub> &lt; n</code></li>
	<li><code>A<sub>i</sub> != B<sub>i</sub></code></li>
	<li><code>1 &lt;= W<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>There <strong>may be</strong> multiple edges between a pair of nodes, but they must have unique weights.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-total-price-of-the-trips/description" target="_blank" rel="noopener noreferrer">Minimize the Total Price of the Trips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exists an undirected and unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given the integer <code>n</code> and a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>Each node has an associated price. You are given an integer array <code>price</code>, where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> node.</p>

<p>The <strong>price sum</strong> of a given path is the sum of the prices of all nodes lying on that path.</p>

<p>Additionally, you are given a 2D integer array <code>trips</code>, where <code>trips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> indicates that you start the <code>i<sup>th</sup></code> trip from the node <code>start<sub>i</sub></code> and travel to the node <code>end<sub>i</sub></code> by any path you like.</p>

<p>Before performing your first trip, you can choose some <strong>non-adjacent</strong> nodes and halve the prices.</p>

<p>Return <em>the minimum total price sum to perform all the given trips</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/16/diagram2.png" style="width: 541px; height: 181px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
<strong>Output:</strong> 23
<strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.
For the 1<sup>st</sup> trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.
For the 2<sup>nd</sup> trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.
For the 3<sup>rd</sup> trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.
The total price sum of all trips is 6 + 7 + 10 = 23.
It can be proven, that 23 is the minimum answer that we can achieve.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/16/diagram3.png" style="width: 456px; height: 111px;" />
<pre>
<strong>Input:</strong> n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.
For the 1<sup>st</sup> trip, we choose path [0]. The price sum of that path is 1.
The total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>price.length == n</code></li>
	<li><code>price[i]</code> is an even integer.</li>
	<li><code>1 &lt;= price[i] &lt;= 1000</code></li>
	<li><code>1 &lt;= trips.length &lt;= 100</code></li>
	<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub>&nbsp;&lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-of-a-path-with-special-roads/description" target="_blank" rel="noopener noreferrer">Minimum Cost of a Path With Special Roads</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>start</code> where <code>start = [startX, startY]</code> represents your initial position <code>(startX, startY)</code> in a 2D space. You are also given the array <code>target</code> where <code>target = [targetX, targetY]</code> represents your target position <code>(targetX, targetY)</code>.</p>

<p>The <strong>cost</strong> of going from a position <code>(x1, y1)</code> to any other position in the space <code>(x2, y2)</code> is <code>|x2 - x1| + |y2 - y1|</code>.</p>

<p>There are also some <strong>special roads</strong>. You are given a 2D array <code>specialRoads</code> where <code>specialRoads[i] = [x1<sub>i</sub>, y1<sub>i</sub>, x2<sub>i</sub>, y2<sub>i</sub>, cost<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> special road goes in <strong>one direction</strong> from <code>(x1<sub>i</sub>, y1<sub>i</sub>)</code> to <code>(x2<sub>i</sub>, y2<sub>i</sub>)</code> with a cost equal to <code>cost<sub>i</sub></code>. You can use each special road any number of times.</p>

<p>Return the <strong>minimum</strong> cost required to go from <code>(startX, startY)</code> to <code>(targetX, targetY)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<ol>
	<li>(1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1.</li>
	<li>(1,2) to (3,3). Use <code><span class="example-io">specialRoads[0]</span></code><span class="example-io"> with</span><span class="example-io"> the cost 2.</span></li>
	<li><span class="example-io">(3,3) to (3,4) with a cost of |3 - 3| + |4 - 3| = 1.</span></li>
	<li><span class="example-io">(3,4) to (4,5). Use </span><code><span class="example-io">specialRoads[1]</span></code><span class="example-io"> with the cost</span><span class="example-io"> 1.</span></li>
</ol>

<p><span class="example-io">So the total cost is 1 + 2 + 1 + 1 = 5.</span></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [3,2], target = [5,7], specialRoads = [[5,7,3,2,1],[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">7</span></p>

<p><strong>Explanation:</strong></p>

<p>It is optimal not to use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7.</p>

<p>Note that the <span class="example-io"><code>specialRoads[0]</code> is directed from (5,7) to (3,2).</span></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [1,1], target = [10,4], specialRoads = [[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<ol>
	<li>(1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1.</li>
	<li>(1,2) to (7,4). Use <code><span class="example-io">specialRoads[1]</span></code><span class="example-io"> with the cost</span><span class="example-io"> 4.</span></li>
	<li>(7,4) to (10,4) with a cost of |10 - 7| + |4 - 4| = 3.</li>
</ol>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>start.length == target.length == 2</code></li>
	<li><code>1 &lt;= startX &lt;= targetX &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= startY &lt;= targetY &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= specialRoads.length &lt;= 200</code></li>
	<li><code>specialRoads[i].length == 5</code></li>
	<li><code>startX &lt;= x1<sub>i</sub>, x2<sub>i</sub> &lt;= targetX</code></li>
	<li><code>startY &lt;= y1<sub>i</sub>, y2<sub>i</sub> &lt;= targetY</code></li>
	<li><code>1 &lt;= cost<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-cost-path3833/1" target="_blank" rel="noopener noreferrer">Minimum Cost Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square <strong>grid </strong>of size <strong>N</strong>, each cell of which contains an integer cost that represents a cost to traverse through that cell, we need to find a <strong>path</strong> from the <strong>top</strong> <strong>left</strong> cell to the <strong>bottom</strong> <strong>right</strong> cell by which the total cost incurred is <strong>minimum</strong>.<br />From the cell (i,j) we can go (i,j-1), (i, j+1), (i-1, j), (i+1, j). </span>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = [[9,4,9,9],<br />               [6,7,6,4],<br />               [8,3,3,7],<br />               [7,4,9,10]]
<strong>Output: </strong>43
<strong>Explanation: </strong>The minimum cost is-
9 + 4 + 7 + 3 + 3 + 7 + 10 = 43.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = [[4,4],<br />               [3,7]]
<strong>Output: </strong>14
<strong>Explanation: </strong>The minimum cost is- 4 + 3 + 7 = 14.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Constraints:</span></strong><br /><span style="font-size: 18px;">1 &le; n &le; 500<br />1 &le; cost of cells &le; 500</span></pre></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-convert-string-i/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Convert String I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>source</code> and <code>target</code>, both of length <code>n</code> and consisting of <strong>lowercase</strong> English letters. You are also given two <strong>0-indexed</strong> character arrays <code>original</code> and <code>changed</code>, and an integer array <code>cost</code>, where <code>cost[i]</code> represents the cost of changing the character <code>original[i]</code> to the character <code>changed[i]</code>.</p>

<p>You start with the string <code>source</code>. In one operation, you can pick a character <code>x</code> from the string and change it to the character <code>y</code> at a cost of <code>z</code> <strong>if</strong> there exists <strong>any</strong> index <code>j</code> such that <code>cost[j] == z</code>, <code>original[j] == x</code>, and <code>changed[j] == y</code>.</p>

<p>Return <em>the <strong>minimum</strong> cost to convert the string </em><code>source</code><em> to the string </em><code>target</code><em> using <strong>any</strong> number of operations. If it is impossible to convert</em> <code>source</code> <em>to</em> <code>target</code>, <em>return</em> <code>-1</code>.</p>

<p><strong>Note</strong> that there may exist indices <code>i</code>, <code>j</code> such that <code>original[j] == original[i]</code> and <code>changed[j] == changed[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;acbe&quot;, original = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;d&quot;], changed = [&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;e&quot;,&quot;b&quot;,&quot;e&quot;], cost = [2,5,5,1,2,20]
<strong>Output:</strong> 28
<strong>Explanation:</strong> To convert the string &quot;abcd&quot; to string &quot;acbe&quot;:
- Change value at index 1 from &#39;b&#39; to &#39;c&#39; at a cost of 5.
- Change value at index 2 from &#39;c&#39; to &#39;e&#39; at a cost of 1.
- Change value at index 2 from &#39;e&#39; to &#39;b&#39; at a cost of 2.
- Change value at index 3 from &#39;d&#39; to &#39;e&#39; at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28.
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;aaaa&quot;, target = &quot;bbbb&quot;, original = [&quot;a&quot;,&quot;c&quot;], changed = [&quot;c&quot;,&quot;b&quot;], cost = [1,2]
<strong>Output:</strong> 12
<strong>Explanation:</strong> To change the character &#39;a&#39; to &#39;b&#39; change the character &#39;a&#39; to &#39;c&#39; at a cost of 1, followed by changing the character &#39;c&#39; to &#39;b&#39; at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of &#39;a&#39; to &#39;b&#39;, a total cost of 3 * 4 = 12 is incurred.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;abce&quot;, original = [&quot;a&quot;], changed = [&quot;e&quot;], cost = [10000]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to convert source to target because the value at index 3 cannot be changed from &#39;d&#39; to &#39;e&#39;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= source.length == target.length &lt;= 10<sup>5</sup></code></li>
	<li><code>source</code>, <code>target</code> consist of lowercase English letters.</li>
	<li><code>1 &lt;= cost.length == original.length == changed.length &lt;= 2000</code></li>
	<li><code>original[i]</code>, <code>changed[i]</code> are lowercase English letters.</li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>original[i] != changed[i]</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have two strings, <code>source</code> and <code>target</code>, both of the same length. Additionally, we have three arrays: <code>original</code>, <code>changed</code>, and <code>cost</code>, each also of the same length.</p>
<p>Our task is to transform the <code>source</code> text into the <code>target</code> text using a series of character conversions. Each conversion works as follows:</p>
<ol>
<li>Identify a character in <code>source</code> that does not match the corresponding character in <code>target</code>.</li>
<li>Find this mismatched character in the <code>original</code> array.</li>
<li>Replace it with the corresponding character from the <code>changed</code> array.</li>
<li>Each conversion has a cost specified in the <code>cost</code> array.</li>
</ol>
<p>The goal is to determine the minimum total cost required to transform <code>source</code> into <code>target</code>.</p>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>Our task is to convert each mismatched character at the lowest possible cost. To tackle this, we can model each character as a node in a graph, with transformations represented as directed edges between nodes, each with a specific cost. The problem then becomes finding the minimum cost path from each character in <code>source</code> to the corresponding character in <code>target</code>.</p>
<p>Consider Example 1 from the problem description visualized as a graph:</p>
<p><img src="../Figures/2976/graph.png" alt="Graph Representation" /></p>
<p>To find the minimum cost path between nodes, Dijkstra's Single Source Shortest Path algorithm is useful. It efficiently calculates the shortest path in a directed graph with non-negative edge weights. For more information, refer to this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Explore Card</a>.</p>
<p>First, create a graph structure using an adjacency list to represent all possible character conversions. For each index <code>i</code>:</p>
<ul>
<li>The character in <code>original[i]</code> is the starting point.</li>
<li>The character in <code>changed[i]</code> is the destination.</li>
<li>The value in <code>cost[i]</code> denotes the conversion cost.</li>
</ul>
<p>Each conversion is an edge in our graph, mapping potential character transformations and their costs. Instead of running Dijkstra's algorithm for every differing character, precompute the shortest path from every character to every other character. This reduces the need to execute the algorithm multiple times, leveraging the fact that there are only <span class="math inline">\(26\)</span> possible characters.</p>
<p>Finally, calculate the total minimum cost by summing the precomputed costs for each differing character in <code>source</code> and <code>target</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main method <code>minimumCost</code>:</p>
<ul>
<li>Create an <code>adjacencyList</code> with 26 entries (one for each lowercase letter).</li>
<li>Iterate through the <code>original</code> array: For each index <code>i</code>:
<ul>
<li>Add an edge to <code>adjacencyList</code> from <code>original[i]</code> to <code>changed[i]</code>, with the corresponding <code>cost[i]</code>.</li>
</ul>
</li>
<li>For each of the <span class="math inline">\(26\)</span> characters, call <code>dijkstra</code> to find the shortest path from this character to all other characters.</li>
<li>Store the results in a 2D array <code>minConversionCosts</code> of size <span class="math inline">\(26 \times 26\)</span>.</li>
<li>Initialize a variable <code>totalCost</code> to <code>0</code>.</li>
<li>Iterate through the length of <code>source</code>:
<ul>
<li>If the character at the current position differs from <code>target</code>:
<ul>
<li>Look up the conversion cost in <code>minConversionCosts</code>:
<ul>
<li>If the conversion is impossible (cost is <code>-1</code>), return <code>-1</code>.</li>
<li>Else, add the cost to <code>totalCost</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalCost</code> as the answer.</li>
</ul>
<p>Helper method <code>dijkstra</code>:</p>
<ul>
<li>Define a method <code>dijkstra</code> with parameters: <code>startChar</code> and <code>adjacencyList</code>.</li>
<li>Create a priority queue <code>priorityQueue</code> with each element as a pair of (cost, character). Sort the queue by cost (lowest first).</li>
<li>Initialize an array <code>minCosts</code> of size <span class="math inline">\(26\)</span> with all values set to <code>-1</code> (representing unreachable positions).</li>
<li>Add <code>startChar</code> to <code>priorityQueue</code> with a cost of <code>0</code>.</li>
<li>While <code>priorityQueue</code> is not empty:
<ul>
<li>Poll a pair (<code>currentCost</code>, <code>currentChar</code>) from the queue.</li>
<li>Loop over all possible conversions from <code>currentChar</code> using the <code>adjacencyList</code>. For each <code>conversion</code> to <code>targetChar</code>:
<ul>
<li>Find the <code>newTotalCost</code> to do the conversion as <code>currentCost + conversionCost</code>.</li>
<li>If the conversion hasn't been reached yet <code>minCosts[targetChar] == -1</code>, or <code>newTotalCost</code> is less than the previous cost in <code>minCosts[targetChar]</code>:
<ul>
<li>Set <code>minCosts[targetChar]</code> as <code>newTotalCost</code>.</li>
<li>Add the pair <code>(newTotalCost, targetChar)</code> to the priority queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>minCosts</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5iVVcnzm/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>source</code> and <span class="math inline">\(m\)</span> be the length of the <code>original</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>Creating the adjacency list requires <span class="math inline">\(O(m)\)</span> time as the algorithm loops over the contents of the <code>original</code>, <code>changed</code>, and <code>cost</code> array simultaneously.</p>
<p>In our algorithm, the number of vertices is <span class="math inline">\(26\)</span> and the number of edges is <span class="math inline">\(m\)</span>, which makes the time complexity of Dijkstra's algorithm <span class="math inline">\(O((26 + m) \log 26)\)</span>. We call <code>dijkstra</code> for each of the <span class="math inline">\(26\)</span> characters. Thus, the total time complexity is <span class="math inline">\(O(26 \cdot (26 + m) \log 26)\)</span>, which can be simplified to <span class="math inline">\(O(m)\)</span>.</p>
<p>To calculate the <code>totalCost</code>, we iterate over the <code>source</code> string, which has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The total time complexity is the addition of all these elements, i.e., <span class="math inline">\(O(m) + O(n) = O(m + n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The <code>adjacencyList</code> stores all possible conversions, requiring a space complexity of <span class="math inline">\(O(m)\)</span>. <code>minConversionCosts</code> uses <span class="math inline">\(O(26 \times 26)\)</span> space, which simplifies to <span class="math inline">\(O(1)\)</span>.</p>
<p>The <code>dijkstra</code> method uses a priority queue that can store at most <span class="math inline">\(m\)</span> elements in the worst case. The array <code>minCosts</code> has a fixed size of <span class="math inline">\(26\)</span>. Thus, the total space used by the method is <span class="math inline">\(O(m)\)</span>.</p>
<p>The total space required by the algorithm is <span class="math inline">\(O(m) + O(1) + O(m)\)</span>, which simplifies to <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-floyd-warshall-algorithm">Approach 2: Floyd-Warshall Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used Dijkstra's algorithm to find the minimum cost of converting each of the 26 lowercase characters to every other character, effectively applying a single-source shortest path algorithm multiple times. Instead, we can use a multi-source shortest-path algorithm.</p>
<p><a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall's All Pairs Shortest Path</a> algorithm, an effective dynamic programming technique, calculates the minimum cost path between all pairs of vertices in a directed graph. This fits our needs perfectly since we require the minimum traversal cost between every pair of lowercase characters.</p>
<p>The Floyd-Warshall algorithm works by iterating through each vertex as a potential intermediate point for all pairs of vertices. We create a matrix <code>minCost</code>, where <code>minCost[i][j]</code> represents the minimum cost to travel from vertex <code>i</code> to <code>j</code>. The algorithm involves three nested loops to update <code>minCost[i][j]</code> by considering whether a shorter path exists through an intermediate vertex <code>k</code>. After completing these iterations, <code>minCost</code> will hold the minimum costs for all character pairs.</p>
<p>We then iterate through the <code>source</code> and <code>target</code> strings, comparing characters at each position. For differing characters, we look up the minimum conversion cost in the <code>minCost</code> matrix. If any transformation is impossible, we return <code>-1</code>; otherwise, we sum the costs to get the total minimum conversion cost.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li><code>totalCost</code> to store the total minimum cost.</li>
<li>a 2D array <code>minCost</code> to store the minimum transformation cost between any two characters.</li>
</ul>
</li>
<li>Initialize each entry in <code>minCost</code> to the maximum integer value to represent initial conversion costs.</li>
<li>Using <code>original</code>, <code>changed</code>, and <code>cost</code>, update the <code>minCost</code> array with the minimum cost for each given conversion.</li>
<li>Utilize three loops. The outermost loop runs <code>k</code> from <code>0</code> to <code>25</code>, where <code>k</code> is the character being considered as an intermediate node.
<ul>
<li>For each fixed k, the inner loops iterate over all pairs of characters <code>(i, j)</code>, where <code>i</code> and <code>j</code> are the source and destination characters respectively. For each <code>(i, j)</code>:
<ul>
<li>We check whether the current known minimum cost <code>minCost[i][j]</code> can be improved by going through the intermediate character <code>k</code>. If it can, we update <code>minCost[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate through each character of <code>source</code>:
<ul>
<li>If the character matches with <code>target</code>, continue with the next iteration.</li>
<li>Else, check <code>minCost</code> for the conversion cost:
<ul>
<li>If the conversion cost is greater than or equal to the max integer value, return <code>-1</code>.</li>
<li>Else, add the cost to <code>totalCost</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalCost</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/dnbset9z/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>source</code> and <span class="math inline">\(m\)</span> be the length of the <code>original</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>Populating <code>minCosts</code> with the initial conversion costs takes <span class="math inline">\(O(m)\)</span> time.</p>
<p>Each of the three nested loops runs <span class="math inline">\(26\)</span> times. Thus, the overall time taken is <span class="math inline">\(O(26^3) = O(1)\)</span>.</p>
<p>To calculate the <code>totalCost</code>, the algorithm loops over the <code>source</code> string, which takes linear time.</p>
<p>Thus, the time complexity of the algorithm is <span class="math inline">\(O(m) + O(1) + O(n)\)</span>, which simplifies to <span class="math inline">\(O(m + n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The <code>minCost</code> array has a fixed size of <span class="math inline">\(26 \times 26\)</span>. We do not use any other data structures dependent on the length of the input space. Thus, the algorithm has a constant space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-convert-string-ii/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Convert String II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>source</code> and <code>target</code>, both of length <code>n</code> and consisting of <strong>lowercase</strong> English characters. You are also given two <strong>0-indexed</strong> string arrays <code>original</code> and <code>changed</code>, and an integer array <code>cost</code>, where <code>cost[i]</code> represents the cost of converting the string <code>original[i]</code> to the string <code>changed[i]</code>.</p>

<p>You start with the string <code>source</code>. In one operation, you can pick a <strong>substring</strong> <code>x</code> from the string, and change it to <code>y</code> at a cost of <code>z</code> <strong>if</strong> there exists <strong>any</strong> index <code>j</code> such that <code>cost[j] == z</code>, <code>original[j] == x</code>, and <code>changed[j] == y</code>. You are allowed to do <strong>any</strong> number of operations, but any pair of operations must satisfy <strong>either</strong> of these two conditions:</p>

<ul>
	<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with either <code>b &lt; c</code> <strong>or</strong> <code>d &lt; a</code>. In other words, the indices picked in both operations are <strong>disjoint</strong>.</li>
	<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with <code>a == c</code> <strong>and</strong> <code>b == d</code>. In other words, the indices picked in both operations are <strong>identical</strong>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> cost to convert the string </em><code>source</code><em> to the string </em><code>target</code><em> using <strong>any</strong> number of operations</em>. <em>If it is impossible to convert</em> <code>source</code> <em>to</em> <code>target</code>,<em> return</em> <code>-1</code>.</p>

<p><strong>Note</strong> that there may exist indices <code>i</code>, <code>j</code> such that <code>original[j] == original[i]</code> and <code>changed[j] == changed[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;acbe&quot;, original = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;d&quot;], changed = [&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;e&quot;,&quot;b&quot;,&quot;e&quot;], cost = [2,5,5,1,2,20]
<strong>Output:</strong> 28
<strong>Explanation:</strong> To convert &quot;abcd&quot; to &quot;acbe&quot;, do the following operations:
- Change substring source[1..1] from &quot;b&quot; to &quot;c&quot; at a cost of 5.
- Change substring source[2..2] from &quot;c&quot; to &quot;e&quot; at a cost of 1.
- Change substring source[2..2] from &quot;e&quot; to &quot;b&quot; at a cost of 2.
- Change substring source[3..3] from &quot;d&quot; to &quot;e&quot; at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28. 
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;acdeeghh&quot;, original = [&quot;bcd&quot;,&quot;fgh&quot;,&quot;thh&quot;], changed = [&quot;cde&quot;,&quot;thh&quot;,&quot;ghh&quot;], cost = [1,3,5]
<strong>Output:</strong> 9
<strong>Explanation:</strong> To convert &quot;abcdefgh&quot; to &quot;acdeeghh&quot;, do the following operations:
- Change substring source[1..3] from &quot;bcd&quot; to &quot;cde&quot; at a cost of 1.
- Change substring source[5..7] from &quot;fgh&quot; to &quot;thh&quot; at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.
- Change substring source[5..7] from &quot;thh&quot; to &quot;ghh&quot; at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.
The total cost incurred is 1 + 3 + 5 = 9.
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;addddddd&quot;, original = [&quot;bcd&quot;,&quot;defgh&quot;], changed = [&quot;ddd&quot;,&quot;ddddd&quot;], cost = [100,1578]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to convert &quot;abcdefgh&quot; to &quot;addddddd&quot;.
If you select substring source[1..3] as the first operation to change &quot;abcdefgh&quot; to &quot;adddefgh&quot;, you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.
If you select substring source[3..7] as the first operation to change &quot;abcdefgh&quot; to &quot;abcddddd&quot;, you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= source.length == target.length &lt;= 1000</code></li>
	<li><code>source</code>, <code>target</code> consist only of lowercase English characters.</li>
	<li><code>1 &lt;= cost.length == original.length == changed.length &lt;= 100</code></li>
	<li><code>1 &lt;= original[i].length == changed[i].length &lt;= source.length</code></li>
	<li><code>original[i]</code>, <code>changed[i]</code> consist only of lowercase English characters.</li>
	<li><code>original[i] != changed[i]</code></li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Make at Least One Valid Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of <code>grid[i][j]</code> can be:</p>

<ul>
	<li><code>1</code> which means go to the cell to the right. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j + 1]</code>)</li>
	<li><code>2</code> which means go to the cell to the left. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j - 1]</code>)</li>
	<li><code>3</code> which means go to the lower cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i + 1][j]</code>)</li>
	<li><code>4</code> which means go to the upper cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i - 1][j]</code>)</li>
</ul>

<p>Notice that there could be some signs on the cells of the grid that point outside the grid.</p>

<p>You will initially start at the upper left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code> following the signs on the grid. The valid path does not have to be the shortest.</p>

<p>You can modify the sign on a cell with <code>cost = 1</code>. You can modify the sign on a cell <strong>one time only</strong>.</p>

<p>Return <em>the minimum cost to make the grid have at least one valid path</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid1.png" style="width: 400px; height: 390px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You will start at point (0, 0).
The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost = 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost = 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost = 1 --&gt; (3, 3)
The total cost = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid2.png" style="width: 350px; height: 341px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,3],[3,2,2],[1,1,4]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> You can follow the path from (0, 0) to (2, 2).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid3.png" style="width: 200px; height: 192px;" />
<pre>
<strong>Input:</strong> grid = [[1,2],[4,3]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 4</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Let’s consider a single cell (<code>row</code>, <code>col</code>) in the middle of the grid. To reach this cell, we can come from one of its four neighbors: above (<code>row - 1</code>, <code>col</code>), left (<code>row</code>, <code>col - 1</code>), below (<code>row + 1</code>, <code>col</code>), or right (<code>row</code>, <code>col + 1</code>). The cost to reach this cell depends on two factors: the cost of reaching one of its neighbors and the cost of moving from that neighbor to (<code>row</code>, <code>col</code>). This leads us to the conclusion that if we can compute the minimum cost to reach its neighbors, we can determine the minimum cost to reach the current cell as well.</p>
<p>This dependency on neighboring cells suggests a dynamic programming approach. Initially, it might seem logical to move right and down from the top-left corner towards the bottom-right corner, filling the grid as we go. However, this problem is more complex because paths aren’t restricted to just right or down movements. In fact, a more cost-effective path might involve going left or up, depending on the direction changes needed.</p>
<p>To solve this, we create a grid <code>minChanges</code> to store the minimum cost to reach each cell. Initially, we set all cells to infinity except for the starting cell <code>(0, 0)</code>, which starts at 0 because there’s no cost to begin there.</p>
<p>To find the minimum cost path, we use a two-pass system that repeats until we can't find any better paths:</p>
<ol>
<li>
<p><strong>Forward Pass</strong>: Starting from the top-left corner, we move towards the bottom-right corner. For each cell, we check the cost of reaching it from its neighbors above or to the left. If the neighbor’s direction naturally points to the current cell, there’s no additional cost; otherwise, it costs 1 to change direction. Using this information, we update the minimum cost for the current cell.</p>
</li>
<li>
<p><strong>Backward Pass</strong>: Starting from the bottom-right corner, we move back towards the top-left corner. This pass considers neighbors below or to the right. It’s particularly useful for uncovering paths where a roundabout route (moving up or left) results in a lower cost than a direct one.</p>
</li>
</ol>
<p>After each pass, we check if any cell’s minimum cost has changed. If not, it means we’ve found the optimal solution. Since the cost of a cell can only decrease with each iteration and cannot drop below 0, this process is guaranteed to converge.</p>
<p>Finally, the value in the bottom-right cell of the <code>minChanges</code> grid represents the minimum cost to create a valid path from the top-left to the bottom-right corner.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input <code>grid</code>.</li>
<li>Create a 2-D array <code>minChanges</code> with dimensions <code>numRows * numCols</code> to track the minimum changes needed to reach each cell.</li>
<li>Initialize all cells in the <code>minChanges</code> array to the maximum possible integer value.</li>
<li>Set the value of <code>minChanges[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter an infinite loop that will continue until convergence is reached.
<ul>
<li>Create a 2-D array <code>prevState</code> to store the previous state of <code>minChanges</code> for comparison.</li>
<li>Copy the current state of <code>minChanges</code> into <code>prevState</code>.</li>
<li>Begin the forward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from above and left</li>
<li>Update the <code>minChanges</code> value based on:
<ul>
<li>Whether the neighbor naturally points to the current cell (cost is 0).</li>
<li>Or needs to be changed to point to the current cell (cost is 1).</li>
</ul>
</li>
</ul>
</li>
<li>Begin the backward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from below and right</li>
<li>Apply the same cost calculation logic as in the forward pass.</li>
</ul>
</li>
<li>Compare prevState with the current <code>minChanges</code> array:
<ul>
<li>If they are identical, break the loop as convergence is reached.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minChanges[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cUHwszao/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n \cdot m)^2)\)</span></p>
<p>The algorithm has an outer loop that continues until convergence, where <span class="math inline">\(k\)</span> is the number of iterations needed. In each iteration, we perform a forward pass and a backward pass through the entire grid, each taking <span class="math inline">\(O(n \cdot m)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot k)\)</span>.</p>
<p>The value of <span class="math inline">\(k\)</span> depends on the grid configuration and in the worst case could be proportional to <span class="math inline">\(n \cdot m\)</span>, making the worst-case time complexity <span class="math inline">\(O((n \cdot m)^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses two 2D arrays - <code>minChanges</code> and <code>prevState</code>, each of size <span class="math inline">\(n \times m\)</span>. No additional space scaling with input size is needed. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dijkstras-algorithm">Approach 2: Dijkstra's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We start by thinking of the grid as a network of connected points (a graph). Each cell represents a point (node), and the cells are connected to their neighbors. These connections (edges) have specific costs:</p>
<ol>
<li>Cost is 0 if the sign in one cell points directly to its neighbor.</li>
<li>Cost is 1 in all other cases where we need to change the sign.</li>
</ol>
<p>This gives us a problem where we need to find the cheapest path through a directed graph, which is exactly what Dijkstra's algorithm is designed to handle.</p>
<p>With Dijkstra’s algorithm, we use a priority queue to explore cells based on their current cost, ensuring that we always process the lowest-cost paths first. We also maintain a grid, <code>minCost</code>, where each cell tracks the cheapest way to reach that cell from the start. The queue holds cells we are currently exploring, each entry containing three pieces of information: the total cost so far, and the row and column indices of the cell. The queue is organized such that cells with the lower cost are processed first, which helps us prioritize more promising paths over more expensive ones.</p>
<p>For each cell we explore, we evaluate all its four neighboring cells. To do this, we calculate the cost to reach the neighbor by adding the current cost to the cost of moving to the neighbor (either 0 or 1, depending on the sign). If this new cost is lower than the current recorded cost in <code>minCost</code>, we’ve found a better path to the neighbor, so we update the cost in <code>minCost</code> and add the neighbor to the queue for further exploration.</p>
<p>This process continues until all cells have been explored, and the queue is empty. At this point, the <code>minCost</code> grid holds the minimum cost required to reach each cell from the starting cell (top-left corner). Finally, the solution to the problem is simply the value stored in <code>minCost</code> at the bottom-right corner of the grid.</p>
<blockquote>
<p>For a more comprehensive understanding of Dijkstra's Algorithm, check out the <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card 🔗</a>. This resource provides an in-depth look at Dijkstra's Algorithm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a 2-D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</p>
</li>
<li>
<p>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</p>
</li>
<li>
<p>Create a minimum priority queue <code>pq</code> ordered by cost, where each element is a triplet [cost, row, col].</p>
</li>
<li>
<p>Add the starting position <code>[0, 0, 0]</code> to the priority queue with initial cost <code>0</code>.</p>
</li>
<li>
<p>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</p>
</li>
<li>
<p>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</p>
</li>
<li>
<p>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</p>
</li>
<li>
<p>Enter a loop that continues while the priority queue is not empty:</p>
<ul>
<li>Extract the current cell with minimum cost from the priority queue.</li>
<li>If a better path to this cell has been found, skip processing this cell.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Check if the new position is within the grid boundaries.</li>
<li>Calculate the new cost:
<ul>
<li>Add <code>0</code> if the current cell naturally points in this direction.</li>
<li>Add <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new cost is less than the previously known cost for the new position:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>Add the new position to the priority queue with its cost.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/8rasikDe/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span></p>
<p>The algorithm uses Dijkstra's algorithm with a priority queue. In the worst case, we might need to visit each cell multiple times until we find the optimal path, but no more than <span class="math inline">\(4\)</span> times per cell (once for each direction). For each cell, we perform a priority queue operation which takes <span class="math inline">\(O(\log(n \cdot m))\)</span> time, where <span class="math inline">\(n \cdot m\)</span> is the maximum size of the queue. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a priority queue that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-0-1-breadth-first-search">Approach 3: 0-1 Breadth-First Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Dijkstra's algorithm works well for finding the shortest path, but our problem has a unique feature: the path costs are either 0 or 1. This is key because any path with only 0-cost edges, no matter how long, will always be better than one that uses even a single 1-cost edge. Therefore, it makes sense to prioritize exploring 0-cost edges first. Only after all 0-cost edges have been explored, should we move on to the 1-cost edges. This insight leads us to a modification of the Breadth-First Search (BFS) algorithm, known as 0-1 BFS.</p>
<p>In 0-1 BFS, we adjust the traditional BFS by using a deque (double-ended queue) instead of a regular queue. The deque allows us to prioritize 0-cost edges more efficiently. Each element of the deque will store the row and column indices of a cell, and we will maintain a <code>minCost</code> grid to track the minimum cost to reach each cell.</p>
<p>As we visit each cell, we evaluate its four neighboring cells. If moving to a neighbor doesn’t require a sign change (i.e., the move is a 0-cost move), we add that neighbor to the front of the deque because we want to explore it immediately. On the other hand, if a sign change is required (making it a 1-cost move), we add the neighbor to the back of the deque, ensuring it gets explored later, after all the 0-cost moves.</p>
<p>For each neighbor we explore, we calculate the cost to reach it and compare it to the current value in the <code>minCost</code> grid. If the calculated cost is lower, we update <code>minCost</code> with the new, cheaper value.</p>
<p>Once the BFS traversal completes and all cells have been processed, the minimum cost to reach the bottom-right corner will be stored in <code>minCost</code>. We return this value as the solution to the problem.</p>
<p>The below slideshow demonstrates the algorithm in action:</p>
<p>!?!../Documents/1368/slideshow.json:1080,1080!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</li>
<li>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</li>
<li>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</li>
<li>Create a double-ended queue <code>deque</code> for 0-1 BFS implementation.</li>
<li>Add the starting position <code>[0, 0]</code> to the front of the <code>deque</code>.</li>
<li>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter a loop that continues while the <code>deque</code> is not empty:
<ul>
<li>Extract the current cell from the front of the <code>deque</code>.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Calculate the <code>cost</code>:
<ul>
<li>Set <code>cost</code> to <code>0</code> if the current cell naturally points in this direction.</li>
<li>Set <code>cost</code> to <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new position is valid and the new path is cheaper:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>If the <code>cost</code> is 1:
<ul>
<li>Add the new position to the back of the <code>deque</code>.</li>
</ul>
</li>
<li>If the <code>cost</code> is 0:
<ul>
<li>Add the new position to the front of the <code>deque</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<p>Helper method <code>isValid(row, col, numRows, numCols)</code>:</p>
<ul>
<li>Check if the given position is:
<ul>
<li>Within the grid's row boundaries.</li>
<li>Within the grid's column boundaries.</li>
</ul>
</li>
<li>Return <code>true</code> if all conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/NWGViPMb/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses 0-1 BFS approach where each cell is visited at most once for each edge weight (0 or 1). Since we process zero-weight edges before one-weight edges (by adding to the front of the deque), each cell gets its final shortest distance when it's first processed. No cell is processed more than once with the same cost. Therefore, the time complexity is linear with respect to the number of cells, giving us <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a deque that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-depth-first-search--breadth-first-search">Approach 4: Depth-First Search + Breadth-First Search</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let us extend the idea of exploring all 0-weight edges. Since some paths cost 0 to traverse, we could technically explore a sizable portion of the grid without incurring any cost at all. Now, if we are allowed a cost of 1, we could expand from the parts of the grid already explored and cover an even larger area. Like this, if we gradually increase the cost that we allow for exploration, there will be a cost value where the entire grid (along with the target cell), will be explored.</p>
<p>The primary difference between this approach and all the other ones is that previously we started with exploring the grid and populated the cost along the way. But here, we fix the cost and figure out how much we can explore adhering to it.</p>
<p>We'll use a combination of Breadth-First Search (BFS) and Depth-First Search (DFS) to implement our idea. Imagine our exploration as having levels; cells reachable with cost 0 being one level, cells with cost 1 as another, and so on. We'll use DFS to explore all cells at a given level (cost) and we'll use BFS to guide the exploration level by level until all the cells have been explored.</p>
<p>Let's break down how this works:</p>
<p>Starting at (0,0), we use DFS to follow the arrows without any modifications. If a cell points right and we follow it right, that's free! We keep following these zero-cost paths until we can't go further. Think of this as drawing a continuous line through cells, following arrows until we have to lift our pencil.</p>
<p>Every time we reach a cell through DFS, we also add it to a queue. These cells will serve as the starting points for the next level of exploration.</p>
<p>After we've explored all zero-cost paths, we switch to BFS. We take a cell from the queue, and make a modification to the direction, thereby increasing the cost by 1. With the new direction of the current cell, new cells in the grid are now reachable, and we explore all cells using DFS like before. As we explore the grid using DFS, we maintain a grid <code>minCost</code> which stores the cost at which we first visited that cell.</p>
<p>We continue this process of modification for all direction values for each cell at the current level. After the current level is explored, we increase the cost by 1 again and start modifying the direction of cells in the queue to explore further.</p>
<p>As usual, when all the cells in the grid have been explored, we'll return the bottom-right corner of the <code>minCost</code> array as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize a directions array <code>dirs</code> with four vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize the variables for <code>numRows</code>, <code>numCols</code>, and the initial <code>cost</code> (set to 0).</li>
<li>Create a 2D array <code>minCost</code> to track the minimum cost to reach each cell.</li>
<li>Fill the <code>minCost</code> array with maximum integer values to mark cells as unvisited.</li>
<li>Create a <code>queue</code> to store cells that need cost increments for the BFS part.</li>
<li>Call <code>dfs</code> from the origin <code>(0,0)</code> with the initial cost of 0.</li>
<li>In the BFS part, while the <code>queue</code> is not empty:
<ul>
<li>Increment the <code>cost</code> by 1.</li>
<li>Store the current level size.</li>
<li>Process all cells at the current level:
<ul>
<li>Poll a cell from the <code>queue</code>.</li>
<li>For each of the four directions:
<ul>
<li>Call <code>dfs</code> from the new position with the current <code>cost</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Finally, return the minimum cost to reach the bottom-right cell of the grid (<code>minCost[numRows - 1][numCols - 1]</code>).</li>
</ul>
<p>Helper method <code>dfs(grid, row, col, minCost, cost, queue)</code>:</p>
<ul>
<li>Check if the current cell is valid and unvisited using the <code>isUnvisited</code> function.</li>
<li>If not valid or already visited, return.</li>
<li>Set the current cell's cost in the <code>minCost</code> array.</li>
<li>Add the current cell to the <code>queue</code>.</li>
<li>Calculate the next direction based on the <code>grid</code> value (subtracting 1 for 0-based indexing).</li>
<li>Recursively call <code>dfs</code> in the direction pointed by the arrow without increasing the cost.</li>
</ul>
<p>Helper method <code>isUnvisited(minCost, row, col)</code>:</p>
<ul>
<li>Check if the row and column are within the grid bounds.</li>
<li>Check if the cell has not been visited (still has maximum value).</li>
<li>Return <code>true</code> only if both conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ti9zFAP6/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a hybrid DFS-BFS approach. In the DFS part, each cell is visited at most once when following zero-cost paths (following arrows). In the BFS part, each cell might be added to the queue once for exploration in different directions, but again, each cell is processed at most once since we only visit unvisited cells. Since each cell can only be visited once in both phases, and for each cell, we perform constant time operations, the total time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses multiple data structures that each can grow up to <span class="math inline">\(O(n \cdot m)\)</span>: the <code>minCost</code> array to track visited cells, the <code>queue</code> for BFS that in the worst case might contain all cells, and the recursive call stack for DFS that in worst case might go through all cells in a snake-like pattern. Thus, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-reach-destination-in-time/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Reach Destination in Time</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a country of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> where <strong>all the cities are connected</strong> by bi-directional roads. The roads are represented as a 2D integer array <code>edges</code> where <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> denotes a road between cities <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> that takes <code>time<sub>i</sub></code> minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.</p>

<p>Each time you pass through a city, you must pay a passing fee. This is represented as a <strong>0-indexed</strong> integer array <code>passingFees</code> of length <code>n</code> where <code>passingFees[j]</code> is the amount of dollars you must pay when you pass through city <code>j</code>.</p>

<p>In the beginning, you are at city <code>0</code> and want to reach city <code>n - 1</code> in <code>maxTime</code><strong> minutes or less</strong>. The <strong>cost</strong> of your journey is the <strong>summation of passing fees</strong> for each city that you passed through at some moment of your journey (<strong>including</strong> the source and destination cities).</p>

<p>Given <code>maxTime</code>, <code>edges</code>, and <code>passingFees</code>, return <em>the <strong>minimum cost</strong> to complete your journey, or </em><code>-1</code><em> if you cannot complete it within </em><code>maxTime</code><em> minutes</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png" style="width: 371px; height: 171px;" /></p>

<pre>
<strong>Input:</strong> maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The path to take is 0 -&gt; 1 -&gt; 2 -&gt; 5, which takes 30 minutes and has $11 worth of passing fees.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png" style="width: 371px; height: 171px;" /></strong></p>

<pre>
<strong>Input:</strong> maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<strong>Output:</strong> 48
<strong>Explanation:</strong> The path to take is 0 -&gt; 3 -&gt; 4 -&gt; 5, which takes 26 minutes and has $48 worth of passing fees.
You cannot take path 0 -&gt; 1 -&gt; 2 -&gt; 5 since it would take too long.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no way to reach city 5 from city 0 within 25 minutes.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= maxTime &lt;= 1000</code></li>
	<li><code>n == passingFees.length</code></li>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= 1000</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 1000</code></li>
	<li><code>1 &lt;= passingFees[j] &lt;= 1000</code>&nbsp;</li>
	<li>The graph may contain multiple edges between two nodes.</li>
	<li>The graph does not contain self loops.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-walk-in-weighted-graph/description" target="_blank" rel="noopener noreferrer">Minimum Cost Walk in Weighted Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected weighted graph with <code>n</code> vertices labeled from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given the integer <code>n</code> and an array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between vertices <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with a weight of <code>w<sub>i</sub></code>.</p>

<p>A walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It&#39;s important to note that a walk may visit the same edge or vertex more than once.</p>

<p>The <strong>cost</strong> of a walk starting at node <code>u</code> and ending at node <code>v</code> is defined as the bitwise <code>AND</code> of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is <code>w<sub>0</sub>, w<sub>1</sub>, w<sub>2</sub>, ..., w<sub>k</sub></code>, then the cost is calculated as <code>w<sub>0</sub> &amp; w<sub>1</sub> &amp; w<sub>2</sub> &amp; ... &amp; w<sub>k</sub></code>, where <code>&amp;</code> denotes the bitwise <code>AND</code> operator.</p>

<p>You are also given a 2D array <code>query</code>, where <code>query[i] = [s<sub>i</sub>, t<sub>i</sub>]</code>. For each query, you need to find the minimum cost of the walk starting at vertex <code>s<sub>i</sub></code> and ending at vertex <code>t<sub>i</sub></code>. If there exists no such walk, the answer is <code>-1</code>.</p>

<p>Return <em>the array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> denotes the <strong>minimum</strong> cost of a walk for query </em><code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1]</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/31/q4_example1-1.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 351px; height: 141px;" />
<p>To achieve the cost of 1 in the first query, we need to move on the following edges: <code>0-&gt;1</code> (weight 7), <code>1-&gt;2</code> (weight 1), <code>2-&gt;1</code> (weight 1), <code>1-&gt;3</code> (weight 7).</p>

<p>In the second query, there is no walk between nodes 3 and 4, so the answer is -1.</p>

<p><strong class="example">Example 2:</strong></p>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0]</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/31/q4_example2e.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 211px; height: 181px;" />
<p>To achieve the cost of 0 in the first query, we need to move on the following edges: <code>1-&gt;2</code> (weight 1), <code>2-&gt;1</code> (weight 6), <code>1-&gt;2</code> (weight 1).</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= w<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= query.length &lt;= 10<sup>5</sup></code></li>
	<li><code>query[i].length == 2</code></li>
	<li><code>0 &lt;= s<sub>i</sub>, t<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>s<sub>i</sub> !=&nbsp;t<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an undirected weighted graph, represented by an array <code>edges</code>, where <code>edges[i] = [u, v, w]</code> indicates an edge between vertices <code>u</code> and <code>v</code> with weight <code>w</code>. Additionally, we are given an array <code>queries</code>, where <code>queries[i] = [s, t]</code> represents a pair of nodes in the graph.</p>
<p>For each query, our task is to determine the minimum <em>cost</em> of a <em>walk</em> that starts at node <code>s</code> and ends at node <code>t</code>. If no such walk exists, the answer is <code>-1</code>. Let's first define the two key terms involved in this task:</p>
<ul>
<li>A <em>walk</em> in a graph is a sequence of connected vertices and the edges that connect them. Unlike a path, a walk allows both edges and vertices to be repeated.</li>
<li>The <em>cost</em> of a walk is defined as the bitwise AND of the weights of all edges encountered in the walk.</li>
</ul>
<p>First, recall that the bitwise AND operation compares the bits of all the numbers involved and keeps a bit as <code>1</code> only if it is <code>1</code> in every number; otherwise, the bit becomes <code>0</code>. Now, consider the smallest number in the group. It already has some bits set to <code>0</code>. Since the AND operation can only turn bits off (changing <code>1</code> to <code>0</code>, but never <code>0</code> to <code>1</code>), the result can never have more <code>1</code>s than the smallest number. This means the result is always less than or equal to the smallest number.</p>
<p>In this problem, that tells us that adding more edges to a walk can only keep the cost the same or make it smaller. So, to find the minimum cost, we should try to include as many edges as possible in the walk.</p>
<p>Notice that since <code>w AND w = w</code>, revisiting the same edge multiple times does not change the total cost. This can be useful if we need to backtrack to take a different path, in order to visit more edges.</p>
<hr />
<h3 id="approach-1-disjoint-set-union-find">Approach 1: Disjoint-Set (Union-Find)</h3>
<h4 id="intuition">Intuition</h4>
<p>First, let's determine when the answer to a query is <code>-1</code>. This happens when no walk exists between the two nodes, meaning they belong to different connected components.</p>
<blockquote>
<p>A connected component in an undirected graph is a group of nodes where there is a path between any pair of nodes.</p>
</blockquote>
<p>Now, suppose the two nodes belong to the same connected component. What is the minimum cost of a walk connecting them? As mentioned, the optimal walk includes as many edges as possible. Since revisiting an edge does not affect the total score, we can freely traverse the edges of the component, meaning that we can move back and forth to reach all of them. Therefore, the best way to achieve the lowest cost is to visit every edge in the component.</p>
<p>To efficiently find and process the connected components of the graph, we use the Disjoint Set (Union-Find) data structure. This approach relies on two main operations: Union and Find. Each connected component has a representative node, known as its root, which is returned by the Find operation for any node in the group. When we Union two nodes, we merge their entire groups, as now a path exists between every node in one group and every node in the other. To maintain efficiency, the root of the larger group is chosen as the representative of the merged group. This minimizes the time needed for future Find operations by reducing the number of steps required to reach the current representative.</p>
<blockquote>
<p><strong>Disjoint Set (Union-Find)</strong>: For a more comprehensive understanding of the Disjoint Set data structure, check out the <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Disjoint Set/Union-Find Explore Card</a>. This resource provides an in-depth look at Union-Find, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>Once the nodes are grouped into connected components, we calculate the total cost for each component as the bitwise AND of all its edge weights. In the end, the minimum cost of a walk between any two nodes in the same component will be the same and equal to the component's total cost.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="main-function-minimumcostn-edges-queries">Main Function: <code>minimumCost(n, edges, queries)</code></h5>
<ul>
<li>Initialize three arrays of size <code>n</code>:
<ul>
<li><code>parent</code>, with all values set to <code>-1</code>, meaning that each node initially forms its own connected component.</li>
<li><code>depth</code>, with all values initialized to <code>0</code>.</li>
<li><code>componentCost</code>, with all values set to the largest integer (<code>2^32 - 1</code>), which is the neutral value for the AND operation, as it contains only <code>1</code>s in its binary representation.</li>
</ul>
</li>
<li>Construct the connected components of the graph:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in <code>edges</code>:
<ul>
<li><code>Union(node1, node2)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Calculate the cost of each component:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in <code>edges</code>:
<ul>
<li>Find the root of the edge's component: <code>root = find(node1)</code>.</li>
<li>Update the component cost by performing a bitwise AND: <code>componentCost[root] &amp;= weight</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an array <code>answer</code> to store the answer for each query.
<ul>
<li>For each <code>query = [start, end]</code> in <code>queries</code>:
<ul>
<li>If the two nodes belong to different connected components, i.e. <code>find(start) != find(end)</code>, push <code>-1</code> into <code>answer</code>.</li>
<li>Otherwise:
<ul>
<li>Find the root of their component: <code>root = find(start)</code>.</li>
<li>Push <code>componentCost[root]</code> into <code>answer</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>answer</code>.</li>
</ul>
<h5 id="findnode-function"><code>find(node)</code> function:</h5>
<ul>
<li>If <code>parent[node] = -1</code>, <code>node</code> is the representative of its group, so return <code>node</code>.</li>
<li>Otherwise, return <code>find(parent[node])</code> and store the result in <code>parent[node]</code> (path compression).</li>
</ul>
<h5 id="unionnode1-node2-function"><code>Union(node1, node2)</code> function:</h5>
<ul>
<li>Find the root of each node's component: set <code>root1 = find(node1)</code> and <code>root2 = find(node2)</code>.</li>
<li>If the two nodes already belong to the same component, i.e. <code>root1 == root2</code>, return.</li>
<li>Otherwise, if <code>depth[root1] &lt; depth[root2]</code>, swap the two roots to ensure that <code>root1</code> has greater depth.</li>
<li>Merge the two groups, by setting <code>parent[root2] = root1</code>.</li>
<li>If the groups had the same depth, increment the depth of the merged group by <code>1</code> (<code>depth[root1]++</code>).</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MuYneAW2/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph, <span class="math inline">\(m\)</span> the number of edges, and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + q)\)</span></p>
<p>First, we must account for the time needed for the initialization of the <code>parent</code> and <code>size</code> arrays, which is equal to <span class="math inline">\(O(n)\)</span>. The rest of the program consists of three loops. In the first loop, we iterate over all edges to construct the connected components of the graph. With the union-by-rank and path compression optimizations, both Find and Union operations take <span class="math inline">\(O(1)\)</span> time on average (or <span class="math inline">\(a(n)\)</span> time, where <span class="math inline">\(a\)</span> is the inverse Ackermann function that grows really slowly and is considered practically constant), so the time complexity of this loop is <span class="math inline">\(O(m)\)</span>. In the second loop, we call the Find method and update the component's cost in <span class="math inline">\(O(1)\)</span> time for each iteration, making the time complexity of this loop also <span class="math inline">\(O(m)\)</span>. Finally, we answer each query in <span class="math inline">\(O(1)\)</span> time, as it only involves checking if the two nodes belong to the same component and returning a precomputed value if they do. Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n + m + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create three arrays: <code>parent</code>, <code>depth</code>, and <code>componentCost</code>, each of size <span class="math inline">\(n\)</span>. The <code>answer</code> array is the output of the algorithm and doesn't contribute to the auxiliary space complexity, which is therefore equal to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we use Breadth-First Search (BFS) to find the connected components of the graph and calculate their costs. Each component is assigned a unique ID, allowing us to later check if two nodes belong to the same component and retrieve the precomputed cost.</p>
<p>We start a BFS traversal from each unvisited node, marking it as part of a new component with a unique <code>componentId</code>. During the traversal, we mark every node we visit as part of the current component by setting <code>components[node] = componentId</code>. As we explore, we calculate the component's cost by performing a bitwise AND on the weights of the edges we visit. After finishing the traversal of all nodes and edges in the component, we store the calculated cost in a map, where the key is the <code>componentId</code> and the value is the component's cost.</p>
<p>In the worst case—when each node forms its own connected component—we will need exactly <code>n</code> distinct <code>componentId</code> values. By setting the <code>componentId</code> to the number of already explored components (starting at <code>0</code>), we can assign a unique number to each component in the range <code>[0, n - 1]</code>. This allows us to use an array instead of a map to store the component costs, optimizing both runtime and memory usage.</p>
<p>Finally, for each query, we compare the <code>componentId</code> values of the two nodes in the <code>components</code> array. If they have the same ID, indicating they belong to the same component, we return the precomputed cost; otherwise, we return <code>-1</code> to show they are not connected.</p>
<blockquote>
<p><strong>Breadth-First Search</strong>: For a more comprehensive understanding of the Breadth-First Search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="main-function-minimumcostn-edges-queries-1">Main Function: <code>minimumCost(n, edges, queries)</code></h5>
<ul>
<li>Construct the adjacency list (<code>adjList</code>) of the graph:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in edges:
<ul>
<li>Push <code>[node2, weight]</code> to <code>adjList[node1]</code>.</li>
<li>Push <code>[node1, weight]</code> to <code>adjList[node2]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a <code>visited</code> array of size <code>n</code>.</li>
<li>an array, called <code>components</code> of size <code>n</code>, to store the component ID of the component each node belongs to.</li>
<li>an empty array, called <code>componentCost</code>.</li>
<li><code>componentId</code> to <code>0</code>.</li>
</ul>
</li>
<li>Find the connected components of the graph:
<ul>
<li>For each <code>node</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If <code>node</code> is not visited, meaning that it belongs to a new component:
<ul>
<li>Push the result of <code>getComponentCost(node, adjList, visited, components, componentId)</code> into <code>componentCost</code>.</li>
<li>Increment <code>componentId</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an empty array <code>answer</code> to store the answer to each query.</li>
<li>For each <code>query = [start, end]</code> in <code>queries</code>:
<ul>
<li>If <code>components[start] == components[end]</code>, meaning that the two nodes belong to the same component:
<ul>
<li>Push the cost of the component (<code>componentCost[components[start]]</code>) into <code>answer</code>.</li>
</ul>
</li>
<li>Otherwise, the two nodes are not connected, so push <code>-1</code> into <code>answer</code>.</li>
</ul>
</li>
<li>Return <code>answer</code>.</li>
</ul>
<h5 id="getcomponentcostsource-adjlist-visited-components-componentid-function"><code>getComponentCost(source, adjList, visited, components, componentId)</code> function:</h5>
<ul>
<li>Initialize:
<ul>
<li>a queue, called <code>nodesQueue</code>.</li>
<li><code>componentCost</code> to a number where all bits are set to 1 in its binary representation.</li>
</ul>
</li>
<li>Push <code>source</code> into <code>nodesQueue</code> and mark it as visited.</li>
<li>While <code>nodesQueue</code> is not empty:
<ul>
<li>Pop the top node of the queue as <code>node</code>.</li>
<li>Mark that <code>node</code> belongs to this component by setting <code>components[node] = componentId</code>.</li>
<li>For each <code>[neighbor, weight]</code> in <code>adjList[node]</code>:
<ul>
<li>Update the component cost by performing a bitwise AND: <code>componentCost &amp;= weight</code>.</li>
<li>If <code>neighbor</code> is visited, continue.</li>
<li>Otherwise, mark it as visited and push it into the queue.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>componentCost</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZvmjGS6T/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph, <span class="math inline">\(m\)</span> the number of edges, and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n + q)\)</span></p>
<p>First, we construct the adjacency list of the graph in <span class="math inline">\(O(m)\)</span> time, as we iterate over the edges and process each of them in constant time. Next, we perform a BFS traversal over the graph, which takes <span class="math inline">\(O(n + m)\)</span> time, as each node and edge is visited exactly once. Finally, we answer each query in constant time, as all component costs are already computed. Overall, the time complexity of the algorithm is <span class="math inline">\(O(m + n + q)\)</span>, as the steps are executed sequentially and independently of one another.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list contains exactly <span class="math inline">\(2m\)</span> elements, so it takes up <span class="math inline">\(O(m)\)</span> space. The other data structures we use, including the <code>visited</code>, <code>components</code>, and <code>componentCost</code> arrays, grow linearly with the number of nodes in the graph, contributing <span class="math inline">\(O(n)\)</span> to the algorithm's space complexity. Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-depth-first-search-dfs">Approach 3: Depth-First Search (DFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this approach, we will use the same logic as previously, assigning a unique ID to each component and marking all nodes of the component with this ID. However, we will now use a different type of graph traversal—Depth-First Search (DFS)—to find the connected components and mark the nodes.</p>
<p>The main difference between the two traversals (BFS and DFS) is that DFS is typically implemented recursively and explores as far along a path as possible before backtracking, while BFS extends paths one layer at a time. In this problem, since we explore the entire graph and visit all nodes and edges exactly once, both DFS and BFS perform equally in terms of time complexity.</p>
<blockquote>
<p><strong>Depth-First Search</strong>: For a more comprehensive understanding of the Depth-First Search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/depth-first-search-in-graph/">DFS Explore Card</a>. This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<h5 id="main-function-minimumcostn-edges-queries-2">Main Function: <code>minimumCost(n, edges, queries)</code></h5>
<ul>
<li>Construct the adjacency list (<code>adjList</code>) of the graph:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in edges:
<ul>
<li>Push <code>[node2, weight]</code> to <code>adjList[node1]</code>.</li>
<li>Push <code>[node1, weight]</code> to <code>adjList[node2]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a <code>visited</code> array of size <code>n</code>.</li>
<li>an array, called <code>components</code> of size <code>n</code>, to store the component ID of the component each node belongs to.</li>
<li>an empty array, called <code>componentCost</code>.</li>
<li><code>componentId</code> to <code>0</code>.</li>
</ul>
</li>
<li>Find the connected components of the graph:
<ul>
<li>For each <code>node</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If <code>node</code> is not visited, meaning that it belongs to a new component:
<ul>
<li>Push the result of <code>getComponentCost(node, adjList, visited, components, componentId)</code> into <code>componentCost</code>.</li>
<li>Increment <code>componentId</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an empty array <code>answer</code>, to store the answer to each query.</li>
<li>For each <code>query = [start, end]</code> in <code>queries</code>:
<ul>
<li>If <code>components[start] == components[end]</code>, meaning that the two nodes belong to the same component:
<ul>
<li>Push the cost of the component (<code>componentCost[components[start]]</code>) into <code>answer</code>.</li>
</ul>
</li>
<li>Otherwise, the two nodes are not connected, so push <code>-1</code> into <code>answer</code>.</li>
</ul>
</li>
<li>Return <code>answer</code>.</li>
</ul>
<h5 id="getcomponentcostnode-adjlist-visited-components-componentid-function"><code>getComponentCost(node, adjList, visited, components, componentId)</code> function:</h5>
<ul>
<li>Set <code>components[node] = componentId</code> to mark the <code>node</code> as part of the current component.</li>
<li>Mark <code>node</code> as visited.</li>
<li>Initialize <code>currentCost</code> to a number where all bits are set to 1 in its binary representation.</li>
<li>For each <code>[neighbor, weight]</code> in <code>adjList[node]</code>:
<ul>
<li>Update the component cost by performing a bitwise AND: <code>currentCost &amp;= weight</code>.</li>
<li>If <code>neighbor</code> is not visited:
<ul>
<li>Recursively explore the rest of the component and accumulate its cost by calling <code>getComponentCost(neighbor, adjList, visited, components, componentId)</code> and update <code>currentCost</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>currentCost</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/7m7LDYei/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph, <span class="math inline">\(m\)</span> the number of edges, and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n + q)\)</span></p>
<p>Constructing the adjacency list of the graph requires <span class="math inline">\(O(m)\)</span> time, as each edge is processed in constant time. Additionally, the DFS traversal takes <span class="math inline">\(O(m + n)\)</span> time, since each node and each edge is visited exactly once. During the traversal, we calculate and store the costs of the components, so we answer each query in constant time. Therefore, the overall time complexity of the algorithm is <span class="math inline">\(O(m + n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The space complexity of the algorithm is determined by the size of the data structures used and the recursion depth. The adjacency list contains two elements for each edge of the graph, taking up <span class="math inline">\(O(m)\)</span> space, while the arrays <code>visited</code>, <code>components</code>, and <code>componentCost</code> have at most <span class="math inline">\(n\)</span> elements, contributing <span class="math inline">\(O(n)\)</span> to the space complexity. Moreover, the recursion depth can grow up to <span class="math inline">\(n\)</span> in the worst case, where all nodes belong to the same connected component and form a list. As a result, the total space complexity of the algorithm is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/description" target="_blank" rel="noopener noreferrer">Minimum Degree of a Connected Trio in a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">enumeration</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected graph. You are given an integer <code>n</code> which is the number of nodes in the graph and an array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an undirected edge between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>A <strong>connected trio</strong> is a set of <strong>three</strong> nodes where there is an edge between <b>every</b> pair of them.</p>

<p>The <strong>degree of a connected trio</strong> is the number of edges where one endpoint is in the trio, and the other is not.</p>

<p>Return <em>the <strong>minimum</strong> degree of a connected trio in the graph, or</em> <code>-1</code> <em>if the graph has no connected trios.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/26/trios1.png" style="width: 388px; height: 164px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/26/trios2.png" style="width: 388px; height: 164px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are exactly three trios:
1) [1,4,3] with degree 0.
2) [2,5,6] with degree 2.
3) [5,6,7] with degree 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 400</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= edges.length &lt;= n * (n-1) / 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/description" target="_blank" rel="noopener noreferrer">Minimum Edge Reversals So Every Node Is Reachable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>simple directed graph</strong> with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. The graph would form a <strong>tree</strong> if its edges were bi-directional.</p>

<p>You are given an integer <code>n</code> and a <strong>2D</strong> integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> represents a <strong>directed edge</strong> going from node <code>u<sub>i</sub></code> to node <code>v<sub>i</sub></code>.</p>

<p>An <strong>edge reversal</strong> changes the direction of an edge, i.e., a directed edge going from node <code>u<sub>i</sub></code> to node <code>v<sub>i</sub></code> becomes a directed edge going from node <code>v<sub>i</sub></code> to node <code>u<sub>i</sub></code>.</p>

<p>For every node <code>i</code> in the range <code>[0, n - 1]</code>, your task is to <strong>independently</strong> calculate the <strong>minimum</strong> number of <strong>edge reversals</strong> required so it is possible to reach any other node starting from node <code>i</code> through a <strong>sequence</strong> of <strong>directed edges</strong>.</p>

<p>Return <em>an integer array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the</em><em> </em> <em><strong>minimum</strong> number of <strong>edge reversals</strong> required so it is possible to reach any other node starting from node </em><code>i</code><em> through a <strong>sequence</strong> of <strong>directed edges</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img height="246" src="https://assets.leetcode.com/uploads/2023/08/26/image-20230826221104-3.png" width="312" /></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[2,0],[2,1],[1,3]]
<strong>Output:</strong> [1,1,0,2]
<strong>Explanation:</strong> The image above shows the graph formed by the edges.
For node 0: after reversing the edge [2,0], it is possible to reach any other node starting from node 0.
So, answer[0] = 1.
For node 1: after reversing the edge [2,1], it is possible to reach any other node starting from node 1.
So, answer[1] = 1.
For node 2: it is already possible to reach any other node starting from node 2.
So, answer[2] = 0.
For node 3: after reversing the edges [1,3] and [2,1], it is possible to reach any other node starting from node 3.
So, answer[3] = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img height="217" src="https://assets.leetcode.com/uploads/2023/08/26/image-20230826225541-2.png" width="322" /></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[1,2],[2,0]]
<strong>Output:</strong> [2,0,1]
<strong>Explanation:</strong> The image above shows the graph formed by the edges.
For node 0: after reversing the edges [2,0] and [1,2], it is possible to reach any other node starting from node 0.
So, answer[0] = 2.
For node 1: it is already possible to reach any other node starting from node 1.
So, answer[1] = 0.
For node 2: after reversing the edge [1, 2], it is possible to reach any other node starting from node 2.
So, answer[2] = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub> == edges[i][0] &lt; n</code></li>
	<li><code>0 &lt;= v<sub>i</sub> == edges[i][1] &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>The input is generated such&nbsp;that if the edges were bi-directional, the graph would be a tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/description" target="_blank" rel="noopener noreferrer">Minimum Edge Weight Equilibrium Queries in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">strongly-connected-component</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given the integer <code>n</code> and a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with weight <code>w<sub>i</sub></code> in the tree.</p>

<p>You are also given a 2D integer array <code>queries</code> of length <code>m</code>, where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>. For each query, find the <strong>minimum number of operations</strong> required to make the weight of every edge on the path from <code>a<sub>i</sub></code> to <code>b<sub>i</sub></code> equal. In one operation, you can choose any edge of the tree and change its weight to any value.</p>

<p><strong>Note</strong> that:</p>

<ul>
	<li>Queries are <strong>independent</strong> of each other, meaning that the tree returns to its <strong>initial state</strong> on each new query.</li>
	<li>The path from <code>a<sub>i</sub></code> to <code>b<sub>i</sub></code> is a sequence of <strong>distinct</strong> nodes starting with node <code>a<sub>i</sub></code> and ending with node <code>b<sub>i</sub></code> such that every two adjacent nodes in the sequence share an edge in the tree.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>m</code><em> where</em> <code>answer[i]</code> <em>is the answer to the</em> <code>i<sup>th</sup></code> <em>query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/11/graph-6-1.png" style="width: 339px; height: 344px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]
<strong>Output:</strong> [0,0,1,3]
<strong>Explanation:</strong> In the first query, all the edges in the path from 0 to 3 have a weight of 1. Hence, the answer is 0.
In the second query, all the edges in the path from 3 to 6 have a weight of 2. Hence, the answer is 0.
In the third query, we change the weight of edge [2,3] to 2. After this operation, all the edges in the path from 2 to 6 have a weight of 2. Hence, the answer is 1.
In the fourth query, we change the weights of edges [0,1], [1,2] and [2,3] to 2. After these operations, all the edges in the path from 0 to 6 have a weight of 2. Hence, the answer is 3.
For each queries[i], it can be shown that answer[i] is the minimum number of operations needed to equalize all the edge weights in the path from a<sub>i</sub> to b<sub>i</sub>.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/11/graph-9-1.png" style="width: 472px; height: 370px;" />
<pre>
<strong>Input:</strong> n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]
<strong>Output:</strong> [1,2,2,3]
<strong>Explanation:</strong> In the first query, we change the weight of edge [1,3] to 6. After this operation, all the edges in the path from 4 to 6 have a weight of 6. Hence, the answer is 1.
In the second query, we change the weight of edges [0,3] and [3,1] to 6. After these operations, all the edges in the path from 0 to 4 have a weight of 6. Hence, the answer is 2.
In the third query, we change the weight of edges [1,3] and [5,2] to 6. After these operations, all the edges in the path from 6 to 5 have a weight of 6. Hence, the answer is 2.
In the fourth query, we change the weights of edges [0,7], [0,3] and [1,3] to 6. After these operations, all the edges in the path from 7 to 4 have a weight of 6. Hence, the answer is 3.
For each queries[i], it can be shown that answer[i] is the minimum number of operations needed to equalize all the edge weights in the path from a<sub>i</sub> to b<sub>i</sub>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 26</code></li>
	<li>The input is generated such that <code>edges</code> represents a valid tree.</li>
	<li><code>1 &lt;= queries.length == m &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description" target="_blank" rel="noopener noreferrer">Minimum Fuel Cost to Report to the Capital</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> roads. The capital city is city <code>0</code>. You are given a 2D integer array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists a <strong>bidirectional road</strong> connecting cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>There is a meeting for the representatives of each city. The meeting is in the capital city.</p>

<p>There is a car in each city. You are given an integer <code>seats</code> that indicates the number of seats in each car.</p>

<p>A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.</p>

<p>Return <em>the minimum number of liters of fuel to reach the capital city</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/22/a4c380025e3ff0c379525e96a7d63a3.png" style="width: 303px; height: 332px;" />
<pre>
<strong>Input:</strong> roads = [[0,1],[0,2],[0,3]], seats = 5
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
- Representative<sub>1</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>2</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>3</sub> goes directly to the capital with 1 liter of fuel.
It costs 3 liters of fuel at minimum. 
It can be proven that 3 is the minimum number of liters of fuel needed.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/16/2.png" style="width: 274px; height: 340px;" />
<pre>
<strong>Input:</strong> roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
<strong>Output:</strong> 7
<strong>Explanation:</strong> 
- Representative<sub>2</sub> goes directly to city 3 with 1 liter of fuel.
- Representative<sub>2</sub> and representative<sub>3</sub> go together to city 1 with 1 liter of fuel.
- Representative<sub>2</sub> and representative<sub>3</sub> go together to the capital with 1 liter of fuel.
- Representative<sub>1</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>5</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>6</sub> goes directly to city 4 with 1 liter of fuel.
- Representative<sub>4</sub> and representative<sub>6</sub> go together to the capital with 1 liter of fuel.
It costs 7 liters of fuel at minimum. 
It can be proven that 7 is the minimum number of liters of fuel needed.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/27/efcf7f7be6830b8763639cfd01b690a.png" style="width: 108px; height: 86px;" />
<pre>
<strong>Input:</strong> roads = [], seats = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> No representatives need to travel to the capital city.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>roads.length == n - 1</code></li>
	<li><code>roads[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>roads</code> represents a valid tree.</li>
	<li><code>1 &lt;= seats &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-height-trees/description" target="_blank" rel="noopener noreferrer">Minimum Height Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly</i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.</p>

<p>Given a tree of <code>n</code> nodes&nbsp;labelled from <code>0</code> to <code>n - 1</code>, and an array of&nbsp;<code>n - 1</code>&nbsp;<code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i</sub></code> and&nbsp;<code>b<sub>i</sub></code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)&nbsp; are called <strong>minimum height trees</strong> (MHTs).</p>

<p>Return <em>a list of all <strong>MHTs&#39;</strong> root labels</em>.&nbsp;You can return the answer in <strong>any order</strong>.</p>

<p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" style="width: 800px; height: 213px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,0],[1,2],[1,3]]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/e2.jpg" style="width: 800px; height: 321px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
<strong>Output:</strong> [3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are distinct.</li>
	<li>The given input is <strong>guaranteed</strong> to be a tree and there will be <strong>no repeated</strong> edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-multiplications-to-reach-end/1" target="_blank" rel="noopener noreferrer">Minimum Multiplications to reach End</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given <strong>start</strong>, <strong>end</strong> and an array <strong>arr</strong> of <strong>n</strong>&nbsp;numbers. At each step, <strong>start</strong> is multiplied with any number in the array and then mod operation with <strong>100000</strong> is done to get the new start. </span></p>
<p><span style="font-size: 18px;">Your task is to find the minimum steps in which <strong>end</strong> can be achieved starting from <strong>start</strong>. If it is not possible to reach <strong>end</strong>, then return <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
arr[] = {2, 5, 7}
start = 3, end = 30
<strong>Output:</strong>
2
<strong>Explanation:</strong>
Step 1: 3*2 = 6 % 100000 = 6 
Step 2: 6*5 = 30 % 100000 = 30
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
arr[] = {3, 4, 65}
start = 7, end = 66175
<strong>Output:</strong>
4
<strong>Explanation:</strong>
Step 1: 7*3 = 21 % 100000 = 21&nbsp;
Step 2: 21*3 = 63 % 100000 = 63&nbsp;
Step 3: 63*65 = 4095 % 100000 = 4095&nbsp;
Step 4: 4095*65 = 266175 % 100000 = 66175
</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:<br /></strong></span><span style="font-size: 18px;">You don't need to print or input anything. Complete the function <strong>minimumMultiplications()</strong> which takes an integer array <strong>arr</strong>, an integer <strong>start</strong> and an integer<strong> end</strong> as the input parameters and returns an integer, denoting the minumum steps to reach in which <strong>end</strong> can be achieved starting from <strong>start</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(10<sup>5</sup>)<br /></span><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(10<sup>5</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= n &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">1 &lt;= arr[i] &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">1 &lt;= start, end &lt;&nbsp;10<sup>5</sup></span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/description" target="_blank" rel="noopener noreferrer">Minimum Number of Vertices to Reach All Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a<strong>&nbsp;directed acyclic graph</strong>,&nbsp;with&nbsp;<code>n</code>&nbsp;vertices numbered from&nbsp;<code>0</code>&nbsp;to&nbsp;<code>n-1</code>,&nbsp;and an array&nbsp;<code>edges</code>&nbsp;where&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;represents a directed edge from node&nbsp;<code>from<sub>i</sub></code>&nbsp;to node&nbsp;<code>to<sub>i</sub></code>.</p>

<p>Find <em>the smallest set of vertices from which all nodes in the graph are reachable</em>. It&#39;s guaranteed that a unique solution exists.</p>

<p>Notice that you can return the vertices in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/07/07/untitled22.png" style="width: 231px; height: 181px;" /></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
<strong>Output:</strong> [0,3]
<b>Explanation: </b>It&#39;s not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/07/07/untitled.png" style="width: 201px; height: 201px;" /></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
<strong>Output:</strong> [0,2,3]
<strong>Explanation: </strong>Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10^5</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= from<sub>i,</sub>&nbsp;to<sub>i</sub> &lt; n</code></li>
	<li>All pairs <code>(from<sub>i</sub>, to<sub>i</sub>)</code> are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/description" target="_blank" rel="noopener noreferrer">Minimum Obstacle Removal to Reach Corner</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code>. Each cell has one of two values:</p>

<ul>
	<li><code>0</code> represents an <strong>empty</strong> cell,</li>
	<li><code>1</code> represents an <strong>obstacle</strong> that may be removed.</li>
</ul>

<p>You can move up, down, left, or right from and to an empty cell.</p>

<p>Return <em>the <strong>minimum</strong> number of <strong>obstacles</strong> to <strong>remove</strong> so you can move from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png" style="width: 605px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
It can be shown that we need to remove at least 2 obstacles, so we return 2.
Note that there may be other ways to remove 2 obstacles to create a path.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png" style="width: 405px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2-D matrix <code>grid</code>, where each cell is either empty or contains an obstacle. We can remove any obstacle, and our goal is to find the minimum number of obstacles that need to be removed to create a path from the top-left corner to the bottom-right corner.</p>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We can frame this problem as a shortest-path problem with a start and end point, and from each cell, we can move in four directions (up, down, left, right). There are two scenarios for movement:</p>
<ol>
<li>Moving to an empty cell costs nothing (edge weight = 0).</li>
<li>Moving to a cell with an obstacle costs 1 as we must remove it (edge weight = 1).</li>
</ol>
<p>This turns our problem into a graph with edges weighted 0 or 1. The goal is to find the shortest path from the start to the destination using Dijkstra's algorithm.</p>
<p>We’ll implement Dijkstra’s algorithm using a priority queue, where each element contains the cell's coordinates and the number of obstacles removed to reach it. The queue will be sorted by obstacle count in increasing order. For each element, we explore its four neighbors. If a neighbor contains an obstacle, we increment the obstacle count and add it to the queue for further exploration.</p>
<p>As we explore, we’ll eventually reach the destination cell. Once we do, we return its obstacle count, which is guaranteed to be the minimum, as the queue prioritizes cells with the fewest obstacles.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Set dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.
<ul>
<li>Set all cells in <code>minObstacles</code> to infinity to represent unvisited cells.</li>
</ul>
</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to the value of <code>grid[0][0]</code>, since this is the initial position.</li>
<li>Create a priority queue <code>pq</code> that orders elements based on the number of obstacles encountered.
<ul>
<li>Each element in the queue is an array containing: [obstacles count, row, column]</li>
</ul>
</li>
<li>Add the starting position to the priority queue with its obstacle count.</li>
<li>Enter a loop that continues while <code>pq</code> is not empty:
<ul>
<li>Extract the cell with minimum obstacles from the queue.</li>
<li>If this cell is the target <code>(m-1, n-1)</code>, return the obstacle count.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid:
<ul>
<li>Calculate the new obstacle count by adding the grid value of the new position.</li>
<li>If the new obstacle count is less than the previously recorded count for that cell:</li>
<li>Update the <code>minObstacles</code> array with the new count.</li>
<li>Add the new position to <code>pq</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return -1 if the main loop completes without finding the target (this shouldn't happen).</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z4CaAqmQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>The priority queue can contain up to <span class="math inline">\(O(m \cdot n)\)</span> elements (all the cells in the grid), making each operation cost <span class="math inline">\(O(\log(m \cdot n))\)</span> time. Thus, the time complexity is <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is dominated by two main components: the <code>minObstacles</code> array and the priority queue, both of which have a complexity of <span class="math inline">\(O(m \cdot n)\)</span>. The <code>directions</code> array and other variables take constant space.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-0-1-breadth-first-search-bfs">Approach 2: 0-1 Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As stated earlier, moving through cells without obstacles has no cost. Therefore, we prioritize exploring neighboring empty cells first, only moving to cells with obstacles when no free cells are left.</p>
<p>We perform a BFS using a deque to manage the queue. When exploring neighboring cells, we add empty cells to the front of the deque for immediate exploration, and cells with obstacles to the back, delaying their exploration.</p>
<p>We maintain a result grid, <code>minObstacles</code>, initialized to infinity (indicating they are unvisited), to track the minimum obstacles encountered at each cell. We'll add the top left cell to the deque and begin our exploration. At each step, we'll pop the top cell in the deque and explore its neighbors. All empty neighbors go to the front of the deque, while others go to the bottom with their obstacle count increased by 1. Simultaneously, we'll update the <code>minObstacles</code> value for each neighboring position.</p>
<p>Once all cells are explored, the value at the bottom-right cell of <code>minObstacles</code> will give the minimum obstacles encountered on the shortest path.</p>
<p>Here's a brief visualization of how the <code>minObstacles</code> matrix is filled up step by step:</p>
<p>!?!../Documents/2290/slideshow.json:702,942!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 2-D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Store the dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2-D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.</li>
<li>Initialize all cells in <code>minObstacles</code> with infinity to represent unvisited cells.</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to 0, as we start from this position.</li>
<li>Create a double-ended queue <code>deque</code> to process cells.
<ul>
<li>Add the starting position to the queue.</li>
</ul>
</li>
<li>Loop while the deque is not empty:
<ul>
<li>Extract the first cell from the queue.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid and unvisited (<code>minObstacles</code> value is infinity):
<ul>
<li>If the new cell contains an obstacle (value 1):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count plus 1.</li>
<li>Add the new position to the back of the deque.</li>
</ul>
</li>
<li>If the new cell is empty (value 0):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count.</li>
<li>Add a new position to the front of the deque.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minObstacles[m-1][n-1]</code> representing minimum obstacles removed to reach target.</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VbP4ycxv/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Each of the <span class="math inline">\(m \cdot n\)</span> cells in the grid is visited exactly once because we only process unvisited cells. The deque operations are all <span class="math inline">\(O(1)\)</span>.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The <code>minObstacles</code> array and the deque both take <span class="math inline">\(O(m \cdot n)\)</span> space. All other variables take constant space.</p>
<p>Thus, the space complexity remains <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description" target="_blank" rel="noopener noreferrer">Minimum Score of a Path Between Two Cities</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing <code>n</code> cities numbered from <code>1</code> to <code>n</code>. You are also given a <strong>2D</strong> array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code> indicates that there is a <strong>bidirectional </strong>road between cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with a distance equal to <code>distance<sub>i</sub></code>. The cities graph is not necessarily connected.</p>

<p>The <strong>score</strong> of a path between two cities is defined as the <strong>minimum </strong>distance of a road in this path.</p>

<p>Return <em>the <strong>minimum </strong>possible score of a path between cities </em><code>1</code><em> and </em><code>n</code>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>A path is a sequence of roads between two cities.</li>
	<li>It is allowed for a path to contain the same road <strong>multiple</strong> times, and you can visit cities <code>1</code> and <code>n</code> multiple times along the path.</li>
	<li>The test cases are generated such that there is <strong>at least</strong> one path between <code>1</code> and <code>n</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/12/graph11.png" style="width: 190px; height: 231px;" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 4. The score of this path is min(9,5) = 5.
It can be shown that no other path has less score.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/12/graph22.png" style="width: 190px; height: 231px;" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4. The score of this path is min(2,2,4,7) = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>There are no repeated edges.</li>
	<li>There is at least one path between <code>1</code> and <code>n</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-spanning-tree/1" target="_blank" rel="noopener noreferrer">Minimum Spanning Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">Given a weighted, undirected, and connected graph with V vertices and E edges, your task is to find the sum of the weights of the edges in the Minimum Spanning Tree (MST) of the graph. The graph is provided as a list of edges, where each edge is represented as [u, v, w], indicating an edge between vertex u and vertex v with edge weight w.</span></span></p>
<pre><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Input: </strong>V = 3, E = 3, Edges = [[0, 1, 5], [1, 2, 3], [0, 2, 1]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700343/Web/Other/blobid1_1744376821.jpg" width="229" height="186" /> <br /><strong>Output: </strong>4
<strong>Explanation</strong>:
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700343/Web/Other/blobid2_1744376854.jpg" width="237" height="193" /><br />The Spanning Tree resulting in a weight
of 4 is shown above.</span></pre>
<pre><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong style="white-space: normal;">Input: </strong><span style="white-space: normal;">V = 2, E = 1, Edges = [[0 1 5]]</span></span><br /><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"> <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700343/Web/Other/blobid3_1744376890.jpg" width="232" height="189" /></span><br /><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Output: </strong>5 </span><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Explanation</strong>: Only one Spanning Tree is possible which has a weight of 5.<br /></span></pre>
<p><strong style="font-family: arial, helvetica, sans-serif; font-size: 14pt;">Constraints:<br /></strong><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;">2 &le; V &le; 1000<br />V-1 &le; E &le; (V*(V-1))/2<br />1 &le; w &le; 1000<br />The graph is connected and doesn't contain self-loops &amp; multiple edges.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-150">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-spanning-tree-kruskals-algorithm/1" target="_blank" rel="noopener noreferrer">Minimum Spanning Tree - Kruskal&#39;s Algorithm</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">Given a weighted, undirected, and connected graph with V vertices and E edges, the task is to find the sum of the weights of the edges in the <strong>Minimum Spanning Tree</strong> (MST) of the graph using <strong>Kruskal's Algorithm</strong>. The graph is represented as an edge list <strong>edges[][]</strong>, where edges[i] = [u, v, w] denotes an undirected edge between <strong>u</strong> and <strong>v </strong>with weight <strong>w</strong>.</span></span></p>
<pre><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Input:</strong> V = 3, E = 3, edges[][] = [[0, 1, 5], [1, 2, 3], [0, 2, 1]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/888914/Web/Other/blobid0_1745301795.jpg" width="279" height="227" /><br /><strong>Output: </strong>4
<strong>Explanation</strong>:
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/888914/Web/Other/blobid1_1745301818.jpg" width="287" height="233" /><br />The Spanning Tree resulting in a weight of 4 is shown above.</span></pre>
<pre><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong style="white-space: normal;">Input: </strong><span style="white-space: normal;">V = 2, E = 1, edges = [[0, 1, 5]]</span></span><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"> <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/888914/Web/Other/blobid2_1745301846.jpg" width="279" height="227" /> </span><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Output: </strong>5 </span><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Explanation</strong>: Only one Spanning Tree is possible which has a weight of 5.<br /></span></pre>
<p><strong style="font-family: arial, helvetica, sans-serif; font-size: 14pt;">Constraints:<br /></strong><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;">2 &le; V &le; 1000<br />V-1 &le; E &le; (V*(V-1))/2<br />1 &le; w &le; 1000<br />The graph is connected and doesn't contain self-loops &amp; multiple edges.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-151">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-swaps/1" target="_blank" rel="noopener noreferrer">Minimum Swaps to Sort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong> of distinct elements. Find the minimum number of swaps required to sort the array in strictly increasing order.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [2, 8, 5, 4]
<strong>Output: </strong>1
<strong>Explanation: </strong>Swap 8 with 4 to get the sorted array.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [10, 19, 6, 3, 5]
<strong>Output: </strong>2
<strong>Explanation: </strong>Swap 10 with 3 and 19 with 5 to get the sorted array.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1, 3, 4, 5, 6]
<strong>Output:</strong> 0
<strong>Explanation: </strong>Input array is already sorted.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>5</sup><br />1 &le; arr[i] &le; 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-152">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-for-k-connected-components/description" target="_blank" rel="noopener noreferrer">Minimum Time for K Connected Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an undirected graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code> indicates an undirected edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> that can be removed at <code>time<sub>i</sub></code>.</p>

<p>You are also given an integer <code>k</code>.</p>

<p>Initially, the graph may be connected or disconnected. Your task is to find the <strong>minimum</strong> time <code>t</code> such that after removing all edges with <code>time &lt;= t</code>, the graph contains <strong>at least</strong> <code>k</code> connected components.</p>

<p>Return the <strong>minimum</strong> time <code>t</code>.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1,3]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022724.png" style="width: 230px; height: 85px;" /></p>

<ul>
	<li>Initially, there is one connected component <code>{0, 1}</code>.</li>
	<li>At <code>time = 1</code> or <code>2</code>, the graph remains unchanged.</li>
	<li>At <code>time = 3</code>, edge <code>[0, 1]</code> is removed, resulting in <code>k = 2</code> connected components <code>{0}</code>, <code>{1}</code>. Thus, the answer is 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[1,2,4]], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022812.png" style="width: 180px; height: 164px;" /></p>

<ul>
	<li>Initially, there is one connected component <code>{0, 1, 2}</code>.</li>
	<li>At <code>time = 2</code>, edge <code>[0, 1]</code> is removed, resulting in two connected components <code>{0}</code>, <code>{1, 2}</code>.</li>
	<li>At <code>time = 4</code>, edge <code>[1, 2]</code> is removed, resulting in <code>k = 3</code> connected components <code>{0}</code>, <code>{1}</code>, <code>{2}</code>. Thus, the answer is 4.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,2,5]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022930.png" style="width: 180px; height: 155px;" /></p>

<ul>
	<li>Since there are already <code>k = 2</code> disconnected components <code>{1}</code>, <code>{0, 2}</code>, no edge removal is needed. Thus, the answer is 0.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-153">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-reach-destination-in-directed-graph/description" target="_blank" rel="noopener noreferrer">Minimum Time to Reach Destination in Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and a <strong>directed</strong> graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, start<sub>i</sub>, end<sub>i</sub>]</code> indicates an edge from node <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code> that can <strong>only</strong> be used at any integer time <code>t</code> such that <code>start<sub>i</sub> &lt;= t &lt;= end<sub>i</sub></code>.</p>

<p>You start at node 0 at time 0.</p>

<p>In one unit of time, you can either:</p>

<ul>
	<li>Wait at your current node without moving, or</li>
	<li>Travel along an outgoing edge from your current node if the current time <code>t</code> satisfies <code>start<sub>i</sub> &lt;= t &lt;= end<sub>i</sub></code>.</li>
</ul>

<p>Return the <strong>minimum</strong> time required to reach node <code>n - 1</code>. If it is impossible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,0,1],[1,2,2,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/05/screenshot-2025-06-06-at-004535.png" style="width: 150px; height: 141px;" /></p>

<p>The optimal path is:</p>

<ul>
	<li>At time <code>t = 0</code>, take the edge <code>(0 &rarr; 1)</code> which is available from 0 to 1. You arrive at node 1 at time <code>t = 1</code>, then wait until <code>t = 2</code>.</li>
	<li>At time <code>t = <code>2</code></code>, take the edge <code>(1 &rarr; 2)</code> which is available from 2 to 5. You arrive at node 2 at time 3.</li>
</ul>

<p>Hence, the minimum time to reach node 2 is 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,1,0,3],[1,3,7,8],[0,2,1,5],[2,3,4,7]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/05/screenshot-2025-06-06-at-004757.png" style="width: 170px; height: 219px;" /></p>

<p>The optimal path is:</p>

<ul>
	<li>Wait at node 0 until time <code>t = 1</code>, then take the edge <code>(0 &rarr; 2)</code> which is available from 1 to 5. You arrive at node 2 at <code>t = 2</code>.</li>
	<li>Wait at node 2 until time <code>t = 4</code>, then take the edge <code>(2 &rarr; 3)</code> which is available from 4 to 7. You arrive at node 3 at <code>t = 5</code>.</li>
</ul>

<p>Hence, the minimum time to reach node 3 is 5.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[1,0,1,3],[1,2,3,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/05/screenshot-2025-06-06-at-004914.png" style="width: 150px; height: 145px;" /></p>

<ul>
	<li>Since there is no outgoing edge from node 0, it is impossible to reach node 2. Hence, the output is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>, start<sub>i</sub>, end<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-154">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-transport-all-individuals/description" target="_blank" rel="noopener noreferrer">Minimum Time to Transport All Individuals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>n</code> individuals at a base camp who need to cross a river to reach a destination using a single boat. The boat can carry at most <code>k</code> people at a time. The trip is affected by environmental conditions that vary <strong>cyclically</strong> over <code>m</code> stages.</p>

<p>Each stage <code>j</code> has a speed multiplier <code>mul[j]</code>:</p>

<ul>
	<li>If <code>mul[j] &gt; 1</code>, the trip slows down.</li>
	<li>If <code>mul[j] &lt; 1</code>, the trip speeds up.</li>
</ul>

<p>Each individual <code>i</code> has a rowing strength represented by <code>time[i]</code>, the time (in minutes) it takes them to cross alone in neutral conditions.</p>

<p><strong>Rules:</strong></p>

<ul>
	<li>A group <code>g</code> departing at stage <code>j</code> takes time equal to the <strong>maximum</strong> <code>time[i]</code> among its members, multiplied by <code>mul[j]</code> minutes to reach the destination.</li>
	<li>After the group crosses the river in time <code>d</code>, the stage advances by <code>floor(d) % m</code> steps.</li>
	<li>If individuals are left behind, one person must return with the boat. Let <code>r</code> be the index of the returning person, the return takes <code>time[r] &times; mul[current_stage]</code>, defined as <code>return_time</code>, and the stage advances by <code>floor(return_time) % m</code>.</li>
</ul>

<p>Return the <strong>minimum</strong> total time required to transport all individuals. If it is not possible to transport all individuals to the destination, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 1, k = 1, m = 2, time = [5], mul = [1.0,1.3]</span></p>

<p><strong>Output:</strong> <span class="example-io">5.00000</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Individual 0 departs from stage 0, so crossing time = <code>5 &times; 1.00 = 5.00</code> minutes.</li>
	<li>All team members are now at the destination. Thus, the total time taken is <code>5.00</code> minutes.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, k = 2, m = 3, time = [2,5,8], mul = [1.0,1.5,0.75]</span></p>

<p><strong>Output:</strong> <span class="example-io">14.50000</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal strategy is:</p>

<ul>
	<li>Send individuals 0 and 2 from the base camp to the destination from stage 0. The crossing time is <code>max(2, 8) &times; mul[0] = 8 &times; 1.00 = 8.00</code> minutes. The stage advances by <code>floor(8.00) % 3 = 2</code>, so the next stage is <code>(0 + 2) % 3 = 2</code>.</li>
	<li>Individual 0 returns alone from the destination to the base camp from stage 2. The return time is <code>2 &times; mul[2] = 2 &times; 0.75 = 1.50</code> minutes. The stage advances by <code>floor(1.50) % 3 = 1</code>, so the next stage is <code>(2 + 1) % 3 = 0</code>.</li>
	<li>Send individuals 0 and 1 from the base camp to the destination from stage 0. The crossing time is <code>max(2, 5) &times; mul[0] = 5 &times; 1.00 = 5.00</code> minutes. The stage advances by <code>floor(5.00) % 3 = 2</code>, so the final stage is <code>(0 + 2) % 3 = 2</code>.</li>
	<li>All team members are now at the destination. The total time taken is <code>8.00 + 1.50 + 5.00 = 14.50</code> minutes.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, k = 1, m = 2, time = [10,10], mul = [2.0,2.0]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1.00000</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Since the boat can only carry one person at a time, it is impossible to transport both individuals as one must always return. Thus, the answer is <code>-1.00</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == time.length &lt;= 12</code></li>
	<li><code>1 &lt;= k &lt;= 5</code></li>
	<li><code>1 &lt;= m &lt;= 5</code></li>
	<li><code>1 &lt;= time[i] &lt;= 100</code></li>
	<li><code>m == mul.length</code></li>
	<li><code>0.5 &lt;= mul[i] &lt;= 2.0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-155">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Time to Visit a Cell In a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers where <code>grid[row][col]</code> represents the <strong>minimum</strong> time required to be able to visit the cell <code>(row, col)</code>, which means you can visit the cell <code>(row, col)</code> only when the time you visit it is greater than or equal to <code>grid[row][col]</code>.</p>

<p>You are standing in the <strong>top-left</strong> cell of the matrix in the <code>0<sup>th</sup></code> second, and you must move to <strong>any</strong> adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.</p>

<p>Return <em>the <strong>minimum</strong> time required in which you can visit the bottom-right cell of the matrix</em>. If you cannot visit the bottom-right cell, then return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png" /></p>

<pre>
<strong>Input:</strong> grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> One of the paths that we can take is the following:
- at t = 0, we are on the cell (0,0).
- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1.
- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2.
- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3.
- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4.
- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5.
- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6.
- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7.
The final time is 7. It can be shown that it is the minimum time possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png" style="width: 151px; height: 151px;" /></p>

<pre>
<strong>Input:</strong> grid = [[0,2,4],[3,2,1],[1,0,4]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no path from the top left to the bottom-right cell.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[0][0] == 0</code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-modified-dijkstras-algorithm">Approach: Modified Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a matrix <code>grid</code> where each cell contains the minimum time required for that cell to be accessible. In other words, if we begin at the top-left cell and each move takes 1 second, the value in each cell tells us the minimum time after which we can enter it.</p>
<p>The challenge arises when we find ourselves stuck in a cell, unable to move forward because all neighboring cells are inaccessible, with higher minimum times. In such situations, we must &quot;waste&quot; time to move forward. How do we do that? By wandering around! We can move back and forth between the current cell and any previously accessible cells until a neighboring cell becomes accessible.</p>
<p>The time we need to &quot;waste&quot; is determined by the difference between the current cell’s time and the minimum time of an accessible neighboring cell. It’s important to note that each unit of time wasted takes 2 seconds since we travel to a previous cell and return to the current cell. Therefore, if the difference between the current time and the target cell's time is odd, we can step into the target cell exactly when it becomes accessible. Here's a slideshow demonstrating that:</p>
<p>!?!../Documents/2577/odd_slideshow.json:564,822!?!</p>
<p>On the other hand, if the difference is even, we’ll arrive at the target cell 1 second after it has opened:</p>
<p>!?!../Documents/2577/even_slideshow.json:564,822!?!</p>
<p>Next, let’s discuss the base case. If we are at the top-left corner and all neighboring cells have a minimum time greater than 1, we are stuck. There are no other accessible cells to waste time on, and thus, the solution is not possible. In this case, we return -1.</p>
<p>Otherwise, a solution exists. We can apply Dijkstra’s shortest path algorithm with a priority queue, starting from the top-left cell. Each element in the queue holds the cell’s coordinates and the time taken to reach it, ordered by time in ascending order. We also maintain a <code>visited</code> matrix to track the cells we have already processed. For each cell in the queue, we check its neighbors, compute the time required to enter each one, and add any accessible neighbors to the queue, adjusting for the waiting time. When we reach the bottom-right corner, we return the associated time as the final answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Check if both initial moves (right and down) in the grid require more than 1 second:</p>
<ul>
<li>If both <code>grid[0][1] &gt; 1</code> and <code>grid[1][0] &gt; 1</code>, return <code>-1</code> because it’s impossible to proceed.</li>
</ul>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>rows</code> and <code>cols</code> store the dimensions of the grid.</li>
<li><code>directions</code> array defines the possible moves: down, up, right, and left.</li>
<li><code>visited</code> array keeps track of visited cells.</li>
<li><code>pq</code> is a priority queue that stores <code>{time, row, col}</code> tuples, ordered by minimum time to reach each cell.</li>
</ul>
</li>
<li>
<p>Add the starting point (top-left cell) to the priority queue with its initial time (<code>grid[0][0]</code>).</p>
</li>
<li>
<p>While the priority queue is not empty:</p>
<ul>
<li>
<p>Poll the cell with the minimum time (<code>time, row, col</code>).</p>
</li>
<li>
<p>If the target cell (bottom-right) is reached, return the <code>time</code>.</p>
</li>
<li>
<p>Skip the current cell if it has already been visited.</p>
</li>
<li>
<p>Mark the current cell as visited.</p>
</li>
<li>
<p>For each of the four possible directions:</p>
<ul>
<li>Calculate the next cell coordinates (<code>nextRow, nextCol</code>).</li>
<li>If the cell is valid (within bounds and not visited), calculate the additional wait time for the next cell:
<ul>
<li>If the difference between the grid value and the current time is even, the additional wait time is <code>1</code>.</li>
<li>Otherwise, the wait time is <code>0</code>.</li>
</ul>
</li>
<li>Calculate the next possible time based on the grid value and the wait time, and add the new <code>{nextTime, nextRow, nextCol}</code> to the priority queue.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the loop ends without reaching the target, return <code>-1</code> (no path found).</p>
</li>
<li>
<p>Helper function <code>isValid</code>:</p>
<ul>
<li>Check if a cell is within bounds and has not been visited.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/J2vnwBjv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>In the main loop, the priority queue operations (insertion and deletion) take <span class="math inline">\(O(\log k)\)</span> time where <span class="math inline">\(k\)</span> is the number of elements in the queue. Since each cell is added to the queue exactly once, the queue size is bounded by <span class="math inline">\(O(m \cdot n)\)</span>. Therefore, with <span class="math inline">\(O(m \cdot n)\)</span> cells and <span class="math inline">\(O(\log(m \cdot n))\)</span> time for each queue operation, the total time complexity is <span class="math inline">\(O(m \cdot n\log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is determined by two main components: the <code>visited</code> boolean matrix and the priority queue, both of which use <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-156">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-visit-disappearing-nodes/description" target="_blank" rel="noopener noreferrer">Minimum Time to Visit Disappearing Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected graph of <code>n</code> nodes. You are given a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code> describes an edge between node <code>u<sub>i</sub></code> and node <code>v<sub>i</sub></code> with a traversal time of <code>length<sub>i</sub></code> units.</p>

<p>Additionally, you are given an array <code>disappear</code>, where <code>disappear[i]</code> denotes the time when the node <code>i</code> disappears from the graph and you won&#39;t be able to visit it.</p>

<p><strong>Note</strong>&nbsp;that the graph might be <em>disconnected</em> and might contain <em>multiple edges</em>.</p>

<p>Return the array <code>answer</code>, with <code>answer[i]</code> denoting the <strong>minimum</strong> units of time required to reach node <code>i</code> from node 0. If node <code>i</code> is <strong>unreachable</strong> from node 0 then <code>answer[i]</code> is <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/output-onlinepngtools.png" style="width: 350px; height: 210px;" /></p>

<p>We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.</p>

<ul>
	<li>For node 0, we don&#39;t need any time as it is our starting point.</li>
	<li>For node 1, we need at least 2 units of time to traverse <code>edges[0]</code>. Unfortunately, it disappears at that moment, so we won&#39;t be able to visit it.</li>
	<li>For node 2, we need at least 4 units of time to traverse <code>edges[2]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/output-onlinepngtools-1.png" style="width: 350px; height: 210px;" /></p>

<p>We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.</p>

<ul>
	<li>For node 0, we don&#39;t need any time as it is the starting point.</li>
	<li>For node 1, we need at least 2 units of time to traverse <code>edges[0]</code>.</li>
	<li>For node 2, we need at least 3 units of time to traverse <code>edges[0]</code> and <code>edges[1]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1,1]], disappear = [1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1]</span></p>

<p><strong>Explanation:</strong></p>

<p>Exactly when we reach node 1, it disappears.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>disappear.length == n</code></li>
	<li><code>1 &lt;= disappear[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-157">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/description" target="_blank" rel="noopener noreferrer">Minimum Weighted Subgraph With the Required Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> denoting the number of nodes of a <strong>weighted directed</strong> graph. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> denotes that there exists a <strong>directed</strong> edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with weight <code>weight<sub>i</sub></code>.</p>

<p>Lastly, you are given three <strong>distinct</strong> integers <code>src1</code>, <code>src2</code>, and <code>dest</code> denoting three distinct nodes of the graph.</p>

<p>Return <em>the <strong>minimum weight</strong> of a subgraph of the graph such that it is <strong>possible</strong> to reach</em> <code>dest</code> <em>from both</em> <code>src1</code> <em>and</em> <code>src2</code> <em>via a set of edges of this subgraph</em>. In case such a subgraph does not exist, return <code>-1</code>.</p>

<p>A <strong>subgraph</strong> is a graph whose vertices and edges are subsets of the original graph. The <strong>weight</strong> of a subgraph is the sum of weights of its constituent edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png" style="width: 263px; height: 250px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
<strong>Output:</strong> 9
<strong>Explanation:</strong>
The above figure represents the input graph.
The blue edges represent one of the subgraphs that yield the optimal answer.
Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png" style="width: 350px; height: 51px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong>
The above figure represents the input graph.
It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li><code>src1</code>, <code>src2</code>, and <code>dest</code> are pairwise distinct.</li>
	<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-158">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/modify-graph-edge-weights/description" target="_blank" rel="noopener noreferrer">Modify Graph Edge Weights</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <strong>undirected weighted</strong> <strong>connected</strong> graph containing <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, and an integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>Some edges have a weight of <code>-1</code> (<code>w<sub>i</sub> = -1</code>), while others have a <strong>positive</strong> weight (<code>w<sub>i</sub> &gt; 0</code>).</p>

<p>Your task is to modify <strong>all edges</strong> with a weight of <code>-1</code> by assigning them <strong>positive integer values </strong>in the range <code>[1, 2 * 10<sup>9</sup>]</code> so that the <strong>shortest distance</strong> between the nodes <code>source</code> and <code>destination</code> becomes equal to an integer <code>target</code>. If there are <strong>multiple</strong> <strong>modifications</strong> that make the shortest distance between <code>source</code> and <code>destination</code> equal to <code>target</code>, any of them will be considered correct.</p>

<p>Return <em>an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from </em><code>source</code><em> to </em><code>destination</code><em> equal to </em><code>target</code><em>, or an <strong>empty array</strong> if it&#39;s impossible.</em></p>

<p><strong>Note:</strong> You are not allowed to modify the weights of edges with initial positive weights.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/18/graph.png" style="width: 300px; height: 300px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
<strong>Output:</strong> [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
<strong>Explanation:</strong> The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/18/graph-2.png" style="width: 300px; height: 300px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
<strong>Output:</strong> []
<strong>Explanation:</strong> The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/19/graph-3.png" style="width: 300px; height: 300px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
<strong>Output:</strong> [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
<strong>Explanation:</strong> The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code><font face="monospace">1 &lt;= edges.length &lt;= n * (n - 1) / 2</font></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i&nbsp;</sub>&lt;&nbsp;n</code></li>
	<li><code><font face="monospace">w<sub>i</sub>&nbsp;= -1&nbsp;</font></code>or <code><font face="monospace">1 &lt;= w<sub>i&nbsp;</sub>&lt;= 10<sup><span style="font-size: 10.8333px;">7</span></sup></font></code></li>
	<li><code>a<sub>i&nbsp;</sub>!=&nbsp;b<sub>i</sub></code></li>
	<li><code>0 &lt;= source, destination &lt; n</code></li>
	<li><code>source != destination</code></li>
	<li><code><font face="monospace">1 &lt;= target &lt;= 10<sup>9</sup></font></code></li>
	<li>The graph is connected, and there are no self-loops or repeated edges</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We've got a connected graph with <code>n</code> nodes, where edges connect pairs of nodes with certain weights. Our goal is to adjust the graph so that the shortest path between two specific nodes, <code>source</code> and <code>destination</code>, matches a given target distance.</p>
<p>The input provides:</p>
<ul>
<li>The number of nodes <code>n</code>.</li>
<li>A list of edges, each described by <span class="math inline">\([a_i, b_i, w_i]\)</span>, where <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_i\)</span> are the nodes connected by the edge, and <span class="math inline">\(w_i\)</span> is its weight.</li>
<li>Two nodes, <code>source</code> and <code>destination</code>.</li>
<li>A <code>target</code> distance that we want the shortest path between <code>source</code> and <code>destination</code> to exactly match.</li>
</ul>
<p>Some edges have weights of <code>-1</code>, meaning we need to assign them positive weights. Other edges have fixed weights that can’t be changed.</p>
<p>Our task is to find positive weights for the <code>-1</code> edges so that the shortest path from <code>source</code> to <code>destination</code> equals the <code>target</code> distance. The new weights should be between <code>1</code> and <code>2 * 10^9</code>.</p>
<p>If we can adjust the weights to meet the target distance, we return the updated list of edges. If not, we return an empty list. There might be several correct ways to set the weights, and any of them will work.</p>
<p>This problem is similar to designing a road network where some roads have fixed distances and others are planned but not yet constructed. The challenge is to adjust the planned road lengths so that the shortest route between two cities meets the specified distance, all while considering the existing infrastructure.</p>
<p>To fully grasp the solution, it’s a good idea to review <a href="https://leetcode.com/explore/featured/card/graph/">Dijkstra's algorithm</a> first, as our approach relies heavily on its principles.</p>
<hr />
<h3 id="approach-1-traditional-dijkstras-algorithm">Approach 1: Traditional Dijkstra's algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>The idea behind the solution is to use Dijkstra's algorithm, which is great for finding the shortest paths in a graph with non-negative edge weights. We tweak the algorithm a bit to handle situations where some of the edge weights have to be figured out as we go along.</p>
<p>We start by running Dijkstra's algorithm but ignore any edges with weights of <code>-1</code> for now. This first run helps us find the shortest distance from the <code>source</code> to the <code>destination</code>. We then check how this distance compares to our <code>target</code> distance.</p>
<ol>
<li>
<p>If the shortest distance matches the <code>target</code>, the current positive weights already give us the desired path length. In this case, we can set the <code>-1</code> edges to a large value (like <code>2 × 10^9</code>) to make sure they don’t change the shortest path.</p>
</li>
<li>
<p>If the shortest distance is less than the <code>target</code>, there’s no way to extend the path to reach the <code>target</code> just by adjusting the <code>-1</code> edges. In this scenario, the graph structure doesn’t support increasing the path length, so we return an empty list.</p>
</li>
<li>
<p>If the shortest distance is more than the <code>target</code>, we need to reduce the path length by tweaking the <code>-1</code> edges.</p>
</li>
</ol>
<p>We start by setting a high weight on the <code>-1</code> edges to ensure they don’t interfere with our initial path calculation. Then, we adjust the weight of each <code>-1</code> edge to a smaller value (like <code>1</code>) and rerun Dijkstra’s algorithm to see if the shortest path gets closer to the target distance.</p>
<p>If changing an edge’s weight helps get the shortest path closer to the target, we update the weight. We repeat this until we find suitable weights for all <code>-1</code> edges that give us the target distance.</p>
<p>If we manage to find weights that achieve the target distance, we return the updated edge list. If not, we return an empty list.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define <code>INF</code> as a large constant representing infinity.</li>
</ul>
<p>Inside the main function <code>modifiedGraphEdges</code>:</p>
<ul>
<li>Calculate the initial shortest path from <code>source</code> to <code>destination</code> using Dijkstra's algorithm(<code>runDijkstra</code> helper function), storing the result in <code>currentShortestDistance</code>.</li>
<li>Check if the current distance is less than the target:
<ul>
<li>If yes, return an empty result as it's impossible to achieve the target distance.</li>
</ul>
</li>
<li>Determine if the current distance matches the target:
<ul>
<li>If it does, set a flag <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>Iterate through each edge to adjust weights:
<ul>
<li>Skip edges that already have a positive weight since they don't need adjustment.</li>
<li>Set edge weight:
<ul>
<li>If <code>matchesTarget</code> is true, set the weight to a large value (<code>INF</code>).</li>
<li>Otherwise, set the weight to 1.</li>
</ul>
</li>
</ul>
</li>
<li>Check if the current distance matches the target:
<ul>
<li>If not, recompute the shortest distance using Dijkstra's algorithm with the updated edge weights.</li>
<li>If the new distance is within the target range, adjust the edge weight to match the target, and update <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>Return modified edges:
<ul>
<li>If the target distance is achieved (<code>matchesTarget</code> is true), return the modified edges.</li>
<li>Otherwise, return an empty result.</li>
</ul>
</li>
</ul>
<p>Inside the helper function <code>runDijkstra</code>:</p>
<ul>
<li>Initialize adjacency matrix with a large value (<code>INF</code>) to represent no direct connection between nodes.</li>
<li>Initialize distance array to store the minimum distance from the source node to each node, initially set to <code>INF</code>.</li>
<li>Mark the distance to the source node as 0 because the shortest path to itself is zero.</li>
<li>Fill the adjacency matrix with the weights of the edges from the input.</li>
<li>Perform Dijkstra's algorithm:
<ul>
<li>Iterate through all nodes to find the shortest path.</li>
<li>Find the nearest unvisited node with the smallest distance from the source.</li>
<li>Mark the nearest node as visited to avoid reprocessing.</li>
<li>Update the minimum distance for each adjacent node based on the newly visited node's distance.</li>
</ul>
</li>
<li>Return the shortest distance to the destination node as the result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4wcKVMHK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(V\)</span> be the number of nodes and <span class="math inline">\(E\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(E \times V^2)\)</span></p>
<p>Dijkstra's algorithm runs in <span class="math inline">\(O(V^2)\)</span> time, due to the adjacency matrix representation.</p>
<p>The overall complexity is <span class="math inline">\(O(E \times V^2)\)</span> because we potentially run Dijkstra's algorithm for each modifiable edge.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(V^2)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(V^2)\)</span> due to the adjacency matrix, with additional space for the distance and visited arrays.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dijkstras-algorithm-with-min-heap">Approach 2: Dijkstra's Algorithm with Min-Heap</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the traditional approach, after initializing distances, we repeatedly scan all nodes to find the unvisited node with the smallest tentative distance. This operation takes <span class="math inline">\(O(n)\)</span> time per selection, leading to an overall time complexity of <span class="math inline">\(O(n^2)\)</span> in the worst case.</p>
<p>To optimize this, we use a priority queue (min-heap) to manage and retrieve the node with the smallest tentative distance efficiently. When a node is processed, its neighbors are updated, and if a shorter path is found, the neighbor is pushed onto the priority queue with its updated distance. This ensures that the next node to be processed is always the one with the smallest distance.</p>
<p>Apart from the use of a priority queue, the approach remains largely the same: we construct the graph, ignoring edges with weights of <code>-1</code>, as these represent unknown or adjustable weights. We then compute the shortest distance from the source to the destination using the optimized Dijkstra algorithm. If the computed distance is already less than the target, we return an empty result.</p>
<p>If the distance matches the target, we set all <code>-1</code> edges to a large value (<code>INF</code>) to prevent any further adjustments. If the initial distance exceeds the target, we adjust the <code>-1</code> edges to a minimal weight of 1, re-run Dijkstra's algorithm, and fine-tune the last adjusted edge to exactly match the target.</p>
<blockquote>
<p>Here we require additional memory for the priority queue. The queue needs to store nodes and their tentative distances, which slightly increases memory usage, but this is usually a reasonable trade-off for the gained efficiency.</p>
</blockquote>
<p>!?!../Documents/2699/modifygraph.json:835,575!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define <code>INF</code> as a large constant representing infinity.</li>
</ul>
<p>Inside the main function <code>modifiedGraphEdges</code>:</p>
<ul>
<li>
<p>Build the graph:</p>
<ul>
<li>Iterate through each edge in the input list.</li>
<li>For edges with a positive weight (not <code>-1</code>), add them to the adjacency list for both nodes.</li>
</ul>
</li>
<li>
<p>Calculate the initial shortest path from <code>source</code> to <code>destination</code> using Dijkstra's algorithm (<code>runDijkstra</code> helper function), storing the result in <code>currentShortestDistance</code>.</p>
</li>
<li>
<p>Check if the current shortest distance is less than the target:</p>
<ul>
<li>If true, return an empty result as it is impossible to achieve the target distance with the given edges.</li>
</ul>
</li>
<li>
<p>Determine if the current distance matches the target:</p>
<ul>
<li>If it does, set a flag <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>
<p>Iterate through each edge to adjust weights:</p>
<ul>
<li>Skip edges that already have a positive weight since they don't need adjustment.</li>
<li>For each edge with weight <code>-1</code>:
<ul>
<li>Set the edge weight to a large value (<code>INF</code>) if <code>matchesTarget</code> is true.</li>
<li>Otherwise, set the edge weight to 1.</li>
<li>Update the adjacency list with the new weight.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check if the updated shortest distance matches the target:</p>
<ul>
<li>If <code>matchesTarget</code> is false, recompute the shortest distance using Dijkstra's algorithm with the updated edge weights.</li>
<li>If the new distance is within the target range, adjust the edge weight to match the target distance, and update <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>
<p>Return modified edges:</p>
<ul>
<li>If the target distance is achieved (<code>matchesTarget</code> is true), return the modified edges.</li>
<li>Otherwise, return an empty result.</li>
</ul>
</li>
</ul>
<p>Inside the helper function <code>runDijkstra</code>:</p>
<ul>
<li>
<p>Initialize the <code>minDistance</code> array to store the minimum distance from the source node to each node, initially set to <code>INF</code>.</p>
</li>
<li>
<p>Initialize a priority queue to process nodes in order of their current known shortest distance.</p>
</li>
<li>
<p>Set the <code>minDistance</code> to the source node as 0 because the shortest path to itself is zero.</p>
</li>
<li>
<p>Perform Dijkstra's algorithm:</p>
<ul>
<li>Iterate through all nodes to find the shortest path.</li>
<li>Extract the node with the smallest distance from the source.</li>
<li>Update the minimum distance for each adjacent node based on the extracted node's distance.</li>
<li>Push updated distances into the priority queue.</li>
</ul>
</li>
<li>
<p>Return the shortest distance to the destination node as the result.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GmrtoLsP/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(V\)</span> be the number of nodes and <span class="math inline">\(E\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(E \times (V + E) \log V)\)</span></p>
<p>Dijkstra's algorithm operates with a time complexity of <span class="math inline">\(O((V + E) \log V)\)</span> when using a priority queue (min-heap). This is because each vertex and edge is processed at most once, and each priority queue operation (insertion and extraction) takes <span class="math inline">\(O(\log V)\)</span> time.</p>
<p>Dijkstra's algorithm once executes the shortest path from the source to the destination with the current weights. Then, for each edge that weights <code>-1</code>, Dijkstra's algorithm is rerun after modifying the edge weight. In the worst-case scenario, where all edges weigh <code>-1</code>, this results in running Dijkstra's up to <span class="math inline">\(E\)</span> times.</p>
<p>Thus, the overall time complexity for handling all possible edge modifications is <span class="math inline">\(O(E \times (V + E) \log V)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(V + E)\)</span></p>
<p>The adjacency list representation of the graph requires <span class="math inline">\(O(V + E)\)</span> space. Each vertex has a list of its adjacent vertices and their corresponding edge weights.</p>
<p>Dijkstra’s algorithm uses an array to store the shortest distance from the source to each vertex, which requires <span class="math inline">\(O(V)\)</span> space.</p>
<p>The priority queue used during Dijkstra's algorithm can hold up to <span class="math inline">\(V\)</span> elements, which also requires <span class="math inline">\(O(V)\)</span> space.</p>
<p>Summing up these components, the total space complexity is <span class="math inline">\(O(V + E)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-159">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-profitable-path-in-a-tree/description" target="_blank" rel="noopener noreferrer">Most Profitable Path in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>At every node <code>i</code>, there is a gate. You are also given an array of even integers <code>amount</code>, where <code>amount[i]</code> represents:</p>

<ul>
	<li>the price needed to open the gate at node <code>i</code>, if <code>amount[i]</code> is negative, or,</li>
	<li>the cash reward obtained on opening the gate at node <code>i</code>, otherwise.</li>
</ul>

<p>The game goes on as follows:</p>

<ul>
	<li>Initially, Alice is at node <code>0</code> and Bob is at node <code>bob</code>.</li>
	<li>At every second, Alice and Bob <b>each</b> move to an adjacent node. Alice moves towards some <strong>leaf node</strong>, while Bob moves towards node <code>0</code>.</li>
	<li>For <strong>every</strong> node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
	<ul>
		<li>If the gate is <strong>already open</strong>, no price will be required, nor will there be any cash reward.</li>
		<li>If Alice and Bob reach the node <strong>simultaneously</strong>, they share the price/reward for opening the gate there. In other words, if the price to open the gate is <code>c</code>, then both Alice and Bob pay&nbsp;<code>c / 2</code> each. Similarly, if the reward at the gate is <code>c</code>, both of them receive <code>c / 2</code> each.</li>
	</ul>
	</li>
	<li>If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node <code>0</code>, he stops moving. Note that these events are <strong>independent</strong> of each other.</li>
</ul>

<p>Return<em> the <strong>maximum</strong> net income Alice can have if she travels towards the optimal leaf node.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/29/eg1.png" style="width: 275px; height: 275px;" />
<pre>
<strong>Input:</strong> edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The above diagram represents the given tree. The game goes as follows:
- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.
  Alice&#39;s net income is now -2.
- Both Alice and Bob move to node 1. 
&nbsp; Since they reach here simultaneously, they open the gate together and share the reward.
&nbsp; Alice&#39;s net income becomes -2 + (4 / 2) = 0.
- Alice moves on to node 3. Since Bob already opened its gate, Alice&#39;s income remains unchanged.
&nbsp; Bob moves on to node 0, and stops moving.
- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.
Now, neither Alice nor Bob can make any further moves, and the game ends.
It is not possible for Alice to get a higher net income.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/29/eg2.png" style="width: 250px; height: 78px;" />
<pre>
<strong>Input:</strong> edges = [[0,1]], bob = 1, amount = [-7280,2350]
<strong>Output:</strong> -7280
<strong>Explanation:</strong> 
Alice follows the path 0-&gt;1 whereas Bob follows the path 1-&gt;0.
Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>1 &lt;= bob &lt; n</code></li>
	<li><code>amount.length == n</code></li>
	<li><code>amount[i]</code> is an <strong>even</strong> integer in the range <code>[-10<sup>4</sup>, 10<sup>4</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a tree with <code>n</code> nodes, where <code>n - 1</code> edges define its structure. The tree is rooted at node <code>0</code>. Additionally, we are provided with an array <code>amount</code> of size <code>n</code>, where each element represents the value of a node. All values in <code>amount</code> are even integers. Finally, we are given an integer <code>bob</code>, which indicates the starting node for Bob.</p>
<p>The two players Alice and Bob, traverse the tree simultaneously under the following conditions:</p>
<ol>
<li>Alice starts at node <code>0</code> and moves towards a leaf node (a node with only one connection).</li>
<li>Bob starts at node <code>bob</code> and moves towards node <code>0</code> along the shortest path.</li>
</ol>
<p>For each node visited, the income calculations follow these rules:</p>
<ul>
<li>If a player reaches a node first, they collect the full value of that node.</li>
<li>If both players arrive at the same node at the same time, they split the value equally.</li>
<li>If a node was previously visited by the other player, no income is collected.</li>
</ul>
<p>Our goal is to find the largest (maximum) income Alice can collect by choosing an optimal path toward a leaf node.</p>
<p>Let's look at an example of finding the maximum income that Alice can achieve:</p>
<p>!?!../Documents/2467/slideshow.json:960,540!?!</p>
<p>In the given example, Bob’s path is fixed since he must travel toward node 0, while Alice has multiple choices for reaching a leaf. Some paths might yield higher income than others due to how Bob’s movements impact the node values. The key is to strategically choose a path that maximizes Alice’s total earnings.</p>
<hr />
<h3 id="approach-1-depth-first-search-and-breadth-first-search">Approach 1: Depth-First Search and Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find Bob’s path to node <code>0</code> and then find the best path Alice can take to maximize her collected amount. Since Bob only has one possible path to node <code>0</code> — the unique path from his starting position to the root — we can take advantage of this structure to track Bob’s travel time across each node.</p>
<p>To find Bob’s path, we use <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">Depth-First Search (DFS)</a>. DFS is a natural choice because it fully explores each path before backtracking, allowing us to efficiently find the path Bob follows to the root. As we traverse, we record how long it takes Bob to reach each node along his path. Nodes not on this path are ignored since Bob never visits them.</p>
<p>Once Bob’s path is established, our next goal is to find Alice’s optimal path to a leaf node. Unlike Bob, Alice has multiple choices since a tree can have multiple leaves. This means we need an approach that considers all possible paths efficiently.</p>
<p>For this, we use <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Breadth-First Search (BFS)</a>. BFS systematically explores all nodes level by level, making it ideal for finding optimal paths. We start at the root node (<code>0</code>) and explore all adjacent nodes before moving deeper into the tree. This ensures that every possible path Alice can take is considered.</p>
<p>As Alice traverses, we use Bob’s path information to determine how much of the amount Alice can collect from each node. If Alice reaches a node before Bob, she takes the <strong>full amount</strong>. If Alice and Bob arrive at the same time, Alice only takes <strong>half</strong>. If Alice arrives after Bob, she gets <strong>nothing</strong> from that node.</p>
<p>Whenever Alice reaches a leaf node, we check her accumulated income along that path. If it is greater than the maximum recorded income, we update our maximum. By the end of the BFS traversal, we will have explored all valid paths for Alice and can return the highest income she can achieve.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>tree</code> as an adjacency list to store the tree structure.</p>
</li>
<li>
<p>Initialize <code>bobPath</code> as a hashmap to track how long it takes Bob to traverse from one node to another.</p>
</li>
<li>
<p>Initialize <code>visited</code> as an array of boolean values to track the explored nodes.</p>
</li>
<li>
<p>Store the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Define a Depth-First Search (DFS) function <code>findBobPath</code>:</p>
<ul>
<li>Set <code>bobPath[sourceNode]</code> to <code>time</code> and <code>visited[sourceNode]</code> to <code>true</code> to mark the current node as explored.</li>
<li>If <code>sourceNode</code> is 0, return <code>true</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>, recursively call <code>findBobPath</code> for the child node and return <code>true</code>.</li>
</ul>
</li>
<li>Remove <code>sourceNode</code>  from <code>bobPath</code> and return <code>false</code>, indicating that <code>sourceNode</code> is not part of Bob's path.</li>
</ul>
</li>
<li>
<p>Define <code>mostProfitablePath</code> function:</p>
<ul>
<li>Initialize <code>maxIncome</code> to 0 to track the maximum income path.</li>
<li>Initialize <code>nodeQueue</code> as a queue of integer arrays of size <code>3</code>, starting with an initial element <code>{0,0,0}</code>.</li>
<li>Set <code>n</code> as the number of nodes.</li>
<li>Resize <code>tree</code> to store <code>n</code> empty lists.</li>
<li>Resize <code>visited</code> to store <code>n</code> boolean values and set each value to <code>false</code>.</li>
<li>Iterate through <code>edges</code> and build the adjacency list representation of the tree.</li>
<li>Call <code>findBobPath(bob, 0)</code> to build Bob's path.</li>
<li>Set the values of <code>visited</code> back to <code>false</code>.</li>
<li>Iterate through the elements in <code>nodeQueue</code>. For each element:
<ul>
<li>Initialize <code>sourceNode</code>, <code>time</code>, and <code>income</code> to the values of the top element of <code>nodeQueue</code>.</li>
<li>If Alice reaches the node first (<code>sourceNode</code> is not in <code>bobPath</code> or <code>bobPath[sourceNode] &gt; time</code>), add <code>amount[sourceNode]</code> to <code>income</code>.</li>
<li>If Alice and Bob reach the node at the same time (<code>bobPath[sourceNode] == time</code>), add half of <code>amount[sourceNode]</code> to <code>income</code>.</li>
<li>If Alice reached a leaf node (<code>tree[sourceNode]</code> only has one value and <code>sourceNode</code> is not <code>0</code>), set <code>maxIncome</code> to the maximum of <code>maxIncome</code> and <code>income</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>:, push an array consisting of <code>adjacentNode</code>, <code>time + 1</code>, and <code>income</code> into <code>nodeQueue</code>.</li>
</ul>
</li>
<li>Set <code>visited[sourceNode]</code> as <code>true</code> to mark the current node as explored.</li>
<li>Remove the current element from <code>nodeQueue</code>.</li>
</ul>
</li>
<li>Return <code>maxIncome</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NTXgC95P/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To begin, to add all the edges to <code>tree</code>, we have to iterate through all the elements of <code>edges</code>, which is of size <span class="math inline">\(n - 1\)</span>. This leads to a time complexity of <span class="math inline">\(O(n - 1)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we have to figure out how long it takes Bob to find the optimal path to node 0. In the worst case, a depth-first search for Bob's path takes <span class="math inline">\(O(n)\)</span> time if Bob traverses through every node to reach node <code>0</code>. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we need to calculate the time it takes for Alice to find the optimal path to a leaf node. Here, a breadth-first search traverses each node until every node has been explored. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these time complexities, the overall time complexity of this solution is <span class="math inline">\(O(3 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the <code>bobPath</code> hashmap, <code>visited</code> and <code>tree</code> arrays,  <code>nodeQueue</code> queue, and the recursive stack.</p>
<p>Firstly, <code>bobPath</code> stores the nodes that bob traverses to reach node 0. In the worst case, Bob has to traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>visited</code> array is initialized to hold <code>n</code> boolean values corresponding to each node, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>tree</code> 2D array is initialized to hold <span class="math inline">\(n\)</span> nodes and <span class="math inline">\(n - 1\)</span> edges. Across all the nodes, the total number of elements stored in the array is <span class="math inline">\(2 \cdot (n - 1)\)</span>, since each edge is stored twice, once for each node. This leads to a space complexity of <span class="math inline">\(O(2 \cdot (n - 1))\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>nodeQueue</code> queue tracks all the nodes being traversed in the breadth-first search. In the worst case, <code>nodeQueue</code> holds all the nodes in the tree if all other nodes are directly adjacent to node 0. This leads to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these space complexities, the overall space complexity of this solution is <span class="math inline">\(O(5 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-depth-first-searches">Approach 2: Two Depth-First Searches</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used BFS to explore all possible paths Alice could take. However, BFS requires maintaining a queue to track nodes at each level, which can introduce overhead when dealing with large trees. Each node needs to be added and removed from the queue multiple times, leading to additional memory usage.</p>
<p>To optimize this, we can replace BFS with DFS for Alice’s traversal. DFS naturally fits the problem because we can reuse the recursive call stack instead of an explicit queue, reducing memory overhead. This makes the approach more space-efficient while still ensuring that all paths are explored.</p>
<p>We start with a <strong>DFS traversal to find Bob’s path</strong> to node <code>0</code>. This step remains unchanged from the previous approach. We record the time Bob takes to reach each node along his path. This information will be used later to determine how much Alice can collect from each node.</p>
<p>Once Bob’s path is identified, we initiate <strong>another DFS traversal for Alice</strong>. During this traversal, we recursively explore each path from node <code>0</code> to a leaf, keeping track of Alice’s time and accumulated income. At each node, we compare Alice’s arrival time with Bob’s recorded time:</p>
<ul>
<li>If Alice arrives <strong>before</strong> Bob, she collects the full amount.</li>
<li>If Alice and Bob arrive <strong>at the same time</strong>, she collects half.</li>
<li>If Alice arrives <strong>after</strong> Bob, she collects nothing.</li>
</ul>
<p>Since DFS explores one path at a time before backtracking, when Alice reaches a leaf node, we record her total collected income and compare it to the current maximum. We repeat this process until all paths are explored.</p>
<p>By the end of the traversal, we will have determined the largest income Alice can achieve and return this value as the result.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>maxIncome</code> to 0 to track the maximum income path.</p>
</li>
<li>
<p>Initialize <code>tree</code> as an adjacency list to store the tree structure.</p>
</li>
<li>
<p>Initialize <code>bobPath</code> as a hashmap to track how long it takes Bob to traverse from one node to another.</p>
</li>
<li>
<p>Initialize <code>visited</code> as an array of boolean values to track the explored nodes.</p>
</li>
<li>
<p>Store the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Define a Depth-First Search (DFS) function <code>findBobPath</code>:</p>
<ul>
<li>Set <code>bobPath[sourceNode]</code> to <code>time</code> and <code>visited[sourceNode]</code> to <code>true</code> to mark the current node as explored.</li>
<li>If <code>sourceNode</code> is 0, return <code>true</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>, recursively call <code>findBobPath</code> for the child node and return <code>true</code>.</li>
</ul>
</li>
<li>Remove <code>sourceNode</code>  from <code>bobPath</code> and return <code>false</code>, indicating that <code>sourceNode</code> is not part of Bob's path.</li>
</ul>
</li>
<li>
<p>Define a Depth-First Search (DFS) function  <code>findAlicePath</code>:</p>
<ul>
<li>Set <code>visited[sourceNode]</code> to <code>true</code> to mark the current node as explored.</li>
<li>If Alice and Bob reach the node at the same time (<code>bobPath[sourceNode] == time</code>), add half of <code>amount[sourceNode]</code> to <code>income</code>.</li>
<li>If Alice reached a leaf node (<code>tree[sourceNode]</code> only has one value and <code>sourceNode</code> is not <code>0</code>), set <code>maxIncome</code> to the maximum of <code>maxIncome</code> and <code>income</code>.</li>
<li>If Alice reached a leaf node (<code>tree[sourceNode]</code> only has one value and <code>sourceNode</code> is not <code>0</code>), set <code>maxIncome</code> to the maximum of <code>maxIncome</code> and <code>income</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>, recursively call <code>findAlicePath</code> for the child node.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Define <code>mostProfitablePath</code> function:</p>
<ul>
<li>Set <code>n</code> as the number of nodes.</li>
<li>Resize <code>tree</code> to store <code>n</code> empty lists.</li>
<li>Resize <code>visited</code> to store <code>n</code> boolean values and set each value to <code>false</code>.</li>
<li>Iterate through <code>edges</code> and build the adjacency list representation of the tree.</li>
<li>Call <code>findBobPath(bob, 0)</code> to build Bob's path.</li>
<li>Set the values of <code>visited</code> back to <code>false</code>.</li>
<li>Call <code>findAlicePath(0, 0, 0, amount)</code> to find Alice's optimal path, starting from the root node.</li>
<li>Return <code>maxIncome</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/UjEiiB3w/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To begin, to add all the edges to <code>tree</code>, we have to iterate through all the elements of <code>edges</code>, which is of size <span class="math inline">\(n - 1\)</span>. This leads to a time complexity of <span class="math inline">\(O(n - 1)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we have to figure out how long it takes Bob to find the optimal path to node 0. In the worst case, a depth-first search for Bob's path takes <span class="math inline">\(O(n)\)</span> time if Bob traverses through every node to reach node 0. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these time complexities, the overall time complexity of this solution is <span class="math inline">\(O(3 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the hashmap <code>bobPath</code>, arrays <code>visited</code> and <code>tree</code>, queue <code>nodeQueue</code>, and recursive stack.</p>
<p>Firstly, <code>bobPath</code> stores the nodes that Bob traverses to reach node <code>0</code>. In the worst case, Bob has to traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>visited</code> array is initialized to hold <code>n</code> boolean values, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>tree</code> 2D array is initialized to hold <span class="math inline">\(n\)</span> nodes and <span class="math inline">\(n - 1\)</span> edges. Across all the nodes, the total number of elements stored in the array is <span class="math inline">\(2(n - 1)\)</span>, since each edge is stored twice, once for each node. This leads to a space complexity of <span class="math inline">\(O(2(n - 1))\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these space complexities, the overall space complexity of this solution is <span class="math inline">\(O(4 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-depth-first-search">Approach 3: Depth-First Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The previous solution used two separate DFS traversals: one to determine Bob’s path and another to explore Alice’s optimal path. However, this causes redundancy, as each node may be visited twice. Instead, we can optimize the process by combining both tasks into a <strong>single DFS traversal</strong>, ensuring that we only explore each node once.</p>
<p>Our strategy is to use DFS to simultaneously track Bob’s path and compute Alice’s best possible income. Here, we first establish Bob’s travel time to each node. We initialize all node distances to <code>n</code>, a value greater than any possible travel time. As we traverse the tree, if a node is part of Bob’s path to <code>0</code>, we update its distance to reflect how long it takes for Bob to reach it. Nodes not on Bob’s path retain their initial value, ensuring that they are always considered as being reached <strong>after</strong> Alice.</p>
<p>With Bob’s travel times recorded, we can now determine how much Alice collects from each node while recursively traversing the tree. As Alice moves, we compare her arrival time at each node to Bob’s recorded time. If she reaches a node before Bob, she collects the <strong>full amount</strong>. If she and Bob arrive at the same time, she gets <strong>half</strong>. If she arrives after Bob, she receives <strong>nothing</strong>. By structuring the traversal this way, Alice's maximum income is updated dynamically as she moves deeper into the tree. This ensures that we efficiently compute the highest possible income while keeping the traversal to just one DFS pass.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>tree</code> as an adjacency list to store the tree structure.</p>
</li>
<li>
<p>Initialize <code>distanceFromBob</code> as an array to store the shortest distance of each node from Bob.</p>
</li>
<li>
<p>Store the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Define a Depth-First Search (DFS) function <code>findPaths</code>:</p>
<ul>
<li>Initialize <code>maxIncome</code> to 0 and <code>maxChild</code> to <code>INT_MIN</code> to track the maximum income path.</li>
<li>If <code>sourceNode</code> is <code>bob</code>, set its distance to 0; otherwise, set it to <code>n</code> (a large value).</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>adjacentNode</code> is not <code>parentNode</code>, recursively call <code>findPaths</code> for the child node.</li>
<li>Update <code>distanceFromBob[sourceNode]</code> as the minimum of its current value and the child's distance plus one.</li>
</ul>
</li>
<li>If Alice reaches the node first (<code>distanceFromBob[sourceNode] &gt; time</code>), add the node’s <code>amount</code> to <code>maxIncome</code>.</li>
<li>If Alice and Bob reach the node at the same time (<code>distanceFromBob[sourceNode] == time</code>), add half of <code>amount[sourceNode]</code> to <code>maxIncome</code>.</li>
<li>If <code>maxChild</code> remains <code>INT_MIN</code>, return <code>maxIncome</code> (indicating a leaf node).</li>
<li>Otherwise, return <code>maxIncome + maxChild</code> (adding the best income from child nodes).</li>
</ul>
</li>
<li>
<p>Define <code>mostProfitablePath</code> function:</p>
<ul>
<li>Set <code>n</code> as the number of nodes.</li>
<li>Resize <code>tree</code> to store <code>n</code> empty lists.</li>
<li>Iterate through <code>edges</code> and build the adjacency list representation of the tree.</li>
<li>Resize <code>distanceFromBob</code> to store <code>n</code> distances.</li>
<li>Return the result of <code>findPaths(0, 0, 0, bob, amount)</code>, starting from the root node.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/XuZtsRQF/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To begin, to add all the edges to <code>tree</code>, we have to iterate through all the elements of <code>edges</code>, which is size <span class="math inline">\(n - 1\)</span>. This leads to a time complexity of <span class="math inline">\(O(n - 1)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
<p>Then, we have to figure out how long it takes for Bob to find the path to node <code>0</code> and Alice to find an optimal path to a leaf node. Here, a depth-first search visits each node once to process Alice's maximum income based on Bob's distance from his starting point at each node. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these time complexities, the overall time complexity of this solution is <span class="math inline">\(O(2 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the <code>distanceFromBob</code> and <code>tree</code> arrays and the recursive stack.</p>
<p>Firstly, <code>distanceFromBob</code> checks every node in the tree, checking if they were traversed by Bob and, if so, how far they are from Bob's starting point. This leads to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, the <code>tree</code> 2D array is initialized to hold <span class="math inline">\(n\)</span> nodes and <span class="math inline">\(n - 1\)</span> edges. Across all the nodes, the total number of elements stored in the array is <span class="math inline">\(2 \cdot (n - 1)\)</span>, since each edge is stored twice, once for each node. This leads to a space complexity of <span class="math inline">\(O(2 \cdot (n - 1))\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these space complexities, the overall space complexity of this solution is <span class="math inline">\(O(3 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-160">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-stones-removed-with-same-row-or-column/description" target="_blank" rel="noopener noreferrer">Most Stones Removed with Same Row or Column</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On a 2D plane, we place <code>n</code> stones at some integer coordinate points. Each coordinate point may have at most one stone.</p>

<p>A stone can be removed if it shares either <strong>the same row or the same column</strong> as another stone that has not been removed.</p>

<p>Given an array <code>stones</code> of length <code>n</code> where <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the location of the <code>i<sup>th</sup></code> stone, return <em>the largest possible number of stones that can be removed</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One way to remove 5 stones is as follows:
1. Remove stone [2,2] because it shares the same row as [2,1].
2. Remove stone [2,1] because it shares the same column as [0,1].
3. Remove stone [1,2] because it shares the same row as [1,0].
4. Remove stone [1,0] because it shares the same column as [0,0].
5. Remove stone [0,1] because it shares the same row as [0,0].
Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One way to make 3 moves is as follows:
1. Remove stone [2,2] because it shares the same row as [2,0].
2. Remove stone [2,0] because it shares the same column as [0,0].
3. Remove stone [0,2] because it shares the same row as [0,0].
Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> stones = [[0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> [0,0] is the only stone on the plane, so you cannot remove it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>No two stones are at the same coordinate point.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2-D plane with <code>n</code> stones placed at integer coordinates, where a stone can be removed only if another stone shares either its row or column. Our task is to determine the maximum number of stones that can be removed from the plane under these conditions.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Two stones are considered &quot;connected&quot; if they share a row or column, but this connection extends beyond just pairs of stones. If stone A is connected to stone B and stone B is connected to stone C, then all three stones form part of the same group, even if A and C don’t directly share a row or column. This concept is akin to connected components in graph theory, where a connected component is a group of nodes where you can reach any node from any other node in the group. Take a look at the illustration below to visualize the components:</p>
<p><img src="../Figures/947_re/components.png" alt="connected components" /></p>
<p>Since every stone in a connected component shares a row or column with at least one other stone, we can remove all but one stone. The remaining stone cannot be removed as it no longer shares coordinates with any other stone, having eliminated all others in its component.</p>
<p>Therefore, if our 2-D plane contains multiple connected components, each can be reduced to a single stone. The maximum number of stones that can be removed can be mathematically expressed as:</p>
<pre><code>Max removable stones = Total stones - Number of connected components
</code></pre>
<details>
  <summary>Proof that in a connected component of stones, we can remove all but one stone.</summary>
<p>Base case: For <span class="math inline">\(n \leq 2\)</span>, the statement is trivially true.</p>
<ul>
<li>For <span class="math inline">\(n = 1\)</span>, we can't remove any stones.</li>
<li>For <span class="math inline">\(n = 2\)</span>, we can remove one stone, leaving the other.</li>
</ul>
<p>Inductive hypothesis: Assume the statement holds for all connected components of size <span class="math inline">\(k\)</span> or less, where <span class="math inline">\(k \geq 2\)</span>.</p>
<p>Inductive step: Consider a connected component <span class="math inline">\(C\)</span> of size <span class="math inline">\(k + 1\)</span>.</p>
<ol>
<li>Choose an arbitrary stone <span class="math inline">\(S\)</span> to keep.</li>
<li>The remaining <span class="math inline">\(k\)</span> stones form <span class="math inline">\(m\)</span> connected sub-components <span class="math inline">\(C_1\)</span>, <span class="math inline">\(C_2\)</span>, ..., <span class="math inline">\(C_m\)</span>, where <span class="math inline">\(1 ≤ m ≤ k\)</span>.</li>
<li>Let <span class="math inline">\(s_1\)</span>, <span class="math inline">\(s_2\)</span>, ..., <span class="math inline">\(s_m\)</span> be the sizes of these sub-components. We know that: <span class="math inline">\(s_1 + s_2 + ... + s_m = k\)</span></li>
<li>For each sub-component <span class="math inline">\(C_i\)</span>:
<ol>
<li>By the inductive hypothesis, we can remove all but one stone from <span class="math inline">\(C_i\)</span>.</li>
<li>Choose to keep the stone in <span class="math inline">\(C_i\)</span> that is connected to <span class="math inline">\(S\)</span> in the original component <span class="math inline">\(C\)</span>.</li>
</ol>
</li>
<li>After applying step 4 to all sub-components, we have removed: <span class="math inline">\((s_1 - 1) + (s_2 - 1) + ... + (s_m - 1) = (s_1 + s_2 + ... + s_m) - m = k - m\)</span> stones</li>
<li>We are now left with <span class="math inline">\(m + 1\)</span> stones: the <span class="math inline">\(m\)</span> stones we kept from each sub-component, plus our original chosen stone <span class="math inline">\(S\)</span>.</li>
<li>Each of these <span class="math inline">\(m\)</span> stones shares either a row or column with <span class="math inline">\(S\)</span> (by our choice in step 4(ii)). Therefore, we can remove these <span class="math inline">\(m\)</span> stones one by one.</li>
<li>In total, we have removed <span class="math inline">\((k - m) + m = k\)</span> stones, leaving only the originally chosen stone <span class="math inline">\(S\)</span>.</li>
</ol>
<p>Conclusion: By the principle of mathematical induction, we've proved that for any connected component of size <span class="math inline">\(n\)</span>, we can remove <span class="math inline">\(n - 1\)</span> stones, leaving just one stone.</p>
</details>
<br>
<p>So, our implementation boils down to two parts:</p>
<ol>
<li>Represent the stones as a graph.</li>
<li>Count the number of connected components in this graph.</li>
</ol>
<p>For the first part, we can utilize an adjacency list, where for each stone, we maintain a list of all other stones it's connected to (i.e., shares a row or column with).</p>
<p>For the second part, we can apply a graph traversal algorithm, such as Depth-First Search (DFS). We start a DFS from an unvisited stone, marking all reachable stones as visited, and count this as one connected component. We repeat this process until all stones are visited. The number of DFS executions will give us the total number of connected components in the grid, after which we can apply the formula above to determine the maximum number of stones that can be removed.</p>
<blockquote>
<p>Note: While we've discussed using depth-first search to explore each connected component, breadth-first search is an equally valid alternative, offering similar time and space complexities.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<p>Main method <code>removeStones</code>:</p>
<ul>
<li>Set <code>n</code> as the length of the input array <code>stones</code>.</li>
<li>Initialize a list of lists <code>adjacencyList</code>  with <code>n</code> empty lists.</li>
<li>Iterate over each stone <code>i</code>:
<ul>
<li>For each stone <code>i</code>, iterate over stones <code>j</code> from <code>i+1</code> to <code>n-1</code>:
<ul>
<li>If <code>stone[i]</code> shares the same row (<code>stones[i][0] == stones[j][0]</code>) or column (<code>stones[i][1] == stones[j][1]</code>) as <code>stone[j]</code>:
<ul>
<li>Add <code>j</code> to the adjacency list of <code>i</code> and <code>i</code> to the adjacency list of <code>j</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize a variable <code>numOfConnectedComponents</code> to <code>0</code>, to keep track of the number of connected components in the graph.</li>
<li>Create a boolean array <code>visited</code> of length <code>n</code> initialized to <code>false</code>, to track which stones have been visited during the DFS.</li>
<li>Iterate over each stone <code>i</code>:
<ul>
<li>If stone <code>i</code> has not been visited, perform a DFS starting from stone <code>i</code> to visit all stones in the same connected component.</li>
<li>After the DFS completes, increment <code>numOfConnectedComponents</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>n - numOfConnectedComponents</code> as our answer.</li>
</ul>
<p>Helper method <code>depthFirstSearch</code>:</p>
<ul>
<li>Define a method <code>depthFirstSearch</code> with parameters: <code>adjacencyList</code>, <code>visited</code>, and the current <code>stone</code>.</li>
<li>Mark the current <code>stone</code> as visited by setting <code>visited[stone]</code> to <code>true</code>.</li>
<li>For each <code>neighbor</code> of <code>stone</code> in the <code>adjacencyList</code>:
<ul>
<li>If the neighbor has not been visited:
<ul>
<li>Recursively call <code>depthFirstSearch</code> on <code>neighbor</code> to visit all stones in the connected component.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/2KezyDco/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>stones</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The graph is built by iterating over all pairs of stones <code>(i,j)</code> to check if they share the same row or column, resulting in <span class="math inline">\(O(n^2)\)</span> time complexity.</p>
<p>In the worst case, the depth-first search will traverse all nodes and edges. Since each stone can be connected to every other stone, the algorithm can visit all <span class="math inline">\(O(n^2)\)</span> edges across all DFS calls.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(2 \cdot O(n^2) = O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>In the worst case, any two stones could share the same row or column. So, the <code>adjacencyList</code> could store up to <span class="math inline">\(n^2\)</span> edges, taking <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>The <code>visited</code> array takes an additional linear space.</p>
<p>The recursive DFS call stack can go as deep as the number of stones in a single connected component. In the worst case, this depth could be <span class="math inline">\(n\)</span>, leading to <span class="math inline">\(O(n)\)</span> additional space for the stack.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(2 \cdot O(n) + O(n^2) = O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-disjoint-set-union">Approach 2: Disjoint Set Union</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A Disjoint Set Union (or Union-Find) is an efficient data structure for identifying connected components in a graph. It helps us group elements into disjoint sets, determine which set an element belongs to, and efficiently merge sets—exactly what we need here. If you are unfamiliar with DSU, have a look at this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Explore Card</a> for in-depth explanation.</p>
<p>We begin by treating each stone as a separate set, meaning every stone starts off in its own connected component. Then, we iterate over each pair of stones and merge (union) them if they share a common row or column.</p>
<p>In our Union-Find data structure, we also maintain a <code>count</code>, which keeps track of the total number of separate connected components in the graph. This <code>count</code> is initially set to <code>n</code>, the total number of stones. Each successful union operation indicates that two separate components have merged into one, so we decrement the <code>count</code>.</p>
<p>After processing all possible pairs of stones, the value of <code>n - count</code> gives us the maximum number of stones that can be removed.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>removeStones</code>:</p>
<ul>
<li>Set <code>n</code> as the length of the input array <code>stones</code>.</li>
<li>Initialize a <code>UnionFind</code> object <code>uf</code> with <code>n</code> as the size.</li>
<li>Iterate over each stone <code>i</code>:
<ul>
<li>For each <code>i</code>, iterate over stones <code>j</code> from <code>i+1</code> to <code>n-1</code>:
<ul>
<li>If stone <code>i</code> shares the same row (<code>stones[i][0] == stones[j][0]</code>) or column (<code>stones[i][1] == stones[j][1]</code>) as stone <code>j</code>:
<ul>
<li>Perform a <code>union</code> operation on <code>i</code> and <code>j</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>n - uf.count</code>.</li>
</ul>
<p>Helper class <code>UnionFind</code>:</p>
<ul>
<li>Define a class <code>UnionFind</code> with fields: an integer array <code>parent</code> and a variable <code>count</code>.</li>
<li>Override the default constructor:
<ul>
<li>Initialize <code>parent</code> to size <code>n</code> with all elements set to <code>-1</code>.</li>
<li>Set <code>count</code> to <code>n</code>, representing the initial number of connected components.</li>
</ul>
</li>
</ul>
<p>Helper method <code>find(node)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>If the parent of <code>node</code> is <code>-1</code>, return <code>node</code> as it is its own root.</li>
<li>Otherwise, recursively call <code>find</code> on <code>parent[node]</code>, set its result to <code>parent[node]</code> and return it.</li>
</ul>
<p>Helper method <code>union(n1, n2)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>Find the roots of <code>n1</code> and <code>n2</code> using the <code>find</code> method and store it in <code>root1</code> and <code>root2</code>, respectively.</li>
<li>If <code>root1</code> is equal to <code>root2</code>, both stones are already in the same connected component, so return.</li>
<li>If <code>root1</code> and <code>root2</code> are different, merge the two components by setting <code>parent[root1]</code> to <code>root2</code>.</li>
<li>Decrement <code>count</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/FFRQ5ohm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>stones</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha(n))\)</span></p>
<p>Initializing the <code>parent</code> array with <code>-1</code> takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The nested loops iterate through each pair of stones <code>(i, j)</code>. The number of pairs is <span class="math inline">\(\frac{n(n-1)}{2}\)</span>, which is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For each pair, if the stones share the same row or column, the <code>union</code> operation is performed. The <code>union</code> (and subsequent <code>find</code>) operation takes <span class="math inline">\(O(\alpha(n))\)</span>, where <span class="math inline">\(\alpha\)</span> is the <a href="https://www.gabrielnivasch.org/fun/inverse-ackermann">inverse Ackermann function</a>.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n^2 \cdot \alpha(n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The only additional space used by the algorithm is the <code>parent</code> array, which takes <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-optimized">Approach 3: Disjoint Set Union (Optimized)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The most time-consuming part of our previous algorithms has been iterating through every possible pair of stones, but can we do better?</p>
<p>In our earlier approach, each stone was treated as a distinct entity. In this improved method, we'll break each stone down into two entities: a row index and a column index. Although this effectively doubles the total number of nodes in the graph, it doesn't affect our solution since our goal is to find the number of connected components, not the number of nodes within each component.</p>
<p>When we treat the row and column indices as separate entities, all stones that share the same row or column index become implicitly connected, eliminating the need to manually connect these stones. However, we do need to connect the row and column indices of a stone since they were originally part of the same element.</p>
<p>This optimization condenses our algorithm into a single step: looping through the input array <code>stones</code> and unioning the row and column indices of each element. However, this approach introduces two challenges:</p>
<ol>
<li>
<p>Differentiating Between Row and Column Elements:<br />
If a row and column share the same value, how do we distinguish between them? For instance, consider two stones positioned at (x, y) and (y, z). If we union x with y, and y with z, the Disjoint Set Union (DSU) might incorrectly consider the two stones as connected, which is not necessarily true. To address this, we differentiate between row and column elements by offsetting the column value by a large constant that places it beyond the range of valid row values. We use 10,001 for this purpose, as the range of row indices is [0, 10,000].</p>
</li>
<li>
<p>Counting the Number of Connected Components:<br />
Initially, we assumed the number of connected components was <code>n</code> since each stone was treated as a separate node. However, in this approach, a stone is no longer the basic unit in the graph. While it might seem logical to consider the number of nodes as twice the number of stones, this assumption is incorrect because row and column indices are likely to be repeated among stones and thus will not form separate nodes in the graph.</p>
<p>To accurately track the number of nodes, we maintain a set called <code>uniqueNodes</code>. Before performing a union operation, we check if the nodes (row and column) have been encountered before. If not, these are new nodes in the graph and can initially be considered separate components, so we increment our count. If the union operation is successful, we subsequently decrease the count.</p>
</li>
</ol>
<p>After all operations are complete, the count will store the number of connected components in the graph.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>removeStones</code>:</p>
<ul>
<li>Set <code>n</code> as the length of the input array <code>stones</code>.</li>
<li>Create an instance of the <code>UnionFind</code> class <code>uf</code> with a size of <code>20002</code> to handle the coordinate range.</li>
<li>Loop through each stone <code>i</code> in <code>stones</code>:
<ul>
<li>Call <code>uf.union()</code> to union the x-coordinate (<code>stones[i][0]</code>) and the y-coordinate offset by <code>10001</code> (<code>stones[i][1] + 10001</code>).</li>
</ul>
</li>
<li>Return <code>n - uf.componentCount</code> as our result.</li>
</ul>
<p>Helper class <code>UnionFind</code>:</p>
<ul>
<li>Define a class <code>UnionFind</code> with fields: an integer array <code>parent</code>, a variable <code>componentCount</code>, and a set <code>uniqueNodes</code>.</li>
<li>Override the default constructor:
<ul>
<li>Initialize <code>parent</code> to size <code>n</code> with all elements set to <code>-1</code>.</li>
<li>Set <code>componentCount</code> to <code>0</code> to track the number of connected components.</li>
<li>Initialize <code>uniqueNodes</code> to track which nodes have been processed.</li>
</ul>
</li>
</ul>
<p>Helper method <code>find(node)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>If <code>node</code> is not in <code>uniqueNodes</code>:
<ul>
<li>Increment <code>componentCount</code> and add the node to <code>uniqueNodes</code>.</li>
</ul>
</li>
<li>If the parent of the <code>node</code> is <code>-1</code>:
<ul>
<li>Return <code>node</code> itself as it is its own parent.</li>
</ul>
</li>
<li>Otherwise, recursively call <code>find</code> on <code>parent[node]</code>, set its result to <code>parent[node]</code> and return it.</li>
</ul>
<p>Helper method <code>union(n1, n2)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>Find the root of <code>n1</code> and <code>n2</code> using the <code>find</code> method and store it in <code>root1</code> and <code>root2</code>, respectively.</li>
<li>If the roots are the same, they are already in the same component, so return.</li>
<li>Otherwise, merge the two components by setting <code>parent[root1]</code> to <code>root2</code>.</li>
<li>Decrement <code>componentCount</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/65v9h49d/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>stones</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since the size of the <code>parent</code> array is constant (<code>20002</code>), initializing it takes constant time.</p>
<p>The <code>union</code> operation is called <code>n</code> times, once for each stone. All <code>union</code> and <code>find</code> operations take <span class="math inline">\(O(\alpha(20002)) = O(1)\)</span> time, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + 20002)\)</span></p>
<p>The <code>parent</code> array takes a constant space of <code>20002</code>.</p>
<p>The <code>uniqueNodes</code> set can have at most <span class="math inline">\(2 \cdot n\)</span> elements, corresponding to all unique <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> coordinates. The space complexity of this set is <span class="math inline">\(O(n)\)</span>.</p>
<p>Thus, the overall space complexity of the approach is <span class="math inline">\(O(n + 20002)\)</span>.</p>
<blockquote>
<p>While constants are typically excluded from complexity analysis, we've included it here due to its substantial size.</p>
</blockquote>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-161">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/mother-vertex/1" target="_blank" rel="noopener noreferrer">Mother Vertex</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Directed Graph, find a Mother Vertex in the Graph (<strong>if present</strong>).&nbsp;<br />A Mother Vertex is a vertex through which we can reach all the other vertices of the Graph.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701116/Web/Other/blobid0_1745298210.jpg" width="293" height="238" /><br /><span style="font-size: 18px;"><strong>Output: </strong>0</span><br /><span style="font-size: 18px;"><strong>Explanation: </strong>According to the given edges, all 
nodes can be reached from nodes from 0, 1 and 2. 
But, since 0 is minimum among 0,1 and 2, so 0 
is the output.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701116/Web/Other/blobid1_1745298243.jpg" width="270" height="220" /><br /><strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">-1</span><br /><span style="font-size: 18px;"><strong>Explanation: </strong>According to the given edges, 
no vertices are there from where we can 
reach all vertices. So, output is -1.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>findMotherVertex()&nbsp;</strong>which takes V denoting the number of vertices and adjacency list as input parameter and returns the vertices from through which we can traverse all other vertices of the graph. If there is more than one possible nodes then return the node with minimum value. If not possible returns -1.<br /><br /></span><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(V + E)<br /><strong>Expected Space Complexity: </strong>O(V)<br /></span><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; V &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-162">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/neemans-shoes/1" target="_blank" rel="noopener noreferrer">Neeman&#39;s Shoes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Due to the second wave of&nbsp;Gorona virus,&nbsp;Geekland imposed another&nbsp;lockdown and&nbsp;Geek has gained some wieght. Now Geek has decided to exercise.<br />
There are <strong>N</strong> intersections in the city numbered from <strong>0</strong> to <strong>N-1</strong> and <strong>M</strong> bidirectional roads each road connecting two intersections. All the intersections are connected to each-other through some set of roads,<strong> i<sup>th</sup></strong> road connect intersections&nbsp;<strong>A[i][0] </strong>and<strong> A[i][1]</strong> and is of length<strong> A[i][2]</strong>.<br />
Every morning Geek will start at intersection <strong>src</strong> and will run/walk upto intersection <strong>dest</strong>. Geek only has one hour in the morning so he will choose to cover the shortest path from <strong>src</strong> to <strong>dest</strong>.<br />
After planning his exercising schedule, Geek wants to buy the perfect shoes to walk/run in the morning. He goes to&nbsp;Neeman&#39;s Shoe factory which is the National Shoe factory of Geekland.&nbsp;</span></p>

<p><span style="font-size:18px">Geek sees that there are two types of shoes &quot;Neeman&#39;s Wool Joggers&quot; and &quot;Neeman&#39;s Cotton Classics&quot;, &quot;Neeman&#39;s Wool Joggers&quot; are good for running and &quot;Neeman&#39;s Cotton Classics&quot; are good for walking.<br />
Geek is confused which shoes to buy, so he comes up with a strategy. If the distance he has to cover in the morning is less than or equal to X, then he will walk the distance, therefore he will buy &quot;Neeman&#39;s Cotton Classics&quot;. If the distance is greater than X, he will buy &quot;Neeman&#39;s Wool Joggers&quot;. Geek is too lazy to calculate the shortest distance between two intersections src and dest. Help him decide which shoes to buy.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:&nbsp;</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 3, M = 2, src = 0, dest = 2, X = 5
A[][] = {{0, 1, 3},
&nbsp;        {1, 2, 3}}
<strong>Output:</strong>
Neeman&#39;s Wool Joggers
<strong>Explanation</strong>: 
Shortest path from src to dest is 6 
which is greater than X, hence Geek will
buy &quot;Neeman&#39;s Wool Joggers&quot;.
</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:&nbsp;</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
N = 3, M = 2, src = 0, dest = 2, X = 6 
A[][] = {{0, 1, 3},
&nbsp;      &nbsp; {1, 2, 3}} 
<strong>Output:</strong> 
Neeman&#39;s Cotton Classics 
<strong>Explanation</strong>: 
Shortest path from src to dest is 6
which is not greater than X, hence Geek 
will â€‹buy &quot;Neeman&#39;s Cotton Classics&quot;.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>exercise( )</strong>&nbsp;which takes&nbsp;<strong>N</strong>, <strong>M</strong>, <strong>A[ ][ ]</strong>, <strong>src</strong>,<strong> dest</strong>&nbsp;and <strong>X</strong>&nbsp;as input parameters and returns string representing the shoes he selects. Either&nbsp;<strong>&quot;Neeman&#39;s Wool Joggers&quot;</strong>&nbsp;or <strong>&quot;Neeman&#39;s Cotton Classics&quot;.</strong></span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O((N + M) * Log(M))<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N + M)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
2 &le; N&nbsp;&le; 10<sup>4</sup><br />
1 &le; M&nbsp;&le; min((N*(N-1))/2, 2*10<sup>5</sup>)<br />
0 &le; A[i][0], A[i][1]&nbsp;&lt; N<br />
0 &le; src, dest &lt; N<br />
1 &le; A[i][2], X &le; 10<sup>9</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-163">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/negative-weight-cycle3504/1" target="_blank" rel="noopener noreferrer">Negative weight cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a weighted directed graph with n nodes and m edges. Nodes are labeled from 0 to n-1, the task is to check if it contains a negative weight cycle or not.<br /><strong>Note:&nbsp;</strong>edges[i] is&nbsp;defined as u, v and weight.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 3, edges = {{0,1,-1},{1,2,-2},
{2,0,-3}}
<strong>Output: </strong>1
<strong>Explanation: </strong>The graph contains negative weight
cycle as 0-&gt;1-&gt;2-&gt;0 with weight -1,-2,-3.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 3, edges = {{0,1,-1},{1,2,-2},
{2,0,3}}
<strong>Output: </strong>0
<strong>Explanation: </strong>The graph does not contain any
negative weight cycle.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anyhting. Your task is to complete the function&nbsp;<strong>isNegativeWeightCycle()&nbsp;</strong>which takes n and edges as input paramater and returns 1 if graph contains negative weight cycle otherwise returns 0.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n*m)<br /><strong>Expected Space Compelxity:&nbsp;</strong>O(n)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 100<br />0 &lt;= m &lt;= n*(n-1)</span><span style="font-size: 18px;">, where m is the total number of Edges in the directed graph.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-164">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/network-delay-time/description" target="_blank" rel="noopener noreferrer">Network Delay Time</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. You are also given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>, where <code>u<sub>i</sub></code> is the source node, <code>v<sub>i</sub></code> is the target node, and <code>w<sub>i</sub></code> is the time it takes for a signal to travel from source to target.</p>

<p>We will send a signal from a given node <code>k</code>. Return <em>the <strong>minimum</strong> time it takes for all the</em> <code>n</code> <em>nodes to receive the signal</em>. If it is impossible for all the <code>n</code> nodes to receive the signal, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" style="width: 217px; height: 239px;" />
<pre>
<strong>Input:</strong> times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 1
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 2
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= times.length &lt;= 6000</code></li>
	<li><code>times[i].length == 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= w<sub>i</sub> &lt;= 100</code></li>
	<li>All the pairs <code>(u<sub>i</sub>, v<sub>i</sub>)</code> are <strong>unique</strong>. (i.e., no multiple edges.)</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-165">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/network-recovery-pathways/description" target="_blank" rel="noopener noreferrer">Network Recovery Pathways</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="502" data-start="75">You are given a directed acyclic graph of <code>n</code> nodes numbered from 0 to <code>n &minus; 1</code>. This is represented by a 2D array <code data-end="201" data-start="194">edges</code> of length<font face="monospace"> <code>m</code></font>, where <code data-end="255" data-start="227">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code> indicates a one‑way communication from node <code data-end="304" data-start="300">u<sub>i</sub></code> to node <code data-end="317" data-start="313">v<sub>i</sub></code> with a recovery cost of <code data-end="349" data-start="342">cost<sub>i</sub></code>.</p>

<p data-end="502" data-start="75">Some nodes may be offline. You are given a boolean array <code data-end="416" data-start="408">online</code> where <code data-end="441" data-start="423">online[i] = true</code> means node <code data-end="456" data-start="453">i</code> is online. Nodes 0 and <code>n &minus; 1</code> are always online.</p>

<p data-end="547" data-start="504">A path from 0 to <code>n &minus; 1</code> is <strong data-end="541" data-start="532">valid</strong> if:</p>

<ul>
	<li>All intermediate nodes on the path are online.</li>
	<li data-end="676" data-start="605">The total recovery cost of all edges on the path does not exceed <code>k</code>.</li>
</ul>

<p data-end="771" data-start="653">For each valid path, define its <strong data-end="694" data-start="685">score</strong> as the minimum edge‑cost along that path.</p>

<p data-end="913" data-start="847">Return the <strong>maximum</strong> path score (i.e., the largest <strong>minimum</strong>-edge cost) among all valid paths. If no valid path exists, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,5],[1,3,10],[0,2,3],[2,3,4]], online = [true,true,true,true], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-10.png" style="width: 239px; height: 267px;" /></p>

<ul data-end="551" data-start="146">
	<li data-end="462" data-start="146">
	<p data-end="206" data-start="148">The graph has two possible routes from node 0 to node 3:</p>

	<ol data-end="462" data-start="209">
		<li data-end="315" data-start="209">
		<p data-end="228" data-start="212">Path <code>0 &rarr; 1 &rarr; 3</code></p>

		<ul data-end="315" data-start="234">
			<li data-end="315" data-start="234">
			<p data-end="315" data-start="236">Total cost = <code>5 + 10 = 15</code>, which exceeds k (<code>15 &gt; 10</code>), so this path is invalid.</p>
			</li>
		</ul>
		</li>
		<li data-end="462" data-start="318">
		<p data-end="337" data-start="321">Path <code>0 &rarr; 2 &rarr; 3</code></p>

		<ul data-end="462" data-start="343">
			<li data-end="397" data-start="343">
			<p data-end="397" data-start="345">Total cost = <code>3 + 4 = 7 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="462" data-start="403">
			<p data-end="462" data-start="405">The minimum edge‐cost along this path is <code>min(3, 4) = 3</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="551" data-start="463">
	<p data-end="551" data-start="465">There are no other valid paths. Hence, the maximum among all valid path‐scores is 3.</p>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,7],[1,4,5],[0,2,6],[2,3,6],[3,4,2],[2,4,6]], online = [true,true,true,false,true], k = 12</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-11.png" style="width: 343px; height: 194px;" /></p>

<ul>
	<li data-end="790" data-start="726">
	<p data-end="790" data-start="728">Node 3 is offline, so any path passing through 3 is invalid.</p>
	</li>
	<li data-end="1231" data-start="791">
	<p data-end="837" data-start="793">Consider the remaining routes from 0 to 4:</p>

	<ol data-end="1231" data-start="840">
		<li data-end="985" data-start="840">
		<p data-end="859" data-start="843">Path <code>0 &rarr; 1 &rarr; 4</code></p>

		<ul data-end="985" data-start="865">
			<li data-end="920" data-start="865">
			<p data-end="920" data-start="867">Total cost = <code>7 + 5 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="985" data-start="926">
			<p data-end="985" data-start="928">The minimum edge‐cost along this path is <code>min(7, 5) = 5</code>.</p>
			</li>
		</ul>
		</li>
		<li data-end="1083" data-start="988">
		<p data-end="1011" data-start="991">Path <code>0 &rarr; 2 &rarr; 3 &rarr; 4</code></p>

		<ul data-end="1083" data-start="1017">
			<li data-end="1083" data-start="1017">
			<p data-end="1083" data-start="1019">Node 3 is offline, so this path is invalid regardless of cost.</p>
			</li>
		</ul>
		</li>
		<li data-end="1231" data-start="1086">
		<p data-end="1105" data-start="1089">Path <code>0 &rarr; 2 &rarr; 4</code></p>

		<ul data-end="1231" data-start="1111">
			<li data-end="1166" data-start="1111">
			<p data-end="1166" data-start="1113">Total cost = <code>6 + 6 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="1231" data-start="1172">
			<p data-end="1231" data-start="1174">The minimum edge‐cost along this path is <code>min(6, 6) = 6</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="1314" data-is-last-node="" data-start="1232">
	<p data-end="1314" data-is-last-node="" data-start="1234">Among the two valid paths, their scores are 5 and 6. Therefore, the answer is 6.</p>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="42" data-start="20"><code data-end="40" data-start="20">n == online.length</code></li>
	<li data-end="63" data-start="45"><code data-end="61" data-start="45">2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="102" data-start="66"><code data-end="100" data-start="66">0 &lt;= m == edges.length &lt;= </code><code>min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>
	<li data-end="102" data-start="66"><code data-end="127" data-start="105">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code></li>
	<li data-end="151" data-start="132"><code data-end="149" data-start="132">0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li data-end="166" data-start="154"><code data-end="164" data-start="154">u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="191" data-start="169"><code data-end="189" data-start="169">0 &lt;= cost<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li data-end="213" data-start="194"><code data-end="211" data-start="194">0 &lt;= k &lt;= 5 * 10<sup>13</sup></code></li>
	<li data-end="309" data-start="216"><code data-end="227" data-start="216">online[i]</code> is either <code data-end="244" data-is-only-node="" data-start="238">true</code> or <code data-end="255" data-start="248">false</code>, and both <code data-end="277" data-start="266">online[0]</code> and <code data-end="295" data-start="282">online[n &minus; 1]</code> are <code data-end="306" data-start="300">true</code>.</li>
	<li data-end="362" data-is-last-node="" data-start="312">The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-166">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/nodes-at-even-distance0532/1" target="_blank" rel="noopener noreferrer">Nodes at even distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a connected acyclic graph with n&nbsp;nodes and n-1 edges, count the pair&nbsp;of nodes that are at even distance(number of edges) from each other.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 3
graph = {{}, {2}, {1, 3}, {2}}
<strong>Output:</strong> 1
<strong>Explaination:</strong> Here there are three pairs {1,2},{1,3}
and {2,3} and only {1,3} has even distance between them.
</span><span style="font-size:18px">i.e</span> <span style="font-size:18px">          1
             /
            2
           /
          3</span></pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 5
graph = {{}, {2,4}, {1,3}, {2}, {1,5}, {4}}
<strong>Output:</strong> 4
<strong>Explaination:</strong> There are four pairs {1,3},{1,5},{2,4}
and {3,5} which has even distance.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>countOfNodes()</strong>&nbsp;which takes the array <strong>graph[]</strong>&nbsp;(given as <a href="https://en.wikipedia.org/wiki/Adjacency_list#:~:text=In%20graph%20theory%20and%20computer,particular%20vertex%20in%20the%20graph.">Adjacency list</a>)&nbsp;</span><span style="font-size:18px">and its size <strong>n&nbsp;</strong>as input parameters&nbsp;and returns the count&nbsp;of&nbsp;pair of nodes that are at even distance from each other</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(V+E)<br />
<strong>Expected Auxiliary Space:</strong> O(V)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n&nbsp;&le; 10<sup>4</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-167">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/node-with-highest-edge-score/description" target="_blank" rel="noopener noreferrer">Node With Highest Edge Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a directed graph with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, where each node has <strong>exactly one</strong> outgoing edge.</p>

<p>The graph is represented by a given <strong>0-indexed</strong> integer array <code>edges</code> of length <code>n</code>, where <code>edges[i]</code> indicates that there is a <strong>directed</strong> edge from node <code>i</code> to node <code>edges[i]</code>.</p>

<p>The <strong>edge score</strong> of a node <code>i</code> is defined as the sum of the <strong>labels</strong> of all the nodes that have an edge pointing to <code>i</code>.</p>

<p>Return <em>the node with the highest <strong>edge score</strong></em>. If multiple nodes have the same <strong>edge score</strong>, return the node with the <strong>smallest</strong> index.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png" style="width: 450px; height: 260px;" />
<pre>
<strong>Input:</strong> edges = [1,0,0,0,0,7,7,5]
<strong>Output:</strong> 7
<strong>Explanation:</strong>
- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.
- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.
- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.
- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.
Node 7 has the highest edge score so return 7.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png" style="width: 150px; height: 155px;" />
<pre>
<strong>Input:</strong> edges = [2,0,0,2]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.
- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.
Nodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges[i] &lt; n</code></li>
	<li><code>edges[i] != i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-168">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-distinct-islands/1" target="_blank" rel="noopener noreferrer">Number of Distinct Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a boolean 2D matrix <strong>grid&nbsp;</strong>of size <strong>n</strong> * <strong>m</strong>. You have to find the number of distinct islands where a group of connected 1s (horizontally or vertically) forms an island. Two islands are considered to be distinct if and only if one island is not equal to another (not rotated or reflected).</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = [[1, 1, 0, 0, 0],
            [1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1],
            [0, 0, 0, 1, 1]]</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">grid[][] = [[<span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>, 0, 0, 0], 
&nbsp;           [<span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>, 0, 0, 0], 
&nbsp;           [0, 0, 0, <span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>], 
&nbsp;           [0, 0, 0, <span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>]]
Same colored islands are equal. We have 2 equal islands, so we have only 1 distinct island.</span>

</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = [[1, 1, 0, 1, 1],
&nbsp;           [1, 0, 0, 0, 0],
&nbsp;           [0, 0, 0, 0, 1],
&nbsp;           [1, 1, 0, 1, 1]]</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:
</strong>grid[][] = [[<span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>, 0, <span style="color: #00ff00;">1</span>, <span style="color: #00ff00;">1</span>], 
&nbsp;           [<span style="color: #ff0000;">1</span>, 0, 0, 0, 0], 
&nbsp;           [0, 0, 0, 0, <span style="color: #0000cd;">1</span>], 
&nbsp;           [<span style="color: #00ff00;">1</span>, <span style="color: #00ff00;">1</span>, 0, <span style="color: #0000ff;">1</span>, <span style="color: #0000ff;">1</span>]]</span>
<span style="font-size: 18px;">Same colored islands are equal.
We have 4 islands, but 2 of them
are equal, So we have 3 distinct islands.</span>

</pre>
<p><span style="font-size: 18px;"><strong>Your Task: </strong></span><span style="font-size: 18px;">You don't need to read or print anything. Your task is to complete the function <strong>countDistinctIslands()&nbsp;</strong>which takes the <strong>grid</strong> as an input parameter and returns the total number of <strong>distinct</strong> islands.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 500<br />grid[i][j] == 0 or grid[i][j] == 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-169">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-enclaves/1" target="_blank" rel="noopener noreferrer">Number Of Enclaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an <strong>n&nbsp;x m</strong>&nbsp;binary matrix <strong>grid</strong>, where <strong>0</strong> represents a sea cell and <strong>1</strong> represents a land cell.</span></p>
<p><span style="font-size: 18px;">A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.</span></p>
<p><span style="font-size: 18px;">Find the number of land cells in <strong>grid</strong> for which we cannot walk off the boundary of the grid in any number of moves.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = {{0, 0, 0, 0},
            {1, 0, 1, 0},
            {0, 1, 1, 0},
            {0, 0, 0, 0}}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">0 0 0 0
1 0 <strong>1</strong> 0
0 <strong>1</strong> <strong>1</strong> 0
0 0 0 0</span>
<span style="font-size: 18px;">The highlighted cells represents the land cells.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = {{0, 0, 0, 1},
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 1, 1, 0}}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">4</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">0 0 0 1
0 <strong>1</strong> <strong>1</strong> 0
0 <strong>1</strong> <strong>1</strong> 0
0 0 0 1
0 1 1 0</span>
<span style="font-size: 18px;">The highlighted cells represents the land cells.</span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">You don't need to print or input anything. Complete the function <strong>numberOfEnclaves()&nbsp;</strong>which takes a 2D integer matrix <strong>grid&nbsp;</strong>as the input parameter and returns an integer, denoting the number of land cells.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n * m)</span></p>
<p><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(n * m)</span></p>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= n, m &lt;= 500</span></li>
<li><span style="font-size: 18px;">grid[i][j] == 0 or 1</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-170">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-good-components--170647/1" target="_blank" rel="noopener noreferrer">Number of Good Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected graph with <strong>v </strong>vertices(numbered from <strong>1</strong> to <strong>v</strong>) and <strong>e </strong>edges. Find the number of good components in the graph.<br />A component of the graph is good if and only if the component is fully connected.<br /><strong>Note:&nbsp;</strong>A fully connected component is a subgraph of a given graph such that there's an edge between every pair of vertices in the component, the given graph can be a <strong>disconnected graph.&nbsp;</strong></span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> e=3, v=3, edges[][] <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">= [[</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1, 2], [1, 3], [3, 2]]</span><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/713974/Web/Other/blobid0_1745300373.jpg" width="277" height="277" /><br /><strong>Output: </strong>1</span><strong><span style="font-size: 18px;">
Explanation: <br /></span></strong><span style="font-size: 18px;">We can see that there is only one component in the graph and in this component there is a edge between any two vertces</span><strong><span style="font-size: 18px;">.</span></strong></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>e=5, v=7, edges[][] <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">= [[</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1, 2] ,[7, 2], [3, 5], [3, 4], [4, 5]]</span>
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/713974/Web/Other/blobid1_1745300608.jpg" width="327" height="327" /><br /><strong>Output: </strong>2
</span><strong><span style="font-size: 18px;">Explanation: <br /></span></strong><span style="font-size: 18px;">We can see that there are 3 components in the graph. For 1-2-7 there is no edge between 1 to 7, so it is not a fully connected component. Rest 2 are individually fully connected component.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>findNumberOfGoodComponent()</strong>, which<strong> </strong>takes an integer <strong>e</strong> and <strong>v </strong>and <strong>edges[][] </strong>as input parameters and returns an integer denoting the number of good components. </span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(v+e)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(depth of the graph)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1 &lt;= edges[i][0], edges[i][1] &lt;= v<br />1 &le; v, e &le; 10<sup>4</sup><br />All edges are unique</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-171">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-good-paths/description" target="_blank" rel="noopener noreferrer">Number of Good Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a tree (i.e. a connected, undirected graph with no cycles) consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> edges.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>vals</code> of length <code>n</code> where <code>vals[i]</code> denotes the value of the <code>i<sup>th</sup></code> node. You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>A <strong>good path</strong> is a simple path that satisfies the following conditions:</p>

<ol>
	<li>The starting node and the ending node have the <strong>same</strong> value.</li>
	<li>All nodes between the starting node and the ending node have values <strong>less than or equal to</strong> the starting node (i.e. the starting node&#39;s value should be the maximum value along the path).</li>
</ol>

<p>Return <em>the number of distinct good paths</em>.</p>

<p>Note that a path and its reverse are counted as the <strong>same</strong> path. For example, <code>0 -&gt; 1</code> is considered to be the same as <code>1 -&gt; 0</code>. A single node is also considered as a valid path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png" style="width: 400px; height: 333px;" />
<pre>
<strong>Input:</strong> vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There is 1 additional good path: 1 -&gt; 0 -&gt; 2 -&gt; 4.
(The reverse path 4 -&gt; 2 -&gt; 0 -&gt; 1 is treated as the same as 1 -&gt; 0 -&gt; 2 -&gt; 4.)
Note that 0 -&gt; 2 -&gt; 3 is not a good path because vals[2] &gt; vals[0].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png" style="width: 273px; height: 350px;" />
<pre>
<strong>Input:</strong> vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There are 2 additional good paths: 0 -&gt; 1 and 2 -&gt; 3.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png" style="width: 100px; height: 88px;" />
<pre>
<strong>Input:</strong> vals = [1], edges = []
<strong>Output:</strong> 1
<strong>Explanation:</strong> The tree consists of only one node, so there is one good path.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == vals.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= vals[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-172">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-increasing-paths-in-a-grid/description" target="_blank" rel="noopener noreferrer">Number of Increasing Paths in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, where you can move from a cell to any adjacent cell in all <code>4</code> directions.</p>

<p>Return <em>the number of <strong>strictly</strong> <strong>increasing</strong> paths in the grid such that you can start from <strong>any</strong> cell and end at <strong>any</strong> cell. </em>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Two paths are considered different if they do not have exactly the same sequence of visited cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png" style="width: 181px; height: 121px;" />
<pre>
<strong>Input:</strong> grid = [[1,1],[3,4]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -&gt; 3], [1 -&gt; 4], [3 -&gt; 4].
- Paths with length 3: [1 -&gt; 3 -&gt; 4].
The total number of paths is 4 + 3 + 1 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1],[2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -&gt; 2].
The total number of paths is 2 + 1 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-173">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-operations-to-make-network-connected/description" target="_blank" rel="noopener noreferrer">Number of Operations to Make Network Connected</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> computers numbered from <code>0</code> to <code>n - 1</code> connected by ethernet cables <code>connections</code> forming a network where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a connection between computers <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Any computer can reach any other computer directly or indirectly through the network.</p>

<p>You are given an initial computer network <code>connections</code>. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.</p>

<p>Return <em>the minimum number of times you need to do this in order to make all the computers connected</em>. If it is not possible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/sample_1_1677.png" style="width: 500px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 4, connections = [[0,1],[0,2],[1,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Remove cable between computer 1 and 2 and place between computers 1 and 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/sample_2_1677.png" style="width: 500px; height: 129px;" />
<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are not enough cables.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= connections.length &lt;= min(n * (n - 1) / 2, 10<sup>5</sup>)</code></li>
	<li><code>connections[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated connections.</li>
	<li>No two computers are connected by more than one cable.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-174">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-pairs-1645358985/1" target="_blank" rel="noopener noreferrer">Number of pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">The director of your college&nbsp;is&nbsp;planning to send 2 people to the ICPC&nbsp;regionals. He&nbsp;wants them to be from different branches. You will be given a list of pairs of student ids. Each pair is made of students from the same branch. Determine how many pairs of students from different branches they can choose from.</span></p>
<pre><span style="font-size: 18px;"><strong>Example 1:
Input:</strong>
N=5
P=3
pairs[]={{0,1},
         {2,3},
         {0,4}}
<strong>Output:</strong>
6
<strong>Explanation:</strong>
Their are total five studets 0,1,2,3,4.
Students [0,1,4] are from same bracnh while 
[2,3] are from a different one.So we can choose
different pairs like: [0,2],[0,3],[1,2],[1,3],
[4,2],[4,3]</span></pre>
<p>&nbsp;</p>
<pre><span style="font-size: 18px;"><strong>Example 2:
Input:</strong>
N=4 
P=1
pairs[]={{0,2}}
<strong>Output:</strong>
5
<strong>Explanation:</strong>
[0,1],[0,3],[2,1],[2,3] and [1,3] are all possible 
pairs because [0,2],[1] and [3] all belongs to 
different branches.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>numberOfPairs()</strong>&nbsp;which takes the 2d array pairs[], its size P<strong>&nbsp;</strong>and an integer N representing total number of students<strong>&nbsp;</strong>as input parameters&nbsp;and returns the total number of pairs(as explianed in the question).</span>.</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N)<br /><strong>Expected Auxiliary Space:</strong> O(N)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br />1&lt;=N&lt;=10<sup>5</sup><br />1&lt;=P&lt;=10<sup>4</sup><br />0&lt;=P[i][0],P[i][1]</span></p>
<p>&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-175">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-possible-sets-of-closing-branches/description" target="_blank" rel="noopener noreferrer">Number of Possible Sets of Closing Branches</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">enumeration</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a company with <code>n</code> branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads.</p>

<p>The company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches (<strong>possibly none</strong>). However, they want to ensure that the remaining branches have a distance of at most <code>maxDistance</code> from each other.</p>

<p>The <strong>distance</strong> between two branches is the <strong>minimum</strong> total traveled length needed to reach one branch from another.</p>

<p>You are given integers <code>n</code>, <code>maxDistance</code>, and a <strong>0-indexed</strong> 2D array <code>roads</code>, where <code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> represents the <strong>undirected</strong> road between branches <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with length <code>w<sub>i</sub></code>.</p>

<p>Return <em>the number of possible sets of closing branches, so that any branch has a distance of at most </em><code>maxDistance</code><em> from any other</em>.</p>

<p><strong>Note</strong> that, after closing a branch, the company will no longer have access to any roads connected to it.</p>

<p><strong>Note</strong> that, multiple roads are allowed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/11/08/example11.png" style="width: 221px; height: 191px;" />
<pre>
<strong>Input:</strong> n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The possible sets of closing branches are:
- The set [2], after closing, active branches are [0,1] and they are reachable to each other within distance 2.
- The set [0,1], after closing, the active branch is [2].
- The set [1,2], after closing, the active branch is [0].
- The set [0,2], after closing, the active branch is [1].
- The set [0,1,2], after closing, there are no active branches.
It can be proven, that there are only 5 possible sets of closing branches.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/11/08/example22.png" style="width: 221px; height: 241px;" />
<pre>
<strong>Input:</strong> n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The possible sets of closing branches are:
- The set [], after closing, active branches are [0,1,2] and they are reachable to each other within distance 4.
- The set [0], after closing, active branches are [1,2] and they are reachable to each other within distance 2.
- The set [1], after closing, active branches are [0,2] and they are reachable to each other within distance 2.
- The set [0,1], after closing, the active branch is [2].
- The set [1,2], after closing, the active branch is [0].
- The set [0,2], after closing, the active branch is [1].
- The set [0,1,2], after closing, there are no active branches.
It can be proven, that there are only 7 possible sets of closing branches.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 1, maxDistance = 10, roads = []
<strong>Output:</strong> 2
<strong>Explanation:</strong> The possible sets of closing branches are:
- The set [], after closing, the active branch is [0].
- The set [0], after closing, there are no active branches.
It can be proven, that there are only 2 possible sets of closing branches.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>1 &lt;= maxDistance &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= roads.length &lt;= 1000</code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 1000</code></li>
	<li>All branches are reachable from each other by traveling some roads.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-176">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-provinces/1" target="_blank" rel="noopener noreferrer">Number of Provinces</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an <strong>undirected</strong></span><span style="font-size: 18px;">&nbsp;graph with <strong>V</strong> vertices. We say two vertices u and v belong to a single province if there is a path from u to v or v to u. Your task is to find the number of provinces.</span><br /><br /><span style="font-size: 18px;"><strong>Note: </strong></span> <span style="font-size: 18px;">A province is a group of <strong>directly </strong>or <strong>indirectly connected</strong> cities and no other cities outside of the group. </span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span><span style="font-size: 18px;"><strong>[[1, 0, 1],</strong></span><span style="font-size: 18px;"><strong>[0, 1, 0],</strong></span><span style="font-size: 18px;"><strong>[1, 0, 1]]
</strong></span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706298/Web/Other/blobid0_1744377052.jpg" width="225" height="183" /> <br /><strong>Output:
</strong>2
<strong>Explanation:</strong>
The graph clearly has 2 Provinces [1,3] and [2]. As city 1 and city 3 has a path between them they belong to a single province. City 2 has no path to city 1 or city 3 hence it belongs to another province.</span>
</pre>
<div><span style="font-size: 18px;"><strong>Example 2:</strong></span></div>
<pre><span style="font-size: 18px;"><strong>Input:[[1, 1],[1, 1]]</strong></span><br /><br /><span style="font-size: 18px;"><strong>&nbsp;</strong></span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706298/Web/Other/blobid1_1744378525.jpg" width="228" height="185" /> </span><br /><br /><span style="font-size: 18px;"><strong>Output :</strong>
1</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>numProvinces()</strong> which takes an integer V and an adjacency matrix adj(as a 2d vector) as input and returns the number of provinces. adj[i][j] = 1, if nodes i and j are connected and adj[i][j] = 0, if not connected.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(V<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(V)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; V &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-177">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-provinces/description" target="_blank" rel="noopener noreferrer">Number of Provinces</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p>

<p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p>

<p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>i<sup>th</sup></code> city and the <code>j<sup>th</sup></code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p>

<p>Return <em>the total number of <strong>provinces</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" style="width: 222px; height: 142px;" />
<pre>
<strong>Input:</strong> isConnected = [[1,1,0],[1,1,0],[0,0,1]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" style="width: 222px; height: 142px;" />
<pre>
<strong>Input:</strong> isConnected = [[1,0,0],[0,1,0],[0,0,1]]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>n == isConnected.length</code></li>
	<li><code>n == isConnected[i].length</code></li>
	<li><code>isConnected[i][j]</code> is <code>1</code> or <code>0</code>.</li>
	<li><code>isConnected[i][i] == 1</code></li>
	<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given <code>n</code> cities, some of which are connected to other cities given by an <code>n x n</code> matrix <code>isConnected</code>. The connectivity is transitive, which means that if city <code>a</code> is directly connected with city <code>b</code> and city <code>b</code> is directly connected with city <code>c</code>, then city <code>a</code> is indirectly connected with city <code>c</code>.</p>
<p>A province is defined as a group of directly or indirectly connected cities with no other cities outside of the group.</p>
<p>Our task is to return the total number of provinces.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that two cities <code>x</code> and <code>y</code> belong to the same province if there is a <strong>path</strong> from city <code>x</code> to city <code>y</code> using the cities that are directly connected.</p>
<p>This leads us to consider the problem in terms of graphs.</p>
<p>Each city can be thought of as a node in a graph. The roads that directly connect the cities are the edges. If there is a path in this graph connecting cities <code>x</code> and <code>y</code>, then <code>x</code> and <code>y</code> are in the same province. Because the graph is undirected, <code>x</code> and <code>y</code> belong to the same province if and only if they are part of the same graph component.</p>
<p><strong>The number of required provinces is the number of connected components formed in such a graph.</strong></p>
<p>To check the number of connected components in a graph, we can use a graph traversal algorithm like depth first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p><img src="../Figures/547/547-dfs.png" alt="img" /></p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
<p>To figure out how many connected components there are in the graph, we first mark all nodes as unvisited.</p>
<p>We iterate through all the nodes from <code>0</code> to <code>n - 1</code>, checking whether each <code>node</code> has been visited or not. As the graph is undirected, a DFS traversal from <code>node</code> would visit all of the nodes in the component to which <code>node</code> belongs. Whenever we see an unvisited node while looping through all the nodes, it means we have found a new component. We run the DFS traversal from the unvisited node to traverse over all the nodes in the new component, marking all these nodes as visited to avoid counting a component more than once.</p>
<p>The number of connected components in the graph is equal to the number of unvisited nodes we encounter (the number of times we start a DFS traversal) in this process.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph. Initialize it to <code>0</code>.</li>
<li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a DFS traversal:
<ul>
<li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>node</code>, <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.</li>
<li>We mark <code>node</code> as visited.</li>
<li>We iterate over all the values in <code>isConnected[node]</code> to get the neighbors of <code>node</code>. If <code>isConnected[node][i] == 1</code>, one neighbor of <code>node</code> is <code>i</code> (as we have a direct edge between <code>node</code> and <code>i</code>). For each neighbor <code>i</code> that has not yet been visited, we recursively call <code>dfs</code> with <code>i</code> as the node.</li>
</ul>
</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z8EQGch8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>The <code>dfs</code> function visits each node once, which takes <span class="math inline">\(O(n)\)</span> time because there are <span class="math inline">\(n\)</span> nodes in total. From each <code>node</code>, we iterate over all possible edges using <code>isConnected[node]</code> which takes <span class="math inline">\(O(n)\)</span> time for each visited node. As a result, it takes a total of <span class="math inline">\(O(n^2)\)</span> time to visit all the nodes and iterate over its edges.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we just have to find the number of connected components in the graph, another method is to use a breadth-first search (BFS).</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>Here is an example with the steps:</p>
<p><img src="../Figures/547/547-bfs.png" alt="img" /></p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">LeetCode Explore Card</a>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph. Initialize it to <code>0</code>.</li>
<li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a BFS traversal:
<ul>
<li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>node</code>, <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.</li>
<li>We create an integer queue <code>q</code> and push <code>node</code> into it. We also mark <code>node</code> as visited.</li>
<li>We now loop until the queue is empty. The queue's first element, <code>node</code>, is popped out. We iterate over all the neighbors of <code>node</code> where the neighboring nodes are found using <code>isConnected[node]</code>. If any <code>neighbor</code> has not yet been visited, we mark it as visited and push it into the queue.</li>
</ul>
</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/i3nKSSz5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can only be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. As discussed above, we iterate over all possible edges using <code>isConnected[node]</code> which takes <span class="math inline">\(O(n)\)</span> time for each visited node, resulting in <span class="math inline">\(O(n^2)\)</span> operations in total in the worst-case scenario while visiting all nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The BFS queue takes <span class="math inline">\(O(n)\)</span> because each node is added, and in the worst-case scenario you could have a linear amount of nodes in the queue at once.</li>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space as well.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union-find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving questions based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a union–find data structure or merge–find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. It implements two useful operations:</p>
<ol>
<li><code>Find</code>: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.</li>
<li><code>Union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">LeetCode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Our task, as with the previous approaches, is to count the number of connected components formed in the graph with cities acting as nodes and an edge between directly connected cities.</p>
<p>We initialize all nodes as separate components in the union-find data structure. We create a variable called <code>numberOfComponents</code> to count the number of connected components in the graph and initialize it to the number to the nodes.</p>
<p>We iterate over all the edges, decrementing <code>numberOfComponents</code> by <code>1</code> for each edge whenever two different components are merged into a single one using that edge.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create an instance of <code>UnionFind</code> of size <code>n</code>.</li>
<li>Create an integer variable <code>numberOfComponents</code> to count the number of connected components in the graph. We initialize it to <code>n</code> as each node initially behaves as a separate component.</li>
<li>We iterate over <code>isConnected</code> using two loops, outer loop running from <code>i = 0</code> to <code>n - 1</code> and an inner loop running from <code>j = i + 1</code> to <code>n - 1</code>. For each pair of directly connected cities <code>i</code> and <code>j</code>, i.e., <code>isConnected[i][j] == 1</code>, we use the <code>find</code> operation to determine which components both of them belong to. If they belong to different components, i.e., <code>find(i)!= find(j)</code>, we perform a <code>union</code> operation on both nodes, combining the two different connected components into a single connected component. We also reduce <code>numberOfComponents</code> by one as we just merged two different components. We don't do anything if <code>i</code> and <code>j</code> already belong to the same component.</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/bLutVW9r/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>We need <span class="math inline">\(O(n^2)\)</span> time to iterate over all the values in <code>isConnected</code>.</li>
<li>For <span class="math inline">\(T\)</span> operations, the amortized time complexity of the union-find algorithm (using path compression with union by rank) is <span class="math inline">\(O(alpha(T))\)</span>. Here, <span class="math inline">\(\alpha(T)\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(T\)</span> (approximately <span class="math inline">\( T < 10^{600}\)</span>). You can read more about the complexity of union-find <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity">here</a>.  Because the function grows so slowly, we consider it to be <span class="math inline">\(O(1)\)</span>.</li>
<li>Initializing <code>UnionFind</code> takes <span class="math inline">\(O(n)\)</span> time beacuse we are initializing the <code>parent</code> and <code>rank</code> arrays of size <code>n</code> each.</li>
<li>We iterate through every edge and use the <code>find</code> operation to find the component of nodes connected by each edge. It takes <span class="math inline">\(O(1)\)</span> per operation and takes <span class="math inline">\(O(e)\)</span> time for all the <span class="math inline">\(e\)</span> edges. We can have a maximum of <span class="math inline">\(O(n^2)\)</span> edges in between <span class="math inline">\(n\)</span> nodes (each node is connected to other), so it would take <span class="math inline">\(O(n^2)\)</span> time. If nodes from different components are connected by an edge, we also perform <code>union</code> of the nodes, which takes <span class="math inline">\(O(1)\)</span> time per operation. In the worst-case scenario, it may be called <span class="math inline">\(O(n)\)</span> times to connect all the components to form a connected graph with only one component.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We are using the <code>parent</code> and <code>rank</code> arrays, both of which require <span class="math inline">\(O(n)\)</span> space each.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-178">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/description" target="_blank" rel="noopener noreferrer">Number of Restricted Paths From First to Last Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected weighted connected graph. You are given a positive integer <code>n</code> which denotes that the graph has <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, and an array <code>edges</code> where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, weight<sub>i</sub>]</code> denotes that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with weight equal to <code>weight<sub>i</sub></code>.</p>

<p>A path from node <code>start</code> to node <code>end</code> is a sequence of nodes <code>[z<sub>0</sub>, z<sub>1</sub>,<sub> </sub>z<sub>2</sub>, ..., z<sub>k</sub>]</code> such that <code>z<sub>0 </sub>= start</code> and <code>z<sub>k</sub> = end</code> and there is an edge between <code>z<sub>i</sub></code> and <code>z<sub>i+1</sub></code> where <code>0 &lt;= i &lt;= k-1</code>.</p>

<p>The distance of a path is the sum of the weights on the edges of the path. Let <code>distanceToLastNode(x)</code> denote the shortest distance of a path between node <code>n</code> and node <code>x</code>. A <strong>restricted path</strong> is a path that also satisfies that <code>distanceToLastNode(z<sub>i</sub>) &gt; distanceToLastNode(z<sub>i+1</sub>)</code> where <code>0 &lt;= i &lt;= k-1</code>.</p>

<p>Return <em>the number of restricted paths from node</em> <code>1</code> <em>to node</em> <code>n</code>. Since that number may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex1.png" style="width: 351px; height: 341px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Each circle contains the node number in black and its <code>distanceToLastNode value in blue. </code>The three restricted paths are:
1) 1 --&gt; 2 --&gt; 5
2) 1 --&gt; 2 --&gt; 3 --&gt; 5
3) 1 --&gt; 3 --&gt; 5
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex22.png" style="width: 356px; height: 401px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Each circle contains the node number in black and its <code>distanceToLastNode value in blue. </code>The only restricted path is 1 --&gt; 3 --&gt; 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li><code>1 &lt;= weight<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li>There is at most one edge between any two nodes.</li>
	<li>There is at least one path between any two nodes.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-179">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-ways-to-arrive-at-destination/1" target="_blank" rel="noopener noreferrer">Number of Ways to Arrive at Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You are in a city that consists of&nbsp;<code>n</code>&nbsp;intersections numbered from&nbsp;<code>0</code>&nbsp;to&nbsp;<code>n - 1</code>&nbsp;with&nbsp;<strong>bi-directional</strong>&nbsp;roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.</span></p>

<p><span style="font-size:18px">You are given an integer&nbsp;<code>n</code>&nbsp;and a 2D integer array&nbsp;<code>roads</code>&nbsp;where&nbsp;<code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code>&nbsp;means that there is a road between intersections&nbsp;<code>u<sub>i</sub></code>&nbsp;and&nbsp;<code>v<sub>i</sub></code>&nbsp;that takes&nbsp;<code>time<sub>i</sub></code>&nbsp;minutes to travel. You want to know in how many ways you can travel from intersection&nbsp;<code>0</code>&nbsp;to intersection&nbsp;<code>n - 1</code>&nbsp;in the&nbsp;<strong>shortest amount of time</strong>.</span></p>

<p><span style="font-size:18px">Return&nbsp;<em>the&nbsp;<strong>number of ways</strong>&nbsp;you can arrive at your destination in the&nbsp;<strong>shortest amount of time</strong></em>. Since the answer may be large, return it&nbsp;<strong>modulo</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>.</span></p>

<p><span style="font-size:18px">Example 1:</span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n=7, m=10
edges= [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]</span>

<span style="font-size:18px"><strong>Output:</strong>
4
Explaination:</span>

<span style="font-size:18px">The four ways to get there in 7 minutes are:
- 0  6
- 0  4  6
- 0  1  2  5  6
- 0  1  3  5  6</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px">Example 2:</span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n=6, m=8
edges= [[0,5,8],[0,2,2],[0,1,1],[1,3,3],[1,2,3],[2,5,6],[3,4,2],[4,5,2]]</span>

<span style="font-size:18px"><strong>Output:</strong>
3
Explaination:</span>

<span style="font-size:18px">The three ways to get there in 8 minutes are:
- 0  5
- 0  2  5
- 0  1  3  4  5
</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
<code>1 &lt;= n &lt;= 200<br />
n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2<br />
roads[i].length == 3<br />
0 &lt;= u<sub>i</sub>, v<sub>i</sub>&nbsp;&lt;= n - 1<br />
1 &lt;= time<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup><br />
u<sub>i&nbsp;</sub>!= v<sub>i</sub></code><br />
There is at most one road connecting any two intersections.<br />
You can reach any intersection from any other intersection.<br />
<br />
Expected Time Complexity:&nbsp;O(M * logN + N)<br />
Expected Space Complexity: O(M+N)</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-180">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-arrive-at-destination/description" target="_blank" rel="noopener noreferrer">Number of Ways to Arrive at Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are in a city that consists of <code>n</code> intersections numbered from <code>0</code> to <code>n - 1</code> with <strong>bi-directional</strong> roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.</p>

<p>You are given an integer <code>n</code> and a 2D integer array <code>roads</code> where <code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code> means that there is a road between intersections <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> that takes <code>time<sub>i</sub></code> minutes to travel. You want to know in how many ways you can travel from intersection <code>0</code> to intersection <code>n - 1</code> in the <strong>shortest amount of time</strong>.</p>

<p>Return <em>the <strong>number of ways</strong> you can arrive at your destination in the <strong>shortest amount of time</strong></em>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/02/14/1976_corrected.png" style="width: 255px; height: 400px;" />
<pre>
<strong>Input:</strong> n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, roads = [[1,0,10]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li>There is at most one road connecting any two intersections.</li>
	<li>You can reach any intersection from any other intersection.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have <code>n</code> intersections in a city, represented as nodes in a fully connected graph with bidirectional roads as edges. Each road has a given travel time. Our goal is to determine the number of distinct ways to travel from intersection <code>0</code> to intersection <code>n - 1</code> while taking the shortest possible time. The problem guarantees that every intersection is reachable from any other intersection, ensuring that the graph is fully connected. Additionally, there is at most one road between any two intersections, so we do not have to consider duplicate edges.</p>
<p>One important detail is that the number of ways can be large, so the answer must be returned modulo <span class="math inline">\(10^9 + 7\)</span>. A common mistake is assuming that all roads have unique travel times, but the problem does not impose this restriction. Multiple roads may contribute to the shortest path calculation, and all must be considered. Since the roads are bidirectional, each one can be traversed in either direction. However, backtracking is unnecessary here, meaning we can ignore paths that visit the same road twice, as they will definitely take more time to reach the destination.</p>
<p>For instance, in the first example of the problem description, the shortest time to travel from intersection <code>0</code> to intersection <code>6</code> is <code>7</code> minutes. There are four distinct paths that achieve this travel time, each taking different routes but resulting in the same minimum duration.</p>
<p>Our approach will be based on two fundamental concepts: graph theory and Dijkstra’s shortest path algorithm. Since these topics are crucial to understanding the solution, we recommend having some prior knowledge of them. However, we will also provide a thorough explanation to ensure clarity.</p>
<ol>
<li>
<p><strong>Graph Theory</strong> – Understanding graphs, nodes, edges, and different types of graph representations (adjacency list, adjacency matrix).</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/">Graph Theory - LeetCode Explore Card</a></li>
</ul>
</li>
<li>
<p><strong>Dijkstra’s Algorithm</strong> – A fundamental shortest path algorithm that efficiently finds the minimum distance from a source node to all other nodes in a weighted graph.</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3885/">Dijkstra’s Algorithm - LeetCode Explore Card</a></li>
</ul>
</li>
</ol>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>Dijkstra’s algorithm is the best fit for this problem because it efficiently finds the shortest path from a single source node to all other nodes in a graph with edges that have non-negative weights. The core principle of Dijkstra’s algorithm is that it always expands the currently known shortest path first, ensuring that when we reach a node, we do so in the minimum time possible.</p>
<p>Other approaches, such as Breadth-First Search (BFS), Depth-First Search (DFS), or the Bellman-Ford algorithm, would not be efficient. BFS does not work for weighted graphs unless modified with a priority queue, which ultimately turns it into Dijkstra’s algorithm. DFS would be highly inefficient because it would explore all possible paths, many of which would be unnecessary since they do not guarantee the shortest travel time. The brute-force approach of checking all paths using DFS would have an exponential time complexity and would be infeasible for large inputs.</p>
<p>Dijkstra’s algorithm is a greedy algorithm that uses a min-heap (priority queue) to process nodes in increasing order of their shortest known distance. The algorithm starts from the source node, which is node <code>0</code>, and initializes its distance to <code>0</code> while setting the distance for all other nodes to infinity. The priority queue ensures that the node with the shortest known distance is always processed first.</p>
<p>For each node that is extracted from the priority queue, its neighbors are checked. If traveling through the current node provides a shorter path to a neighboring node, the shortest time to that node is updated, and the neighbor is added to the priority queue for further processing. This continues until all nodes have been processed, at which point the shortest time to each node is known.</p>
<p>The reason Dijkstra’s algorithm works correctly is that once a node is extracted from the priority queue, we are guaranteed that we have found the shortest possible path to that node. Any future attempts to update its distance will fail. This is because any other node that could have led to a shorter path already has a greater cost (otherwise, we would have extracted it first from the heap). Additionally, since all edges have a positive weight, any further paths to that node will only add a positive value to the total cost, increasing it further.</p>
<p>The standard implementation of Dijkstra’s algorithm only finds the shortest distance to each node. However, this problem also requires us to count how many different ways exist to reach the last node (<code>n - 1</code>) using the shortest possible time.</p>
<p>To achieve this, we introduce an additional array, <code>pathCount</code>, where <code>pathCount[i]</code> keeps track of the number of ways to reach node <code>i</code> in the shortest time possible. This modification allows us to not only compute the shortest travel time but also count all valid paths that follow this time constraint.</p>
<p>Initially, <code>pathCount[0] = 1</code>, since there is exactly one way to start at node <code>0</code>. When we find a new shorter path to a node, we reset its path count to be the same as the number of ways we could reach the previous node, since we have discovered a new optimal route.</p>
<p>If we encounter another way to reach a node with the same shortest time, we do not reset the path count. Instead, we add the number of ways we could reach the previous node to the current node’s path count. Since the number of ways can be large, we take the result modulo <span class="math inline">\(10^9 + 7\)</span> to prevent integer overflow.</p>
<p>This problem is notorious for its edge cases, which often cause issues when submitted. A common mistake is using <code>INT_MAX</code> (or similar equivalent in the language of your choice) as the initial value, assuming it is large enough to represent an unreachable node. However, for this problem, using <code>INT_MAX</code> causes incorrect results or even integer overflow in certain test cases.</p>
<p>To understand why, we need to analyze the constraints. The number of nodes (<code>n</code>) is at most <span class="math inline">\(200\)</span>, and the edge weights (<code>time[i]</code>) can be as large as <span class="math inline">\(10^9\)</span>. The worst-case scenario occurs when the shortest path to a node involves traversing <code>199</code> edges, forming a nearly linear path. In such a case, the total shortest path value can reach:</p>
<p><span class="math inline">\(199 \times 10^9 = 1.99 \times 10^{11}\)</span></p>
<p>This is far greater than <code>INT_MAX</code> (which is <span class="math inline">\(2.1 × 10^9\)</span>). If we initialize our distances with <code>INT_MAX</code>, adding even a single edge weight (<span class="math inline">\(10^9\)</span>) could exceed this limit, causing integer overflow. As a result, the algorithm may produce incorrect results when comparing distances, leading to failures in large test cases like test case 53.</p>
<p>To avoid this issue, we should initialize the <code>shortestTime</code> array with <code>LLONG_MAX</code>, which is <span class="math inline">\(9.2 × 10^18\)</span>, or use a sufficiently large constant like <code>1e12</code>. Both options ensure that our algorithm can correctly compute distances without encountering overflow. This small but crucial adjustment is necessary to handle the problem’s constraints correctly.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1976/dijikstra.json:690,608!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define <code>MOD = 1e9 + 7</code> for modular arithmetic.</p>
</li>
<li>
<p>Build an adjacency list <code>graph</code> where <code>graph[i]</code> stores <code>{neighbor, travelTime}</code> pairs.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) for Dijkstra's algorithm.</p>
</li>
<li>
<p>Create <code>shortestTime</code> array to store the shortest time to each node, initialized to <code>LLONG_MAX</code> (or its equivalent in other preferred languages).</p>
</li>
<li>
<p>Create <code>pathCount</code> array to store the number of shortest paths to each node, initialized to <code>0</code>.</p>
</li>
<li>
<p>Set <code>shortestTime[0] = 0</code> and <code>pathCount[0] = 1</code> (starting node has distance <code>0</code> and one valid path).</p>
</li>
<li>
<p>Push <code>{0, 0}</code> into <code>minHeap</code> to start processing.</p>
</li>
<li>
<p>While <code>minHeap</code> is not empty:</p>
<ul>
<li>Extract the node <code>currNode</code> with the current shortest known time <code>currTime</code>.</li>
<li>If <code>currTime &gt; shortestTime[currNode]</code>, skip outdated distances.</li>
<li>Iterate over neighbors of <code>currNode</code>:
<ul>
<li>If a new shortest path is found:
<ul>
<li>Update <code>shortestTime[neighborNode]</code>.</li>
<li>Reset <code>pathCount[neighborNode]</code> to match <code>pathCount[currNode]</code>.</li>
<li>Push <code>{shortestTime[neighborNode], neighborNode}</code> into <code>minHeap</code>.</li>
</ul>
</li>
<li>If an equally short path is found:
<ul>
<li>Add <code>pathCount[currNode]</code> to <code>pathCount[neighborNode]</code>, modulo <code>MOD</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>pathCount[n - 1]</code>, the number of shortest paths to the last node.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Time-saving coding tip:</p>
<p>Whenever a problem involves calculating distances or counting paths, it's a good idea to use long long (or an equivalent large integer type) and apply the modulo operator when required. This helps prevent integer overflow and ensures accurate results, especially in graph and dynamic programming problems.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/faYwk3KQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the graph and <span class="math inline">\(E\)</span> be the number of edges in the given road connections.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N + E \log E)\)</span></p>
<p>Building the adjacency list takes <span class="math inline">\(O(E)\)</span> time, since we iterate over all the edges once.</p>
<p>The main part of the algorithm is Dijkstra’s algorithm using a min-heap. In this implementation, a node can be added to the heap multiple times (if a shorter path to it is found later). For each edge, we may perform a heap insertion, and the heap can grow up to size <span class="math inline">\(O(E)\)</span> in the worst case. Each insertion or extraction from the heap takes <span class="math inline">\(O(\log E)\)</span> time. Thus, the total time spent on heap operations is <span class="math inline">\(O(E \log E)\)</span>.</p>
<p>Combining both parts, the overall time complexity is: <span class="math inline">\(O(E) + O(E \log E) = O(N + E \log E)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span></p>
<p>The adjacency list stores <span class="math inline">\(O(2 \cdot E)\)</span> edges, but it requires <span class="math inline">\(O(N + 2E) \approx O(N + E)\)</span> space in total, as it also includes the <span class="math inline">\(N\)</span> nodes in the outer list. The priority queue stores at most <span class="math inline">\(O(N)\)</span> elements at any time. Additionally, the <code>shortestTime</code> and <code>pathCount</code> arrays require <span class="math inline">\(O(N)\)</span> space. Since the total space used is dominated by <span class="math inline">\(O(N + E)\)</span> for storing the graph, the overall space complexity is <span class="math inline">\(O(N + E)\)</span>.</p>
<p>Other auxiliary variables, such as integers and loop variables, contribute <span class="math inline">\(O(1)\)</span> space, which is negligible compared to <span class="math inline">\(O(N + E)\)</span>. Therefore, the dominant space complexity remains <span class="math inline">\(O(N + E)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-floyd-warshall-algorithm">Approach 2: Floyd-Warshall algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An alternate acceptable approach is to use the concept of Floyd-Warshall algorithm. The core idea of this algorithm is to check whether using an intermediate node <code>mid</code> can create a shorter path between <code>src</code> and <code>dest</code>. Instead of expanding outward from a single source like Dijkstra’s algorithm, Floyd-Warshall updates the shortest path between all pairs of nodes at the same time. This guarantees that once the algorithm completes, every possible shortest path has been counted. However, the Floyd-Warshall algorithm runs in <span class="math inline">\(O(n^3)\)</span> time complexity, which makes it impractical for very large graphs.</p>
<p>To implement this, we define a three-dimensional dynamic programming table <code>dp[src][dest][x]</code>. The first value, <code>dp[src][dest][0]</code>, stores the shortest time required to travel from <code>src</code> to <code>dest</code>, while <code>dp[src][dest][1]</code> keeps track of how many different ways this shortest time can be achieved. At the beginning, the shortest time between any two distinct nodes is set to a very large value, representing that they are initially unreachable. The number of ways is set to <code>0</code> because no path has been established yet. The only exception is when <code>src</code> and <code>dest</code> are the same, in which case the shortest time is <code>0</code> and the number of ways is <code>1</code>, as staying at the node is trivially possible in exactly one way.</p>
<p>Once the table is initialized, we update it with the given roads. If there is a direct connection between <code>startNode</code> and <code>endNode</code> with a given travel time, then the shortest time between these nodes is simply that travel time, and there is exactly one way to travel along this road. Since the roads are bidirectional, the same update applies in both directions.</p>
<p>Once all direct edges are accounted for, we use Floyd-Warshall to iteratively improve our shortest paths by considering each node <code>mid</code> as a possible bridge between every pair of nodes <code>(src, dest)</code>. For every such pair, we check whether traveling through <code>mid</code> results in a smaller total travel time than the best-known value stored in <code>dp[src][dest][0]</code>. If a strictly shorter path is found, we update <code>dp[src][dest][0]</code> to reflect this new shortest time and reset <code>dp[src][dest][1]</code> to be the product of <code>dp[src][mid][1]</code> and <code>dp[mid][dest][1]</code>, which accounts for all possible ways to reach <code>mid</code> from <code>src</code> and then travel from <code>mid</code> to <code>dest</code>. If the new path through <code>mid</code> results in the same shortest time that was already recorded, we do not update <code>dp[src][dest][0]</code>, but we add the newly found paths to <code>dp[src][dest][1]</code>, since they provide additional routes that achieve the minimum distance.</p>
<p>Once we have iterated through all possible intermediate nodes, <code>dp[n - 1][0][1]</code> contains the number of ways to travel between nodes <code>n - 1</code> and <code>0</code> in either direction, using the shortest possible time. This value represents our final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 3D DP table <code>dp[n][n][2]</code> where:
<ul>
<li><code>dp[src][dest][0]</code> stores the minimum time to reach <code>dest</code> from <code>src</code>.</li>
<li><code>dp[src][dest][1]</code> stores the number of ways to achieve the minimum time.</li>
</ul>
</li>
<li>Initialize the DP table:
<ul>
<li>Set the time needed to travel from a node to itself to <code>0</code> and the number of ways to <code>1</code>.</li>
<li>Set the time needed to travel between any two different nodes to a large value (<code>1e12</code>) and the number of ways to <code>0</code>.</li>
</ul>
</li>
<li>Populate the DP table with direct roads (<code>[u, v, time]</code>) from the input:
<ul>
<li>Update the time needed to travel between <code>u</code> and <code>v</code> to <code>time</code> in both directions, and set the number of ways to <code>1</code>.</li>
</ul>
</li>
<li>Apply the Floyd-Warshall algorithm to compute shortest paths:
<ul>
<li>For each intermediate node <code>mid</code>:
<ul>
<li>For each starting node <code>src</code>:
<ul>
<li>For each destination node <code>dest</code>:
<ul>
<li>If <code>src != mid</code> and <code>dest != mid</code>:
<ul>
<li>Calculate <code>newTime</code> as <code>dp[src][mid][0] + dp[mid][dest][0]</code>.</li>
<li>If <code>newTime &lt; dp[src][dest][0]</code> (current time):
<ul>
<li>Update <code>dp[src][dest][0]</code> to <code>newTime</code>.</li>
<li>Update the number of ways <code>dp[src][dest][1]</code> to the number of ways to reach <code>mid</code> from <code>src</code> (<code>dp[src][mid][1]</code>) multiplied by the number of ways to reach <code>dest</code> from <code>mid</code> (<code>dp[mid][dest][1]</code>).</li>
</ul>
</li>
<li>If <code>newTime == dp[src][dest][0]</code> (current time):
<ul>
<li>Increment the number of ways <code>dp[src][dest][1]</code> by the number of ways to reach <code>mid</code> from <code>src</code> (<code>dp[src][mid][1]</code>) multiplied by the number of ways to reach <code>dest</code> from <code>mid</code> (<code>dp[mid][dest][1]</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the number of shortest paths from node <code>n - 1</code> to node <code>0</code> stored in <code>dp[n - 1][0][1]</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/H2DorSwM/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the graph and <span class="math inline">\(E\)</span> be the number of edges in the given road connections.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3)\)</span></p>
<p>The time complexity is dominated by the Floyd-Warshall algorithm. The algorithm involves three nested loops, each iterating over all nodes (from <code>0</code> to <code>N - 1</code>). Therefore, the time complexity is <span class="math inline">\(O(N^3)\)</span>.</p>
<p>Additionally, the initialization of the <code>dp</code> table takes <span class="math inline">\(O(N^2)\)</span> time, and the initialization of the roads (edges) takes <span class="math inline">\(O(E)\)</span> time. However, these are dominated by the <span class="math inline">\(O(N^3)\)</span> complexity of the Floyd-Warshall algorithm.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The space complexity is determined by the size of the <code>dp</code> table, which is a 3D array of size <span class="math inline">\(N \times N \times 2\)</span>. This results in a space complexity of <span class="math inline">\(O(N^2)\)</span>, as the third dimension is a constant factor (<code>2</code>).</p>
<p>The input roads (edges) are stored in an array, which takes <span class="math inline">\(O(E)\)</span> space, but this is negligible compared to the <span class="math inline">\(O(N^2)\)</span> space used by the <code>dp</code> table. Therefore, the overall space complexity is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-181">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/description" target="_blank" rel="noopener noreferrer">Number Of Ways To Reconstruct A Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>pairs</code>, where <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>, and:</p>

<ul>
	<li>There are no duplicates.</li>
	<li><code>x<sub>i</sub> &lt; y<sub>i</sub></code></li>
</ul>

<p>Let <code>ways</code> be the number of rooted trees that satisfy the following conditions:</p>

<ul>
	<li>The tree consists of nodes whose values appeared in <code>pairs</code>.</li>
	<li>A pair <code>[x<sub>i</sub>, y<sub>i</sub>]</code> exists in <code>pairs</code> <strong>if and only if</strong> <code>x<sub>i</sub></code> is an ancestor of <code>y<sub>i</sub></code> or <code>y<sub>i</sub></code> is an ancestor of <code>x<sub>i</sub></code>.</li>
	<li><strong>Note:</strong> the tree does not have to be a binary tree.</li>
</ul>

<p>Two ways are considered to be different if there is at least one node that has different parents in both ways.</p>

<p>Return:</p>

<ul>
	<li><code>0</code> if <code>ways == 0</code></li>
	<li><code>1</code> if <code>ways == 1</code></li>
	<li><code>2</code> if <code>ways &gt; 1</code></li>
</ul>

<p>A <strong>rooted tree</strong> is a tree that has a single root node, and all edges are oriented to be outgoing from the root.</p>

<p>An <strong>ancestor</strong> of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2020/12/03/trees2.png" style="width: 208px; height: 221px;" />
<pre>
<strong>Input:</strong> pairs = [[1,2],[2,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is exactly one valid rooted tree, which is shown in the above figure.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/03/tree.png" style="width: 234px; height: 241px;" />
<pre>
<strong>Input:</strong> pairs = [[1,2],[2,3],[1,3]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are multiple valid rooted trees. Three of them are shown in the above figures.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> pairs = [[1,2],[2,3],[2,4],[1,5]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no valid rooted trees.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= x<sub>i </sub>&lt; y<sub>i</sub> &lt;= 500</code></li>
	<li>The elements in <code>pairs</code> are unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-182">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-boggle-ii--141631/1" target="_blank" rel="noopener noreferrer">Open the gates</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">recursion</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Geek and his friends went on a trip to one of the hill stations in Geekland. While trekking they found a treasure map, it was in the form of <strong>r x c</strong> size board, each cell on the <strong>map</strong> denotes a latin uppercase letter. On the bottom of the map it was written that there are <strong>n gates</strong> with a specific name and if they could find out the name of the gate on the map that gate would open. Help Geek and his friends to find out the gates they could possibly open with the map they found.&nbsp;</span></p>
<p><span style="font-size: 14pt;">A name can be formed by a sequence of adjacent characters on the map. We can move to any of 8 adjacent characters. While forming a word we can move to any of the 8 adjacent cells. A cell can be used only once in one name.</span></p>
<p><span style="font-size: 14pt;">&nbsp;<strong>NOTE</strong>: All gate names returned must be different even it occurs multiple times in the input.</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: 
</strong>n = 3
gate_names = {"ZARA", "ZETH", "MYTH"}
r = 3, c = 3
map = A Z E<br />       R Y T<br />       M A H
<strong>Output:</strong>
{"ZARA", "ZETH", "MYTH"}
<strong>Explanation</strong>: <br /><span style="color: #e03e2d;"><span style="color: #000000;">Opening gate ZARA</span><br />A</span> <span style="color: #e03e2d;">Z</span> E<br /><span style="color: #e03e2d;">R</span> Y T<br />M <span style="color: #e03e2d;">A</span> H<br />Opening gate ZETH<br />A <span style="color: #3598db;">Z</span> <span style="color: #3598db;">E</span><br />R Y <span style="color: #3598db;">T</span><br />M A <span style="color: #3598db;">H</span><br />Opening gate MYTH<br />A Z E<br />R <span style="color: #2dc26b;">Y</span> <span style="color: #2dc26b;">T</span><br /><span style="color: #2dc26b;">M</span> A <span style="color: #2dc26b;">H</span>
</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
n = 5
gate_names = {"NYX","ONYX","VIRA","KARA", "NYX"}
r = 3, c = 3 
map = N O A<br />       P Y V<br />       K R X
<strong>Output:</strong>
{"NYX", "ONYX"}
<strong>Explanation</strong>: <br /><span style="color: #000000;">Opening gate NYX<br /><span style="color: #e03e2d;">N</span> O A<br />P <span style="color: #e03e2d;">Y</span> V<br />K R <span style="color: #e03e2d;">X</span><br />Opening gate ONYX<br /><span style="color: #3598db;">N</span> <span style="color: #3598db;">O</span> A<br />P <span style="color: #3598db;">Y</span> V<br />K R <span style="color: #3598db;">X<br /><strong><span style="color: #000000;">Note that NYX is counted only once.</span></strong></span></span></span></pre>
<p><span style="font-size: 14pt;"><strong>Your task:</strong><br />You don&rsquo;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>openGates()</strong> which takes the <strong>gate_names</strong> contaning <strong>n</strong> space-separated strings and <strong>r*c map</strong> as input parameters and returns a list of gate names that can be opened</span></p>
<p><span style="font-size: 14pt;"><strong>Expected Time Complexity: </strong>O(4^(N^2))<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N^2)</span></p>
<div><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n &le; 15<br />1 &le; r, c &le; 50<br />1 &le; length of each gate name &le; 60</span></div>
<div><span style="font-size: 14pt;">All words of gate_names and all characters of map are uppercase letters from <strong>'A'</strong> to <strong>'Z'</strong></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-183">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/pacific-atlantic-water-flow/1" target="_blank" rel="noopener noreferrer">Pacific Atlantic Water Flow</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a matrix <strong>mat[][]</strong> of dimensions <strong>n x m</strong>, where mat[i][j] represents the <strong>height of a cell</strong> in a rectangular grid island. The <strong>Pacific Ocean</strong> touches the island's <strong>left and top</strong> borders, and the <strong>Atlantic Ocean</strong> touches the island's <strong>right and bottom</strong> borders. Rainwater can flow from a cell to its neighbouring cells in the directions North, South, East, and West, but only if the <strong>neighbouring cell has a height less than or equal to the current cell's height</strong>.</span></p>
<p><span style="font-size: 18px;">The task is to determine <strong>all coordinates (x, y)</strong> such that water can flow from the cell (x, y) to <strong>both</strong> the Pacific Ocean and the Atlantic Ocean. Water can flow from any adjacent cell directly into an ocean.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[1, 2, 2, 3, 5],<br />                [3, 2, 3, 4, 4],<br />                [2, 4, 5, 3, 1],<br />                [6, 7, 1, 4, 5],<br />                [5, 1, 1, 2, 4]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> </span><span style="font-size: 18px;">In the given matrix, there are 7 coordinates through which the water can flow to both the Oceans</span>. They are  (0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), and (4, 0).</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[][] = [[2, 2], <br />               [2, 2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> </span><span style="font-size: 18px;">In the following example, all cells allow water to flow to both the Oceans.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; number of rows,&nbsp;</span><span style="font-size: 18px;">number of columns</span><span style="font-size: 18px;">&nbsp;&le; 10</span><sup>3<br /></sup><span style="font-size: 18px;">1 &le; arr[i][j] &le; 10<sup>3</sup>&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-184">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/parallel-courses-ii/description" target="_blank" rel="noopener noreferrer">Parallel Courses II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, which indicates that there are <code>n</code> courses labeled from <code>1</code> to <code>n</code>. You are also given an array <code>relations</code> where <code>relations[i] = [prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code>, representing a prerequisite relationship between course <code>prevCourse<sub>i</sub></code> and course <code>nextCourse<sub>i</sub></code>: course <code>prevCourse<sub>i</sub></code> has to be taken before course <code>nextCourse<sub>i</sub></code>. Also, you are given the integer <code>k</code>.</p>

<p>In one semester, you can take <strong>at most</strong> <code>k</code> courses as long as you have taken all the prerequisites in the <strong>previous</strong> semesters for the courses you are taking.</p>

<p>Return <em>the <strong>minimum</strong> number of semesters needed to take all courses</em>. The testcases will be generated such that it is possible to take every course.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_1.png" style="width: 269px; height: 147px;" />
<pre>
<strong>Input:</strong> n = 4, relations = [[2,1],[3,1],[1,4]], k = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> The figure above represents the given graph.
In the first semester, you can take courses 2 and 3.
In the second semester, you can take course 1.
In the third semester, you can take course 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_2.png" style="width: 271px; height: 211px;" />
<pre>
<strong>Input:</strong> n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> The figure above represents the given graph.
In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.
In the second semester, you can take course 4.
In the third semester, you can take course 1.
In the fourth semester, you can take course 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 15</code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li><code>0 &lt;= relations.length &lt;= n * (n-1) / 2</code></li>
	<li><code>relations[i].length == 2</code></li>
	<li><code>1 &lt;= prevCourse<sub>i</sub>, nextCourse<sub>i</sub> &lt;= n</code></li>
	<li><code>prevCourse<sub>i</sub> != nextCourse<sub>i</sub></code></li>
	<li>All the pairs <code>[prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code> are <strong>unique</strong>.</li>
	<li>The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-185">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/parallel-courses-iii/description" target="_blank" rel="noopener noreferrer">Parallel Courses III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, which indicates that there are <code>n</code> courses labeled from <code>1</code> to <code>n</code>. You are also given a 2D integer array <code>relations</code> where <code>relations[j] = [prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code> denotes that course <code>prevCourse<sub>j</sub></code> has to be completed <strong>before</strong> course <code>nextCourse<sub>j</sub></code> (prerequisite relationship). Furthermore, you are given a <strong>0-indexed</strong> integer array <code>time</code> where <code>time[i]</code> denotes how many <strong>months</strong> it takes to complete the <code>(i+1)<sup>th</sup></code> course.</p>

<p>You must find the <strong>minimum</strong> number of months needed to complete all the courses following these rules:</p>

<ul>
	<li>You may start taking a course at <strong>any time</strong> if the prerequisites are met.</li>
	<li><strong>Any number of courses</strong> can be taken at the <strong>same time</strong>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of months needed to complete all the courses</em>.</p>

<p><strong>Note:</strong> The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/10/07/ex1.png" style="width: 392px; height: 232px;" /></strong>

<pre>
<strong>Input:</strong> n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The figure above represents the given graph and the time required to complete each course. 
We start course 1 and course 2 simultaneously at month 0.
Course 1 takes 3 months and course 2 takes 2 months to complete respectively.
Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/10/07/ex2.png" style="width: 500px; height: 365px;" /></strong>

<pre>
<strong>Input:</strong> n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
<strong>Output:</strong> 12
<strong>Explanation:</strong> The figure above represents the given graph and the time required to complete each course.
You can start courses 1, 2, and 3 at month 0.
You can complete them after 1, 2, and 3 months respectively.
Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.
Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.
Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 10<sup>4</sup>)</code></li>
	<li><code>relations[j].length == 2</code></li>
	<li><code>1 &lt;= prevCourse<sub>j</sub>, nextCourse<sub>j</sub> &lt;= n</code></li>
	<li><code>prevCourse<sub>j</sub> != nextCourse<sub>j</sub></code></li>
	<li>All the pairs <code>[prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code> are <strong>unique</strong>.</li>
	<li><code>time.length == n</code></li>
	<li><code>1 &lt;= time[i] &lt;= 10<sup>4</sup></code></li>
	<li>The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-topological-sort-kahns-algorithm">Approach 1: Topological Sort, Kahn's Algorithm</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are not familiar with topological sorting, please refer to our explore cards <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/">Topological Sorting Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>We can think of each course as a node in a graph, with the prerequisites being directed edges. Each node has a value, given in <code>time</code>. The problem tells us two things:</p>
<ol>
<li>We can start taking a course as soon as the prerequisites are met</li>
<li>We can take any number of courses simultaneously</li>
</ol>
<p>Take a look at the following graph.</p>
<p><img src="../Figures/2050/1.png" alt="example" /><br />
<br></p>
<p>Before we can start the course in green, we must finish the three other prerequisite courses first. However, only the completion time of the course in blue matters. Because of the 2nd rule, we can take all of them simultaneously. The course in blue requires the longest completion time, so by the time we take 4 months to finish it, the other two courses will have already been completed. Thus, we can complete the course in green after 4 + 5 = 9 months.</p>
<p>Let's extend the graph.</p>
<p><img src="../Figures/2050/2.png" alt="example" /><br />
<br></p>
<p>The nodes in green are the same ones from the first image. We already established that it takes 9 months to complete those courses. Thus, to start the red course, the other two nodes with values 7 and 8 are irrelevant because, by the time we take 9 months to finish the green nodes, they will already have been completed. To finish the red course, we need 9 + 5 = 14 months.</p>
<p><img src="../Figures/2050/3.png" alt="example" /><br />
<br></p>
<p>Without loss of generality, we can consider all the green nodes as a single node with value 9. If we were to extend the graph further, then we could consider the entire previous graph as a single node with value 14.</p>
<p><img src="../Figures/2050/4.png" alt="example" /><br />
<br></p>
<p>The takeaway from these examples is that we don't need to worry about the order in which the courses are taken. The only thing that matters for the completion time of each course is the latest prerequisite to be completed.</p>
<p>This simplifies the problem: let's define the <strong>value</strong> of a path as the sum of values for each node on the path. Consider all paths starting from nodes without any prerequisites. The answer to the problem is the maximum value of all such paths.</p>
<p>We can topologically sort the courses using Kahn's algorithm to solve this problem by simulating the process we talked about in the above example.</p>
<p>Consider an array <code>maxTime</code>. Let <code>maxTime[node]</code> represent the maximum value of all paths <strong>ending</strong> at <code>node</code>. Essentially, this array represents the simplifications from the above examples.</p>
<p><img src="../Figures/2050/5.png" alt="example" /><br />
<br></p>
<p>We initially consider all nodes with an indegree of 0 (no prerequisites). For each node, we iterate over each <code>neighbor</code> and try to update <code>maxTime[neighbor]</code> with a larger value. We also decrease the indegree of <code>neighbor</code>, and if it becomes 0, we push <code>neighbor</code> to our queue. In the end, the answer is the maximum value in <code>maxTime</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize the following data structures:
<ul>
<li>A <code>graph</code> from <code>relations</code>. For convenience, we will change the nodes to be 0-indexed.</li>
<li>An array <code>indegree</code> of length <code>n</code>, representing the indegree of each node.</li>
<li>A <code>queue</code> to perform Kahn's algorithm.</li>
<li>An array <code>maxTime</code> of length <code>n</code>, representing the maximum value of all paths ending at certain nodes.</li>
</ul>
</li>
<li>For all nodes with <code>indegree[node] = 0</code>, push them to the queue and initialize <code>maxTime[node] = time[node]</code>.</li>
<li>While <code>queue</code> is not empty:
<ul>
<li>Pop a <code>node</code>.</li>
<li>Iterate over <code>graph[node]</code>. For each <code>neighbor</code>:
<ul>
<li>Update <code>maxTime[neighbor]</code> with <code>maxTime[node] + time[neighbor]</code> if it is larger.</li>
<li>Decrement <code>indegree[neighbor]</code>.</li>
<li>If <code>indegree[neighbor] == 0</code>, push <code>neighbor</code> to <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>max(maxTime)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/4QGkyzB7/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(e\)</span> as the length of <code>relations</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p>It costs <span class="math inline">\(O(e)\)</span> to build <code>graph</code> and <span class="math inline">\(O(n)\)</span> to initialize <code>maxTime</code>, <code>queue</code>, and <code>indegree</code>.</p>
<p>During Kahn's algorithm, each node is pushed and popped to <code>queue</code> once, costing <span class="math inline">\(O(n)\)</span>. We have a for loop inside the while loop, but this for loop is iterating over edges. Because we only visit each node once, each edge in the input can only be iterated over once as well. This means all for loop iterations across the algorithm will cost <span class="math inline">\(O(e)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p><code>graph</code> takes <span class="math inline">\(O(n + e)\)</span> space, the <code>queue</code> can take up to <span class="math inline">\(O(n)\)</span> space, <code>maxTime</code> and <code>indegree</code> both take <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-dfs--memoization-top-down-dp">Approach 2: DFS + Memoization (Top-Down DP)</h3>
<p><strong>Intuition</strong></p>
<p>We can also use DFS to solve this problem in the other direction. Let's define <code>dfs(node)</code> as the maximum value of all paths starting with <code>node</code>. If <code>node</code> is not a prerequisite to any courses, then we can simply return the value of <code>node</code> since the only path starting at <code>node</code> is <code>node</code> itself.</p>
<p>Otherwise, we iterate over each <code>neighbor</code> of <code>node</code> and call <code>dfs(neighbor)</code>. We take the maximum value of all these calls, add the value of <code>node</code> to it, and return that as <code>dfs(node)</code>. The answer to the original problem is the maximum value of <code>dfs</code> across all nodes. Because <code>dfs(node)</code> may be called many times, we will memoize our function to improve performance.</p>
<blockquote>
<p>This approach is very similar to the first one. In the first approach, for each <code>node</code>, we consider all paths ending at <code>node</code>, and we update <code>maxTime[node]</code> using the prerequisites of <code>node</code>.</p>
<p>In this approach, for each <code>node</code>, we consider all paths starting at <code>node</code>, and we update <code>dfs(node)</code> using the courses that <code>node</code> is a prerequisite of.</p>
<p>Due to the nature of recursion, we do not need to worry about the order in which we visit nodes, and thus a simple DFS works - we don't need to topologically sort.</p>
</blockquote>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a <code>graph</code> from <code>relations</code>. For convenience, we will change the nodes to be 0-indexed.</li>
<li>Define a memoized function <code>dfs(node)</code>:
<ul>
<li>If <code>node</code> has no outgoing edges, return <code>time[node]</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate over <code>graph[node]</code>. For each <code>neighbor</code>, set <code>ans = max(ans, dfs(neighbor))</code>.</li>
<li>Return <code>time[node] + ans</code>.</li>
</ul>
</li>
<li>Call <code>dfs(node)</code> for all nodes and return the maximum value.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/eDAN7FLi/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(e\)</span> as the length of <code>relations</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p>It costs <span class="math inline">\(O(e)\)</span> to build <code>graph</code>.</p>
<p>Because we memoized <code>dfs</code>, we never calculate <code>dfs</code> for a given <code>node</code> more than once. In <code>dfs</code>, we have a for loop. This for loop will iterate <span class="math inline">\(O(e)\)</span> times across all iterations, since we can never iterate over an edge more than once. Thus, the total time for all <code>dfs</code> calls is <span class="math inline">\(O(n + e)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p><code>graph</code> takes <span class="math inline">\(O(n + e)\)</span> space, <code>memo</code> takes <span class="math inline">\(O(n)\)</span> space, and the recursion call stack can take up to <span class="math inline">\(O(n)\)</span> space in the worst-case scenario (when this directed graph degenerates into a linked list.)</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-186">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-existence-queries-in-a-graph-i/description" target="_blank" rel="noopener noreferrer">Path Existence Queries in a Graph I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of nodes in a graph, labeled from 0 to <code>n - 1</code>.</p>

<p>You are also given an integer array <code>nums</code> of length <code>n</code> sorted in <strong>non-decreasing</strong> order, and an integer <code>maxDiff</code>.</p>

<p>An <strong>undirected </strong>edge exists between nodes <code>i</code> and <code>j</code> if the <strong>absolute</strong> difference between <code>nums[i]</code> and <code>nums[j]</code> is <strong>at most</strong> <code>maxDiff</code> (i.e., <code>|nums[i] - nums[j]| &lt;= maxDiff</code>).</p>

<p>You are also given a 2D integer array <code>queries</code>. For each <code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>, determine whether there exists a path between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>Return a boolean array <code>answer</code>, where <code>answer[i]</code> is <code>true</code> if there exists a path between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the <code>i<sup>th</sup></code> query and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, nums = [1,3], maxDiff = 1, queries = [[0,0],[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,false]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Query <code>[0,0]</code>: Node 0 has a trivial path to itself.</li>
	<li>Query <code>[0,1]</code>: There is no edge between Node 0 and Node 1 because <code>|nums[0] - nums[1]| = |1 - 3| = 2</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Thus, the final answer after processing all the queries is <code>[true, false]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, nums = [2,5,6,8], maxDiff = 2, queries = [[0,1],[0,2],[1,3],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false,false,true,true]</span></p>

<p><strong>Explanation:</strong></p>

<p>The resulting graph is:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/25/screenshot-2025-03-26-at-122249.png" style="width: 300px; height: 170px;" /></p>

<ul>
	<li>Query <code>[0,1]</code>: There is no edge between Node 0 and Node 1 because <code>|nums[0] - nums[1]| = |2 - 5| = 3</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Query <code>[0,2]</code>: There is no edge between Node 0 and Node 2 because <code>|nums[0] - nums[2]| = |2 - 6| = 4</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Query <code>[1,3]</code>: There is a path between Node 1 and Node 3 through Node 2 since <code>|nums[1] - nums[2]| = |5 - 6| = 1</code> and <code>|nums[2] - nums[3]| = |6 - 8| = 2</code>, both of which are within <code>maxDiff</code>.</li>
	<li>Query <code>[2,3]</code>: There is an edge between Node 2 and Node 3 because <code>|nums[2] - nums[3]| = |6 - 8| = 2</code>, which is equal to <code>maxDiff</code>.</li>
	<li>Thus, the final answer after processing all the queries is <code>[false, false, true, true]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
	<li><code>0 &lt;= maxDiff &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i] == [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-187">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-existence-queries-in-a-graph-ii/description" target="_blank" rel="noopener noreferrer">Path Existence Queries in a Graph II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of nodes in a graph, labeled from 0 to <code>n - 1</code>.</p>

<p>You are also given an integer array <code>nums</code> of length <code>n</code> and an integer <code>maxDiff</code>.</p>

<p>An <strong>undirected </strong>edge exists between nodes <code>i</code> and <code>j</code> if the <strong>absolute</strong> difference between <code>nums[i]</code> and <code>nums[j]</code> is <strong>at most</strong> <code>maxDiff</code> (i.e., <code>|nums[i] - nums[j]| &lt;= maxDiff</code>).</p>

<p>You are also given a 2D integer array <code>queries</code>. For each <code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>, find the <strong>minimum</strong> distance between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code><sub>.</sub> If no path exists between the two nodes, return -1 for that query.</p>

<p>Return an array <code>answer</code>, where <code>answer[i]</code> is the result of the <code>i<sup>th</sup></code> query.</p>

<p><strong>Note:</strong> The edges between the nodes are unweighted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, nums = [1,8,3,4,2], maxDiff = 3, queries = [[0,3],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p>The resulting graph is:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/25/4149example1drawio.png" style="width: 281px; height: 161px;" /></p>

<table>
	<tbody>
		<tr>
			<th>Query</th>
			<th>Shortest Path</th>
			<th>Minimum Distance</th>
		</tr>
		<tr>
			<td>[0, 3]</td>
			<td>0 &rarr; 3</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[2, 4]</td>
			<td>2 &rarr; 4</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>Thus, the output is <code>[1, 1]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, nums = [5,3,1,9,10], maxDiff = 2, queries = [[0,1],[0,2],[2,3],[4,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,-1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p>The resulting graph is:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/25/4149example2drawio.png" style="width: 281px; height: 121px;" /></p>
</div>

<table>
	<tbody>
		<tr>
			<th>Query</th>
			<th>Shortest Path</th>
			<th>Minimum Distance</th>
		</tr>
		<tr>
			<td>[0, 1]</td>
			<td>0 &rarr; 1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[0, 2]</td>
			<td>0 &rarr; 1 &rarr; 2</td>
			<td>2</td>
		</tr>
		<tr>
			<td>[2, 3]</td>
			<td>None</td>
			<td>-1</td>
		</tr>
		<tr>
			<td>[4, 3]</td>
			<td>3 &rarr; 4</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>Thus, the output is <code>[1, 2, -1, 1]</code>.</p>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, nums = [3,6,1], maxDiff = 1, queries = [[0,0],[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1,-1]</span></p>

<p><strong>Explanation:</strong></p>

<p>There are no edges between any two nodes because:</p>

<ul>
	<li>Nodes 0 and 1: <code>|nums[0] - nums[1]| = |3 - 6| = 3 &gt; 1</code></li>
	<li>Nodes 0 and 2: <code>|nums[0] - nums[2]| = |3 - 1| = 2 &gt; 1</code></li>
	<li>Nodes 1 and 2: <code>|nums[1] - nums[2]| = |6 - 1| = 5 &gt; 1</code></li>
</ul>

<p>Thus, no node can reach any other node, and the output is <code>[0, -1, -1]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= maxDiff &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i] == [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-188">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-maximum-probability/description" target="_blank" rel="noopener noreferrer">Path with Maximum Probability</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected weighted graph of&nbsp;<code>n</code>&nbsp;nodes (0-indexed), represented by an edge list where&nbsp;<code>edges[i] = [a, b]</code>&nbsp;is an undirected edge connecting the nodes&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>&nbsp;with a probability of success of traversing that edge&nbsp;<code>succProb[i]</code>.</p>

<p>Given two nodes&nbsp;<code>start</code>&nbsp;and&nbsp;<code>end</code>, find the path with the maximum probability of success to go from&nbsp;<code>start</code>&nbsp;to&nbsp;<code>end</code>&nbsp;and return its success probability.</p>

<p>If there is no path from&nbsp;<code>start</code>&nbsp;to&nbsp;<code>end</code>, <strong>return&nbsp;0</strong>. Your answer will be accepted if it differs from the correct answer by at most <strong>1e-5</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png" style="width: 187px; height: 186px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
<strong>Output:</strong> 0.25000
<strong>Explanation:</strong>&nbsp;There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png" style="width: 189px; height: 186px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
<strong>Output:</strong> 0.30000
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png" style="width: 215px; height: 191px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
<strong>Output:</strong> 0.00000
<strong>Explanation:</strong>&nbsp;There is no path between 0 and 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10^4</code></li>
	<li><code>0 &lt;= start, end &lt; n</code></li>
	<li><code>start != end</code></li>
	<li><code>0 &lt;= a, b &lt; n</code></li>
	<li><code>a != b</code></li>
	<li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li>
	<li><code>0 &lt;= succProb[i] &lt;= 1</code></li>
	<li>There is at most one edge between every two nodes.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-bellman-ford-algorithm">Approach 1: Bellman-Ford Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with the Bellman-Ford algorithm, please refer to our <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3864/">Bellman-Ford Algorithm Explore Card</a>. For the sake of brevity, we will focus only on the usage of Bellman-Ford and not the implementation details.</p>
</blockquote>
<p>The algorithm works by relaxing edges in the graph, meaning that it tries to improve the shortest path estimate for each node in the graph until the solution is found.</p>
<p>Bellman-Ford is typically used to find the shortest path in a weighted graph. In this problem, instead of the shortest distance, we are looking for the <strong>maximum probability</strong>. The length of a path is the sum of the weights of its edges. Here, the probability of a path equals the product of the probabilities of its edges.</p>
<p>Initially, we set the probability to reach the starting node <code>start</code> as <code>1</code> and all other probabilities as <code>0</code>. Then we iteratively relax the edges of the graph by updating the probability to each node if a higher probability is found.</p>
<p>Considering that a path in the graph without a cycle contains at most <code>n - 1</code> edges, the process is repeated <code>n - 1</code> times, which is enough to relax every edge of every possible path.</p>
<ul>
<li>In the first round, we update the maximum probability of reaching each node <code>u</code> from the starting node along the path that contains only one edge <code>(u, v)</code>.</li>
<li>In the second round, we update the maximum probability of reaching each node <code>u</code> from the starting node along the path that contains two edges (including <code>(u, v)</code>).</li>
<li>and so on.</li>
</ul>
<p>After <code>n - 1</code> rounds, we have updated <code>max_prob[end]</code> to be the maximum probability of reaching <code>end</code> from the staring node along every possible path.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize an array <code>maxProb</code> as the maximum probability to reach each node from the staring node, set <code>maxProb[start]</code> as <code>1</code>.</p>
</li>
<li>
<p>Relax all edges: for each edge <code>(u, v)</code>, if a higher probability of reaching <code>u</code> through this edge is found, update the <code>max_prob[u]</code> as <code>max_prob[u] = max_prob[v] * path_prob</code>, if a higher probability to reach <code>v</code> through this edge is found, update the <code>max_prob[v]</code>.</p>
</li>
<li>
<p>If we are unable to update any node with a higher probability, we can stop the iteration by proceeding to step 4. Otherwise, repeat step 2 until all edges are relaxed <code>n - 1</code> times.</p>
</li>
<li>
<p>Return <code>max_prob[end]</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/CjXtoU2k/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes and <span class="math inline">\(m\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<ul>
<li>The algorithm relaxes all edges in the graph <code>n - 1</code> times, each round contains an iteration over all <code>m</code> edges.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We only need an array of size <span class="math inline">\(n\)</span> to update the maximum probability to reach each node from the starting node.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-shortest-path-faster-algorithm">Approach 2: Shortest Path Faster Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman–Ford algorithm which computes single-source shortest paths in a weighted directed graph.</p>
<p>We start at node <code>start</code> and traverse all its neighbors, calculating the probability of moving from <code>start</code> to each neighbor. We then add these neighbors to a queue, and continue the process for all nodes in the queue until we empty the queue.</p>
<p>The key is maintaining a running maximum probability for each node, and using this maximum to calculate the probabilities for its neighbors. If the probability of traveling from the starting node to a neighbor node through a specific edge is greater than the current maximum probability for that neighbor, we update the maximum probability of this neighbor node, and add this neighbor node to the queue.</p>
<p>Another key point to note is how we calculate the probability of traveling from <code>start</code> to a neighbor node. We are given a set of edge weights that represent the probabilities of moving from one node to another. To calculate the probability of traveling from the starting node to a neighbor node through a specific edge, we simply multiply the edge weight (i.e., the probability of traveling through that edge) by the maximum probability of reaching the current node from the starting node. This gives us the probability of reaching the neighbor node through the current edge.</p>
<p>Take the slides below as an example:</p>
<p>!?!../Documents/1514/s1.json:601,301!?!</p>
<blockquote>
<p>You might wonder, will repeatedly adding the same node back to the queue cause an infinite loop and result in a timeout?</p>
</blockquote>
<p>The answer is NO, because we only update the probability of reaching a neighbor node, say <code>nxt_node</code> and add it back to <code>queue</code> if the current path <strong>increases</strong> the probability of reaching <code>nxt_node</code> from the starting node. Moreover, the weight (probability) of each path is less than or equal to 1. Therefore, even if the graph contains a cycle, the product of the probabilities of all edges in the cycle is still less than or equal to 1. Since loops do not increase the probability of reaching a node, paths that contain loops will be excluded from consideration and not added to the queue.</p>
<p><img src="../Figures/1514/c.png" alt="img" /></p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize an empty queue <code>queue</code> to store nodes that need to be visited.</p>
</li>
<li>
<p>Initialize an array <code>max_prob</code> to store the maximum probability of reaching each node from the starting node. Set the probability of the starting node <code>max_prob[start]</code> as 1, and the probability of all other nodes as 0.</p>
</li>
<li>
<p>Add the starting node <code>start</code> to the <code>queue</code>.</p>
</li>
<li>
<p>While <code>queue</code> is not empty, we remove the first node <code>cur_node</code> from the queue.</p>
</li>
<li>
<p>For each neighbor of <code>nxt_node</code>, calculate the probability of traveling from the starting node to the <code>nxt_node</code> through the current edge (<code>cur_node --- nxt_node</code>), and update the maximum probability for this neighbor <code>max_prob[nxt_node]</code> if necessary.</p>
</li>
<li>
<p>If the probability to this neighbor node is increased, add <code>nxt_node</code> to <code>queue</code>.</p>
</li>
<li>
<p>Repeat steps 4-6 until <code>queue</code> is empty.</p>
</li>
<li>
<p>Return <code>max_prob[end]</code>, the maximum probability of reaching the end node <code>end</code> from the starting node.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/D5ubKTh3/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes and <span class="math inline">\(m\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<ul>
<li>The worst-case running of SPFA is <span class="math inline">\(O(|V|\cdot|E|)\)</span>. However, this is only the worst-case scenario, and the average runtime of SPFA is better than in Bellman-Ford.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<ul>
<li>We build a hash map <code>graph</code> based on all edges, which takes <span class="math inline">\(O(m)\)</span> space.</li>
<li>The algorithm stores the probability array <code>max_prob</code> of size <span class="math inline">\(O(n)\)</span> and a queue of vertices <code>queue</code>. In the worst-case scenario, there are <span class="math inline">\(O(m)\)</span> nodes in <code>queue</code> at the same time.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-dijkstras-algorithm">Approach 3: Dijkstra's Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<blockquote>
<p>If you are not familiar with the Dijkstra's algorithm, please refer to our <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card</a>. For the sake of brevity, we will focus on the usage of the algorithm and not implementation details.</p>
</blockquote>
<p>In BFS, we are exploring the graph in a breadth-first manner, which may not always lead to the shortest path. This is because BFS does not take into account the weights of the edges and only considers the number of hops. As shown in the picture below, even though the two paths to <code>end</code></p>
<ul>
<li><code>0</code> -- <code>2</code></li>
<li><code>0</code> -- <code>1</code> -- <code>2</code><br />
don't have the maximum probability, we still need to update all the nodes along these paths.</li>
</ul>
<p><img src="../Figures/1514/d1.png" alt="img" /></p>
<p>In contrast, Dijkstra's algorithm takes into account the weights of the edges and always guarantees to find the highest probability from the source node to any other node in the graph. This is where Dijkstra's algorithm becomes more suitable than BFS, as it takes into account the weights (probabilities) of the edges and can find the path with the highest probability of reaching the end node.</p>
<p><img src="../Figures/1514/d2.png" alt="img" /></p>
<p>We start from the starting node <code>start</code>, and consider its neighbors one by one, updating the probability to each neighboring node <code>nxt_node</code> if the probability of reaching <code>nxt_node</code> through the current node <code>cur_node</code> is higher than the previous stored probability of reaching <code>nxt_node</code> (by other paths). In order to always select the node with the highest reaching probability, we use a priority queue <code>pq</code> to store the nodes to visit, where the node with the highest probability of being reached from the starting node has the highest priority.</p>
<br>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Initialize a priority queue <code>pq</code> to store nodes that need to be visited, and an array <code>max_prob</code> to store the maximum probability to reach each node from the starting node. Set the probability of the starting node as <code>1</code>, and the probability of all other nodes as <code>0</code>.</p>
</li>
<li>
<p>Add the starting node <code>start</code> and its probability to the priority queue.</p>
</li>
<li>
<p>While <code>pq</code> is not empty, remove <code>cur_node</code>, the node with the highest priority from it.</p>
</li>
<li>
<p>For each neighbor <code>nxt_node</code> of the current node <code>cur_node</code>, calculate the probability of traveling from the starting node to the <code>nxt_node</code> through the current edge <code>cur_node --- nxt_node</code>, and update the maximum probability of <code>nxt_node</code> if necessary. To update the maximum probability, compare the product of the probability with the current node and the probability of the edge <code>cur_node --- nxt_node</code>, with the current maximum probability to the neighbor node. If the product is larger than the maximum probability stored in <code>max_prob[nxt_node]</code>, we update the maximum probability <code>max_prob[nxt_node]</code> as their product.</p>
</li>
<li>
<p>If the neighbor node <code>nxt_node</code> has not been visited, we add it and its probability to the <code>pq</code>.</p>
</li>
<li>
<p>Repeat steps 3-5 until the priority queue is empty or the ending node <code>end</code> has been reached.</p>
</li>
<li>
<p>Return <code>max_prob[end]</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/kjLJ59V7/shared">code</a></p>
<blockquote>
<p>Note that Python's heapq module only implements min heaps. Since we want higher probabilities to be popped first, we need a max heap. To fix this, we multiply the probabilities by <code>-1</code>.</p>
</blockquote>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes and <span class="math inline">\(m\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n + m) \cdot \log n)\)</span></p>
<ul>
<li>We build an adjacency list <code>graph</code> based on all edges, which takes <span class="math inline">\(O(m)\)</span> time.</li>
<li>In the worst case, each node could be pushed into the priority queue exactly once, which results in <span class="math inline">\(O(n \cdot \log n)\)</span> operations.</li>
<li>Each edge is considered exactly once when its corresponding node is dequeued from the priority queue. This takes <span class="math inline">\(O(m \cdot \log n)\)</span> time in total, due to the priority queue's <span class="math inline">\(\log n\)</span> complexity for insertion and deletion operations.</li>
</ul>
</li>
</ul>
<blockquote>
<p>You can also refer to our <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card</a> for details on the complexity analysis.</p>
</blockquote>
<ul>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + m)\)</span></p>
<ul>
<li>We build an adjacency list <code>graph</code> based on all edges, which takes <span class="math inline">\(O(m)\)</span> space.</li>
<li>The algorithm stores the <code>maxProb</code> array, which uses <span class="math inline">\(O(n)\)</span> space.</li>
<li>We use a priority queue to keep track of nodes to be visited, and there are at most <span class="math inline">\(n\)</span> nodes in the queue.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-189">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/path-with-minimum-effort/1" target="_blank" rel="noopener noreferrer">Path With Minimum Effort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are a hiker preparing for an upcoming hike. You are given&nbsp;<strong><code>heights[][]</code></strong>, a 2D array of size&nbsp;<code><strong>rows x columns</strong></code>, where&nbsp;<strong><code>heights[row][col]</code></strong>&nbsp;represents the height of cell&nbsp;<code><strong>(row, col)</strong></code>. You are situated in the top-left cell,&nbsp;<code><strong>(0, 0)</strong></code>, and you hope to travel to the bottom-right cell,&nbsp;<code><strong>(rows-1, columns-1)</strong></code>&nbsp;(i.e.,&nbsp;<strong>0-indexed</strong>). You can move&nbsp;<strong>up</strong>,&nbsp;<strong>down</strong>,&nbsp;<strong>left</strong>, or&nbsp;<strong>right</strong>, and you wish to find the route with minimum <strong>effort</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note: </strong>A route's <strong>effort</strong>&nbsp;is the&nbsp;<strong>maximum absolute difference</strong><strong>&nbsp;</strong>in heights between two consecutive cells of the route.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong><br />row = 3<br />columns = 3 <br />heights = [[1,2,2],[3,8,2],[5,3,5]]
<strong>Output:</strong> <br />2
<strong>Explanation:</strong> <br />The route 1-&gt;3-&gt;5-&gt;3-&gt;5 has a maximum absolute difference of 2 in consecutive cells. This is better than the route 1-&gt;2-&gt;2-&gt;2-&gt;5, where the maximum absolute difference is 3.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong><br />row = 2<br />columns = 2 <br />heights = [[7,7],[7,7]]
<strong>Output:</strong> <br />0
<strong>Explanation:</strong> <br />Any route from the top-left cell to the bottom-right cell has a maximum absolute difference of 0 in consecutive cells.<br /></span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>MinimumEffort()&nbsp;</strong>which takes intergers <strong>rows</strong>, <strong>columns,</strong> and the 2D array <strong>heights[][] </strong><strong>&nbsp;</strong>and returns the<em> </em><strong>minimum</strong>&nbsp;<strong>effort</strong>&nbsp;required to travel from the top-left cell to the bottom-right cell<em>.</em></span></p>
<p><span style="font-size: 18px;"><strong style="font-family: monospace; font-size: 18px;">Expected Time Complexity:&nbsp;</strong><span style="font-family: monospace; font-size: 18px; background-color: #b4d7ff;">O(rowsxcolumns)</span><br style="font-family: monospace; font-size: 18px;" /><strong style="font-family: monospace; font-size: 18px;">Expected Space Complexity:&nbsp;</strong><span style="font-family: monospace; font-size: 18px; background-color: #b4d7ff;">O(rowsxcolumns)</span></span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong><span style="font-family: monospace; background-color: #b4d7ff;">1 &lt;= rows, columns &lt;= 100</span><strong><br /></strong></span><span style="font-size: 18px;"><code>rows == heights.length<br />
columns == heights[i].length<br />0 &lt;= heights[i][j] &lt;= 10<sup>6</sup></code></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-190">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/possible-bipartition/description" target="_blank" rel="noopener noreferrer">Possible Bipartition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We want to split a group of <code>n</code> people (labeled from <code>1</code> to <code>n</code>) into two groups of <strong>any size</strong>. Each person may dislike some other people, and they should not go into the same group.</p>

<p>Given the integer <code>n</code> and the array <code>dislikes</code> where <code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that the person labeled <code>a<sub>i</sub></code> does not like the person labeled <code>b<sub>i</sub></code>, return <code>true</code> <em>if it is possible to split everyone into two groups in this way</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, dislikes = [[1,2],[1,3],[2,4]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The first group has [1,4], and the second group has [2,3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, dislikes = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> false
<strong>Explanation:</strong> We need at least 3 groups to divide them. We cannot put them in two groups.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2000</code></li>
	<li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li>
	<li><code>dislikes[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= n</code></li>
	<li>All the pairs of <code>dislikes</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-191">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/possible-paths3834/1" target="_blank" rel="noopener noreferrer">Possible paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a directed graph and two vertices <strong>&lsquo;u&rsquo;</strong> and <strong>&lsquo;v&rsquo;</strong> in it. Find the number of possible walks from <strong>&lsquo;u&rsquo;</strong> to <strong>&lsquo;v&rsquo;</strong> with exactly <strong>k</strong> edges on the walk modulo 10<sup>9</sup>+7.</span></p>
<p><span style="font-size: 18px;"><strong>Note :&nbsp;</strong>There can be a cycle in the graph and an edge can be travelled multiple times.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input 1: </strong>graph = {{0,1,1,1},{0,0,0,1}, 
{0,0,0,1}, {0,0,0,0}}, u = 0, v = 3, k = 2
<strong>Output: </strong>2
<strong>Explanation: </strong>Let source &lsquo;u&rsquo; be vertex 0, 
destination &lsquo;v&rsquo; be 3 and k be 2. The output 
should be 2 as there are two walk from 0 to 
3 with exactly 2 edges. The walks are {0, 2, 3}
and {0, 1, 3}.</span>
<img src="http://d1hyf4ir1gqw6c.cloudfront.net/wp-content/uploads/graph1.png" alt="" />
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>MinimumWalk()&nbsp;</strong>which takes graph, u, v and k as input parameter and returns total possible paths from u to v using exactly k edges modulo 10<sup>9</sup>+7.</span><br /><span style="font-size: 18px;"><strong>Note:&nbsp;</strong>In graph, if graph[i][j] = 1, it means there is an directed edge from vertex i to j.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>3</sup>)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(n<sup>3</sup>)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 50<br />1 &le; k &le; n<br />0 &le; u, v &le; n-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-192">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/possible-paths-between-2-vertices-1587115620/1" target="_blank" rel="noopener noreferrer">Possible paths between 2 vertices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>Directed Graph</strong> having <strong>V</strong> nodes numbered from <strong>0</strong>&nbsp;to <strong>V-1</strong>, and E&nbsp;directed edges. Given two nodes,&nbsp;<em><strong>source </strong></em>and <em><strong>destination</strong></em>, count the number of ways or paths between these two vertices in the&nbsp;directed graph. These paths should not&nbsp;contain any cycle.<br /><strong>Note:&nbsp;</strong>Graph doesn't contain multiple edges, self-loop, and cycles.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong></span><span style="font-size: 18px;">V = 5, E = 7, Adj = [{1,2,4}, {3,4}, {4}, {2}, {}]
source = 0, destination = 4</span><span style="font-size: 18px;">
<strong>Output:</strong> 4
<strong>Explanation</strong>: 
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701246/Web/Other/blobid0_1752143630.jpg" width="327" height="217" /><br />There are 4 paths from 0 to 4.
0 -&gt; 4
0 -&gt; 1 -&gt; 4
0 -&gt; 2 -&gt; 4
0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>V = 4, E = 5
Adj = [{1,3}, {2,3}, {3}, {}]
source = 0&nbsp;
destination = 3</span><span style="font-size: 18px;">
<strong>Output:</strong> 3
<strong>Explanation</strong>:
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701246/Web/Other/blobid1_1752143671.jpg" width="307" height="204" /><br /><span style="font-size: 18px;">There are 3 paths from 0 to 3.
0 -&gt; 3
0 -&gt; 1 -&gt; 3
0 -&gt; 1 -&gt; 2 -&gt; 3
</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Your task:</strong><br />You don't need to read, input, or print anything. Your task is to complete the function&nbsp;<strong>countPaths(),</strong>&nbsp;which takes the integer <strong>V</strong> denoting the number of vertices, <a href="https://www.geeksforgeeks.org/graph-and-its-representations/">adjacency list</a>&nbsp;<strong>adj</strong>, integer <strong>source</strong>, and <strong>destination </strong>as input parameters and returns the number of paths in the graph from the source vertex to the destination vertex.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(V!)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(V)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; V, E &le; 100<br />1 &le; source, destination&nbsp;&le; V</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-193">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/power-grid-maintenance/description" target="_blank" rel="noopener noreferrer">Power Grid Maintenance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="401" data-start="120">You are given an integer <code data-end="194" data-start="191">c</code> representing <code data-end="211" data-start="208">c</code> power stations, each with a unique identifier <code>id</code> from 1 to <code>c</code> (1‑based indexing).</p>

<p data-end="401" data-start="120">These stations are interconnected via <code data-end="295" data-start="292">n</code> <strong>bidirectional</strong> cables, represented by a 2D array <code data-end="357" data-start="344">connections</code>, where each element <code data-end="430" data-start="405">connections[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates a connection between station <code>u<sub>i</sub></code> and station <code>v<sub>i</sub></code>. Stations that are directly or indirectly connected form a <strong>power grid</strong>.</p>

<p data-end="626" data-start="586">Initially, <strong>all</strong> stations are online (operational).</p>

<p data-end="720" data-start="628">You are also given a 2D array <code data-end="667" data-start="658">queries</code>, where each query is one of the following <em>two</em> types:</p>

<ul data-end="995" data-start="722">
	<li data-end="921" data-start="722">
	<p data-end="921" data-start="724"><code data-end="732" data-start="724">[1, x]</code>: A maintenance check is requested for station <code data-end="782" data-start="779">x</code>. If station <code>x</code> is online, it resolves the check by itself. If station <code>x</code> is offline, the check is resolved by the operational station with the smallest <code>id</code> in the same <strong>power grid</strong> as <code>x</code>. If <strong>no</strong> <strong>operational</strong> station <em>exists</em> in that grid, return -1.</p>
	</li>
	<li data-end="995" data-start="923">
	<p data-end="995" data-start="925"><code data-end="933" data-start="925">[2, x]</code>: Station <code data-end="946" data-start="943">x</code> goes offline (i.e., it becomes non-operational).</p>
	</li>
</ul>

<p data-end="1106" data-start="997">Return an array of integers representing the results of each query of type <code data-end="1080" data-start="1072">[1, x]</code> in the <strong>order</strong> they appear.</p>

<p data-end="1106" data-start="997"><strong>Note:</strong> The power grid preserves its structure; an offline (non‑operational) node remains part of its grid and taking it offline does not alter connectivity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">c = 5, connections = [[1,2],[2,3],[3,4],[4,5]], queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/15/powergrid.jpg" style="width: 361px; height: 42px;" /></p>

<ul>
	<li data-end="223" data-start="143">Initially, all stations <code>{1, 2, 3, 4, 5}</code> are online and form a single power grid.</li>
	<li data-end="322" data-start="226">Query <code>[1,3]</code>: Station 3 is online, so the maintenance check is resolved by station 3.</li>
	<li data-end="402" data-start="325">Query <code>[2,1]</code>: Station 1 goes offline. The remaining online stations are <code>{2, 3, 4, 5}</code>.</li>
	<li data-end="557" data-start="405">Query <code>[1,1]</code>: Station 1 is offline, so the check is resolved by the operational station with the smallest <code>id</code> among <code>{2, 3, 4, 5}</code>, which is station 2.</li>
	<li data-end="641" data-start="560">Query <code>[2,2]</code>: Station 2 goes offline. The remaining online stations are <code>{3, 4, 5}</code>.</li>
	<li data-end="800" data-start="644">Query <code>[1,2]</code>: Station 2 is offline, so the check is resolved by the operational station with the smallest <code>id</code> among <code>{3, 4, 5}</code>, which is station 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">c = 3, connections = [], queries = [[1,1],[2,1],[1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li data-end="976" data-start="909">There are no connections, so each station is its own isolated grid.</li>
	<li data-end="1096" data-start="979">Query <code>[1,1]</code>: Station 1 is online in its isolated grid, so the maintenance check is resolved by station 1.</li>
	<li data-end="1135" data-start="1099">Query <code>[2,1]</code>: Station 1 goes offline.</li>
	<li data-end="1237" data-start="1138">Query <code>[1,1]</code>: Station 1 is offline and there are no other stations in its grid, so the result is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="155" data-start="139"><code>1 &lt;= c &lt;= 10<sup>5</sup></code></li>
	<li data-end="213" data-start="158"><code>0 &lt;= n == connections.length &lt;= min(10<sup>5</sup>, c * (c - 1) / 2)</code></li>
	<li data-end="244" data-start="216"><code>connections[i].length == 2</code></li>
	<li data-end="295" data-start="247"><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= c</code></li>
	<li data-end="338" data-start="298"><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="374" data-start="341"><code>1 &lt;= queries.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li data-end="401" data-start="377"><code>queries[i].length == 2</code></li>
	<li data-end="436" data-start="404"><code>queries[i][0]</code> is either 1 or 2.</li>
	<li data-end="462" data-start="439"><code>1 &lt;= queries[i][1] &lt;= c</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-194">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/prerequisite-tasks/1" target="_blank" rel="noopener noreferrer">Prerequisite Tasks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are a total of N tasks, labeled from 0 to N-1. Some tasks may have prerequisites, for example to do task 0 you have to first complete task 1, which is expressed as a pair: [0, 1]<br />Given the total number of tasks <strong>N</strong> and a list of <strong>P prerequisite pairs</strong>, find if it is possible to finish all tasks.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>N = 4, P = 3, prerequisites = [[1,0],[2,1],[3,2]]
<strong>Output: </strong>Yes
<strong>Explanation</strong>: To do task 1 you should have completed task 0, and to do task 2 you should have finished task 1, and to do task 3 you should have finished task 2. So it is possible.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>N = 2, P = 2, prerequisites = [[1,0],[0,1]]
<strong>Output: </strong>No
<strong>Explanation</strong>: To do task 1 you should have completed task 0, and to do task 0 you should have finished task 1. So it is impossible.
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 10<sup>4</sup><br />1 &le; P &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-195">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-adjacency-list-1587115620/1" target="_blank" rel="noopener noreferrer">Print adjacency list</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18px;">Given an&nbsp;</span></span><span style="font-family: arial, helvetica, sans-serif; font-size: 18px;">undirected graph with&nbsp;</span><strong style="font-family: arial, helvetica, sans-serif; font-size: 18px;">V&nbsp;</strong><span style="font-family: arial, helvetica, sans-serif; font-size: 18px;">nodes and </span><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18px;"><strong>E</strong> <strong>edges</strong>, create and return an <a href="https://www.geeksforgeeks.org/adjacency-list-meaning-definition-in-dsa/" target="_blank" rel="noopener">adjacency list</a> of the graph</span></span><span style="font-size: 18px; font-family: arial, helvetica, sans-serif;">. <strong>0-based indexing</strong> is followed everywhere.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:<br /></strong>V = 5, E = 7<br />edges = [[0,1], [0,4], [4,1], [4,3], [1,3], [1,2], [3,2]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701247/Web/Other/blobid2_1744376584.jpg" width="229" height="186" /><br /><strong>Output:</strong> 
[[1,4], [0,2,3,4], [1,3], [1,2,4], [0,1,3]]
<strong>Explanation</strong>:
Node 0 is connected to 1 and 4.<br /></span><span style="font-size: 18px;">Node 1 is connected to 0,2,3 and 4.<br /></span><span style="font-size: 18px;">Node 2 is connected to 1 and 3.<br />Node 3 is connected to 1,2 and 4.<br />Node 4 is connected to 0,1 and 3.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:<br /></strong>V = 4, E = 3<br />edges = [[0,3], [0,2], [2,1]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701247/Web/Other/blobid5_1744376643.jpg" width="223" height="182" /> &nbsp;<br /><strong>Output:</strong> 
[[2,3], [2], [0,1], [0]]
<strong>Explanation</strong>:<br /></span><span style="font-size: 18px;">Node 0 is connected to 2 and 3.<br />Node 1 is only connected to 2.<br />Node 2 is connected to 0 and 1.<br />Node 3 is only connected to 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; V, E &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-196">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/waves-b18625d7/" target="_blank" rel="noopener noreferrer">Printing patterns</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">implementation</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are required to form a matrix of size <span class="mathjax-latex">\(r\times c\)</span> where <span class="mathjax-latex">\(r\)</span> is the number of rows and <span class="mathjax-latex">\(c\)</span> is the number of columns. You are required to form the waves of numbers around the provided center, <span class="mathjax-latex">\((C_i,\ C_j)\)</span> (0-based indexing).</p>

<p>Example:</p>

<ul>
	<li>Size of the matrix: <span class="mathjax-latex">\(r = 9\)</span> and <span class="mathjax-latex">\(c = 9\)</span></li>
	<li>Center coordinates: <span class="mathjax-latex">\(C_i = 4\)</span> and <span class="mathjax-latex">\(C_j = 4\)</span> (0 based indexing)</li>
	<li>Pattern:</li>
</ul>

<p style="margin-left: 40px;">            4 4 4 4 4 4 4 4 4 <br>
            4 3 3 3 3 3 3 3 4 <br>
            4 3 2 2 2 2 2 3 4 <br>
            4 3 2 1 1 1 2 3 4 <br>
            4 3 2 1 0 1 2 3 4 <br>
            4 3 2 1 1 1 2 3 4 <br>
            4 3 2 2 2 2 2 3 4 <br>
            4 3 3 3 3 3 3 3 4 <br>
            4 4 4 4 4 4 4 4 4</p>

<p>You are given the values of <span class="mathjax-latex">\(r,\ c,\ C_i,\ C_j\)</span> (the values of <span class="mathjax-latex">\(C_i\)</span> and <span class="mathjax-latex">\(C_j\)</span> is 0-based indexed). Your task is to print the provided pattern.</p>

<p><strong>Input format</strong></p>

<p>The first line contains four integers <span class="mathjax-latex">\(r\)</span>, <span class="mathjax-latex">\(c\)</span>, <span class="mathjax-latex">\(C_i\)</span>, and <span class="mathjax-latex">\(C_j\)</span> denoting the number of rows, number of columns, <span class="mathjax-latex">\(x\)</span> coordinate of center, and <span class="mathjax-latex">\(y\)</span> coordinate of center.</p>

<p><strong>Output format</strong></p>

<p>Print the pattern for the provided input.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \le r \le 1e3\\
1 \le c \le 1e3\\
0 \le C_i &lt; r\\
0 \le C_j &lt; c\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Given input have shown output.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-197">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/prison-break-5/" target="_blank" rel="noopener noreferrer">Prison Break</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">approved</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">easy</span> <span class="topic-badge">graph</span> <span class="topic-badge">open</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alfie was a prisoner in mythland. Though Alfie was a witty and intelligent guy.He was confident of escaping prison.After few days of observation,He figured out that the prison consists of (<strong><span class="mathjax-latex">\(N × N\)</span></strong>) cells.i.e The shape of prison was (<strong><span class="mathjax-latex">\(N × N\)</span></strong>) matrix. Few of the cells of the prison contained motion detectors.So Alfie planned that while escaping the prison he will avoid those cells containing motion detectors.Yet before executing his plan,Alfie wants to know the total number of unique possible paths which he can take to escape the prison.Initially Alfie is in cell  <br />
<strong>(<span class="mathjax-latex">\(1,1\)</span>)</strong> while the exit of the cell <strong>(<span class="mathjax-latex">\(N,N\)</span>)</strong>.  </p>
<p><strong>note</strong>:-&gt;Alfie can move in all four direction{ if his current location is  <strong>(<span class="mathjax-latex">\(X,Y\)</span>)</strong>, he can move to either <br />
<strong>(<span class="mathjax-latex">\(X+1,Y\)</span>)</strong>, <strong>(<span class="mathjax-latex">\(X-1,Y\)</span>)</strong>, <strong>(<span class="mathjax-latex">\(X,Y+1\)</span>)</strong>, <strong>(<span class="mathjax-latex">\(X,Y-1\)</span>)</strong> }. If the first cell <strong>(<span class="mathjax-latex">\(1,1\)</span>)</strong> and the last cell(<strong><span class="mathjax-latex">\(N,N\)</span></strong>) contain motion detectors,then Alfie can't break out of the prison.</p>
<p><strong>INPUT</strong>: </p>
<p>The first line contain number of test cases "<strong><em>T</em></strong>".<strong><em>T</em></strong> test cases follow.The first line of each test case contains an integer "<strong><em>N</em></strong>",(i.e the size of the (<strong><span class="mathjax-latex">\(N × N\)</span></strong>) matrix).The next <strong><em>n</em></strong> lines contain <strong><em>N</em></strong> space separated values either <strong><em>0</em></strong> or <strong><em>1</em></strong>."<strong><em>1</em></strong>" represents a cell containing motion detectors. </p>
<p><strong>OUTPUT</strong>: </p>
<p>output total number of unique possible paths which he can take to escape the prison.  </p>
<p><strong>Constraint</strong>:</p>
<p><span class="mathjax-latex">\(1 \le  T \le 20\)</span></p>
<p><span class="mathjax-latex">\(1 \le N \le 20\)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-198">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/process-restricted-friend-requests/description" target="_blank" rel="noopener noreferrer">Process Restricted Friend Requests</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> indicating the number of people in a network. Each person is labeled from <code>0</code> to <code>n - 1</code>.</p>

<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>restrictions</code>, where <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> means that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> <strong>cannot </strong>become <strong>friends</strong>,<strong> </strong>either <strong>directly</strong> or <strong>indirectly</strong> through other people.</p>

<p>Initially, no one is friends with each other. You are given a list of friend requests as a <strong>0-indexed</strong> 2D integer array <code>requests</code>, where <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> is a friend request between person <code>u<sub>j</sub></code> and person <code>v<sub>j</sub></code>.</p>

<p>A friend request is <strong>successful </strong>if <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> can be <strong>friends</strong>. Each friend request is processed in the given order (i.e., <code>requests[j]</code> occurs before <code>requests[j + 1]</code>), and upon a successful request, <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> <strong>become direct friends</strong> for all future friend requests.</p>

<p>Return <em>a <strong>boolean array</strong> </em><code>result</code>,<em> where each </em><code>result[j]</code><em> is </em><code>true</code><em> if the </em><code>j<sup>th</sup></code><em> friend request is <strong>successful</strong> or </em><code>false</code><em> if it is not</em>.</p>

<p><strong>Note:</strong> If <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> are already direct friends, the request is still <strong>successful</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
<strong>Output:</strong> [true,false]
<strong>Explanation:
</strong>Request 0: Person 0 and person 2 can be friends, so they become direct friends. 
Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
<strong>Output:</strong> [true,false]
<strong>Explanation:
</strong>Request 0: Person 1 and person 2 can be friends, so they become direct friends.
Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
<strong>Output:</strong> [true,false,true,false]
<strong>Explanation:
</strong>Request 0: Person 0 and person 4 can be friends, so they become direct friends.
Request 1: Person 1 and person 2 cannot be friends since they are directly restricted.
Request 2: Person 3 and person 1 can be friends, so they become direct friends.
Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>
	<li><code>restrictions[i].length == 2</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= requests.length &lt;= 1000</code></li>
	<li><code>requests[j].length == 2</code></li>
	<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-199">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/project-manager--141631/1" target="_blank" rel="noopener noreferrer">Project Manager</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">An IT company is working on a large project. The project is broken into <strong>N</strong> modules and distributed to different teams. Each team can work parallelly. The amount of time (in months) required to complete each module is given in an array <strong>duration[ ]</strong>&nbsp;<em>i.e.</em> time needed to complete<strong> i<sup>th</sup>&nbsp;</strong>module is <strong>duration[i]</strong> months.&nbsp;<br />You are also given&nbsp;<strong>M</strong> <strong>dependencies</strong>&nbsp;such that for each i (1 &le; i &le; M)&nbsp;&nbsp;<strong>dependencies[i][1]<sup>th</sup> </strong>module can be started after&nbsp;<strong>dependencies[i][0]<sup>th</sup> </strong>module is completed.<br />As the project manager, compute the minimum time required to complete the project.<br /><strong>Note</strong>: It is guaranteed that a module is not dependent on itself.</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 6, M = 6
duration[] = [1, 2, 3, 1, 3, 2]
dependencies[][]:[[5, 2], [5, 0], [4, 0], [4, 1], [2, 3], [3, 1]]
<strong>Output:</strong> 
8
<strong>Explanation: </strong>
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/706082/Web/Other/blobid0_1745301599.jpg" width="260" height="176" /><br /><span style="font-size: 18px;">The Graph of dependency forms this and 
the project will be completed when Module 
1 is completed which takes 8 months.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 3, M = 3
duration[] = [5, 5, 5]
dependencies[][]:[[0, 1], [1, 2], [2, 0]]
<strong>Output: </strong>-1
<strong>Explanation: </strong>
There is a cycle in the dependency graph 
hence the project cannot be completed.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />Complete the function <strong>minTime()</strong> which takes <strong>N</strong>, <strong>M</strong>, <strong>duration</strong> <strong>array</strong>, and <strong>dependencies</strong> <strong>array</strong> as input parameter and return the minimum time required. return -1 if the project can not be completed.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N+M)<br /><strong>Expected Auxiliary Space:</strong> O(N)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le;&nbsp;N &le;&nbsp;10<sup>5</sup><br />0 &le;&nbsp;M &le;&nbsp;2*10<sup>5</sup><br />0 &le;&nbsp;duration[i] &le;&nbsp;10<sup>5</sup><br />0 &le;&nbsp;dependencies[i][j]&nbsp;&lt;&nbsp;N</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-200">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/properties-graph/description" target="_blank" rel="noopener noreferrer">Properties Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>properties</code> having dimensions <code>n x m</code> and an integer <code>k</code>.</p>

<p>Define a function <code>intersect(a, b)</code> that returns the <strong>number of distinct integers</strong> common to both arrays <code>a</code> and <code>b</code>.</p>

<p>Construct an <strong>undirected</strong> graph where each index <code>i</code> corresponds to <code>properties[i]</code>. There is an edge between node <code>i</code> and node <code>j</code> if and only if <code>intersect(properties[i], properties[j]) &gt;= k</code>, where <code>i</code> and <code>j</code> are in the range <code>[0, n - 1]</code> and <code>i != j</code>.</p>

<p>Return the number of <strong>connected components</strong> in the resulting graph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The graph formed has 3 connected components:</p>

<p><img height="171" src="https://assets.leetcode.com/uploads/2025/02/27/image.png" width="279" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,2,3],[2,3,4],[4,3,5]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The graph formed has 1 connected component:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/02/27/screenshot-from-2025-02-27-23-58-34.png" style="width: 219px; height: 171px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,1],[1,1]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><code>intersect(properties[0], properties[1]) = 1</code>, which is less than <code>k</code>. This means there is no edge between <code>properties[0]</code> and <code>properties[1]</code> in the graph.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == properties.length &lt;= 100</code></li>
	<li><code>1 &lt;= m == properties[i].length &lt;= 100</code></li>
	<li><code>1 &lt;= properties[i][j] &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= m</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-201">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rank-transform-of-a-matrix/description" target="_blank" rel="noopener noreferrer">Rank Transform of a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>matrix</code>, return <em>a new matrix </em><code>answer</code><em> where </em><code>answer[row][col]</code><em> is the </em><em><strong>rank</strong> of </em><code>matrix[row][col]</code>.</p>

<p>The <strong>rank</strong> is an <strong>integer</strong> that represents how large an element is compared to other elements. It is calculated using the following rules:</p>

<ul>
	<li>The rank is an integer starting from <code>1</code>.</li>
	<li>If two elements <code>p</code> and <code>q</code> are in the <strong>same row or column</strong>, then:
	<ul>
		<li>If <code>p &lt; q</code> then <code>rank(p) &lt; rank(q)</code></li>
		<li>If <code>p == q</code> then <code>rank(p) == rank(q)</code></li>
		<li>If <code>p &gt; q</code> then <code>rank(p) &gt; rank(q)</code></li>
	</ul>
	</li>
	<li>The <strong>rank</strong> should be as <strong>small</strong> as possible.</li>
</ul>

<p>The test cases are generated so that <code>answer</code> is unique under the given rules.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank1.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2],[3,4]]
<strong>Output:</strong> [[1,2],[2,3]]
<strong>Explanation:</strong>
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
The rank of matrix[0][1] is 2 because matrix[0][1] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][0] is 2 because matrix[1][0] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][1] is 3 because matrix[1][1] &gt; matrix[0][1], matrix[1][1] &gt; matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank2.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[7,7],[7,7]]
<strong>Output:</strong> [[1,1],[1,1]]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank3.jpg" style="width: 601px; height: 322px;" />
<pre>
<strong>Input:</strong> matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
<strong>Output:</strong> [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[row][col] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-202">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reachable-nodes-in-subdivided-graph/description" target="_blank" rel="noopener noreferrer">Reachable Nodes In Subdivided Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected graph (the <strong>&quot;original graph&quot;</strong>) with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You decide to <strong>subdivide</strong> each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.</p>

<p>The graph is given as a 2D array of <code>edges</code> where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the original graph, and <code>cnt<sub>i</sub></code> is the total number of new nodes that you will <strong>subdivide</strong> the edge into. Note that <code>cnt<sub>i</sub> == 0</code> means you will not subdivide the edge.</p>

<p>To <strong>subdivide</strong> the edge <code>[u<sub>i</sub>, v<sub>i</sub>]</code>, replace it with <code>(cnt<sub>i</sub> + 1)</code> new edges and <code>cnt<sub>i</sub></code> new nodes. The new nodes are <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code>, and the new edges are <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>-1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code>.</p>

<p>In this <strong>new graph</strong>, you want to know how many nodes are <strong>reachable</strong> from the node <code>0</code>, where a node is <strong>reachable</strong> if the distance is <code>maxMoves</code> or less.</p>

<p>Given the original graph and <code>maxMoves</code>, return <em>the number of nodes that are <strong>reachable</strong> from node </em><code>0</code><em> in the new graph</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" style="width: 600px; height: 247px;" />
<pre>
<strong>Input:</strong> edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
<strong>Output:</strong> 13
<strong>Explanation:</strong> The edge subdivisions are shown in the image above.
The nodes that are reachable are highlighted in yellow.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
<strong>Output:</strong> 23
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
<strong>Output:</strong> 1
<strong>Explanation:</strong> Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>
	<li>There are <strong>no multiple edges</strong> in the graph.</li>
	<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= n &lt;= 3000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dijkstras">Approach 1: Dijkstra's</h3>
<p><strong>Intuition</strong></p>
<p>Treating the original graph as a weighted, undirected graph, we can use Dijkstra's algorithm to find all reachable nodes in the original graph.  However, this won't be enough to solve examples where subdivided edges are only used partially.</p>
<p>When we travel along an edge (in either direction), we can keep track of how much we use it.  At the end, we want to know every node we reached in the original graph, plus the sum of the utilization of each edge.</p>
<p><strong>Algorithm</strong></p>
<p>We use <em>Dijkstra's algorithm</em> to find the shortest distance from our source to all targets.  This is a textbook algorithm, refer to <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">this link</a> for more details.</p>
<p>Additionally, for each (directed) edge <code>(node, nei)</code>, we'll keep track of how many &quot;new&quot; nodes (new from subdivision of the original edge) were <code>used</code>.  At the end, we'll sum up the utilization of each edge.</p>
<p>Please see the inline comments for more details.</p>
<p><a href="https://leetcode.com/playground/PktDsMD2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(E \log N)\)</span>, where <span class="math inline">\(E\)</span> is the length of <code>edges</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(E)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-203">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reachable-nodes-with-restrictions/description" target="_blank" rel="noopener noreferrer">Reachable Nodes With Restrictions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> edges.</p>

<p>You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given an integer array <code>restricted</code> which represents <strong>restricted</strong> nodes.</p>

<p>Return <em>the <strong>maximum</strong> number of nodes you can reach from node </em><code>0</code><em> without visiting a restricted node.</em></p>

<p>Note that node <code>0</code> will <strong>not</strong> be a restricted node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png" style="width: 402px; height: 322px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The diagram above shows the tree.
We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png" style="width: 412px; height: 312px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The diagram above shows the tree.
We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>1 &lt;= restricted.length &lt; n</code></li>
	<li><code>1 &lt;= restricted[i] &lt; n</code></li>
	<li>All the values of <code>restricted</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-204">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reconstruct-itinerary/description" target="_blank" rel="noopener noreferrer">Reconstruct Itinerary</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">eulerian-circuit</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a list of airline <code>tickets</code> where <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.</p>

<p>All of the tickets belong to a man who departs from <code>&quot;JFK&quot;</code>, thus, the itinerary must begin with <code>&quot;JFK&quot;</code>. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p>

<ul>
	<li>For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>
</ul>

<p>You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" style="width: 382px; height: 222px;" />
<pre>
<strong>Input:</strong> tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]
<strong>Output:</strong> [&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" style="width: 222px; height: 230px;" />
<pre>
<strong>Input:</strong> tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
<strong>Output:</strong> [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]
<strong>Explanation:</strong> Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] but it is larger in lexical order.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tickets.length &lt;= 300</code></li>
	<li><code>tickets[i].length == 2</code></li>
	<li><code>from<sub>i</sub>.length == 3</code></li>
	<li><code>to<sub>i</sub>.length == 3</code></li>
	<li><code>from<sub>i</sub></code> and <code>to<sub>i</sub></code> consist of uppercase English letters.</li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-205">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/reduce-the-array-2-2a1e3e02/" target="_blank" rel="noopener noreferrer">Reduce the Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <span class="mathjax-latex">\(N\)</span> numbers, and you are asked to minimize the total "<span class="mathjax-latex">\(OR \ \ cost\)</span>" incurred when reducing the array to a single number. To achieve this, you need to follow these steps:</p>

<ol>
	<li>Select any two numbers <span class="mathjax-latex">\(P\)</span> and <span class="mathjax-latex">\(Q\)</span> from the array. The cost of selecting these two numbers is <span class="mathjax-latex">\(((P + Q) + (P | Q) - (P &amp; Q))\)</span>, where "|" denotes the bitwise <span class="mathjax-latex">\(OR\)</span> operator, and "&amp;" denotes the bitwise <span class="mathjax-latex">\(AND\)</span> operator.</li>
	<li>
	<p>Choose one of the two numbers you selected in the previous step and remove it from the array. Concatenate the remaining numbers.</p>
	</li>
	<li>
	<p>Repeat the above two steps until the array is reduced to a single number.</p>
	</li>
</ol>

<p>The "<span class="mathjax-latex">\(OR\)</span> <span class="mathjax-latex">\(cost\)</span>" is defined as the bitwise <span class="mathjax-latex">\(OR\)</span> of all the costs incurred in reducing the array to a single number.</p>

<p>&nbsp;</p>

<p><u><strong>Input Format :</strong></u></p>

<p>An integer <span class="mathjax-latex">\(N\)</span> denoting the size of the array</p>

<p><span class="mathjax-latex">\(N\)</span> integers denoting the elements of the array</p>

<p><u><strong>Output Format :</strong></u></p>

<p>Print one integer, the minimum&nbsp;<span class="mathjax-latex">\(OR \ \ cost\)</span></p>

<p><u><strong>Constraints :</strong></u></p>

<p><u><strong><span class="mathjax-latex">\(1 \leq N \leq 10^3\)</span></strong></u></p>

<p><span class="mathjax-latex">\(1 \leq a_i \leq 10^6\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Sure, here's a possible rephrased version of the explanation:</p>

<p>Consider the following example array: [1, 5, 2, 3]. To minimize the total "OR cost," we can follow these steps:</p>

<ol>
	<li>
	<p>Select 1 and 5. Remove 5 from the array, and concatenate the remaining numbers [1, 2, 3]. The cost incurred is&nbsp;<span class="mathjax-latex">\(((1 + 5) + (1 | 5) - (1 &amp; 5)) = 10.\)</span></p>
	</li>
	<li>
	<p>Select 1 and 2. Remove 2 from the array, and concatenate the remaining numbers [1, 3]. The cost incurred is <span class="mathjax-latex">\(((1 + 2) + (1 | 2) - (1 &amp; 2)) = 6.\)</span></p>
	</li>
	<li>
	<p>Select 1 and 3. Remove 1 from the array, and concatenate the remaining numbers [3]. The cost incurred is <span class="mathjax-latex">\(((1 + 3) + (1 | 3) - (1 &amp; 3)) = 6.\)</span></p>
	</li>
</ol>

<p>Thus, the total "OR cost" is the bitwise OR of the individual costs incurred, which is <span class="mathjax-latex">\((10 | 6 | 6)\)</span> = 14. It can be shown that we can never achieve a total cost less than 14 for this particular array.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-206">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/redundant-connection/description" target="_blank" rel="noopener noreferrer">Redundant Connection</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p>

<p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong> vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p>

<p>Return <em>an edge that can be removed so that the resulting graph is a tree of </em><code>n</code><em> nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg" style="width: 382px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
<strong>Output:</strong> [1,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>3 &lt;= n &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= edges.length</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
	<li>The given graph is connected.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a graph consisting of <span class="math inline">\(N\)</span> nodes and <span class="math inline">\(N − 1\)</span> edges, which means the graph initially forms a tree. A tree is a special type of graph that is connected (there is a path between any two nodes) and acyclic (it does not contain any cycles). However, a new edge is added to the tree, connecting two nodes that are already part of the graph. This new edge creates a cycle because there are now two distinct paths between some pairs of nodes. As a result, the graph is no longer a tree but a single-cycle graph.</p>
<p>Our goal is to identify the edge that, if removed, will restore the graph to its original state as a tree. Since the tree must be connected and acyclic, removing any edge from the cycle will break the cycle and turn the graph into a tree. However, if there are multiple edges that can be removed to achieve this, we are required to return the edge that appears last in the given list of edges.</p>
<hr />
<h3 id="approach-1-depth-first-search---brute-force">Approach 1: Depth-First Search - Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The key idea is that we can safely discard an edge if it connects two nodes that are already part of the same connected component. In simple terms, this means that if there's already a path between the two nodes (even without the current edge), adding this edge would create a cycle, making it redundant.</p>
<p>To check if a path exists between two nodes, we can use graph traversal techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS). In this approach, we will use DFS to verify whether the two nodes of each edge are already connected. If you're unfamiliar with DFS, you can explore this helpful <a href="https://leetcode.com/explore/featured/card/graph/">DFS guide</a>.</p>
<p>Now, as we go through the edges, we examine each one. For every edge, we use DFS to determine if the two nodes it connects are already part of the same connected component. If a path already exists, that means the nodes are connected, and we can safely discard the edge because it would create a cycle. If there’s no existing path, we know that the edge is essential for connecting the nodes, so we add it to our graph.</p>
<p>One important thing to remember is that we process the edges in the order they appear in the input list. This ensures that if multiple redundant edges are present, the last one we process will be the one that forms the cycle.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Define the function <code>isConnected</code> that takes the source node <code>src</code>, target node <code>target</code>, boolean array <code>visited</code>, and the adjacency list <code>adjList</code>. This returns true if there's a path between <code>src</code> and <code>target</code> with the edges in the list <code>adjList</code> using DFS:
<ul>
<li>Mark the current node <code>src</code> as visited.</li>
<li>Initialize the variable <code>isFound</code> to <code>false</code>, this is going to denote the answer.</li>
<li>Recursively traverse to the unvisited adjacent nodes and check if the <code>target</code> node is found.</li>
<li>Return <code>isFound</code> in the end.</li>
</ul>
</li>
<li>Iterate over the list <code>edges</code> from left to and right and for each <code>edge</code>:
<ul>
<li>Initialize an empty array <code>visited</code> with all indices as <code>false</code>.</li>
<li>Call the method <code>isConnected</code> and if it returns <code>true</code> return <code>edge</code></li>
<li>Otherwise, add the edge to the adjacency list <code>adjList</code>.</li>
</ul>
</li>
<li>If the input is valid, this part of the code should be unreachable. Return an empty list <code>{}</code> in such cases.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ydw6rbYM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span>.</p>
<p>Iterating over each of the <span class="math inline">\(N\)</span> edges and performing a DFS to check if the nodes are already connected would result in <span class="math inline">\(N \times N\)</span> operations. The time complexity of a DFS is <span class="math inline">\(O(V+E)\)</span>, where <span class="math inline">\(V\)</span> is the number of vertices and <span class="math inline">\(E\)</span> is the number of edges. In this problem, both <span class="math inline">\(V\)</span> and <span class="math inline">\(E\)</span> are equal to <span class="math inline">\(N\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The adjacency list <code>adjList</code> will store <span class="math inline">\(N\)</span> edges, and the size of the <code>visited</code> array is <span class="math inline">\(N\)</span>. Additionally, space is required for the active stack calls in the DFS, which can be as large as one per node. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search---single-traversal">Approach 2: Depth-First Search - Single Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We cannot remove just any edge from the graph, as doing so might disconnect the graph. The edge we remove must be part of the cycle. If we can identify the edges or nodes involved in the cycle, we can choose to remove the edge that appears last in the input edge list.</p>
<p>To detect the cycle in the graph, we need to identify at least one node that belongs to it. This can be accomplished using DFS while keeping track of the parent of each node, where the parent represents the node from which we reached the current node. If we encounter a node that has already been visited and the node we are coming from is different from its parent, we can conclude that the node is part of the cycle.</p>
<p>Once we identify a node in the cycle, we can backtrack through the parent array to find all the other nodes that are part of the cycle, until we return to the starting node. We will mark all these cycle nodes in an unordered map. Then, we iterate over the edges in reverse order, and if both nodes of an edge are marked in the map, we can discard this edge as it forms the cycle. Finally, we can return this redundant edge.</p>
<p><img src="../Figures/684/684A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li>Set <code>cycleStart</code> to <code>-1</code> to mark the start of the cycle.</li>
<li>Create a <code>visited</code> array to keep track of visited nodes.</li>
<li>Create a <code>parent</code> array to store the parent of each node in the DFS traversal.</li>
<li>Initialize an adjacency list <code>adjList</code> to represent the graph.</li>
</ul>
</li>
<li>
<p>Build the Graph:</p>
<ul>
<li>Loop through each edge in the input <code>edges</code> list.</li>
<li>For each edge <code>[u, v]</code>, add <code>v</code> to <code>adjList[u]</code> and <code>u</code> to <code>adjList[v]</code> to make the graph undirected.</li>
</ul>
</li>
<li>
<p>Start a DFS from node <code>0</code> (or any node, as the graph is connected).</p>
<ul>
<li>In the DFS function:
<ul>
<li>Mark the current node as visited.</li>
<li>For each adjacent node, check if it's visited:
<ul>
<li>If not visited, recursively call DFS on the adjacent node, and update its parent.</li>
<li>If the node is visited and its parent is different from the previous one, mark it as <code>cycleStart</code> to identify the cycle.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Track Cycle Nodes:</p>
<ul>
<li>Using the <code>parent</code> array, backtrack from <code>cycleStart</code> to collect all nodes in the cycle.</li>
<li>Store these nodes in the <code>cycleNodes</code> map for quick lookup.</li>
</ul>
</li>
<li>
<p>Identify the Redundant Edge:</p>
<ul>
<li>Iterate through the edges in reverse order.</li>
<li>For each edge, check if both nodes of the edge are in the <code>cycleNodes</code> map:
<ul>
<li>If both nodes are in the cycle, return this edge as the redundant connection.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5URgLFer/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>We perform the DFS starting from node <code>0</code> only once, which has a time complexity of <span class="math inline">\(O(N)\)</span>. Then, we iterate over the cycle nodes using the <code>parent</code> array, with a maximum of <span class="math inline">\(N\)</span> iterations if all nodes are part of the cycle. Finally, we iterate over all edges and check the map in <span class="math inline">\(O(1)\)</span> time for each edge. Therefore, the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The adjacency list <code>adjList</code> will store <span class="math inline">\(N\)</span> edges, and the size of the visited array is <span class="math inline">\(N\)</span>. Additionally, space is required for the active stack calls during DFS, which can be as large as one per node. The map <code>cycleNodes</code> can contain at most <span class="math inline">\(N\)</span> entries. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-dsu">Approach 3: Disjoint Set Union (DSU)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We’re still working with the same core idea as in the first approach: an edge can be discarded if the nodes it connects are already part of the same component. In the previous approach, we used DFS to check if a path existed between the nodes. However, there's an alternative and more efficient way to do this using a data structure called Disjoint Set Union (DSU).</p>
<blockquote>
<p>If you are not familiar with DSU, please go through our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Explore Card</a>. We will not talk about implementation details here and assume you are already familiar with the interface of DSU.</p>
</blockquote>
<p>The idea behind DSU is that each node is in its own a separate set. As we go through the edges, we perform a union operation that merges the sets of the two connected nodes. This helps us track which nodes are in the same component. If, during this process, we encounter an edge where the two nodes are already in the same component (i.e., they share the same representative), we know that adding this edge would create a cycle, so it’s redundant and can be safely discarded.</p>
<p>The great thing about DSU is that it can check whether two nodes are in the same component in nearly constant time, specifically in <span class="math inline">\(O(α(N))\)</span>, where <span class="math inline">\(α(N)\)</span> is the inverse Ackermann function (which grows extremely slowly). This makes DSU much faster than DFS for this type of problems.</p>
<p>In this approach, we treat each node as its own component at the start. As we process each edge, we perform the union operation to merge the components of the two nodes connected by the edge. If the nodes are in different components, we unite them and update their representatives. If the nodes are already in the same component, we’ve found a redundant edge and return it as the result.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Define DSU (Disjoint Set Union):</p>
<ul>
<li>Initialize two arrays:
<ul>
<li><code>size[]</code> to store the size of each component (starts with 1 for each node).</li>
<li><code>representative[]</code> to track the representative (or root) of each component (initially, each node is its own representative).</li>
<li>Find Operation (<code>find</code>):
<ul>
<li>For each node, find its ultimate representative (root of the component).</li>
<li>Path Compression: During the recursive search, update the representative of each visited node to directly point to the root, speeding up future lookups.</li>
</ul>
</li>
<li>Union Operation (<code>doUnion</code>):
<ul>
<li>Check if the two nodes belong to the same component:</li>
<li>If they already share the same representative, they are part of the same component, so adding this edge would form a cycle. Return <code>false</code>.</li>
<li>If the nodes belong to different components, union them:</li>
<li>Attach the smaller component to the larger one (union by size), ensuring the tree remains balanced to minimize depth.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate Through Edges:</p>
<ul>
<li>Process each edge in the list of edges:
<ul>
<li>Convert the 1-based indices from the input to 0-based for array indexing.</li>
<li>Use <code>doUnion</code> to attempt connecting the nodes of the edge.</li>
<li>If <code>doUnion</code> returns <code>false</code>, it means adding this edge would form a cycle, so return the current edge as the redundant edge.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the input is valid, this part of the code should be unreachable. Return an empty list <code>{}</code> in such cases.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/JWuYpx4d/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot \alpha(N))\)</span></p>
<p>We iterate over all edges, and for each edge, we invoke the <code>doUnion</code> function, which has a time complexity of <span class="math inline">\(O(\alpha(N))\)</span>, given that both union by size and path compression are employed. Consequently, the overall time complexity of the algorithm is <span class="math inline">\(O(N \cdot \alpha(N))\)</span>. It is important to note that <span class="math inline">\(\alpha(N)\)</span> represents the inverse Ackermann function, which grows so slowly that it is often considered asymptotically constant, or <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The list <code>representative</code>, used to store the representatives, and the list <code>size</code>, used to store the size of each component, will each contain <span class="math inline">\(N\)</span> entries. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-207">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/redundant-connection-ii/description" target="_blank" rel="noopener noreferrer">Redundant Connection II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>

<p>The given input is a directed graph that started as a rooted tree with <code>n</code> nodes (with distinct values from <code>1</code> to <code>n</code>), with one additional directed edge added. The added edge has two different vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed.</p>

<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u<sub>i</sub>, v<sub>i</sub>]</code> that represents a <b>directed</b> edge connecting nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, where <code>u<sub>i</sub></code> is a parent of child <code>v<sub>i</sub></code>.</p>

<p>Return <em>an edge that can be removed so that the resulting graph is a rooted tree of</em> <code>n</code> <em>nodes</em>. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg" style="width: 222px; height: 382px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
<strong>Output:</strong> [4,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>3 &lt;= n &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Starting from a rooted tree with <code>N-1</code> edges and <code>N</code> vertices, let's enumerate the possibilities for the added &quot;redundant&quot; edge. If there is no loop, then either one vertex must have two parents (or no edge is redundant). If there is a loop, then either one vertex has two parents, or every vertex has one parent.</p>
<p>In the first two cases, there are only two candidates for deleting an edge, and we can try removing the last one and seeing if that works. In the last case, the last edge of the cycle can be removed: for example, when <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>, we want the last edge (by order of occurrence) in the cycle <code>1-&gt;2-&gt;3-&gt;4-&gt;1</code> (but not necessarily <code>1-&gt;5</code>).</p>
<p><strong>Algorithm</strong></p>
<p>We'll first construct the underlying graph, keeping track of edges coming from nodes with multiple parents. After, we either have 2 or 0 <code>candidates</code>.</p>
<p>If there are no candidates, then every vertex has one parent, such as in the case <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>. From any node, we walk towards its parent until we revisit a node - then we must be inside the cycle, and any future seen nodes are part of that cycle.  Now we take the last edge that occurs in the cycle.</p>
<p>Otherwise, we'll see if the graph induced by <code>parent</code> is a rooted tree. We again take the <code>root</code> by walking from any node towards the parent until we can't, then we perform a depth-first search on this <code>root</code>. If we visit every node, then removing the last of the two edge candidates is acceptable, and we should.  Otherwise, we should remove the first of the two edge candidates.</p>
<p>In our solution, we use <code>orbit</code> to find the result upon walking from a node <code>x</code> towards its parent repeatedly until you revisit a node or can't walk anymore.  <code>orbit(x).node</code> (or <code>orbit(x)[0]</code> in Python) will be the resulting node, while <code>orbit(x).seen</code> (or <code>orbit(x)[1]</code>) will be all the nodes visited.</p>
<p><a href="https://leetcode.com/playground/GbE4kZpx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span> where <span class="math inline">\(N\)</span> is the number of vertices (and also the number of edges) in the graph. We perform a depth-first search.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the graph.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-208">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description" target="_blank" rel="noopener noreferrer">Remove Max Number of Edges to Keep Graph Fully Traversable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob have an undirected graph of <code>n</code> nodes and three types of edges:</p>

<ul>
	<li>Type 1: Can be traversed by Alice only.</li>
	<li>Type 2: Can be traversed by Bob only.</li>
	<li>Type 3: Can be traversed by both Alice and Bob.</li>
</ul>

<p>Given an array <code>edges</code> where <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code> represents a bidirectional edge of type <code>type<sub>i</sub></code> between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.</p>

<p>Return <em>the maximum number of edges you can remove, or return</em> <code>-1</code> <em>if Alice and Bob cannot fully traverse the graph.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/ex1.png" style="width: 179px; height: 191px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
<strong>Output:</strong> 2
<strong>Explanation: </strong>If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/ex2.png" style="width: 178px; height: 190px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
<strong>Output:</strong> 0
<strong>Explanation: </strong>Notice that removing any edge will not make the graph fully traversable by Alice and Bob.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/ex3.png" style="width: 178px; height: 190px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
<strong>Output:</strong> -1
<b>Explanation: </b>In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it&#39;s impossible to make the graph fully traversable.</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, 3 * n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>1 &lt;= type<sub>i</sub> &lt;= 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt;= n</code></li>
	<li>All tuples <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-209">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-methods-from-project/description" target="_blank" rel="noopener noreferrer">Remove Methods From Project</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are maintaining a project that has <code>n</code> methods numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given two integers <code>n</code> and <code>k</code>, and a 2D integer array <code>invocations</code>, where <code>invocations[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that method <code>a<sub>i</sub></code> invokes method <code>b<sub>i</sub></code>.</p>

<p>There is a known bug in method <code>k</code>. Method <code>k</code>, along with any method invoked by it, either <strong>directly</strong> or <strong>indirectly</strong>, are considered <strong>suspicious</strong> and we aim to remove them.</p>

<p>A group of methods can only be removed if no method <strong>outside</strong> the group invokes any methods <strong>within</strong> it.</p>

<p>Return an array containing all the remaining methods after removing all the <strong>suspicious</strong> methods. You may return the answer in <em>any order</em>. If it is not possible to remove <strong>all</strong> the suspicious methods, <strong>none</strong> should be removed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, k = 1, invocations = [[1,2],[0,1],[3,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,1,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/18/graph-2.png" style="width: 200px; height: 200px;" /></p>

<p>Method 2 and method 1 are suspicious, but they are directly invoked by methods 3 and 0, which are not suspicious. We return all elements without removing anything.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, k = 0, invocations = [[1,2],[0,2],[0,1],[3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/18/graph-3.png" style="width: 200px; height: 200px;" /></p>

<p>Methods 0, 1, and 2 are suspicious and they are not directly invoked by any other method. We can remove them.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, k = 2, invocations = [[1,2],[0,1],[2,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/20/graph.png" style="width: 200px; height: 200px;" /></p>

<p>All methods are suspicious. We can remove them.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= k &lt;= n - 1</code></li>
	<li><code>0 &lt;= invocations.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>invocations[i] == [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>invocations[i] != invocations[j]</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-210">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description" target="_blank" rel="noopener noreferrer">Reorder Routes to Make All Paths Lead to the City Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.</p>

<p>Roads are represented by <code>connections</code> where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a road from city <code>a<sub>i</sub></code> to city <code>b<sub>i</sub></code>.</p>

<p>This year, there will be a big event in the capital (city <code>0</code>), and many people want to travel to this city.</p>

<p>Your task consists of reorienting some roads such that each city can visit the city <code>0</code>. Return the <strong>minimum</strong> number of edges changed.</p>

<p>It&#39;s <strong>guaranteed</strong> that each city can reach city <code>0</code> after reorder.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png" style="width: 311px; height: 189px;" />
<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>Change the direction of edges show in red such that each node can reach the node 0 (capital).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png" style="width: 509px; height: 79px;" />
<pre>
<strong>Input:</strong> n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
<strong>Output:</strong> 2
<strong>Explanation: </strong>Change the direction of edges show in red such that each node can reach the node 0 (capital).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3, connections = [[1,0],[2,0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>connections.length == n - 1</code></li>
	<li><code>connections[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a tree with <code>n</code> nodes where each node is a city numbered from <code>0</code> to <code>n - 1</code>. The edges are referred to as roads between the cities.</p>
<p>The tree given in the problem has directed edges provided by <code>connections</code>.</p>
<p>We need to return the number of edges that need to be flipped so that from every node, you can somehow reach node <code>0</code>, i.e., there is a path from every node to node <code>0</code>.</p>
<p>Before moving on to the solution, consider some of the graph terminologies that will be used later:</p>
<p><img src="../Figures/1466/1466-1.png" alt="img" /></p>
<ol>
<li><strong>Child</strong>: A node that is one edge further away from a given node in a rooted tree. In the above image, nodes <code>3, 4</code> are children of <code>1</code>, which is called the parent. (When we consider <code>0</code> as the root)</li>
<li><strong>Descendants</strong>: Descendants of a node are children, children of children, and so on. In the above image, nodes <code>3, 4, 6, 7, 9</code> are all descendants of <code>1</code>.</li>
<li><strong>Subtree</strong>: A subtree of a node <code>T</code> is a tree <code>S</code> consisting of a node <code>T</code> and all of its descendants in <code>T</code>. The subtree corresponding to the root node is the entire tree.</li>
</ol>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Because we need to bring everyone to node <code>0</code>, we can model the graph as a tree rooted at node <code>0</code> (the problem statement hints at this by stating that the network forms a tree structure). We can imagine that in order to move from any node to the root, all edges must be directed from a child to its parent. If there is an edge from a parent node to its child node, no node in the subtree of the child can reach the root node. This edge must be flipped.</p>
<p>Let's take a visual example to understand this.</p>
<p><img src="../Figures/1466/1466-2.png" alt="img" /></p>
<p><strong>So, our task is to count the number of edges in a tree rooted at node '0' that are directed from the parent node to a child node.</strong></p>
<p>We must traverse the entire tree to determine the number of such edges that are directed from the parent to the child node. To traverse the tree, we can use a graph traversal algorithm such as depth-first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<p>The caveat is that our edges are directed. To count the number of edges that are directed from a parent to its child node, we must traverse the entire tree. If there is an edge from a child to its parent node, we will be unable to reach the child from the parent.</p>
<p>To traverse the entire tree, we must find a way to get from node <code>0</code> to all of the nodes in any case. This is possible if the edges are treated as undirected. We add an opposite edge from node <code>b</code> to node <code>a</code> for every given edge in <code>connections</code> from node <code>a</code> to node <code>b</code>. Let us refer to the edge we added as an &quot;artificial&quot; edge and the edge present in <code>connections</code> as an &quot;original&quot; edge.</p>
<p>If we use an &quot;artificial&quot; edge to move from the parent node to the child node, we know that the original edge is directed from the child node to the parent node. We don't need to flip the &quot;original&quot; edge.</p>
<p>If we use an &quot;original&quot; edge to move from the parent node to the child node, it means we need to flip this edge. Whenever we encounter such an edge, we will increment our answer variable by <code>1</code>.</p>
<p>We can distinguish between an &quot;original&quot; and an &quot;artificial&quot; edge in many different ways (assigning booleans, specific numbers, etc.). In this article, we will associate an extra value with each edge - <code>1</code> for &quot;original&quot; edges and <code>0</code> for &quot;artificial&quot; edges.</p>
<p>We also set an answer variable <code>count = 0</code> to count the number of edges that must be flipped. Now we start a DFS from node <code>0</code> and work our way down the tree (from parent to child). If we come across an &quot;original&quot; edge during the traversal, that is, an edge labeled with a <code>1</code>, we increase the <code>count</code> by one. We don't modify <code>count</code> if we come across an &quot;artificial&quot; edge. We can combine these two operations and perform <code>count += sign</code> where <code>sign</code> is either <code>0</code> or <code>1</code> indicating an &quot;artificial&quot; or &quot;original&quot; edge.</p>
<p>We have our answer in <code>count</code> at the end of the traversal.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>count</code> to count the number of edges that must be flipped. We initialize it with <code>0</code>.</li>
<li>Create an adjacency list <code>adj</code> that contains a list of pairs of integers such that <code>adj[node]</code> contains all the neighbors of <code>node</code> in the form of <code>(neighbor, sign)</code> where <code>neighbor</code> is the neighboring node of <code>node</code> and <code>sign</code> denotes the direction of the edge i.e., whether its an &quot;original&quot; or &quot;artificial&quot; edge.</li>
<li>Start a DFS traversal.
<ul>
<li>We use a function <code>dfs</code> to perform the traversal. For each call, pass <code>node, parent, adj</code> as the parameters. We start with node <code>0</code> and parent as <code>-1</code>.</li>
<li>Iterate over all the neighbors of the <code>node</code> (nodes that share an edge) using <code>adj[node]</code>. For every <code>neighbor, sign</code> in <code>adj[node]</code>, check if <code>neighbor</code> is equal to <code>parent</code>. If <code>neighbor</code> is equal to <code>parent</code>, we will not visit it again.</li>
<li>If <code>neighbor</code> is not equal to <code>parent</code>, we perform <code>count += sign</code> and recursively call the <code>dfs</code> with <code>node = neighbor</code> and <code>parent = node</code>. At the end of the <code>dfs</code> traversal, we have the total edges that are required to be flipped in <code>count</code>.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ELVVivHQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We need <span class="math inline">\(O(n)\)</span> time to initialize the adjacency list.</li>
<li>The <code>dfs</code> function visits each node once, which takes <span class="math inline">\(O(n)\)</span> time in total. Because we have undirected edges, each edge can only be iterated twice (by nodes at the end), resulting in <span class="math inline">\(O(e)\)</span> operations total while visiting all nodes, where <span class="math inline">\(e\)</span> is the number of edges. Because the given graph is a tree, there are <span class="math inline">\(n - 1\)</span> undirected edges, so <span class="math inline">\(O(n + e) = O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Another method is to use a breadth-first search (BFS) because we only need to find the number of edges that are directed from the parent node to the child node in a rooted tree. This approach is identical to the first one, we are just using BFS instead of DFS to perform the traversal.</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Leetcode Explore Card</a>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an integer variable <code>count</code> to count the number of edges that are to be flipped. We initialize it with <code>0</code>.</li>
<li>Create an adjacency list <code>adj</code> that contains a list of pairs of integers such that <code>adj[node]</code> contains all the neighbors of <code>node</code> in the form of <code>(neighbor, sign)</code> where <code>neighbor</code> is the neighboring node of <code>node</code> and <code>sign</code> denotes the direction of the edge i.e., whether its an &quot;original&quot; or &quot;artificial&quot; edge.</li>
<li>Start a BFS traversal.
<ul>
<li>We use a function <code>bfs</code> to perform the traversal. Pass <code>node, n, adj</code> as the parameters. We start with node <code>0</code>.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>We initialize a queue <code>q</code> of integers and push <code>0</code> into it. We also mark <code>0</code> as visited.</li>
<li>While the queue is not empty, we dequeue the first element <code>node</code> from the queue and iterate over all its neighbors using <code>adj[node]</code>. For each <code>neighbor, sign</code> in <code>adj[node]</code>, we check if <code>neighbor</code> has been visited already. If <code>neighbor</code> has not yet been visited, we mark it visited, perform <code>count += sign</code>, and push <code>neighbor</code> into the queue.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/SLiFjRGY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We need <span class="math inline">\(O(n)\)</span> time to initialize the adjacency list and <span class="math inline">\(O(n)\)</span> to initialize the <code>visit</code> array.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can only be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue, so for an undirected edge, a given edge could be iterated at most twice (by nodes at both ends), resulting in <span class="math inline">\(O(e)\)</span> operations total for all the nodes. As mentioned in the previous approach, <span class="math inline">\(O(e) = O(n)\)</span> since the graph is a tree.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space as well.</li>
<li>The BFS queue takes <span class="math inline">\(O(n)\)</span> space in the worst-case because each node is added once.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-211">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/replace-os-with-xs0052/1" target="_blank" rel="noopener noreferrer">Replace O&#39;s with X&#39;s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix <strong>mat</strong>&nbsp;where every element is either 'O' or 'X'. Replace all 'O' or a group of 'O' with 'X' that are surrounded by 'X'. </span></p>
<p><span style="font-size: 18px;">A 'O' (or a set of 'O') is considered to be surrounded by 'X' if there are 'X' at locations just below, just above, just left and just right of it.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat = <br />[['X', 'X', 'X', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'O', 'O', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Output:</strong> <br />[['X', 'X', 'X', 'X'], <br />['X', 'X', 'X', 'X'], <br />['X', 'X', 'X', 'X'], <br />['X', 'X', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Explanation:</strong> We only changed those 'O' that are surrounded by 'X'</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat = <br />[['X', 'O', 'X', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'O', 'O', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Output:</strong> <br />[['X', 'O', 'X', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'O', 'O', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Explanation:</strong> There's no 'O' that's surround by 'X'.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat = <br />[['X', 'X', 'X'], <br />['X', 'O', 'X'], <br />['X', 'X', 'X']]
<strong>Output:</strong> <br />[['X', 'X', 'X'], <br />['X', 'X', 'X'], <br />['X', 'X', 'X']]
<strong>Explanation:</strong> There's only one 'O' that's surround by 'X'.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 100<br />1 &le; mat[0].size() &le; 100<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-212">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-delete-algorithm-for-minimum-spanning-tree1158/1" target="_blank" rel="noopener noreferrer">Reverse Delete Algorithm for Minimum Spanning Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Reverse Delete algorithm is closely related to Kruskal&rsquo;s algorithm. In Reverse Delete algorithm, we sort all edges in decreasing order of their weights. After sorting, we one by one pick edges in decreasing order. We include current picked edge if excluding current edge causes disconnection in current graph. The main idea is delete edge if its deletion does not lead to disconnection of graph. Your task is to print the value of total weight of Minimum Spanning Tree formed.</span></p>
<p><strong><span style="font-size: 18px;">NOTE: Array elements represent the triplets U , V edge and Weight of that edge. Please read test cases explanation for more details.</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;"><strong>V = </strong>4, <strong>E = </strong>5</span>
<span style="font-size: 18px;"><strong>Arr[] = </strong>{0, 1, 10, 0, 2, 6, 0, 3, 5, 1, 3, 15, 2, 3, 4}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">19</span>
<span style="font-size: 18px;"><strong>Explanation:<br /><br /></strong>Array elements represent the triplets are :</span></pre>
<pre><span>U V Weight<br />0 1  10<br />0 2  6<br />0 3  5<br />1 3  15<br />2 3  4</span></pre>
<pre><span style="font-size: 18px;"></span><span style="font-size: 18px;">The weight of the Minimum Spanning Tree formed is 19.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;"><strong>V = </strong>4, <strong>E = </strong>3</span>
<span style="font-size: 18px;"><strong>Arr[] = </strong>{0, 1, 98, 1, 3, 69, 0, 3, 25}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">192</span>
<span style="font-size: 18px;"><strong>Explanation:<br /></strong></span>
<span style="font-size: 18px;">Array elements represent the triplets are :</span></pre>
<pre><span style="font-size: 18px;">U V Weight<br />0 1  98<br />1 3  69<br />0 3  25<br /><br /></span><span style="font-size: 18px;">The weight of the Minimum Spanning
Tree formed is 192.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>RevDelMST()</strong> which takes 2 Integers V, and E and an array of length 3*E where each triplet consists of two nodes u and v and weight of thir edge w as input and returns the Weight of the Minimum Spanning Tree.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(V*E)<br /><strong>Expected Auxiliary Space:</strong> O(E)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= V,E &lt;= 1000</span><br /><span style="font-size: 18px;">1 &lt;= u,v &lt;= V<br />1 &lt;= w &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-213">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rotten-oranges2536/1" target="_blank" rel="noopener noreferrer">Rotten Oranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix <strong>mat[][]</strong> of dimension <strong>n * m</strong> where each cell in the matrix can have values <strong>0, 1 or 2</strong> which has the following meaning:</span><br /><span style="font-size: 18px;"><strong>0 </strong>: Empty cell </span><br /><span style="font-size: 18px;"><strong>1</strong> : Cell have fresh oranges </span><br /><span style="font-size: 18px;"><strong>2</strong> : Cell have rotten oranges </span></p>
<p><span style="font-size: 18px;">We have to determine what is the earliest time after which all the oranges are rotten. A rotten orange at index (i, j) can rot other fresh orange at indexes (i-1, j), (i+1, j), (i, j-1), (i, j+1) (<strong>up</strong>, <strong>down</strong>, <strong>left</strong> and <strong>right</strong>) in a unit time. </span></p>
<p><strong><span style="font-size: 18px;">Note</span></strong><span style="font-size: 18px;"><strong>:</strong> Your task is to return the minimum time to rot all the fresh oranges. If not possible returns</span><strong><span style="font-size: 18px;"> -1.</span></strong></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[0, 1, 2], [0, 1, 2], [2, 1, 1]]
<strong>Output: </strong>1
<strong>Explanation: </strong>Oranges at positions (0,2), (1,2), (2,0) will rot oranges at (0,1), (1,1), (2,2) and (2,1) in unit time.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[2, 2, 0, 1]]
<strong>Output: </strong>-1
<strong>Explanation: </strong>Oranges at (0,0) and (0,1) can't rot orange at (0,3).</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[2, 2, 2], [0, 2, 0]]
<strong>Output: </strong>0
<strong>Explanation: </strong></span><span style="font-size: 18px;">There is no fresh orange. </span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 500<br /></span><span style="font-size: 18px;">1 &le; mat[0].size() &le; 500<br /></span><span style="font-size: 18px;">mat[i][j] = {0, 1, 2}&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-214">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/santa-banta2814/1" target="_blank" rel="noopener noreferrer">Santa Banta</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">sieve</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Santa is still not married. He approaches a marriage bureau and asks them to hurry the process. The bureau checks the list of eligible girls of size <strong>N</strong> and hands it over to Santa. Santa being conscious about his marriage is determined to find a girl with <strong>maximum</strong> connections so that he can gather more information about her. Accordingly, he looks to figure out the <strong>maximum </strong>number of girls (from the list) who know each other to achieve the above purpose.</span></p>
<p><span style="font-size: 18px;">In order to finalize the girl, he needs to find the <strong>Kth</strong> prime. Where k = largest group of girls who know each other. Considering Santa's poor knowledge of Maths, he seeks Banta's help for the answer. Now you, a fan of Santa Banta Jokes, take this prestigious opportunity to solve the problem.</span></p>
<p><span style="font-size: 18px;">In case no of connections is zero, print "-1". Here the connection between girls is represented by a 2-D array <strong>g </strong>of dimension M*2, where <strong>M</strong> is the number of connections.</span></p>
<p><span style="font-size: 18px;"><strong>Note :</strong><br />1. Suppose girl "a" knows girl "b" and girl "b" knows girl "c", then girl "a" also knows girl "c". <strong>Transitivity</strong> holds here.<br />2. Consider 1 as a <strong>composite</strong> number.<br />3. For precompute function given in the template you just have to complete it and use it wherever required, do not call it again and again, it is already being called by driver function before executing test cases.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input :</strong> <br /></span><span style="font-size: 18px;">N = 10<br />M = 6<br />g[] = {{1,2},{2,3},{3,4},{4,5},{6,7},{9,10}}
<strong>Output :</strong> <br />11
<strong>Explanation:</strong>
Here in this graph there are 4 groups. 
In 1<sup>st</sup> group: (1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5) are 
there. In 2<sup>nd</sup>&nbsp;group: (6 -&gt; 7) are there.
In 3<sup>rd </sup>group: (8) is there.
In 4<sup>th</sup>&nbsp;group: (10 -&gt; 9) are there.
In these 4 group the maximum number of 
value is 5. So, K = 5 and the 5<sup>th</sup>&nbsp;prime number 
is 11. Return 11.
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input :</strong> <br />N = 2<br />M = 1<br />g[] = {{1, 2}} <strong>
Output :</strong> <br />3
<strong>Explanation:
</strong>In this Example there will only be a <br /></span><span style="font-size: 18px;">single </span><span style="font-size: 18px;">group of 2 girls, and hence the <br />value of K is 2, The 2nd prime is 3.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">This is a function problem. The input is already taken care of by the driver code. You only need to complete the function <strong>helpSanta()</strong> that takes a number of girls <strong>(n)</strong>, a number of connections <strong>(m),</strong> a <strong>2-D</strong> <strong>array </strong>of girls connections&nbsp;<strong>(g)</strong>, and return the Kth prime no if there are no connections then return -1. The driver code takes care of the printing.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N + M).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N + M).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1 &le; n &le; 10<sup>5</sup><br />0 &le; m &le; 10<sup>5</sup><br />1 &le; u, v &le; n<br />Sum of n+m will not exceed 10<sup>5</sup>.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-215">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/satisfiability-of-equality-equations/description" target="_blank" rel="noopener noreferrer">Satisfiability of Equality Equations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>equations</code> that represent relationships between variables where each string <code>equations[i]</code> is of length <code>4</code> and takes one of two different forms: <code>&quot;x<sub>i</sub>==y<sub>i</sub>&quot;</code> or <code>&quot;x<sub>i</sub>!=y<sub>i</sub>&quot;</code>.Here, <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> are lowercase letters (not necessarily different) that represent one-letter variable names.</p>

<p>Return <code>true</code><em> if it is possible to assign integers to variable names so as to satisfy all the given equations, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;a==b&quot;,&quot;b!=a&quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.
There is no way to assign the variables to satisfy both equations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;b==a&quot;,&quot;a==b&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> We could assign a = 1 and b = 1 to satisfy both equations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= equations.length &lt;= 500</code></li>
	<li><code>equations[i].length == 4</code></li>
	<li><code>equations[i][0]</code> is a lowercase letter.</li>
	<li><code>equations[i][1]</code> is either <code>&#39;=&#39;</code> or <code>&#39;!&#39;</code>.</li>
	<li><code>equations[i][2]</code> is <code>&#39;=&#39;</code>.</li>
	<li><code>equations[i][3]</code> is a lowercase letter.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-216">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/second-minimum-time-to-reach-destination/description" target="_blank" rel="noopener noreferrer">Second Minimum Time to Reach Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A city is represented as a <strong>bi-directional connected</strong> graph with <code>n</code> vertices where each vertex is labeled from <code>1</code> to <code>n</code> (<strong>inclusive</strong>). The edges in the graph are represented as a 2D integer array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a bi-directional edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by <strong>at most one</strong> edge, and no vertex has an edge to itself. The time taken to traverse any edge is <code>time</code> minutes.</p>

<p>Each vertex has a traffic signal which changes its color from <strong>green</strong> to <strong>red</strong> and vice versa every&nbsp;<code>change</code> minutes. All signals change <strong>at the same time</strong>. You can enter a vertex at <strong>any time</strong>, but can leave a vertex <strong>only when the signal is green</strong>. You <strong>cannot wait </strong>at a vertex if the signal is <strong>green</strong>.</p>

<p>The <strong>second minimum value</strong> is defined as the smallest value<strong> strictly larger </strong>than the minimum value.</p>

<ul>
	<li>For example the second minimum value of <code>[2, 3, 4]</code> is <code>3</code>, and the second minimum value of <code>[2, 2, 4]</code> is <code>4</code>.</li>
</ul>

<p>Given <code>n</code>, <code>edges</code>, <code>time</code>, and <code>change</code>, return <em>the <strong>second minimum time</strong> it will take to go from vertex </em><code>1</code><em> to vertex </em><code>n</code>.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li>You can go through any vertex <strong>any</strong> number of times, <strong>including</strong> <code>1</code> and <code>n</code>.</li>
	<li>You can assume that when the journey <strong>starts</strong>, all signals have just turned <strong>green</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e1.png" style="width: 200px; height: 250px;" /> &emsp; &emsp; &emsp; &emsp;<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e2.png" style="width: 200px; height: 250px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
<strong>Output:</strong> 13
<strong>Explanation:</strong>
The figure on the left shows the given graph.
The blue path in the figure on the right is the minimum time path.
The time taken is:
- Start at 1, time elapsed=0
- 1 -&gt; 4: 3 minutes, time elapsed=3
- 4 -&gt; 5: 3 minutes, time elapsed=6
Hence the minimum time needed is 6 minutes.

The red path shows the path to get the second minimum time.
- Start at 1, time elapsed=0
- 1 -&gt; 3: 3 minutes, time elapsed=3
- 3 -&gt; 4: 3 minutes, time elapsed=6
- Wait at 4 for 4 minutes, time elapsed=10
- 4 -&gt; 5: 3 minutes, time elapsed=13
Hence the second minimum time is 13 minutes.      
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/eg2.png" style="width: 225px; height: 50px;" />
<pre>
<strong>Input:</strong> n = 2, edges = [[1,2]], time = 3, change = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong>
The minimum time path is 1 -&gt; 2 with time = 3 minutes.
The second minimum time path is 1 -&gt; 2 -&gt; 1 -&gt; 2 with time = 11 minutes.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>Each vertex can be reached directly or indirectly from every other vertex.</li>
	<li><code>1 &lt;= time, change &lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<h3 id="overview">Overview</h3>
<p>The problem is to find the second minimum distance (&quot;strictly larger value&quot; than minimum value) in a weighted graph where the traversal over any edge is only possible at certain intervals. The second minimum distance can either come by iterating over some nodes in the path multiple times (as shown in second example of the description) or there could be a longer path than the shortest path with all the nodes occurring just once (as shown in first example of the description).</p>
<h3 id="approach-1-dijkstra">Approach 1: Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>The shortest distance problem in a weighted graph directly leads to thinking about the Dijkstra algorithm. However, the standard Dijkstra does not work here, since we want to find the second minimum distance to reach node <code>n</code>. We may need to modify it a bit to make it work.</p>
<p>Let’s try to recap quickly how the standard Dijkstra looks and the corresponding changes we would need to solve this problem.</p>
<h5 id="standard-dijkstra">Standard Dijkstra</h5>
<ul>
<li>We use an array <code>distance</code> to maintain the shortest distance to each node so far. For any node <code>X</code> except the source node, <code>distance[X]</code> is initialized with infinity. We also maintain a priority queue storing the node and its shortest distance. Whenever any of <code>X</code>'s neighbors is popped out of the priority queue, if the total distance to <code>X</code> via the neighbors is lesser than the <code>distance[X]</code>, <code>distance[X]</code> is updated to the new shortest distance and get pushed into the priority queue.</li>
<li>Whenever a node <code>Y</code> is popped out of the queue, we have the minimum distance for the node <code>Y</code> which cannot be reduced further. If there was a shorter path for <code>Y</code>, it would have been covered before since we use a priority queue in the implementation. We iterate over the neighbors of <code>Y</code> to check if any child could be updated.</li>
</ul>
<h5 id="modified-dijkstra">Modified Dijkstra</h5>
<p>Since we need to find the second minimal distance, an idea is to maintain both the minimal and the second minimal distance.</p>
<ul>
<li>We would use two distance arrays, <code>dist1</code> and <code>dist2</code> to maintain the shortest and second shortest distance (&quot;strictly larger value&quot; than the minimum value) to each node so far. For any node <code>X</code> except the source node, <code>dist1[X]</code> and <code>dist2[X]</code> are initialized with infinity. We would maintain a priority queue storing the node, its shortest distance, and also its second shortest distance. Whenever any of <code>X</code>'s neighbors is popped out of the priority queue, if the total distance to <code>X</code> via the neighbors is less than <code>dist1[X]</code>, <code>dist1[X]</code> is updated and pushed to the queue. Else, we try to update <code>dist2[X]</code> if possible and push it to the priority queue.</li>
<li>Whenever a node <code>Y</code> is popped out of the queue for the first time, we have the minimum distance for the node <code>Y</code> which cannot be reduced further. In this case, we would use <code>dist1[Y]</code> as the distance to reach node <code>Y</code> to compute the total distance of its neighbours. If it pops out a second time, we have the second minimum distance for the node <code>Y</code>. Now, we would use <code>dist2[Y]</code> as the distance to reach node <code>Y</code> to compute the total distance of its neighbours.</li>
</ul>
<h4 id="green-and-red-light-constraint">Green and Red Light Constraint</h4>
<p>In the previous analysis, we discussed how to solve the second minimal distance problem generally with modified Dijkstra. Still, the problem has another part: the constraint on the green and red lights. Let's think about how to handle it.</p>
<p>Under the green and red traffic light constraint, the time it takes to pass the edge is no longer the weight of the edge. We need to be careful when updating the distance in the Dijkstra algorithm.</p>
<p>Please take a look at the image which helps to handle this constraint (<code>c</code> in the figure means the value <code>change</code>):</p>
<p><img src="../Figures/2045/2045-1.png" alt="img" /></p>
<p>There are some observations from the figure. If the current time falls between <code>2 * m * c</code> and <code>2 * m * c + c</code>, where <code>m</code> is any integer, we have a green signal for the node, otherwise, we have a red signal. We can pass the green signal straight way but would have to wait at the red signal till it turns green.</p>
<p>The time taken to go through an edge could be presented as the following code:</p>
<pre><code>// `timeTaken` represent the total time taken to reach the current node,
// and we want to move to its neighbors.
if ((timeTaken / change) % 2) {
    // red light, we need to wait for the next green light
    timeTakenToReachNeighbor = change * (timeTaken / change + 1) + time;
} else {
    // green light, just pass
    timeTakenToReachNeighbor = timeTaken + time;
}
</code></pre>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an adjacency list where <code>adj[X]</code> contains all the neighbors of node <code>X</code>.</li>
<li>Initialize two distance arrays <code>dist1</code> and <code>dist2</code> storing the minimum and the second minimum distance from node <code>1</code> for all the nodes. We would initialize these arrays with large integer values.</li>
<li>Initialize a frequency array <code>freq</code> to store the number of times when a node is popped out of the queue. Since we need the second minimal distance, each node can be poped out at most twice.</li>
<li>Initialize a priority queue storing a <code>{distance, node_id}</code> pair, ordered by the distance. Insert node <code>1</code> with distance <code>0</code> into the queue as <code>{0, 1}</code>.</li>
<li>Perform the Dijkstra until the priority queue is empty.
<ul>
<li>Pop out the top pair of integers, and fetch the node (let's say it is <code>Y</code>) and distance to reach node <code>Y</code>.</li>
<li>Increase <code>freq[Y]</code> by 1.</li>
<li>If <code>Y == n</code> and <code>freq[n] == 2</code>, it means we’ve encountered this node via the second minimum distance. In this case, we return <code>dist2[n]</code>.</li>
<li>Else, iterate over all the neighbors of <code>Y</code>.</li>
<li>For each <code>neighbor</code>, check if <code>dist1[neighbor]</code> could be updated using <code>distance[Y]</code>. If not, check if <code>dist2[neighbor]</code> could be updated.</li>
<li>Push pair <code>{distance_neighbor, neighbor}</code> into the queue whenever <code>dist1[neighbor]</code> or <code>dist2[neighbor]</code> is updated.</li>
</ul>
</li>
<li>If we do not return the answer after the queue is empty, we know that the graph only has one node. Therefore, we just return <code>0</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/eWxFfyDc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of cities and <span class="math inline">\(E\)</span> be the total edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + E \cdot \log N)\)</span>.</p>
<ul>
<li>Our algorithm has twice the complexity as the Dijkstra algorithm. We pop twice and use the node to calculate the minimum and second miimum distance. Since 2 is a constant factor, it actually has the same time complexity as the standard Dijkstra algorithm.</li>
<li>For standard Dijkstra, the maximum number of vertices that could be added to the priority queue is <span class="math inline">\(E\)</span> and each operation takes <span class="math inline">\(O(log E)\)</span> time. Thus, push and pop operations on the priority queue take <span class="math inline">\(O(E \cdot log E)\)</span> time. The value of <span class="math inline">\(E\)</span> can be at most <span class="math inline">\(N \cdot (N−1)\)</span>, so  <span class="math inline">\(O(E \cdot log E) = O(E \cdot log(N^2)) = O(E \cdot log N)\)</span>. It also takes <span class="math inline">\(O(N + E)\)</span> for adjacency list and dist array initializations. Therefore, the total complexity is <span class="math inline">\(O(N+E \cdot log N)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(N + E)\)</span> space. For the Dijkstra algorithm, each vertex is added to the queue at most <span class="math inline">\(N−1\)</span> times, so the space it takes is <span class="math inline">\(N \cdot (N−1) = O(N^2) = O(E)\)</span>. For the distance and frequency arrays, they take <span class="math inline">\(O(N)\)</span> space.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>If you are not much familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">Leetcode Explore Card</a> and have some knowledge of it beforehand.</p>
<p>The given problem involves a city, which is represented as a bi-directionally connected graph with <code>n</code> vertices and some edges. The cost of passing through each edge takes an equal amount of <code>time</code>. We also have some red-to-green signal transitions that happen at the same time, i.e., all signals switch from red to green (and vice-versa) at the same time after every <code>change</code> interval.</p>
<p>Since each edge takes an equal amount of time to cross and the red-signal transitions happen at the same time, we can observe that the time taken for any equal-length path in terms of steps taken would be similar. This is because we would be taking <code>time</code> to cross each edge and would also be waiting at the red signals at the same time.</p>
<p>Let's use an example to understand this more. If we start at the time <code>T = 0</code> from node <code>1</code>, we can reach any node one edge away at <code>T = time</code>. Let's assume we've got a green signal now. We would cross another edge to reach any node two edges away at <code>T = 2 * time</code>. Suppose, we have a red signal now and it takes <code>c</code> time to switch back to green. We would start moving from the current node at <code>T = 2 * time + c</code> and reach any node three edges away at <code>T = 3 * time + c</code>. We cannot reach nodes at level three earlier than <code>3 * time + c</code>. If we take the longer route, it will undoubtedly take more time.</p>
<p>This shows that the shortest length path in terms of steps would be the ideal path to compute the minimum time to reach node <code>n</code> and the second shortest length path would be the ideal path to compute the second minimum time. In this case, all the weight is <code>1</code> so the graph is unweighted. Therefore, we only need to focus on the number of steps to reach the target node instead of time. Hence, Dijkstra was overkill.</p>
<p>As we know, the path used in BFS traversal always has the least number of edges. The BFS algorithm does a level-wise iteration of the graph. As a result, it first finds all paths that are one edge away from the source node, followed by all paths that are two edges away from the source node, and so on. This allows BFS to find the shortest path in terms of steps from the source node to any other node. The time spent at red light crossings will be calculated in the same way as in the first approach. We will use this concept to solve the problem.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an adjacency list where <code>adj[X]</code> contains all the neighbors of node <code>X</code>.</li>
<li>Initialise two distance arrays <code>dist1</code> and <code>dist2</code> storing the minimum and second minimum distance from node 1 for all the nodes. We would initialize these arrays with <code>-1</code>.</li>
<li>Initialize a queue with a pair of integers <code>(node, freq)</code> and insert  <code>{1, 1}</code> where the first integer denotes the node and the second denotes the frequency of the visit.</li>
<li>Pop out the front pair from the queue and iterate over the neighbors of the node updating the <code>dist1</code> and <code>dist2</code> accordingly (as we did above).</li>
<li>If <code>dist1[child] = -1</code>, it means this is the first time we are visiting this node, so update the <code>dist1[child]</code>. This is the minimum distance of the node <code>child</code>. Else, check similarly for <code>dist2[child]</code> to compute the second minimum distance and ensure it is not equal to <code>dist1[child]</code>.</li>
</ol>
<blockquote>
<p>The important point to learn here is that this approach works only because the graph is equally weighted for all edges.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YgLQPMf5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of cities and <span class="math inline">\(E\)</span> be the total edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>The complexity would be similar to the standard BFS algorithm since we’re iterating at most twice over a node.</li>
<li>For the BFS algorithm, each single queue operation takes <span class="math inline">\(O(1)\)</span>, and a single node could be pushed at most once leading <span class="math inline">\(O(N)\)</span> operations. For each node popped out of the queue we iterate over all its neighbors, so for an undirected edge, a given edge could be iterated at most twice (by nodes at the end) which leads to <span class="math inline">\(O(E)\)</span> operations in total for all the nodes and a total <span class="math inline">\(O(N + E)\)</span> time complexity.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(E)\)</span> space. The BFS queue takes <span class="math inline">\(O(N)\)</span> because each vertex is added at most once. The other distance arrays take <span class="math inline">\(O(N)\)</span> space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-217">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-cycle-in-a-graph/description" target="_blank" rel="noopener noreferrer">Shortest Cycle in a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>bi-directional </strong>graph with <code>n</code> vertices, where each vertex is labeled from <code>0</code> to <code>n - 1</code>. The edges in the graph are represented by a given 2D integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes an edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.</p>

<p>Return <em>the length of the <strong>shortest </strong>cycle in the graph</em>. If no cycle exists, return <code>-1</code>.</p>

<p>A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/04/cropped.png" style="width: 387px; height: 331px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The cycle with the smallest length is : 0 -&gt; 1 -&gt; 2 -&gt; 0 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png" style="width: 307px; height: 307px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[0,2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no cycles in this graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>1 &lt;= edges.length &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-218">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-distance-after-road-addition-queries-i/description" target="_blank" rel="noopener noreferrer">Shortest Distance After Road Addition Queries I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and a 2D integer array <code>queries</code>.</p>

<p>There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code>. Initially, there is a <strong>unidirectional</strong> road from city <code>i</code> to city <code>i + 1</code> for all <code>0 &lt;= i &lt; n - 1</code>.</p>

<p><code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> represents the addition of a new <strong>unidirectional</strong> road from city <code>u<sub>i</sub></code> to city <code>v<sub>i</sub></code>. After each query, you need to find the <strong>length</strong> of the <strong>shortest path</strong> from city <code>0</code> to city <code>n - 1</code>.</p>

<p>Return an array <code>answer</code> where for each <code>i</code> in the range <code>[0, queries.length - 1]</code>, <code>answer[i]</code> is the <em>length of the shortest path</em> from city <code>0</code> to city <code>n - 1</code> after processing the <strong>first </strong><code>i + 1</code> queries.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, queries = [[2,4],[0,2],[0,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,1]</span></p>

<p><strong>Explanation: </strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg" style="width: 350px; height: 60px;" /></p>

<p>After the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg" style="width: 350px; height: 60px;" /></p>

<p>After the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg" style="width: 350px; height: 96px;" /></p>

<p>After the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, queries = [[0,3],[0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg" style="width: 300px; height: 70px;" /></p>

<p>After the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg" style="width: 300px; height: 70px;" /></p>

<p>After the addition of the road from 0 to 2, the length of the shortest path remains 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= queries.length &lt;= 500</code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= queries[i][0] &lt; queries[i][1] &lt; n</code></li>
	<li><code>1 &lt; queries[i][1] - queries[i][0]</code></li>
	<li>There are no repeated roads among the queries.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>According to the problem statement:</p>
<ul>
<li>There are <span class="math inline">\(n\)</span> cities, numbered from <span class="math inline">\(0\)</span> to <span class="math inline">\(n-1\)</span>.</li>
<li>Initially, each pair of consecutive cities is connected by a one-way road.
<ul>
<li>Formally, for each <span class="math inline">\(i\)</span> where <span class="math inline">\(0 \leq i \leq n-2\)</span>, there exists a directed and unweighted edge from city <span class="math inline">\(i\)</span> to city <span class="math inline">\(i+1\)</span>.</li>
</ul>
</li>
</ul>
<p>Additionally, we are given an array of length <span class="math inline">\(q\)</span>, called <span class="math inline">\(queries\)</span>, where each element represents a new road to be added:</p>
<ul>
<li>Each element in <span class="math inline">\(queries\)</span> is defined as <span class="math inline">\(\text{queries}[i] = [u_i, v_i]\)</span>, where:
<ul>
<li><span class="math inline">\(u_i\)</span> and <span class="math inline">\(v_i\)</span> are the cities between which a new directed and unweighted road will be added at step <span class="math inline">\(i\)</span>.</li>
<li>It is guaranteed that <span class="math inline">\(u_i < v_i\)</span>.</li>
</ul>
</li>
</ul>
<p>After adding each road in <span class="math inline">\(queries\)</span>, we have to determine the length of the shortest path between city <span class="math inline">\(0\)</span> and city <span class="math inline">\(n-1\)</span>. Then we will return the result as an array of length <span class="math inline">\(q\)</span>, where each element corresponds to the shortest path length after each step.</p>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem statement naturally suggests a graphical representation, where cities are modeled as nodes and the roads connecting them are represented as edges. This transforms our task into a well-known graph problem: finding the shortest path between two nodes.</p>
<p>However, there's an important distinction: our graph is dynamic, with new edges added at each step. A logical approach is to update the graph with each new road and apply a path-finding algorithm at each step to find the shortest path.</p>
<p>To select the appropriate algorithm, we need to consider the properties of our graph. One notable characteristic is that the edges are unweighted. This implies that the total cost of a path is equivalent to the number of steps taken to reach the destination, or, in other words, the number of layers of nodes that must be explored.</p>
<p>This understanding leads us to implement the <a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/">Breadth-First Search (BFS)</a> algorithm, which is particularly suited for this type of problem.</p>
<p>!?!../Documents/3243/3243_Approach1.json:960,540!?!</p>
<p>If you need a refresher on how BFS works, you can refer to the classic problem <a href="https://leetcode.com/problems/rotting-oranges/description">994. Rotting Oranges</a>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define a helper function <code>bfs</code> that, given the number of nodes <code>n</code> and the graph's adjacency list <code>adjList</code>, returns the number of edges in the shortest path between node <code>0</code> and node <code>n - 1</code>.</p>
<ul>
<li>Initialize a boolean array <code>visited</code> to mark the processed nodes.</li>
<li>Initialize a queue <code>nodeQueue</code>.</li>
<li>Push node <code>0</code> into the queue and mark it as visited.</li>
<li>Initialize a variable <code>currentLayerNodeCount</code> to <code>1</code> (since node <code>0</code> is already in the queue), <code>nextLayerNodeCount</code> to <code>0</code>, and <code>layersExplored</code> to <code>0</code>.</li>
<li>Perform BFS until the queue is empty:
<ul>
<li>Iterate over the nodes in the current layer, with <code>i</code> ranging from <code>0</code> to <code>currentLayerNodeCount - 1</code>:
<ul>
<li>Pop the first node, called <code>currentNode</code>, from the queue and check whether it is the target node (<code>n - 1</code>).
<ul>
<li>If the condition is true, return <code>layersExplored</code>.</li>
</ul>
</li>
<li>For every <code>neighbor</code> in <code>adjList[currentNode]</code>:
<ul>
<li>If <code>neighbor</code> has already been visited, continue.</li>
<li>Otherwise:
<ul>
<li>Push <code>neighbor</code> into the queue.</li>
<li>Increment <code>nextLayerNodeCount</code> by <code>1</code>.</li>
<li>Mark <code>neighbor</code> as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>When the loop is over and all nodes in the current layer are processed:
<ul>
<li>Set <code>currentLayerNodeCount = nextLayerNodeCount</code>.</li>
<li>Set <code>nextLayerNodeCount = 0</code>.</li>
<li>Increment <code>layersExplored</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Since the initial constraint that every two consecutive nodes are connected guarantees that there is always a path between node <code>0</code> and node <code>n - 1</code>, the algorithm will never exit the BFS loop without having found and returned the shortest path length. Here, simply return a random value, e.g., <code>-1</code>.</li>
</ul>
</li>
<li>
<p>In the main function <code>shortestDistanceAfterQueries</code>:</p>
<ul>
<li>Initialize the result array <code>answer</code>.</li>
<li>Initialize a 2D array <code>adjList</code>.</li>
<li>Iterate over the first <code>n - 1</code> nodes with <code>i</code> ranging from <code>0</code> to <code>n - 2</code>:
<ul>
<li>Push <code>i + 1</code> to <code>adjList[i]</code>.</li>
</ul>
</li>
<li>Enter a new loop to process each query <code>query[i] = [u, v]</code>:
<ul>
<li>Push <code>v</code> to <code>adjList[u]</code>.</li>
<li>Run <code>bfs</code> and push the result to the <code>answer</code> array.</li>
</ul>
</li>
<li>Finally, return <code>answer</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/SYe9kez7/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of cities and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n + q))\)</span>.</p>
<p>At first glance, the <code>bfs</code> function appears to contain three nested loops, which might suggest a time complexity of <span class="math inline">\(O(n^3)\)</span>. However, this is misleading. A closer look shows that each part of the BFS algorithm runs in relation to the nodes and edges in the graph after each road (edge) addition.</p>
<ul>
<li>Node Processing (first inner loop): Each node is added to and removed from the queue exactly once, giving a time complexity of <span class="math inline">\(O(n)\)</span> for processing all nodes.</li>
<li>Edge Exploration (second inner loop): For each dequeued node, the algorithm checks all its neighbors. Each edge is examined only once, so the total time for edge exploration is <span class="math inline">\(O(e)\)</span>, where <span class="math inline">\(e\)</span> is the number of edges in the graph.</li>
</ul>
<p>Combining these, the time complexity of each BFS run is <span class="math inline">\(O(n + e)\)</span>.</p>
<ul>
<li>Layer-wise Node Processing (outer loop): The outer loop runs based on the number of graph layers rather than the number of nodes, ensuring the BFS explores nodes systematically. This does not increase the overall complexity, which remains <span class="math inline">\(O(n + e)\)</span>.</li>
</ul>
<p>Each BFS after adding a road incrementally increases the edge count. The time complexity across all <span class="math inline">\(q\)</span> queries is thus:</p>
<ol>
<li>After the 1st road: <span class="math inline">\(O(n + n)\)</span>.</li>
<li>After the 2nd road: <span class="math inline">\(O(n + n + 1)\)</span>.</li>
<li>…</li>
<li>After the <span class="math inline">\(q\)</span>-th road: <span class="math inline">\(O(n + n + q - 1)\)</span>.</li>
</ol>
<p>Summing these yields:</p>
<p><span class="math display">\[\begin{aligned}
    O(n + n) + O(n + n + 1) + \dots + O(n + n + q - 1) \\
    = O(2qn + \frac{q(q-1)}{2}) \\
    = O(q \times (n + q))
\end{aligned}
\]</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n+q)\)</span>.</p>
<p>To represent our graph, we create and continuously update its adjacency list in the form of a 2D array. Initially, this array contains <span class="math inline">\(n-1\)</span> elements, representing the edges between every two consecutive nodes. After processing all queries, the array will contain <span class="math inline">\(n + q - 1\)</span> elements, contributing <span class="math inline">\(O(n + q)\)</span> to the total space complexity.</p>
<p>In addition to the adjacency list, the <code>bfs</code> function creates a 1D array, named <code>visited</code> and a queue, called <code>nodeQueue</code>, both of which can have a maximum size of <span class="math inline">\(n\)</span>.</p>
<p>Therefore, the overall space complexity remains <span class="math inline">\(O(n+q)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursive-dynamic-programming-top-down">Approach 2: Recursive Dynamic Programming (Top-Down)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Upon closer examination of the graph, we can determine that it is a Directed Acyclic Graph (DAG). This means:</p>
<ul>
<li>
<p>Directed Edges: Each road in the graph has a specific direction (is unidirectional).</p>
</li>
<li>
<p>No Cycles: A key characteristic of a DAG is that it does not contain any cycles. In this graph, every road's destination node has a value greater than that of its source node. This property ensures that it is impossible to return to a starting node by following the directed edges.</p>
</li>
</ul>
<p>Using the language of the problem, we can say that for every node <span class="math inline">\(v_i\)</span>, the distance to the final node <span class="math inline">\(v_{n-1}\)</span> only depends on two factors:</p>
<ul>
<li>The distance from <span class="math inline">\(v_i\)</span> to the subsequent nodes <span class="math inline">\(v_{i+1}\)</span>, <span class="math inline">\(v_{i+2}\)</span>, ..., <span class="math inline">\(v_{n-1}\)</span>.</li>
<li>The distance from the subsequent nodes <span class="math inline">\(v_{i+1}\)</span>, <span class="math inline">\(v_{i+2}\)</span>, ..., <span class="math inline">\(v_{n-1}\)</span> to the final node <span class="math inline">\(v_{n-1}\)</span>.</li>
</ul>
<p>Specifically the relationship can be expressed as, <span class="math inline">\(distance_{v_i, v_{n-1}} = \min_{j} (distance_{v_i, v_j}+ distance_{v_j, v_{n-1}})\)</span>.</p>
<p>In our calculations, we notice that some states overlap, meaning they are needed in various computations but are independent of one another. This characteristic indicates that dynamic programming could help us solve this problem efficiently.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Define a recursive function <code>findMinDistance</code> that, given the number of nodes <code>n</code>, the graph's adjacency list <code>adjList</code>, the memoization array <code>dp</code>, and the node <code>currentNode</code>, returns the number of edges in the shortest path from node <code>currentNode</code> to node <code>n - 1</code>.</p>
<ul>
<li>Base case: if <code>currentNode == n - 1</code>, return <code>0</code>.</li>
<li>Computed case: if <code>dp[currentNode] != -1</code>, return <code>dp[currentNode]</code>.</li>
<li>Initialize a variable <code>minDistance</code> to <code>n</code>.</li>
<li>For every <code>neighbor</code> of <code>currentNode</code>:
<ul>
<li>Set <code>minDistace = min(minDistance, 1 + findMinDistance(..., neighbor))</code>.</li>
</ul>
</li>
<li>Store the computed <code>minDistance</code>; set <code>dp[currentNode] = minDistance</code>.</li>
<li>Return <code>minDistance</code>.</li>
</ul>
</li>
<li>
<p>In the main function <code>shortestDistanceAfterQueries</code>:</p>
<ul>
<li>Initialize an empty result array <code>answer</code>.</li>
<li>Initialize a memoization array <code>dp</code> of size <code>n</code>. Initially set all <code>dp</code> values to <code>-1</code>.</li>
<li>Initialize a 2D array <code>adjList</code> to represent the graph.</li>
<li>Iterate over the first <code>n - 1</code> nodes, with <code>i</code> ranging from <code>0</code> to <code>n - 2</code>:
<ul>
<li>Add <code>i+1</code> to <code>adjList[i]</code> to create initial consecutive edges.</li>
</ul>
</li>
<li>Process each query <code>query[i] = [u, v]</code> in a loop:
<ul>
<li>Add <code>v</code> to <code>adjList[u]</code> to represent the new edge.</li>
<li>Run <code>findMinDistance</code> for node <code>0</code> and append the result to the <code>answer</code> array.</li>
<li>Reset all values in the <code>dp</code> array to <code>-1</code>.</li>
</ul>
</li>
<li>Finally, return <code>answer</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/35b7NhLC/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of cities and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n+q))\)</span>.</p>
</li>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n+q))\)</span>.</p>
<p>The <code>findMinDistance</code> function is called on the starting node (node <code>0</code>) each time a query is processed. If the distance for a node is already computed, the function returns the cached value from the <code>dp</code> array, avoiding redundant calculations.</p>
<p>During its first call for node <code>0</code>, <code>findMinDistance</code> explores all neighbors, iterating over all outgoing edges. Each node is processed only once for distance calculation due to caching in the <code>dp</code> array.</p>
<p>The time complexity of a single <code>findMinDistance</code> call on node <code>0</code> is <span class="math inline">\(O(e)\)</span>, where <span class="math inline">\(e\)</span> represents the current number of edges in the graph. Since each edge is visited exactly once, the computation scales linearly with the number of edges.</p>
<p>Thus, the total time complexity sums to:</p>
<p><span class="math display">\[\begin{aligned}
    O(n) +  O(n+1) + \ldots +  O(n+q-1) \\
    = O(q \times (n+q))
\end{aligned}
\]</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n+q)\)</span>.</p>
<p>Once again, we choose to represent our graph using an adjacency list, the maximum size of which is <span class="math inline">\(O(n + q)\)</span>. Additionally, we create a 1D memoization array, called <code>dp</code>, with a fixed size of <span class="math inline">\(n\)</span> and we also invoke a recursive function <code>findMinDistance</code>, whose depth is <span class="math inline">\(O(n)\)</span>, as well. Combining the above, we conclude that the total space complexity is <span class="math inline">\(O(n+q)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterative-dynamic-programming-bottom-up">Approach 3: Iterative Dynamic Programming (Bottom-Up)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>While the top-down dynamic programming approach is often intuitive, it can become less effective in certain situations, particularly due to uncontrolled recursion depth. This is especially true for larger input sizes, where deep recursion can lead to stack overflow errors. To avoid this risk, it is generally considered a good idea to convert recursive dynamic programming solutions into iterative ones.</p>
<p>In an iterative approach, we essentially take each line from the previous recursive algorithm and translate it into its iterative equivalent. A key consideration in this translation is that when we compute <code>dp[u]</code>, it represents the result of the <code>findMinDistance</code> function for node <code>u</code>. Thus, both the return value and the runtime complexity of <code>findMinDistance(u)</code> can be directly replaced with <code>dp[u]</code>.</p>
<p>To implement the iterative approach effectively, we need to recognize the relationship between the calls in the recursive function. We begin our computation at the base case, which occurs when <code>currentNode</code> equals <code>n - 1</code>, and work our way up to <code>currentNode = 0</code>. This means that our bottom-up approach should process nodes in reverse order, starting from <code>currentNode = n - 1</code> and building our results incrementally until we reach <code>currentNode = 0</code>. By doing so, we ensure that all necessary values are calculated before they are needed.</p>
<p>!?!../Documents/3243/3243_Approach3.json:960,540!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define a function <code>findMinDistance</code> that, given the number of nodes <code>n</code> and the graph's adjacency list <code>adjList</code>, returns the number of edges in the shortest path from node <code>0</code> to node <code>n - 1</code>.</p>
<ul>
<li>Initialize a 1D array of size <code>n</code>, called <code>dp</code>.</li>
<li>Base case: set <code>dp[n-1] = 0</code>.</li>
<li>Iterate over the first <code>n - 1</code> nodes in reversed order, with <code>currentNode</code> from <code>n - 2</code> to <code>0</code>. On each iteration:
<ul>
<li>Initialize <code>minDistance</code> to <code>n</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:
<ul>
<li>Set <code>minDistance = min(minDistance, dp[neighbor] + 1)</code>.</li>
</ul>
</li>
<li>After exiting the inner loop, set <code>dp[currentNode] = minDistance</code>.</li>
</ul>
</li>
<li>Return <code>dp[0]</code>.</li>
</ul>
</li>
<li>
<p>In the main function <code>shortestDistanceAfterQueries</code>:</p>
<ul>
<li>Initialize an empty result array <code>answer</code>.</li>
<li>Initialize a 2D array <code>adjList</code> to represent the graph.</li>
<li>Iterate over the first <code>n-1</code> nodes, with <code>i</code> ranging from <code>0</code> to <code>n-2</code>:
<ul>
<li>Add <code>i+1</code> to <code>adjList[i]</code> to create initial consecutive edges.</li>
</ul>
</li>
<li>Process each query <code>query[i] = [u, v]</code> in a loop:
<ul>
<li>Add <code>v</code> to <code>adjList[u]</code> to represent the new edge.</li>
<li>Run <code>findMinDistance</code> and append the result to the <code>answer</code> array.</li>
</ul>
</li>
<li>Finally, return <code>answer</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/oRhhY73r/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of cities and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n+q))\)</span>.</p>
<p>The <code>findMinDistance</code> function iterates over each edge exactly once, so its time complexity for a graph with <span class="math inline">\(e\)</span> edges is <span class="math inline">\(O(e)\)</span>.</p>
<p>Therefore, like the previous approaches, the total time complexity of the algorithm can be expressed as:</p>
<p><span class="math display">\[\begin{aligned}
    O(n) +  O(n+1) + ... +  O(n+q-1) = \\
    O(q \times (n+q)).
\end{aligned}
\]</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n+q)\)</span>.</p>
<p>The total space complexity is once again determined by the size of the adjacency list which is at most <span class="math inline">\(O(n+q)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-219">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-distance-after-road-addition-queries-ii/description" target="_blank" rel="noopener noreferrer">Shortest Distance After Road Addition Queries II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">ordered set</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and a 2D integer array <code>queries</code>.</p>

<p>There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code>. Initially, there is a <strong>unidirectional</strong> road from city <code>i</code> to city <code>i + 1</code> for all <code>0 &lt;= i &lt; n - 1</code>.</p>

<p><code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> represents the addition of a new <strong>unidirectional</strong> road from city <code>u<sub>i</sub></code> to city <code>v<sub>i</sub></code>. After each query, you need to find the <strong>length</strong> of the <strong>shortest path</strong> from city <code>0</code> to city <code>n - 1</code>.</p>

<p>There are no two queries such that <code>queries[i][0] &lt; queries[j][0] &lt; queries[i][1] &lt; queries[j][1]</code>.</p>

<p>Return an array <code>answer</code> where for each <code>i</code> in the range <code>[0, queries.length - 1]</code>, <code>answer[i]</code> is the <em>length of the shortest path</em> from city <code>0</code> to city <code>n - 1</code> after processing the <strong>first </strong><code>i + 1</code> queries.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, queries = [[2,4],[0,2],[0,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,1]</span></p>

<p><strong>Explanation: </strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg" style="width: 350px; height: 60px;" /></p>

<p>After the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg" style="width: 350px; height: 60px;" /></p>

<p>After the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg" style="width: 350px; height: 96px;" /></p>

<p>After the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, queries = [[0,3],[0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg" style="width: 300px; height: 70px;" /></p>

<p>After the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg" style="width: 300px; height: 70px;" /></p>

<p>After the addition of the road from 0 to 2, the length of the shortest path remains 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= queries[i][0] &lt; queries[i][1] &lt; n</code></li>
	<li><code>1 &lt; queries[i][1] - queries[i][0]</code></li>
	<li>There are no repeated roads among the queries.</li>
	<li>There are no two queries such that <code>i != j</code> and <code>queries[i][0] &lt; queries[j][0] &lt; queries[i][1] &lt; queries[j][1]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-220">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1" target="_blank" rel="noopener noreferrer">Shortest Distance in a Binary Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>n * m</strong>&nbsp;matrix <strong>grid</strong> where each element can either be <strong>0</strong> or <strong>1</strong>. You&nbsp;need to find the shortest distance&nbsp;between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1.&nbsp;</span></p>
<p><span style="font-size: 18px;">If the path is not possible between source cell and destination cell, then return <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note :&nbsp;</strong>You can move into an adjacent cell if that adjacent cell is filled with element 1. Two cells are adjacent if they share a side. In other words, you can move in one of the four directions, Up, Down, Left and Right. The source and destination cell are based on the zero based indexing. The destination cell should be 1.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">grid[][] = {{1, 1, 1, 1},
            {1, 1, 0, 1},
            {1, 1, 1, 1},
            {1, 1, 0, 0},
            {1, 0, 0, 1}}</span>
<span style="font-size: 18px;">source = {0, 1}</span>
<span style="font-size: 18px;">destination = {2, 2}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">1 <strong>1</strong> 1 1
1 <strong>1</strong> 0 1
1 <strong>1</strong> <strong>1</strong> 1
1 1 0 0
1 0 0 1
The highlighted part in the matrix denotes the 
shortest path from source to destination cell.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">grid[][] = {{1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0},
            {1, 0, 1, 0, 1}}</span>
<span style="font-size: 18px;">source = {0, 0}</span>
<span style="font-size: 18px;">destination = {3, 4}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">-1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">The path is not possible between source and</span>&nbsp;
<span style="font-size: 18px;">destination, hence return -1.</span>
</pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">You don't need to read or print anything. Your task is to complete the function <strong>shortestPath()&nbsp;</strong>which takes the a 2D integer array&nbsp;<strong>grid</strong>, <strong>source</strong> cell and <strong>destination</strong> cell&nbsp;as an input parameters and returns the shortest distance between source and destination cell.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n * m)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(n * m)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &le; n, m &le; 500</span></li>
<li><span style="font-size: 18px;">grid[i][j] == 0 or grid[i][j] == 1</span></li>
<li><span style="font-size: 18px;">The source and destination cells are always inside the given matrix.</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-221">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-from-1-to-n0156/1" target="_blank" rel="noopener noreferrer">Shortest path from 1 to n</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">mathematical</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Consider a <strong>directed graph </strong>whose vertices are numbered from <strong>1</strong> <strong>to n</strong>. There is an edge from a vertex <strong>i</strong> to a vertex <strong>j</strong> if and only if either <strong>j = i + 1 or j = 3 * i</strong>. The task is to find the <strong>minimum </strong>number of edges in a path from vertex <strong>1</strong> to vertex <strong>n</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 9
<strong>Output: </strong>2
<strong>Explanation</strong>: Many paths are possible from 1 to 9. Shortest one possible is, 1 -&gt; 3 -&gt; 9, of length 2.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: n = 4
<strong>Output: </strong>2
<strong>Explanation</strong>: Possible paths from 1 to 4 are, 1 -&gt; 2 -&gt; 3 -&gt; 4 and 1 -&gt; 3 -&gt; 4. Second path of length 2 is the shortest.<br /></span></pre>
<pre><span><strong>Input</strong>: n = 15
<strong>Output: </strong>4</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-222">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph/1" target="_blank" rel="noopener noreferrer">Shortest path in Directed Acyclic Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Directed Acyclic Graph of V vertices from 0 to n-1 and a 2D Integer array(or vector) edges[ ][ ] of length E, where there is a directed edge from edge[i][0] to edge[i][1] with a distance of edge[i][2] for all i.</span></p>
<p><span style="font-size: 18px;">Find the <strong>shortest</strong> path from <strong>src(0) </strong>vertex&nbsp;to all the vertices&nbsp;and if it is impossible to reach any vertex, then return&nbsp;<strong>-1</strong> for that vertex.</span></p>
<p><strong><span style="font-size: 18px;">Examples :<br /></span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, E = 2, edges = [[0,1,2], [0,2,1]]
<strong>Output: </strong>[0, 2, 1, -1]<br /></span><strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">Shortest path from 0 to 1 is 0-&gt;1 with edge weight 2.</span><span style="font-size: 18px;"> Shortest path from 0 to 2 is 0-&gt;2 with edge weight 1. There is no way we can reach 3, so it's -1 for 3.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 6, E = 7, edges = [[0,1,2], [0,4,1], [4,5,4], [4,2,2], [1,2,3], [2,3,6], [5,3,1]]
<strong>Output: </strong>[0, 2, 3, 6, 1, 5]<br /></span><strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">Shortest path from 0 to 1 is 0-&gt;1 with edge weight 2.</span><span style="font-size: 18px;"> Shortest path from 0 to 2 is 0-&gt;4-&gt;2 with edge weight 1+2=3. Shortest path from 0 to 3 is 0-&gt;4-&gt;5-&gt;3 with edge weight 1+4+1=6. Shortest path from 0 to 4 is 0-&gt;4 with edge weight 1.Shortest path from 0 to 5 is 0-&gt;4-&gt;5 with edge weight 1+4=5.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraint:<br /></strong></span><span style="font-size: 18px;">1 &lt;= V &lt;= 100<br />1 &lt;= E &lt;= min((N*(N-1))/2,4000)<br /></span><span style="font-size: 18px;">0 &lt;= edges<sub>i,0</sub>, edges<sub>i,1</sub>&nbsp;&lt;&nbsp;n<br />0 &lt;=&nbsp;</span><span style="font-size: 18px;">edge</span><sub>i,2</sub><span style="font-size: 18px;">&nbsp;&lt;=10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-223">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph-having-unit-distance/1" target="_blank" rel="noopener noreferrer">Shortest Path in Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an adjacency list, <strong>adj&nbsp;</strong>of <strong>Undirected Graph</strong> having <strong>unit weight </strong>of the edges, find the shortest path<strong> </strong>from<strong> src </strong>to all the vertex and if it is <strong>unreachable</strong> to reach any vertex, then return<strong> -1</strong> for that vertex.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>adj[][] = [[1, 3], [0, 2], [1, 6], [0, 4], [3, 5], [4, 6], [2, 5, 7, 8], [6, 8], [7, 6]], src=0
<strong>Output: </strong>[0, 1, 2, 1, 2, 3, 3, 4, 4]<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711976/Web/Other/blobid0_1745302423.jpg" width="249" height="220" /></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>adj[][]= [[3], [3], [], [0, 1]], src=3
<strong>Output: </strong>[1, 1, -1, 0]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711976/Web/Other/blobid0_1747111194.webp" width="207" height="195" /><br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>adj[][]= [[], [], [], [4], [3], [], []], src=1
<strong>Output: </strong>[-1, 0, -1, -1, -1, -1, -1] </span></pre>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br />1&lt;=adj.size()&lt;=10<sup>4</sup><br />0&lt;=edges&lt;=</span><span style="font-size: 18px;">adj.size()</span><span style="font-size: 18px;">-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-224">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-weighted-undirected-graph/1" target="_blank" rel="noopener noreferrer">Shortest Path in Weighted undirected graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a weighted undirected graph having <strong>n</strong> vertices numbered from <strong>1 to n</strong> and <strong>m</strong> edges along with their weights. Find the <strong>shortest&nbsp;</strong></span><strong style="font-size: 18px;">weight </strong><span style="font-size: 18px;"><strong>path </strong>between the vertex 1 and the vertex <strong>n</strong>,&nbsp;</span><span style="font-size: 18px;"> if there exists a path, and return<strong> </strong>a list of integers whose first element is the <strong>weight </strong>of the path, and the rest consist of the nodes on that path. If no path exists, then return a list containing a single element <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;">The input list of edges is as follows - <strong>{a, b, w}</strong>, denoting there is an edge between <strong>a</strong> and <strong>b</strong>, and <strong>w</strong> is the weight of that edge.</span></p>
<p><strong><em><span style="font-size: 18px;">Note:</span></em><span style="font-size: 18px;"> </span></strong><span style="font-size: 14pt;">The driver code here will first check&nbsp;if the&nbsp;weight of the path&nbsp;returned is&nbsp;<strong>equal</strong>&nbsp;to the&nbsp;<strong>sum </strong>of the weights along the nodes on that path, if&nbsp;<strong>equal</strong>&nbsp;it will output the&nbsp;weight of the path,&nbsp;else&nbsp;<strong>-2</strong>. In case the list contains only a single element (<strong>-1</strong>)&nbsp;it will simply output <strong>-1</strong>.&nbsp;</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 5, m= 6, edges = [[1, 2, 2], [2, 5, 5], [2, 3, 4], [1, 4, 1], [4, 3, 3], [3, 5, 1]]
<strong>Output: </strong>5
<strong>Explanation: </strong>Shortest path from 1 to n is by the path 1 4 3 5 whose weight is 5. <br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, m= 1, edges = [[1, 2, 2]]
<strong>Output: </strong>2
<strong>Explanation: </strong>Shortest path from 1 to 2 is by the path 1 2 whose weight is 2. </span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, m= 0, edges = [ ]
<strong>Output: </strong>-1
<strong>Explanation: </strong>Since there are no edges, so no answer is possible.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(m* log(n))<br /><strong>Expected Space Complexity:</strong> O(n+m)</span></p>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br />2 &lt;= n &lt;= 10<sup>6</sup><br />0 &lt;= m &lt;= 10<sup>6</sup><br />1 &lt;= a, b &lt;= n<br />1 &lt;= w &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-225">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-using-atmost-one-curved-edge--170647/1" target="_blank" rel="noopener noreferrer">Shortest Path Using Atmost One Curved Edge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected, connected graph with <strong>n</strong> vertices and <strong>m</strong> double-edges stored in <strong>edges[][]</strong> 2-D array. Each double-edge is represented by a tuple <strong>(x, y, w1, w2)</strong>, which indicates that there are two edges between vertices <strong>x</strong> and <strong>y</strong>: a straight edge with weight <strong>w1</strong> and a curved edge with weight <strong>w2</strong>.</span></p>
<p><span style="font-size: 18px;">You are given two vertices <strong>a</strong> and <strong>b</strong> and you have to go from <strong>a</strong> to <strong>b</strong> through a series of edges such that in the entire path, you can use at most 1 curved edge. Your task is to find the shortest path from <strong>a</strong> to <strong>b</strong> satisfying the above condition.</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, m = 4, a = 2, b = 4, edges[][] = [[1, 2, 1, 4], [1, 3, 2, 4],[1, 4, 3, 1], [2, 4, 6, 5]]
<strong>Output: </strong>2
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/713968/Web/Other/blobid0_1745470590.jpg" width="292" height="258" /><br /><strong>Explanation:</strong>
We can follow the path 2 -&gt; 1 -&gt; 4.</span> <span style="font-size: 18px;">This gives a distance of 1+3 = 4 if we follow all straight paths. But we can take the curved path  from 1 -&gt; 4, which costs 1. This will result in a cost of 1 + 1 = 2</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, m = 1, a = 1, b = 2, edges = [[1, 2, 4, 1]]
<strong>Output : </strong>1
</span><img src="https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/713968/Web/Other/fcf19135-c88b-48ac-8fc4-bc46efc7ca3f_1685087926.png" />
<span style="font-size: 18px;"><strong>Explanation:</strong>
Take the curved path from 1 to 2 which costs 1. </span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &le; n &le; 10<sup>5</sup></span></li>
<li><span style="font-size: 18px;">1&nbsp;</span><span style="font-size: 18px;">&le; m </span><span style="font-size: 18px;">&le; 2 x&nbsp;</span><span style="font-size: 18px;">10</span><sup>5</sup></li>
<li><span style="font-size: 18px;">1 &le; a, b &le; n</span></li>
<li><span style="font-size: 18px;">1 &le; edges[i][0], edges[i][1] &le; n</span></li>
<li><span style="font-size: 18px;">0 &le;&nbsp;edges[i][2], edges[i][3] &le; 10<sup>4</sup></span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-226">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-visiting-all-nodes/description" target="_blank" rel="noopener noreferrer">Shortest Path Visiting All Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have an undirected, connected graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an array <code>graph</code> where <code>graph[i]</code> is a list of all the nodes connected with node <code>i</code> by an edge.</p>

<p>Return <em>the length of the shortest path that visits every node</em>. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg" style="width: 222px; height: 183px;" />
<pre>
<strong>Input:</strong> graph = [[1,2,3],[0],[0],[0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [1,0,2,0,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg" style="width: 382px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [0,1,4,2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>1 &lt;= n &lt;= 12</code></li>
	<li><code>0 &lt;= graph[i].length &lt;&nbsp;n</code></li>
	<li><code>graph[i]</code> does not contain <code>i</code>.</li>
	<li>If <code>graph[a]</code> contains <code>b</code>, then <code>graph[b]</code> contains <code>a</code>.</li>
	<li>The input graph is always connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-227">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-with-alternating-colors/description" target="_blank" rel="noopener noreferrer">Shortest Path with Alternating Colors</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, the number of nodes in a directed graph where the nodes are labeled from <code>0</code> to <code>n - 1</code>. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.</p>

<p>You are given two arrays <code>redEdges</code> and <code>blueEdges</code> where:</p>

<ul>
	<li><code>redEdges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is a directed red edge from node <code>a<sub>i</sub></code> to node <code>b<sub>i</sub></code> in the graph, and</li>
	<li><code>blueEdges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> indicates that there is a directed blue edge from node <code>u<sub>j</sub></code> to node <code>v<sub>j</sub></code> in the graph.</li>
</ul>

<p>Return an array <code>answer</code> of length <code>n</code>, where each <code>answer[x]</code> is the length of the shortest path from node <code>0</code> to node <code>x</code> such that the edge colors alternate along the path, or <code>-1</code> if such a path does not exist.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
<strong>Output:</strong> [0,1,-1]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
<strong>Output:</strong> [0,1,-1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= redEdges.length,&nbsp;blueEdges.length &lt;= 400</code></li>
	<li><code>redEdges[i].length == blueEdges[j].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>, u<sub>j</sub>, v<sub>j</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-228">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-source-to-destination-path3544/1" target="_blank" rel="noopener noreferrer">Shortest Source to Destination Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a&nbsp;2D binary matrix A(0-based index) of dimensions NxM. Find the minimum number of steps required to reach from (0,0) to (X, Y).<br />Note: You can only move left, right, up and down, and only through cells that <strong>contain 1</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
N=3, M=4
A=[[1,0,0,0], 
   [1,1,0,1],<br />   [0,1,1,1]]
X=2, Y=3 
<strong>Output:</strong>
5
<strong>Explanation:</strong>
The shortest path is as follows:
(0,0)-&gt;(1,0)-&gt;(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3).</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
N=3, M=4
A=[[1,1,1,1],
   [0,0,0,1],<br />   [0,0,0,1]]
X=0, Y=3
<strong>Output:</strong>
3
<strong>Explanation:</strong>
The shortest path is as follows:
(0,0)-&gt;(0,1)-&gt;(0,2)-&gt;(0,3).</span></pre>
<p><span style="font-size: 14pt;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>shortestDistance()</strong> which takes the integer N, M, X, Y, and the 2D binary matrix A as input parameters and returns the minimum number of steps required to go from (0,0) to (X, Y).If it is impossible to go from (0,0) to&nbsp;(X, Y),then function returns -1. If value of the cell (0,0) is 0&nbsp;(i.e&nbsp; A[0][0]=0)&nbsp;then return -1.</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= N,M &lt;= 250<br /></span><span style="font-size: 14pt;">0 &lt;= X &lt; N<br /></span><span style="font-size: 14pt;">0 &lt;= Y &lt; M<br />0 &lt;= A[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-229">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/snake-and-ladder-problem4816/1" target="_blank" rel="noopener noreferrer">Snake and Ladder Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a <strong>5x6</strong>&nbsp;snakes and ladders board, find the minimum number of dice throws required to reach the destination or last cell (<strong>30<sup>th</sup></strong>&nbsp;cell) from the source (1st cell). </span></p>

<p><span style="font-size:18px">You are given an integer&nbsp;<strong>N </strong>denoting&nbsp;the&nbsp;total number of snakes and ladders&nbsp;and an array <strong>arr[]</strong>&nbsp;of <strong>2*N</strong> size where <strong>2*i</strong> and <strong>(2*i + 1)<sup>th</sup></strong>&nbsp;values denote the starting and ending point respectively of <strong>i<sup>th&nbsp;</sup></strong>snake or ladder. The&nbsp;board looks like the following.<br />
<strong>Note:&nbsp;</strong>Assume that you have&nbsp;complete control over the 6 sided dice. No ladder starts from 1st cell.</span></p>

<p><br />
<span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="https://contribute.geeksforgeeks.org/wp-content/uploads/snake-and-ladders.jpg" style="border-style:solid; border-width:4px; height:292px; width:436px" /></span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 8
arr[] = {3, 22, 5, 8, 11, 26, 20, 29, 
&nbsp;      17, 4, 19, 7, 27, 1, 21, 9}
<strong>Output: </strong>3
<strong>Explanation:</strong>
The given board is the board shown
in the figure. For the above board 
output will be 3. 
a) For 1st throw get a 2. 
b) For 2nd throw get a 6.
c) For 3rd throw get a 2.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You do not need to read input or print anything. Your task is to complete the function <strong>minThrow()</strong> which takes <strong>N</strong> and <strong>arr</strong> as input parameters and returns the minimum number of throws required to reach the end of the game.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<br />
1 &le; arr[i] &le; 30&nbsp;&nbsp;</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-230">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-items-by-groups-respecting-dependencies/description" target="_blank" rel="noopener noreferrer">Sort Items by Groups Respecting Dependencies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are&nbsp;<code>n</code>&nbsp;items each&nbsp;belonging to zero or one of&nbsp;<code>m</code>&nbsp;groups where <code>group[i]</code>&nbsp;is the group that the <code>i</code>-th item belongs to and it&#39;s equal to <code>-1</code>&nbsp;if the <code>i</code>-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.</p>

<p>Return a sorted list of the items such that:</p>

<ul>
	<li>The items that belong to the same group are next to each other in the sorted list.</li>
	<li>There are some&nbsp;relations&nbsp;between these items where&nbsp;<code>beforeItems[i]</code>&nbsp;is a list containing all the items that should come before the&nbsp;<code>i</code>-th item in the sorted array (to the left of the&nbsp;<code>i</code>-th item).</li>
</ul>

<p>Return any solution if there is more than one solution and return an <strong>empty list</strong>&nbsp;if there is no solution.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/11/1359_ex1.png" style="width: 191px; height: 181px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
<strong>Output:</strong> [6,3,4,1,5,2,0,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
<strong>Output:</strong> []
<strong>Explanation:</strong>&nbsp;This is the same as example 1 except that 4 needs to be before 6 in the sorted list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>group.length == beforeItems.length == n</code></li>
	<li><code>-1 &lt;= group[i] &lt;= m - 1</code></li>
	<li><code>0 &lt;= beforeItems[i].length &lt;= n - 1</code></li>
	<li><code>0 &lt;= beforeItems[i][j] &lt;= n - 1</code></li>
	<li><code>i != beforeItems[i][j]</code></li>
	<li><code>beforeItems[i]&nbsp;</code>does not contain&nbsp;duplicates elements.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-231">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/spidey-sense5556/1" target="_blank" rel="noopener noreferrer">Spidey Sense</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Spiderman is stuck in a difficult situation. His arch-enemy the Green Goblin has planted several of his infamous Pumpkin Bombs in various locations in a building. Help Spiderman activate his Spidey Sense and identify the impact zones.&nbsp;<br />
He has a blueprint of the building which is a M x N matrix that is filled with the characters O, B, and W where:&nbsp;<br />
O represents an open space.<br />
B represents a bomb.<br />
W represents a wall.<br />
You have to replace all of the Os (open spaces) in the matrix with their shortest distance from a bomb without being able to go through any walls. Also, replace the bombs with 0 and walls with -1 in the resultant matrix. If no path exists between a bomb and an open space replace the corresponding &#39;O&#39; with -1.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>N = 3, M = 3
A[] = {</span><span style="font-size:18px">{O, O, O}, 
       {W, B, B},&nbsp;
       {W, O, O</span><span style="font-size:18px">}}</span>
<span style="font-size:18px"><strong>Output:</strong> {</span><span style="font-size:18px">{2, 1, 1}, 
         {-1, 0, 0},&nbsp; 
         {-1, 1, 1</span><span style="font-size:18px">}}</span>
<span style="font-size:18px"><strong>Explanation: </strong></span><span style="font-size:18px">The walls at (1,0) and (2,0) 
are replaced by -1.</span><span style="font-size:18px"> The bombs at (1,1) and 
(1,2) are replaced by 0.</span><span style="font-size:18px"><strong> The impact zone 
for the bomb at (1,1)</strong> includes open spaces 
at index (0,0), (0,1) and (2,1) with distance 
from bomb calculated as 2,1,1 respectively.</span>
<span style="font-size:18px"><strong>The impact zone for the bomb at (1,2)</strong> 
includes open spaces at index (0,3) and (2,2) 
with distance from bomb calculated as 1,1 
respectively.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>IInput: </strong>N = 2, M = 2
A[] = {</span><span style="font-size:18px">{O, O},
       {O, O}</span><span style="font-size:18px">}</span> 
<span style="font-size:18px"><strong>Output:</strong> {{-1, -1}
         {-1, -1}
</span></pre>

<p><span style="font-size:18px"><strong>Your Task: </strong>&nbsp;<br />
You don&#39;t need to read input or print anything. Complete the function <strong>findDistance()</strong> which takes the matrix A[], M, and N as input parameters and the resultant matrix</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(M*N)<br />
<strong>Expected Auxiliary Space:</strong> O(M*N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N*M &le; 10<sup>6</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-232">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/steps-by-knight5927/1" target="_blank" rel="noopener noreferrer">Steps by Knight</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square <strong>chessboard </strong>of<strong> </strong>size <strong>(n x n)</strong>, the initial position and target postion of Knight are given. Find out the <strong>minimum steps</strong> a Knight will take to reach the target position.<br /><br /></span><span style="font-size: 18px;"><strong>Note: </strong>The initial and the target position coordinates of Knight have been given according to 1-base indexing.<br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 3<strong>, </strong>knightPos[] = [3, 3], targetPos[]= [1, 2]<strong><br />Output:</strong> 1<strong><br />Explanation:<br /></strong>Knight takes 1 step to reach from&nbsp;<br />(3, 3) to (1 ,2).</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 6, knightPos[] = [4, 5],targetPos[] = [1, 1]</span>
<span style="font-size: 18px;"><strong>Output: </strong>3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/KnightChess.jpg" />
<span style="font-size: 18px;">Knight takes 3 step to reach from 
(4, 5) to (1, 1):
(4, 5) -&gt; (5, 3) -&gt; (3, 2) -&gt; (1, 1).</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n&lt;= 1000<br />1 &lt;= knightpos </span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito; font-size: 17px;">&le; </span><span style="font-size: 18px;">[x, y], </span><span style="font-size: 18px;">targertpos[x, y] </span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito; font-size: 17px;">&le;&nbsp;</span><span style="font-size: 18px;"> n&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-233">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/strange-printer-ii/description" target="_blank" rel="noopener noreferrer">Strange Printer II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a strange printer with the following two special requirements:</p>

<ul>
	<li>On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.</li>
	<li>Once the printer has used a color for the above operation, <strong>the same color cannot be used again</strong>.</li>
</ul>

<p>You are given a <code>m x n</code> matrix <code>targetGrid</code>, where <code>targetGrid[row][col]</code> is the color in the position <code>(row, col)</code> of the grid.</p>

<p>Return <code>true</code><em> if it is possible to print the matrix </em><code>targetGrid</code><em>,</em><em> otherwise, return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/print1.jpg" style="width: 600px; height: 175px;" />
<pre>
<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/print2.jpg" style="width: 600px; height: 367px;" />
<pre>
<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to form targetGrid because it is not allowed to print the same color in different turns.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == targetGrid.length</code></li>
	<li><code>n == targetGrid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 60</code></li>
	<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-234">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/strongly-connected-component-tarjanss-algo-1587115621/1" target="_blank" rel="noopener noreferrer">Strongly connected component (Tarjans&#39;s Algo)</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Directed Graph with V vertices and E edges</span>, <span style="font-size: 18px;"> Find the members of strongly connected components in the graph.</span></p>
<p><strong><span style="font-size: 18px;">Note - </span></strong><span style="font-size: 18px;">Sort both the individual components and array of the components.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701448/Web/Other/blobid0_1745301017.jpg" width="319" height="319" /><br /><span style="font-size: 18px;"><strong>Output: </strong>0 1 2 3 4
<strong>Explanation</strong>:
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701448/Web/Other/blobid1_1745301078.jpg" width="363" height="245" /><br /><span style="font-size: 18px;">We can clearly see that there are 3 Strongly
Connected Components in the Graph</span> <span style="font-size: 18px;">as mentioned
in the Output.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701448/Web/Other/blobid2_1745301113.jpg" width="370" height="246" /><br /><span style="font-size: 18px;"><strong>Output: </strong>0 1 2
<strong>Explanation</strong>:</span>
<span style="font-size: 18px;">All of the nodes are connected to each other.
So, there's only one SCC as shown.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:</strong></span><br /><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function <strong>tarjans()</strong>&nbsp;which takes the number of vertices V&nbsp;and adjacency list of the graph as input parameters&nbsp;and returns a list of list of integers denoting the members of strongly connected components in the given graph.<br /><strong>Note: </strong>A single strongly connected component must be represented in the form of a list if integers sorted in the ascending order.&nbsp;The resulting list should consist of a list of all SCCs&nbsp;which must be&nbsp;sorted in a way such that a lexicographically smaller list of integers appears first. </span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(V + E).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(V).</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> V&nbsp;</span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> 10<sup>5</sup><br />1 </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> E&nbsp;</span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> 10<sup>5</sup><br />0 </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> u, v </span> <span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> N-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-235">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-of-dependencies-in-a-graph5311/1" target="_blank" rel="noopener noreferrer">Sum of dependencies in a graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a directed graph with&nbsp;</span><span style="font-size: 18px;"><strong>V</strong> nodes and&nbsp;</span><span style="font-size: 18px;"><strong>E</strong> edges, the graph's edges are represented as a 2D array, <strong>edges</strong>[][]</span><span style="font-size: 18px;">. Each row in the array represents a directed edge </span><span style="font-size: 18px;">(<strong>u</strong>, <strong>v</strong>), meaning there is a directed edge from node </span><span style="font-size: 18px;"><strong>u</strong> to node </span><span style="font-size: 18px;"><strong>v</strong>. </span><span style="font-size: 18px;">If there is a directed edge from&nbsp;</span><span style="font-size: 18px;"><strong>u</strong> to<strong>&nbsp;</strong></span><span style="font-size: 18px;"><strong>v</strong>, it means that&nbsp;</span><span style="font-size: 18px;"><strong>u</strong> depends on&nbsp;</span><span style="font-size: 18px;"><strong>v</strong>. The Number of Dependencies (NoD) for a node&nbsp;</span><span style="font-size: 18px;"><strong>x</strong> is the total count of nodes that&nbsp;</span><span style="font-size: 18px;"><strong>x</strong> depends upon.</span></p>
<p><span style="font-size: 18px;">Your task is to calculate the sum of the Number of Dependencies (NoD) for all nodes in the graph.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V<strong> </strong>= 4, E<strong> </strong>= 4, edges[][] = [[0,2],[0,3],[1,3],[2,3]]</span>
<span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/705732/Web/Other/blobid0_1733466066.png" width="322" height="285" /></span>
<span style="font-size: 18px;"><strong>Output: </strong>4
<strong>Explanation: </strong>For the graph in diagram, A depends on C and D i.e. A's NoD is 2, </span><span style="font-size: 18px;">B depends on D i.e. B's NoD is 1, C depends on D i.e. D's NoD is 1 and D depends on none. Hence answer is 2 + 1 + 1 + 0 = 4.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V<strong> </strong>= 4, E<strong> </strong>= 3, edges[][]<strong> </strong>= [[0,3],[0,2],[0,1]]
<strong>Output: </strong>3
<strong>Explanation: </strong>The sum of dependencies: 3 + 0 + 0 + 0 = 3.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= V &lt;= 10<sup>5<br /></sup>1 &lt;= E &lt;= 10<sup>5<br /></sup></span><span style="font-size: 18px;">edges.size() = E<br />edges[i].size() = 2<br />0 &lt;= edges[i][j] &lt;= V-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-236">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-distances-in-tree/description" target="_blank" rel="noopener noreferrer">Sum of Distances in Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected connected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> edges.</p>

<p>You are given the integer <code>n</code> and the array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>Return an array <code>answer</code> of length <code>n</code> where <code>answer[i]</code> is the sum of the distances between the <code>i<sup>th</sup></code> node in the tree and all other nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist1.jpg" style="width: 304px; height: 224px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
<strong>Output:</strong> [8,12,6,10,10,10]
<strong>Explanation:</strong> The tree is shown above.
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.
Hence, answer[0] = 8, and so on.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist2.jpg" style="width: 64px; height: 65px;" />
<pre>
<strong>Input:</strong> n = 1, edges = []
<strong>Output:</strong> [0]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist3.jpg" style="width: 144px; height: 145px;" />
<pre>
<strong>Input:</strong> n = 2, edges = [[1,0]]
<strong>Output:</strong> [1,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>The given input represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-237">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-time-when-the-network-becomes-idle/description" target="_blank" rel="noopener noreferrer">The Time When the Network Becomes Idle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a network of <code>n</code> servers, labeled from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates there is a message channel between servers <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, and they can pass <strong>any</strong> number of messages to <strong>each other</strong> directly in <strong>one</strong> second. You are also given a <strong>0-indexed</strong> integer array <code>patience</code> of length <code>n</code>.</p>

<p>All servers are <strong>connected</strong>, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.</p>

<p>The server labeled <code>0</code> is the <strong>master</strong> server. The rest are <strong>data</strong> servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers <strong>optimally</strong>, so every message takes the <strong>least amount of time</strong> to arrive at the master server. The master server will process all newly arrived messages <strong>instantly</strong> and send a reply to the originating server via the <strong>reversed path</strong> the message had gone through.</p>

<p>At the beginning of second <code>0</code>, each data server sends its message to be processed. Starting from second <code>1</code>, at the <strong>beginning</strong> of <strong>every</strong> second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:</p>

<ul>
	<li>If it has not, it will <strong>resend</strong> the message periodically. The data server <code>i</code> will resend the message every <code>patience[i]</code> second(s), i.e., the data server <code>i</code> will resend the message if <code>patience[i]</code> second(s) have <strong>elapsed</strong> since the <strong>last</strong> time the message was sent from this server.</li>
	<li>Otherwise, <strong>no more resending</strong> will occur from this server.</li>
</ul>

<p>The network becomes <strong>idle</strong> when there are <strong>no</strong> messages passing between servers or arriving at servers.</p>

<p>Return <em>the <strong>earliest second</strong> starting from which the network becomes <strong>idle</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example 1" src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" style="width: 750px; height: 384px;" />
<pre>
<strong>Input:</strong> edges = [[0,1],[1,2]], patience = [0,2,1]
<strong>Output:</strong> 8
<strong>Explanation:</strong>
At (the beginning of) second 0,
- Data server 1 sends its message (denoted 1A) to the master server.
- Data server 2 sends its message (denoted 2A) to the master server.

At second 1,
- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.
- Server 1 has not received any reply. 1 second (1 &lt; patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.
- Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).

At second 2,
- The reply 1A arrives at server 1. No more resending will occur from server 1.
- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.
- Server 2 resends the message (denoted 2C).
...
At second 4,
- The reply 2A arrives at server 2. No more resending will occur from server 2.
...
At second 7, reply 2D arrives at server 2.

Starting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.
This is the time when the network becomes idle.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="example 2" src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" style="width: 100px; height: 85px;" />
<pre>
<strong>Input:</strong> edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Data servers 1 and 2 receive a reply back at the beginning of second 2.
From the beginning of the second 3, the network becomes idle.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == patience.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>patience[0] == 0</code></li>
	<li><code>1 &lt;= patience[i] &lt;= 10<sup>5</sup></code> for <code>1 &lt;= i &lt; n</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>Each server can directly or indirectly reach another server.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-238">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/time-taken-to-mark-all-nodes/description" target="_blank" rel="noopener noreferrer">Time Taken to Mark All Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exists an <strong>undirected</strong> tree with <code>n</code> nodes numbered <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the tree.</p>

<p>Initially, <strong>all</strong> nodes are <strong>unmarked</strong>. For each node <code>i</code>:</p>

<ul>
	<li>If <code>i</code> is odd, the node will get marked at time <code>x</code> if there is <strong>at least</strong> one node <em>adjacent</em> to it which was marked at time <code>x - 1</code>.</li>
	<li>If <code>i</code> is even, the node will get marked at time <code>x</code> if there is <strong>at least</strong> one node <em>adjacent</em> to it which was marked at time <code>x - 2</code>.</li>
</ul>

<p>Return an array <code>times</code> where <code>times[i]</code> is the time when all nodes get marked in the tree, if you mark node <code>i</code> at time <code>t = 0</code>.</p>

<p><strong>Note</strong> that the answer for each <code>times[i]</code> is <strong>independent</strong>, i.e. when you mark node <code>i</code> all other nodes are <em>unmarked</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1],[0,2]]</span></p>

<p><strong>Output:</strong> [2,4,3]</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/01/screenshot-2024-06-02-122236.png" style="width: 500px; height: 241px;" /></p>

<ul>
	<li>For <code>i = 0</code>:

	<ul>
		<li>Node 1 is marked at <code>t = 1</code>, and Node 2 at <code>t = 2</code>.</li>
	</ul>
	</li>
	<li>For <code>i = 1</code>:
	<ul>
		<li>Node 0 is marked at <code>t = 2</code>, and Node 2 at <code>t = 4</code>.</li>
	</ul>
	</li>
	<li>For <code>i = 2</code>:
	<ul>
		<li>Node 0 is marked at <code>t = 2</code>, and Node 1 at <code>t = 3</code>.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1]]</span></p>

<p><strong>Output:</strong> [1,2]</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/01/screenshot-2024-06-02-122249.png" style="width: 500px; height: 257px;" /></p>

<ul>
	<li>For <code>i = 0</code>:

	<ul>
		<li>Node 1 is marked at <code>t = 1</code>.</li>
	</ul>
	</li>
	<li>For <code>i = 1</code>:
	<ul>
		<li>Node 0 is marked at <code>t = 2</code>.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = </span>[[2,4],[0,1],[2,3],[0,2]]</p>

<p><strong>Output:</strong> [4,6,3,5,5]</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/03/screenshot-2024-06-03-210550.png" style="height: 266px; width: 500px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= edges[i][0], edges[i][1] &lt;= n - 1</code></li>
	<li>The input is generated such that <code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-239">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/topological-sort/1" target="_blank" rel="noopener noreferrer">Topological sort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a&nbsp;<strong>Directed Acyclic Graph (DAG)</strong>&nbsp;of&nbsp;<strong>V&nbsp;</strong>(0 to V-1)&nbsp;vertices and&nbsp;<strong>E</strong>&nbsp;edges represented as a 2D list of&nbsp;<strong>edges[][]</strong>, where each entry&nbsp;<strong>edges[i] = [u, v]</strong> denotes a&nbsp;<span style="background-color: #ffffff; color: #1e2229; font-family: var(--gfg-font-secondary); font-weight: bolder;">directed<strong>&nbsp;</strong>edge&nbsp;</span><span style="background-color: #ffffff; color: #1e2229; font-family: var(--gfg-font-secondary); font-weight: bolder;">u -&gt; v</span>. Return the <strong>topological sort</strong>&nbsp;for the given graph.</span></p>
<blockquote><span style="font-size: 14pt;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">Topological sorting for&nbsp;</span><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">Directed Acyclic Graph (DAG)</span></span><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">&nbsp;is a linear ordering of vertices such that for every directed edge&nbsp;<strong>u&nbsp;</strong></span><strong>-&gt;&nbsp;</strong><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><strong>v</strong>, vertex&nbsp;</span><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">u</strong></strong><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">&nbsp;comes before&nbsp;</span><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">v</strong></strong><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">&nbsp;in the ordering.</span></span></blockquote>
<p><span style="font-size: 14pt;"><strong>Note:&nbsp;</strong>As there are multiple Topological orders possible, you may return any of them. If your returned Topological sort is correct then the output will be&nbsp;<strong>true</strong>&nbsp;else&nbsp;<strong>false</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> V = 4, E = 3, edges[][] = [[3, 0], [1, 0], [2, 0]]</span><br /><span style="font-size: 14pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700255/Web/Other/blobid0_1744196747.jpg" width="330" height="247" /></span><br /><span style="font-size: 14pt;"><strong>Output: </strong>true</span><br /><span style="font-size: 14pt;"><strong>Explanation</strong>: The output true denotes that the order is valid. Few valid Topological orders for the given graph are:
[3, 2, 1, 0]</span><br /><span style="font-size: 14pt;">[1, 2, 3, 0]</span><br /><span style="font-size: 14pt;">[2, 3, 1, 0]</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>V = 6, E = 6, edges[][] = [[1, 3], [2, 3], [4, 1], [4, 0], [5, 0], [5,2]]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700255/Web/Other/blobid1_1744196789.jpg" width="361" height="269" /><br /><strong>Output: </strong>true
<strong>Explanation: </strong>The output true denotes that the order is valid. Few valid Topological orders for the graph are:<br />[4, 5, 0, 1, 2, 3]<br />[5, 2, 4, 0, 1, 3]</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />2&nbsp;&nbsp;</span><span style="font-size: 18px;">&le;</span>&nbsp;&nbsp;<span style="font-size: 18px;">V&nbsp;&nbsp;</span><span style="font-size: 18px;">&le;</span>&nbsp; 5 x <span style="font-size: 18px;">10<sup>3</sup><br />1&nbsp;&nbsp;</span><span style="font-size: 18px;">&le;</span>&nbsp;&nbsp;<span style="font-size: 18px;">E =&nbsp;</span><span style="font-size: 14pt;">edges.size()</span><span style="font-size: 18px;">&nbsp;&nbsp;</span><span style="font-size: 18px;">&le;</span>&nbsp; min[10<sup>5</sup>, <span style="font-size: 18px;">(V * (V - 1)) / 2]</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-240">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/transitive-closure-of-a-graph0930/1" target="_blank" rel="noopener noreferrer">Transitive closure of a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a directed graph, determine whether a vertex <strong>j</strong> is reachable from another vertex <strong>i</strong>&nbsp;for all vertex pairs <strong>(i, j)</strong> in the given <strong>graph</strong>. Here,&nbsp;</span><span style="font-size: 18px;">vertex&nbsp;</span><strong style="font-size: 18px;">j</strong><span style="font-size: 18px;">&nbsp;is reachable from another vertex&nbsp;</span><strong style="font-size: 18px;">i </strong><span style="font-size: 18px;">means that there is a path from vertex </span><strong style="font-size: 18px;">i </strong><span style="font-size: 18px;">to </span><strong style="font-size: 18px;">j.</strong><span style="font-size: 18px;">&nbsp;The reachability matrix is called the </span><strong style="font-size: 18px;">transitive closure of a graph</strong><span style="font-size: 18px;">. The directed graph is represented by an </span><strong style="font-size: 18px;">adjacency matrix </strong><span style="font-size: 18px;">where there are </span><strong style="font-size: 18px;">N</strong><span style="font-size: 18px;"> vertices.&nbsp;</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> N = 4
graph = {{1, 1, 0, 1}, 
&nbsp;        {0, 1, 1, 0}, 
&nbsp;        {0, 0, 1, 1}, 
&nbsp;        {0, 0, 0, 1}}
<strong>Output:</strong> {{1, 1, 1, 1}, 
&nbsp;        {0, 1, 1, 1}, 
&nbsp;        {0, 0, 1, 1}, 
&nbsp;        {0, 0, 0, 1}}
<strong>Explanation: <br /></strong></span><span style="font-size: 18px;">The output list shows the reachable indexes.<br /></span></pre>
<p style="font-family: sans-serif; font-size: medium; white-space: normal;"><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> N = 3
graph = {{1, 0, 0}, 
&nbsp;        {0, 1, 0}, 
&nbsp;        {0, 0, 1}}
<strong>Output:</strong> {{1, 0, 0}, 
&nbsp;        {0, 1, 0}, 
&nbsp;        {0, 0, 1}}
<strong>Explanation: <br /></strong>The output list shows the reachable indexes.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You do not need to read input or print anything. Your task is to complete the function <strong>transitiveClosure()</strong> which takes an integer <strong>N</strong> and a 2D array <strong>graph</strong>(adjacency matrix of the graph)<strong>&nbsp;</strong>as <strong>input parameters </strong>and returns the <strong>transitive closure </strong>of the graph in the form of <strong>2D array</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N<sup>3</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 100&nbsp;&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-241">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/till-the-end-of-the-time-d73ba7d1/" target="_blank" rel="noopener noreferrer">Travel diaries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">grammar-verified</span> <span class="topic-badge">graph</span> <span class="topic-badge">medium</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a matrix of size <span class="mathjax-latex">\(N \times M\)</span> that contains the digits <em>0</em>, <em>1</em>, or <em>2</em> only. All the cells that contain <em>1</em> and are adjacent to any cell that contains <em>2</em> will be converted from <em>1</em> to <em>2</em>, simultaneously in <em>1</em> second. Write a program to find the minimum time to convert all the cells having value <em>1</em> to <em>2</em>.</p>
<p><strong>Input format</strong><br /></p>
<ul>
<li>First line: Two space-separated integers <em>N</em> and <em>M</em><br /></li>
<li>Next <em>N</em> lines: <em>M</em> space-separated integers (denoting the matrix)</li>
</ul>
<p><strong>Output format</strong><br /></p>
<p>Print the minimum time to convert all the cells having value <em>1</em> to <em>2</em>.</p>
<p><strong>Constraints</strong><br /></p>
<p><span class="mathjax-latex">\(1 ≤ N, M ≤ 10^3 \)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>If you starts from the cell [1,4] or [3,4] and travels to [2,3] then the cost will be 2 which is maximum of all possible journeys.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-242">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/castle-run3644/1" target="_blank" rel="noopener noreferrer">Traverse All Edges And Vertices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are presented with an <strong>undirected connected graph </strong>consisting of <strong>n</strong> vertices and connections between them represented by an <strong>adjacency matrix</strong>. Your objective is to determine whether it is possible to start traversing from a node, <strong>x</strong>, and return to it after traversing all the vertices <strong>at least once</strong>, using each edge <strong>exactly once</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>paths = 0 1 1 1 1<br />  &nbsp; &nbsp; &nbsp;&nbsp;1 0 0 1 0<br />  &nbsp; &nbsp;  &nbsp;1 0 0 1 0<br />  &nbsp; &nbsp;  &nbsp;1 1 1 0 1<br />  &nbsp; &nbsp;  &nbsp;1 0 0 1 0<br /></span><span style="font-size: 18px;"><strong>Output: </strong>1<br /></span><span style="font-size: 18px;"><strong>Explanation: <br /></strong>One can visit the vertices in the following way:
1-&gt;3-&gt;4-&gt;5-&gt;1-&gt;4-&gt;2-&gt;1 (assuming 1-based indexing)
Here all the vertices has been visited and all
paths are used exactly once.<br /></span></pre>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: medium; white-space: normal;"><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: <br /></strong>paths = 0 1 1 0<br />        1 0 1 1<br />        1 1 0 0<br />        0 1 0 0
<strong>Output: </strong>0
<strong>Explanation: <br /></strong>There exists no such vertex from which all the <br />vertices could be visited and all edges are used <br />exactly once.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>isPossible()&nbsp;</strong>which takes adjacency matrix <strong>paths</strong> as an input parameter and returns <strong>1 </strong>if it is possible </span><span style="font-size: 18px;">to start traversing from a node,&nbsp;</span><strong style="font-size: 18px;">x</strong><span style="font-size: 18px;">, and come back to it after traversing all the vertices&nbsp;</span><strong style="font-size: 18px;">at least once</strong><span style="font-size: 18px;">, using each edge&nbsp;</span><strong style="font-size: 18px;">exactly once</strong><span style="font-size: 18px;">.</span></p>
<p>&nbsp;<span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>)<br /><strong>Expected Space Compelxity:&nbsp;</strong>O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 100<br />0 &lt;= paths[i][j] &lt;= 1<br /><strong>Note:</strong>&nbsp;</span><span style="font-size: 18px;">paths[i][j] = 0 where </span><span style="font-size: 18px;">i == j or there exists no edge between i and j. paths[i][j] = 1 means there is a path between i to j.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-243">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/tree-journeys-fd9f8f9c/" target="_blank" rel="noopener noreferrer">Tree Trips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">bruteforce</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Bob is going to make <span class="mathjax-latex">\(m\)</span>&nbsp;trips on a <strong>tree</strong>. During each trip he goes from a node, <span class="mathjax-latex">\(x_{i}\)</span>,&nbsp;to another node, <span class="mathjax-latex">\(y_{i}\)</span>, using the simple path between the two nodes.&nbsp;</p>

<p>Alice is jealous of Bob, and doesn't want him to be able to go on any of the <span class="mathjax-latex">\(m\)</span> trips. Before Bob wakes up, Alice plans to remove some edges in the tree, in a way that Bob wouldn't be able to make <strong>any of the <span class="mathjax-latex">\(m\)</span> trips</strong>.&nbsp;</p>

<p>Please, help Alice find out the <strong>minimum </strong>number of edges she should remove from the tree, so Bob cannot make any of the trips.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>INPUT FORMAT</strong></p>

<p>The first line of input contains two integers,&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;<span class="mathjax-latex">\((2 &lt;= n &lt;= 15)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;<span class="mathjax-latex">\((1 &lt;= m &lt;= \frac{n(n - 1)}{2})\)</span>&nbsp;- denoting the number of nodes in the tree, and the number of trips Bob wants to make.&nbsp;</p>

<p>The next&nbsp;<span class="mathjax-latex">\(n - 1\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(u_{i} (1 &lt;= u_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(v_{i} (1 &lt;= v_{i} &lt;= n)\)</span>&nbsp;(<span class="mathjax-latex">\(u_{i} &lt; v_{i}\)</span>)&nbsp;- denoting the edges in the tree.&nbsp;</p>

<p>The last&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(x_{i} (1 &lt;= x_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(y_{i} (1 &lt;= y_{i} &lt;= n)\)</span>&nbsp;<span class="mathjax-latex">\((x_{i} \neq y_{i})\)</span>&nbsp;- denoting start and end nodes of the trips Bob wants to make.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>OUTPUT FORMAT</strong></p>

<p>The minimum number of edges Alice should remove from the tree to make the trips impossible.&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the sample input we have a tree with <span class="mathjax-latex">\(4\)</span> edges <span class="mathjax-latex">\((1, 2)\)</span>, <span class="mathjax-latex">\((1, 3)\)</span>, <span class="mathjax-latex">\((1, 4)\)</span> and <span class="mathjax-latex">\((1, 5)\)</span>.</p>

<p>The tree looks like:&nbsp;</p>

<p><img alt="" height="300" src="https://he-s3.s3.amazonaws.com/media/uploads/1bff5952-4c0f-4a7b-a0c2-0aee81416da9.png" width="318"></p>

<p>Bob wants to make the following trips <strong>2 -&gt; 3&nbsp;</strong>and <strong>3 -&gt; 4</strong>.&nbsp;</p>

<p>It is easy to see that if we remove the edge <span class="mathjax-latex">\((1, 3)\)</span>, then he can't make any of those trips. The resulting graphs looks like:&nbsp;</p>

<p><img alt="" height="280" src="https://he-s3.s3.amazonaws.com/media/uploads/216160d7-496e-4da9-a8b5-558d32c189b1.png" width="325"></p>

<p>Hence, the answer for this input is <span class="mathjax-latex">\(1\)</span>.&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-244">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1" target="_blank" rel="noopener noreferrer">Undirected Graph Cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18.6667px;">Given an <strong>undirected graph </strong>with <strong>V</strong> vertices and<strong> E </strong>edges, represented as a 2D vector <strong>edges[][]</strong>, where each entry <strong>edges[i] = [u, v]</strong> denotes an edge between vertices <strong>u</strong> and <strong>v</strong>, determine whether the graph contains a <strong>cycle </strong>or not. The graph can have multiple component.</span><span style="font-size: 18px;"><img style="font-size: 18px; font-weight: bold;" src="C:\Users\Mukul kumar\Desktop\GFG_PIC.JPG" alt="" /></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, E = 4, edges[][] = [[0, 1], [0, 2], [1, 2], [2, 3]]
<strong>Output: </strong>true
<strong>Explanation:</strong> 
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/891735/Web/Other/blobid1_1743510240.jpg" width="176" height="158" /> <br /><span style="font-size: 18px;">1 -&gt; 2 -&gt; 0 -&gt; 1 is a cycle.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, E = 3, edges[][] = [[0, 1], [1, 2], [2, 3]]</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">false</span><span style="font-size: 18px;">
<strong>Explanation: 
</strong></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/891735/Web/Other/blobid2_1743510254.jpg" width="169" height="153" /> <br /><span style="font-size: 18px;">No cycle in the graph.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1&nbsp;&le; V&nbsp;&le;&nbsp;10<sup>5</sup><br />1 &le; E = edges.size() &le; 10<sup>5</sup><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-245">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/union-find/1" target="_blank" rel="noopener noreferrer">Union-Find</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">This problem is to implement disjoint set union. There will be 2 incomplete functions namely union and find. You have to complete these functions.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Union:</strong> Join two subsets into a single set.<br /><strong>isConnected:</strong> Determine which subset a particular element is in. This can be used for determining if two elements are in same subset.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 5
q = 4
Queries = 
Union(1,3)
isConnected(1,2)
Union(1,5)
isConnected(3,5)
<strong>Output:
</strong>0
1<strong>
Explanation: </strong>Initially all nodes 1 2 3 4 5
are not connected.&nbsp;
After <strong>Union(1,3)</strong>, node 1 and 3 will be
connected.
When we do <strong>isConnected(</strong><strong>1,2)</strong>,&nbsp; as node 1
and 2&nbsp;are not connected it will return 0.
After <strong>Union(1,5)</strong>, node 1 and 5&nbsp;will be
connected.
When we do <strong>isConnected(3,5</strong><strong>)</strong>,&nbsp; as node
1 and 3&nbsp;are&nbsp;connected, and node 1 and 5
are connected, hence 3 and 5 are
connected.&nbsp;Thus it will return 1.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 5
q = 4
Queries = 
Union(1,4)
Union(1,5)
isConnected(2,3)
Union(3,4)
<strong>Output: </strong>0</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">You have to complete the function <strong>union_() </strong>which merges the node1 and node2. You will also have to complete the function <strong>isConnected() </strong>which will return whether the two nodes are connected.</span></p>
<p><strong><span style="font-size: 18px;">Note:&nbsp;</span></strong><span style="font-size: 18px;">Both function will contain two arrays&nbsp;<strong>par[] and ranks1[]&nbsp;</strong>along with two nodes. Initially&nbsp;<strong>par[i] = i </strong>and <strong>rank1[i] = 1&nbsp;</strong></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N + Q).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(1).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:&nbsp;</strong><br />1 &lt;= N &lt;= 10<sup>5</sup><br />1&lt;= Q &lt;= 10<sup>5</sup><br />1 &lt;= node1, node2 &lt;= N</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-246">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/length-of-largest-region-of-1s-1587115620/1" target="_blank" rel="noopener noreferrer">Unit Area of largest region of 1&#39;s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a grid of dimension <strong>n</strong>x<strong>m&nbsp;</strong>containing 0s and 1s. Find the unit area of the largest region of 1s.<br />
Region of 1&#39;s is a group of 1&#39;s connected 8-directionally (horizontally, vertically, diagonally).</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>grid = {{1,1,1,0},{0,0,1,0},{0,0,0,1}}
<strong>Output: </strong>5
<strong>Explanation: </strong>The grid is-
<span style="color:#FF0000">1 1 1</span> 0
0 0 <span style="color:#FF0000">1 </span>0
0 0 0 <span style="color:#FF0000">1
</span>The largest region of 1&#39;s is colored
in orange.
</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>grid = {{0,1}}
<strong>Output: </strong>1
<strong>Explanation: </strong>The grid is-
0 <span style="color:#FF0000">1
</span>The largest region of 1&#39;s is colored in 
orange.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read or print anyhting. Your task is to complete the function&nbsp;<strong>findMaxArea()&nbsp;</strong>which takes grid as input parameter and returns the area of the largest region of 1&#39;s.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(n*m)<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(n*m)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n, m &le; 500</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-247">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unit-conversion-i/description" target="_blank" rel="noopener noreferrer">Unit Conversion I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> types of units indexed from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>conversions</code> of length <code>n - 1</code>, where <code>conversions[i] = [sourceUnit<sub>i</sub>, targetUnit<sub>i</sub>, conversionFactor<sub>i</sub>]</code>. This indicates that a single unit of type <code>sourceUnit<sub>i</sub></code> is equivalent to <code>conversionFactor<sub>i</sub></code> units of type <code>targetUnit<sub>i</sub></code>.</p>

<p>Return an array <code>baseUnitConversion</code> of length <code>n</code>, where <code>baseUnitConversion[i]</code> is the number of units of type <code>i</code> equivalent to a single unit of type 0. Since the answer may be large, return each <code>baseUnitConversion[i]</code> <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">conversions = [[0,1,2],[1,2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,6]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Convert a single unit of type 0 into 2 units of type 1 using <code>conversions[0]</code>.</li>
	<li>Convert a single unit of type 0 into 6 units of type 2 using <code>conversions[0]</code>, then <code>conversions[1]</code>.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/12/example1.png" style="width: 545px; height: 118px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">conversions = [[0,1,2],[0,2,3],[1,3,4],[1,4,5],[2,5,2],[4,6,3],[5,7,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,3,8,10,6,30,24]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Convert a single unit of type 0 into 2 units of type 1 using <code>conversions[0]</code>.</li>
	<li>Convert a single unit of type 0 into 3 units of type 2 using <code>conversions[1]</code>.</li>
	<li>Convert a single unit of type 0 into 8 units of type 3 using <code>conversions[0]</code>, then <code>conversions[2]</code>.</li>
	<li>Convert a single unit of type 0 into 10 units of type 4 using <code>conversions[0]</code>, then <code>conversions[3]</code>.</li>
	<li>Convert a single unit of type 0 into 6 units of type 5 using <code>conversions[1]</code>, then <code>conversions[4]</code>.</li>
	<li>Convert a single unit of type 0 into 30 units of type 6 using <code>conversions[0]</code>, <code>conversions[3]</code>, then <code>conversions[5]</code>.</li>
	<li>Convert a single unit of type 0 into 24 units of type 7 using <code>conversions[1]</code>, <code>conversions[4]</code>, then <code>conversions[6]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>conversions.length == n - 1</code></li>
	<li><code>0 &lt;= sourceUnit<sub>i</sub>, targetUnit<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= conversionFactor<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li>It is guaranteed that unit 0 can be converted into any other unit through a <strong>unique</strong> combination of conversions without using any conversions in the opposite direction.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-248">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-arrangement-of-pairs/description" target="_blank" rel="noopener noreferrer">Valid Arrangement of Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">eulerian-circuit</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>pairs</code> where <code>pairs[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>. An arrangement of <code>pairs</code> is <strong>valid</strong> if for every index <code>i</code> where <code>1 &lt;= i &lt; pairs.length</code>, we have <code>end<sub>i-1</sub> == start<sub>i</sub></code>.</p>

<p>Return <em><strong>any</strong> valid arrangement of </em><code>pairs</code>.</p>

<p><strong>Note:</strong> The inputs will be generated such that there exists a valid arrangement of <code>pairs</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> pairs = [[5,1],[4,5],[11,9],[9,4]]
<strong>Output:</strong> [[11,9],[9,4],[4,5],[5,1]]
<strong>Explanation:
</strong>This is a valid arrangement since end<sub>i-1</sub> always equals start<sub>i</sub>.
end<sub>0</sub> = 9 == 9 = start<sub>1</sub> 
end<sub>1</sub> = 4 == 4 = start<sub>2</sub>
end<sub>2</sub> = 5 == 5 = start<sub>3</sub>
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> pairs = [[1,3],[3,2],[2,1]]
<strong>Output:</strong> [[1,3],[3,2],[2,1]]
<strong>Explanation:</strong>
This is a valid arrangement since end<sub>i-1</sub> always equals start<sub>i</sub>.
end<sub>0</sub> = 3 == 3 = start<sub>1</sub>
end<sub>1</sub> = 2 == 2 = start<sub>2</sub>
The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> pairs = [[1,2],[1,3],[2,1]]
<strong>Output:</strong> [[1,2],[2,1],[1,3]]
<strong>Explanation:</strong>
This is a valid arrangement since end<sub>i-1</sub> always equals start<sub>i</sub>.
end<sub>0</sub> = 2 == 2 = start<sub>1</sub>
end<sub>1</sub> = 1 == 1 = start<sub>2</sub>
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>
	<li><code>pairs[i].length == 2</code></li>
	<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>start<sub>i</sub> != end<sub>i</sub></code></li>
	<li>No two pairs are exactly the same.</li>
	<li>There <strong>exists</strong> a valid arrangement of <code>pairs</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We're given a list of pairs, each represented as <code>[start, end]</code>, and our task is to arrange these pairs in a specific order. For this order to be valid, the <code>end</code> of each pair has to match the <code>start</code> of the next one in line. Thankfully, we know that a valid arrangement is guaranteed to exist.</p>
<p>To put it more technically:</p>
<ul>
<li>For every pair in the sequence, the <code>end</code> of the pair at index <code>i-1</code> has to equal the <code>start</code> of the pair at index <code>i</code>.</li>
<li>If there’s more than one possible arrangement, we only need to return one of them.</li>
</ul>
<p>To solve this, we can borrow ideas from Eulerian paths. If you’re not familiar with them, the basic idea is that an Eulerian path in a graph visits every edge exactly once, and it turns out that this is pretty similar to our goal where each pair’s <code>end</code> needs to connect smoothly(<span class="math inline">\(end_{i-1} == start_i\)</span>) to the <code>start</code> of the next pair.</p>
<h6 id="the-rules-of-eulerian-path">The Rules of Eulerian Path</h6>
<p>Eulerian paths have a couple of conditions:</p>
<ol>
<li>In an undirected graph, either all nodes have an even degree, or exactly two have an odd degree.</li>
<li>In a directed graph (which is what we have here), we need to check if:
<ul>
<li>Each node’s <code>outDegree</code> matches its <code>inDegree</code>.</li>
<li>Or, exactly one node has one more outgoing edge (<code>outDegree = inDegree + 1</code>), which indicates our starting point.</li>
</ul>
</li>
</ol>
<blockquote>
<p>A diagram illustrating the starting condition (<code>outDegree = inDegree + 1</code>) is shown below.</p>
</blockquote>
<p><img src="../Figures/2097/euler.png" alt="2097_euler" /></p>
</br>
<p>With the problem's guarantee of a valid arrangement, we can rely on these properties. So, all we need to do is find that starting node, then follow the edges to build our path.</p>
<hr />
<h3 id="approach-1-eulerian-path-recursive">Approach 1: Eulerian Path (Recursive)</h3>
<h4 id="intuition">Intuition</h4>
<p>Before finding the starting node, we treat each pair as a directed edge between two nodes, where the <code>start</code> is the beginning node and the <code>end</code> is the destination. Using this setup, we can create a graph representation with an adjacency list, where each node points to the nodes it connects to directly. This list of neighbors for each node will help us keep track of the possible paths we can take as we form the sequence of pairs.</p>
<p>The next step is finding the right starting node for our traversal. We’re looking for a node where the outgoing edges (or <code>outDegree</code>) exceed the incoming edges (or <code>inDegree</code>) by one. Such a node, if it exists, serves as a natural starting point because it has one extra outgoing connection that begins the path. If there’s no node like this (meaning all nodes have equal in and out degrees), then any node can be chosen as the start, as this suggests a closed Eulerian path.</p>
<p>With our starting node identified, we can traverse the graph using Depth-First Search (Postorder DFS). Starting from our chosen node, we follow each edge, moving to neighboring nodes and adding each visited node to our path. This way, we ensure that every edge is visited exactly once, creating a continuous sequence that meets the required conditions. As we explore each edge, we add nodes to the path in the reverse order (because of DFS), which means we’ll need to reverse the recorded path at the end to obtain the correct order.</p>
<p>At this point, you might wonder why we need to use postorder DFS. The intuitive approach is to use a DFS with backtracking, which would also work but would likely lead to a Time Limit Exceeded (TLE) issue. The time complexity of a basic DFS with backtracking is <span class="math inline">\(O(N * E)\)</span>, where N is the number of nodes and E is the number of edges. This approach is too slow because we may end up revisiting nodes or edges multiple times.</p>
<p>The key to optimizing this is to use postorder DFS, which runs in <span class="math inline">\(O(N + E)\)</span> time. The reason postorder DFS works well for this problem is that:</p>
<ol>
<li>We need to perform a DFS traversal to visit every edge exactly once, and since we are guaranteed an Eulerian path, we know that all edges/pairs will be visited starting from the correct start node.</li>
<li>The crucial part is that we need to ensure that all edges starting from a given node are visited before we append that node to the path. In postorder DFS, we first explore all the neighbors (edges) of a node and only append the node to the path after all its edges have been processed. This guarantees that we follow the correct sequence, ensuring that the traversal respects the rule of visiting all edges from the current node before moving on.</li>
</ol>
<blockquote>
<p>Another way to explain why we use postorder DFS is that when we are at a node <code>u</code> with multiple unvisited outgoing edges, we know we will need to return to <code>u</code> later in the tour to complete the Eulerian path. However, not all outgoing edges will lead back to <code>u</code>, as demonstrated in Example 3 of the problem description. To handle this, we perform a postorder traversal instead of a preorder traversal, ensuring that we visit all outgoing edges before returning to the node.</p>
</blockquote>
<p>Thus, postorder DFS effectively reduces unnecessary work, avoids TLE, and provides the optimal solution. If you're still unsure about the approach, We highly recommend looking at problem <a href="https://leetcode.com/problems/reconstruct-itinerary/description/">332. Reconstruct Itinerary</a>, which involves a similar solution and approach.</p>
<p>Finally, with our ordered path in hand, we construct the final result by pairing each consecutive node in the path as <code>[start, end]</code> pairs.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>adjacencyMatrix</code> as an unordered map of deques to represent the graph (adjacency list).</p>
</li>
<li>
<p>Initialize <code>inDegree</code> and <code>outDegree</code> to track the in-degrees and out-degrees of each node.</p>
</li>
<li>
<p>For each pair in <code>pairs</code>:</p>
<ul>
<li>Extract the <code>start</code> and <code>end</code> values from the pair.</li>
<li>Add <code>end</code> to the adjacency list of <code>start</code> in <code>adjacencyMatrix</code>.</li>
<li>Increment <code>outDegree[start]</code> and <code>inDegree[end]</code>.</li>
</ul>
</li>
<li>
<p>Define a helper function <code>visit(int node)</code> for DFS traversal:</p>
<ul>
<li>While there are outgoing edges from the current node (<code>node</code>):
<ul>
<li>Pop the next node from the adjacency list and recursively call <code>visit</code> on it.</li>
</ul>
</li>
<li>After visiting all outgoing nodes, add the current node to <code>result</code>.</li>
</ul>
</li>
<li>
<p>Find the starting node for the DFS:</p>
<ul>
<li>Search for a node <code>startNode</code> where the out-degree is exactly one greater than the in-degree (<code>outDegree[node] == inDegree[node] + 1</code>).</li>
<li>If no such node exists, use the first element of the first pair as the starting node.</li>
</ul>
</li>
<li>
<p>Perform DFS starting from <code>startNode</code>:</p>
<ul>
<li>Call <code>visit(startNode)</code> to perform the traversal and fill the <code>result</code> array with the nodes in reverse order.</li>
</ul>
</li>
<li>
<p>Reverse the <code>result</code> array to restore the correct order of nodes.</p>
</li>
<li>
<p>Construct the result pairs:</p>
<ul>
<li>For each consecutive pair of nodes in <code>result</code>, add a pair <code>[result[i-1], result[i]]</code> to <code>pairedResult</code>.</li>
</ul>
</li>
<li>
<p>Return <code>pairedResult</code>, which represents the valid arrangement of the input pairs.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZwTwq8nQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of pairs in the input <code>pairs</code>, <span class="math inline">\(V\)</span> be the number of unique vertices in the graph formed by these pairs, and <span class="math inline">\(E\)</span> be the number of edges in the graph, which equals <span class="math inline">\(n\)</span> since each pair represents an edge.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(V + E)\)</span></p>
<p>Building the adjacency list and tracking degrees involves iterating through each pair once. For each pair, we perform constant-time operations to update the adjacency list and degree maps. This step takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>To find the start node, we iterate through the <code>outDegree</code> map, which has at most <span class="math inline">\(V\)</span> entries. For each entry, we perform constant-time operations. This step takes <span class="math inline">\(O(V)\)</span> time.</p>
<p>In the DFS traversal, we visit each edge exactly once. Since there are <span class="math inline">\(E\)</span> edges, the DFS traversal itself takes <span class="math inline">\(O(E)\)</span> time. During the traversal, we perform constant-time operations per edge, like popping from the deque and pushing to the result array.</p>
<p>Reversing the result array takes <span class="math inline">\(O(V)\)</span> time because it contains <span class="math inline">\(V\)</span> vertices. Finally, constructing the result pairs requires iterating through the result array once, performing constant-time operations for each vertex. This step also takes <span class="math inline">\(O(V)\)</span> time.</p>
<p>Overall, the dominant term in the time complexity is <span class="math inline">\(O(V + E)\)</span>. Given that <span class="math inline">\(E = n\)</span>, the time complexity can be expressed as <span class="math inline">\(O(V + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(V + E)\)</span></p>
<p>The adjacency list stores <span class="math inline">\(E\)</span> edges, with each edge stored in a deque associated with a vertex. Thus, the total space used by the adjacency list is <span class="math inline">\(O(V + E)\)</span>.</p>
<p>The degree maps, both <code>inDegree</code> and <code>outDegree</code>, store one entry per unique vertex. Therefore, they take <span class="math inline">\(O(V)\)</span> space.</p>
<p>The result array stores <span class="math inline">\(V\)</span> vertices, requiring <span class="math inline">\(O(V)\)</span> space.</p>
<p>The maximum depth of the recursive stack during DFS is <span class="math inline">\(V\)</span>, so the recursive stack requires <span class="math inline">\(O(V)\)</span> space.</p>
<p>Overall, the space complexity is dominated by the adjacency list, resulting in <span class="math inline">\(O(V + E)\)</span>. Given that <span class="math inline">\(E = n\)</span>, the space complexity can be expressed as <span class="math inline">\(O(V + n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-hierholzers-algorithm-iterative">Approach 2: Hierholzer's Algorithm (Iterative)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To solve the problem iteratively, we follow the same core logic used in the recursive solution but avoid recursion by using a stack for DFS. The key concept stays the same. Start by creating an adjacency list, then find the starting node, and after that, we proceed with iterative DFS.</p>
<p>The idea is to use a stack to manage our current position in the graph. Starting from the identified starting node, we push the node onto the stack. At each step, we check if the current node has any outgoing edges left (i.e., if the adjacency list for that node is non-empty). If it does, we push the next node (taken from the front of the adjacency list) onto the stack. This continues until there are no more outgoing edges to visit from the current node.</p>
<p>If a node has no more outgoing edges, it means we’ve fully explored all edges from that node, so we pop it off the stack and add it to the result list. Since we’re collecting the nodes in reverse order (because we process the last node of each pair first), we need to reverse the result list at the end to get the correct order for the Eulerian path.</p>
<p>Finally, we construct the solution by pairing consecutive nodes in the reversed path. This gives us the correct sequence of pairs where each pair’s <code>end</code> connects to the next pair’s <code>start</code>.</p>
<blockquote>
<p>This algorithm is famously known as Hierholzer's algorithm, named after the German mathematician Carl Hierholzer.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>adjacencyMatrix</code> as an unordered map of deques to represent the graph (adjacency list).</p>
</li>
<li>
<p>Initialize <code>inDegree</code> and <code>outDegree</code> to track the in-degrees and out-degrees of each node.</p>
</li>
<li>
<p>For each <code>pair</code> in <code>pairs</code>:</p>
<ul>
<li>Add the edge to the adjacency list (<code>adjacencyMatrix[start]</code>).</li>
<li>Increment the <code>outDegree</code> of the <code>start</code> node.</li>
<li>Increment the <code>inDegree</code> of the <code>end</code> node.</li>
</ul>
</li>
<li>
<p>Initialize <code>startNode</code> to -1 to store the node from where the traversal should begin.</p>
</li>
<li>
<p>For each node in <code>outDegree</code>:</p>
<ul>
<li>Check if the <code>outDegree</code> is one greater than the <code>inDegree</code> (i.e., <code>outDegree[node] == inDegree[node] + 1</code>):
<ul>
<li>If so, set <code>startNode</code> to this node and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no such <code>startNode</code> is found (i.e., no node with <code>outDegree</code> greater than <code>inDegree</code> by 1), set <code>startNode</code> to the first element of the first pair in <code>pairs</code>.</p>
</li>
<li>
<p>Initialize <code>nodeStack</code> and push <code>startNode</code> onto the stack for DFS traversal.</p>
</li>
<li>
<p>Perform an iterative DFS using the stack:</p>
<ul>
<li>While <code>nodeStack</code> is not empty:
<ul>
<li>Get the <code>top</code> node from the stack.</li>
<li>If the <code>top</code> node has outgoing edges in <code>adjacencyMatrix</code>, push the next node onto the stack.</li>
<li>If there are no outgoing edges left for the <code>top</code> node, add it to the result list and pop it from the stack.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Reverse the <code>result</code> since nodes were added in reverse order during DFS.</p>
</li>
<li>
<p>Construct <code>pairedResult</code> from the reversed <code>result</code>:</p>
<ul>
<li>For each consecutive pair of nodes in <code>result</code>, create a new pair (<code>result[i-1], result[i]</code>) and add it to <code>pairedResult</code>.</li>
</ul>
</li>
<li>
<p>Return <code>pairedResult</code> as the final answer, representing the valid arrangement of pairs.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/LZR5pVwV/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of pairs in the input <code>pairs</code>, <span class="math inline">\(V\)</span> be the number of unique vertices in the graph formed by these pairs, and <span class="math inline">\(E\)</span> be the number of edges in the graph, which equals <span class="math inline">\(n\)</span> since each pair represents an edge.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(V + E)\)</span></p>
<p>Building the adjacency list and tracking in-degrees and out-degrees requires iterating through each pair once. For each pair, we perform constant-time operations to update the adjacency list and the degree maps. This step takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>To find the start node, we iterate through the <code>outDegree</code> map, which has at most <span class="math inline">\(V\)</span> entries. For each entry, we perform constant-time operations. This step takes <span class="math inline">\(O(V)\)</span> time.</p>
<p>The DFS traversal (implemented iteratively with a stack) visits each edge exactly once. Since there are <span class="math inline">\(E\)</span> edges, the DFS traversal itself takes <span class="math inline">\(O(E)\)</span> time. During the traversal, we perform constant-time operations for each edge, such as popping from the deque and pushing to the result array.</p>
<p>Reversing the result array takes <span class="math inline">\(O(V)\)</span> time, as it contains <span class="math inline">\(V\)</span> vertices. Constructing the result pairs involves iterating through the result array once, performing constant-time operations for each vertex. This step also takes <span class="math inline">\(O(V)\)</span> time.</p>
<p>Overall, the dominant term in the time complexity is <span class="math inline">\(O(V + E)\)</span>. Since <span class="math inline">\(E = n\)</span>, the time complexity can also be expressed as <span class="math inline">\(O(V + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(V + E)\)</span></p>
<p>The adjacency matrix stores <span class="math inline">\(E\)</span> edges, with each edge stored in a deque associated with a vertex. The total space used by the adjacency matrix is <span class="math inline">\(O(V + E)\)</span>.</p>
<p>The <code>inDegree</code> and <code>outDegree</code> maps store one entry per unique vertex. Thus, both maps together take <span class="math inline">\(O(V)\)</span> space.</p>
<p>The <code>result</code> array stores <span class="math inline">\(V\)</span> vertices, which require <span class="math inline">\(O(V)\)</span> space.</p>
<p>The maximum depth of the stack during the DFS traversal is <span class="math inline">\(V\)</span>, as it corresponds to the number of vertices. Thus, the stack uses <span class="math inline">\(O(V)\)</span> space.</p>
<p>Overall, the space complexity is dominated by the adjacency matrix, resulting in <span class="math inline">\(O(V + E)\)</span>. Since <span class="math inline">\(E = n\)</span>, the space complexity can be expressed as <span class="math inline">\(O(V + n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-249">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/validate-binary-tree-nodes/description" target="_blank" rel="noopener noreferrer">Validate Binary Tree Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> binary tree nodes numbered from <code>0</code> to <code>n - 1</code> where node <code>i</code> has two children <code>leftChild[i]</code> and <code>rightChild[i]</code>, return <code>true</code> if and only if <strong>all</strong> the given nodes form <strong>exactly one</strong> valid binary tree.</p>

<p>If node <code>i</code> has no left child then <code>leftChild[i]</code> will equal <code>-1</code>, similarly for the right child.</p>

<p>Note that the nodes have no values and that we only use the node numbers in this problem.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png" style="width: 195px; height: 287px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png" style="width: 183px; height: 272px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png" style="width: 82px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 2, leftChild = [1,0], rightChild = [-1,-1]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == leftChild.length == rightChild.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Before we go into the approaches, let's first talk about what makes a binary tree valid.</p>
<blockquote>
<p>Note that while this is not a formal definition of a binary tree, these rules are sufficient for solving the problem.</p>
</blockquote>
<p><strong>A binary tree must have a root. This is a node with no incoming edges - that is, the root has no parent.</strong></p>
<p><img src="../Figures/1361/1.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p><img src="../Figures/1361/2.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>The tree must be connected - every node must be reachable from one node (the root).</strong></p>
<p><img src="../Figures/1361/3.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>There cannot be a cycle.</strong></p>
<p><img src="../Figures/1361/4.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p>To solve this problem, we can check the nodes given to us against these rules.</p>
<blockquote>
<p>You may notice that some of these rules imply each other. For example, if a binary tree had a root, it would have a cycle only if it was not connected, or there was a node with more than one parent.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
</blockquote>
<p>One way to solve this problem would be to perform a DFS on the tree and check that all the rules are followed. Before we can start a DFS, we need to locate the root. Let's define a function <code>findRoot</code> that helps us find the root.</p>
<p>As mentioned above, the root has no parent - this also means that the root is not the child of any nodes. The input arrays <code>leftChild</code> and <code>rightChild</code> describe all children, so the root would not appear in these arrays. We can simply use a for loop from <code>0</code> to <code>n - 1</code> and for each number, check if it is present in <code>leftChild</code> or <code>rightChild</code>. If it's not present in either, then we can return it as the root. If we don't find any root, we can return <code>-1</code>.</p>
<p>To improve efficiency, we will convert <code>leftChild</code> and <code>rightChild</code> to a set for <span class="math inline">\(O(1)\)</span> checks.</p>
<p><a href="https://leetcode.com/playground/iV5vT2dM/shared">code</a></p>
<p>We will start by obtaining <code>root = findRoot()</code>. If <code>root = -1</code>, there is no node without a parent, and we can immediately return false as the tree is invalid.</p>
<p>Once we have the root, we can start a DFS from it. We will implement the DFS iteratively with a stack. How can we validate the tree? First of all, if we see a node multiple times during the DFS, it means a node has multiple parents (and there could be a cycle). We will use a set <code>seen</code> that keeps track of all the nodes we have seen so far during the traversal. When we move to a <code>child</code>, if <code>child</code> is already in <code>seen</code>, we can immediately return false since we would be visiting <code>child</code> for the second time.</p>
<p>Once the DFS finishes, every node we visited will be in <code>seen</code>. If the tree is connected, then the length of <code>seen</code> will be equal to <code>n</code>. If <code>seen.length != n</code>, it means that some nodes were not visited, and thus the tree must be disconnected. Thus, we can return <code>seen.length == n</code> at the end of the algorithm.</p>
<p>This process is sufficient in validating a binary tree:</p>
<ol>
<li>If a binary tree does not have a root, then <code>findRoot</code> will return <code>-1</code>.</li>
<li>If there is a node with more than one parent, then we will detect it with <code>seen</code>.</li>
<li>If the tree is disconnected, then <code>seen</code> will hold less than <code>n</code> nodes at the end.</li>
<li>If there is a cycle, then we will detect it with <code>seen</code>.</li>
</ol>
<p>Any other scenario we don't explicitly check for will be caught by some other rule. For example, the second rule we stated was:</p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p>You may be thinking: we are explicitly checking the case when a node has multiple parents with <code>seen</code>, but what if there is a node with no parent other than the <code>root</code>? That is, what if there are multiple roots? In that scenario, <code>findRoot</code> would give us the root with the lowest value. We would perform a DFS from there, and never reach any of the other roots. Then at the end, <code>seen</code> would have less than <code>n</code> nodes.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>stack</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop the top of the stack as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the stack and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the DFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/W65UxZEa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a DFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>stack</code> and <code>seen</code> during the DFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes an interviewer may ask you to implement both BFS and DFS. This approach is the same as the previous one, except we will use BFS to perform the traversal instead of DFS.</p>
<p>BFS uses a queue instead of a stack. If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>queue</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Pop the front of the queue as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the queue and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the BFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8LE3ZeZN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a BFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once. Note that an efficient queue implementation with <span class="math inline">\(O(1)\)</span> operations is required to achieve this complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>queue</code> and <code>seen</code> during the BFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union Find</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This is a more advanced, but interesting way to approach this problem. We have included it for the sake of completeness. It is unlikely you will be expected to implement this approach in an interview if you have already used one of the previous approaches, so we will not delve into great detail in this approach.</p>
</blockquote>
<p>A disjoint-set data structure (also called a union–find), is a data structure that stores a collection of disjoint (non-overlapping) sets. Union-find provides us with the following methods:</p>
<ol>
<li><code>find</code>: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.</li>
<li><code>union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Leetcode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Initially, all nodes belong to their own subset. We will iterate over all <code>(parent, child)</code> pairs given in <code>leftChild</code> and <code>rightChild</code> and attempt a <code>union</code>. We want to assign the subset of <code>child</code> to the subset of <code>parent</code>. For each call to <code>union(parent, child)</code>, we can see if the tree is invalid with the following checks:</p>
<ol>
<li>If <code>find(child) != child</code>, then <code>child</code> must have been assigned a parent earlier, and thus <code>child</code> has multiple parents.</li>
<li>If <code>parent</code> and <code>child</code> already belong to the same subset, then there must be a directed path from <code>child</code> to <code>parent</code> as <code>parent</code> must have been assigned to the subset of <code>child</code> earlier, and thus there exists a cycle.</li>
</ol>
<p>After performing all <code>union</code> operations successfully between parents and their children, there should only be one component in the union-find data structure. We can track the number of components by subtracting one from the count on each successful <code>union</code> operation, and then check whether the final count of components is equal to 1.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a union-find data structure <code>uf</code> that implements <code>find(node)</code> and <code>union(parent, child)</code>. It should also track the number of <code>components</code>.
<ul>
<li>In <code>union</code>, we return a boolean indicating if the union was successful. A union is unsuccessful if the parent of <code>child</code> is not <code>child</code>, or the parent of <code>parent</code> is <code>child</code>.</li>
<li>If <code>union</code> is successful, we assign the subset of <code>child</code> to the subset of <code>parent</code> and decrement the number of <code>components</code>.</li>
</ul>
</li>
<li>Iterate <code>node</code> from <code>0</code> until <code>n</code>:
<ul>
<li>Iterate over the children of <code>node</code> as <code>child</code>:
<ul>
<li>If <code>child == - 1</code>, ignore it.</li>
<li>Otherwise, perform a <code>union(node, child)</code>. If it returns false, then <code>return false</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>uf.components == 1</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note: In C++, <code>union</code> is a reserved keyword and cannot be redefined. Therefore, we need to rename the <code>union</code> method, and we call it <code>join</code> here.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/c33bCEGR/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>For <span class="math inline">\(T\)</span> operations, the amortized time complexity of the union-find algorithm with path compression and union-by rank is <span class="math inline">\(O(\alpha(T))\)</span>. Here, <span class="math inline">\(\alpha(T)\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(T\)</span> (approximately <span class="math inline">\( T < 10^{600}\)</span>). You can read more about the complexity of union-find <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity">here</a>. Because the function grows so slowly, we consider it to be <span class="math inline">\(O(1)\)</span>.</p>
<p>You may have noticed that we didn't use union-by-rank optimization as in other DSU problems. The reason for this is that the structure of this problem is not like a regular graph. More specifically, if a pair of nodes <code>(parent, child)</code> is considered valid for union, only the eligible tree root node is considered as the new child, and it will always have a rank of 0. Therefore, during the union process, the rank of all nodes will not exceed 1. As for the possibility of nodes having a rank greater than 1, it would be filtered out as required by the problem statement and won't occur. Therefore, we don't need to use union-by-rank in this problem. We encourage readers to build test cases and try them out.</p>
<p>Initializing the <code>UnionFind</code> data structure costs <span class="math inline">\(O(n)\)</span>. Then, we simply iterate over each node once and perform some union-find operations at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>UnionFind</code> data structure keeps a <code>parents</code> array that takes <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-250">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/villain-con0511/1" target="_blank" rel="noopener noreferrer">Villain Con</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">The minions are very elitist in nature. If minion x admires minion y, then y thinks too highly of himself and does not admire x back. Also, if x admires y, x also admires everyone that y admires.<br />
All the&nbsp;minions are going to be present at the Villain Con. They want&nbsp;to make sure that they do not dress in the&nbsp;same color as someone who admires them.&nbsp;<br />
There are <strong>N</strong> minions and <strong>M</strong> relations between them. The relations are given in a 2D array <strong>mat</strong>. Each relation is given in x<sub>i</sub>&nbsp;, y<sub>i</sub>&nbsp;format where y<sub>i</sub>&nbsp;admires x<sub>i. </sub>Find the minimum number of different colours that the minions will be dressing in.&nbsp;</span></p>

<p>&nbsp;</p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
N = 5, M = 6
mat = {{1, 3}, 
&nbsp;      {2, 3}, 
&nbsp;      {3, 4}, 
&nbsp;      {1, 4}, 
&nbsp;      {2, 5}, 
&nbsp;      {3, 5}}
<strong>Output:</strong> 3
<strong>Explaination:
</strong>If we assign red colour to 1 and 2,
green colour to 3, and blue colour to 4 and 5, then
every minion will have different coloured dresses
from the one who admires them.</span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:
</span></strong><span style="font-size:18px">N = 3, M = 2
mat = {{1,3},{2,3}}</span><strong><span style="font-size:18px">
Output:
</span></strong><span style="font-size:18px">2</span><strong><span style="font-size:18px">
Explanation:
</span></strong><span style="font-size:18px">If we assign red colour to 1 and 2, and green colour to 3, then the condition is satisfied.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You do not need to read input or print anything. Your task is to complete the function <strong>minColour()</strong> which takes N, M and mat[][] as input parameters and returns the minimum number of colours required.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N+M)<br />
<strong>Expected Auxiliary Space:</strong> O(N+M)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<sup>5</sup><br />
1 &le; M &le; 2*10<sup>5</sup>&nbsp;&nbsp;<br />
1 &le; x<sub>i</sub> , y<sub>i</sub> &le; N</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-251">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/water-connection-problem5822/1" target="_blank" rel="noopener noreferrer">Water Connection Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">There are n houses and p water pipes in Geek Colony. Every house has at most one pipe going into it and at most one pipe going out of it. Geek needs to install pairs of tanks and taps in the colony according to the following guidelines. &nbsp;<br />
1. Every house with one outgoing pipe but no incoming pipe gets a tank on its roof.<br />
2. Every house with only one incoming and no outgoing pipe gets a tap.<br />
The Geek council has proposed a network of pipes where connections are denoted by three input values: ai, bi, di denoting the pipe of diameter di from house ai to house bi.<br />
Find a more efficient way for the construction of this network of pipes. Minimize the diameter of pipes wherever possible.<br />
<strong>Note</strong>: The generated output will have the following format. The first line will contain t, denoting the total number of pairs of tanks and taps installed. The next t lines contain three integers each: house number of tank, house number of tap, and the minimum diameter of pipe between them</span><span style="font-size:18px">.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 9, p = 6
a[] = {7,5,4,2,9,3}
b[] = {4,9,6,8,7,1}
d[] = {98,72,10,22,17,66} 
<strong>Output:</strong> 
3
2 8 22
3 1 66
5 6 10
<strong>Explanation:</strong>
Connected components are 
<strong><em>3-&gt;1, 5-&gt;9-&gt;7-&gt;4-&gt;6 and 2-&gt;8</em></strong>.
Therefore, our answer is<strong> 3</strong> 
followed by <strong>2 8 22, 3 1 66, 5 6 10.</strong></span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>solve()</strong>&nbsp;which takes an integer n(the number of houses), p(the number of pipes),the&nbsp;array a[] , b[] and&nbsp;d[] (where&nbsp;<strong>d[i]&nbsp;</strong>denoting the diameter of the ith pipe from the house <strong>a[i]</strong> to house <strong>b[i]</strong>) as input parameter and returns the array of&nbsp;pairs of tanks and taps installed i.e ith element of the array&nbsp;contains three integers: house number of tank, house number of tap and the minimum diameter of pipe between them. Note that, returned array <strong>must be sorted based on the house number&nbsp;containing a tank</strong> (i.e. smaller house number should come before a large house number).</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(n+p)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(n+p)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=n&lt;=20<br />
1&lt;=p&lt;=50<br />
1&lt;=a[i],b[i]&lt;=20<br />
1&lt;=d[i]&lt;=100</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-252">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-boggle4143/1" target="_blank" rel="noopener noreferrer">Word Boggle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">recursion</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a dictionary of distinct <strong>words</strong> and an <strong>M x N</strong> board where every cell has one character. Find all possible words from the dictionary that can be formed by a sequence of adjacent characters on the board. We can move to any of 8 adjacent characters</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;While forming a word we can move to&nbsp;any of the 8 adjacent cells. A&nbsp;cell can be used&nbsp;only once in one word.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>N = 1
dictionary = {"CAT"}
R = 3, C = 3
board = {{C,A,P},{A,N,D},{T,I,E}}
<strong>Output:</strong>
CAT
<strong>Explanation</strong>: 
<span style="color: #800080;">C</span> A P
<span style="color: #800080;">A</span> N D
<span style="color: #800080;">T</span> I E
Words we got is denoted using same color.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 4
dictionary = {"GEEKS","FOR","QUIZ","GO"}
R = 3, C = 3 
board = {{G,I,Z},{U,E,K},{Q,S,E}}
<strong>Output:</strong>
GEEKS QUIZ
<strong>Explanation</strong>: 
<span style="color: #ff8c00;">G</span> <span style="color: #0000cd;">I</span> <span style="color: #0000cd;">Z</span>
<span style="color: #0000cd;">U</span> <span style="color: #ff8c00;">E</span> <span style="color: #ff8c00;">K</span>
<span style="color: #0000cd;">Q</span> <span style="color: #ff8c00;">S</span> <span style="color: #ff8c00;">E</span> 
Words we got is denoted using same color.</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your task:</strong><br />You dont need to read input or print anything. Your task is to complete the function&nbsp;<strong>wordBoggle()</strong>&nbsp;which takes the dictionary contaning N&nbsp;space-separated strings and R*C board </span><span style="font-size: 18px;">as input parameters and returns a list of&nbsp;words that exist on the board in <strong>lexicographical order</strong>.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(N*W + R*C^2)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*W + R*C)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N&nbsp;&le; 15<br />1 &le; R, C&nbsp;&le; 50<br />1 &le; length of Word&nbsp;&le; 60<br />Each word can consist of both lowercase and uppercase letters.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-253">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-ladder/1" target="_blank" rel="noopener noreferrer">Word Ladder I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two distinct words <strong>startWord</strong> and <strong>targetWord</strong>, and a list&nbsp;denoting <strong>wordList</strong>&nbsp;of unique words of equal lengths. Find the length of the shortest transformation sequence from startWord to targetWord.<br />Keep&nbsp;the following conditions in mind:</span></p>
<ul>
<li><span style="font-size: 18px;">A word can only consist of lowercase characters.</span></li>
<li><span style="font-size: 18px;">Only one letter can be changed in each transformation.</span></li>
<li><span style="font-size: 18px;">Each transformed word must exist in the wordList including the targetWord.</span></li>
<li><span style="font-size: 18px;">startWord may or may not be part of the&nbsp;wordList</span></li>
</ul>
<p><span style="font-size: 18px;">The second part of this problem can be found <a href="https://practice.geeksforgeeks.org/problems/word-ladder-ii/1/">here</a>.</span></p>
<p><span style="font-size: 18px;"><strong>Note</strong>: If no possible way to&nbsp;transform&nbsp;sequence from startWord to targetWord <strong>return 0</strong></span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
wordList = {"des","der","dfr","dgt","dfs"}
startWord = "der", targetWord= "dfs",
<strong>Output:
</strong>3
<strong>Explanation:
</strong>The length of the smallest transformation
sequence from "der" to "dfs" is 3
i,e "der" -&gt; "dfr" -&gt; "dfs".
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
wordList = {"geek", "gefk"}
startWord = "gedk", targetWord= "geek", 
<strong>Output:
</strong>2
<strong>Explanation:
</strong>gedk -&gt; geek</span></pre>
<p><strong><span style="font-size: 18px;">Example 3:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>
wordList = {"poon", "plee", "same", "poie","plea","plie","poin"}
startWord = "toon", targetWord= "plea",
<strong>Output: </strong>7 
<strong>Explanation:
</strong>toon -&gt; poon -&gt; poin -&gt; poie -&gt; plie -&gt; plee -&gt; plea </span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;<strong>wordLadderLength()&nbsp;</strong>which takes startWord, targetWord and wordList as input parameter and returns the&nbsp;length of the shortest transformation sequence from startWord to targetWord. If not possible return&nbsp;0.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Compelxity:&nbsp;</strong>O(N<sup>2</sup>&nbsp;* M)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N * M) where N = length of wordList and M = |wordList<sub>i</sub>|</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 100<br />1 &le; M &le; 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-254">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-ladder-ii/1" target="_blank" rel="noopener noreferrer">Word Ladder II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two distinct words <strong>startWord</strong> and <strong>targetWord</strong>, and a list&nbsp;denoting <strong>wordList</strong>&nbsp;of unique words of equal lengths. </span> <span style="font-size: 18px;">Find all shortest transformation sequence(s) from startWord to targetWord. You can return them in any order possible.</span><br /><span style="font-size: 18px;">Keep&nbsp;the following conditions in mind:</span></p>
<ul>
<li><span style="font-size: 18px;">A word can only consist of lowercase characters.</span></li>
<li><span style="font-size: 18px;">Only one letter can be changed in each transformation.</span></li>
<li><span style="font-size: 18px;">Each transformed word must exist in the wordList including the targetWord.</span></li>
<li><span style="font-size: 18px;">startWord may or may not be part of the&nbsp;wordList.</span><span style="font-size: 18px;"> </span></li>
<li><span style="font-size: 18px;">Return an empty list if there is no such transformation sequence.</span></li>
</ul>
<p><span style="font-size: 18px;">The first part of this problem can be found <a href="https://practice.geeksforgeeks.org/problems/word-ladder/1/">here</a>.</span></p>
<p><br /><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">startWord = "der", targetWord = "dfs",
wordList = {"des","der","dfr","dgt","dfs"}
<strong>Output:
</strong>der dfr dfs
der des dfs
<strong>Explanation:
</strong>The length of the smallest transformation is 3.
And the following are the only two ways to get
to targetWord:-
"der" -&gt; "des" -&gt; "dfs".</span>
<span style="font-size: 18px;">"der" -&gt; "dfr" -&gt; "dfs".</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>startWord = "gedk", targetWord = "geek", 
wordList = {"geek", "gefk"}
<strong>Output:
</strong>"gedk" -&gt; "geek"</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;findSequences<strong>()&nbsp;</strong>which takes startWord, targetWord and wordList as input parameter and returns a list of list of strings of the shortest transformation sequence from startWord to targetWord.<br /><strong>Note: </strong>You don't have to return -1 in case of no possible sequence. Just return the Empty List.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Compelxity:&nbsp;</strong>O(N*(logN * M * 26))<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N * M) where N = length of wordList and M = |wordList<sub>i</sub>|</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 100<br />1 &le; M &le; 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-255">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-search/1" target="_blank" rel="noopener noreferrer">Word Search</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a <strong>two-dimensional</strong> <strong>mat[][]</strong> of <strong>size n*m</strong> containing English alphabets and a string <strong>word</strong>. Check if the word exists on the mat. The word can be constructed by using letters from <strong>adjacent</strong> cells, either horizontally or vertically. The same cell cannot be used more than <strong>once</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [['T', 'E', 'E'], ['S', 'G', 'K'], ['T', 'E', 'L']], word = "GEEK"
<strong>Output: </strong>true
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886266/Web/Other/blobid4_1737981964.png" alt="" width="220" height="200" /><br />The letter cells which are used to construct the "GEEK" are colored.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [['T', 'E', 'U'], ['S', 'G', 'K'], ['T', 'E', 'L']], word = "GEEK"
<strong>Output: </strong>false
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886266/Web/Other/blobid5_1737981964.png" alt="" width="220" height="199" /><br />It is impossible to construct the string word from the mat using each cell only once.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [['A', 'B', 'A'], ['B', 'A', 'B']], word = "AB"
<strong>Output: </strong>true
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886266/Web/Other/blobid6_1737981964.png" alt="" width="222" height="184" /><br />There are multiple ways to construct the word "AB".</span></pre>
<p><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Constraints:</strong><br /><span style="font-size: 14pt;">1 &le; n, m &le; 6</span><br /><span style="font-size: 14pt;">1 &le; L &le; 15</span><br /><span style="font-size: 18.6667px;">mat and word consists of only lowercase and uppercase English letters.</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-256">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/x-total-shapes3617/1" target="_blank" rel="noopener noreferrer">X Total Shapes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given&nbsp; a grid of <strong>n</strong>*<strong>m</strong>&nbsp;consisting<strong>&nbsp;</strong>of <strong>O<code>'s</code></strong>&nbsp;and <strong>X<code>'s</code></strong>. The task is to find the number of '<strong>X</strong>' total shapes.<br /><strong>Note:&nbsp;</strong>'<strong>X</strong>' shape consists of one or more adjacent <strong>X</strong><code>'s</code>&nbsp;(diagonals not included).</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{X,O,X},{O,X,O},{X,X,X}}
<strong>Output: </strong>3
<strong>Explanation: 
</strong>The grid is-
<span style="color: #ee82ee;"><strong>X</strong></span> O <span style="color: #ff8c00;"><strong>X</strong></span>
O <span style="color: #00ff00;"><strong>X</strong></span> O
<strong><span style="color: #00ff00;">X</span> <span style="color: #00ff00;">X</span> <span style="color: #00ff00;">X</span>
</strong>So, X with same colour are adjacent to each 
other vertically for horizontally (diagonals 
not included). So, there are 3 different groups 
in the given grid.</span>

</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{X,X},{X,X}}
<strong>Output: </strong>1
<strong>Expanation: 
</strong>The grid is- 
<span style="color: #ee82ee;"><strong>X</strong></span> <span style="color: #ee82ee;"><strong>X</strong></span>
<strong><span style="color: #ee82ee;">X</span> <span style="color: #ee82ee;">X</span></strong>
So, X with same colour are adjacent to each
other vertically for horizontally (diagonals
not included). So, there is only 1 group
in the given grid.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function <strong>xShape()&nbsp;</strong>which takes grid as input parameter and returns the count of total X shapes.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Compelxity:&nbsp;</strong>O(n*m)<br /><strong>Expected Space Compelxity:&nbsp;</strong>O(n*m)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m&nbsp;&le; 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-257">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/your-social-network0328/1" target="_blank" rel="noopener noreferrer">Your Social Network</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Influenced by Social Networking sites, Rahul launches his own site&nbsp;Friendsbook. Each user in Friendsbook is given a unique number, first user being numbered 1. There are N users in Friendsbook numbered from 1 to N. In Friendsbook, i th user can make j th user his friend without becoming his friend himself, i.e. in Friendsbook, there is a one-way link rather than a two-way link as in Facebook. Moreover i th user can make j th user his friend iff i&gt;j. Also one user should have no more and no less than one friend except user 1 who will have no friend. Rahul wants to modify Friendsbook and find out whether one user is somehow linked to some other user. Help Rahul do so.</span></p>

<p><span style="font-size:18px">Print all possible connections between the users in the following format:&nbsp;<br />
4 2 2 means 4 is linked to 2 via 2 connections.<br />
5 2 3 means 5 is linked to 2 via 3 connections, and so on.</span></p>

<p><span style="font-size:18px">The order of display should be as follows:</span><br />
<span style="font-size:18px">Print all possible connections starting from user 2 to user N with other users starting from 1 to The Current User Number - 1. In case one user is not connected at all with another user, that connection should not be printed.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong></span>
<span style="font-size:18px"><strong>N = </strong>3</span>
<span style="font-size:18px"><strong>arr[] = </strong>{1, 2}</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">2 1 1 3 1 2 3 2 1
<strong>Explanation:</strong></span>
<span style="font-size:18px">2 is directly linked to 1 and hence 2 is
linked to 1 via 1 connection. 3 is directly
linked to 2 which in turn is directly
linked to 1. Hence 3 is linked to 1 via 
2 connections and to 2 via 1 connection.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong></span>
<span style="font-size:18px"><strong>N = </strong>3</span>
<span style="font-size:18px"><strong>arr[] = </strong>{1, 1}</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">2 1 1 3 1 1
<strong>Explanation:</strong></span>
<span style="font-size:18px">Both 2 and 3 are directly linked to 1.
Hence both 2 and 3 are linked to 1 via
1 connection.</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>socialNetwork()</strong> which takes an Integer N and an array arr[] of N-1 integers as input and returns s string representing the answer.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>)<br />
<strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span><br />
<span style="font-size:18px">2 &lt;= N &lt;= 500</span><br />
<span style="font-size:18px">1 &lt;= arr[i] &lt;= i</span></p>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>