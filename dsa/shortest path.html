<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shortest path - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>shortest path</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">35</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Cheapest Flights Within K Stops</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-1" class="toc-link">Cheapest Flights Within K Stops</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">City With the Smallest Number of Neighbors at a Threshold Distance</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-3" class="toc-link">Design Graph With Shortest Path Calculator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Digit Operations to Make Two Integers Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Evaluate Division</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Find a Safe Walk Through a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Find Edges in Shortest Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Find Minimum Time to Reach Last Room I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Find Minimum Time to Reach Last Room II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Find the City With the Smallest Number of Neighbors at a Threshold Distance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Minimize the Maximum Edge Weight of Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Minimum Cost of a Path With Special Roads</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Minimum Cost to Convert String I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Minimum Cost to Convert String II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Minimum Cost to Make at Least One Valid Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Minimum Obstacle Removal to Reach Corner</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Minimum Time to Reach Destination in Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Minimum Time to Transport All Individuals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Minimum Time to Visit a Cell In a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Minimum Time to Visit Disappearing Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Minimum Weighted Subgraph With the Required Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Modify Graph Edge Weights</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Network Delay Time</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Network Recovery Pathways</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Number of Possible Sets of Closing Branches</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Number of Restricted Paths From First to Last Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Number of Ways to Arrive at Destination</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-28" class="toc-link">Number of Ways to Arrive at Destination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Path with Maximum Probability</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Reachable Nodes In Subdivided Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Second Minimum Time to Reach Destination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Shortest path from 1 to n</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-33" class="toc-link">Shortest path in Directed Acyclic Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-34" class="toc-link">Shortest Path Using Atmost One Curved Edge</a> <span class="toc-platform">GeeksForGeeks</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/cheapest-flights-within-k-stops/1" target="_blank" rel="noopener noreferrer">Cheapest Flights Within K Stops</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">queue</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are&nbsp;<code>n</code>&nbsp;cities and m edges connected by some number of flights. You are given an array&nbsp;<code>flights</code>&nbsp;where&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code>&nbsp;indicates that there is a flight from the city&nbsp;<code>from<sub>i</sub></code>&nbsp;to city&nbsp;<code>to<sub>i</sub></code>&nbsp;with cost&nbsp;<code>price<sub>i</sub></code>.</span></p>
<p><span style="font-size: 18px;">You are also given three integers&nbsp;<code>src</code>,&nbsp;<code>dst</code>, and&nbsp;<code>k</code>, return&nbsp;<em><strong>the cheapest price</strong>&nbsp;from&nbsp;</em><code>src</code><em>&nbsp;to&nbsp;</em><code>dst</code><em>&nbsp;with at most&nbsp;</em><code>k</code><em>&nbsp;stops.&nbsp;</em>If there is no such route, return<em>&nbsp;</em><code>-1</code>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note</strong>: The price from city A to B may be different From the price from city B to A. </span></p>
<pre><span style="font-size: 18px;"><strong>Example 1:</strong>
<strong>Input:</strong>
n = 4
flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]
src = 0
dst = 3
k = 1
<strong>Output:</strong>
700
Explanation:
</span><span style="font-size: 18px;">The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br /><code>1 &lt;= n &lt;= 100<br />
0 &lt;= flights.length &lt;= (n * (n - 1) / 2)<br />
flights[i].length == 3<br />
0 &lt;= from<sub>i</sub>, to<sub>i</sub>&nbsp;&lt; n<br />
from<sub>i</sub>&nbsp;!= to<sub>i</sub><br />
1 &lt;= price<sub>i</sub>&nbsp;&lt;= 10<sup>4</sup></code><br />There will not be any multiple flights between the two cities.<br /><code>0 &lt;= src, dst, k &lt; n<br />
src != dst</code></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cheapest-flights-within-k-stops/description" target="_blank" rel="noopener noreferrer">Cheapest Flights Within K Stops</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities connected by some number of flights. You are given an array <code>flights</code> where <code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> indicates that there is a flight from city <code>from<sub>i</sub></code> to city <code>to<sub>i</sub></code> with cost <code>price<sub>i</sub></code>.</p>

<p>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return <em><strong>the cheapest price</strong> from </em><code>src</code><em> to </em><code>dst</code><em> with at most </em><code>k</code><em> stops. </em>If there is no such route, return<em> </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-3drawio.png" style="width: 332px; height: 392px;" />
<pre>
<strong>Input:</strong> n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1
<strong>Output:</strong> 700
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-1drawio.png" style="width: 332px; height: 242px;" />
<pre>
<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
<strong>Output:</strong> 200
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-2drawio.png" style="width: 332px; height: 242px;" />
<pre>
<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
<strong>Output:</strong> 500
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>
	<li><code>flights[i].length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>There will not be any multiple flights between two cities.</li>
	<li><code>0 &lt;= src, dst, k &lt; n</code></li>
	<li><code>src != dst</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/1" target="_blank" rel="noopener noreferrer">City With the Smallest Number of Neighbors at a Threshold Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are <strong>n</strong> cities labeled from 0 to n-1 with <strong>m </strong>edges connecting them. Given the array <strong>edges</strong>&nbsp;where <strong>edges[i] = [from<sub>i&nbsp;</sub>, to<sub>i ,</sub>weight<sub>i</sub>]<sub>&nbsp;</sub></strong>&nbsp;represents a <strong>bidirectional </strong>and <strong>weighted edge </strong>between cities <strong>from<sub>i</sub>&nbsp;</strong>and <strong>to<sub>i</sub></strong>, and given the integer <strong>distanceThreshold</strong>. You need to find out a city with the <strong>smallest number </strong>of cities that are reachable through some path and whose distance is&nbsp;<strong>at most</strong>&nbsp;<strong>Threshold Distance.</strong>&nbsp;If there are multiple such cities, our answer will&nbsp;be the city with the <strong>greatest label</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> The distance of a path connecting cities <em><strong>i</strong></em>&nbsp;and&nbsp;<em><strong>j</strong></em> is equal to the sum of the edge's weights along that path.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">n = 4, m = 4</span>
<span style="font-size: 18px;">edges = [[0, 1, 3],<br />         [1, 2, 1], <br />         [1, 3, 4],  <br />         [2, 3, 1]]</span>
<span style="font-size: 18px;">distanceThreshold = 4</span>
<strong><span style="font-size: 18px;">Output:<br /></span></strong><span style="font-size: 18px;">3</span>
<strong><span style="font-size: 18px;">Explaination:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid1_1745300064.jpg" width="278" height="278" /><br /></span></strong><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -&gt; [City 1, City 2]&nbsp;
City 1 -&gt; [City 0, City 2, City 3]&nbsp;
City 2 -&gt; [City 0, City 1, City 3]&nbsp;
City 3 -&gt; [City 1, City 2]&nbsp;
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input:&nbsp;</span></strong><span style="font-size: 18px;"><span style="font-size: 18px;"><br />n = 5, m = 6<br />edges = [[0, 1, 2],
         [0, 4, 8],<br />         [1, 2, 3], <br />         [1, 4, 2], <br />         [2, 3, 1],<br />         [3, 4, 1]]<br />distanceThreshold = 2.<br /></span></span><span style="font-size: 18px;"><strong style="font-size: 18px;">Output:<br /></strong><span style="font-size: 18px;">0<br /></span><strong style="font-size: 18px;">Explaination:<br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid2_1745300084.jpg" width="320" height="320" /><br /><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -&gt; [City 1] 
City 1 -&gt; [City 0, City 4] 
City 2 -&gt; [City 3, City 4] 
City 3 -&gt; [City 2, City 4]
City 4 -&gt; [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.<br /></span></span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong><br /><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>findCity( )&nbsp;</strong>which takes a number of nodes <strong>n, </strong>total number of edges <strong>m</strong>&nbsp;and vector of <strong>edges</strong> and <strong>distanceThreshold</strong>. and return the city with the smallest number of cities that are reachable through some path and whose distance is <strong>at most</strong> Threshold Distance. If there are multiple such cities, return the city with the greatest label.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup> + length(edges)*nlog(n) )</span><br /><span style="font-size: 18px;"><strong>Expected Auxiliary Space:&nbsp;&nbsp;</strong>O(n<sup>3</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&nbsp; &le;&nbsp; n &le;&nbsp; 100<br />1 &lt;= m &lt;= n*(n-1)/2<br />length(edges[i]) == 3<br />0 &lt;= from<sub>i&nbsp;</sub>&lt; to<sub>i</sub>&nbsp;&lt; n<br />1 &lt;= weight<sub>i </sub>distanceThreshold &lt;= 10<sup>4</sup><br />All pairs (from<sub>i</sub>, to<sub>i</sub>) are distinct</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-graph-with-shortest-path-calculator/description" target="_blank" rel="noopener noreferrer">Design Graph With Shortest Path Calculator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed weighted</strong> graph that consists of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The edges of the graph are initially represented by the given array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, edgeCost<sub>i</sub>]</code> meaning that there is an edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with the cost <code>edgeCost<sub>i</sub></code>.</p>

<p>Implement the <code>Graph</code> class:</p>

<ul>
	<li><code>Graph(int n, int[][] edges)</code> initializes the object with <code>n</code> nodes and the given edges.</li>
	<li><code>addEdge(int[] edge)</code> adds an edge to the list of edges where <code>edge = [from, to, edgeCost]</code>. It is guaranteed that there is no edge between the two nodes before adding this one.</li>
	<li><code>int shortestPath(int node1, int node2)</code> returns the <strong>minimum</strong> cost of a path from <code>node1</code> to <code>node2</code>. If no path exists, return <code>-1</code>. The cost of a path is the sum of the costs of the edges in the path.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png" style="width: 621px; height: 191px;" />
<pre>
<strong>Input</strong>
[&quot;Graph&quot;, &quot;shortestPath&quot;, &quot;shortestPath&quot;, &quot;addEdge&quot;, &quot;shortestPath&quot;]
[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
<strong>Output</strong>
[null, 6, -1, null, 6]

<strong>Explanation</strong>
Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -&gt; 0 -&gt; 1 -&gt; 2 with a total cost of 3 + 2 + 1 = 6.
g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.
g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -&gt; 1 -&gt; 3 with a total cost of 2 + 4 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>
	<li><code>edges[i].length == edge.length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, from, to, node1, node2 &lt;= n - 1</code></li>
	<li><code>1 &lt;= edgeCost<sub>i</sub>, edgeCost &lt;= 10<sup>6</sup></code></li>
	<li>There are no repeated edges and no self-loops in the graph at any point.</li>
	<li>At most <code>100</code> calls will be made for <code>addEdge</code>.</li>
	<li>At most <code>100</code> calls will be made for <code>shortestPath</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Imagine you're tasked with navigating a complex web of interconnected locations, each with its unique path and cost associated with traveling from one place to another. This is precisely the challenge presented in this problem.</p>
<p>You're given a directed weighted graph, represented by an array of edges. Each edge signifies a one-way connection between two locations, complete with a cost. Your mission is to create a &quot;Graph&quot; class that can efficiently manage this network and provide two essential services.</p>
<ol>
<li>
<p><strong>Setting Up the Map (<code>Graph(int n, int[][] edges)</code>):</strong> Just like preparing a map for a journey, you initialize the graph with &quot;n&quot; locations and the given edges. This step lays out the foundation for your navigation.</p>
</li>
<li>
<p><strong>Plotting New Routes (<code>addEdge(int[] edge)</code>):</strong> As your journey unfolds, you'll come across new routes. The &quot;addEdge&quot; method allows you to add these paths to your map. It's worth noting that this method ensures no duplicate paths between locations.</p>
</li>
<li>
<p><strong>Finding the Optimal Path (<code>int shortestPath(int node1, int node2)</code>):</strong> The core of this adventure lies in discovering the shortest and most cost-effective path from one location to another. This method calculates the minimum cost required to travel from &quot;node1&quot; to &quot;node2.&quot; If a path doesn't exist, it signals your GPS to return -1.</p>
</li>
</ol>
<p>Solving this problem involves creating a powerful navigation tool (the &quot;Graph&quot; class) that not only builds and updates the map as new routes are discovered but also efficiently guides you to your destination, ensuring that you reach your target location with the least possible cost.</p>
<p>This problem mirrors real-world scenarios where you might be navigating transportation networks, optimizing data flow in networks, or even finding the shortest connections in social networks. So, crafting a robust solution here not only solves the immediate challenge but can also have practical applications in various fields.</p>
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>If you are not familiar with Dijkstra's Algorithm, please refer to our explore cards <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
<p>We first use Dijkstra's algorithm, a well-known method for finding the shortest path in weighted graphs, which is particularly effective for this type of problem. The algorithm maintains a priority queue of nodes to explore, prioritizing those with the lowest tentative distances.</p>
<p>We begin by setting the cost of the source node to 0 and enqueue it in a priority queue. Simultaneously, we initialize an array to store the cost associated with each node when starting from the source node. While there are nodes remaining in the queue, we dequeue the node with the lowest cost, examine whether it corresponds to the destination node, and return its cost if it does. If not, we explore its neighboring nodes, compute new costs for the neighboring nodes, and if these new costs are lower than the previously recorded costs in our node cost array, we enqueue the neighboring nodes into the priority queue. In the event that the destination node cannot be reached, we return -1 to indicate the absence of a viable path.</p>
<p>We implement this approach by creating a <code>Graph</code> class with methods for initialization, adding edges, and finding the shortest path using Dijkstra's algorithm. This approach logically addresses the problem's requirements while leveraging a well-established algorithm for efficiency and correctness.</p>
<p>!?!../Documents/2642/design_graph_with_shortest_path_calculator.json:3000,1687!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p><strong>Initialization:</strong></p>
<ul>
<li>When we initialize the <code>Graph</code> class with <code>n</code> nodes and a list of <code>edges</code>, we create an adjacency list representation for the directed weighted graph.</li>
<li>We initialize an empty adjacency list <code>adj_list</code>, where each node's outgoing edges will be stored along with their cost.</li>
</ul>
</li>
<li>
<p><strong>Adding Edges:</strong></p>
<ul>
<li>When we call the <code>addEdge</code> method to add an edge to the graph, we provide an <code>edge</code> in the form of a list <code>[from, to, edgeCost]</code>.</li>
<li>We extract the <code>from_node</code>, <code>to_node</code>, and <code>cost</code> from the input edge.</li>
<li>We append a tuple/pair <code>(to_node, cost)</code> to the adjacency list entry for <code>from_node</code>. This represents a directed edge from <code>from_node</code> to <code>to_node</code> with the specified cost.</li>
</ul>
</li>
<li>
<p><strong>Shortest Path Calculation:</strong></p>
<ul>
<li>When we call the <code>shortestPath</code> method to find the minimum cost path from <code>node1</code> to <code>node2</code>, we use Dijkstra's algorithm.</li>
<li>We initialize an array <code>costForNode</code> to keep track of the minimum costs to reach each node when starting from <code>node1</code> and a priority queue <code>pq</code> to explore nodes in ascending order of their accumulated cost from <code>node1</code>.</li>
<li>We set <code>costForNode[node1]</code> to 0 since we are starting here.</li>
<li>We start by adding <code>(0, node1)</code> to <code>pq</code> with an initial cost of 0 for <code>node1</code>.</li>
<li>While <code>pq</code> is not empty, we continue exploring nodes.</li>
<li>For each iteration:
<ul>
<li>We pop the node with the smallest accumulated cost (<code>curr_cost</code>) from <code>pq</code>.</li>
<li>If <code>curr_node</code> is equal to <code>node2</code>, we have found the shortest path, and we return <code>curr_cost</code>.</li>
<li>We iterate through the neighbors of <code>curr_node</code> stored in the adjacency list.</li>
<li>For each neighbor, we calculate the new cost (<code>new_cost</code>) by adding the cost of the current edge to the <code>curr_cost</code>.</li>
<li>If the neighbor's <code>new_cost</code> is less than its cost in <code>costForNode</code> (<code>costForNode[node1]</code>), we add <code>(new_cost, neighbor)</code> to <code>pq</code>, which means we will explore this neighbor with the updated cost. We additionally assign the value of <code>new_cost</code> to <code>costForNode[node1]</code>.</li>
</ul>
</li>
<li>If the priority queue is empty and we have not found <code>node2</code>, it means there is no path from <code>node1</code> to <code>node2</code>, so we return -1.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/RnYjN5Sw/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(E\)</span> be number of edges in the graph when the call to any method is made.<br />
Let <span class="math inline">\(V\)</span> be the number of vertices in the graph when the call to any method is made.<br />
Let <span class="math inline">\(N\)</span> be the maximum number of calls made to <code>addEdge</code>.<br />
Let <span class="math inline">\(M\)</span> be the maximum number of calls made to <code>shortestPath</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + M\cdot (V + E\cdot logV))\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(E + V)\)</span>. Initializing a list to the size of <span class="math inline">\(V\)</span> costs <span class="math inline">\(O(V)\)</span> and iterating over all the edges costs <span class="math inline">\(O(E)\)</span></li>
<li>addEdge: <span class="math inline">\(O(N)\)</span>. Appending an element to a list costs <span class="math inline">\(O(1)\)</span>, and when this operation is performed <span class="math inline">\(N\)</span> times, it results in a linear time complexity of <span class="math inline">\(O(N)\)</span>.</li>
<li>shortestPath: <span class="math inline">\(O(M\cdot (V + E\cdot logV))\)</span>. Initializing the <code>costForNode</code> list will incur a time complexity of <span class="math inline">\(O(V)\)</span>. The time complexity for Dijkstra's algorithm is <span class="math inline">\((E\cdot logV)\)</span>. Calling <code>shortestPath</code> <span class="math inline">\(M\)</span> times leads to a combined time complexity of <span class="math inline">\(O(M\cdot (V + E\cdot logV))\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(E + V + N)\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(E + V)\)</span>. This is the cost to initialize the adjacency list.</li>
<li>addEdge: <span class="math inline">\(O(N)\)</span>. Adding an element in the adjacency list will incur a space complexity of <span class="math inline">\(O(1)\)</span>, and when this operation is performed <span class="math inline">\(N\)</span> times, it results in a linear space complexity of <span class="math inline">\(O(N)\)</span>.</li>
<li>shortestPath: <span class="math inline">\(O(E + V)\)</span>. The <code>costForNode</code> list will incur a space complexity of <span class="math inline">\(O(V)\)</span>. The priority queue will will incur a space complexity of <span class="math inline">\(O(E)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-floydwarshall-algorithm">Approach 2: Floyd–Warshall algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We start by considering how to represent the graph. Given that it's a weighted directed graph, we opt for an adjacency matrix to store the edge costs between nodes. This matrix, <code>adj_matrix</code>, will be initialized with a very large value (infinity) to signify that there's no direct edge between two nodes.</p>
<p>In the constructor, we take the number of nodes <code>n</code> and the initial <code>edges</code> as input. We initialize the adjacency matrix with infinity values for all pairs of nodes. Then, we iterate through the given edges and update the corresponding positions in the adjacency matrix with the edge costs. To maintain consistency, we also set the diagonal entries to 0 since the cost from a node to itself is zero.</p>
<p><strong>Floyd-Warshall Algorithm:</strong> We recognize the need to find the shortest paths between all pairs of nodes efficiently. To achieve this, we implement the Floyd-Warshall algorithm. We use nested loops to iterate through all possible intermediate nodes (<code>k</code>), source nodes (<code>i</code>), and destination nodes (<code>j</code>). For each pair of nodes (<code>i, j</code>), we update the minimum cost if there's a shorter path through the intermediate node (<code>k</code>).</p>
<p>In the <code>addEdge</code> method, we address the requirement to add a new edge to the graph. We take the edge information as input (from_node, to_node, and cost). To update the adjacency matrix efficiently, we iterate through all pairs of nodes (<code>i, j</code>) and check if the path from <code>i</code> to <code>j</code> can be improved by going through the newly added edge. If there's an improvement, we update the cost accordingly. This is commonly known as the &quot;relaxation&quot; step.</p>
<p><strong>Finding Shortest Path:</strong> In the <code>shortestPath</code> method, we provide a simple interface for users to find the shortest path between two nodes. We return the cost stored in the adjacency matrix for the given pair of nodes (node1, node2). Since we have already relaxed all paths in the <code>addEdge</code> method, the adjacent matrix is guaranteed to store the cost of the shortest path. If the cost is still infinite, it indicates there's no path between those nodes, and we return -1.</p>
<p>The key insight here is that the Floyd-Warshall algorithm efficiently computes the shortest paths between all pairs of nodes, making the <code>shortestPath</code> method fast and time-constant.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p><strong>Initialization:</strong></p>
<ul>
<li>When we initialize the <code>Graph</code> class with <code>n</code> nodes and a list of <code>edges</code>, we create an adjacency matrix representation for the directed weighted graph.</li>
<li>We initialize an empty adjacency matrix <code>adj_matrix</code> of size <code>n x n</code>, where <code>n</code> is the number of nodes.</li>
<li>For each edge in the input <code>edges</code>, we update the corresponding entry in the adjacency matrix with the provided cost.</li>
<li>We set the diagonal elements of the adjacency matrix to 0 because the cost to reach a node from itself is always 0.</li>
</ul>
</li>
<li>
<p><strong>Floyd-Warshall Algorithm:</strong></p>
<ul>
<li>After initializing the adjacency matrix, we apply the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes.</li>
<li>We use three nested loops:
<ul>
<li>The outermost loop iterates over all intermediate nodes (indexed by <code>i</code>).</li>
<li>The middle loop iterates over all source nodes (indexed by <code>j</code>).</li>
<li>The innermost loop iterates over all destination nodes (indexed by <code>k</code>).</li>
</ul>
</li>
<li>During each iteration, we update the entry <code>adj_matrix[j][k]</code> by taking the minimum of its current value and the sum of the values <code>adj_matrix[j][i]</code> and <code>adj_matrix[i][k]</code>. This represents the minimum cost to reach node <code>k</code> from node <code>j</code> via an intermediate node <code>i</code>.</li>
</ul>
</li>
<li>
<p><strong>Adding Edges:</strong></p>
<ul>
<li>When we call the <code>addEdge</code> method to add an edge to the graph, we provide an <code>edge</code> in the form of a list <code>[from, to, edgeCost]</code>.</li>
<li>We iterate over all pairs of nodes in the adjacency matrix and update the entry <code>adj_matrix[i][j]</code> by taking the minimum of its current value and the sum of the values <code>adj_matrix[i][from_node]</code>, <code>adj_matrix[to_node][j]</code>, and <code>cost</code>. This represents the updated minimum cost considering the new edge.</li>
</ul>
</li>
<li>
<p><strong>Shortest Path Calculation:</strong></p>
<ul>
<li>When we call the <code>shortestPath</code> method to find the minimum cost path from <code>node1</code> to <code>node2</code>, we check if the value at <code>adj_matrix[node1][node2]</code> is still equal to infinity(<code>inf</code>). If it is, there is no path between the two nodes, so we return -1.</li>
<li>Otherwise, we return <code>adj_matrix[node1][node2]</code>, which represents the minimum cost to reach <code>node2</code> from <code>node1</code> based on the computed shortest paths.</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QNyfnDS3/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(E\)</span> be number of edges in the graph when the call to any method is made.<br />
Let <span class="math inline">\(V\)</span> be the number of vertices in the graph when the call to any method is made.<br />
Let <span class="math inline">\(N\)</span> be the maximum number of calls made to <code>addEdge</code>.<br />
Let <span class="math inline">\(M\)</span> be the maximum number of calls made to <code>shortestPath</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M + N\cdot V^2 + V^3)\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(V^3)\)</span>. The Floyd-Warshall Algorithm incurs a cost of <span class="math inline">\(O(V^3)\)</span> to find the minimum cost between all pairs of vertices.</li>
<li>addEdge: <span class="math inline">\(O(N\cdot V^2)\)</span>. When adding an edge, we iterate over the whole matrix to check if the new edge lowers the cost between any of the vertices. This operation costs <span class="math inline">\(O(V^2)\)</span>. When this operation is performed <span class="math inline">\(N\)</span> times, it results in a time complexity of <span class="math inline">\(O(N\cdot V^2)\)</span>.</li>
<li>shortestPath: <span class="math inline">\(O(M)\)</span>. Finding the <code>shortestPath</code> doesn't require any additional computation. Hence, it incurs a constant time complexity of <span class="math inline">\(O(1)\)</span>. When this operation is performed <span class="math inline">\(M\)</span> times, it results in a linear time complexity of <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity:  <span class="math inline">\(O(V^2)\)</span></p>
<ul>
<li>initialization: <span class="math inline">\(O(V^2)\)</span>. We initialize a 2-D adjacency matrix that stores the minimum cost between all vertices. This matrix incurs a cost of <span class="math inline">\(O(V^2)\)</span>.</li>
<li>addEdge: <span class="math inline">\(O(1)\)</span>. We will not need any extra space to add an edge.</li>
<li>shortestPath: <span class="math inline">\(O(1)\)</span>. We will not need any extra space to return the cost of the shortest path.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="notes">Notes:</h3>
<p>If there is a significant imbalance between the frequency of <code>shortestPath</code> calls compared to the frequency of <code>addEdge</code> calls, the choice between using the Floyd-Warshall algorithm and Dijkstra's algorithm should be based on the number of times these two operations are performed:</p>
<ul>
<li>When <code>shortestPath</code> is called much more often than <code>addEdge</code>, it is more efficient to utilize the Floyd-Warshall algorithm.</li>
<li>Conversely, if <code>addEdge</code> is called significantly more often than <code>shortestPath</code>, it is more practical to employ Dijkstra's algorithm for this problem.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/digit-operations-to-make-two-integers-equal/description" target="_blank" rel="noopener noreferrer">Digit Operations to Make Two Integers Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>n</code> and <code>m</code> that consist of the <strong>same</strong> number of digits.</p>

<p>You can perform the following operations <strong>any</strong> number of times:</p>

<ul>
	<li>Choose <strong>any</strong> digit from <code>n</code> that is not 9 and <strong>increase</strong> it by 1.</li>
	<li>Choose <strong>any</strong> digit from <code>n</code> that is not 0 and <strong>decrease</strong> it by 1.</li>
</ul>

<p>The integer <code>n</code> must not be a <span data-keyword="prime-number">prime</span> number at any point, including its original value and after each operation.</p>

<p>The cost of a transformation is the sum of <strong>all</strong> values that <code>n</code> takes throughout the operations performed.</p>

<p>Return the <strong>minimum</strong> cost to transform <code>n</code> into <code>m</code>. If it is impossible, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 10, m = 12</span></p>

<p><strong>Output:</strong> <span class="example-io">85</span></p>

<p><strong>Explanation:</strong></p>

<p>We perform the following operations:</p>

<ul>
	<li>Increase the first digit, now <code>n = <u><strong>2</strong></u>0</code>.</li>
	<li>Increase the second digit, now <code>n = 2<strong><u>1</u></strong></code>.</li>
	<li>Increase the second digit, now <code>n = 2<strong><u>2</u></strong></code>.</li>
	<li>Decrease the first digit, now <code>n = <strong><u>1</u></strong>2</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, m = 8</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>It is impossible to make <code>n</code> equal to <code>m</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 6, m = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>Since 2 is already a prime, we can&#39;t make <code>n</code> equal to <code>m</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, m &lt; 10<sup>4</sup></code></li>
	<li><code>n</code> and <code>m</code> consist of the same number of digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/evaluate-division/description" target="_blank" rel="noopener noreferrer">Evaluate Division</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>

<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>

<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>

<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>

<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]
<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]
<strong>Explanation:</strong> 
Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>
queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined =&gt; -1.0</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]
<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]
<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= equations.length &lt;= 20</code></li>
	<li><code>equations[i].length == 2</code></li>
	<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>
	<li><code>values.length == equations.length</code></li>
	<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>
	<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-safe-walk-through-a-grid/description" target="_blank" rel="noopener noreferrer">Find a Safe Walk Through a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code> and an integer <code>health</code>.</p>

<p>You start on the upper-left corner <code>(0, 0)</code> and would like to get to the lower-right corner <code>(m - 1, n - 1)</code>.</p>

<p>You can move up, down, left, or right from one cell to another adjacent cell as long as your health <em>remains</em> <strong>positive</strong>.</p>

<p>Cells <code>(i, j)</code> with <code>grid[i][j] = 1</code> are considered <strong>unsafe</strong> and reduce your health by 1.</p>

<p>Return <code>true</code> if you can reach the final cell with a health value of 1 or more, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png" style="width: 301px; height: 121px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>A minimum of 4 health points is needed to reach the final cell safely.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png" style="width: 361px; height: 161px;" /></div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png" style="width: 181px; height: 121px;" /></p>

<p>Any path that does not go through the cell <code>(1, 1)</code> is unsafe since your health will drop to 0 when reaching the final cell.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code><font face="monospace">2 &lt;= m * n</font></code></li>
	<li><code>1 &lt;= health &lt;= m + n</code></li>
	<li><code>grid[i][j]</code> is either 0 or 1.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-edges-in-shortest-paths/description" target="_blank" rel="noopener noreferrer">Find Edges in Shortest Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected weighted graph of <code>n</code> nodes numbered from 0 to <code>n - 1</code>. The graph consists of <code>m</code> edges represented by a 2D array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>Consider all the shortest paths from node 0 to node <code>n - 1</code> in the graph. You need to find a <strong>boolean</strong> array <code>answer</code> where <code>answer[i]</code> is <code>true</code> if the edge <code>edges[i]</code> is part of <strong>at least</strong> one shortest path. Otherwise, <code>answer[i]</code> is <code>false</code>.</p>

<p>Return the array <code>answer</code>.</p>

<p><strong>Note</strong> that the graph may not be connected.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/05/graph35drawio-1.png" style="height: 129px; width: 250px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,true,true,false,true,true,true,false]</span></p>

<p><strong>Explanation:</strong></p>

<p>The following are <strong>all</strong> the shortest paths between nodes 0 and 5:</p>

<ul>
	<li>The path <code>0 -&gt; 1 -&gt; 5</code>: The sum of weights is <code>4 + 1 = 5</code>.</li>
	<li>The path <code>0 -&gt; 2 -&gt; 3 -&gt; 5</code>: The sum of weights is <code>1 + 1 + 3 = 5</code>.</li>
	<li>The path <code>0 -&gt; 2 -&gt; 3 -&gt; 1 -&gt; 5</code>: The sum of weights is <code>1 + 1 + 2 + 1 = 5</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/05/graphhhh.png" style="width: 185px; height: 136px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,false,false,true]</span></p>

<p><strong>Explanation:</strong></p>

<p>There is one shortest path between nodes 0 and 3, which is the path <code>0 -&gt; 2 -&gt; 3</code> with the sum of weights <code>1 + 2 = 3</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= m &lt;= min(5 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-reach-last-room-i/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Reach Last Room I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a dungeon with <code>n x m</code> rooms arranged as a grid.</p>

<p>You are given a 2D array <code>moveTime</code> of size <code>n x m</code>, where <code>moveTime[i][j]</code> represents the <strong>minimum</strong> time in seconds <strong>after</strong> which the room opens and can be moved to. You start from the room <code>(0, 0)</code> at time <code>t = 0</code> and can move to an <strong>adjacent</strong> room. Moving between adjacent rooms takes <em>exactly</em> one second.</p>

<p>Return the <strong>minimum</strong> time to reach the room <code>(n - 1, m - 1)</code>.</p>

<p>Two rooms are <strong>adjacent</strong> if they share a common wall, either <em>horizontally</em> or <em>vertically</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,4],[4,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 6 seconds.</p>

<ul>
	<li>At time <code>t == 4</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 5</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in one second.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,0,0],[0,0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 3 seconds.</p>

<ul>
	<li>At time <code>t == 0</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 1</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in one second.</li>
	<li>At time <code>t == 2</code>, move from room <code>(1, 1)</code> to room <code>(1, 2)</code> in one second.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == moveTime.length &lt;= 50</code></li>
	<li><code>2 &lt;= m == moveTime[i].length &lt;= 50</code></li>
	<li><code>0 &lt;= moveTime[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-shortest-path--dijkstra">Approach: Shortest Path + Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a two-dimensional array of size <span class="math inline">\(n \times m\)</span>, and the task is to find the shortest time required to move from position <span class="math inline">\((0, 0)\)</span> to position <span class="math inline">\((n - 1, m - 1)\)</span>. While moving, one can go to any of the four adjacent positions (up, down, left, right), and each position has an associated earliest move time, meaning one can only move to that position after that time.</p>
<p>Therefore, the two-dimensional array can be regarded as an undirected graph of size <span class="math inline">\(n \times m\)</span>, where the position <span class="math inline">\((i, j)\)</span> has undirected edges connecting it to <span class="math inline">\((i - 1, j)\)</span>, <span class="math inline">\((i + 1, j)\)</span>, <span class="math inline">\((i, j - 1)\)</span>, and <span class="math inline">\((i, j + 1)\)</span>. We are required to find the shortest path from <span class="math inline">\((0, 0)\)</span> to <span class="math inline">\((n - 1, m - 1)\)</span>.</p>
<p>There are many algorithms for finding the shortest path, and here we choose Dijkstra's algorithm. You can refer to the editorial of <a href="https://leetcode.com/problems/network-delay-time/editorial/">743. Network Delay Time</a> to understand the basic process of Dijkstra's algorithm.</p>
<p>Unlike the standard Dijkstra algorithm, in this problem we define <span class="math inline">\(d[i][j]\)</span> to represent the shortest time required to reach <span class="math inline">\((i, j)\)</span> from <span class="math inline">\((0, 0)\)</span>. The time to move from <span class="math inline">\((i, j)\)</span> to an adjacent coordinate <span class="math inline">\((u, v)\)</span> is given by <span class="math inline">\(\max(d[i][j], \textit{moveTime}[u][v]) + 1\)</span>. The rest of the process is consistent with Dijkstra's algorithm.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3gwDjz6F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in <span class="math inline">\(\textit{moveTime}\)</span>, respectively.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(nm \log(nm))\)</span>.</li>
</ul>
<p>There are <span class="math inline">\(nm\)</span> points and <span class="math inline">\(O(nm)\)</span> edges. We implement Dijkstra's algorithm using a min-heap, performing at most <span class="math inline">\(O(nm)\)</span> insertions and deletions. Each heap operation takes <span class="math inline">\(O(\log(nm))\)</span> time, so the overall time complexity is <span class="math inline">\(O(nm \log(nm))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(nm)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Reach Last Room II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a dungeon with <code>n x m</code> rooms arranged as a grid.</p>

<p>You are given a 2D array <code>moveTime</code> of size <code>n x m</code>, where <code>moveTime[i][j]</code> represents the <strong>minimum</strong> time in seconds when you can <strong>start moving</strong> to that room. You start from the room <code>(0, 0)</code> at time <code>t = 0</code> and can move to an <strong>adjacent</strong> room. Moving between <strong>adjacent</strong> rooms takes one second for one move and two seconds for the next, <strong>alternating</strong> between the two.</p>

<p>Return the <strong>minimum</strong> time to reach the room <code>(n - 1, m - 1)</code>.</p>

<p>Two rooms are <strong>adjacent</strong> if they share a common wall, either <em>horizontally</em> or <em>vertically</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,4],[4,4]]</span></p>

<p><strong>Output:</strong> 7</p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 7 seconds.</p>

<ul>
	<li>At time <code>t == 4</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 5</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,0,0,0],[0,0,0,0]]</span></p>

<p><strong>Output:</strong> 6</p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 6 seconds.</p>

<ul>
	<li>At time <code>t == 0</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 1</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li>
	<li>At time <code>t == 3</code>, move from room <code>(1, 1)</code> to room <code>(1, 2)</code> in one second.</li>
	<li>At time <code>t == 4</code>, move from room <code>(1, 2)</code> to room <code>(1, 3)</code> in two seconds.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> 4</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == moveTime.length &lt;= 750</code></li>
	<li><code>2 &lt;= m == moveTime[i].length &lt;= 750</code></li>
	<li><code>0 &lt;= moveTime[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-shortest-path--dijkstra">Approach: Shortest Path + Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem is an extended version of <a href="https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/description/">3341. Find Minimum Time to Reach Last Room I</a>. The key difference is that the time required for each move alternate: the first move takes 1 second, the second move takes 2 seconds, the third move takes 1 second, and so on.</p>
<p>Since the movement occurs on a two-dimensional grid, each move changes the coordinates <span class="math inline">\((i, j)\)</span> by exactly 1 in one of the four directions. As a result, the parity of <span class="math inline">\((i + j)\)</span> changes with every move. This allows us to determine the move's parity directly based on the current coordinates.</p>
<p>Let <span class="math inline">\(d[i][j]\)</span> represent the shortest time required to reach <span class="math inline">\((i, j)\)</span> from <span class="math inline">\((0, 0)\)</span>. Then, the time to move from <span class="math inline">\((i, j)\)</span> to an adjacent cell <span class="math inline">\((u, v)\)</span> is given by:</p>
<p><span class="math display">\[\max(d[i][j], \textit{moveTime}[u][v]) + (i + j) \bmod 2 + 1.
\]</span></p>
<p>Additionally, since reaching <span class="math inline">\((n - 1, m - 1)\)</span> is guaranteed, we can optimize the algorithm by checking within the main loop whether the current point is <span class="math inline">\((n - 1, m - 1)\)</span>. If it is, we can exit early to avoid unnecessary computations for other cells.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ar24ZbDa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in <span class="math inline">\(\textit{moveTime}\)</span>, respectively.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(nm \log(nm))\)</span>.</li>
</ul>
<p>There are <span class="math inline">\(nm\)</span> points and <span class="math inline">\(O(nm)\)</span> edges. We implement Dijkstra's algorithm using a min-heap, performing at most <span class="math inline">\(O(nm)\)</span> insertions and deletions. Since each heap operation takes <span class="math inline">\(O(\log(nm))\)</span> time, the overall time complexity is <span class="math inline">\(O(nm \log(nm))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(nm)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description" target="_blank" rel="noopener noreferrer">Find the City With the Smallest Number of Neighbors at a Threshold Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities numbered from <code>0</code> to <code>n-1</code>. Given the array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> represents a bidirectional and weighted edge between cities <code>from<sub>i</sub></code> and <code>to<sub>i</sub></code>, and given the integer <code>distanceThreshold</code>.</p>

<p>Return the city with the smallest number of cities that are reachable through some path and whose distance is <strong>at most</strong> <code>distanceThreshold</code>, If there are multiple such cities, return the city with the greatest number.</p>

<p>Notice that the distance of a path connecting cities <em><strong>i</strong></em> and <em><strong>j</strong></em> is equal to the sum of the edges&#39; weights along that path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/23/problem1334example1.png" style="width: 300px; height: 224px;" /></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
<strong>Output:</strong> 3
<strong>Explanation: </strong>The figure above describes the graph.&nbsp;
The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -&gt; [City 1, City 2]&nbsp;
City 1 -&gt; [City 0, City 2, City 3]&nbsp;
City 2 -&gt; [City 0, City 1, City 3]&nbsp;
City 3 -&gt; [City 1, City 2]&nbsp;
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/23/problem1334example0.png" style="width: 300px; height: 224px;" /></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
<strong>Output:</strong> 0
<strong>Explanation: </strong>The figure above describes the graph.&nbsp;
The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -&gt; [City 1]&nbsp;
City 1 -&gt; [City 0, City 4]&nbsp;
City 2 -&gt; [City 3, City 4]&nbsp;
City 3 -&gt; [City 2, City 4]
City 4 -&gt; [City 1, City 2, City 3]&nbsp;
The city 0 has 1 neighboring city at a distanceThreshold = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= weight<sub>i</sub>,&nbsp;distanceThreshold &lt;= 10^4</code></li>
	<li>All pairs <code>(from<sub>i</sub>, to<sub>i</sub>)</code> are distinct.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Imagine we're city planners analyzing the connectivity of cities in a region. We have:</p>
<ol>
<li>A network of <code>n</code> cities, numbered from <code>0</code> to <code>n-1</code>.</li>
<li>A list of roads (edges) connecting these cities, with each road having a certain length (weight).</li>
<li>A maximum travel distance (<code>distanceThreshold</code>) we're willing to consider.</li>
</ol>
<p>Our goal is to find the most isolated city — the one that can reach the fewest other cities within the <code>distanceThreshold</code>. If there's a tie, we choose the city with the highest number.</p>
<p>This is a graph problem where we calculate the reachability of each city within the given distance constraint and then select the optimal city accordingly.</p>
<p>In this article, we'll cover applications of four different graph algorithms to provide a comprehensive guide on the main traversal techniques used in <a href="https://leetcode.com/explore/featured/card/graph/">graphs for finding the shortest path</a>. If you are completely unaware of these algorithms, it is recommended to check them out first. Users can treat this as a template and refer back whenever they need clarification on shortest path algorithms. We will maintain a consistent main function throughout the article, changing only the specific algorithm logic. This article will help keep the focus on the dynamic parts that vary according to different algorithms, without overwhelming you with a wall of text.</p>
<p>The four algorithms we'll discuss are:</p>
<ol>
<li>Dijkstra's Algorithm</li>
<li>Bellman-Ford Algorithm</li>
<li>Shortest Path First Algorithm (SPFA)</li>
<li>Floyd-Warshall Algorithm</li>
</ol>
<hr />
<h3 id="approach-1-dijkstra-algorithm">Approach 1: Dijkstra Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>Dijkstra's algorithm is a graph search algorithm that finds the shortest paths between nodes in a graph. It is particularly effective for finding the shortest path from a single source node to all other nodes in graphs with non-negative edge weights.</p>
<p>The algorithm uses a greedy strategy, maintaining a set of vertices whose shortest distance from the source is known. At each step, it selects the vertex with the minimum distance value from the set of unvisited vertices.</p>
<p>We initialize distances to all vertices as infinity, except for the source vertex, which is set to zero. A priority queue is used to efficiently select the vertex with the minimum distance in each iteration, ensuring that the most promising paths are processed first and saving unnecessary computations.</p>
<p>For each neighbor of the current vertex, we calculate the distance through the current vertex. If this calculated distance is less than the previously known distance to that neighbor, the distance is updated — a process known as relaxation. Dijkstra's algorithm performs relaxation efficiently by always processing the most promising vertex next.</p>
<p>After computing all shortest paths, we count reachable cities and select the most isolated ones.</p>
<p>In summary, the algorithm involves three main steps:</p>
<ol>
<li>
<p><strong>Initialization:</strong> Set the distance to the source city as zero and all others as infinity. Use a priority queue to process cities based on their shortest distance.</p>
</li>
<li>
<p><strong>Relaxation:</strong> Extract the city with the smallest distance from the priority queue. Update the distances to their neighboring cities, adding them back to the queue if their distances are updated.</p>
</li>
<li>
<p><strong>Result Computation:</strong> Compute the shortest paths from each city. Count the number of reachable cities within the distance threshold. Choose the city with the fewest reachable cities or, in case of ties, the city with the greatest number.</p>
</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create an adjacency list <code>adjacencyList</code> to store the graph.</p>
</li>
<li>
<p>Create a 2D array <code>shortestPathMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Set all distances in <code>shortestPathMatrix[i]</code> to the maximum integer value.</li>
<li>Set the distance from the city <code>i</code> to itself (<code>shortestPathMatrix[i][i]</code>) to <code>0</code>.</li>
<li>Initialize <code>adjacencyList[i]</code> as an empty list.</li>
</ul>
</li>
<li>
<p>Iterate through each edge in <code>edges</code>:</p>
<ul>
<li>Extract <code>start</code>, <code>end</code>, and <code>weight</code> from each edge.</li>
<li>Add <code>(end, weight)</code> to <code>adjacencyList[start]</code>.</li>
<li>Add <code>(start, weight)</code> to <code>adjacencyList[end]</code>.</li>
</ul>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Call <code>dijkstra(n, adjacencyList, shortestPathMatrix[i], i)</code>, where <code>i</code> is the source city and <code>shortestPathMatrix[i]</code> is the array that will hold the shortest path distances from city <code>i</code>.</li>
</ul>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>dijkstra(n, adjacencyList, shortestPathDistances, source)</code> Function:</strong></p>
<ul>
<li>
<p>Use a priority queue to process nodes with the smallest distance first:</p>
<ul>
<li>Initialize the priority queue with the <code>source</code> city.</li>
<li>Set all distances in <code>shortestPathDistances</code> to <code>Integer.MAX_VALUE</code>.</li>
<li>Set the distance to the <code>source</code> city itself (<code>shortestPathDistances[source]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Process nodes in priority order:</p>
<ul>
<li>For each node, update distances to neighboring cities if a shorter path is found.</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from the city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1334/approach1.json:975,490!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/We2utpec/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3 \log n)\)</span></p>
<p>For one source, Dijkstra's algorithm using a priority queue runs in <span class="math inline">\(O(m \cdot \log n)\)</span>. With the maximum number of edges <code>m</code>, this becomes <span class="math inline">\(O(n \cdot (n - 1) / 2 \cdot \log n) = O(n^2 \log n)\)</span>. Running Dijkstra's algorithm for each city (source), the overall time complexity is <span class="math inline">\(O(n \cdot n^2 \log n) = O(n^3 \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n^2)\)</span> for the <code>shortestPathMatrix</code> and <span class="math inline">\(O(m + n)\)</span> for the adjacency list and auxiliary data structures. Since <span class="math inline">\(m = O(n^2)\)</span> in the worst case, the overall space complexity simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bellman-ford-algorithm">Approach 2: Bellman-Ford Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The Bellman-Ford algorithm is a graph search algorithm that finds the shortest paths from a single source vertex to all other vertices in a weighted graph. Unlike Dijkstra's algorithm, Bellman-Ford can handle graphs with negative edge weights, making it more versatile but potentially slower.</p>
<p>We start by initializing distances to all vertices as infinity, except the source vertex, which is set to zero. This initialization represents our initial state of knowledge - we don't know any paths yet, so we assume they're infinitely long, except for the trivial path from a vertex to itself.</p>
<p>Next, we perform the key operation, relaxation. For each edge in the graph, we check if the distance to the destination vertex can be improved by going through the source vertex of that edge. We repeat this relaxation step for V-1 times, where V is the number of vertices. In the worst case, where vertices form a line, it might take V-1 steps for changes to propagate from one end to the other.</p>
<p>In our implementation, we apply Bellman-Ford from each city as a source, giving us the shortest paths from every city to every other city. We could have used a single source and run Bellman-Ford once, then repeated for other sources, but running it independently for each source simplifies our code structure.</p>
<p>After computing all shortest paths, we count how many cities are reachable from each city within the distance threshold, and then select the city that can reach the fewest others, breaking ties by choosing the higher-numbered city.</p>
<p>This approach guarantees correctness even with negative edge weights (though we don't have those here). Its simplicity makes Bellman-Ford a good algorithm, even if it's not the most efficient for our specific problem. We don't need to implement cycle detection or early termination, keeping our code straightforward at the cost of potentially unnecessary computations.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Create a 2D array <code>shortestPathMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Call <code>bellmanFord(n, edges, shortestPathMatrix[i], i)</code>, where <code>i</code> is the source city and <code>shortestPathMatrix[i]</code> is the array that will hold the shortest path distances from the city <code>i</code>.</li>
</ul>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>bellmanFord(n, edges, shortestPathDistances, source)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize the distances from the <code>source</code> city:</p>
<ul>
<li>Set all distances in <code>shortestPathDistances</code> (initially set to <code>Integer.MAX_VALUE</code>, which represents <code>INF</code>) to a large value, indicating that the shortest distance is unknown at the start.</li>
<li>Set the distance to the <code>source</code> city itself (<code>shortestPathDistances[source]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Relax edges up to <code>n-1</code> times:</p>
<ul>
<li>Iterate through all edges in <code>edges</code>:
<ul>
<li>For each edge, extract <code>start</code>, <code>end</code>, and <code>weight</code>.</li>
<li>Update the shortest path distances if a shorter path is found. Specifically:
<ul>
<li>If the distance from <code>start</code> to <code>end</code> can be reduced by taking the current edge, update <code>shortestPathDistances[end]</code>.</li>
<li>Similarly, update <code>shortestPathDistances[start]</code> if a shorter path is found through the <code>end</code> city.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p>Note: We have introduced an <code>updated</code> flag to break out of the loop early (relaxation of edges) if no updates are made in an iteration. This optimization can reduce the number of iterations in some cases, addressing the Time Limit Exceeded (TLE) issues that occur when the algorithm is run without this adjustment in Python implementations. For those implementing this algorithm in C++ or Java, refer to the Python code to see how this simple <code>updated</code> flag has been integrated.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/gTrh989H/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^4)\)</span></p>
<p>For one source, Bellman-Ford runs in <span class="math inline">\(O(n \cdot m)\)</span>, where <code>m</code> is the number of edges. In the worst case, <code>m</code> is <span class="math inline">\(n \cdot (n - 1) / 2\)</span> (checkout the constraints), so the time complexity for one source becomes <span class="math inline">\(O(n \cdot (n \cdot (n - 1) / 2)) = O(n^3)\)</span>. Since Bellman-Ford must be run for each city (source), the overall time complexity is <span class="math inline">\(O(n \cdot n^3) = O(n^4)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is dominated by the <code>shortestPathMatrix</code>, which stores the shortest path distances between each pair of cities. This matrix requires <span class="math inline">\(O(n^2)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-shortest-path-first-algorithm-spfa">Approach 3: Shortest Path First Algorithm (SPFA)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman-Ford algorithm, designed to work faster on average, especially for sparse graphs, while still handling negative edge weights.</p>
<p>SPFA starts similarly to Bellman-Ford by initializing all distances to infinity except for the source vertex. However, instead of blindly relaxing all edges in each iteration, SPFA uses a queue to keep track of which vertices need to be processed. We begin by adding the source vertex to the queue, then enter a loop that continues as long as the queue is not empty. In each iteration, we remove a vertex from the queue and relax its outgoing edges. If relaxing an edge updates the distance to a neighbor, we add that neighbor to the queue if it's not already there.</p>
<p>This queue-based approach allows SPFA to focus on the parts of the graph where improvements are still possible, potentially skipping large portions of the graph that won't lead to better paths. This targeted processing often makes SPFA faster than Bellman-Ford in practice.</p>
<p>Our implementation includes a cycle detection mechanism. We keep track of how many times each vertex has been processed. If any vertex is processed more than V times (where V is the number of vertices), it indicates a negative weight cycle. While not strictly necessary for our problem (as we're guaranteed no negative weights), this showcases SPFA's ability to handle more general graphs and could be useful if the algorithm is repurposed for other problems.</p>
<p>Like in previous approaches, we run SPFA from each city as a source to build our complete shortest path matrix. After computing all shortest paths, we perform the same counting and selection process to find the most isolated city.</p>
<p>SPFA offers a middle ground between Bellman-Ford and Dijkstra's algorithm. It can handle negative edge weights like Bellman-Ford, but it's often much faster in practice, sometimes approaching the efficiency of Dijkstra's algorithm. It allows for more efficient processing, especially in graphs where only a few edges contribute to the shortest paths. However, it's worth noting that SPFA's worst-case time complexity is still O(VE) like Bellman-Ford, so it's not guaranteed to be faster in all cases.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Create an adjacency list <code>adjacencyList</code> to store the graph.</p>
</li>
<li>
<p>Create a 2D array <code>shortestPathMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Set all distances in <code>shortestPathMatrix[i]</code> to <code>Integer.MAX_VALUE</code>.</li>
<li>Set the distance from city <code>i</code> to itself (<code>shortestPathMatrix[i][i]</code>) to <code>0</code>.</li>
<li>Initialize <code>adjacencyList[i]</code> as an empty list.</li>
</ul>
</li>
<li>
<p>Iterate through each edge in <code>edges</code>:</p>
<ul>
<li>Extract <code>start</code>, <code>end</code>, and <code>weight</code> from each edge.</li>
<li>Add <code>(end, weight)</code> to <code>adjacencyList[start]</code>.</li>
<li>Add <code>(start, weight)</code> to <code>adjacencyList[end]</code>.</li>
</ul>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Call <code>spfa(n, adjacencyList, shortestPathMatrix[i], i)</code>, where <code>i</code> is the source city and <code>shortestPathMatrix[i]</code> is the array that will hold the shortest path distances from city <code>i</code>.</li>
</ul>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>spfa(n, adjacencyList, shortestPathDistances, source)</code> Function:</strong></p>
<ul>
<li>
<p>Use a queue to process nodes with updated shortest path distances:</p>
<ul>
<li>Initialize the queue with the <code>source</code> city.</li>
<li>Set all distances in <code>shortestPathDistances</code> to <code>Integer.MAX_VALUE</code>.</li>
<li>Set the distance to the <code>source</code> city itself (<code>shortestPathDistances[source]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Process nodes in queue:</p>
<ul>
<li>For each node, update distances to neighboring cities if a shorter path is found.</li>
<li>Track the number of updates for each node.</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/Wc3cKduH/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^4)\)</span></p>
<p>The average time complexity of SPFA is <span class="math inline">\(Θ(m)\)</span> per source, which is <span class="math inline">\(Θ(n^2)\)</span> in the worst case per source. Running SPFA for each city (source), the overall average time complexity is <span class="math inline">\(Θ(n \cdot m) = Θ(n \cdot n^2) = Θ(n^3)\)</span>, and the worst-case time complexity is <span class="math inline">\(O(n \cdot n^3) = O(n^4)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n^2)\)</span> for the <code>shortestPathMatrix</code> and <span class="math inline">\(O(m + n)\)</span> for the adjacency list and auxiliary data structures. Since <span class="math inline">\(m = O(n^2)\)</span> in the worst case, the overall space complexity simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-floyd-warshall-algorithm">Approach 4: Floyd-Warshall Algorithm</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The Floyd-Warshall algorithm finds the shortest paths in a weighted graph with positive or negative edge weights, as long as there are no negative cycles. Unlike algorithms that compute shortest paths from a single source, Floyd-Warshall computes the shortest paths between all pairs of vertices in the graph.</p>
<p>This algorithm takes a fundamentally different approach by computing all-pairs shortest paths in one go, rather than separately for each source. We start by initializing a distance matrix where direct connections between cities are filled with their edge weights, and all other distances are set to infinity. The distance from a city to itself is set to zero. This matrix serves both as our working space and our final result.</p>
<p>The core of the our algorithm involves three nested loops. The outermost loop iterates through all vertices, considering each as a potential intermediate point on the shortest path between every other pair of vertices. For each pair of vertices <code>(i, j)</code>, we check if passing through the current intermediate vertex <code>k</code> offers a shorter path than we currently know. If it does, we update the distance.</p>
<p>This iterative process gradually refines our shortest paths. By the time all vertices have been considered as intermediates, we have determined all shortest paths. After running Floyd-Warshall, our distance matrix contains all the information needed. We can directly count reachable cities for each source and select our answer, similar to previous approaches.</p>
<p>Floyd-Warshall has several advantages: it solves the all-pairs shortest path problem directly with a simple and elegant one-pass implementation. For dense graphs, its time complexity of O(V^3) can be more efficient than running algorithms like Dijkstra’s or SPFA multiple times. However, for sparse graphs or when only a few sources are involved, other algorithms might be more efficient.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Define <code>INF</code> as a large constant value (e.g., <code>1e9 + 7</code>) to represent an infinite distance for initial comparisons.</p>
</li>
<li>
<p>Create a 2D array <code>distanceMatrix</code> with dimensions <code>n x n</code> to store shortest path distances between all pairs of cities.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>Set all distances in <code>distanceMatrix[i]</code> to <code>INF</code>.</li>
<li>Set the distance from city <code>i</code> to itself (<code>distanceMatrix[i][i]</code>) to <code>0</code>.</li>
</ul>
</li>
<li>
<p>Iterate through each edge in <code>edges</code>:</p>
<ul>
<li>Extract <code>start</code>, <code>end</code>, and <code>weight</code> from each edge.</li>
<li>Update <code>distanceMatrix[start][end]</code> and <code>distanceMatrix[end][start]</code> with <code>weight</code>.</li>
</ul>
</li>
<li>
<p>Call <code>floyd(n, distanceMatrix)</code> to compute shortest paths between all pairs of cities.</p>
</li>
<li>
<p>Return the city identified by calling <code>getCityWithFewestReachable(n, distanceMatrix, distanceThreshold)</code> as having the fewest number of reachable cities within the given distance threshold.</p>
</li>
</ul>
<p><strong><code>floyd(n, distanceMatrix)</code> Function:</strong></p>
<ul>
<li>
<p>Use three nested loops to update the <code>distanceMatrix</code>:</p>
<ul>
<li>Outer Loop: Iterate over each intermediate city <code>k</code>.</li>
<li>Middle Loop: Iterate over each source city <code>i</code>.</li>
<li>Inner Loop: Iterate over each destination city <code>j</code>.</li>
</ul>
</li>
<li>
<p>For each combination of cities <code>(i, j)</code> and intermediate city <code>k</code>, update the distance if a shorter path is found through <code>k</code>:</p>
<ul>
<li>Condition: If <code>distanceMatrix[i][j] &gt; distanceMatrix[i][k] + distanceMatrix[k][j]</code>, then update:
<ul>
<li>Update: <code>distanceMatrix[i][j] = distanceMatrix[i][k] + distanceMatrix[k][j]</code></li>
<li>Explanation: This means that if the path from city <code>i</code> to city <code>j</code> is longer than the path from city <code>i</code> to city <code>k</code> plus the path from city <code>k</code> to city <code>j</code>, update the shortest distance from <code>i</code> to <code>j</code> to be the sum of distances <code>i</code> to <code>k</code> and <code>k</code> to <code>j</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>getCityWithFewestReachable(n, shortestPathMatrix, distanceThreshold)</code> Function:</strong></p>
<ul>
<li>
<p>Initialize <code>cityWithFewestReachable</code> to <code>-1</code> and <code>fewestReachableCount</code> to <code>n</code>.</p>
</li>
<li>
<p>For each city <code>i</code>:</p>
<ul>
<li>
<p>Count how many cities are reachable from the city <code>i</code> within the <code>distanceThreshold</code>:</p>
<ul>
<li>For each city <code>j</code>, check if <code>shortestPathMatrix[i][j]</code> is less than or equal to <code>distanceThreshold</code>.</li>
<li>Increment <code>reachableCount</code> if city <code>j</code> is reachable within the threshold.</li>
</ul>
</li>
<li>
<p>Update <code>cityWithFewestReachable</code> if the current city <code>i</code> has fewer reachable cities compared to previously evaluated cities.</p>
</li>
</ul>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1334/approach4_re.json:980,485!?!</p>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/nbkKWfMR/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <code>n</code> refer to the number of cities, where the constraints are <span class="math inline">\(2 <= n <= 100\)</span>, and <code>m</code> refer to the number of edges, with <span class="math inline">\(1 <= edges.length <= \frac{n \cdot (n - 1)}{2}\)</span>. This means that <code>m</code> can be at most <span class="math inline">\(\frac{n \cdot (n - 1)}{2}\)</span>, representing the maximum number of edges in an undirected graph where every city is connected to every other city with a unique edge.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3)\)</span></p>
<p>The Floyd-Warshall algorithm directly computes the shortest paths between all pairs of cities in <span class="math inline">\(O(n^3)\)</span>, regardless of the number of edges. This comes from the three nested loops, each iterating <code>n</code> times.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is dominated by the <code>distanceMatrix</code>, which requires <span class="math inline">\(O(n^2)\)</span> space to store the shortest path distances between each pair of cities.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/description" target="_blank" rel="noopener noreferrer">Minimize the Maximum Edge Weight of Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers, <code>n</code> and <code>threshold</code>, as well as a <strong>directed</strong> weighted graph of <code>n</code> nodes numbered from 0 to <code>n - 1</code>. The graph is represented by a <strong>2D</strong> integer array <code>edges</code>, where <code>edges[i] = [A<sub>i</sub>, B<sub>i</sub>, W<sub>i</sub>]</code> indicates that there is an edge going from node <code>A<sub>i</sub></code> to node <code>B<sub>i</sub></code> with weight <code>W<sub>i</sub></code>.</p>

<p>You have to remove some edges from this graph (possibly <strong>none</strong>), so that it satisfies the following conditions:</p>

<ul>
	<li>Node 0 must be reachable from all other nodes.</li>
	<li>The <strong>maximum</strong> edge weight in the resulting graph is <strong>minimized</strong>.</li>
	<li>Each node has <strong>at most</strong> <code>threshold</code> outgoing edges.</li>
</ul>

<p>Return the <strong>minimum</strong> possible value of the <strong>maximum</strong> edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s-1.png" style="width: 300px; height: 233px;" /></p>

<p>Remove the edge <code>2 -&gt; 0</code>. The maximum weight among the remaining edges is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>It is impossible to reach node 0 from node 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s2-1.png" style="width: 300px; height: 267px;" /></p>

<p>Remove the edges <code>1 -&gt; 3</code> and <code>1 -&gt; 4</code>. The maximum weight among the remaining edges is 2.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= threshold &lt;= n - 1</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2).</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= A<sub>i</sub>, B<sub>i</sub> &lt; n</code></li>
	<li><code>A<sub>i</sub> != B<sub>i</sub></code></li>
	<li><code>1 &lt;= W<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>There <strong>may be</strong> multiple edges between a pair of nodes, but they must have unique weights.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-of-a-path-with-special-roads/description" target="_blank" rel="noopener noreferrer">Minimum Cost of a Path With Special Roads</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>start</code> where <code>start = [startX, startY]</code> represents your initial position <code>(startX, startY)</code> in a 2D space. You are also given the array <code>target</code> where <code>target = [targetX, targetY]</code> represents your target position <code>(targetX, targetY)</code>.</p>

<p>The <strong>cost</strong> of going from a position <code>(x1, y1)</code> to any other position in the space <code>(x2, y2)</code> is <code>|x2 - x1| + |y2 - y1|</code>.</p>

<p>There are also some <strong>special roads</strong>. You are given a 2D array <code>specialRoads</code> where <code>specialRoads[i] = [x1<sub>i</sub>, y1<sub>i</sub>, x2<sub>i</sub>, y2<sub>i</sub>, cost<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> special road goes in <strong>one direction</strong> from <code>(x1<sub>i</sub>, y1<sub>i</sub>)</code> to <code>(x2<sub>i</sub>, y2<sub>i</sub>)</code> with a cost equal to <code>cost<sub>i</sub></code>. You can use each special road any number of times.</p>

<p>Return the <strong>minimum</strong> cost required to go from <code>(startX, startY)</code> to <code>(targetX, targetY)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<ol>
	<li>(1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1.</li>
	<li>(1,2) to (3,3). Use <code><span class="example-io">specialRoads[0]</span></code><span class="example-io"> with</span><span class="example-io"> the cost 2.</span></li>
	<li><span class="example-io">(3,3) to (3,4) with a cost of |3 - 3| + |4 - 3| = 1.</span></li>
	<li><span class="example-io">(3,4) to (4,5). Use </span><code><span class="example-io">specialRoads[1]</span></code><span class="example-io"> with the cost</span><span class="example-io"> 1.</span></li>
</ol>

<p><span class="example-io">So the total cost is 1 + 2 + 1 + 1 = 5.</span></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [3,2], target = [5,7], specialRoads = [[5,7,3,2,1],[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">7</span></p>

<p><strong>Explanation:</strong></p>

<p>It is optimal not to use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7.</p>

<p>Note that the <span class="example-io"><code>specialRoads[0]</code> is directed from (5,7) to (3,2).</span></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">start = [1,1], target = [10,4], specialRoads = [[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<ol>
	<li>(1,1) to (1,2) with a cost of |1 - 1| + |2 - 1| = 1.</li>
	<li>(1,2) to (7,4). Use <code><span class="example-io">specialRoads[1]</span></code><span class="example-io"> with the cost</span><span class="example-io"> 4.</span></li>
	<li>(7,4) to (10,4) with a cost of |10 - 7| + |4 - 4| = 3.</li>
</ol>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>start.length == target.length == 2</code></li>
	<li><code>1 &lt;= startX &lt;= targetX &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= startY &lt;= targetY &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= specialRoads.length &lt;= 200</code></li>
	<li><code>specialRoads[i].length == 5</code></li>
	<li><code>startX &lt;= x1<sub>i</sub>, x2<sub>i</sub> &lt;= targetX</code></li>
	<li><code>startY &lt;= y1<sub>i</sub>, y2<sub>i</sub> &lt;= targetY</code></li>
	<li><code>1 &lt;= cost<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-convert-string-i/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Convert String I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>source</code> and <code>target</code>, both of length <code>n</code> and consisting of <strong>lowercase</strong> English letters. You are also given two <strong>0-indexed</strong> character arrays <code>original</code> and <code>changed</code>, and an integer array <code>cost</code>, where <code>cost[i]</code> represents the cost of changing the character <code>original[i]</code> to the character <code>changed[i]</code>.</p>

<p>You start with the string <code>source</code>. In one operation, you can pick a character <code>x</code> from the string and change it to the character <code>y</code> at a cost of <code>z</code> <strong>if</strong> there exists <strong>any</strong> index <code>j</code> such that <code>cost[j] == z</code>, <code>original[j] == x</code>, and <code>changed[j] == y</code>.</p>

<p>Return <em>the <strong>minimum</strong> cost to convert the string </em><code>source</code><em> to the string </em><code>target</code><em> using <strong>any</strong> number of operations. If it is impossible to convert</em> <code>source</code> <em>to</em> <code>target</code>, <em>return</em> <code>-1</code>.</p>

<p><strong>Note</strong> that there may exist indices <code>i</code>, <code>j</code> such that <code>original[j] == original[i]</code> and <code>changed[j] == changed[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;acbe&quot;, original = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;d&quot;], changed = [&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;e&quot;,&quot;b&quot;,&quot;e&quot;], cost = [2,5,5,1,2,20]
<strong>Output:</strong> 28
<strong>Explanation:</strong> To convert the string &quot;abcd&quot; to string &quot;acbe&quot;:
- Change value at index 1 from &#39;b&#39; to &#39;c&#39; at a cost of 5.
- Change value at index 2 from &#39;c&#39; to &#39;e&#39; at a cost of 1.
- Change value at index 2 from &#39;e&#39; to &#39;b&#39; at a cost of 2.
- Change value at index 3 from &#39;d&#39; to &#39;e&#39; at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28.
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;aaaa&quot;, target = &quot;bbbb&quot;, original = [&quot;a&quot;,&quot;c&quot;], changed = [&quot;c&quot;,&quot;b&quot;], cost = [1,2]
<strong>Output:</strong> 12
<strong>Explanation:</strong> To change the character &#39;a&#39; to &#39;b&#39; change the character &#39;a&#39; to &#39;c&#39; at a cost of 1, followed by changing the character &#39;c&#39; to &#39;b&#39; at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of &#39;a&#39; to &#39;b&#39;, a total cost of 3 * 4 = 12 is incurred.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;abce&quot;, original = [&quot;a&quot;], changed = [&quot;e&quot;], cost = [10000]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to convert source to target because the value at index 3 cannot be changed from &#39;d&#39; to &#39;e&#39;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= source.length == target.length &lt;= 10<sup>5</sup></code></li>
	<li><code>source</code>, <code>target</code> consist of lowercase English letters.</li>
	<li><code>1 &lt;= cost.length == original.length == changed.length &lt;= 2000</code></li>
	<li><code>original[i]</code>, <code>changed[i]</code> are lowercase English letters.</li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>original[i] != changed[i]</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have two strings, <code>source</code> and <code>target</code>, both of the same length. Additionally, we have three arrays: <code>original</code>, <code>changed</code>, and <code>cost</code>, each also of the same length.</p>
<p>Our task is to transform the <code>source</code> text into the <code>target</code> text using a series of character conversions. Each conversion works as follows:</p>
<ol>
<li>Identify a character in <code>source</code> that does not match the corresponding character in <code>target</code>.</li>
<li>Find this mismatched character in the <code>original</code> array.</li>
<li>Replace it with the corresponding character from the <code>changed</code> array.</li>
<li>Each conversion has a cost specified in the <code>cost</code> array.</li>
</ol>
<p>The goal is to determine the minimum total cost required to transform <code>source</code> into <code>target</code>.</p>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>Our task is to convert each mismatched character at the lowest possible cost. To tackle this, we can model each character as a node in a graph, with transformations represented as directed edges between nodes, each with a specific cost. The problem then becomes finding the minimum cost path from each character in <code>source</code> to the corresponding character in <code>target</code>.</p>
<p>Consider Example 1 from the problem description visualized as a graph:</p>
<p><img src="../Figures/2976/graph.png" alt="Graph Representation" /></p>
<p>To find the minimum cost path between nodes, Dijkstra's Single Source Shortest Path algorithm is useful. It efficiently calculates the shortest path in a directed graph with non-negative edge weights. For more information, refer to this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Explore Card</a>.</p>
<p>First, create a graph structure using an adjacency list to represent all possible character conversions. For each index <code>i</code>:</p>
<ul>
<li>The character in <code>original[i]</code> is the starting point.</li>
<li>The character in <code>changed[i]</code> is the destination.</li>
<li>The value in <code>cost[i]</code> denotes the conversion cost.</li>
</ul>
<p>Each conversion is an edge in our graph, mapping potential character transformations and their costs. Instead of running Dijkstra's algorithm for every differing character, precompute the shortest path from every character to every other character. This reduces the need to execute the algorithm multiple times, leveraging the fact that there are only <span class="math inline">\(26\)</span> possible characters.</p>
<p>Finally, calculate the total minimum cost by summing the precomputed costs for each differing character in <code>source</code> and <code>target</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main method <code>minimumCost</code>:</p>
<ul>
<li>Create an <code>adjacencyList</code> with 26 entries (one for each lowercase letter).</li>
<li>Iterate through the <code>original</code> array: For each index <code>i</code>:
<ul>
<li>Add an edge to <code>adjacencyList</code> from <code>original[i]</code> to <code>changed[i]</code>, with the corresponding <code>cost[i]</code>.</li>
</ul>
</li>
<li>For each of the <span class="math inline">\(26\)</span> characters, call <code>dijkstra</code> to find the shortest path from this character to all other characters.</li>
<li>Store the results in a 2D array <code>minConversionCosts</code> of size <span class="math inline">\(26 \times 26\)</span>.</li>
<li>Initialize a variable <code>totalCost</code> to <code>0</code>.</li>
<li>Iterate through the length of <code>source</code>:
<ul>
<li>If the character at the current position differs from <code>target</code>:
<ul>
<li>Look up the conversion cost in <code>minConversionCosts</code>:
<ul>
<li>If the conversion is impossible (cost is <code>-1</code>), return <code>-1</code>.</li>
<li>Else, add the cost to <code>totalCost</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalCost</code> as the answer.</li>
</ul>
<p>Helper method <code>dijkstra</code>:</p>
<ul>
<li>Define a method <code>dijkstra</code> with parameters: <code>startChar</code> and <code>adjacencyList</code>.</li>
<li>Create a priority queue <code>priorityQueue</code> with each element as a pair of (cost, character). Sort the queue by cost (lowest first).</li>
<li>Initialize an array <code>minCosts</code> of size <span class="math inline">\(26\)</span> with all values set to <code>-1</code> (representing unreachable positions).</li>
<li>Add <code>startChar</code> to <code>priorityQueue</code> with a cost of <code>0</code>.</li>
<li>While <code>priorityQueue</code> is not empty:
<ul>
<li>Poll a pair (<code>currentCost</code>, <code>currentChar</code>) from the queue.</li>
<li>Loop over all possible conversions from <code>currentChar</code> using the <code>adjacencyList</code>. For each <code>conversion</code> to <code>targetChar</code>:
<ul>
<li>Find the <code>newTotalCost</code> to do the conversion as <code>currentCost + conversionCost</code>.</li>
<li>If the conversion hasn't been reached yet <code>minCosts[targetChar] == -1</code>, or <code>newTotalCost</code> is less than the previous cost in <code>minCosts[targetChar]</code>:
<ul>
<li>Set <code>minCosts[targetChar]</code> as <code>newTotalCost</code>.</li>
<li>Add the pair <code>(newTotalCost, targetChar)</code> to the priority queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>minCosts</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5iVVcnzm/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>source</code> and <span class="math inline">\(m\)</span> be the length of the <code>original</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>Creating the adjacency list requires <span class="math inline">\(O(m)\)</span> time as the algorithm loops over the contents of the <code>original</code>, <code>changed</code>, and <code>cost</code> array simultaneously.</p>
<p>In our algorithm, the number of vertices is <span class="math inline">\(26\)</span> and the number of edges is <span class="math inline">\(m\)</span>, which makes the time complexity of Dijkstra's algorithm <span class="math inline">\(O((26 + m) \log 26)\)</span>. We call <code>dijkstra</code> for each of the <span class="math inline">\(26\)</span> characters. Thus, the total time complexity is <span class="math inline">\(O(26 \cdot (26 + m) \log 26)\)</span>, which can be simplified to <span class="math inline">\(O(m)\)</span>.</p>
<p>To calculate the <code>totalCost</code>, we iterate over the <code>source</code> string, which has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The total time complexity is the addition of all these elements, i.e., <span class="math inline">\(O(m) + O(n) = O(m + n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The <code>adjacencyList</code> stores all possible conversions, requiring a space complexity of <span class="math inline">\(O(m)\)</span>. <code>minConversionCosts</code> uses <span class="math inline">\(O(26 \times 26)\)</span> space, which simplifies to <span class="math inline">\(O(1)\)</span>.</p>
<p>The <code>dijkstra</code> method uses a priority queue that can store at most <span class="math inline">\(m\)</span> elements in the worst case. The array <code>minCosts</code> has a fixed size of <span class="math inline">\(26\)</span>. Thus, the total space used by the method is <span class="math inline">\(O(m)\)</span>.</p>
<p>The total space required by the algorithm is <span class="math inline">\(O(m) + O(1) + O(m)\)</span>, which simplifies to <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-floyd-warshall-algorithm">Approach 2: Floyd-Warshall Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used Dijkstra's algorithm to find the minimum cost of converting each of the 26 lowercase characters to every other character, effectively applying a single-source shortest path algorithm multiple times. Instead, we can use a multi-source shortest-path algorithm.</p>
<p><a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall's All Pairs Shortest Path</a> algorithm, an effective dynamic programming technique, calculates the minimum cost path between all pairs of vertices in a directed graph. This fits our needs perfectly since we require the minimum traversal cost between every pair of lowercase characters.</p>
<p>The Floyd-Warshall algorithm works by iterating through each vertex as a potential intermediate point for all pairs of vertices. We create a matrix <code>minCost</code>, where <code>minCost[i][j]</code> represents the minimum cost to travel from vertex <code>i</code> to <code>j</code>. The algorithm involves three nested loops to update <code>minCost[i][j]</code> by considering whether a shorter path exists through an intermediate vertex <code>k</code>. After completing these iterations, <code>minCost</code> will hold the minimum costs for all character pairs.</p>
<p>We then iterate through the <code>source</code> and <code>target</code> strings, comparing characters at each position. For differing characters, we look up the minimum conversion cost in the <code>minCost</code> matrix. If any transformation is impossible, we return <code>-1</code>; otherwise, we sum the costs to get the total minimum conversion cost.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li><code>totalCost</code> to store the total minimum cost.</li>
<li>a 2D array <code>minCost</code> to store the minimum transformation cost between any two characters.</li>
</ul>
</li>
<li>Initialize each entry in <code>minCost</code> to the maximum integer value to represent initial conversion costs.</li>
<li>Using <code>original</code>, <code>changed</code>, and <code>cost</code>, update the <code>minCost</code> array with the minimum cost for each given conversion.</li>
<li>Utilize three loops. The outermost loop runs <code>k</code> from <code>0</code> to <code>25</code>, where <code>k</code> is the character being considered as an intermediate node.
<ul>
<li>For each fixed k, the inner loops iterate over all pairs of characters <code>(i, j)</code>, where <code>i</code> and <code>j</code> are the source and destination characters respectively. For each <code>(i, j)</code>:
<ul>
<li>We check whether the current known minimum cost <code>minCost[i][j]</code> can be improved by going through the intermediate character <code>k</code>. If it can, we update <code>minCost[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate through each character of <code>source</code>:
<ul>
<li>If the character matches with <code>target</code>, continue with the next iteration.</li>
<li>Else, check <code>minCost</code> for the conversion cost:
<ul>
<li>If the conversion cost is greater than or equal to the max integer value, return <code>-1</code>.</li>
<li>Else, add the cost to <code>totalCost</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalCost</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/dnbset9z/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>source</code> and <span class="math inline">\(m\)</span> be the length of the <code>original</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>Populating <code>minCosts</code> with the initial conversion costs takes <span class="math inline">\(O(m)\)</span> time.</p>
<p>Each of the three nested loops runs <span class="math inline">\(26\)</span> times. Thus, the overall time taken is <span class="math inline">\(O(26^3) = O(1)\)</span>.</p>
<p>To calculate the <code>totalCost</code>, the algorithm loops over the <code>source</code> string, which takes linear time.</p>
<p>Thus, the time complexity of the algorithm is <span class="math inline">\(O(m) + O(1) + O(n)\)</span>, which simplifies to <span class="math inline">\(O(m + n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The <code>minCost</code> array has a fixed size of <span class="math inline">\(26 \times 26\)</span>. We do not use any other data structures dependent on the length of the input space. Thus, the algorithm has a constant space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-convert-string-ii/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Convert String II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>source</code> and <code>target</code>, both of length <code>n</code> and consisting of <strong>lowercase</strong> English characters. You are also given two <strong>0-indexed</strong> string arrays <code>original</code> and <code>changed</code>, and an integer array <code>cost</code>, where <code>cost[i]</code> represents the cost of converting the string <code>original[i]</code> to the string <code>changed[i]</code>.</p>

<p>You start with the string <code>source</code>. In one operation, you can pick a <strong>substring</strong> <code>x</code> from the string, and change it to <code>y</code> at a cost of <code>z</code> <strong>if</strong> there exists <strong>any</strong> index <code>j</code> such that <code>cost[j] == z</code>, <code>original[j] == x</code>, and <code>changed[j] == y</code>. You are allowed to do <strong>any</strong> number of operations, but any pair of operations must satisfy <strong>either</strong> of these two conditions:</p>

<ul>
	<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with either <code>b &lt; c</code> <strong>or</strong> <code>d &lt; a</code>. In other words, the indices picked in both operations are <strong>disjoint</strong>.</li>
	<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with <code>a == c</code> <strong>and</strong> <code>b == d</code>. In other words, the indices picked in both operations are <strong>identical</strong>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> cost to convert the string </em><code>source</code><em> to the string </em><code>target</code><em> using <strong>any</strong> number of operations</em>. <em>If it is impossible to convert</em> <code>source</code> <em>to</em> <code>target</code>,<em> return</em> <code>-1</code>.</p>

<p><strong>Note</strong> that there may exist indices <code>i</code>, <code>j</code> such that <code>original[j] == original[i]</code> and <code>changed[j] == changed[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;acbe&quot;, original = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;d&quot;], changed = [&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;e&quot;,&quot;b&quot;,&quot;e&quot;], cost = [2,5,5,1,2,20]
<strong>Output:</strong> 28
<strong>Explanation:</strong> To convert &quot;abcd&quot; to &quot;acbe&quot;, do the following operations:
- Change substring source[1..1] from &quot;b&quot; to &quot;c&quot; at a cost of 5.
- Change substring source[2..2] from &quot;c&quot; to &quot;e&quot; at a cost of 1.
- Change substring source[2..2] from &quot;e&quot; to &quot;b&quot; at a cost of 2.
- Change substring source[3..3] from &quot;d&quot; to &quot;e&quot; at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28. 
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;acdeeghh&quot;, original = [&quot;bcd&quot;,&quot;fgh&quot;,&quot;thh&quot;], changed = [&quot;cde&quot;,&quot;thh&quot;,&quot;ghh&quot;], cost = [1,3,5]
<strong>Output:</strong> 9
<strong>Explanation:</strong> To convert &quot;abcdefgh&quot; to &quot;acdeeghh&quot;, do the following operations:
- Change substring source[1..3] from &quot;bcd&quot; to &quot;cde&quot; at a cost of 1.
- Change substring source[5..7] from &quot;fgh&quot; to &quot;thh&quot; at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.
- Change substring source[5..7] from &quot;thh&quot; to &quot;ghh&quot; at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.
The total cost incurred is 1 + 3 + 5 = 9.
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;addddddd&quot;, original = [&quot;bcd&quot;,&quot;defgh&quot;], changed = [&quot;ddd&quot;,&quot;ddddd&quot;], cost = [100,1578]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to convert &quot;abcdefgh&quot; to &quot;addddddd&quot;.
If you select substring source[1..3] as the first operation to change &quot;abcdefgh&quot; to &quot;adddefgh&quot;, you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.
If you select substring source[3..7] as the first operation to change &quot;abcdefgh&quot; to &quot;abcddddd&quot;, you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= source.length == target.length &lt;= 1000</code></li>
	<li><code>source</code>, <code>target</code> consist only of lowercase English characters.</li>
	<li><code>1 &lt;= cost.length == original.length == changed.length &lt;= 100</code></li>
	<li><code>1 &lt;= original[i].length == changed[i].length &lt;= source.length</code></li>
	<li><code>original[i]</code>, <code>changed[i]</code> consist only of lowercase English characters.</li>
	<li><code>original[i] != changed[i]</code></li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Make at Least One Valid Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of <code>grid[i][j]</code> can be:</p>

<ul>
	<li><code>1</code> which means go to the cell to the right. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j + 1]</code>)</li>
	<li><code>2</code> which means go to the cell to the left. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j - 1]</code>)</li>
	<li><code>3</code> which means go to the lower cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i + 1][j]</code>)</li>
	<li><code>4</code> which means go to the upper cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i - 1][j]</code>)</li>
</ul>

<p>Notice that there could be some signs on the cells of the grid that point outside the grid.</p>

<p>You will initially start at the upper left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code> following the signs on the grid. The valid path does not have to be the shortest.</p>

<p>You can modify the sign on a cell with <code>cost = 1</code>. You can modify the sign on a cell <strong>one time only</strong>.</p>

<p>Return <em>the minimum cost to make the grid have at least one valid path</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid1.png" style="width: 400px; height: 390px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You will start at point (0, 0).
The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost = 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost = 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost = 1 --&gt; (3, 3)
The total cost = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid2.png" style="width: 350px; height: 341px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,3],[3,2,2],[1,1,4]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> You can follow the path from (0, 0) to (2, 2).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid3.png" style="width: 200px; height: 192px;" />
<pre>
<strong>Input:</strong> grid = [[1,2],[4,3]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 4</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Let’s consider a single cell (<code>row</code>, <code>col</code>) in the middle of the grid. To reach this cell, we can come from one of its four neighbors: above (<code>row - 1</code>, <code>col</code>), left (<code>row</code>, <code>col - 1</code>), below (<code>row + 1</code>, <code>col</code>), or right (<code>row</code>, <code>col + 1</code>). The cost to reach this cell depends on two factors: the cost of reaching one of its neighbors and the cost of moving from that neighbor to (<code>row</code>, <code>col</code>). This leads us to the conclusion that if we can compute the minimum cost to reach its neighbors, we can determine the minimum cost to reach the current cell as well.</p>
<p>This dependency on neighboring cells suggests a dynamic programming approach. Initially, it might seem logical to move right and down from the top-left corner towards the bottom-right corner, filling the grid as we go. However, this problem is more complex because paths aren’t restricted to just right or down movements. In fact, a more cost-effective path might involve going left or up, depending on the direction changes needed.</p>
<p>To solve this, we create a grid <code>minChanges</code> to store the minimum cost to reach each cell. Initially, we set all cells to infinity except for the starting cell <code>(0, 0)</code>, which starts at 0 because there’s no cost to begin there.</p>
<p>To find the minimum cost path, we use a two-pass system that repeats until we can't find any better paths:</p>
<ol>
<li>
<p><strong>Forward Pass</strong>: Starting from the top-left corner, we move towards the bottom-right corner. For each cell, we check the cost of reaching it from its neighbors above or to the left. If the neighbor’s direction naturally points to the current cell, there’s no additional cost; otherwise, it costs 1 to change direction. Using this information, we update the minimum cost for the current cell.</p>
</li>
<li>
<p><strong>Backward Pass</strong>: Starting from the bottom-right corner, we move back towards the top-left corner. This pass considers neighbors below or to the right. It’s particularly useful for uncovering paths where a roundabout route (moving up or left) results in a lower cost than a direct one.</p>
</li>
</ol>
<p>After each pass, we check if any cell’s minimum cost has changed. If not, it means we’ve found the optimal solution. Since the cost of a cell can only decrease with each iteration and cannot drop below 0, this process is guaranteed to converge.</p>
<p>Finally, the value in the bottom-right cell of the <code>minChanges</code> grid represents the minimum cost to create a valid path from the top-left to the bottom-right corner.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input <code>grid</code>.</li>
<li>Create a 2-D array <code>minChanges</code> with dimensions <code>numRows * numCols</code> to track the minimum changes needed to reach each cell.</li>
<li>Initialize all cells in the <code>minChanges</code> array to the maximum possible integer value.</li>
<li>Set the value of <code>minChanges[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter an infinite loop that will continue until convergence is reached.
<ul>
<li>Create a 2-D array <code>prevState</code> to store the previous state of <code>minChanges</code> for comparison.</li>
<li>Copy the current state of <code>minChanges</code> into <code>prevState</code>.</li>
<li>Begin the forward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from above and left</li>
<li>Update the <code>minChanges</code> value based on:
<ul>
<li>Whether the neighbor naturally points to the current cell (cost is 0).</li>
<li>Or needs to be changed to point to the current cell (cost is 1).</li>
</ul>
</li>
</ul>
</li>
<li>Begin the backward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from below and right</li>
<li>Apply the same cost calculation logic as in the forward pass.</li>
</ul>
</li>
<li>Compare prevState with the current <code>minChanges</code> array:
<ul>
<li>If they are identical, break the loop as convergence is reached.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minChanges[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cUHwszao/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n \cdot m)^2)\)</span></p>
<p>The algorithm has an outer loop that continues until convergence, where <span class="math inline">\(k\)</span> is the number of iterations needed. In each iteration, we perform a forward pass and a backward pass through the entire grid, each taking <span class="math inline">\(O(n \cdot m)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot k)\)</span>.</p>
<p>The value of <span class="math inline">\(k\)</span> depends on the grid configuration and in the worst case could be proportional to <span class="math inline">\(n \cdot m\)</span>, making the worst-case time complexity <span class="math inline">\(O((n \cdot m)^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses two 2D arrays - <code>minChanges</code> and <code>prevState</code>, each of size <span class="math inline">\(n \times m\)</span>. No additional space scaling with input size is needed. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dijkstras-algorithm">Approach 2: Dijkstra's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We start by thinking of the grid as a network of connected points (a graph). Each cell represents a point (node), and the cells are connected to their neighbors. These connections (edges) have specific costs:</p>
<ol>
<li>Cost is 0 if the sign in one cell points directly to its neighbor.</li>
<li>Cost is 1 in all other cases where we need to change the sign.</li>
</ol>
<p>This gives us a problem where we need to find the cheapest path through a directed graph, which is exactly what Dijkstra's algorithm is designed to handle.</p>
<p>With Dijkstra’s algorithm, we use a priority queue to explore cells based on their current cost, ensuring that we always process the lowest-cost paths first. We also maintain a grid, <code>minCost</code>, where each cell tracks the cheapest way to reach that cell from the start. The queue holds cells we are currently exploring, each entry containing three pieces of information: the total cost so far, and the row and column indices of the cell. The queue is organized such that cells with the lower cost are processed first, which helps us prioritize more promising paths over more expensive ones.</p>
<p>For each cell we explore, we evaluate all its four neighboring cells. To do this, we calculate the cost to reach the neighbor by adding the current cost to the cost of moving to the neighbor (either 0 or 1, depending on the sign). If this new cost is lower than the current recorded cost in <code>minCost</code>, we’ve found a better path to the neighbor, so we update the cost in <code>minCost</code> and add the neighbor to the queue for further exploration.</p>
<p>This process continues until all cells have been explored, and the queue is empty. At this point, the <code>minCost</code> grid holds the minimum cost required to reach each cell from the starting cell (top-left corner). Finally, the solution to the problem is simply the value stored in <code>minCost</code> at the bottom-right corner of the grid.</p>
<blockquote>
<p>For a more comprehensive understanding of Dijkstra's Algorithm, check out the <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card 🔗</a>. This resource provides an in-depth look at Dijkstra's Algorithm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a 2-D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</p>
</li>
<li>
<p>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</p>
</li>
<li>
<p>Create a minimum priority queue <code>pq</code> ordered by cost, where each element is a triplet [cost, row, col].</p>
</li>
<li>
<p>Add the starting position <code>[0, 0, 0]</code> to the priority queue with initial cost <code>0</code>.</p>
</li>
<li>
<p>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</p>
</li>
<li>
<p>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</p>
</li>
<li>
<p>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</p>
</li>
<li>
<p>Enter a loop that continues while the priority queue is not empty:</p>
<ul>
<li>Extract the current cell with minimum cost from the priority queue.</li>
<li>If a better path to this cell has been found, skip processing this cell.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Check if the new position is within the grid boundaries.</li>
<li>Calculate the new cost:
<ul>
<li>Add <code>0</code> if the current cell naturally points in this direction.</li>
<li>Add <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new cost is less than the previously known cost for the new position:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>Add the new position to the priority queue with its cost.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/8rasikDe/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span></p>
<p>The algorithm uses Dijkstra's algorithm with a priority queue. In the worst case, we might need to visit each cell multiple times until we find the optimal path, but no more than <span class="math inline">\(4\)</span> times per cell (once for each direction). For each cell, we perform a priority queue operation which takes <span class="math inline">\(O(\log(n \cdot m))\)</span> time, where <span class="math inline">\(n \cdot m\)</span> is the maximum size of the queue. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a priority queue that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-0-1-breadth-first-search">Approach 3: 0-1 Breadth-First Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Dijkstra's algorithm works well for finding the shortest path, but our problem has a unique feature: the path costs are either 0 or 1. This is key because any path with only 0-cost edges, no matter how long, will always be better than one that uses even a single 1-cost edge. Therefore, it makes sense to prioritize exploring 0-cost edges first. Only after all 0-cost edges have been explored, should we move on to the 1-cost edges. This insight leads us to a modification of the Breadth-First Search (BFS) algorithm, known as 0-1 BFS.</p>
<p>In 0-1 BFS, we adjust the traditional BFS by using a deque (double-ended queue) instead of a regular queue. The deque allows us to prioritize 0-cost edges more efficiently. Each element of the deque will store the row and column indices of a cell, and we will maintain a <code>minCost</code> grid to track the minimum cost to reach each cell.</p>
<p>As we visit each cell, we evaluate its four neighboring cells. If moving to a neighbor doesn’t require a sign change (i.e., the move is a 0-cost move), we add that neighbor to the front of the deque because we want to explore it immediately. On the other hand, if a sign change is required (making it a 1-cost move), we add the neighbor to the back of the deque, ensuring it gets explored later, after all the 0-cost moves.</p>
<p>For each neighbor we explore, we calculate the cost to reach it and compare it to the current value in the <code>minCost</code> grid. If the calculated cost is lower, we update <code>minCost</code> with the new, cheaper value.</p>
<p>Once the BFS traversal completes and all cells have been processed, the minimum cost to reach the bottom-right corner will be stored in <code>minCost</code>. We return this value as the solution to the problem.</p>
<p>The below slideshow demonstrates the algorithm in action:</p>
<p>!?!../Documents/1368/slideshow.json:1080,1080!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</li>
<li>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</li>
<li>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</li>
<li>Create a double-ended queue <code>deque</code> for 0-1 BFS implementation.</li>
<li>Add the starting position <code>[0, 0]</code> to the front of the <code>deque</code>.</li>
<li>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter a loop that continues while the <code>deque</code> is not empty:
<ul>
<li>Extract the current cell from the front of the <code>deque</code>.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Calculate the <code>cost</code>:
<ul>
<li>Set <code>cost</code> to <code>0</code> if the current cell naturally points in this direction.</li>
<li>Set <code>cost</code> to <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new position is valid and the new path is cheaper:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>If the <code>cost</code> is 1:
<ul>
<li>Add the new position to the back of the <code>deque</code>.</li>
</ul>
</li>
<li>If the <code>cost</code> is 0:
<ul>
<li>Add the new position to the front of the <code>deque</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<p>Helper method <code>isValid(row, col, numRows, numCols)</code>:</p>
<ul>
<li>Check if the given position is:
<ul>
<li>Within the grid's row boundaries.</li>
<li>Within the grid's column boundaries.</li>
</ul>
</li>
<li>Return <code>true</code> if all conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/NWGViPMb/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses 0-1 BFS approach where each cell is visited at most once for each edge weight (0 or 1). Since we process zero-weight edges before one-weight edges (by adding to the front of the deque), each cell gets its final shortest distance when it's first processed. No cell is processed more than once with the same cost. Therefore, the time complexity is linear with respect to the number of cells, giving us <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a deque that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-depth-first-search--breadth-first-search">Approach 4: Depth-First Search + Breadth-First Search</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let us extend the idea of exploring all 0-weight edges. Since some paths cost 0 to traverse, we could technically explore a sizable portion of the grid without incurring any cost at all. Now, if we are allowed a cost of 1, we could expand from the parts of the grid already explored and cover an even larger area. Like this, if we gradually increase the cost that we allow for exploration, there will be a cost value where the entire grid (along with the target cell), will be explored.</p>
<p>The primary difference between this approach and all the other ones is that previously we started with exploring the grid and populated the cost along the way. But here, we fix the cost and figure out how much we can explore adhering to it.</p>
<p>We'll use a combination of Breadth-First Search (BFS) and Depth-First Search (DFS) to implement our idea. Imagine our exploration as having levels; cells reachable with cost 0 being one level, cells with cost 1 as another, and so on. We'll use DFS to explore all cells at a given level (cost) and we'll use BFS to guide the exploration level by level until all the cells have been explored.</p>
<p>Let's break down how this works:</p>
<p>Starting at (0,0), we use DFS to follow the arrows without any modifications. If a cell points right and we follow it right, that's free! We keep following these zero-cost paths until we can't go further. Think of this as drawing a continuous line through cells, following arrows until we have to lift our pencil.</p>
<p>Every time we reach a cell through DFS, we also add it to a queue. These cells will serve as the starting points for the next level of exploration.</p>
<p>After we've explored all zero-cost paths, we switch to BFS. We take a cell from the queue, and make a modification to the direction, thereby increasing the cost by 1. With the new direction of the current cell, new cells in the grid are now reachable, and we explore all cells using DFS like before. As we explore the grid using DFS, we maintain a grid <code>minCost</code> which stores the cost at which we first visited that cell.</p>
<p>We continue this process of modification for all direction values for each cell at the current level. After the current level is explored, we increase the cost by 1 again and start modifying the direction of cells in the queue to explore further.</p>
<p>As usual, when all the cells in the grid have been explored, we'll return the bottom-right corner of the <code>minCost</code> array as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize a directions array <code>dirs</code> with four vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize the variables for <code>numRows</code>, <code>numCols</code>, and the initial <code>cost</code> (set to 0).</li>
<li>Create a 2D array <code>minCost</code> to track the minimum cost to reach each cell.</li>
<li>Fill the <code>minCost</code> array with maximum integer values to mark cells as unvisited.</li>
<li>Create a <code>queue</code> to store cells that need cost increments for the BFS part.</li>
<li>Call <code>dfs</code> from the origin <code>(0,0)</code> with the initial cost of 0.</li>
<li>In the BFS part, while the <code>queue</code> is not empty:
<ul>
<li>Increment the <code>cost</code> by 1.</li>
<li>Store the current level size.</li>
<li>Process all cells at the current level:
<ul>
<li>Poll a cell from the <code>queue</code>.</li>
<li>For each of the four directions:
<ul>
<li>Call <code>dfs</code> from the new position with the current <code>cost</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Finally, return the minimum cost to reach the bottom-right cell of the grid (<code>minCost[numRows - 1][numCols - 1]</code>).</li>
</ul>
<p>Helper method <code>dfs(grid, row, col, minCost, cost, queue)</code>:</p>
<ul>
<li>Check if the current cell is valid and unvisited using the <code>isUnvisited</code> function.</li>
<li>If not valid or already visited, return.</li>
<li>Set the current cell's cost in the <code>minCost</code> array.</li>
<li>Add the current cell to the <code>queue</code>.</li>
<li>Calculate the next direction based on the <code>grid</code> value (subtracting 1 for 0-based indexing).</li>
<li>Recursively call <code>dfs</code> in the direction pointed by the arrow without increasing the cost.</li>
</ul>
<p>Helper method <code>isUnvisited(minCost, row, col)</code>:</p>
<ul>
<li>Check if the row and column are within the grid bounds.</li>
<li>Check if the cell has not been visited (still has maximum value).</li>
<li>Return <code>true</code> only if both conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ti9zFAP6/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a hybrid DFS-BFS approach. In the DFS part, each cell is visited at most once when following zero-cost paths (following arrows). In the BFS part, each cell might be added to the queue once for exploration in different directions, but again, each cell is processed at most once since we only visit unvisited cells. Since each cell can only be visited once in both phases, and for each cell, we perform constant time operations, the total time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses multiple data structures that each can grow up to <span class="math inline">\(O(n \cdot m)\)</span>: the <code>minCost</code> array to track visited cells, the <code>queue</code> for BFS that in the worst case might contain all cells, and the recursive call stack for DFS that in worst case might go through all cells in a snake-like pattern. Thus, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/description" target="_blank" rel="noopener noreferrer">Minimum Obstacle Removal to Reach Corner</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code>. Each cell has one of two values:</p>

<ul>
	<li><code>0</code> represents an <strong>empty</strong> cell,</li>
	<li><code>1</code> represents an <strong>obstacle</strong> that may be removed.</li>
</ul>

<p>You can move up, down, left, or right from and to an empty cell.</p>

<p>Return <em>the <strong>minimum</strong> number of <strong>obstacles</strong> to <strong>remove</strong> so you can move from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png" style="width: 605px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
It can be shown that we need to remove at least 2 obstacles, so we return 2.
Note that there may be other ways to remove 2 obstacles to create a path.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png" style="width: 405px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2-D matrix <code>grid</code>, where each cell is either empty or contains an obstacle. We can remove any obstacle, and our goal is to find the minimum number of obstacles that need to be removed to create a path from the top-left corner to the bottom-right corner.</p>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We can frame this problem as a shortest-path problem with a start and end point, and from each cell, we can move in four directions (up, down, left, right). There are two scenarios for movement:</p>
<ol>
<li>Moving to an empty cell costs nothing (edge weight = 0).</li>
<li>Moving to a cell with an obstacle costs 1 as we must remove it (edge weight = 1).</li>
</ol>
<p>This turns our problem into a graph with edges weighted 0 or 1. The goal is to find the shortest path from the start to the destination using Dijkstra's algorithm.</p>
<p>We’ll implement Dijkstra’s algorithm using a priority queue, where each element contains the cell's coordinates and the number of obstacles removed to reach it. The queue will be sorted by obstacle count in increasing order. For each element, we explore its four neighbors. If a neighbor contains an obstacle, we increment the obstacle count and add it to the queue for further exploration.</p>
<p>As we explore, we’ll eventually reach the destination cell. Once we do, we return its obstacle count, which is guaranteed to be the minimum, as the queue prioritizes cells with the fewest obstacles.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Set dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.
<ul>
<li>Set all cells in <code>minObstacles</code> to infinity to represent unvisited cells.</li>
</ul>
</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to the value of <code>grid[0][0]</code>, since this is the initial position.</li>
<li>Create a priority queue <code>pq</code> that orders elements based on the number of obstacles encountered.
<ul>
<li>Each element in the queue is an array containing: [obstacles count, row, column]</li>
</ul>
</li>
<li>Add the starting position to the priority queue with its obstacle count.</li>
<li>Enter a loop that continues while <code>pq</code> is not empty:
<ul>
<li>Extract the cell with minimum obstacles from the queue.</li>
<li>If this cell is the target <code>(m-1, n-1)</code>, return the obstacle count.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid:
<ul>
<li>Calculate the new obstacle count by adding the grid value of the new position.</li>
<li>If the new obstacle count is less than the previously recorded count for that cell:</li>
<li>Update the <code>minObstacles</code> array with the new count.</li>
<li>Add the new position to <code>pq</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return -1 if the main loop completes without finding the target (this shouldn't happen).</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z4CaAqmQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>The priority queue can contain up to <span class="math inline">\(O(m \cdot n)\)</span> elements (all the cells in the grid), making each operation cost <span class="math inline">\(O(\log(m \cdot n))\)</span> time. Thus, the time complexity is <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is dominated by two main components: the <code>minObstacles</code> array and the priority queue, both of which have a complexity of <span class="math inline">\(O(m \cdot n)\)</span>. The <code>directions</code> array and other variables take constant space.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-0-1-breadth-first-search-bfs">Approach 2: 0-1 Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As stated earlier, moving through cells without obstacles has no cost. Therefore, we prioritize exploring neighboring empty cells first, only moving to cells with obstacles when no free cells are left.</p>
<p>We perform a BFS using a deque to manage the queue. When exploring neighboring cells, we add empty cells to the front of the deque for immediate exploration, and cells with obstacles to the back, delaying their exploration.</p>
<p>We maintain a result grid, <code>minObstacles</code>, initialized to infinity (indicating they are unvisited), to track the minimum obstacles encountered at each cell. We'll add the top left cell to the deque and begin our exploration. At each step, we'll pop the top cell in the deque and explore its neighbors. All empty neighbors go to the front of the deque, while others go to the bottom with their obstacle count increased by 1. Simultaneously, we'll update the <code>minObstacles</code> value for each neighboring position.</p>
<p>Once all cells are explored, the value at the bottom-right cell of <code>minObstacles</code> will give the minimum obstacles encountered on the shortest path.</p>
<p>Here's a brief visualization of how the <code>minObstacles</code> matrix is filled up step by step:</p>
<p>!?!../Documents/2290/slideshow.json:702,942!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 2-D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Store the dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2-D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.</li>
<li>Initialize all cells in <code>minObstacles</code> with infinity to represent unvisited cells.</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to 0, as we start from this position.</li>
<li>Create a double-ended queue <code>deque</code> to process cells.
<ul>
<li>Add the starting position to the queue.</li>
</ul>
</li>
<li>Loop while the deque is not empty:
<ul>
<li>Extract the first cell from the queue.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid and unvisited (<code>minObstacles</code> value is infinity):
<ul>
<li>If the new cell contains an obstacle (value 1):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count plus 1.</li>
<li>Add the new position to the back of the deque.</li>
</ul>
</li>
<li>If the new cell is empty (value 0):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count.</li>
<li>Add a new position to the front of the deque.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minObstacles[m-1][n-1]</code> representing minimum obstacles removed to reach target.</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VbP4ycxv/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Each of the <span class="math inline">\(m \cdot n\)</span> cells in the grid is visited exactly once because we only process unvisited cells. The deque operations are all <span class="math inline">\(O(1)\)</span>.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The <code>minObstacles</code> array and the deque both take <span class="math inline">\(O(m \cdot n)\)</span> space. All other variables take constant space.</p>
<p>Thus, the space complexity remains <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-reach-destination-in-directed-graph/description" target="_blank" rel="noopener noreferrer">Minimum Time to Reach Destination in Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and a <strong>directed</strong> graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, start<sub>i</sub>, end<sub>i</sub>]</code> indicates an edge from node <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code> that can <strong>only</strong> be used at any integer time <code>t</code> such that <code>start<sub>i</sub> &lt;= t &lt;= end<sub>i</sub></code>.</p>

<p>You start at node 0 at time 0.</p>

<p>In one unit of time, you can either:</p>

<ul>
	<li>Wait at your current node without moving, or</li>
	<li>Travel along an outgoing edge from your current node if the current time <code>t</code> satisfies <code>start<sub>i</sub> &lt;= t &lt;= end<sub>i</sub></code>.</li>
</ul>

<p>Return the <strong>minimum</strong> time required to reach node <code>n - 1</code>. If it is impossible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,0,1],[1,2,2,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/05/screenshot-2025-06-06-at-004535.png" style="width: 150px; height: 141px;" /></p>

<p>The optimal path is:</p>

<ul>
	<li>At time <code>t = 0</code>, take the edge <code>(0 &rarr; 1)</code> which is available from 0 to 1. You arrive at node 1 at time <code>t = 1</code>, then wait until <code>t = 2</code>.</li>
	<li>At time <code>t = <code>2</code></code>, take the edge <code>(1 &rarr; 2)</code> which is available from 2 to 5. You arrive at node 2 at time 3.</li>
</ul>

<p>Hence, the minimum time to reach node 2 is 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,1,0,3],[1,3,7,8],[0,2,1,5],[2,3,4,7]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/05/screenshot-2025-06-06-at-004757.png" style="width: 170px; height: 219px;" /></p>

<p>The optimal path is:</p>

<ul>
	<li>Wait at node 0 until time <code>t = 1</code>, then take the edge <code>(0 &rarr; 2)</code> which is available from 1 to 5. You arrive at node 2 at <code>t = 2</code>.</li>
	<li>Wait at node 2 until time <code>t = 4</code>, then take the edge <code>(2 &rarr; 3)</code> which is available from 4 to 7. You arrive at node 3 at <code>t = 5</code>.</li>
</ul>

<p>Hence, the minimum time to reach node 3 is 5.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[1,0,1,3],[1,2,3,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/05/screenshot-2025-06-06-at-004914.png" style="width: 150px; height: 145px;" /></p>

<ul>
	<li>Since there is no outgoing edge from node 0, it is impossible to reach node 2. Hence, the output is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>, start<sub>i</sub>, end<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-transport-all-individuals/description" target="_blank" rel="noopener noreferrer">Minimum Time to Transport All Individuals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>n</code> individuals at a base camp who need to cross a river to reach a destination using a single boat. The boat can carry at most <code>k</code> people at a time. The trip is affected by environmental conditions that vary <strong>cyclically</strong> over <code>m</code> stages.</p>

<p>Each stage <code>j</code> has a speed multiplier <code>mul[j]</code>:</p>

<ul>
	<li>If <code>mul[j] &gt; 1</code>, the trip slows down.</li>
	<li>If <code>mul[j] &lt; 1</code>, the trip speeds up.</li>
</ul>

<p>Each individual <code>i</code> has a rowing strength represented by <code>time[i]</code>, the time (in minutes) it takes them to cross alone in neutral conditions.</p>

<p><strong>Rules:</strong></p>

<ul>
	<li>A group <code>g</code> departing at stage <code>j</code> takes time equal to the <strong>maximum</strong> <code>time[i]</code> among its members, multiplied by <code>mul[j]</code> minutes to reach the destination.</li>
	<li>After the group crosses the river in time <code>d</code>, the stage advances by <code>floor(d) % m</code> steps.</li>
	<li>If individuals are left behind, one person must return with the boat. Let <code>r</code> be the index of the returning person, the return takes <code>time[r] &times; mul[current_stage]</code>, defined as <code>return_time</code>, and the stage advances by <code>floor(return_time) % m</code>.</li>
</ul>

<p>Return the <strong>minimum</strong> total time required to transport all individuals. If it is not possible to transport all individuals to the destination, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 1, k = 1, m = 2, time = [5], mul = [1.0,1.3]</span></p>

<p><strong>Output:</strong> <span class="example-io">5.00000</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Individual 0 departs from stage 0, so crossing time = <code>5 &times; 1.00 = 5.00</code> minutes.</li>
	<li>All team members are now at the destination. Thus, the total time taken is <code>5.00</code> minutes.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, k = 2, m = 3, time = [2,5,8], mul = [1.0,1.5,0.75]</span></p>

<p><strong>Output:</strong> <span class="example-io">14.50000</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal strategy is:</p>

<ul>
	<li>Send individuals 0 and 2 from the base camp to the destination from stage 0. The crossing time is <code>max(2, 8) &times; mul[0] = 8 &times; 1.00 = 8.00</code> minutes. The stage advances by <code>floor(8.00) % 3 = 2</code>, so the next stage is <code>(0 + 2) % 3 = 2</code>.</li>
	<li>Individual 0 returns alone from the destination to the base camp from stage 2. The return time is <code>2 &times; mul[2] = 2 &times; 0.75 = 1.50</code> minutes. The stage advances by <code>floor(1.50) % 3 = 1</code>, so the next stage is <code>(2 + 1) % 3 = 0</code>.</li>
	<li>Send individuals 0 and 1 from the base camp to the destination from stage 0. The crossing time is <code>max(2, 5) &times; mul[0] = 5 &times; 1.00 = 5.00</code> minutes. The stage advances by <code>floor(5.00) % 3 = 2</code>, so the final stage is <code>(0 + 2) % 3 = 2</code>.</li>
	<li>All team members are now at the destination. The total time taken is <code>8.00 + 1.50 + 5.00 = 14.50</code> minutes.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, k = 1, m = 2, time = [10,10], mul = [2.0,2.0]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1.00000</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Since the boat can only carry one person at a time, it is impossible to transport both individuals as one must always return. Thus, the answer is <code>-1.00</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == time.length &lt;= 12</code></li>
	<li><code>1 &lt;= k &lt;= 5</code></li>
	<li><code>1 &lt;= m &lt;= 5</code></li>
	<li><code>1 &lt;= time[i] &lt;= 100</code></li>
	<li><code>m == mul.length</code></li>
	<li><code>0.5 &lt;= mul[i] &lt;= 2.0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Time to Visit a Cell In a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers where <code>grid[row][col]</code> represents the <strong>minimum</strong> time required to be able to visit the cell <code>(row, col)</code>, which means you can visit the cell <code>(row, col)</code> only when the time you visit it is greater than or equal to <code>grid[row][col]</code>.</p>

<p>You are standing in the <strong>top-left</strong> cell of the matrix in the <code>0<sup>th</sup></code> second, and you must move to <strong>any</strong> adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.</p>

<p>Return <em>the <strong>minimum</strong> time required in which you can visit the bottom-right cell of the matrix</em>. If you cannot visit the bottom-right cell, then return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png" /></p>

<pre>
<strong>Input:</strong> grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> One of the paths that we can take is the following:
- at t = 0, we are on the cell (0,0).
- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1.
- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2.
- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3.
- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4.
- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5.
- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6.
- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7.
The final time is 7. It can be shown that it is the minimum time possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png" style="width: 151px; height: 151px;" /></p>

<pre>
<strong>Input:</strong> grid = [[0,2,4],[3,2,1],[1,0,4]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no path from the top left to the bottom-right cell.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[0][0] == 0</code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-modified-dijkstras-algorithm">Approach: Modified Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a matrix <code>grid</code> where each cell contains the minimum time required for that cell to be accessible. In other words, if we begin at the top-left cell and each move takes 1 second, the value in each cell tells us the minimum time after which we can enter it.</p>
<p>The challenge arises when we find ourselves stuck in a cell, unable to move forward because all neighboring cells are inaccessible, with higher minimum times. In such situations, we must &quot;waste&quot; time to move forward. How do we do that? By wandering around! We can move back and forth between the current cell and any previously accessible cells until a neighboring cell becomes accessible.</p>
<p>The time we need to &quot;waste&quot; is determined by the difference between the current cell’s time and the minimum time of an accessible neighboring cell. It’s important to note that each unit of time wasted takes 2 seconds since we travel to a previous cell and return to the current cell. Therefore, if the difference between the current time and the target cell's time is odd, we can step into the target cell exactly when it becomes accessible. Here's a slideshow demonstrating that:</p>
<p>!?!../Documents/2577/odd_slideshow.json:564,822!?!</p>
<p>On the other hand, if the difference is even, we’ll arrive at the target cell 1 second after it has opened:</p>
<p>!?!../Documents/2577/even_slideshow.json:564,822!?!</p>
<p>Next, let’s discuss the base case. If we are at the top-left corner and all neighboring cells have a minimum time greater than 1, we are stuck. There are no other accessible cells to waste time on, and thus, the solution is not possible. In this case, we return -1.</p>
<p>Otherwise, a solution exists. We can apply Dijkstra’s shortest path algorithm with a priority queue, starting from the top-left cell. Each element in the queue holds the cell’s coordinates and the time taken to reach it, ordered by time in ascending order. We also maintain a <code>visited</code> matrix to track the cells we have already processed. For each cell in the queue, we check its neighbors, compute the time required to enter each one, and add any accessible neighbors to the queue, adjusting for the waiting time. When we reach the bottom-right corner, we return the associated time as the final answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Check if both initial moves (right and down) in the grid require more than 1 second:</p>
<ul>
<li>If both <code>grid[0][1] &gt; 1</code> and <code>grid[1][0] &gt; 1</code>, return <code>-1</code> because it’s impossible to proceed.</li>
</ul>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>rows</code> and <code>cols</code> store the dimensions of the grid.</li>
<li><code>directions</code> array defines the possible moves: down, up, right, and left.</li>
<li><code>visited</code> array keeps track of visited cells.</li>
<li><code>pq</code> is a priority queue that stores <code>{time, row, col}</code> tuples, ordered by minimum time to reach each cell.</li>
</ul>
</li>
<li>
<p>Add the starting point (top-left cell) to the priority queue with its initial time (<code>grid[0][0]</code>).</p>
</li>
<li>
<p>While the priority queue is not empty:</p>
<ul>
<li>
<p>Poll the cell with the minimum time (<code>time, row, col</code>).</p>
</li>
<li>
<p>If the target cell (bottom-right) is reached, return the <code>time</code>.</p>
</li>
<li>
<p>Skip the current cell if it has already been visited.</p>
</li>
<li>
<p>Mark the current cell as visited.</p>
</li>
<li>
<p>For each of the four possible directions:</p>
<ul>
<li>Calculate the next cell coordinates (<code>nextRow, nextCol</code>).</li>
<li>If the cell is valid (within bounds and not visited), calculate the additional wait time for the next cell:
<ul>
<li>If the difference between the grid value and the current time is even, the additional wait time is <code>1</code>.</li>
<li>Otherwise, the wait time is <code>0</code>.</li>
</ul>
</li>
<li>Calculate the next possible time based on the grid value and the wait time, and add the new <code>{nextTime, nextRow, nextCol}</code> to the priority queue.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the loop ends without reaching the target, return <code>-1</code> (no path found).</p>
</li>
<li>
<p>Helper function <code>isValid</code>:</p>
<ul>
<li>Check if a cell is within bounds and has not been visited.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/J2vnwBjv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>In the main loop, the priority queue operations (insertion and deletion) take <span class="math inline">\(O(\log k)\)</span> time where <span class="math inline">\(k\)</span> is the number of elements in the queue. Since each cell is added to the queue exactly once, the queue size is bounded by <span class="math inline">\(O(m \cdot n)\)</span>. Therefore, with <span class="math inline">\(O(m \cdot n)\)</span> cells and <span class="math inline">\(O(\log(m \cdot n))\)</span> time for each queue operation, the total time complexity is <span class="math inline">\(O(m \cdot n\log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is determined by two main components: the <code>visited</code> boolean matrix and the priority queue, both of which use <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-visit-disappearing-nodes/description" target="_blank" rel="noopener noreferrer">Minimum Time to Visit Disappearing Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected graph of <code>n</code> nodes. You are given a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code> describes an edge between node <code>u<sub>i</sub></code> and node <code>v<sub>i</sub></code> with a traversal time of <code>length<sub>i</sub></code> units.</p>

<p>Additionally, you are given an array <code>disappear</code>, where <code>disappear[i]</code> denotes the time when the node <code>i</code> disappears from the graph and you won&#39;t be able to visit it.</p>

<p><strong>Note</strong>&nbsp;that the graph might be <em>disconnected</em> and might contain <em>multiple edges</em>.</p>

<p>Return the array <code>answer</code>, with <code>answer[i]</code> denoting the <strong>minimum</strong> units of time required to reach node <code>i</code> from node 0. If node <code>i</code> is <strong>unreachable</strong> from node 0 then <code>answer[i]</code> is <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/output-onlinepngtools.png" style="width: 350px; height: 210px;" /></p>

<p>We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.</p>

<ul>
	<li>For node 0, we don&#39;t need any time as it is our starting point.</li>
	<li>For node 1, we need at least 2 units of time to traverse <code>edges[0]</code>. Unfortunately, it disappears at that moment, so we won&#39;t be able to visit it.</li>
	<li>For node 2, we need at least 4 units of time to traverse <code>edges[2]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/output-onlinepngtools-1.png" style="width: 350px; height: 210px;" /></p>

<p>We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.</p>

<ul>
	<li>For node 0, we don&#39;t need any time as it is the starting point.</li>
	<li>For node 1, we need at least 2 units of time to traverse <code>edges[0]</code>.</li>
	<li>For node 2, we need at least 3 units of time to traverse <code>edges[0]</code> and <code>edges[1]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1,1]], disappear = [1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1]</span></p>

<p><strong>Explanation:</strong></p>

<p>Exactly when we reach node 1, it disappears.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>disappear.length == n</code></li>
	<li><code>1 &lt;= disappear[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/description" target="_blank" rel="noopener noreferrer">Minimum Weighted Subgraph With the Required Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> denoting the number of nodes of a <strong>weighted directed</strong> graph. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> denotes that there exists a <strong>directed</strong> edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with weight <code>weight<sub>i</sub></code>.</p>

<p>Lastly, you are given three <strong>distinct</strong> integers <code>src1</code>, <code>src2</code>, and <code>dest</code> denoting three distinct nodes of the graph.</p>

<p>Return <em>the <strong>minimum weight</strong> of a subgraph of the graph such that it is <strong>possible</strong> to reach</em> <code>dest</code> <em>from both</em> <code>src1</code> <em>and</em> <code>src2</code> <em>via a set of edges of this subgraph</em>. In case such a subgraph does not exist, return <code>-1</code>.</p>

<p>A <strong>subgraph</strong> is a graph whose vertices and edges are subsets of the original graph. The <strong>weight</strong> of a subgraph is the sum of weights of its constituent edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png" style="width: 263px; height: 250px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
<strong>Output:</strong> 9
<strong>Explanation:</strong>
The above figure represents the input graph.
The blue edges represent one of the subgraphs that yield the optimal answer.
Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png" style="width: 350px; height: 51px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong>
The above figure represents the input graph.
It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li><code>src1</code>, <code>src2</code>, and <code>dest</code> are pairwise distinct.</li>
	<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/modify-graph-edge-weights/description" target="_blank" rel="noopener noreferrer">Modify Graph Edge Weights</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <strong>undirected weighted</strong> <strong>connected</strong> graph containing <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, and an integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>Some edges have a weight of <code>-1</code> (<code>w<sub>i</sub> = -1</code>), while others have a <strong>positive</strong> weight (<code>w<sub>i</sub> &gt; 0</code>).</p>

<p>Your task is to modify <strong>all edges</strong> with a weight of <code>-1</code> by assigning them <strong>positive integer values </strong>in the range <code>[1, 2 * 10<sup>9</sup>]</code> so that the <strong>shortest distance</strong> between the nodes <code>source</code> and <code>destination</code> becomes equal to an integer <code>target</code>. If there are <strong>multiple</strong> <strong>modifications</strong> that make the shortest distance between <code>source</code> and <code>destination</code> equal to <code>target</code>, any of them will be considered correct.</p>

<p>Return <em>an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from </em><code>source</code><em> to </em><code>destination</code><em> equal to </em><code>target</code><em>, or an <strong>empty array</strong> if it&#39;s impossible.</em></p>

<p><strong>Note:</strong> You are not allowed to modify the weights of edges with initial positive weights.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/18/graph.png" style="width: 300px; height: 300px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
<strong>Output:</strong> [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
<strong>Explanation:</strong> The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/18/graph-2.png" style="width: 300px; height: 300px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
<strong>Output:</strong> []
<strong>Explanation:</strong> The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/19/graph-3.png" style="width: 300px; height: 300px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
<strong>Output:</strong> [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
<strong>Explanation:</strong> The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code><font face="monospace">1 &lt;= edges.length &lt;= n * (n - 1) / 2</font></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i&nbsp;</sub>&lt;&nbsp;n</code></li>
	<li><code><font face="monospace">w<sub>i</sub>&nbsp;= -1&nbsp;</font></code>or <code><font face="monospace">1 &lt;= w<sub>i&nbsp;</sub>&lt;= 10<sup><span style="font-size: 10.8333px;">7</span></sup></font></code></li>
	<li><code>a<sub>i&nbsp;</sub>!=&nbsp;b<sub>i</sub></code></li>
	<li><code>0 &lt;= source, destination &lt; n</code></li>
	<li><code>source != destination</code></li>
	<li><code><font face="monospace">1 &lt;= target &lt;= 10<sup>9</sup></font></code></li>
	<li>The graph is connected, and there are no self-loops or repeated edges</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We've got a connected graph with <code>n</code> nodes, where edges connect pairs of nodes with certain weights. Our goal is to adjust the graph so that the shortest path between two specific nodes, <code>source</code> and <code>destination</code>, matches a given target distance.</p>
<p>The input provides:</p>
<ul>
<li>The number of nodes <code>n</code>.</li>
<li>A list of edges, each described by <span class="math inline">\([a_i, b_i, w_i]\)</span>, where <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_i\)</span> are the nodes connected by the edge, and <span class="math inline">\(w_i\)</span> is its weight.</li>
<li>Two nodes, <code>source</code> and <code>destination</code>.</li>
<li>A <code>target</code> distance that we want the shortest path between <code>source</code> and <code>destination</code> to exactly match.</li>
</ul>
<p>Some edges have weights of <code>-1</code>, meaning we need to assign them positive weights. Other edges have fixed weights that can’t be changed.</p>
<p>Our task is to find positive weights for the <code>-1</code> edges so that the shortest path from <code>source</code> to <code>destination</code> equals the <code>target</code> distance. The new weights should be between <code>1</code> and <code>2 * 10^9</code>.</p>
<p>If we can adjust the weights to meet the target distance, we return the updated list of edges. If not, we return an empty list. There might be several correct ways to set the weights, and any of them will work.</p>
<p>This problem is similar to designing a road network where some roads have fixed distances and others are planned but not yet constructed. The challenge is to adjust the planned road lengths so that the shortest route between two cities meets the specified distance, all while considering the existing infrastructure.</p>
<p>To fully grasp the solution, it’s a good idea to review <a href="https://leetcode.com/explore/featured/card/graph/">Dijkstra's algorithm</a> first, as our approach relies heavily on its principles.</p>
<hr />
<h3 id="approach-1-traditional-dijkstras-algorithm">Approach 1: Traditional Dijkstra's algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>The idea behind the solution is to use Dijkstra's algorithm, which is great for finding the shortest paths in a graph with non-negative edge weights. We tweak the algorithm a bit to handle situations where some of the edge weights have to be figured out as we go along.</p>
<p>We start by running Dijkstra's algorithm but ignore any edges with weights of <code>-1</code> for now. This first run helps us find the shortest distance from the <code>source</code> to the <code>destination</code>. We then check how this distance compares to our <code>target</code> distance.</p>
<ol>
<li>
<p>If the shortest distance matches the <code>target</code>, the current positive weights already give us the desired path length. In this case, we can set the <code>-1</code> edges to a large value (like <code>2 × 10^9</code>) to make sure they don’t change the shortest path.</p>
</li>
<li>
<p>If the shortest distance is less than the <code>target</code>, there’s no way to extend the path to reach the <code>target</code> just by adjusting the <code>-1</code> edges. In this scenario, the graph structure doesn’t support increasing the path length, so we return an empty list.</p>
</li>
<li>
<p>If the shortest distance is more than the <code>target</code>, we need to reduce the path length by tweaking the <code>-1</code> edges.</p>
</li>
</ol>
<p>We start by setting a high weight on the <code>-1</code> edges to ensure they don’t interfere with our initial path calculation. Then, we adjust the weight of each <code>-1</code> edge to a smaller value (like <code>1</code>) and rerun Dijkstra’s algorithm to see if the shortest path gets closer to the target distance.</p>
<p>If changing an edge’s weight helps get the shortest path closer to the target, we update the weight. We repeat this until we find suitable weights for all <code>-1</code> edges that give us the target distance.</p>
<p>If we manage to find weights that achieve the target distance, we return the updated edge list. If not, we return an empty list.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define <code>INF</code> as a large constant representing infinity.</li>
</ul>
<p>Inside the main function <code>modifiedGraphEdges</code>:</p>
<ul>
<li>Calculate the initial shortest path from <code>source</code> to <code>destination</code> using Dijkstra's algorithm(<code>runDijkstra</code> helper function), storing the result in <code>currentShortestDistance</code>.</li>
<li>Check if the current distance is less than the target:
<ul>
<li>If yes, return an empty result as it's impossible to achieve the target distance.</li>
</ul>
</li>
<li>Determine if the current distance matches the target:
<ul>
<li>If it does, set a flag <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>Iterate through each edge to adjust weights:
<ul>
<li>Skip edges that already have a positive weight since they don't need adjustment.</li>
<li>Set edge weight:
<ul>
<li>If <code>matchesTarget</code> is true, set the weight to a large value (<code>INF</code>).</li>
<li>Otherwise, set the weight to 1.</li>
</ul>
</li>
</ul>
</li>
<li>Check if the current distance matches the target:
<ul>
<li>If not, recompute the shortest distance using Dijkstra's algorithm with the updated edge weights.</li>
<li>If the new distance is within the target range, adjust the edge weight to match the target, and update <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>Return modified edges:
<ul>
<li>If the target distance is achieved (<code>matchesTarget</code> is true), return the modified edges.</li>
<li>Otherwise, return an empty result.</li>
</ul>
</li>
</ul>
<p>Inside the helper function <code>runDijkstra</code>:</p>
<ul>
<li>Initialize adjacency matrix with a large value (<code>INF</code>) to represent no direct connection between nodes.</li>
<li>Initialize distance array to store the minimum distance from the source node to each node, initially set to <code>INF</code>.</li>
<li>Mark the distance to the source node as 0 because the shortest path to itself is zero.</li>
<li>Fill the adjacency matrix with the weights of the edges from the input.</li>
<li>Perform Dijkstra's algorithm:
<ul>
<li>Iterate through all nodes to find the shortest path.</li>
<li>Find the nearest unvisited node with the smallest distance from the source.</li>
<li>Mark the nearest node as visited to avoid reprocessing.</li>
<li>Update the minimum distance for each adjacent node based on the newly visited node's distance.</li>
</ul>
</li>
<li>Return the shortest distance to the destination node as the result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4wcKVMHK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(V\)</span> be the number of nodes and <span class="math inline">\(E\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(E \times V^2)\)</span></p>
<p>Dijkstra's algorithm runs in <span class="math inline">\(O(V^2)\)</span> time, due to the adjacency matrix representation.</p>
<p>The overall complexity is <span class="math inline">\(O(E \times V^2)\)</span> because we potentially run Dijkstra's algorithm for each modifiable edge.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(V^2)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(V^2)\)</span> due to the adjacency matrix, with additional space for the distance and visited arrays.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dijkstras-algorithm-with-min-heap">Approach 2: Dijkstra's Algorithm with Min-Heap</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the traditional approach, after initializing distances, we repeatedly scan all nodes to find the unvisited node with the smallest tentative distance. This operation takes <span class="math inline">\(O(n)\)</span> time per selection, leading to an overall time complexity of <span class="math inline">\(O(n^2)\)</span> in the worst case.</p>
<p>To optimize this, we use a priority queue (min-heap) to manage and retrieve the node with the smallest tentative distance efficiently. When a node is processed, its neighbors are updated, and if a shorter path is found, the neighbor is pushed onto the priority queue with its updated distance. This ensures that the next node to be processed is always the one with the smallest distance.</p>
<p>Apart from the use of a priority queue, the approach remains largely the same: we construct the graph, ignoring edges with weights of <code>-1</code>, as these represent unknown or adjustable weights. We then compute the shortest distance from the source to the destination using the optimized Dijkstra algorithm. If the computed distance is already less than the target, we return an empty result.</p>
<p>If the distance matches the target, we set all <code>-1</code> edges to a large value (<code>INF</code>) to prevent any further adjustments. If the initial distance exceeds the target, we adjust the <code>-1</code> edges to a minimal weight of 1, re-run Dijkstra's algorithm, and fine-tune the last adjusted edge to exactly match the target.</p>
<blockquote>
<p>Here we require additional memory for the priority queue. The queue needs to store nodes and their tentative distances, which slightly increases memory usage, but this is usually a reasonable trade-off for the gained efficiency.</p>
</blockquote>
<p>!?!../Documents/2699/modifygraph.json:835,575!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define <code>INF</code> as a large constant representing infinity.</li>
</ul>
<p>Inside the main function <code>modifiedGraphEdges</code>:</p>
<ul>
<li>
<p>Build the graph:</p>
<ul>
<li>Iterate through each edge in the input list.</li>
<li>For edges with a positive weight (not <code>-1</code>), add them to the adjacency list for both nodes.</li>
</ul>
</li>
<li>
<p>Calculate the initial shortest path from <code>source</code> to <code>destination</code> using Dijkstra's algorithm (<code>runDijkstra</code> helper function), storing the result in <code>currentShortestDistance</code>.</p>
</li>
<li>
<p>Check if the current shortest distance is less than the target:</p>
<ul>
<li>If true, return an empty result as it is impossible to achieve the target distance with the given edges.</li>
</ul>
</li>
<li>
<p>Determine if the current distance matches the target:</p>
<ul>
<li>If it does, set a flag <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>
<p>Iterate through each edge to adjust weights:</p>
<ul>
<li>Skip edges that already have a positive weight since they don't need adjustment.</li>
<li>For each edge with weight <code>-1</code>:
<ul>
<li>Set the edge weight to a large value (<code>INF</code>) if <code>matchesTarget</code> is true.</li>
<li>Otherwise, set the edge weight to 1.</li>
<li>Update the adjacency list with the new weight.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check if the updated shortest distance matches the target:</p>
<ul>
<li>If <code>matchesTarget</code> is false, recompute the shortest distance using Dijkstra's algorithm with the updated edge weights.</li>
<li>If the new distance is within the target range, adjust the edge weight to match the target distance, and update <code>matchesTarget</code> to true.</li>
</ul>
</li>
<li>
<p>Return modified edges:</p>
<ul>
<li>If the target distance is achieved (<code>matchesTarget</code> is true), return the modified edges.</li>
<li>Otherwise, return an empty result.</li>
</ul>
</li>
</ul>
<p>Inside the helper function <code>runDijkstra</code>:</p>
<ul>
<li>
<p>Initialize the <code>minDistance</code> array to store the minimum distance from the source node to each node, initially set to <code>INF</code>.</p>
</li>
<li>
<p>Initialize a priority queue to process nodes in order of their current known shortest distance.</p>
</li>
<li>
<p>Set the <code>minDistance</code> to the source node as 0 because the shortest path to itself is zero.</p>
</li>
<li>
<p>Perform Dijkstra's algorithm:</p>
<ul>
<li>Iterate through all nodes to find the shortest path.</li>
<li>Extract the node with the smallest distance from the source.</li>
<li>Update the minimum distance for each adjacent node based on the extracted node's distance.</li>
<li>Push updated distances into the priority queue.</li>
</ul>
</li>
<li>
<p>Return the shortest distance to the destination node as the result.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GmrtoLsP/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(V\)</span> be the number of nodes and <span class="math inline">\(E\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(E \times (V + E) \log V)\)</span></p>
<p>Dijkstra's algorithm operates with a time complexity of <span class="math inline">\(O((V + E) \log V)\)</span> when using a priority queue (min-heap). This is because each vertex and edge is processed at most once, and each priority queue operation (insertion and extraction) takes <span class="math inline">\(O(\log V)\)</span> time.</p>
<p>Dijkstra's algorithm once executes the shortest path from the source to the destination with the current weights. Then, for each edge that weights <code>-1</code>, Dijkstra's algorithm is rerun after modifying the edge weight. In the worst-case scenario, where all edges weigh <code>-1</code>, this results in running Dijkstra's up to <span class="math inline">\(E\)</span> times.</p>
<p>Thus, the overall time complexity for handling all possible edge modifications is <span class="math inline">\(O(E \times (V + E) \log V)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(V + E)\)</span></p>
<p>The adjacency list representation of the graph requires <span class="math inline">\(O(V + E)\)</span> space. Each vertex has a list of its adjacent vertices and their corresponding edge weights.</p>
<p>Dijkstra’s algorithm uses an array to store the shortest distance from the source to each vertex, which requires <span class="math inline">\(O(V)\)</span> space.</p>
<p>The priority queue used during Dijkstra's algorithm can hold up to <span class="math inline">\(V\)</span> elements, which also requires <span class="math inline">\(O(V)\)</span> space.</p>
<p>Summing up these components, the total space complexity is <span class="math inline">\(O(V + E)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/network-delay-time/description" target="_blank" rel="noopener noreferrer">Network Delay Time</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. You are also given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>, where <code>u<sub>i</sub></code> is the source node, <code>v<sub>i</sub></code> is the target node, and <code>w<sub>i</sub></code> is the time it takes for a signal to travel from source to target.</p>

<p>We will send a signal from a given node <code>k</code>. Return <em>the <strong>minimum</strong> time it takes for all the</em> <code>n</code> <em>nodes to receive the signal</em>. If it is impossible for all the <code>n</code> nodes to receive the signal, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" style="width: 217px; height: 239px;" />
<pre>
<strong>Input:</strong> times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 1
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 2
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= times.length &lt;= 6000</code></li>
	<li><code>times[i].length == 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= w<sub>i</sub> &lt;= 100</code></li>
	<li>All the pairs <code>(u<sub>i</sub>, v<sub>i</sub>)</code> are <strong>unique</strong>. (i.e., no multiple edges.)</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/network-recovery-pathways/description" target="_blank" rel="noopener noreferrer">Network Recovery Pathways</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="502" data-start="75">You are given a directed acyclic graph of <code>n</code> nodes numbered from 0 to <code>n &minus; 1</code>. This is represented by a 2D array <code data-end="201" data-start="194">edges</code> of length<font face="monospace"> <code>m</code></font>, where <code data-end="255" data-start="227">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code> indicates a one‑way communication from node <code data-end="304" data-start="300">u<sub>i</sub></code> to node <code data-end="317" data-start="313">v<sub>i</sub></code> with a recovery cost of <code data-end="349" data-start="342">cost<sub>i</sub></code>.</p>

<p data-end="502" data-start="75">Some nodes may be offline. You are given a boolean array <code data-end="416" data-start="408">online</code> where <code data-end="441" data-start="423">online[i] = true</code> means node <code data-end="456" data-start="453">i</code> is online. Nodes 0 and <code>n &minus; 1</code> are always online.</p>

<p data-end="547" data-start="504">A path from 0 to <code>n &minus; 1</code> is <strong data-end="541" data-start="532">valid</strong> if:</p>

<ul>
	<li>All intermediate nodes on the path are online.</li>
	<li data-end="676" data-start="605">The total recovery cost of all edges on the path does not exceed <code>k</code>.</li>
</ul>

<p data-end="771" data-start="653">For each valid path, define its <strong data-end="694" data-start="685">score</strong> as the minimum edge‑cost along that path.</p>

<p data-end="913" data-start="847">Return the <strong>maximum</strong> path score (i.e., the largest <strong>minimum</strong>-edge cost) among all valid paths. If no valid path exists, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,5],[1,3,10],[0,2,3],[2,3,4]], online = [true,true,true,true], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-10.png" style="width: 239px; height: 267px;" /></p>

<ul data-end="551" data-start="146">
	<li data-end="462" data-start="146">
	<p data-end="206" data-start="148">The graph has two possible routes from node 0 to node 3:</p>

	<ol data-end="462" data-start="209">
		<li data-end="315" data-start="209">
		<p data-end="228" data-start="212">Path <code>0 &rarr; 1 &rarr; 3</code></p>

		<ul data-end="315" data-start="234">
			<li data-end="315" data-start="234">
			<p data-end="315" data-start="236">Total cost = <code>5 + 10 = 15</code>, which exceeds k (<code>15 &gt; 10</code>), so this path is invalid.</p>
			</li>
		</ul>
		</li>
		<li data-end="462" data-start="318">
		<p data-end="337" data-start="321">Path <code>0 &rarr; 2 &rarr; 3</code></p>

		<ul data-end="462" data-start="343">
			<li data-end="397" data-start="343">
			<p data-end="397" data-start="345">Total cost = <code>3 + 4 = 7 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="462" data-start="403">
			<p data-end="462" data-start="405">The minimum edge‐cost along this path is <code>min(3, 4) = 3</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="551" data-start="463">
	<p data-end="551" data-start="465">There are no other valid paths. Hence, the maximum among all valid path‐scores is 3.</p>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,7],[1,4,5],[0,2,6],[2,3,6],[3,4,2],[2,4,6]], online = [true,true,true,false,true], k = 12</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-11.png" style="width: 343px; height: 194px;" /></p>

<ul>
	<li data-end="790" data-start="726">
	<p data-end="790" data-start="728">Node 3 is offline, so any path passing through 3 is invalid.</p>
	</li>
	<li data-end="1231" data-start="791">
	<p data-end="837" data-start="793">Consider the remaining routes from 0 to 4:</p>

	<ol data-end="1231" data-start="840">
		<li data-end="985" data-start="840">
		<p data-end="859" data-start="843">Path <code>0 &rarr; 1 &rarr; 4</code></p>

		<ul data-end="985" data-start="865">
			<li data-end="920" data-start="865">
			<p data-end="920" data-start="867">Total cost = <code>7 + 5 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="985" data-start="926">
			<p data-end="985" data-start="928">The minimum edge‐cost along this path is <code>min(7, 5) = 5</code>.</p>
			</li>
		</ul>
		</li>
		<li data-end="1083" data-start="988">
		<p data-end="1011" data-start="991">Path <code>0 &rarr; 2 &rarr; 3 &rarr; 4</code></p>

		<ul data-end="1083" data-start="1017">
			<li data-end="1083" data-start="1017">
			<p data-end="1083" data-start="1019">Node 3 is offline, so this path is invalid regardless of cost.</p>
			</li>
		</ul>
		</li>
		<li data-end="1231" data-start="1086">
		<p data-end="1105" data-start="1089">Path <code>0 &rarr; 2 &rarr; 4</code></p>

		<ul data-end="1231" data-start="1111">
			<li data-end="1166" data-start="1111">
			<p data-end="1166" data-start="1113">Total cost = <code>6 + 6 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="1231" data-start="1172">
			<p data-end="1231" data-start="1174">The minimum edge‐cost along this path is <code>min(6, 6) = 6</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="1314" data-is-last-node="" data-start="1232">
	<p data-end="1314" data-is-last-node="" data-start="1234">Among the two valid paths, their scores are 5 and 6. Therefore, the answer is 6.</p>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="42" data-start="20"><code data-end="40" data-start="20">n == online.length</code></li>
	<li data-end="63" data-start="45"><code data-end="61" data-start="45">2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="102" data-start="66"><code data-end="100" data-start="66">0 &lt;= m == edges.length &lt;= </code><code>min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>
	<li data-end="102" data-start="66"><code data-end="127" data-start="105">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code></li>
	<li data-end="151" data-start="132"><code data-end="149" data-start="132">0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li data-end="166" data-start="154"><code data-end="164" data-start="154">u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="191" data-start="169"><code data-end="189" data-start="169">0 &lt;= cost<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li data-end="213" data-start="194"><code data-end="211" data-start="194">0 &lt;= k &lt;= 5 * 10<sup>13</sup></code></li>
	<li data-end="309" data-start="216"><code data-end="227" data-start="216">online[i]</code> is either <code data-end="244" data-is-only-node="" data-start="238">true</code> or <code data-end="255" data-start="248">false</code>, and both <code data-end="277" data-start="266">online[0]</code> and <code data-end="295" data-start="282">online[n &minus; 1]</code> are <code data-end="306" data-start="300">true</code>.</li>
	<li data-end="362" data-is-last-node="" data-start="312">The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-possible-sets-of-closing-branches/description" target="_blank" rel="noopener noreferrer">Number of Possible Sets of Closing Branches</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">enumeration</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a company with <code>n</code> branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads.</p>

<p>The company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches (<strong>possibly none</strong>). However, they want to ensure that the remaining branches have a distance of at most <code>maxDistance</code> from each other.</p>

<p>The <strong>distance</strong> between two branches is the <strong>minimum</strong> total traveled length needed to reach one branch from another.</p>

<p>You are given integers <code>n</code>, <code>maxDistance</code>, and a <strong>0-indexed</strong> 2D array <code>roads</code>, where <code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> represents the <strong>undirected</strong> road between branches <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with length <code>w<sub>i</sub></code>.</p>

<p>Return <em>the number of possible sets of closing branches, so that any branch has a distance of at most </em><code>maxDistance</code><em> from any other</em>.</p>

<p><strong>Note</strong> that, after closing a branch, the company will no longer have access to any roads connected to it.</p>

<p><strong>Note</strong> that, multiple roads are allowed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/11/08/example11.png" style="width: 221px; height: 191px;" />
<pre>
<strong>Input:</strong> n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The possible sets of closing branches are:
- The set [2], after closing, active branches are [0,1] and they are reachable to each other within distance 2.
- The set [0,1], after closing, the active branch is [2].
- The set [1,2], after closing, the active branch is [0].
- The set [0,2], after closing, the active branch is [1].
- The set [0,1,2], after closing, there are no active branches.
It can be proven, that there are only 5 possible sets of closing branches.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/11/08/example22.png" style="width: 221px; height: 241px;" />
<pre>
<strong>Input:</strong> n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The possible sets of closing branches are:
- The set [], after closing, active branches are [0,1,2] and they are reachable to each other within distance 4.
- The set [0], after closing, active branches are [1,2] and they are reachable to each other within distance 2.
- The set [1], after closing, active branches are [0,2] and they are reachable to each other within distance 2.
- The set [0,1], after closing, the active branch is [2].
- The set [1,2], after closing, the active branch is [0].
- The set [0,2], after closing, the active branch is [1].
- The set [0,1,2], after closing, there are no active branches.
It can be proven, that there are only 7 possible sets of closing branches.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 1, maxDistance = 10, roads = []
<strong>Output:</strong> 2
<strong>Explanation:</strong> The possible sets of closing branches are:
- The set [], after closing, the active branch is [0].
- The set [0], after closing, there are no active branches.
It can be proven, that there are only 2 possible sets of closing branches.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>1 &lt;= maxDistance &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= roads.length &lt;= 1000</code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 1000</code></li>
	<li>All branches are reachable from each other by traveling some roads.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/description" target="_blank" rel="noopener noreferrer">Number of Restricted Paths From First to Last Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected weighted connected graph. You are given a positive integer <code>n</code> which denotes that the graph has <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, and an array <code>edges</code> where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, weight<sub>i</sub>]</code> denotes that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with weight equal to <code>weight<sub>i</sub></code>.</p>

<p>A path from node <code>start</code> to node <code>end</code> is a sequence of nodes <code>[z<sub>0</sub>, z<sub>1</sub>,<sub> </sub>z<sub>2</sub>, ..., z<sub>k</sub>]</code> such that <code>z<sub>0 </sub>= start</code> and <code>z<sub>k</sub> = end</code> and there is an edge between <code>z<sub>i</sub></code> and <code>z<sub>i+1</sub></code> where <code>0 &lt;= i &lt;= k-1</code>.</p>

<p>The distance of a path is the sum of the weights on the edges of the path. Let <code>distanceToLastNode(x)</code> denote the shortest distance of a path between node <code>n</code> and node <code>x</code>. A <strong>restricted path</strong> is a path that also satisfies that <code>distanceToLastNode(z<sub>i</sub>) &gt; distanceToLastNode(z<sub>i+1</sub>)</code> where <code>0 &lt;= i &lt;= k-1</code>.</p>

<p>Return <em>the number of restricted paths from node</em> <code>1</code> <em>to node</em> <code>n</code>. Since that number may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex1.png" style="width: 351px; height: 341px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Each circle contains the node number in black and its <code>distanceToLastNode value in blue. </code>The three restricted paths are:
1) 1 --&gt; 2 --&gt; 5
2) 1 --&gt; 2 --&gt; 3 --&gt; 5
3) 1 --&gt; 3 --&gt; 5
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex22.png" style="width: 356px; height: 401px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Each circle contains the node number in black and its <code>distanceToLastNode value in blue. </code>The only restricted path is 1 --&gt; 3 --&gt; 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li><code>1 &lt;= weight<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li>There is at most one edge between any two nodes.</li>
	<li>There is at least one path between any two nodes.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-ways-to-arrive-at-destination/1" target="_blank" rel="noopener noreferrer">Number of Ways to Arrive at Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You are in a city that consists of&nbsp;<code>n</code>&nbsp;intersections numbered from&nbsp;<code>0</code>&nbsp;to&nbsp;<code>n - 1</code>&nbsp;with&nbsp;<strong>bi-directional</strong>&nbsp;roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.</span></p>

<p><span style="font-size:18px">You are given an integer&nbsp;<code>n</code>&nbsp;and a 2D integer array&nbsp;<code>roads</code>&nbsp;where&nbsp;<code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code>&nbsp;means that there is a road between intersections&nbsp;<code>u<sub>i</sub></code>&nbsp;and&nbsp;<code>v<sub>i</sub></code>&nbsp;that takes&nbsp;<code>time<sub>i</sub></code>&nbsp;minutes to travel. You want to know in how many ways you can travel from intersection&nbsp;<code>0</code>&nbsp;to intersection&nbsp;<code>n - 1</code>&nbsp;in the&nbsp;<strong>shortest amount of time</strong>.</span></p>

<p><span style="font-size:18px">Return&nbsp;<em>the&nbsp;<strong>number of ways</strong>&nbsp;you can arrive at your destination in the&nbsp;<strong>shortest amount of time</strong></em>. Since the answer may be large, return it&nbsp;<strong>modulo</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>.</span></p>

<p><span style="font-size:18px">Example 1:</span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n=7, m=10
edges= [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]</span>

<span style="font-size:18px"><strong>Output:</strong>
4
Explaination:</span>

<span style="font-size:18px">The four ways to get there in 7 minutes are:
- 0  6
- 0  4  6
- 0  1  2  5  6
- 0  1  3  5  6</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px">Example 2:</span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n=6, m=8
edges= [[0,5,8],[0,2,2],[0,1,1],[1,3,3],[1,2,3],[2,5,6],[3,4,2],[4,5,2]]</span>

<span style="font-size:18px"><strong>Output:</strong>
3
Explaination:</span>

<span style="font-size:18px">The three ways to get there in 8 minutes are:
- 0  5
- 0  2  5
- 0  1  3  4  5
</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
<code>1 &lt;= n &lt;= 200<br />
n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2<br />
roads[i].length == 3<br />
0 &lt;= u<sub>i</sub>, v<sub>i</sub>&nbsp;&lt;= n - 1<br />
1 &lt;= time<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup><br />
u<sub>i&nbsp;</sub>!= v<sub>i</sub></code><br />
There is at most one road connecting any two intersections.<br />
You can reach any intersection from any other intersection.<br />
<br />
Expected Time Complexity:&nbsp;O(M * logN + N)<br />
Expected Space Complexity: O(M+N)</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-arrive-at-destination/description" target="_blank" rel="noopener noreferrer">Number of Ways to Arrive at Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are in a city that consists of <code>n</code> intersections numbered from <code>0</code> to <code>n - 1</code> with <strong>bi-directional</strong> roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.</p>

<p>You are given an integer <code>n</code> and a 2D integer array <code>roads</code> where <code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code> means that there is a road between intersections <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> that takes <code>time<sub>i</sub></code> minutes to travel. You want to know in how many ways you can travel from intersection <code>0</code> to intersection <code>n - 1</code> in the <strong>shortest amount of time</strong>.</p>

<p>Return <em>the <strong>number of ways</strong> you can arrive at your destination in the <strong>shortest amount of time</strong></em>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/02/14/1976_corrected.png" style="width: 255px; height: 400px;" />
<pre>
<strong>Input:</strong> n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, roads = [[1,0,10]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li>There is at most one road connecting any two intersections.</li>
	<li>You can reach any intersection from any other intersection.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have <code>n</code> intersections in a city, represented as nodes in a fully connected graph with bidirectional roads as edges. Each road has a given travel time. Our goal is to determine the number of distinct ways to travel from intersection <code>0</code> to intersection <code>n - 1</code> while taking the shortest possible time. The problem guarantees that every intersection is reachable from any other intersection, ensuring that the graph is fully connected. Additionally, there is at most one road between any two intersections, so we do not have to consider duplicate edges.</p>
<p>One important detail is that the number of ways can be large, so the answer must be returned modulo <span class="math inline">\(10^9 + 7\)</span>. A common mistake is assuming that all roads have unique travel times, but the problem does not impose this restriction. Multiple roads may contribute to the shortest path calculation, and all must be considered. Since the roads are bidirectional, each one can be traversed in either direction. However, backtracking is unnecessary here, meaning we can ignore paths that visit the same road twice, as they will definitely take more time to reach the destination.</p>
<p>For instance, in the first example of the problem description, the shortest time to travel from intersection <code>0</code> to intersection <code>6</code> is <code>7</code> minutes. There are four distinct paths that achieve this travel time, each taking different routes but resulting in the same minimum duration.</p>
<p>Our approach will be based on two fundamental concepts: graph theory and Dijkstra’s shortest path algorithm. Since these topics are crucial to understanding the solution, we recommend having some prior knowledge of them. However, we will also provide a thorough explanation to ensure clarity.</p>
<ol>
<li>
<p><strong>Graph Theory</strong> – Understanding graphs, nodes, edges, and different types of graph representations (adjacency list, adjacency matrix).</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/">Graph Theory - LeetCode Explore Card</a></li>
</ul>
</li>
<li>
<p><strong>Dijkstra’s Algorithm</strong> – A fundamental shortest path algorithm that efficiently finds the minimum distance from a source node to all other nodes in a weighted graph.</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3885/">Dijkstra’s Algorithm - LeetCode Explore Card</a></li>
</ul>
</li>
</ol>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>Dijkstra’s algorithm is the best fit for this problem because it efficiently finds the shortest path from a single source node to all other nodes in a graph with edges that have non-negative weights. The core principle of Dijkstra’s algorithm is that it always expands the currently known shortest path first, ensuring that when we reach a node, we do so in the minimum time possible.</p>
<p>Other approaches, such as Breadth-First Search (BFS), Depth-First Search (DFS), or the Bellman-Ford algorithm, would not be efficient. BFS does not work for weighted graphs unless modified with a priority queue, which ultimately turns it into Dijkstra’s algorithm. DFS would be highly inefficient because it would explore all possible paths, many of which would be unnecessary since they do not guarantee the shortest travel time. The brute-force approach of checking all paths using DFS would have an exponential time complexity and would be infeasible for large inputs.</p>
<p>Dijkstra’s algorithm is a greedy algorithm that uses a min-heap (priority queue) to process nodes in increasing order of their shortest known distance. The algorithm starts from the source node, which is node <code>0</code>, and initializes its distance to <code>0</code> while setting the distance for all other nodes to infinity. The priority queue ensures that the node with the shortest known distance is always processed first.</p>
<p>For each node that is extracted from the priority queue, its neighbors are checked. If traveling through the current node provides a shorter path to a neighboring node, the shortest time to that node is updated, and the neighbor is added to the priority queue for further processing. This continues until all nodes have been processed, at which point the shortest time to each node is known.</p>
<p>The reason Dijkstra’s algorithm works correctly is that once a node is extracted from the priority queue, we are guaranteed that we have found the shortest possible path to that node. Any future attempts to update its distance will fail. This is because any other node that could have led to a shorter path already has a greater cost (otherwise, we would have extracted it first from the heap). Additionally, since all edges have a positive weight, any further paths to that node will only add a positive value to the total cost, increasing it further.</p>
<p>The standard implementation of Dijkstra’s algorithm only finds the shortest distance to each node. However, this problem also requires us to count how many different ways exist to reach the last node (<code>n - 1</code>) using the shortest possible time.</p>
<p>To achieve this, we introduce an additional array, <code>pathCount</code>, where <code>pathCount[i]</code> keeps track of the number of ways to reach node <code>i</code> in the shortest time possible. This modification allows us to not only compute the shortest travel time but also count all valid paths that follow this time constraint.</p>
<p>Initially, <code>pathCount[0] = 1</code>, since there is exactly one way to start at node <code>0</code>. When we find a new shorter path to a node, we reset its path count to be the same as the number of ways we could reach the previous node, since we have discovered a new optimal route.</p>
<p>If we encounter another way to reach a node with the same shortest time, we do not reset the path count. Instead, we add the number of ways we could reach the previous node to the current node’s path count. Since the number of ways can be large, we take the result modulo <span class="math inline">\(10^9 + 7\)</span> to prevent integer overflow.</p>
<p>This problem is notorious for its edge cases, which often cause issues when submitted. A common mistake is using <code>INT_MAX</code> (or similar equivalent in the language of your choice) as the initial value, assuming it is large enough to represent an unreachable node. However, for this problem, using <code>INT_MAX</code> causes incorrect results or even integer overflow in certain test cases.</p>
<p>To understand why, we need to analyze the constraints. The number of nodes (<code>n</code>) is at most <span class="math inline">\(200\)</span>, and the edge weights (<code>time[i]</code>) can be as large as <span class="math inline">\(10^9\)</span>. The worst-case scenario occurs when the shortest path to a node involves traversing <code>199</code> edges, forming a nearly linear path. In such a case, the total shortest path value can reach:</p>
<p><span class="math inline">\(199 \times 10^9 = 1.99 \times 10^{11}\)</span></p>
<p>This is far greater than <code>INT_MAX</code> (which is <span class="math inline">\(2.1 × 10^9\)</span>). If we initialize our distances with <code>INT_MAX</code>, adding even a single edge weight (<span class="math inline">\(10^9\)</span>) could exceed this limit, causing integer overflow. As a result, the algorithm may produce incorrect results when comparing distances, leading to failures in large test cases like test case 53.</p>
<p>To avoid this issue, we should initialize the <code>shortestTime</code> array with <code>LLONG_MAX</code>, which is <span class="math inline">\(9.2 × 10^18\)</span>, or use a sufficiently large constant like <code>1e12</code>. Both options ensure that our algorithm can correctly compute distances without encountering overflow. This small but crucial adjustment is necessary to handle the problem’s constraints correctly.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1976/dijikstra.json:690,608!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define <code>MOD = 1e9 + 7</code> for modular arithmetic.</p>
</li>
<li>
<p>Build an adjacency list <code>graph</code> where <code>graph[i]</code> stores <code>{neighbor, travelTime}</code> pairs.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) for Dijkstra's algorithm.</p>
</li>
<li>
<p>Create <code>shortestTime</code> array to store the shortest time to each node, initialized to <code>LLONG_MAX</code> (or its equivalent in other preferred languages).</p>
</li>
<li>
<p>Create <code>pathCount</code> array to store the number of shortest paths to each node, initialized to <code>0</code>.</p>
</li>
<li>
<p>Set <code>shortestTime[0] = 0</code> and <code>pathCount[0] = 1</code> (starting node has distance <code>0</code> and one valid path).</p>
</li>
<li>
<p>Push <code>{0, 0}</code> into <code>minHeap</code> to start processing.</p>
</li>
<li>
<p>While <code>minHeap</code> is not empty:</p>
<ul>
<li>Extract the node <code>currNode</code> with the current shortest known time <code>currTime</code>.</li>
<li>If <code>currTime &gt; shortestTime[currNode]</code>, skip outdated distances.</li>
<li>Iterate over neighbors of <code>currNode</code>:
<ul>
<li>If a new shortest path is found:
<ul>
<li>Update <code>shortestTime[neighborNode]</code>.</li>
<li>Reset <code>pathCount[neighborNode]</code> to match <code>pathCount[currNode]</code>.</li>
<li>Push <code>{shortestTime[neighborNode], neighborNode}</code> into <code>minHeap</code>.</li>
</ul>
</li>
<li>If an equally short path is found:
<ul>
<li>Add <code>pathCount[currNode]</code> to <code>pathCount[neighborNode]</code>, modulo <code>MOD</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>pathCount[n - 1]</code>, the number of shortest paths to the last node.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Time-saving coding tip:</p>
<p>Whenever a problem involves calculating distances or counting paths, it's a good idea to use long long (or an equivalent large integer type) and apply the modulo operator when required. This helps prevent integer overflow and ensures accurate results, especially in graph and dynamic programming problems.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/faYwk3KQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the graph and <span class="math inline">\(E\)</span> be the number of edges in the given road connections.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N + E \log E)\)</span></p>
<p>Building the adjacency list takes <span class="math inline">\(O(E)\)</span> time, since we iterate over all the edges once.</p>
<p>The main part of the algorithm is Dijkstra’s algorithm using a min-heap. In this implementation, a node can be added to the heap multiple times (if a shorter path to it is found later). For each edge, we may perform a heap insertion, and the heap can grow up to size <span class="math inline">\(O(E)\)</span> in the worst case. Each insertion or extraction from the heap takes <span class="math inline">\(O(\log E)\)</span> time. Thus, the total time spent on heap operations is <span class="math inline">\(O(E \log E)\)</span>.</p>
<p>Combining both parts, the overall time complexity is: <span class="math inline">\(O(E) + O(E \log E) = O(N + E \log E)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span></p>
<p>The adjacency list stores <span class="math inline">\(O(2 \cdot E)\)</span> edges, but it requires <span class="math inline">\(O(N + 2E) \approx O(N + E)\)</span> space in total, as it also includes the <span class="math inline">\(N\)</span> nodes in the outer list. The priority queue stores at most <span class="math inline">\(O(N)\)</span> elements at any time. Additionally, the <code>shortestTime</code> and <code>pathCount</code> arrays require <span class="math inline">\(O(N)\)</span> space. Since the total space used is dominated by <span class="math inline">\(O(N + E)\)</span> for storing the graph, the overall space complexity is <span class="math inline">\(O(N + E)\)</span>.</p>
<p>Other auxiliary variables, such as integers and loop variables, contribute <span class="math inline">\(O(1)\)</span> space, which is negligible compared to <span class="math inline">\(O(N + E)\)</span>. Therefore, the dominant space complexity remains <span class="math inline">\(O(N + E)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-floyd-warshall-algorithm">Approach 2: Floyd-Warshall algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An alternate acceptable approach is to use the concept of Floyd-Warshall algorithm. The core idea of this algorithm is to check whether using an intermediate node <code>mid</code> can create a shorter path between <code>src</code> and <code>dest</code>. Instead of expanding outward from a single source like Dijkstra’s algorithm, Floyd-Warshall updates the shortest path between all pairs of nodes at the same time. This guarantees that once the algorithm completes, every possible shortest path has been counted. However, the Floyd-Warshall algorithm runs in <span class="math inline">\(O(n^3)\)</span> time complexity, which makes it impractical for very large graphs.</p>
<p>To implement this, we define a three-dimensional dynamic programming table <code>dp[src][dest][x]</code>. The first value, <code>dp[src][dest][0]</code>, stores the shortest time required to travel from <code>src</code> to <code>dest</code>, while <code>dp[src][dest][1]</code> keeps track of how many different ways this shortest time can be achieved. At the beginning, the shortest time between any two distinct nodes is set to a very large value, representing that they are initially unreachable. The number of ways is set to <code>0</code> because no path has been established yet. The only exception is when <code>src</code> and <code>dest</code> are the same, in which case the shortest time is <code>0</code> and the number of ways is <code>1</code>, as staying at the node is trivially possible in exactly one way.</p>
<p>Once the table is initialized, we update it with the given roads. If there is a direct connection between <code>startNode</code> and <code>endNode</code> with a given travel time, then the shortest time between these nodes is simply that travel time, and there is exactly one way to travel along this road. Since the roads are bidirectional, the same update applies in both directions.</p>
<p>Once all direct edges are accounted for, we use Floyd-Warshall to iteratively improve our shortest paths by considering each node <code>mid</code> as a possible bridge between every pair of nodes <code>(src, dest)</code>. For every such pair, we check whether traveling through <code>mid</code> results in a smaller total travel time than the best-known value stored in <code>dp[src][dest][0]</code>. If a strictly shorter path is found, we update <code>dp[src][dest][0]</code> to reflect this new shortest time and reset <code>dp[src][dest][1]</code> to be the product of <code>dp[src][mid][1]</code> and <code>dp[mid][dest][1]</code>, which accounts for all possible ways to reach <code>mid</code> from <code>src</code> and then travel from <code>mid</code> to <code>dest</code>. If the new path through <code>mid</code> results in the same shortest time that was already recorded, we do not update <code>dp[src][dest][0]</code>, but we add the newly found paths to <code>dp[src][dest][1]</code>, since they provide additional routes that achieve the minimum distance.</p>
<p>Once we have iterated through all possible intermediate nodes, <code>dp[n - 1][0][1]</code> contains the number of ways to travel between nodes <code>n - 1</code> and <code>0</code> in either direction, using the shortest possible time. This value represents our final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 3D DP table <code>dp[n][n][2]</code> where:
<ul>
<li><code>dp[src][dest][0]</code> stores the minimum time to reach <code>dest</code> from <code>src</code>.</li>
<li><code>dp[src][dest][1]</code> stores the number of ways to achieve the minimum time.</li>
</ul>
</li>
<li>Initialize the DP table:
<ul>
<li>Set the time needed to travel from a node to itself to <code>0</code> and the number of ways to <code>1</code>.</li>
<li>Set the time needed to travel between any two different nodes to a large value (<code>1e12</code>) and the number of ways to <code>0</code>.</li>
</ul>
</li>
<li>Populate the DP table with direct roads (<code>[u, v, time]</code>) from the input:
<ul>
<li>Update the time needed to travel between <code>u</code> and <code>v</code> to <code>time</code> in both directions, and set the number of ways to <code>1</code>.</li>
</ul>
</li>
<li>Apply the Floyd-Warshall algorithm to compute shortest paths:
<ul>
<li>For each intermediate node <code>mid</code>:
<ul>
<li>For each starting node <code>src</code>:
<ul>
<li>For each destination node <code>dest</code>:
<ul>
<li>If <code>src != mid</code> and <code>dest != mid</code>:
<ul>
<li>Calculate <code>newTime</code> as <code>dp[src][mid][0] + dp[mid][dest][0]</code>.</li>
<li>If <code>newTime &lt; dp[src][dest][0]</code> (current time):
<ul>
<li>Update <code>dp[src][dest][0]</code> to <code>newTime</code>.</li>
<li>Update the number of ways <code>dp[src][dest][1]</code> to the number of ways to reach <code>mid</code> from <code>src</code> (<code>dp[src][mid][1]</code>) multiplied by the number of ways to reach <code>dest</code> from <code>mid</code> (<code>dp[mid][dest][1]</code>).</li>
</ul>
</li>
<li>If <code>newTime == dp[src][dest][0]</code> (current time):
<ul>
<li>Increment the number of ways <code>dp[src][dest][1]</code> by the number of ways to reach <code>mid</code> from <code>src</code> (<code>dp[src][mid][1]</code>) multiplied by the number of ways to reach <code>dest</code> from <code>mid</code> (<code>dp[mid][dest][1]</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the number of shortest paths from node <code>n - 1</code> to node <code>0</code> stored in <code>dp[n - 1][0][1]</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/H2DorSwM/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the graph and <span class="math inline">\(E\)</span> be the number of edges in the given road connections.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3)\)</span></p>
<p>The time complexity is dominated by the Floyd-Warshall algorithm. The algorithm involves three nested loops, each iterating over all nodes (from <code>0</code> to <code>N - 1</code>). Therefore, the time complexity is <span class="math inline">\(O(N^3)\)</span>.</p>
<p>Additionally, the initialization of the <code>dp</code> table takes <span class="math inline">\(O(N^2)\)</span> time, and the initialization of the roads (edges) takes <span class="math inline">\(O(E)\)</span> time. However, these are dominated by the <span class="math inline">\(O(N^3)\)</span> complexity of the Floyd-Warshall algorithm.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The space complexity is determined by the size of the <code>dp</code> table, which is a 3D array of size <span class="math inline">\(N \times N \times 2\)</span>. This results in a space complexity of <span class="math inline">\(O(N^2)\)</span>, as the third dimension is a constant factor (<code>2</code>).</p>
<p>The input roads (edges) are stored in an array, which takes <span class="math inline">\(O(E)\)</span> space, but this is negligible compared to the <span class="math inline">\(O(N^2)\)</span> space used by the <code>dp</code> table. Therefore, the overall space complexity is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-maximum-probability/description" target="_blank" rel="noopener noreferrer">Path with Maximum Probability</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected weighted graph of&nbsp;<code>n</code>&nbsp;nodes (0-indexed), represented by an edge list where&nbsp;<code>edges[i] = [a, b]</code>&nbsp;is an undirected edge connecting the nodes&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>&nbsp;with a probability of success of traversing that edge&nbsp;<code>succProb[i]</code>.</p>

<p>Given two nodes&nbsp;<code>start</code>&nbsp;and&nbsp;<code>end</code>, find the path with the maximum probability of success to go from&nbsp;<code>start</code>&nbsp;to&nbsp;<code>end</code>&nbsp;and return its success probability.</p>

<p>If there is no path from&nbsp;<code>start</code>&nbsp;to&nbsp;<code>end</code>, <strong>return&nbsp;0</strong>. Your answer will be accepted if it differs from the correct answer by at most <strong>1e-5</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png" style="width: 187px; height: 186px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
<strong>Output:</strong> 0.25000
<strong>Explanation:</strong>&nbsp;There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png" style="width: 189px; height: 186px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
<strong>Output:</strong> 0.30000
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png" style="width: 215px; height: 191px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
<strong>Output:</strong> 0.00000
<strong>Explanation:</strong>&nbsp;There is no path between 0 and 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10^4</code></li>
	<li><code>0 &lt;= start, end &lt; n</code></li>
	<li><code>start != end</code></li>
	<li><code>0 &lt;= a, b &lt; n</code></li>
	<li><code>a != b</code></li>
	<li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li>
	<li><code>0 &lt;= succProb[i] &lt;= 1</code></li>
	<li>There is at most one edge between every two nodes.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-bellman-ford-algorithm">Approach 1: Bellman-Ford Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with the Bellman-Ford algorithm, please refer to our <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3864/">Bellman-Ford Algorithm Explore Card</a>. For the sake of brevity, we will focus only on the usage of Bellman-Ford and not the implementation details.</p>
</blockquote>
<p>The algorithm works by relaxing edges in the graph, meaning that it tries to improve the shortest path estimate for each node in the graph until the solution is found.</p>
<p>Bellman-Ford is typically used to find the shortest path in a weighted graph. In this problem, instead of the shortest distance, we are looking for the <strong>maximum probability</strong>. The length of a path is the sum of the weights of its edges. Here, the probability of a path equals the product of the probabilities of its edges.</p>
<p>Initially, we set the probability to reach the starting node <code>start</code> as <code>1</code> and all other probabilities as <code>0</code>. Then we iteratively relax the edges of the graph by updating the probability to each node if a higher probability is found.</p>
<p>Considering that a path in the graph without a cycle contains at most <code>n - 1</code> edges, the process is repeated <code>n - 1</code> times, which is enough to relax every edge of every possible path.</p>
<ul>
<li>In the first round, we update the maximum probability of reaching each node <code>u</code> from the starting node along the path that contains only one edge <code>(u, v)</code>.</li>
<li>In the second round, we update the maximum probability of reaching each node <code>u</code> from the starting node along the path that contains two edges (including <code>(u, v)</code>).</li>
<li>and so on.</li>
</ul>
<p>After <code>n - 1</code> rounds, we have updated <code>max_prob[end]</code> to be the maximum probability of reaching <code>end</code> from the staring node along every possible path.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize an array <code>maxProb</code> as the maximum probability to reach each node from the staring node, set <code>maxProb[start]</code> as <code>1</code>.</p>
</li>
<li>
<p>Relax all edges: for each edge <code>(u, v)</code>, if a higher probability of reaching <code>u</code> through this edge is found, update the <code>max_prob[u]</code> as <code>max_prob[u] = max_prob[v] * path_prob</code>, if a higher probability to reach <code>v</code> through this edge is found, update the <code>max_prob[v]</code>.</p>
</li>
<li>
<p>If we are unable to update any node with a higher probability, we can stop the iteration by proceeding to step 4. Otherwise, repeat step 2 until all edges are relaxed <code>n - 1</code> times.</p>
</li>
<li>
<p>Return <code>max_prob[end]</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/CjXtoU2k/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes and <span class="math inline">\(m\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<ul>
<li>The algorithm relaxes all edges in the graph <code>n - 1</code> times, each round contains an iteration over all <code>m</code> edges.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We only need an array of size <span class="math inline">\(n\)</span> to update the maximum probability to reach each node from the starting node.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-shortest-path-faster-algorithm">Approach 2: Shortest Path Faster Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman–Ford algorithm which computes single-source shortest paths in a weighted directed graph.</p>
<p>We start at node <code>start</code> and traverse all its neighbors, calculating the probability of moving from <code>start</code> to each neighbor. We then add these neighbors to a queue, and continue the process for all nodes in the queue until we empty the queue.</p>
<p>The key is maintaining a running maximum probability for each node, and using this maximum to calculate the probabilities for its neighbors. If the probability of traveling from the starting node to a neighbor node through a specific edge is greater than the current maximum probability for that neighbor, we update the maximum probability of this neighbor node, and add this neighbor node to the queue.</p>
<p>Another key point to note is how we calculate the probability of traveling from <code>start</code> to a neighbor node. We are given a set of edge weights that represent the probabilities of moving from one node to another. To calculate the probability of traveling from the starting node to a neighbor node through a specific edge, we simply multiply the edge weight (i.e., the probability of traveling through that edge) by the maximum probability of reaching the current node from the starting node. This gives us the probability of reaching the neighbor node through the current edge.</p>
<p>Take the slides below as an example:</p>
<p>!?!../Documents/1514/s1.json:601,301!?!</p>
<blockquote>
<p>You might wonder, will repeatedly adding the same node back to the queue cause an infinite loop and result in a timeout?</p>
</blockquote>
<p>The answer is NO, because we only update the probability of reaching a neighbor node, say <code>nxt_node</code> and add it back to <code>queue</code> if the current path <strong>increases</strong> the probability of reaching <code>nxt_node</code> from the starting node. Moreover, the weight (probability) of each path is less than or equal to 1. Therefore, even if the graph contains a cycle, the product of the probabilities of all edges in the cycle is still less than or equal to 1. Since loops do not increase the probability of reaching a node, paths that contain loops will be excluded from consideration and not added to the queue.</p>
<p><img src="../Figures/1514/c.png" alt="img" /></p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize an empty queue <code>queue</code> to store nodes that need to be visited.</p>
</li>
<li>
<p>Initialize an array <code>max_prob</code> to store the maximum probability of reaching each node from the starting node. Set the probability of the starting node <code>max_prob[start]</code> as 1, and the probability of all other nodes as 0.</p>
</li>
<li>
<p>Add the starting node <code>start</code> to the <code>queue</code>.</p>
</li>
<li>
<p>While <code>queue</code> is not empty, we remove the first node <code>cur_node</code> from the queue.</p>
</li>
<li>
<p>For each neighbor of <code>nxt_node</code>, calculate the probability of traveling from the starting node to the <code>nxt_node</code> through the current edge (<code>cur_node --- nxt_node</code>), and update the maximum probability for this neighbor <code>max_prob[nxt_node]</code> if necessary.</p>
</li>
<li>
<p>If the probability to this neighbor node is increased, add <code>nxt_node</code> to <code>queue</code>.</p>
</li>
<li>
<p>Repeat steps 4-6 until <code>queue</code> is empty.</p>
</li>
<li>
<p>Return <code>max_prob[end]</code>, the maximum probability of reaching the end node <code>end</code> from the starting node.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/D5ubKTh3/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes and <span class="math inline">\(m\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<ul>
<li>The worst-case running of SPFA is <span class="math inline">\(O(|V|\cdot|E|)\)</span>. However, this is only the worst-case scenario, and the average runtime of SPFA is better than in Bellman-Ford.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<ul>
<li>We build a hash map <code>graph</code> based on all edges, which takes <span class="math inline">\(O(m)\)</span> space.</li>
<li>The algorithm stores the probability array <code>max_prob</code> of size <span class="math inline">\(O(n)\)</span> and a queue of vertices <code>queue</code>. In the worst-case scenario, there are <span class="math inline">\(O(m)\)</span> nodes in <code>queue</code> at the same time.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-dijkstras-algorithm">Approach 3: Dijkstra's Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<blockquote>
<p>If you are not familiar with the Dijkstra's algorithm, please refer to our <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card</a>. For the sake of brevity, we will focus on the usage of the algorithm and not implementation details.</p>
</blockquote>
<p>In BFS, we are exploring the graph in a breadth-first manner, which may not always lead to the shortest path. This is because BFS does not take into account the weights of the edges and only considers the number of hops. As shown in the picture below, even though the two paths to <code>end</code></p>
<ul>
<li><code>0</code> -- <code>2</code></li>
<li><code>0</code> -- <code>1</code> -- <code>2</code><br />
don't have the maximum probability, we still need to update all the nodes along these paths.</li>
</ul>
<p><img src="../Figures/1514/d1.png" alt="img" /></p>
<p>In contrast, Dijkstra's algorithm takes into account the weights of the edges and always guarantees to find the highest probability from the source node to any other node in the graph. This is where Dijkstra's algorithm becomes more suitable than BFS, as it takes into account the weights (probabilities) of the edges and can find the path with the highest probability of reaching the end node.</p>
<p><img src="../Figures/1514/d2.png" alt="img" /></p>
<p>We start from the starting node <code>start</code>, and consider its neighbors one by one, updating the probability to each neighboring node <code>nxt_node</code> if the probability of reaching <code>nxt_node</code> through the current node <code>cur_node</code> is higher than the previous stored probability of reaching <code>nxt_node</code> (by other paths). In order to always select the node with the highest reaching probability, we use a priority queue <code>pq</code> to store the nodes to visit, where the node with the highest probability of being reached from the starting node has the highest priority.</p>
<br>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Initialize a priority queue <code>pq</code> to store nodes that need to be visited, and an array <code>max_prob</code> to store the maximum probability to reach each node from the starting node. Set the probability of the starting node as <code>1</code>, and the probability of all other nodes as <code>0</code>.</p>
</li>
<li>
<p>Add the starting node <code>start</code> and its probability to the priority queue.</p>
</li>
<li>
<p>While <code>pq</code> is not empty, remove <code>cur_node</code>, the node with the highest priority from it.</p>
</li>
<li>
<p>For each neighbor <code>nxt_node</code> of the current node <code>cur_node</code>, calculate the probability of traveling from the starting node to the <code>nxt_node</code> through the current edge <code>cur_node --- nxt_node</code>, and update the maximum probability of <code>nxt_node</code> if necessary. To update the maximum probability, compare the product of the probability with the current node and the probability of the edge <code>cur_node --- nxt_node</code>, with the current maximum probability to the neighbor node. If the product is larger than the maximum probability stored in <code>max_prob[nxt_node]</code>, we update the maximum probability <code>max_prob[nxt_node]</code> as their product.</p>
</li>
<li>
<p>If the neighbor node <code>nxt_node</code> has not been visited, we add it and its probability to the <code>pq</code>.</p>
</li>
<li>
<p>Repeat steps 3-5 until the priority queue is empty or the ending node <code>end</code> has been reached.</p>
</li>
<li>
<p>Return <code>max_prob[end]</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/kjLJ59V7/shared">code</a></p>
<blockquote>
<p>Note that Python's heapq module only implements min heaps. Since we want higher probabilities to be popped first, we need a max heap. To fix this, we multiply the probabilities by <code>-1</code>.</p>
</blockquote>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes and <span class="math inline">\(m\)</span> be the number of edges.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n + m) \cdot \log n)\)</span></p>
<ul>
<li>We build an adjacency list <code>graph</code> based on all edges, which takes <span class="math inline">\(O(m)\)</span> time.</li>
<li>In the worst case, each node could be pushed into the priority queue exactly once, which results in <span class="math inline">\(O(n \cdot \log n)\)</span> operations.</li>
<li>Each edge is considered exactly once when its corresponding node is dequeued from the priority queue. This takes <span class="math inline">\(O(m \cdot \log n)\)</span> time in total, due to the priority queue's <span class="math inline">\(\log n\)</span> complexity for insertion and deletion operations.</li>
</ul>
</li>
</ul>
<blockquote>
<p>You can also refer to our <a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card</a> for details on the complexity analysis.</p>
</blockquote>
<ul>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + m)\)</span></p>
<ul>
<li>We build an adjacency list <code>graph</code> based on all edges, which takes <span class="math inline">\(O(m)\)</span> space.</li>
<li>The algorithm stores the <code>maxProb</code> array, which uses <span class="math inline">\(O(n)\)</span> space.</li>
<li>We use a priority queue to keep track of nodes to be visited, and there are at most <span class="math inline">\(n\)</span> nodes in the queue.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reachable-nodes-in-subdivided-graph/description" target="_blank" rel="noopener noreferrer">Reachable Nodes In Subdivided Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected graph (the <strong>&quot;original graph&quot;</strong>) with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You decide to <strong>subdivide</strong> each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.</p>

<p>The graph is given as a 2D array of <code>edges</code> where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the original graph, and <code>cnt<sub>i</sub></code> is the total number of new nodes that you will <strong>subdivide</strong> the edge into. Note that <code>cnt<sub>i</sub> == 0</code> means you will not subdivide the edge.</p>

<p>To <strong>subdivide</strong> the edge <code>[u<sub>i</sub>, v<sub>i</sub>]</code>, replace it with <code>(cnt<sub>i</sub> + 1)</code> new edges and <code>cnt<sub>i</sub></code> new nodes. The new nodes are <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code>, and the new edges are <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>-1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code>.</p>

<p>In this <strong>new graph</strong>, you want to know how many nodes are <strong>reachable</strong> from the node <code>0</code>, where a node is <strong>reachable</strong> if the distance is <code>maxMoves</code> or less.</p>

<p>Given the original graph and <code>maxMoves</code>, return <em>the number of nodes that are <strong>reachable</strong> from node </em><code>0</code><em> in the new graph</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" style="width: 600px; height: 247px;" />
<pre>
<strong>Input:</strong> edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
<strong>Output:</strong> 13
<strong>Explanation:</strong> The edge subdivisions are shown in the image above.
The nodes that are reachable are highlighted in yellow.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
<strong>Output:</strong> 23
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
<strong>Output:</strong> 1
<strong>Explanation:</strong> Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>
	<li>There are <strong>no multiple edges</strong> in the graph.</li>
	<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= n &lt;= 3000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dijkstras">Approach 1: Dijkstra's</h3>
<p><strong>Intuition</strong></p>
<p>Treating the original graph as a weighted, undirected graph, we can use Dijkstra's algorithm to find all reachable nodes in the original graph.  However, this won't be enough to solve examples where subdivided edges are only used partially.</p>
<p>When we travel along an edge (in either direction), we can keep track of how much we use it.  At the end, we want to know every node we reached in the original graph, plus the sum of the utilization of each edge.</p>
<p><strong>Algorithm</strong></p>
<p>We use <em>Dijkstra's algorithm</em> to find the shortest distance from our source to all targets.  This is a textbook algorithm, refer to <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">this link</a> for more details.</p>
<p>Additionally, for each (directed) edge <code>(node, nei)</code>, we'll keep track of how many &quot;new&quot; nodes (new from subdivision of the original edge) were <code>used</code>.  At the end, we'll sum up the utilization of each edge.</p>
<p>Please see the inline comments for more details.</p>
<p><a href="https://leetcode.com/playground/PktDsMD2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(E \log N)\)</span>, where <span class="math inline">\(E\)</span> is the length of <code>edges</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(E)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/second-minimum-time-to-reach-destination/description" target="_blank" rel="noopener noreferrer">Second Minimum Time to Reach Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A city is represented as a <strong>bi-directional connected</strong> graph with <code>n</code> vertices where each vertex is labeled from <code>1</code> to <code>n</code> (<strong>inclusive</strong>). The edges in the graph are represented as a 2D integer array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a bi-directional edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by <strong>at most one</strong> edge, and no vertex has an edge to itself. The time taken to traverse any edge is <code>time</code> minutes.</p>

<p>Each vertex has a traffic signal which changes its color from <strong>green</strong> to <strong>red</strong> and vice versa every&nbsp;<code>change</code> minutes. All signals change <strong>at the same time</strong>. You can enter a vertex at <strong>any time</strong>, but can leave a vertex <strong>only when the signal is green</strong>. You <strong>cannot wait </strong>at a vertex if the signal is <strong>green</strong>.</p>

<p>The <strong>second minimum value</strong> is defined as the smallest value<strong> strictly larger </strong>than the minimum value.</p>

<ul>
	<li>For example the second minimum value of <code>[2, 3, 4]</code> is <code>3</code>, and the second minimum value of <code>[2, 2, 4]</code> is <code>4</code>.</li>
</ul>

<p>Given <code>n</code>, <code>edges</code>, <code>time</code>, and <code>change</code>, return <em>the <strong>second minimum time</strong> it will take to go from vertex </em><code>1</code><em> to vertex </em><code>n</code>.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li>You can go through any vertex <strong>any</strong> number of times, <strong>including</strong> <code>1</code> and <code>n</code>.</li>
	<li>You can assume that when the journey <strong>starts</strong>, all signals have just turned <strong>green</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e1.png" style="width: 200px; height: 250px;" /> &emsp; &emsp; &emsp; &emsp;<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e2.png" style="width: 200px; height: 250px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
<strong>Output:</strong> 13
<strong>Explanation:</strong>
The figure on the left shows the given graph.
The blue path in the figure on the right is the minimum time path.
The time taken is:
- Start at 1, time elapsed=0
- 1 -&gt; 4: 3 minutes, time elapsed=3
- 4 -&gt; 5: 3 minutes, time elapsed=6
Hence the minimum time needed is 6 minutes.

The red path shows the path to get the second minimum time.
- Start at 1, time elapsed=0
- 1 -&gt; 3: 3 minutes, time elapsed=3
- 3 -&gt; 4: 3 minutes, time elapsed=6
- Wait at 4 for 4 minutes, time elapsed=10
- 4 -&gt; 5: 3 minutes, time elapsed=13
Hence the second minimum time is 13 minutes.      
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/eg2.png" style="width: 225px; height: 50px;" />
<pre>
<strong>Input:</strong> n = 2, edges = [[1,2]], time = 3, change = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong>
The minimum time path is 1 -&gt; 2 with time = 3 minutes.
The second minimum time path is 1 -&gt; 2 -&gt; 1 -&gt; 2 with time = 11 minutes.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>Each vertex can be reached directly or indirectly from every other vertex.</li>
	<li><code>1 &lt;= time, change &lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<h3 id="overview">Overview</h3>
<p>The problem is to find the second minimum distance (&quot;strictly larger value&quot; than minimum value) in a weighted graph where the traversal over any edge is only possible at certain intervals. The second minimum distance can either come by iterating over some nodes in the path multiple times (as shown in second example of the description) or there could be a longer path than the shortest path with all the nodes occurring just once (as shown in first example of the description).</p>
<h3 id="approach-1-dijkstra">Approach 1: Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>The shortest distance problem in a weighted graph directly leads to thinking about the Dijkstra algorithm. However, the standard Dijkstra does not work here, since we want to find the second minimum distance to reach node <code>n</code>. We may need to modify it a bit to make it work.</p>
<p>Let’s try to recap quickly how the standard Dijkstra looks and the corresponding changes we would need to solve this problem.</p>
<h5 id="standard-dijkstra">Standard Dijkstra</h5>
<ul>
<li>We use an array <code>distance</code> to maintain the shortest distance to each node so far. For any node <code>X</code> except the source node, <code>distance[X]</code> is initialized with infinity. We also maintain a priority queue storing the node and its shortest distance. Whenever any of <code>X</code>'s neighbors is popped out of the priority queue, if the total distance to <code>X</code> via the neighbors is lesser than the <code>distance[X]</code>, <code>distance[X]</code> is updated to the new shortest distance and get pushed into the priority queue.</li>
<li>Whenever a node <code>Y</code> is popped out of the queue, we have the minimum distance for the node <code>Y</code> which cannot be reduced further. If there was a shorter path for <code>Y</code>, it would have been covered before since we use a priority queue in the implementation. We iterate over the neighbors of <code>Y</code> to check if any child could be updated.</li>
</ul>
<h5 id="modified-dijkstra">Modified Dijkstra</h5>
<p>Since we need to find the second minimal distance, an idea is to maintain both the minimal and the second minimal distance.</p>
<ul>
<li>We would use two distance arrays, <code>dist1</code> and <code>dist2</code> to maintain the shortest and second shortest distance (&quot;strictly larger value&quot; than the minimum value) to each node so far. For any node <code>X</code> except the source node, <code>dist1[X]</code> and <code>dist2[X]</code> are initialized with infinity. We would maintain a priority queue storing the node, its shortest distance, and also its second shortest distance. Whenever any of <code>X</code>'s neighbors is popped out of the priority queue, if the total distance to <code>X</code> via the neighbors is less than <code>dist1[X]</code>, <code>dist1[X]</code> is updated and pushed to the queue. Else, we try to update <code>dist2[X]</code> if possible and push it to the priority queue.</li>
<li>Whenever a node <code>Y</code> is popped out of the queue for the first time, we have the minimum distance for the node <code>Y</code> which cannot be reduced further. In this case, we would use <code>dist1[Y]</code> as the distance to reach node <code>Y</code> to compute the total distance of its neighbours. If it pops out a second time, we have the second minimum distance for the node <code>Y</code>. Now, we would use <code>dist2[Y]</code> as the distance to reach node <code>Y</code> to compute the total distance of its neighbours.</li>
</ul>
<h4 id="green-and-red-light-constraint">Green and Red Light Constraint</h4>
<p>In the previous analysis, we discussed how to solve the second minimal distance problem generally with modified Dijkstra. Still, the problem has another part: the constraint on the green and red lights. Let's think about how to handle it.</p>
<p>Under the green and red traffic light constraint, the time it takes to pass the edge is no longer the weight of the edge. We need to be careful when updating the distance in the Dijkstra algorithm.</p>
<p>Please take a look at the image which helps to handle this constraint (<code>c</code> in the figure means the value <code>change</code>):</p>
<p><img src="../Figures/2045/2045-1.png" alt="img" /></p>
<p>There are some observations from the figure. If the current time falls between <code>2 * m * c</code> and <code>2 * m * c + c</code>, where <code>m</code> is any integer, we have a green signal for the node, otherwise, we have a red signal. We can pass the green signal straight way but would have to wait at the red signal till it turns green.</p>
<p>The time taken to go through an edge could be presented as the following code:</p>
<pre><code>// `timeTaken` represent the total time taken to reach the current node,
// and we want to move to its neighbors.
if ((timeTaken / change) % 2) {
    // red light, we need to wait for the next green light
    timeTakenToReachNeighbor = change * (timeTaken / change + 1) + time;
} else {
    // green light, just pass
    timeTakenToReachNeighbor = timeTaken + time;
}
</code></pre>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an adjacency list where <code>adj[X]</code> contains all the neighbors of node <code>X</code>.</li>
<li>Initialize two distance arrays <code>dist1</code> and <code>dist2</code> storing the minimum and the second minimum distance from node <code>1</code> for all the nodes. We would initialize these arrays with large integer values.</li>
<li>Initialize a frequency array <code>freq</code> to store the number of times when a node is popped out of the queue. Since we need the second minimal distance, each node can be poped out at most twice.</li>
<li>Initialize a priority queue storing a <code>{distance, node_id}</code> pair, ordered by the distance. Insert node <code>1</code> with distance <code>0</code> into the queue as <code>{0, 1}</code>.</li>
<li>Perform the Dijkstra until the priority queue is empty.
<ul>
<li>Pop out the top pair of integers, and fetch the node (let's say it is <code>Y</code>) and distance to reach node <code>Y</code>.</li>
<li>Increase <code>freq[Y]</code> by 1.</li>
<li>If <code>Y == n</code> and <code>freq[n] == 2</code>, it means we’ve encountered this node via the second minimum distance. In this case, we return <code>dist2[n]</code>.</li>
<li>Else, iterate over all the neighbors of <code>Y</code>.</li>
<li>For each <code>neighbor</code>, check if <code>dist1[neighbor]</code> could be updated using <code>distance[Y]</code>. If not, check if <code>dist2[neighbor]</code> could be updated.</li>
<li>Push pair <code>{distance_neighbor, neighbor}</code> into the queue whenever <code>dist1[neighbor]</code> or <code>dist2[neighbor]</code> is updated.</li>
</ul>
</li>
<li>If we do not return the answer after the queue is empty, we know that the graph only has one node. Therefore, we just return <code>0</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/eWxFfyDc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of cities and <span class="math inline">\(E\)</span> be the total edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + E \cdot \log N)\)</span>.</p>
<ul>
<li>Our algorithm has twice the complexity as the Dijkstra algorithm. We pop twice and use the node to calculate the minimum and second miimum distance. Since 2 is a constant factor, it actually has the same time complexity as the standard Dijkstra algorithm.</li>
<li>For standard Dijkstra, the maximum number of vertices that could be added to the priority queue is <span class="math inline">\(E\)</span> and each operation takes <span class="math inline">\(O(log E)\)</span> time. Thus, push and pop operations on the priority queue take <span class="math inline">\(O(E \cdot log E)\)</span> time. The value of <span class="math inline">\(E\)</span> can be at most <span class="math inline">\(N \cdot (N−1)\)</span>, so  <span class="math inline">\(O(E \cdot log E) = O(E \cdot log(N^2)) = O(E \cdot log N)\)</span>. It also takes <span class="math inline">\(O(N + E)\)</span> for adjacency list and dist array initializations. Therefore, the total complexity is <span class="math inline">\(O(N+E \cdot log N)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(N + E)\)</span> space. For the Dijkstra algorithm, each vertex is added to the queue at most <span class="math inline">\(N−1\)</span> times, so the space it takes is <span class="math inline">\(N \cdot (N−1) = O(N^2) = O(E)\)</span>. For the distance and frequency arrays, they take <span class="math inline">\(O(N)\)</span> space.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>If you are not much familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">Leetcode Explore Card</a> and have some knowledge of it beforehand.</p>
<p>The given problem involves a city, which is represented as a bi-directionally connected graph with <code>n</code> vertices and some edges. The cost of passing through each edge takes an equal amount of <code>time</code>. We also have some red-to-green signal transitions that happen at the same time, i.e., all signals switch from red to green (and vice-versa) at the same time after every <code>change</code> interval.</p>
<p>Since each edge takes an equal amount of time to cross and the red-signal transitions happen at the same time, we can observe that the time taken for any equal-length path in terms of steps taken would be similar. This is because we would be taking <code>time</code> to cross each edge and would also be waiting at the red signals at the same time.</p>
<p>Let's use an example to understand this more. If we start at the time <code>T = 0</code> from node <code>1</code>, we can reach any node one edge away at <code>T = time</code>. Let's assume we've got a green signal now. We would cross another edge to reach any node two edges away at <code>T = 2 * time</code>. Suppose, we have a red signal now and it takes <code>c</code> time to switch back to green. We would start moving from the current node at <code>T = 2 * time + c</code> and reach any node three edges away at <code>T = 3 * time + c</code>. We cannot reach nodes at level three earlier than <code>3 * time + c</code>. If we take the longer route, it will undoubtedly take more time.</p>
<p>This shows that the shortest length path in terms of steps would be the ideal path to compute the minimum time to reach node <code>n</code> and the second shortest length path would be the ideal path to compute the second minimum time. In this case, all the weight is <code>1</code> so the graph is unweighted. Therefore, we only need to focus on the number of steps to reach the target node instead of time. Hence, Dijkstra was overkill.</p>
<p>As we know, the path used in BFS traversal always has the least number of edges. The BFS algorithm does a level-wise iteration of the graph. As a result, it first finds all paths that are one edge away from the source node, followed by all paths that are two edges away from the source node, and so on. This allows BFS to find the shortest path in terms of steps from the source node to any other node. The time spent at red light crossings will be calculated in the same way as in the first approach. We will use this concept to solve the problem.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an adjacency list where <code>adj[X]</code> contains all the neighbors of node <code>X</code>.</li>
<li>Initialise two distance arrays <code>dist1</code> and <code>dist2</code> storing the minimum and second minimum distance from node 1 for all the nodes. We would initialize these arrays with <code>-1</code>.</li>
<li>Initialize a queue with a pair of integers <code>(node, freq)</code> and insert  <code>{1, 1}</code> where the first integer denotes the node and the second denotes the frequency of the visit.</li>
<li>Pop out the front pair from the queue and iterate over the neighbors of the node updating the <code>dist1</code> and <code>dist2</code> accordingly (as we did above).</li>
<li>If <code>dist1[child] = -1</code>, it means this is the first time we are visiting this node, so update the <code>dist1[child]</code>. This is the minimum distance of the node <code>child</code>. Else, check similarly for <code>dist2[child]</code> to compute the second minimum distance and ensure it is not equal to <code>dist1[child]</code>.</li>
</ol>
<blockquote>
<p>The important point to learn here is that this approach works only because the graph is equally weighted for all edges.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YgLQPMf5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of cities and <span class="math inline">\(E\)</span> be the total edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>The complexity would be similar to the standard BFS algorithm since we’re iterating at most twice over a node.</li>
<li>For the BFS algorithm, each single queue operation takes <span class="math inline">\(O(1)\)</span>, and a single node could be pushed at most once leading <span class="math inline">\(O(N)\)</span> operations. For each node popped out of the queue we iterate over all its neighbors, so for an undirected edge, a given edge could be iterated at most twice (by nodes at the end) which leads to <span class="math inline">\(O(E)\)</span> operations in total for all the nodes and a total <span class="math inline">\(O(N + E)\)</span> time complexity.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(E)\)</span> space. The BFS queue takes <span class="math inline">\(O(N)\)</span> because each vertex is added at most once. The other distance arrays take <span class="math inline">\(O(N)\)</span> space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-from-1-to-n0156/1" target="_blank" rel="noopener noreferrer">Shortest path from 1 to n</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">mathematical</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Consider a <strong>directed graph </strong>whose vertices are numbered from <strong>1</strong> <strong>to n</strong>. There is an edge from a vertex <strong>i</strong> to a vertex <strong>j</strong> if and only if either <strong>j = i + 1 or j = 3 * i</strong>. The task is to find the <strong>minimum </strong>number of edges in a path from vertex <strong>1</strong> to vertex <strong>n</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 9
<strong>Output: </strong>2
<strong>Explanation</strong>: Many paths are possible from 1 to 9. Shortest one possible is, 1 -&gt; 3 -&gt; 9, of length 2.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: n = 4
<strong>Output: </strong>2
<strong>Explanation</strong>: Possible paths from 1 to 4 are, 1 -&gt; 2 -&gt; 3 -&gt; 4 and 1 -&gt; 3 -&gt; 4. Second path of length 2 is the shortest.<br /></span></pre>
<pre><span><strong>Input</strong>: n = 15
<strong>Output: </strong>4</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph/1" target="_blank" rel="noopener noreferrer">Shortest path in Directed Acyclic Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Directed Acyclic Graph of V vertices from 0 to n-1 and a 2D Integer array(or vector) edges[ ][ ] of length E, where there is a directed edge from edge[i][0] to edge[i][1] with a distance of edge[i][2] for all i.</span></p>
<p><span style="font-size: 18px;">Find the <strong>shortest</strong> path from <strong>src(0) </strong>vertex&nbsp;to all the vertices&nbsp;and if it is impossible to reach any vertex, then return&nbsp;<strong>-1</strong> for that vertex.</span></p>
<p><strong><span style="font-size: 18px;">Examples :<br /></span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, E = 2, edges = [[0,1,2], [0,2,1]]
<strong>Output: </strong>[0, 2, 1, -1]<br /></span><strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">Shortest path from 0 to 1 is 0-&gt;1 with edge weight 2.</span><span style="font-size: 18px;"> Shortest path from 0 to 2 is 0-&gt;2 with edge weight 1. There is no way we can reach 3, so it's -1 for 3.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 6, E = 7, edges = [[0,1,2], [0,4,1], [4,5,4], [4,2,2], [1,2,3], [2,3,6], [5,3,1]]
<strong>Output: </strong>[0, 2, 3, 6, 1, 5]<br /></span><strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">Shortest path from 0 to 1 is 0-&gt;1 with edge weight 2.</span><span style="font-size: 18px;"> Shortest path from 0 to 2 is 0-&gt;4-&gt;2 with edge weight 1+2=3. Shortest path from 0 to 3 is 0-&gt;4-&gt;5-&gt;3 with edge weight 1+4+1=6. Shortest path from 0 to 4 is 0-&gt;4 with edge weight 1.Shortest path from 0 to 5 is 0-&gt;4-&gt;5 with edge weight 1+4=5.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraint:<br /></strong></span><span style="font-size: 18px;">1 &lt;= V &lt;= 100<br />1 &lt;= E &lt;= min((N*(N-1))/2,4000)<br /></span><span style="font-size: 18px;">0 &lt;= edges<sub>i,0</sub>, edges<sub>i,1</sub>&nbsp;&lt;&nbsp;n<br />0 &lt;=&nbsp;</span><span style="font-size: 18px;">edge</span><sub>i,2</sub><span style="font-size: 18px;">&nbsp;&lt;=10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-using-atmost-one-curved-edge--170647/1" target="_blank" rel="noopener noreferrer">Shortest Path Using Atmost One Curved Edge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected, connected graph with <strong>n</strong> vertices and <strong>m</strong> double-edges stored in <strong>edges[][]</strong> 2-D array. Each double-edge is represented by a tuple <strong>(x, y, w1, w2)</strong>, which indicates that there are two edges between vertices <strong>x</strong> and <strong>y</strong>: a straight edge with weight <strong>w1</strong> and a curved edge with weight <strong>w2</strong>.</span></p>
<p><span style="font-size: 18px;">You are given two vertices <strong>a</strong> and <strong>b</strong> and you have to go from <strong>a</strong> to <strong>b</strong> through a series of edges such that in the entire path, you can use at most 1 curved edge. Your task is to find the shortest path from <strong>a</strong> to <strong>b</strong> satisfying the above condition.</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, m = 4, a = 2, b = 4, edges[][] = [[1, 2, 1, 4], [1, 3, 2, 4],[1, 4, 3, 1], [2, 4, 6, 5]]
<strong>Output: </strong>2
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/713968/Web/Other/blobid0_1745470590.jpg" width="292" height="258" /><br /><strong>Explanation:</strong>
We can follow the path 2 -&gt; 1 -&gt; 4.</span> <span style="font-size: 18px;">This gives a distance of 1+3 = 4 if we follow all straight paths. But we can take the curved path  from 1 -&gt; 4, which costs 1. This will result in a cost of 1 + 1 = 2</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, m = 1, a = 1, b = 2, edges = [[1, 2, 4, 1]]
<strong>Output : </strong>1
</span><img src="https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/713968/Web/Other/fcf19135-c88b-48ac-8fc4-bc46efc7ca3f_1685087926.png" />
<span style="font-size: 18px;"><strong>Explanation:</strong>
Take the curved path from 1 to 2 which costs 1. </span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &le; n &le; 10<sup>5</sup></span></li>
<li><span style="font-size: 18px;">1&nbsp;</span><span style="font-size: 18px;">&le; m </span><span style="font-size: 18px;">&le; 2 x&nbsp;</span><span style="font-size: 18px;">10</span><sup>5</sup></li>
<li><span style="font-size: 18px;">1 &le; a, b &le; n</span></li>
<li><span style="font-size: 18px;">1 &le; edges[i][0], edges[i][1] &le; n</span></li>
<li><span style="font-size: 18px;">0 &le;&nbsp;edges[i][2], edges[i][3] &le; 10<sup>4</sup></span></li>
</ul></div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>