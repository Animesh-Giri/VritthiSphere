<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>string matching - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>string matching</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">33</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Camelcase Matching</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Check If a Word Occurs As a Prefix of Any Word in a Sentence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Count Cells in Overlapping Horizontal and Vertical Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Counting Words With a Given Prefix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Count Prefix and Suffix Pairs I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Count Prefix and Suffix Pairs II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Find All Good Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Find Beautiful Indices in the Given Array I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Find Beautiful Indices in the Given Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Find the Index of the First Occurrence in a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Find the Occurrence of First Almost Equal Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Form Array by Concatenating Subarrays of Another Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Lexicographically Smallest Generated String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Longest Happy Prefix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Match Substring After Replacement</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Maximum Deletions on a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Maximum Repeating Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Minimum Number of Valid Strings to Form Target I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Minimum Number of Valid Strings to Form Target II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Minimum Time to Revert Word to Initial State I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Minimum Time to Revert Word to Initial State II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Number of Subarrays That Match a Pattern I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Number of Subarrays That Match a Pattern II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Repeated String Match</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Repeated Substring Pattern</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Rotate String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Shortest Matching Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Shortest Palindrome</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">String Matching in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">String Transformation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Substring Matching Pattern</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Subtree of Another Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Sum of Scores of Built Strings</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/camelcase-matching/description" target="_blank" rel="noopener noreferrer">Camelcase Matching</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>queries</code> and a string <code>pattern</code>, return a boolean array <code>answer</code> where <code>answer[i]</code> is <code>true</code> if <code>queries[i]</code> matches <code>pattern</code>, and <code>false</code> otherwise.</p>

<p>A query word <code>queries[i]</code> matches <code>pattern</code> if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters <strong>at all</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;
<strong>Output:</strong> [true,false,true,true,false]
<strong>Explanation:</strong> &quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.
&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.
&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;
<strong>Output:</strong> [true,false,true,false,false]
<strong>Explanation:</strong> &quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.
&quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;
<strong>Output:</strong> [false,true,false,false,false]
<strong>Explanation:</strong> &quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pattern.length, queries.length &lt;= 100</code></li>
	<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>
	<li><code>queries[i]</code> and <code>pattern</code> consist of English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/description" target="_blank" rel="noopener noreferrer">Check If a Word Occurs As a Prefix of Any Word in a Sentence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>sentence</code> that consists of some words separated by a <strong>single space</strong>, and a <code>searchWord</code>, check if <code>searchWord</code> is a prefix of any word in <code>sentence</code>.</p>

<p>Return <em>the index of the word in </em><code>sentence</code><em> (<strong>1-indexed</strong>) where </em><code>searchWord</code><em> is a prefix of this word</em>. If <code>searchWord</code> is a prefix of more than one word, return the index of the first word <strong>(minimum index)</strong>. If there is no such word return <code>-1</code>.</p>

<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;i love eating burger&quot;, searchWord = &quot;burg&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> &quot;burg&quot; is prefix of &quot;burger&quot; which is the 4th word in the sentence.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;this problem is an easy problem&quot;, searchWord = &quot;pro&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> &quot;pro&quot; is prefix of &quot;problem&quot; which is the 2nd and the 6th word in the sentence, but we return 2 as it&#39;s the minimal index.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;i am tired&quot;, searchWord = &quot;you&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> &quot;you&quot; is not a prefix of any word in the sentence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= sentence.length &lt;= 100</code></li>
	<li><code>1 &lt;= searchWord.length &lt;= 10</code></li>
	<li><code>sentence</code> consists of lowercase English letters and spaces.</li>
	<li><code>searchWord</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to determine if a given search word is a prefix of any word in a sentence. If it is, we return the 1-based index of the first matching word. If no match is found, we return -1.</p>
<p>Letâ€™s first define what a prefix is: itâ€™s the starting portion of a word. For example, in the word <code>&quot;burger&quot;</code>, the string <code>&quot;burg&quot;</code> is a prefix. Given a sentence like <code>&quot;I love eating burger&quot;</code> and a search word <code>&quot;burg&quot;</code>, we need to identify whether any word in the sentence begins with <code>&quot;burg&quot;</code>. In this example, the word <code>&quot;burger&quot;</code> starts with <code>&quot;burg&quot;</code>, and it is the fourth word in the sentence, so the correct output would be <code>4</code>.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The simplest way to check if <code>searchWord</code> is a prefix of any word in the sentence is by directly comparing each word with <code>searchWord</code>.</p>
<p>We can start by splitting the sentence into individual words. Since words in the sentence are separated by single spaces, we can use space as the delimiter to split the sentence into a list of words. While we might generally need to handle extra spaces or leading/trailing spaces carefully, the problem guarantees that words are separated by single spaces, so these edge cases are not a concern here.</p>
<p>Next, we iterate through the list of words, comparing each word's prefix with <code>searchWord</code>. We use a nested loop to compare characters of the word and <code>searchWord</code> up to the length of <code>searchWord</code>. If all characters match, we return the 1-based index of the word. If no word matches, we return <code>-1</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty <code>wordsList</code> to store the words in the sentence.</p>
</li>
<li>
<p>Initialize an empty <code>currentWord</code> to build words as we traverse the sentence.</p>
</li>
<li>
<p>For each <code>character</code> in <code>sentence</code>:</p>
<ul>
<li>If the <code>character</code> is not a space, append it to <code>currentWord</code>.</li>
<li>If the <code>character</code> is a space and <code>currentWord</code> is not empty:
<ul>
<li>Add <code>currentWord</code> to <code>wordsList</code>.</li>
<li>Reset <code>currentWord</code> to an empty string.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After processing the sentence, if <code>currentWord</code> is not empty, add it to <code>wordsList</code> (handles the last word).</p>
</li>
<li>
<p>For each word in <code>wordsList</code> (indexed by <code>wordIndex</code>):</p>
<ul>
<li>If the length of the current word is greater than or equal to the length of <code>searchWord</code>:
<ul>
<li>Compare each character in <code>searchWord</code> with the corresponding character in the current word.</li>
<li>If all characters match:
<ul>
<li>Return <code>wordIndex + 1</code> (1-based index of the matching word).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no word matches <code>searchWord</code> as a prefix, return <code>-1</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EHZG3vUK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>, <span class="math inline">\(k\)</span> be the average length of words in <code>sentence</code>, and <span class="math inline">\(w\)</span> be the total number of words in <code>sentence</code> such that <span class="math inline">\(w \cdot k = n\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + w \cdot m)\)</span></p>
<p>The first part of the algorithm involves iterating over the <code>sentence</code> to split it into words, which requires traversing all <span class="math inline">\(n\)</span> characters. Each character is processed exactly once to either build a word or identify word boundaries (spaces). This step has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The second part involves checking whether each word in the <code>wordsList</code> starts with the <code>searchWord</code>. For each of the <span class="math inline">\(w\)</span> words, we compare up to <span class="math inline">\(m\)</span> characters with <code>searchWord</code>. In the worst case, all <span class="math inline">\(w\)</span> words are of length <span class="math inline">\(m\)</span> or more, making this step <span class="math inline">\(O(w \cdot m)\)</span>. Adding both parts together, the total time complexity becomes <span class="math inline">\(O(n + w \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>wordsList</code> vector stores all the words from <code>sentence</code>, and the total memory required to hold these words is proportional to the size of the input string <span class="math inline">\(n\)</span>. Additionally, the <code>currentWord</code> string temporarily holds one word at a time during the processing, requiring <span class="math inline">\(O(k)\)</span> space, but this is reused and does not add extra memory. Other variables, such as the loop counters and boolean flags, require constant space <span class="math inline">\(O(1)\)</span>. Hence, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer">Approach 2: Two Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of splitting the sentence into words first, we can directly iterate through the sentence while keeping track of the current word's position. This way, we can avoid storing all words in memory and instead process the sentence in a single pass. We skip over spaces to find the start of each word and then check if the word starts with the <code>searchWord</code>.</p>
<p>To do this, we use a two-pointer approach: the first pointer keeps track of where we are in the sentence, and the second pointer tracks how far weâ€™ve matched the <code>searchWord</code>. If a match is found, we immediately return the current word's position. If no match is found by the end of the sentence, we return <code>-1</code>.</p>
<p>This is particularly efficient for large sentences, as it avoids the overhead of storing and managing a list of words.</p>
</br>
<p>!?!../Documents/1455/1455_two_pointer.json:770,445!?!</p>
<blockquote>
<p>For a more comprehensive understanding of the two-pointer technique, explore the <a href="https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/">Two Pointer Explore Card ðŸ”—</a>. This resource provides an in-depth look at the two-pointer approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>currentWordPosition</code> to 1 to keep track of the current word's position in the sentence.</p>
</li>
<li>
<p>Initialize <code>currentIndex</code> to 0 to traverse the sentence character by character.</p>
</li>
<li>
<p>Store the length of the sentence in <code>sentenceLength</code>.</p>
</li>
<li>
<p>While <code>currentIndex</code> is less than <code>sentenceLength</code>:</p>
<ul>
<li>
<p>Skip leading spaces:</p>
<ul>
<li>While the current character is a space, increment <code>currentIndex</code> and also increment <code>currentWordPosition</code> to move to the next word.</li>
</ul>
</li>
<li>
<p>Check if the current word starts with <code>searchWord</code>:</p>
<ul>
<li>Initialize <code>matchCount</code> to 0 to track how many characters match <code>searchWord</code>.</li>
<li>While characters match between <code>sentence</code> and <code>searchWord</code>:
<ul>
<li>Increment <code>currentIndex</code> and <code>matchCount</code>.</li>
</ul>
</li>
<li>If <code>matchCount</code> equals the length of <code>searchWord</code>, return <code>currentWordPosition</code> since a match is found.</li>
</ul>
</li>
<li>
<p>Skip the rest of the current word:</p>
<ul>
<li>While the current character is not a space, increment <code>currentIndex</code> to move to the end of the word.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no word in the sentence matches <code>searchWord</code> as a prefix, return <code>-1</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/PEcbcEFY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, and <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + w \cdot m)\)</span></p>
<p>The algorithm processes the input string <code>sentence</code> in a single pass. During this traversal, it skips spaces to identify the start of each word, checks for a prefix match between <code>searchWord</code> and the current word, and moves to the end of the word if there is no match. This traversal covers all <span class="math inline">\(n\)</span> characters in <code>sentence</code>.</p>
<p>Additionally, for each word in <code>sentence</code>, the algorithm compares up to <span class="math inline">\(m\)</span> characters with <code>searchWord</code> to check for a prefix match. In the worst case, this adds an <span class="math inline">\(O(m)\)</span> cost for the comparison. Since each word is processed exactly once, the prefix-checking step is effectively absorbed into the overall traversal of <span class="math inline">\(n\)</span>, making the total time complexity <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space. Variables like <code>currentWordPosition</code>, <code>currentIndex</code>, and <code>matchCount</code> are simple integers, and there are no auxiliary data structures (e.g., arrays) used to store intermediate results. Thus, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-built-in-function">Approach 3: Using Built-In Function</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Now that we have explored the approaches where we handle strings manually, let's leverage built-in string libraries for more efficient and cleaner solutions. This will simplify our code and make it easier to understand and maintain.</p>
<h5 id="for-c-users">For C++ Users</h5>
<p>In C++, the <code>istringstream</code> class from the <code>&lt;sstream&gt;</code> library processes strings efficiently. It treats a string as a stream and extracts words using the <code>&gt;&gt;</code> operator. This avoids manual string splitting and space handling. The complexity of extracting words is <span class="math inline">\(O(n)\)</span>, where <code>n</code> is the string length. To check if a word starts with a prefix, the <code>compare</code> function is used, which operates in <span class="math inline">\(O(k)\)</span>, where <code>k</code> is the prefix length.</p>
<h5 id="for-java-users">For Java Users</h5>
<p>In Java, the <code>split</code> method from the <code>String</code> class divides a sentence into words in <span class="math inline">\(O(n)\)</span> time. The <code>startsWith</code> method, operating in <span class="math inline">\(O(k)\)</span>, then checks if each word begins with the given prefix. This combination of <code>split</code> and <code>startsWith</code> ensures clean, efficient code without manual handling of spaces.</p>
<h5 id="for-python3-users">For Python3 Users</h5>
<p>In Python3, the <code>split</code> method separates a sentence into words by whitespace in <span class="math inline">\(O(n)\)</span> time, while the <code>startswith</code> method checks prefixes in <span class="math inline">\(O(k)\)</span>. Then proceed with the implementation.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize a string stream <code>sentenceStream</code> from the input <code>sentence</code> to tokenize the sentence.</p>
</li>
<li>
<p>Initialize <code>currentWord</code> to store each word from the sentence as we process it.</p>
</li>
<li>
<p>Initialize <code>wordPosition</code> to 1 to keep track of the position of the current word in the sentence.</p>
</li>
<li>
<p>While there are words left in the sentence (i.e., <code>sentenceStream &gt;&gt; currentWord</code>):</p>
<ul>
<li>Check if the current word's length is greater than or equal to <code>searchWord</code>'s length and if the current word starts with <code>searchWord</code>:
<ul>
<li>If true, return the current <code>wordPosition</code> (this is the first word that starts with <code>searchWord</code>).</li>
</ul>
</li>
<li>Otherwise, increment <code>wordPosition</code> to check the next word.</li>
</ul>
</li>
<li>
<p>If no word matches, return <code>-1</code> to indicate that no word in the sentence starts with <code>searchWord</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/LWE8FPtk/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>, <span class="math inline">\(k\)</span> be the average length of words in <code>sentence</code>, and <span class="math inline">\(w\)</span> be the total number of words in <code>sentence</code> such that <span class="math inline">\(w \cdot k = n\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + w \cdot m)\)</span></p>
<p>The algorithm first splits the <code>sentence</code> into individual words using built-in functions. This process involves iterating through all <span class="math inline">\(n\)</span> characters of the string once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, for each word extracted from the sentence, the algorithm compares the first <span class="math inline">\(m\)</span> characters of the word with the <code>searchWord</code>. This comparison is done using a built-in function that checks the prefix of length <span class="math inline">\(m\)</span>, which takes <span class="math inline">\(O(m)\)</span> time per word. Since there are <span class="math inline">\(w\)</span> words in the <code>sentence</code>, this part of the algorithm takes <span class="math inline">\(O(w \cdot m)\)</span> time.</p>
<p>Combining both parts, the total time complexity of the algorithm is <span class="math inline">\(O(n + w \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses built-in functions that process the input <code>sentence</code> directly, requiring <span class="math inline">\(O(n)\)</span> space to store the <code>sentence</code> string. The <code>currentWord</code> variable temporarily holds one word at a time, requiring <span class="math inline">\(O(k)\)</span> space, but this space is reused across iterations. Additionally, the algorithm uses constant space <span class="math inline">\(O(1)\)</span> for variables like <code>wordPosition</code>. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-using-trie">Approach 4: Using Trie</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of processing the entire sentence multiple times, we can use a data structure called a <code>Trie</code> (prefix tree). A <code>Trie</code> organizes words so that characters in common prefixes are shared, forming a tree-like structure. This makes it much faster and more efficient to search for prefixes, as both building the <code>Trie</code> and searching for a prefix can be done in linear time relative to the length of the <code>searchWord</code>.</p>
<p>To implement this, we start by creating an empty <code>Trie</code>, which is made up of nodes where each node represents a character. As we add each word from the sentence to the <code>Trie</code>, we also store the wordâ€™s position in the sentence. This is done by keeping a list of positions at each node that corresponds to a character in the word. Later, when we search for a prefix, we can quickly find all the words that match it using this stored information.</p>
<p>For each word in the sentence, we go through the <code>Trie</code> one character at a time. If a character is not already in the Trie, we create a new node for it. As we move through the <code>Trie</code>, we update the list at each node to keep track of which words pass through that character. By the end, the <code>Trie</code> will store all the words in the sentence, organized by their common prefixes.</p>
<p>Once the <code>Trie</code> is built, we can search for the <code>searchWord</code> by going through the <code>Trie</code> one character at a time. If we find all the characters of the <code>searchWord</code>, it means some words in the sentence start with that prefix. The list of word positions at the final node of the <code>searchWord</code> tells us which words match. If we canâ€™t find the node for the <code>searchWord</code>, it means no word in the sentence starts with it.</p>
<p>If we find matching words, we return the smallest position from the list of word positions. This tells us the first word in the sentence that starts with the <code>searchWord</code>. If no matches are found, we return <code>-1</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize the <code>Trie</code> data structure with the root node.</p>
</li>
<li>
<p>Add each word in the sentence to the Trie:</p>
<ul>
<li>Split the sentence into words using an <code>istringstream</code>.</li>
<li>For each word, call <code>addToTrie(word, currentWordPosition)</code> to insert the word into the Trie, associating the word's position in the sentence with it.</li>
<li>Increment <code>currentWordPosition</code> for each word.</li>
</ul>
</li>
<li>
<p>Once all words are added to the Trie, check if the <code>searchWord</code> is a prefix of any word in the sentence:</p>
<ul>
<li>Call <code>checkPrefix(searchWord)</code> to find the positions of words starting with the <code>searchWord</code> prefix.</li>
<li>If no words match the prefix, return <code>-1</code>.</li>
<li>Otherwise, return the smallest position (first occurrence) where the prefix is found in the list of positions.</li>
</ul>
</li>
<li>
<p><code>addToTrie</code> function:</p>
<ul>
<li>Start from the root node.</li>
<li>For each character <code>c</code> in the word:
<ul>
<li>If <code>c</code> is not found in the current node's children, create a new TrieNode for <code>c</code>.</li>
<li>Move to the child node corresponding to <code>c</code>.</li>
<li>Add the <code>currentWordPosition</code> to the nodeâ€™s <code>currentWordPosition</code> list.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>checkPrefix</code> function:</p>
<ul>
<li>Start from the root node.</li>
<li>For each character <code>c</code> in the word:
<ul>
<li>If <code>c</code> is not found in the current node's children, return an empty list (no matching prefix).</li>
<li>Move to the child node corresponding to <code>c</code>.</li>
</ul>
</li>
<li>Return the list of word positions stored in the node corresponding to the last character of the prefix.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/76kWke3Z/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>, <span class="math inline">\(k\)</span> be the average length of words in <code>sentence</code>, and <span class="math inline">\(w\)</span> be the total number of words in <code>sentence</code> such that <span class="math inline">\(w \cdot k = n\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m) \approx O(n)\)</span></p>
<p>The algorithm involves splitting the <code>sentence</code> into words, which takes <span class="math inline">\(O(n)\)</span> time. Building the Trie structure involves inserting each word into the Trie, which takes <span class="math inline">\(O(n)\)</span> time in total (since each character is processed once). Checking the prefix of <code>searchWord</code> in the Trie takes <span class="math inline">\(O(m)\)</span> time, as it involves traversing the Trie for each character in <code>searchWord</code>. Thus, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the Trie structure, which stores all the words from the <code>sentence</code>. In the worst case, the Trie will store all characters of all words, resulting in <span class="math inline">\(O(n)\)</span> space. Additionally, the <code>words</code> list created by splitting the <code>sentence</code> also consumes <span class="math inline">\(O(n)\)</span> space. Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-cells-in-overlapping-horizontal-and-vertical-substrings/description" target="_blank" rel="noopener noreferrer">Count Cells in Overlapping Horizontal and Vertical Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">matrix</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> consisting of characters and a string <code>pattern</code>.</p>

<p>A <strong data-end="264" data-start="240">horizontal substring</strong> is a contiguous sequence of characters read from left to right. If the end of a row is reached before the substring is complete, it wraps to the first column of the next row and continues as needed. You do <strong>not</strong> wrap from the bottom row back to the top.</p>

<p>A <strong data-end="484" data-start="462">vertical substring</strong> is a contiguous sequence of characters read from top to bottom. If the bottom of a column is reached before the substring is complete, it wraps to the first row of the next column and continues as needed. You do <strong>not</strong> wrap from the last column back to the first.</p>

<p>Count the number of cells in the matrix that satisfy the following condition:</p>

<ul>
	<li>The cell must be part of <strong>at least</strong> one horizontal substring and <strong>at least</strong> one vertical substring, where <strong>both</strong> substrings are equal to the given <code>pattern</code>.</li>
</ul>

<p>Return the count of these cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/03/gridtwosubstringsdrawio.png" style="width: 150px; height: 187px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;]], pattern = &quot;abaca&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The pattern <code>&quot;abaca&quot;</code> appears once as a horizontal substring (colored blue) and once as a vertical substring (colored red), intersecting at one cell (colored purple).</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/03/gridexample2fixeddrawio.png" style="width: 150px; height: 150px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;c&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;]], pattern = &quot;aba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The cells colored above are all part of at least one horizontal and one vertical substring matching the pattern <code>&quot;aba&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;a&quot;]], pattern = &quot;a&quot;</span></p>

<p><strong>Output:</strong> 1</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= pattern.length &lt;= m * n</code></li>
	<li><code>grid</code> and <code>pattern</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/counting-words-with-a-given-prefix/description" target="_blank" rel="noopener noreferrer">Counting Words With a Given Prefix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>pref</code>.</p>

<p>Return <em>the number of strings in </em><code>words</code><em> that contain </em><code>pref</code><em> as a <strong>prefix</strong></em>.</p>

<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;pay&quot;,&quot;<strong><u>at</u></strong>tention&quot;,&quot;practice&quot;,&quot;<u><strong>at</strong></u>tend&quot;], <code>pref </code>= &quot;at&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The 2 strings that contain &quot;at&quot; as a prefix are: &quot;<u><strong>at</strong></u>tention&quot; and &quot;<u><strong>at</strong></u>tend&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], <code>pref </code>= &quot;code&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no strings that contain &quot;code&quot; as a prefix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>
	<li><code>words[i]</code> and <code>pref</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Given the small constraints of the problem where <code>words.length</code> <span class="math inline">\(\leq\)</span> 100 (the array contains at most 100 words) and <code>words[i].length</code>, <code>pref.length</code> <span class="math inline">\(\leq\)</span> 100 (each word and the prefix can be up to 100 characters long), a brute-force approach is viable. This approach involves checking each word in the <code>words</code> list to see if it starts with <code>pref</code>. We can do this using two pointers, one for the current word and one for <code>pref</code>, both starting at index 0.</p>
<p>To implement this logic, we iterate through the list of words and for each word, compare its characters with the corresponding characters in <code>pref</code> up to the length of <code>pref</code>. If at any point the characters don't match or if the word's length is smaller than the length of <code>pref</code>, we stop checking that word and move to the next one.</p>
<p>The counter is incremented only when the prefix matches entirely. Finally, after examining all the words in the list, the counter holds the number of words that have <code>pref</code> as their prefix, which is returned as the result.</p>
<h4 id="algorithm">Algorithm</h4>
<p>For the main method <code>prefixCount</code>:</p>
<ul>
<li>Initialize a variable <code>count</code> to <code>0</code> to track the number of strings with the given prefix.</li>
<li>Iterate through each string in the input array <code>words</code>. For each string:
<ul>
<li>Add the result of <code>hasPrefix</code> to <code>count</code>.</li>
</ul>
</li>
<li>Return the final count.</li>
</ul>
<p>For the helper method <code>hasPrefix</code>:</p>
<ul>
<li>Initialize a variable <code>itr</code> to track the current character position being compared.</li>
<li>Start a loop that continues while <code>itr</code> is less than both the length of <code>str</code> and <code>pref</code>:
<ul>
<li>Compare characters at position <code>itr</code> in both strings.</li>
<li>If characters don't match, return <code>0</code> immediately as the prefix is not found.</li>
</ul>
</li>
<li>After the loop ends, check if <code>itr</code> equals the length of <code>pref</code>.
<ul>
<li>If not equal, return <code>0</code> as the string was too short to contain the prefix.</li>
</ul>
</li>
<li>Return <code>1</code> indicating the prefix was found.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fnFNU5E6/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>words</code> and <span class="math inline">\(m\)</span> be the length of the prefix string <code>pref</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The outer loop in <code>prefixCount</code> iterates through each string in the array <code>words</code>, which takes <span class="math inline">\(O(n)\)</span> operations.</p>
<p>For each string, we call <code>hasPrefix</code> which compares characters until it reaches the end of the prefix or finds a mismatch. In the worst case, this character comparison takes <span class="math inline">\(O(m)\)</span> operations.</p>
<p>Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm only uses a constant amount of extra space regardless of the input size. We only store the counter variables <code>count</code> and <code>itr</code>. No additional data structures are created that grow with the input size. Thus, the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-built-in-methods">Approach 2: Built-In Methods</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Matching prefixes is an extremely common task in programming. Because of this, most popular programming languages provide built-in methods to handle prefix matching. These built-in methods have been thoroughly tested and optimized over time, making them more reliable and efficient than custom-written code.</p>
<p>For this reason, it's generally better to use these built-in methods rather than writing our own implementation. Let's look at some popular built-in methods that we can use for this problem:</p>
<h5 id="java">Java</h5>
<ol>
<li>
<p><code>String.startsWith(String prefix)</code><br />
Checks if the string begins with the specified prefix.</p>
</li>
<li>
<p><code>Stream.filter(Predicate&lt;T&gt; predicate)</code><br />
Filters elements in a stream based on a given condition (e.g., checking if a string starts with a prefix).</p>
</li>
<li>
<p><code>String.substring(int beginIndex, int endIndex)</code><br />
Extracts a substring from a string, which can be compared manually to check for a prefix.</p>
</li>
</ol>
<h5 id="c">C++</h5>
<ol>
<li>
<p><code>std::string::find</code> (or <code>std::string::rfind</code>)<br />
Finds the position of the first or last occurrence of a substring and is commonly used to check if it occurs at the start.</p>
</li>
<li>
<p><code>std::string::substr(size_t pos, size_t len)</code><br />
Extracts a substring starting at a position, which can be used to compare the prefix manually.</p>
</li>
<li>
<p><code>std::mismatch</code> (from <code>&lt;algorithm&gt;</code>)<br />
Compares elements of two ranges (e.g., a prefix and the beginning of a string) and determines if they match.</p>
</li>
</ol>
<h5 id="python3">Python3</h5>
<ol>
<li>
<p><code>str.startswith(prefix)</code><br />
Directly checks if the string starts with the specified prefix.</p>
</li>
<li>
<p><code>filter(function, iterable)</code><br />
Applies a function (e.g., a lambda checking <code>startswith</code>) to an iterable and filters elements that match.</p>
</li>
<li>
<p><code>any()</code> and <code>all()</code> (combined with slicing)<br />
Can be used to validate whether a prefix condition holds across a collection.</p>
</li>
</ol>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a variable <code>count</code> to <code>0</code> to track the number of strings with the given prefix.</li>
<li>Iterate through each string <code>word</code> in the input array <code>words</code>:
<ul>
<li>Check if <code>word</code> starts with the given prefix using the built-in string method <code>startsWith</code>.
<ul>
<li>If so, increment the <code>count</code> by 1.</li>
</ul>
</li>
</ul>
</li>
<li>After examining all strings, return the final count.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/4ShBo4Ab/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>words</code> and <span class="math inline">\(m\)</span> be the length of the prefix string <code>pref</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The outer loop iterates through each string in the array <code>words</code>, which takes <span class="math inline">\(O(n)\)</span> operations. For each string, the <code>startsWith</code> method needs to compare characters until it reaches the end of the prefix or finds a mismatch. In the worst case, this comparison takes <span class="math inline">\(O(m)\)</span> operations.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm only uses a constant amount of extra space regardless of the input size. We only store the counter variable <code>count</code>. No additional data structures are created that grow with the input size.</p>
<p>Therefore, the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-trie">Approach 3: Trie</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The process of matching characters sequentially from the beginning aligns perfectly with the concept of a Trie. A Trie is a specialized tree-like data structure designed to handle strings efficiently, especially for operations like prefix searches, word insertions, and word lookups.</p>
<p>Each node in a Trie represents a single character, and the path from the root node to any other node forms a prefix or a word.</p>
<p>Usually a Trie is used in two below ways:</p>
<ol>
<li>
<p>Insertion: When inserting a word into the Trie, we start at the root and traverse down the tree, creating new nodes for each character of the word if they don't already exist. At the end of the word, we mark the final node to signify the completion of the word.</p>
</li>
<li>
<p>Search for a Prefix: To check if a word starts with a given prefix, we simply traverse the Trie following the nodes corresponding to each character of the prefix. If we can traverse all characters successfully, the prefix exists in the Trie.</p>
</li>
</ol>
<p>For example, if we built a Trie using the <code>words</code> array in Example 1 of the problem description, this is how it would look like:</p>
<p><img src="../Figures/2185/trie.png" alt="" /></p>
<p>What makes Tries particularly powerful is their ability to efficiently handle prefix-based operations. Think about how you use autocomplete on your phone - as you type each character, it quickly suggests words that start with those letters. Tries are thus a natural choice for problems involving prefixes or auto-completion. By structuring the characters hierarchically, they allow for fast and intuitive access to any subset of stored strings.</p>
<p>Our version of the Trie has a unique feature - instead of just marking where words end, we keep count of how many words share each prefix. For example, if three words begin with <code>&quot;cat&quot;</code>, then after we reach <code>'t'</code> in the Trie, that node would show a count of 3.</p>
<p>To build this solution, we start by designing our Trie structure. Each node needs two essential pieces: links to its children (representing the next possible characters) and the count variable. Since we're working with lowercase English letters, we can use an array of size 26 for the links, where each index represents a character (a = 0, b = 1, etc.). This array approach gives us constant-time access to child nodes.</p>
<p>When adding words to our Trie, we follow a path determined by each character in the word. If we're adding <code>&quot;cat&quot;</code>, we start at the root and follow (or create) links for <code>'c'</code>, then <code>'a'</code>, then <code>'t'</code>. The crucial part is incrementing the count at each node we visit. This means that after adding <code>&quot;cat&quot;</code>, <code>&quot;car&quot;</code>, and <code>&quot;carpet&quot;</code>, the node for <code>'r'</code> would have a count of 2 (for <code>&quot;car&quot;</code> and <code>&quot;carpet&quot;</code>), while the node for <code>'t'</code> would have a count of 1.</p>
<p>The counting process becomes straightforward once our Trie is built. To find how many words start with a prefix, we simply navigate the Trie following the characters of our prefix. If we can follow the entire prefix, the count at the final node gives us our answer. However, if we can't follow the complete prefix (a link is missing), we know no words start with that prefix, so we return 0.</p>
<blockquote>
<p>For a more comprehensive understanding of tries, check out the <a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card ðŸ”—</a>. This resource provides an in-depth look at the trie data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>prefixCount</code>:</p>
<ul>
<li>Initialize a variable <code>count</code> to 0 to track the count of matching strings.</li>
<li>Create a new instance of the Trie data structure.</li>
<li>Iterate through each string in the input array <code>words</code> and add it to the Trie.</li>
<li>Return the result of counting strings with the given prefix using <code>countPrefix</code>.</li>
</ul>
<p>For the Trie Node structure:</p>
<ul>
<li>Initialize
<ul>
<li>an array <code>links</code> of size <code>26</code> to store pointers to child nodes (one for each lowercase letter).</li>
<li>a variable <code>count</code> to track the number of strings that share the prefix up to this node.</li>
</ul>
</li>
</ul>
<p>For the <code>addWord</code> method:</p>
<ul>
<li>Start at the root node of the Trie.</li>
<li>For each character in the input word:
<ul>
<li>Convert the character to an array index (0-25).</li>
<li>If no node exists for this character, create a new node.</li>
<li>Move to the child node.</li>
<li>Increment the <code>count</code> at the current node to track prefix frequency.</li>
</ul>
</li>
</ul>
<p>For the <code>countPrefix</code> method:</p>
<ul>
<li>Start at the root node of the Trie.</li>
<li>For each character in the prefix string:
<ul>
<li>Convert the character to an array index.</li>
<li>If no node exists for this character, return <code>0</code> as the prefix doesn't exist.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>Return the <code>count</code> stored at the final node, which represents the number of strings containing this prefix.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/LsCe8agi/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the total number of strings in the input array <code>words</code>, <span class="math inline">\(l\)</span> be the maximum length of any string in <code>words</code>, and <span class="math inline">\(m\)</span> be the length of the prefix string <code>pref</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot l + m)\)</span></p>
<p>The algorithm has two main phases. In the first phase, we build the Trie by inserting all words. For each word of maximum length <span class="math inline">\(l\)</span>, we perform <span class="math inline">\(l\)</span> operations to add each character. Since we have <span class="math inline">\(n\)</span> words, building the Trie takes <span class="math inline">\(O(n \cdot l)\)</span> time.</p>
<p>In the second phase, searching for the prefix takes <span class="math inline">\(O(m)\)</span> operations.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(n \cdot l + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot l)\)</span></p>
<p>The space complexity is determined by the size of the Trie structure. In the worst case, when there are no common prefixes among the words, each character of each word will require a new node. Each node contains a fixed-size array of <span class="math inline">\(26\)</span> pointers and a <code>count</code> variable. With <span class="math inline">\(n\)</span> words of maximum length <span class="math inline">\(l\)</span>, the Trie can contain up to <span class="math inline">\(O(n \cdot l)\)</span> nodes. Therefore, the space complexity is <span class="math inline">\(O(n \cdot l)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-prefix-and-suffix-pairs-i/description" target="_blank" rel="noopener noreferrer">Count Prefix and Suffix Pairs I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>

<ul>
	<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword="string-prefix">prefix</span> and a <span data-keyword="string-suffix">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>
</ul>

<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>

<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i, j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.
i = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.
i = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.
i = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.
Therefore, the answer is 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.
i = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.
Therefore, the answer is 2.  </pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]
<strong>Output:</strong> 0
<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.
Therefore, the answer is 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 50</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to count pairs of words where one word is both a prefix and a suffix of the other. A prefix of a string is a part of the string that appears at the start, and a suffix is a part of the string that appears at the end. For example, in the word <code>&quot;ababa&quot;</code>, <code>&quot;aba&quot;</code> is both a prefix and a suffix.</p>
<p>A simple logical solution is to use a brute-force approach, which involves comparing all pairs of words and checking if one word is a prefix and a suffix of the other.</p>
<blockquote>
<p>To check if one string is a prefix or suffix of another, we can use specific built-in functions in different programming languages:</p>
<ul>
<li>In C++, the <code>find</code> function checks if a string appears at the start, and <code>rfind</code> checks if it appears at the end.</li>
<li>In Java and Python3, the <code>startsWith</code> method verifies if a string appears at the start, and the <code>endsWith</code> method checks if it appears at the end.</li>
</ul>
</blockquote>
<p>To implement this, we loop through all pairs of words (<code>i</code>, <code>j</code>) and:</p>
<ul>
<li>For each pair, if <code>str1</code> is longer than <code>str2</code>, we skip that pair because <code>str1</code> cannot be a prefix or suffix of a smaller string.</li>
<li>If <code>str1</code> is both a prefix and a suffix of <code>str2</code>, we increment our count.</li>
</ul>
<p>We repeat this process until we exhaust all possibilities.</p>
<p>This works well for small inputs but becomes inefficient for larger input sizes because of the repeated checks for each pair of words.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of the list of words and <code>count</code> as <code>0</code> to track prefix-suffix pairs.</p>
</li>
<li>
<p>Iterate over all pairs of words:</p>
<ul>
<li>For each word at index <code>i</code>, iterate over all words at index <code>j</code> where <code>j &gt; i</code>.</li>
</ul>
</li>
<li>
<p>For each pair of words (<code>word1</code> and <code>word2</code>):</p>
<ul>
<li>Skip the pair if the length of <code>word1</code> is greater than the length of <code>word2</code>.</li>
<li>Check if <code>word1</code> is both a prefix and a suffix of <code>word2</code>:
<ul>
<li>Verify if <code>word2</code> starts with <code>word1</code>.</li>
<li>Verify if <code>word2</code> ends with <code>word1</code>.</li>
</ul>
</li>
<li>If both conditions are satisfied, increment <code>count</code>.</li>
</ul>
</li>
<li>
<p>Return <code>count</code> as the total number of prefix-suffix pairs.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5w2vLK3F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of words in the input array <code>words</code>, and let <span class="math inline">\(m\)</span> be the average length of the words.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m)\)</span></p>
<p>The algorithm involves a nested loop where the outer loop runs <span class="math inline">\(n\)</span> times and the inner loop runs <span class="math inline">\(n - i - 1\)</span> times for each iteration of the outer loop. For each pair of elements, the algorithm performs two operations:</p>
<ol>
<li>A prefix check using a substring search.</li>
<li>A suffix check using a reverse substring search.</li>
</ol>
<p>Both operations take <span class="math inline">\(O(m)\)</span> time in the worst case, where <span class="math inline">\(m\)</span> is the length of the element being processed. Therefore, the overall time complexity is <span class="math inline">\(O(n^2 \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm uses a fixed amount of extra space, regardless of the input size. The only additional space used is for the loop variables and the <code>count</code> variable, which do not depend on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dual-trie">Approach 2: Dual Trie</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The main challenge in the brute force approach is repeatedly checking for prefixes and suffixes for each word pair. This brings us to the idea of improving efficiency by using a Trie, a data structure that helps with fast prefix matching.</p>
<h5 id="what-is-a-trie">What is a Trie?</h5>
<p>A Trie is a tree-like structure where each node represents a character. When we insert words into a Trie, common prefixes are shared, allowing for efficient prefix lookups. For example, if we store <code>&quot;bat&quot;</code> and <code>&quot;ball&quot;</code>, the Trie would look like this:</p>
<pre><code>      (root)
       |
       b
       |
       a
      / \
     t   l
          \
           l
</code></pre>
<p>Notice how <code>&quot;b&quot;</code> and <code>&quot;a&quot;</code> are shared to save space.</p>
<p>Tries are useful in everyday examples like autocomplete, dictionaries, and word games:</p>
<ul>
<li>Autocomplete: When you type &quot;ca&quot; on your phone, it suggests words like &quot;cat&quot;, &quot;car&quot;, or &quot;can&quot;. It does this by looking up all the words that start with &quot;ca&quot; in a Trie.</li>
<li>Dictionaries: If youâ€™re searching for words that begin with &quot;app&quot;, a Trie quickly finds options like &quot;apple&quot;, &quot;apply&quot;, and &quot;application&quot; without going through the whole list.</li>
<li>Word Games: In games like Scrabble or Boggle, Tries help check if a word is real or suggest possible words from your letters. Some puzzles, like Sudoku, use them too.</li>
</ul>
<p>When inserting a word into the prefix Trie, we are essentially storing all possible prefixes of that word. For example, if the word is <code>&quot;abzdcabz&quot;</code>, we add the following prefixes to the Trie: [<code>&quot;a&quot;</code>, <code>&quot;ab&quot;</code>, <code>&quot;abz&quot;</code>, <code>&quot;abzd&quot;</code>, <code>&quot;abzdc&quot;</code>, <code>&quot;abzdca&quot;</code>, <code>&quot;abzdcab&quot;</code>, <code>&quot;abzdcabz&quot;</code>]. This allows us to quickly determine if any other word starts with the same prefix.</p>
<p>For suffixes, rather than directly storing and checking suffixes (which would require reversing and checking repeatedly for every comparison), we use a trick to convert them to a prefix Trie:</p>
<ol>
<li>Reverse the word.</li>
<li>Insert the reversed word into a separate Trie.</li>
</ol>
<p>By treating the reversed word as a prefix, the suffix-checking problem is reduced to a prefix-matching problem. This allows us to use the same Trie structure for both tasks.</p>
<p>With both the prefix Trie and the suffix Trie set up, we can efficiently check for valid word pairs:</p>
<ul>
<li>For a given word <code>word[i]</code>, use the prefix Trie to check if another word shares the same prefix.</li>
<li>Use the suffix Trie to check if another word shares the same suffix (by checking the reversed version of the word).</li>
</ul>
<p>Let's check if <code>&quot;abz&quot;</code> is both a prefix and a suffix of <code>&quot;abzdcabz&quot;</code>.</p>
<p>First, we insert the string <code>&quot;abzdcabz&quot;</code> into a prefix Trie. This allows us to check if any prefix of a word matches the start of <code>&quot;abzdcabz&quot;</code>. Next, we reverse the string to <code>&quot;zbacdzba&quot;</code> and insert this reversed version into a suffix Trie. This enables us to check if any prefix of a word matches the reversed suffix of <code>&quot;abzdcabz&quot;</code>.</p>
<p>In this way:</p>
<ul>
<li>The prefix Trie for <code>&quot;abzdcabz&quot;</code> stores <code>&quot;abzdcabz&quot;</code>, <code>&quot;abzdcab&quot;</code>, <code>&quot;abzdc&quot;</code>, and so on.</li>
<li>The suffix Trie for <code>&quot;abzdcabz&quot;</code> stores <code>&quot;zbacdzba&quot;</code>, <code>&quot;zbacdzb&quot;</code>, <code>&quot;zbacdz&quot;</code>, and so on.</li>
</ul>
<p>Now, we check each previous word (where <code>j &lt; i</code>). For instance, let's consider <code>&quot;abz&quot;</code> as a previous word.</p>
<p>To verify, we check whether <code>&quot;abz&quot;</code> is a prefix in the prefix Trie and whether <code>&quot;zba&quot;</code> (the reverse of <code>&quot;abz&quot;</code>) is a prefix in the suffix Trie.</p>
<p>In this case:</p>
<ul>
<li><code>&quot;abz&quot;</code> is a prefix of <code>&quot;abzdcabz&quot;</code>, and</li>
<li><code>&quot;zba&quot;</code> (the reversed <code>&quot;abz&quot;</code>) is a prefix of <code>&quot;zbacdzba&quot;</code>, the reversed string of <code>&quot;abzdcabz&quot;</code>.</li>
</ul>
<p>Thus, we count this pair as valid.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/3042/trie.json:805,355!?!</p>
<blockquote>
<p>For a more comprehensive understanding of tries, check out the <a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card ðŸ”—</a>. This resource provides an in-depth look at the trie data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="trie-initialization">Trie Initialization:</h5>
<ul>
<li>Define a <code>Node</code> class that represents each node in the Trie. Each node contains an array <code>links[26]</code> to represent links to <code>26</code> lowercase letters (<code>a</code> - <code>z</code>).</li>
<li>Provide functions:
<ul>
<li><code>contains(c)</code>: Check if a link for character <code>c</code> exists.</li>
<li><code>put(c, node)</code>: Insert a new node for character <code>c</code>.</li>
<li><code>next(c)</code>: Get the next node for character <code>c</code>.</li>
</ul>
</li>
</ul>
<h5 id="trie-insertions--prefix-search">Trie Insertions / Prefix Search:</h5>
<ul>
<li>
<p>Define a <code>Trie</code> class which contains a root node and provides the function <code>insert(word)</code> to insert a word into the Trie and <code>startsWith(prefix)</code> for prefix search:</p>
</li>
<li>
<p><code>insert(word)</code> function:</p>
<ul>
<li>For each character in the word, check if it already exists as a link from the current node. If not, create a new node.</li>
<li>Move to the next node for each character until the entire word is inserted.</li>
</ul>
</li>
<li>
<p><code>startsWith(prefix)</code> function:</p>
<ul>
<li>Traverse the Trie from the root, following the links for each character in the prefix.</li>
<li>If a character link does not exist, return <code>false</code>, indicating the prefix doesn't exist in the Trie.</li>
<li>If the traversal finishes successfully, return <code>true</code>, indicating the prefix exists.</li>
</ul>
</li>
</ul>
<h5 id="main-algorithm-countprefixsuffixpairs">Main Algorithm (countPrefixSuffixPairs):</h5>
<ul>
<li>
<p>Initialize a counter <code>count</code> to 0.</p>
</li>
<li>
<p>For each word in <code>words</code>, do the following:</p>
<ul>
<li>Create two Tries: <code>prefixTrie</code> for storing prefixes of the word and <code>suffixTrie</code> for storing reversed suffixes.</li>
<li>Insert the word into <code>prefixTrie</code> and its reversed version into <code>suffixTrie</code>.</li>
</ul>
</li>
<li>
<p>For each word <code>words[j]</code> (where <code>j &lt; i</code>), check the following:</p>
<ul>
<li>If the length of <code>words[j]</code> is greater than <code>words[i]</code>, skip to the next <code>j</code>.</li>
<li>Extract the prefix <code>prefixWord</code> from <code>words[j]</code> and reverse it to get <code>revPrefixWord</code>.</li>
<li>Check if <code>prefixWord</code> exists in the <code>prefixTrie</code> and <code>revPrefixWord</code> exists in the <code>suffixTrie</code>:
<ul>
<li>If both are true, increment the <code>count</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>count</code> of prefix-suffix pairs.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/egLL23Vb/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of words in the input array <code>words</code>, and let <span class="math inline">\(m\)</span> be the average length of the words.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m)\)</span></p>
<p>The algorithm involves a nested loop where the outer loop runs <span class="math inline">\(n\)</span> times and the inner loop runs <span class="math inline">\(i\)</span> times for each iteration of the outer loop. For each pair of words, the <code>insert</code> and <code>startsWith</code> operations are performed on the Trie. The <code>insert</code> operation takes <span class="math inline">\(O(m)\)</span> time, and the <code>startsWith</code> operation also takes <span class="math inline">\(O(m)\)</span> time. Therefore, the overall time complexity is <span class="math inline">\(O(n^2 \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is determined by the space used by the Tries. Each Trie can store up to <span class="math inline">\(m\)</span> nodes (one for each character in the word), and since there are <span class="math inline">\(n\)</span> words, the total space required for the Tries is <span class="math inline">\(O(n \cdot m)\)</span>. Additionally, the algorithm uses a constant amount of extra space for variables and temporary storage, but this is dominated by the space used by the Tries.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-prefix-and-suffix-pairs-ii/description" target="_blank" rel="noopener noreferrer">Count Prefix and Suffix Pairs II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>

<ul>
	<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword="string-prefix">prefix</span> and a <span data-keyword="string-suffix">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>
</ul>

<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>

<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i<em>, </em>j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.
i = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.
i = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.
i = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.
Therefore, the answer is 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.
i = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.
Therefore, the answer is 2.  </pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]
<strong>Output:</strong> 0
<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.
Therefore, the answer is 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10<sup>5</sup></code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li>The sum of the lengths of all <code>words[i]</code> does not exceed <code>5 * 10<sup>5</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-good-strings/description" target="_blank" rel="noopener noreferrer">Find All Good Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the strings <code>s1</code> and <code>s2</code> of size <code>n</code> and the string <code>evil</code>, return <em>the number of <strong>good</strong> strings</em>.</p>

<p>A <strong>good</strong> string has size <code>n</code>, it is alphabetically greater than or equal to <code>s1</code>, it is alphabetically smaller than or equal to <code>s2</code>, and it does not contain the string <code>evil</code> as a substring. Since the answer can be a huge number, return this <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2, s1 = &quot;aa&quot;, s2 = &quot;da&quot;, evil = &quot;b&quot;
<strong>Output:</strong> 51 
<strong>Explanation:</strong> There are 25 good strings starting with &#39;a&#39;: &quot;aa&quot;,&quot;ac&quot;,&quot;ad&quot;,...,&quot;az&quot;. Then there are 25 good strings starting with &#39;c&#39;: &quot;ca&quot;,&quot;cc&quot;,&quot;cd&quot;,...,&quot;cz&quot; and finally there is one good string starting with &#39;d&#39;: &quot;da&quot;.&nbsp;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 8, s1 = &quot;leetcode&quot;, s2 = &quot;leetgoes&quot;, evil = &quot;leet&quot;
<strong>Output:</strong> 0 
<strong>Explanation:</strong> All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix &quot;leet&quot;, therefore, there is not any good string.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 2, s1 = &quot;gx&quot;, s2 = &quot;gz&quot;, evil = &quot;x&quot;
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>s1.length == n</code></li>
	<li><code>s2.length == n</code></li>
	<li><code>s1 &lt;= s2</code></li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= evil.length &lt;= 50</code></li>
	<li>All strings consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-i/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 10</code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description" target="_blank" rel="noopener noreferrer">Find the Index of the First Occurrence in a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> &quot;sad&quot; occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>
	<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-occurrence-of-first-almost-equal-substring/description" target="_blank" rel="noopener noreferrer">Find the Occurrence of First Almost Equal Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>pattern</code>.</p>

<p>A string <code>x</code> is called <strong>almost equal</strong> to <code>y</code> if you can change <strong>at most</strong> one character in <code>x</code> to make it <em>identical</em> to <code>y</code>.</p>

<p>Return the <strong>smallest</strong> <em>starting index</em> of a <span data-keyword="substring-nonempty">substring</span> in <code>s</code> that is <strong>almost equal</strong> to <code>pattern</code>. If no such index exists, return <code>-1</code>.</p>
A <strong>substring</strong> is a contiguous <b>non-empty</b> sequence of characters within a string.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcdefg&quot;, pattern = &quot;bcdffg&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The substring <code>s[1..6] == &quot;bcdefg&quot;</code> can be converted to <code>&quot;bcdffg&quot;</code> by changing <code>s[4]</code> to <code>&quot;f&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;ababbababa&quot;, pattern = &quot;bacaba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The substring <code>s[4..9] == &quot;bababa&quot;</code> can be converted to <code>&quot;bacaba&quot;</code> by changing <code>s[6]</code> to <code>&quot;c&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcd&quot;, pattern = &quot;dba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;dde&quot;, pattern = &quot;d&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pattern.length &lt; s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>pattern</code> consist only of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow-up:</strong> Could you solve the problem if <strong>at most</strong> <code>k</code> <strong>consecutive</strong> characters can be changed?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/form-array-by-concatenating-subarrays-of-another-array/description" target="_blank" rel="noopener noreferrer">Form Array by Concatenating Subarrays of Another Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>groups</code> of length <code>n</code>. You are also given an integer array <code>nums</code>.</p>

<p>You are asked if you can choose <code>n</code> <strong>disjoint </strong>subarrays from the array <code>nums</code> such that the <code>i<sup>th</sup></code> subarray is equal to <code>groups[i]</code> (<b>0-indexed</b>), and if <code>i &gt; 0</code>, the <code>(i-1)<sup>th</sup></code> subarray appears <strong>before</strong> the <code>i<sup>th</sup></code> subarray in <code>nums</code> (i.e. the subarrays must be in the same order as <code>groups</code>).</p>

<p>Return <code>true</code> <em>if you can do this task, and</em> <code>false</code> <em>otherwise</em>.</p>

<p>Note that the subarrays are <strong>disjoint</strong> if and only if there is no index <code>k</code> such that <code>nums[k]</code> belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
<strong>Output:</strong> true
<strong>Explanation:</strong> You can choose the 0<sup>th</sup> subarray as [1,-1,0,<u><strong>1,-1,-1</strong></u>,3,-2,0] and the 1<sup>st</sup> one as [1,-1,0,1,-1,-1,<u><strong>3,-2,0</strong></u>].
These subarrays are disjoint as they share no common nums[k] element.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
<strong>Output:</strong> false
<strong>Explanation: </strong>Note that choosing the subarrays [<u><strong>1,2,3,4</strong></u>,10,-2] and [1,2,3,4,<u><strong>10,-2</strong></u>] is incorrect because they are not in the same order as in groups.
[10,-2] must come before [1,2,3,4].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
<strong>Output:</strong> false
<strong>Explanation: </strong>Note that choosing the subarrays [7,7,<u><strong>1,2,3</strong></u>,4,7,7] and [7,7,1,2,<u><strong>3,4</strong></u>,7,7] is invalid because they are not disjoint.
They share a common elements nums[4] (0-indexed).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>groups.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>
	<li><code>1 &lt;= groups[i].length, sum(groups[i].length) &lt;= 10<sup><span style="font-size: 10.8333px;">3</span></sup></code></li>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>3</sup></code></li>
	<li><code>-10<sup>7</sup> &lt;= groups[i][j], nums[k] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lexicographically-smallest-generated-string/description" target="_blank" rel="noopener noreferrer">Lexicographically Smallest Generated String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings, <code>str1</code> and <code>str2</code>, of lengths <code>n</code> and <code>m</code>, respectively.</p>

<p>A string <code>word</code> of length <code>n + m - 1</code> is defined to be <strong>generated</strong> by <code>str1</code> and <code>str2</code> if it satisfies the following conditions for <strong>each</strong> index <code>0 &lt;= i &lt;= n - 1</code>:</p>

<ul>
	<li>If <code>str1[i] == &#39;T&#39;</code>, the <strong><span data-keyword="substring-nonempty">substring</span></strong> of <code>word</code> with size <code>m</code> starting at index <code>i</code> is <strong>equal</strong> to <code>str2</code>, i.e., <code>word[i..(i + m - 1)] == str2</code>.</li>
	<li>If <code>str1[i] == &#39;F&#39;</code>, the <strong><span data-keyword="substring-nonempty">substring</span></strong> of <code>word</code> with size <code>m</code> starting at index <code>i</code> is <strong>not equal</strong> to <code>str2</code>, i.e., <code>word[i..(i + m - 1)] != str2</code>.</li>
</ul>

<p>Return the <strong><span data-keyword="lexicographically-smaller-string">lexicographically smallest</span></strong> possible string that can be <strong>generated</strong> by <code>str1</code> and <code>str2</code>. If no string can be generated, return an empty string <code>&quot;&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">str1 = &quot;TFTF&quot;, str2 = &quot;ab&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;ababa&quot;</span></p>

<p><strong>Explanation:</strong></p>

<h4>The table below represents the string <code>&quot;ababa&quot;</code></h4>

<table>
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Index</th>
			<th style="border: 1px solid black;">T/F</th>
			<th style="border: 1px solid black;">Substring of length <code>m</code></th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>&#39;T&#39;</code></td>
			<td style="border: 1px solid black;">&quot;ab&quot;</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>&#39;F&#39;</code></td>
			<td style="border: 1px solid black;">&quot;ba&quot;</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;"><code>&#39;T&#39;</code></td>
			<td style="border: 1px solid black;">&quot;ab&quot;</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;"><code>&#39;F&#39;</code></td>
			<td style="border: 1px solid black;">&quot;ba&quot;</td>
		</tr>
	</tbody>
</table>

<p>The strings <code>&quot;ababa&quot;</code> and <code>&quot;ababb&quot;</code> can be generated by <code>str1</code> and <code>str2</code>.</p>

<p>Return <code>&quot;ababa&quot;</code> since it is the lexicographically smaller string.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">str1 = &quot;TFTF&quot;, str2 = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>No string that satisfies the conditions can be generated.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">str1 = &quot;F&quot;, str2 = &quot;d&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;a&quot;</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == str1.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= m == str2.length &lt;= 500</code></li>
	<li><code>str1</code> consists only of <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code>.</li>
	<li><code>str2</code> consists only of lowercase English characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-happy-prefix/description" target="_blank" rel="noopener noreferrer">Longest Happy Prefix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A string is called a <strong>happy prefix</strong> if is a <strong>non-empty</strong> prefix which is also a suffix (excluding itself).</p>

<p>Given a string <code>s</code>, return <em>the <strong>longest happy prefix</strong> of</em> <code>s</code>. Return an empty string <code>&quot;&quot;</code> if no such prefix exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;level&quot;
<strong>Output:</strong> &quot;l&quot;
<strong>Explanation:</strong> s contains 4 prefix excluding itself (&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;), and suffix (&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;). The largest prefix which is also suffix is given by &quot;l&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ababab&quot;
<strong>Output:</strong> &quot;abab&quot;
<strong>Explanation:</strong> &quot;abab&quot; is the largest prefix which is also suffix. They can overlap in the original string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/match-substring-after-replacement/description" target="_blank" rel="noopener noreferrer">Match Substring After Replacement</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>sub</code>. You are also given a 2D character array <code>mappings</code> where <code>mappings[i] = [old<sub>i</sub>, new<sub>i</sub>]</code> indicates that you may perform the following operation <strong>any</strong> number of times:</p>

<ul>
	<li><strong>Replace</strong> a character <code>old<sub>i</sub></code> of <code>sub</code> with <code>new<sub>i</sub></code>.</li>
</ul>

<p>Each character in <code>sub</code> <strong>cannot</strong> be replaced more than once.</p>

<p>Return <code>true</code><em> if it is possible to make </em><code>sub</code><em> a substring of </em><code>s</code><em> by replacing zero or more characters according to </em><code>mappings</code>. Otherwise, return <code>false</code>.</p>

<p>A <strong>substring</strong> is a contiguous non-empty sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;fool3e7bar&quot;, sub = &quot;leet&quot;, mappings = [[&quot;e&quot;,&quot;3&quot;],[&quot;t&quot;,&quot;7&quot;],[&quot;t&quot;,&quot;8&quot;]]
<strong>Output:</strong> true
<strong>Explanation:</strong> Replace the first &#39;e&#39; in sub with &#39;3&#39; and &#39;t&#39; in sub with &#39;7&#39;.
Now sub = &quot;l3e7&quot; is a substring of s, so we return true.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;fooleetbar&quot;, sub = &quot;f00l&quot;, mappings = [[&quot;o&quot;,&quot;0&quot;]]
<strong>Output:</strong> false
<strong>Explanation:</strong> The string &quot;f00l&quot; is not a substring of s and no replacements can be made.
Note that we cannot replace &#39;0&#39; with &#39;o&#39;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;Fool33tbaR&quot;, sub = &quot;leetd&quot;, mappings = [[&quot;e&quot;,&quot;3&quot;],[&quot;t&quot;,&quot;7&quot;],[&quot;t&quot;,&quot;8&quot;],[&quot;d&quot;,&quot;b&quot;],[&quot;p&quot;,&quot;b&quot;]]
<strong>Output:</strong> true
<strong>Explanation:</strong> Replace the first and second &#39;e&#39; in sub with &#39;3&#39; and &#39;d&#39; in sub with &#39;b&#39;.
Now sub = &quot;l33tb&quot; is a substring of s, so we return true.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= sub.length &lt;= s.length &lt;= 5000</code></li>
	<li><code>0 &lt;= mappings.length &lt;= 1000</code></li>
	<li><code>mappings[i].length == 2</code></li>
	<li><code>old<sub>i</sub> != new<sub>i</sub></code></li>
	<li><code>s</code> and <code>sub</code> consist of uppercase and lowercase English letters and digits.</li>
	<li><code>old<sub>i</sub></code> and <code>new<sub>i</sub></code> are either uppercase or lowercase English letters or digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-deletions-on-a-string/description" target="_blank" rel="noopener noreferrer">Maximum Deletions on a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of only lowercase English letters. In one operation, you can:</p>

<ul>
	<li>Delete <strong>the entire string</strong> <code>s</code>, or</li>
	<li>Delete the <strong>first</strong> <code>i</code> letters of <code>s</code> if the first <code>i</code> letters of <code>s</code> are <strong>equal</strong> to the following <code>i</code> letters in <code>s</code>, for any <code>i</code> in the range <code>1 &lt;= i &lt;= s.length / 2</code>.</li>
</ul>

<p>For example, if <code>s = &quot;ababc&quot;</code>, then in one operation, you could delete the first two letters of <code>s</code> to get <code>&quot;abc&quot;</code>, since the first two letters of <code>s</code> and the following two letters of <code>s</code> are both equal to <code>&quot;ab&quot;</code>.</p>

<p>Return <em>the <strong>maximum</strong> number of operations needed to delete all of </em><code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcabcdabc&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong>
- Delete the first 3 letters (&quot;abc&quot;) since the next 3 letters are equal. Now, s = &quot;abcdabc&quot;.
- Delete all the letters.
We used 2 operations so return 2. It can be proven that 2 is the maximum number of operations needed.
Note that in the second operation we cannot delete &quot;abc&quot; again because the next occurrence of &quot;abc&quot; does not happen in the next 3 letters.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaabaab&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong>
- Delete the first letter (&quot;a&quot;) since the next letter is equal. Now, s = &quot;aabaab&quot;.
- Delete the first 3 letters (&quot;aab&quot;) since the next 3 letters are equal. Now, s = &quot;aab&quot;.
- Delete the first letter (&quot;a&quot;) since the next letter is equal. Now, s = &quot;ab&quot;.
- Delete all the letters.
We used 4 operations so return 4. It can be proven that 4 is the maximum number of operations needed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaaaa&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> In each operation, we can delete the first letter of s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 4000</code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-repeating-substring/description" target="_blank" rel="noopener noreferrer">Maximum Repeating Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>For a string <code>sequence</code>, a string <code>word</code> is <strong><code>k</code>-repeating</strong> if <code>word</code> concatenated <code>k</code> times is a substring of <code>sequence</code>. The <code>word</code>&#39;s <strong>maximum <code>k</code>-repeating value</strong> is the highest value <code>k</code> where <code>word</code> is <code>k</code>-repeating in <code>sequence</code>. If <code>word</code> is not a substring of <code>sequence</code>, <code>word</code>&#39;s maximum <code>k</code>-repeating value is <code>0</code>.</p>

<p>Given strings <code>sequence</code> and <code>word</code>, return <em>the <strong>maximum <code>k</code>-repeating value</strong> of <code>word</code> in <code>sequence</code></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ab&quot;
<strong>Output:</strong> 2
<strong>Explanation: </strong>&quot;abab&quot; is a substring in &quot;<u>abab</u>c&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ba&quot;
<strong>Output:</strong> 1
<strong>Explanation: </strong>&quot;ba&quot; is a substring in &quot;a<u>ba</u>bc&quot;. &quot;baba&quot; is not a substring in &quot;ababc&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ac&quot;
<strong>Output:</strong> 0
<strong>Explanation: </strong>&quot;ac&quot; is not a substring in &quot;ababc&quot;. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= sequence.length &lt;= 100</code></li>
	<li><code>1 &lt;= word.length &lt;= 100</code></li>
	<li><code>sequence</code> and <code>word</code>&nbsp;contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-i/description" target="_blank" rel="noopener noreferrer">Minimum Number of Valid Strings to Form Target I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>target</code>.</p>

<p>A string <code>x</code> is called <strong>valid</strong> if <code>x</code> is a <span data-keyword="string-prefix">prefix</span> of <strong>any</strong> string in <code>words</code>.</p>

<p>Return the <strong>minimum</strong> number of <strong>valid</strong> strings that can be <em>concatenated</em> to form <code>target</code>. If it is <strong>not</strong> possible to form <code>target</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abc&quot;,&quot;aaaaa&quot;,&quot;bcdef&quot;], target = &quot;aabcdabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 2 of <code>words[1]</code>, i.e. <code>&quot;aa&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[2]</code>, i.e. <code>&quot;bcd&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[0]</code>, i.e. <code>&quot;abc&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abababab&quot;,&quot;ab&quot;], target = &quot;ababaababa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abcdef&quot;], target = &quot;xyz&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>3</sup></code></li>
	<li>The input is generated such that <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>3</sup></code></li>
	<li><code>target</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-ii/description" target="_blank" rel="noopener noreferrer">Minimum Number of Valid Strings to Form Target II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>target</code>.</p>

<p>A string <code>x</code> is called <strong>valid</strong> if <code>x</code> is a <span data-keyword="string-prefix">prefix</span> of <strong>any</strong> string in <code>words</code>.</p>

<p>Return the <strong>minimum</strong> number of <strong>valid</strong> strings that can be <em>concatenated</em> to form <code>target</code>. If it is <strong>not</strong> possible to form <code>target</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abc&quot;,&quot;aaaaa&quot;,&quot;bcdef&quot;], target = &quot;aabcdabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 2 of <code>words[1]</code>, i.e. <code>&quot;aa&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[2]</code>, i.e. <code>&quot;bcd&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[0]</code>, i.e. <code>&quot;abc&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abababab&quot;,&quot;ab&quot;], target = &quot;ababaababa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abcdef&quot;], target = &quot;xyz&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The input is generated such that <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>target</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-i/description" target="_blank" rel="noopener noreferrer">Minimum Time to Revert Word to Initial State I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>word</code> and an integer <code>k</code>.</p>

<p>At every second, you must perform the following operations:</p>

<ul>
	<li>Remove the first <code>k</code> characters of <code>word</code>.</li>
	<li>Add any <code>k</code> characters to the end of <code>word</code>.</li>
</ul>

<p><strong>Note</strong> that you do not necessarily need to add the same characters that you removed. However, you must perform <strong>both</strong> operations at every second.</p>

<p>Return <em>the <strong>minimum</strong> time greater than zero required for</em> <code>word</code> <em>to revert to its <strong>initial</strong> state</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;aba&quot; from the prefix of word, and add characters &quot;bac&quot; to the end of word. Thus, word becomes equal to &quot;cababac&quot;.
At the 2nd second, we remove characters &quot;cab&quot; from the prefix of word, and add &quot;aba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 4
<strong>Output:</strong> 1
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;abac&quot; from the prefix of word, and add characters &quot;caba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abcbabcd&quot;, k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.
After 4 seconds, word becomes equal to &quot;abcbabcd&quot; and reverts to its initial state.
It can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 50 </code></li>
	<li><code>1 &lt;= k &lt;= word.length</code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-ii/description" target="_blank" rel="noopener noreferrer">Minimum Time to Revert Word to Initial State II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>word</code> and an integer <code>k</code>.</p>

<p>At every second, you must perform the following operations:</p>

<ul>
	<li>Remove the first <code>k</code> characters of <code>word</code>.</li>
	<li>Add any <code>k</code> characters to the end of <code>word</code>.</li>
</ul>

<p><strong>Note</strong> that you do not necessarily need to add the same characters that you removed. However, you must perform <strong>both</strong> operations at every second.</p>

<p>Return <em>the <strong>minimum</strong> time greater than zero required for</em> <code>word</code> <em>to revert to its <strong>initial</strong> state</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;aba&quot; from the prefix of word, and add characters &quot;bac&quot; to the end of word. Thus, word becomes equal to &quot;cababac&quot;.
At the 2nd second, we remove characters &quot;cab&quot; from the prefix of word, and add &quot;aba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 4
<strong>Output:</strong> 1
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;abac&quot; from the prefix of word, and add characters &quot;caba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abcbabcd&quot;, k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.
After 4 seconds, word becomes equal to &quot;abcbabcd&quot; and reverts to its initial state.
It can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= word.length</code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/description" target="_blank" rel="noopener noreferrer">Number of Subarrays That Match a Pattern I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code>, and a <strong>0-indexed</strong> integer array <code>pattern</code> of size <code>m</code> consisting of integers <code>-1</code>, <code>0</code>, and <code>1</code>.</p>

<p>A <span data-keyword="subarray">subarray</span> <code>nums[i..j]</code> of size <code>m + 1</code> is said to match the <code>pattern</code> if the following conditions hold for each element <code>pattern[k]</code>:</p>

<ul>
	<li><code>nums[i + k + 1] &gt; nums[i + k]</code> if <code>pattern[k] == 1</code>.</li>
	<li><code>nums[i + k + 1] == nums[i + k]</code> if <code>pattern[k] == 0</code>.</li>
	<li><code>nums[i + k + 1] &lt; nums[i + k]</code> if <code>pattern[k] == -1</code>.</li>
</ul>

<p>Return <em>the<strong> count</strong> of subarrays in</em> <code>nums</code> <em>that match the</em> <code>pattern</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6], pattern = [1,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.
Hence, there are 4 subarrays in nums that match the pattern.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
<strong>Output:</strong> 2
<strong>Explanation: </strong>Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.
Hence, there are 2 subarrays in nums that match the pattern.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= m == pattern.length &lt; n</code></li>
	<li><code>-1 &lt;= pattern[i] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subarrays-that-match-a-pattern-ii/description" target="_blank" rel="noopener noreferrer">Number of Subarrays That Match a Pattern II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code>, and a <strong>0-indexed</strong> integer array <code>pattern</code> of size <code>m</code> consisting of integers <code>-1</code>, <code>0</code>, and <code>1</code>.</p>

<p>A <span data-keyword="subarray">subarray</span> <code>nums[i..j]</code> of size <code>m + 1</code> is said to match the <code>pattern</code> if the following conditions hold for each element <code>pattern[k]</code>:</p>

<ul>
	<li><code>nums[i + k + 1] &gt; nums[i + k]</code> if <code>pattern[k] == 1</code>.</li>
	<li><code>nums[i + k + 1] == nums[i + k]</code> if <code>pattern[k] == 0</code>.</li>
	<li><code>nums[i + k + 1] &lt; nums[i + k]</code> if <code>pattern[k] == -1</code>.</li>
</ul>

<p>Return <em>the<strong> count</strong> of subarrays in</em> <code>nums</code> <em>that match the</em> <code>pattern</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6], pattern = [1,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.
Hence, there are 4 subarrays in nums that match the pattern.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
<strong>Output:</strong> 2
<strong>Explanation: </strong>Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.
Hence, there are 2 subarrays in nums that match the pattern.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= m == pattern.length &lt; n</code></li>
	<li><code>-1 &lt;= pattern[i] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/repeated-string-match/description" target="_blank" rel="noopener noreferrer">Repeated String Match</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>a</code> and <code>b</code>, return <em>the minimum number of times you should repeat string </em><code>a</code><em> so that string</em> <code>b</code> <em>is a substring of it</em>. If it is impossible for <code>b</code>â€‹â€‹â€‹â€‹â€‹â€‹ to be a substring of <code>a</code> after repeating it, return <code>-1</code>.</p>

<p><strong>Notice:</strong> string <code>&quot;abc&quot;</code> repeated 0 times is <code>&quot;&quot;</code>, repeated 1 time is <code>&quot;abc&quot;</code> and repeated 2 times is <code>&quot;abcabc&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> We return 3 because by repeating a three times &quot;ab<strong>cdabcdab</strong>cd&quot;, b is a substring of it.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;a&quot;, b = &quot;aa&quot;
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>
	<li><code>a</code> and <code>b</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-ad-hoc-accepted">Approach #1: Ad-Hoc [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>The question can be summarized as &quot;What is the smallest <code>k</code> for which <code>B</code> is a substring of <code>A * k</code>?&quot;  We can just try every <code>k</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Imagine we wrote <code>S = A+A+A+...</code>. If <code>B</code> is to be a substring of <code>S</code>, we only need to check whether some <code>S[0:], S[1:], ..., S[len(A) - 1:]</code> starts with <code>B</code>, as <code>S</code> is long enough to contain <code>B</code>, and <code>S</code> has a period at most <code>len(A)</code>.</p>
<p>Now, suppose <code>q</code> is the least number for which <code>len(B) &lt;= len(A * q)</code>. We only need to check whether <code>B</code> is a substring of <code>A * q</code> or <code>A * (q+1)</code>. If we try <code>k &lt; q</code>, then <code>B</code> has a larger length than <code>A * q</code> and therefore can't be a substring. When <code>k = q+1</code>, <code>A * k</code> is already big enough to try all positions for <code>B</code>; namely, <code>A[i:i+len(B)] == B</code> for <code>i = 0, 1, ..., len(A) - 1</code>.</p>
<p><a href="https://leetcode.com/playground/gTtmgvev/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N*(N+M))\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of strings <code>A, B</code>. We create two strings <code>A * q</code>, <code>A * (q+1)</code> which have a length at most <code>O(M+N)</code>. When checking whether <code>B</code> is a substring of <code>A</code>, this check takes naively the product of their lengths.</p>
</li>
<li>
<p>Space complexity: As justified above, we created strings that used <span class="math inline">\(O(M+N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-rabin-karp-rolling-hash-accepted">Approach #2: Rabin-Karp (Rolling Hash) [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>As in <em>Approach #1</em>, we've reduced the problem to deciding whether B is a substring of some <code>A * k</code>. Using the following technique, we can decide whether <code>B</code> is a substring in <span class="math inline">\(O(len(A) * k)\)</span> time.</p>
<p><strong>Algorithm</strong></p>
<p>For strings <span class="math inline">\(S\)</span>, consider each <span class="math inline">\(S[i]\)</span> as some integer ASCII code. Then for some prime <span class="math inline">\(p\)</span>, consider the following function modulo some prime modulus <span class="math inline">\(\mathcal{M}\)</span>:</p>
<p><span class="math display">\[
Notably, $$\text{hash}(S[1:] + x) = \frac{(\text{hash}(S) - S[0])}{p} + p^{n-1} x$$. This shows we can get the hash of every substring of `A * q` in time complexity linear to its size (We will also use the fact that $$p^{-1} = p^{\mathcal{M}-2} \mod \mathcal{M}$$).

However, hashes may collide haphazardly. To be absolutely sure in theory, we should check the answer in the usual way. The expected number of checks we make is in the order of $$1 + \frac{s}{\mathcal{M}}$$ where $$s$$ is the number of substrings we computed hashes for (assuming the hashes are equally distributed), which is effectively 1.

[code](https://leetcode.com/playground/DKSFgXSr/shared)

**Complexity Analysis**

* Time Complexity: $$O(M+N)$$ (at these sizes), where $$M, N$$ are the lengths of strings `A, B`. As in *Approach #1*, we justify that `A * (q+1)` will be of length $$O(M + N)$$, and computing the rolling hashes was linear work. We will also do a linear $$O(N)$$ final check of our answer $$1 + O(M) / \mathcal{M}$$ times. In total, this is $$O(M+N + N(1 + \frac{M}{\mathcal{M}}))$$ work. Since $$M \leq 10000 < \mathcal{M} = 10^9 + 7$$, we can consider this to be linear behavior.

* Space complexity: $$O(1)$$. Only integers were stored with additional memory.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/repeated-substring-pattern/description" target="_blank" rel="noopener noreferrer">Repeated Substring Pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abab&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> It is the substring &quot;ab&quot; twice.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aba&quot;
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcabcabcabc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotate-string/description" target="_blank" rel="noopener noreferrer">Rotate String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>s</code> and <code>goal</code>, return <code>true</code> <em>if and only if</em> <code>s</code> <em>can become</em> <code>goal</code> <em>after some number of <strong>shifts</strong> on</em> <code>s</code>.</p>

<p>A <strong>shift</strong> on <code>s</code> consists of moving the leftmost character of <code>s</code> to the rightmost position.</p>

<ul>
	<li>For example, if <code>s = &quot;abcde&quot;</code>, then it will be <code>&quot;bcdea&quot;</code> after one shift.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "abcde", goal = "cdeab"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "abcde", goal = "abced"
<strong>Output:</strong> false
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, goal.length &lt;= 100</code></li>
	<li><code>s</code> and <code>goal</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>A rotation shifts the characters of the string to the right, one by one. The simplest way to solve this problem is to simulate each possible rotation of the string <code>s</code> and compare the result to the <code>goal</code>.</p>
<p>If the lengths of <code>s</code> and <code>goal</code> are not equal, there's no way <code>s</code> can be rotated to become <code>goal</code>. This is the base case. If they are of equal length, we can then proceed with checking each rotation.</p>
<p>To simulate a rotation, we move the first character of <code>s</code> to the end and compare the new string with <code>goal</code>. We repeat this process for every possible rotation. If at any point, <code>s</code> matches <code>goal</code>, we can conclude that the rotation works, and we return <code>true</code>. If none of the rotations match the <code>goal</code>, we return <code>false</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Check if the lengths of <code>s</code> and <code>goal</code> are different:</p>
<ul>
<li>If they are not equal, return <code>false</code> since one string cannot be a rotation of the other.</li>
</ul>
</li>
<li>
<p>Initialize <code>length</code> to store the length of string <code>s</code>.</p>
</li>
<li>
<p>Use a loop to attempt all possible rotations of <code>s</code>:</p>
<ul>
<li>For each possible rotation count from <code>0</code> to <code>length - 1</code>:
<ul>
<li>Perform one left rotation on <code>s</code>, moving the first character to the end of the string.</li>
<li>Check if the rotated string <code>s</code> is equal to <code>goal</code>:
<ul>
<li>If they are equal, return <code>true</code>, indicating that <code>goal</code> is a rotation of <code>s</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If all rotations have been checked and none match <code>goal</code>, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/UhNHsCyD/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of string <span class="math inline">\(s\)</span> (and also the size of string <span class="math inline">\(goal\)</span>, since they must be of equal length to be rotations).</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>Checking if the lengths of both strings are different takes <span class="math inline">\(O(1)\)</span>.</p>
<p>The loop iterates <span class="math inline">\(n\)</span> times (for each possible rotation).</p>
<p>Inside the loop, the <code>rotate</code> function performs a rotation, which takes <span class="math inline">\(O(n)\)</span>, and comparing two strings <span class="math inline">\(s\)</span> and <span class="math inline">\(goal\)</span> also takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, for each of the <span class="math inline">\(n\)</span> rotations, we are performing operations that take <span class="math inline">\(O(n)\)</span>, leading to an overall time complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(1)\)</span></p>
<p>Each rotation creates a new string <span class="math inline">\(s\)</span> of length <span class="math inline">\(n\)</span>, so the additional space for each new string is <span class="math inline">\(O(n)\)</span>.</p>
<p>Java and Pythonâ€™s string immutability means that every new rotation stores a new string in memory, leading to <span class="math inline">\(O(n)\)</span> space complexity for each rotation.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span> for Java and Python, as we maintain the current rotated string in memory and for CPP its <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-concatenation-check">Approach 2: Concatenation Check</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of rotating the string and checking after each rotation, we can observe a relationship between <code>s</code> and <code>goal</code>. If <code>goal</code> can be formed by rotating <code>s</code>, it must be possible to find <code>goal</code> as a substring in some version of <code>s</code>.</p>
<p>A clever way to exploit this is by concatenating <code>s</code> with itself. Why? Because this effectively creates a string that contains all possible rotations of <code>s</code> within it. For example, if <code>s = &quot;abcde&quot;</code>, then <code>s + s = &quot;abcdeabcde&quot;</code>. Notice how every possible rotation of <code>s</code> appears somewhere in this concatenated string.</p>
<p>So, if <code>goal</code> can be obtained by rotating <code>s</code>, it must be a substring of <code>s + s</code>. To implement this, we simply check if <code>goal</code> is a substring of the concatenated string. If it is, we return <code>true</code>; otherwise, we return <code>false</code>.</p>
<p><img src="../Figures/796/796_rotate.png" alt="Concatenation Check" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Check if the lengths of strings <code>s</code> and <code>goal</code> are different:</p>
<ul>
<li>If they are, return <code>false</code> because a rotation of <code>s</code> cannot match <code>goal</code>.</li>
</ul>
</li>
<li>
<p>Create a new string <code>doubledString</code> by concatenating <code>s</code> with itself.</p>
</li>
<li>
<p>Use a string search method to find the substring <code>goal</code> within <code>doubledString</code>:</p>
<ul>
<li>If <code>goal</code> is found, check if this index is less than the length of <code>doubledString</code>.</li>
<li>If it is, return <code>true</code>, indicating that <code>goal</code> is a valid rotation of <code>s</code>. Otherwise, return <code>false</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9FJaUG6S/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of string <span class="math inline">\(s\)</span> (and also the size of string <span class="math inline">\(goal\)</span>, since they must be of equal length to be rotations).</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Checking if the lengths of both strings are different takes <span class="math inline">\(O(1)\)</span>.</p>
<p>Concatenating the string <span class="math inline">\(s\)</span> with itself to create <code>doubledString</code> takes <span class="math inline">\(O(n)\)</span> because we are creating a new string that is twice the length of <span class="math inline">\(s\)</span>.</p>
<p>The substring find function is typically implemented using an algorithm that runs in <span class="math inline">\(O(n)\)</span>. This involves scanning the <code>doubledString</code> of length <span class="math inline">\(2n\)</span> for the substring <code>goal</code> of length <span class="math inline">\(n\)</span>. Since the search occurs in a string of size <span class="math inline">\(2n\)</span>, the overall complexity for this operation remains <span class="math inline">\(O(n)\)</span>.</p>
<p>Overall, the most significant operations are linear in terms of <span class="math inline">\(n\)</span>, resulting in a total time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space used for the <code>doubledString</code> is <span class="math inline">\(O(n)\)</span> since it stores a string that is double the size of <span class="math inline">\(s\)</span> (specifically, <span class="math inline">\(O(2 \cdot n) \approx O(n)\)</span>).</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span> due to the concatenated string.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-kmp-algorithm">Approach 3: KMP Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can refine the substring search using the <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt (KMP) algorithm</a>. This follows the same intuition as the concatenation approach but improves how we search for <code>goal</code> within the concatenated string <code>s + s</code>.</p>
<p>The KMP algorithm allows us to search for substrings in linear time by preprocessing the pattern (in this case, <code>goal</code>) to identify where matches might fail early. The idea is to avoid rechecking characters weâ€™ve already confirmed donâ€™t match.</p>
<p>First, we preprocess <code>goal</code> to create the longest prefix suffix (LPS) array. The LPS array stores the lengths of the longest proper prefix of the substring that matches a proper suffix for every prefix of <code>goal</code>. For example, if a mismatch occurs after matching a certain number of characters, the LPS array tells us how many characters we can skip and where to resume checking in the pattern. This way we don't need to start from the beginning of <code>goal</code> each time a mismatch happens.</p>
<p>Once the LPS array is ready, we scan through the concatenated string <code>s + s</code> and use the LPS array to efficiently find the <code>goal</code>. As we iterate through <code>s + s</code>, we compare characters from <code>goal</code> against the characters of the concatenated string. If we find a match, we continue comparing; however, if a mismatch occurs, we use the value from the LPS array to determine the next position in <code>goal</code> to check.</p>
<blockquote>
<p>Note: This approach doesn't change much in terms of time complexity and space complexity compared to the previous approach, but we included it as we thought it could be a good problem to demonstrate the use of KMP in general.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Check if the lengths of strings <code>s</code> and <code>goal</code> are different:</p>
<ul>
<li>If they are, return <code>false</code> (they can't be rotations).</li>
</ul>
</li>
<li>
<p>Concatenate <code>s</code> with itself to create <code>doubledString</code>, which contains all possible rotations of <code>s</code>.</p>
</li>
<li>
<p>Call the <code>kmpSearch</code> function to check if <code>goal</code> is a substring of <code>doubledString</code>.</p>
</li>
<li>
<p>In the <code>kmpSearch</code> function:</p>
<ul>
<li>
<p>Precompute the LPS (Longest Prefix Suffix) array for the <code>pattern</code> (which is <code>goal</code>).</p>
</li>
<li>
<p>Initialize indices <code>textIndex</code> and <code>patternIndex</code> to track positions in <code>text</code> and <code>pattern</code>, respectively.</p>
</li>
<li>
<p>Loop through <code>text</code>:</p>
<ul>
<li>
<p>If the characters at <code>text[textIndex]</code> and <code>pattern[patternIndex]</code> match:</p>
<ul>
<li>Increment both indices.</li>
<li>If <code>patternIndex</code> equals the length of the pattern, return <code>true</code> (the pattern has been found).</li>
</ul>
</li>
<li>
<p>If there's a mismatch after some matches:</p>
<ul>
<li>Use the LPS array to update <code>patternIndex</code> to skip unnecessary comparisons.</li>
</ul>
</li>
<li>
<p>If there are no matches:</p>
<ul>
<li>Move <code>textIndex</code> to the next character.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the loop finishes without finding the pattern, return <code>false</code>.</p>
</li>
</ul>
</li>
<li>
<p>In the <code>computeLPS</code> function:</p>
<ul>
<li>
<p>Initialize the LPS array with zeros.</p>
</li>
<li>
<p>Build the LPS array to store the lengths of the longest prefix that is also a suffix for each position in the pattern:</p>
<ul>
<li>While the <code>index</code> is less than the length of the pattern:
<ul>
<li>If characters match, increment the length and set the corresponding LPS value.</li>
<li>If there's a mismatch, update the length using the previous LPS value.</li>
<li>If there's no match and the length is zero, set the LPS value to zero.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the constructed LPS array.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/7SUakKWm/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of string <span class="math inline">\(s\)</span> (and also the size of string <span class="math inline">\(goal\)</span>, since they must be of equal length to be rotations).</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Checking if the lengths of both strings are different takes <span class="math inline">\(O(1)\)</span>.</p>
<p>Concatenating the string <span class="math inline">\(s\)</span> with itself to create <code>doubledString</code> takes <span class="math inline">\(O(n)\)</span> because we are creating a new string that is twice the length of <span class="math inline">\(s\)</span>.</p>
<p>The KMP substring search involves computing the LPS array for the <code>goal</code>, which takes <span class="math inline">\(O(n)\)</span>, and the search process itself also runs in <span class="math inline">\(O(n)\)</span>. Thus, the total time for KMP is <span class="math inline">\(O(n)\)</span>.</p>
<p>Overall, the most significant operation is linear in terms of <span class="math inline">\(n\)</span>, resulting in a total time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space used for the <code>doubledString</code> is <span class="math inline">\(O(n)\)</span> since it stores a string that is double the size of <span class="math inline">\(s\)</span>.</p>
<p>The LPS array in the <code>computeLPS</code> function is of size <span class="math inline">\(n\)</span>, which contributes <span class="math inline">\(O(n)\)</span> space.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span> due to the concatenated string and the LPS array.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-matching-substring/description" target="_blank" rel="noopener noreferrer">Shortest Matching Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a pattern string <code>p</code>, where <code>p</code> contains <strong>exactly two</strong> <code>&#39;*&#39;</code> characters.</p>

<p>The <code>&#39;*&#39;</code> in <code>p</code> matches any sequence of zero or more characters.</p>

<p>Return the length of the <strong>shortest</strong> <span data-keyword="substring">substring</span> in <code>s</code> that matches <code>p</code>. If there is no such substring, return -1.</p>
<strong>Note:</strong> The empty substring is considered valid.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abaacbaecebce&quot;, p = &quot;ba*c*ce&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p>The shortest matching substring of <code>p</code> in <code>s</code> is <code>&quot;<u><strong>ba</strong></u>e<u><strong>c</strong></u>eb<u><strong>ce</strong></u>&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;baccbaadbc&quot;, p = &quot;cc*baa*adb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no matching substring in <code>s</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;a&quot;, p = &quot;**&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The empty substring is the shortest matching substring.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;madlogic&quot;, p = &quot;*adlogi*&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The shortest matching substring of <code>p</code> in <code>s</code> is <code>&quot;<strong><u>adlogi</u></strong>&quot;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= p.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
	<li><code>p</code> contains only lowercase English letters and exactly two <code>&#39;*&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-palindrome/description" target="_blank" rel="noopener noreferrer">Shortest Palindrome</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>. You can convert <code>s</code> to a <span data-keyword="palindrome-string">palindrome</span> by adding characters in front of it.</p>

<p>Return <em>the shortest palindrome you can find by performing this transformation</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "aacecaaa"
<strong>Output:</strong> "aaacecaaa"
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "abcd"
<strong>Output:</strong> "dcbabcd"
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code>. Our task is to build the smallest palindrome by adding characters to the beginning of <code>s</code>.</p>
<p>To solve this, we can reframe the problem as finding the longest palindromic substring that starts from the index <code>0</code>. Once we know the length of this substring, we can create the shortest palindrome by appending the reverse of the remaining part of the string to the original string to make <code>s</code> a complete palindrome.</p>
<p>For instance, consider the string <code>s = &quot;aacecaaa&quot;</code>. Here, the longest palindromic prefix is <code>&quot;aacecaa&quot;</code>(starts at index <code>0</code>). The remaining part of the string is just the last <code>&quot;a&quot;</code>. To create the smallest palindrome, we reverse this remaining part and add it to the front of the original string, resulting in <code>&quot;aaacecaaa&quot;</code>, which is a palindrome.</p>
<p>Another example is <code>s = &quot;abcd&quot;</code>, where the longest palindromic prefix is just the first character <code>&quot;a&quot;</code>. The remaining part, <code>&quot;bcd&quot;</code>, is not a palindrome. By reversing <code>&quot;bcd&quot;</code> and adding it to the start, we get <code>&quot;dcbabcd&quot;</code>, which is the smallest palindrome that can be formed from the original string. This way, we can find the shortest palindrome by adding only the necessary characters to the front of the string.</p>
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>As we know, a palindrome reads the same forwards and backwards. Therefore, the challenge is to identify the longest prefix of the original string that can be extended to a full palindrome by only adding characters at the start.</p>
<p>First, we need to find out which part of the string is already a palindrome. So, we check the original string and see how much of it matches the end of its reversed version. This helps us figure out the longest palindromic prefix.</p>
<p>To do this, we look at different prefixes of the original string and compare them to suffixes of the reversed string. If a prefix matches a suffix of the reversed string, itâ€™s part of a palindrome.</p>
<p>Once we find the longest palindromic prefix, we need to reverse the rest of the string (the part not included in the prefix) and add this reversed part to the start of the original string. This gives us the shortest possible palindrome.</p>
<p>For example: Letâ€™s take the string <code>&quot;abcbabcab&quot;</code>. We reverse the string to get <code>&quot;bacbabcba&quot;</code>. By comparing prefixes of <code>&quot;abcbabcab&quot;</code> with suffixes of <code>&quot;bacbabcba&quot;</code>, we find that the longest prefix <code>&quot;abcba&quot;</code> matches with the suffix <code>&quot;abcba&quot;</code> in the reversed string. This is a palindrome.</p>
<p>To form the shortest palindrome, we then need to reverse the remaining part of the original string that doesnâ€™t overlap with this prefix. In our example, the remaining part is <code>&quot;bcab&quot;</code>. Reversing <code>&quot;bcab&quot;</code> gives us <code>&quot;bacb&quot;</code>. Adding this to the start of the original string results in <code>&quot;bacbabcbabcab&quot;</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>length</code> with the length of the string <code>s</code>.</p>
</li>
<li>
<p>Reverse the string <code>s</code> to get <code>reversedString</code>.</p>
</li>
<li>
<p>Iterate through the string from <code>0</code> to <code>length - 1</code>:</p>
<ul>
<li>For each index <code>i</code>, check if the substring <code>s.substring(0, length - i)</code> (i.e., the prefix of <code>s</code> up to <code>length - i</code>) is equal to the substring <code>reversedString.substring(i)</code> (i.e., the suffix of <code>reversedString</code> starting from <code>i</code>).</li>
<li>If they are equal, it means the prefix of <code>s</code> is a palindrome:
<ul>
<li>Return the concatenation of <code>reversedString.substring(0, i)</code> (i.e., the characters in <code>reversedString</code> before <code>i</code>) and the original string <code>s</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no valid prefix is found that satisfies the condition, return an empty string <code>&quot;&quot;</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p><strong>Note:</strong> The C++ code gives MLE because <code>std::string</code> allocates fresh heap memory every time you call <code>substr</code>, which consumes a lot of memory. Repeated allocations quickly exceed the memory limit.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/E4fU8VG9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <span class="math inline">\(s\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The reversal of the string <code>s</code> involves traversing the string once, which has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>In the loop, for each iteration, we check if the substring of length <span class="math inline">\(n - i\)</span> of <code>s</code> matches the substring of length <span class="math inline">\(n - i\)</span> of the reversed string. Each check involves string operations that are linear in the length of the substring being compared. Thus, for each iteration <span class="math inline">\(i\)</span>, the comparison is <span class="math inline">\(O(n - i)\)</span>. Since <span class="math inline">\(i\)</span> ranges from 0 to <span class="math inline">\(n - 1\)</span>, the total time complexity of the palindrome check part can be expressed as the sum of comparisons of decreasing lengths. This sum is roughly <span class="math inline">\(O(n^2)\)</span>.</p>
<p>Combining these operations, the overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Creating the reversed string involves additional space proportional to the length of the input string, i.e., <span class="math inline">\(O(n)\)</span>.</p>
<p>The substring operations in the <code>for</code> loop do not require additional space proportional to the length of the string but do create new string objects temporarily, which is still <span class="math inline">\(O(n)\)</span> space for each substring.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer">Approach 2: Two Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the brute force approach, we observe that we need to identify the longest palindromic prefix of a string. To do this, we can now use a method involving two pointers. This method is a bit more efficient compared to checking every possible substring, which would take longer.</p>
<p>Let's consider an example string: <code>&quot;abcbabcaba&quot;</code>. We use two pointers, <code>left</code> and <code>right</code>. We start by setting <code>left</code> to <code>0</code>. Then, we move the <code>right</code> pointer from the end of the string to the beginning. Each time the characters at <code>left</code> and <code>right</code> match, we increment <code>left</code>.</p>
<p>By following this process, we narrow our search to the substring from the beginning of the string up to <code>left</code>. This substring will always include the longest palindromic prefix.</p>
<ul>
<li>If the entire string were a perfect palindrome, the <code>left</code> pointer would move through the entire length of the string, reaching the end (<code>n</code> times).</li>
<li>If the string isnâ€™t a perfect palindrome, the <code>left</code> pointer will still move forward by the length of the palindromic part at the beginning.</li>
</ul>
<p>Therefore, while the substring <span class="math inline">\([0, \text{left})\)</span> may not always be the tightest fit, it will always contain the longest palindromic prefix.</p>
<p>The best-case scenario for this algorithm is when the entire string is a palindrome. In this case, the <code>left</code> pointer will reach the end of the string quickly. The worst-case scenario is when the string is something like <code>&quot;aababababababa&quot;</code>. Here, <code>left</code> initially becomes <code>12</code>, meaning we need to recheck the substring <span class="math inline">\([0, 12)\)</span>. As we continue, <code>left</code> might decrease to <code>10</code>, and so on. In this worst-case scenario, the substring is reduced by only a few elements at each step, making the total number of steps proportional to the length of the string, or <span class="math inline">\(O(n)\)</span>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>If the string <code>s</code> is empty, return <code>s</code> immediately.</p>
</li>
<li>
<p>Find the longest palindromic prefix:</p>
<ul>
<li>Initialize <code>left</code> to 0.</li>
<li>Iterate <code>right</code> from the end of the string (<code>length - 1</code>) to the start (0):
<ul>
<li>If the character at <code>right</code> matches the character at <code>left</code>:
<ul>
<li>Increment <code>left</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If <code>left</code> equals the length of the string, <code>s</code> is already a palindrome, so return <code>s</code>.</p>
</li>
<li>
<p>Extract the suffix that is not part of the palindromic prefix:</p>
<ul>
<li>Create <code>nonPalindromeSuffix</code> as the substring from <code>left</code> to the end of <code>s</code>.</li>
<li>Reverse <code>nonPalindromeSuffix</code> to create <code>reverseSuffix</code>.</li>
</ul>
</li>
<li>
<p>Form the shortest palindrome:</p>
<ul>
<li>Recursively call <code>shortestPalindrome</code> on the substring from the start to <code>left</code> (i.e., <code>s.substring(0, left)</code>).</li>
<li>Concatenate <code>reverseSuffix</code>, the result of the recursive call, and <code>nonPalindromeSuffix</code>.</li>
</ul>
</li>
<li>
<p>Return the concatenated result as the shortest palindrome.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9HivdNx6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>Each iteration of the <code>shortestPalindrome</code> function operates on a substring of size <code>n</code>. In the worst-case scenario, where the string is not a palindrome and we must continually reduce its size, the function might need to be called up to <code>n/2</code> times.</p>
<p>The time complexity <span class="math inline">\(T(n)\)</span> represents the total time taken by the algorithm. At each step, the algorithm processes a substring and then works with a smaller substring by removing two characters. This can be expressed as <span class="math inline">\(T(n) = T(n-2) + O(n)\)</span>, where <span class="math inline">\(O(n)\)</span> is the time taken to process the substring of size <code>n</code>.</p>
<p>Summing up all the steps, we get:<br />
<span class="math inline">\(T(n) = O(n) + O(n-2) + O(n-4) + \ldots + O(1)\)</span></p>
<p>This sum of terms approximates to <span class="math inline">\(O(n^2)\)</span> because it is an arithmetic series where the number of terms grows linearly with <code>n</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is linear, <span class="math inline">\(O(n)\)</span>, due to the space needed to store the reversed suffix and other temporary variables.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-kmp-knuth-morris-pratt-algorithm">Approach 3: KMP (Knuth-Morris-Pratt) Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The KMP algorithm is used for pattern matching within strings. The KMP algorithm computes prefix functions to identify substrings that match specific patterns. In our case, we use this efficiency to compute the longest palindromic prefix. We construct a combined string of the original string, a special delimiter, and the reversed original string. By applying KMP, we can determine the longest prefix of the original string that matches a suffix of the reversed string.</p>
<p>First, we construct a new string by concatenating the original string, a delimiter (such as <code>&quot;#&quot;</code>), and the reversed original string. This combined string looks like <code>&quot;original#reversed&quot;</code>. The delimiter <code>&quot;#&quot;</code> is crucial because it ensures that we are only comparing the original string with its reversed version, and not inadvertently matching parts of the reversed string with itself.</p>
<p>To proceed, we calculate the prefix function for this combined string. The prefix function or partial match table is an array where each element at index <code>i</code> indicates the length of the longest prefix of the substring ending at <code>i</code> which is also a suffix. This helps us identify the longest segment where the prefix of the original string matches a suffix in the reversed string. The purpose is to identify how much of the original string matches a suffix of the reversed string.</p>
</br>
<p>For example: We construct a combined string using the original string <code>s</code>, a delimiter <code>&quot;#&quot;</code>, and the reversed version of <code>s</code>. This combined string helps us find the longest palindromic prefix by applying the KMP algorithm. For the string <code>&quot;aacecaaa&quot;</code>, the reversed string is <code>&quot;aaacecaa&quot;</code>. Thus, the combined string becomes <code>&quot;aacecaaa#aaacecaa&quot;</code>.</p>
<p>The prefix function helps us determine the length of the longest prefix of the original string that can be matched by a suffix of the reversed string. For the combined string <code>&quot;aacecaaa#aaacecaa&quot;</code>, the prefix function will reveal that the longest palindromic prefix of <code>&quot;aacecaaa&quot;</code> is <code>&quot;aacecaa&quot;</code>.</p>
<p>To create the shortest palindrome, we need to prepend characters to the original string. Specifically, we reverse the portion of the original string that extends beyond the longest palindromic prefix and prepend it. In this case, the part of the original string that extends beyond <code>&quot;aacecaa&quot;</code> is <code>&quot;a&quot;</code>. Reversing <code>&quot;a&quot;</code> gives <code>&quot;a&quot;</code>, so we prepend <code>&quot;a&quot;</code> to <code>&quot;aacecaaa&quot;</code> and the result is <code>&quot;aaacecaaa&quot;</code>.</p>
</br>
</br>
<p>The algorithm to generate the prefix table is described below:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>prefixTable<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&lt;</span> n<span style="color:#000;font-weight:bold">;</span> i<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> length <span style="color:#000;font-weight:bold">=</span> prefixTable<span style="color:#000;font-weight:bold">[</span>i <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span>length <span style="color:#000;font-weight:bold">&gt;</span> 0 <span style="color:#000;font-weight:bold">&amp;&amp;</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">!=</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>length<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        length <span style="color:#000;font-weight:bold">=</span> prefixTable<span style="color:#000;font-weight:bold">[</span>length <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">==</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>length<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        length<span style="color:#000;font-weight:bold">++;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    prefixTable<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> length<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><ul>
<li>Begin by setting <code>prefixTable[0] = 0</code> since there is no proper prefix for the first character.</li>
<li>Next, iterate over <code>i</code> from 1 to <code>n - 1</code>:
<ul>
<li>Set <code>length = prefixTable[i - 1]</code>, which represents the longest prefix length for the substring up to the previous character.</li>
<li>While <code>length &gt; 0</code> and the character at position <code>i</code> doesn't match the character at position <code>length</code>, set <code>length = prefixTable[length - 1]</code>. This step is essential when we encounter a mismatch, and we attempt to match a shorter prefix, which is the value of <code>prefixTable[length - 1]</code>, until either we find a match or <code>length</code> becomes 0.</li>
<li>If <code>s.charAt(i) == s.charAt(length)</code>, we increment <code>length</code> by 1 (extend the matching prefix).</li>
<li>Finally, set <code>prefixTable[i] = length</code>.</li>
</ul>
</li>
</ul>
<p>The lookup table generation is as illustrated below:</p>
<p><img src="../Figures/214/shortest_palindrome_KMP.png" alt="KMP" /></p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p><code>shortestPalindrome</code> function:</p>
<ul>
<li>Create <code>reversedString</code> by reversing the input string <code>s</code>.</li>
<li>Concatenate <code>s</code>, a separator <code>#</code>, and <code>reversedString</code> to form <code>combinedString</code>.</li>
<li>Call <code>buildPrefixTable(combinedString)</code> to compute the prefix table for <code>combinedString</code>.</li>
<li>Extract the length of the longest palindromic prefix from the last value in the prefix table (<code>prefixTable[combinedString.length() - 1]</code>).</li>
<li>Compute <code>suffix</code> by taking the substring of <code>s</code> starting from the length of the longest palindromic prefix.</li>
<li>Reverse <code>suffix</code> and prepend it to <code>s</code> to form and return the shortest palindrome.</li>
</ul>
</li>
<li>
<p><code>buildPrefixTable</code> function:</p>
<ul>
<li>Initialize <code>prefixTable</code> with the same length as the input string <code>s</code> and set <code>length</code> to <code>0</code>.</li>
<li>Iterate over <code>s</code> from index <code>1</code> to the end:
<ul>
<li>While <code>length</code> is greater than <code>0</code> and the current character does not match the character at the current length, update <code>length</code> to the value at <code>prefixTable[length - 1]</code>.</li>
<li>If the current character matches the character at <code>length</code>, increment <code>length</code>.</li>
<li>Set <code>prefixTable[i]</code> to the current <code>length</code>.</li>
</ul>
</li>
<li>Return the <code>prefixTable</code>.</li>
</ul>
</li>
<li>
<p>The result is the shortest palindrome string formed by appending the reversed suffix of <code>s</code> to <code>s</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/HcMZySw4/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Creating the reversed string requires a pass through the original string, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Concatenating <code>s</code>, <code>#</code>, and <code>reversedString</code> takes <span class="math inline">\(O(n)\)</span> time, as concatenating strings of length <span class="math inline">\(n\)</span> is linear in the length of the strings.</p>
<p>Constructing the prefix table involves iterating over the combined string of length <span class="math inline">\(2n + 1\)</span>. The <code>buildPrefixTable</code> method runs in <span class="math inline">\(O(m)\)</span> time, where <span class="math inline">\(m\)</span> is the length of the combined string. In this case, <span class="math inline">\(m = 2n + 1\)</span>, so the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>Extracting the suffix and reversing it are both <span class="math inline">\(O(n)\)</span> operations.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>reversedString</code> and <code>combinedString</code> each use <span class="math inline">\(O(n)\)</span> space.</p>
<p>The <code>prefixTable</code> array has a size of <span class="math inline">\(2n + 1\)</span>, which is <span class="math inline">\(O(n)\)</span>. Other variables used (such as <code>length</code> and indices) use <span class="math inline">\(O(1)\)</span> space.</p>
<p>Combining these, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-rolling-hash-based-algorithm">Approach 4: Rolling Hash Based Algorithm</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The rolling hash approach uses hash functions to efficiently compare different substrings of the original string with those of the reversed string. Hashing helps determine if a substring matches another by comparing hash values rather than individual characters.</p>
<p>Rolling hashes were designed to handle substring matching and comparison problems by allowing incremental updates to hash values as we slide through the string. This reduces the number of comparisons needed by comparing hash values instead of actual substrings.</p>
<p>To start, we compute hash values for all prefixes of the original string and all suffixes of the reversed string using a rolling hash function. The rolling hash function allows us to update the hash values incrementally, which speeds up the computation compared to recalculating hashes from scratch.</p>
<p>Next, we compare the hash values of the prefixes from the original string with the hash values of the suffixes from the reversed string. When the hash values match, it indicates that the corresponding substrings are identical. This helps us find the longest palindromic prefix.</p>
<p>For example: Suppose our string is <code>&quot;aacecaaa&quot;</code>. We calculate hash values for the prefixes of <code>&quot;aacecaaa&quot;</code> and the suffixes of its reverse, <code>&quot;aaacecaa&quot;</code>. The hash comparisons reveal that the longest palindromic prefix is <code>&quot;aacecaaa&quot;</code>. We then reverse the remaining part of the string (<code>&quot;a&quot;</code>), yielding <code>&quot;a&quot;</code>. Prepending this reversed part to the original string gives <code>&quot;aaacecaaa&quot;</code>.</p>
<br/>
<h5 id="hash-calculation-details">Hash Calculation Details:</h5>
<p>To give you a clearer idea of how the hashing is calculated, let's see this:</p>
<p>We initialize two hash values: one for the original string and one for its reversed version. Letâ€™s use base <code>29</code> and a large prime modulus <span class="math inline">\(10^9 + 7\)</span> for hashing. We also initialize a variable to keep track of powers of the base.</p>
<p>We iterate through each character of the original string and compute its hash. Suppose we start with the hash value <code>0</code> and process characters one by one:</p>
<br/>
<p><span class="math display">\[
$$\text{Update hash:}$$

$$\text{hash} = (\text{hash} \times \text{base} + \text{character\_value}) \% \text{mod}$$

$$\text{Suppose } \text{character\_value} \text{ for } 'a' \text{ is } 1.$$

$$\text{hash} = (0 \times 29 + 1) \%  1000000007 = 1$$

<br/>

$$\text{Character } 'a':$$

$$\text{Update hash:}$$

$$\text{hash} = (1 \times 29 + 1) \% 1000000007 = 30$$

<br/>

Continue this for all characters. After processing `"aacecaaa"`, letâ€™s assume the final hash is `23456789` for this substring.

We do a similar hash calculation for the reversed string `"aaacecaa"`. We compute the hash values for each prefix of the reversed string. Letâ€™s assume the final hash of the reversed string is `34567890`.

To compare substrings, we use a rolling hash. As we move the window of comparison along the combined string, we update the hash values based on the new and old characters entering and exiting the window. If the hash of a prefix of the original string matches the hash of a suffix of the reversed string, that prefix is palindromic. Now the comparison shows that the longest prefix of `"aacecaaa"` that matches a suffix of `"aaacecaa"` is `"aacecaa"`. This tells us that `"aacecaa"` is a palindromic segment. Now we identify the remaining part of the original string that extends beyond the palindromic prefix. For `"aacecaaa"`, the remaining part is `"a"`.

So we reverse the remaining part (`"a"`) to get `"a"`, and prepend this reversed part to the original string.

Thus the shortest palindrome is `"aaacecaaa"`.

#### Algorithm

- Initialize hash parameters:
  - Set `hashBase` to 29 and `modValue` to $10^9 + 7$.
  - Initialize `forwardHash` and `reverseHash` to 0.
  - Initialize `powerValue` to 1.
  - Initialize `palindromeEndIndex` to -1.

- Iterate over each character `currentChar` in the string `s`:
  - Update `forwardHash` to include the current character:
    - Compute `forwardHash` as `(forwardHash * hashBase + (currentChar - 'a' + 1)) % modValue`.
  - Update `reverseHash` to include the current character:
    - Compute `reverseHash` as `(reverseHash + (currentChar - 'a' + 1) * powerValue) % modValue`.
  - Update `powerValue` for the next character:
    - Compute `powerValue` as `(powerValue * hashBase) % modValue`.
  - If `forwardHash` matches `reverseHash`, update `palindromeEndIndex` to the current index `i`.

- After the loop, find the suffix that follows the longest palindromic prefix:
  - Extract the suffix from the string `s` starting from `palindromeEndIndex + 1` to the end.
  - Reverse the suffix to prepare for prepending.

- Concatenate the reversed suffix to the original string `s` and return the result:
  - Return `reversedSuffix + s`.

#### Implementation

[code](https://leetcode.com/playground/cdGm2VjV/shared)

#### Complexity Analysis

Let $n$ be the length of the input string.

- Time complexity: $O(n)$

    The algorithm performs a single pass over the input string to compute rolling hashes and determine the longest palindromic prefix, resulting in $O(n)$ time complexity. This pass involves constant-time operations for each character, including hash updates and power calculations. After this, we perform an additional pass to reverse the suffix, which is also $O(n)$. The total time complexity remains $O(n)$.

- Space complexity: $O(n)$

    The space complexity is determined by the space used for the reversed suffix and the additional string manipulations. The space required for the forward and reverse hash values, power value, and palindrome end index is constant and does not scale with input size. However, storing the reversed suffix and the final result string both require $O(n)$ space. Thus, the space complexity is $O(n)$.

---

### Approach 5: Manacher's Algorithm

#### Intuition

> Note: This algorithm goes beyond what's typically expected in coding interviews. It's more for those who are curious and eager to explore advanced algorithms, simply out of personal interest or a desire to deepen their understanding of data structures and algorithms. If you're someone who loves learning new concepts beyond interview prep, this approach might be for you! Sometimes this is the only algorithm that can give you an $O(n)$ runtime.

</br>

Developed to address the problem of finding palindromic substrings efficiently, Manacherâ€™s algorithm preprocesses the string to handle both even and odd-length palindromes uniformly. By inserting special characters between each character of the original string, it computes the radius of the longest palindromic substring centered at each position.

To handle palindromes of both even and odd lengths uniformly, the algorithm transforms the original string by inserting special characters (e.g., `"#"`) between every character and at the boundaries. This way, every palindrome can be treated as if itâ€™s surrounded by characters, making it easier to apply the same expansion logic for all cases.

For example, the string `"aacecaaa"` is transformed into `"^#a#a#c#e#c#a#a#a#$"`. Here, `^` and `$` are boundary markers that help avoid out-of-bound errors. `#` helps to treat the string uniformly, making every palindrome appear with a single center.

Manacherâ€™s algorithm maintains an array `P` where `P[i]` denotes the radius of the longest palindromic substring centered at the position `i` in the transformed string.

</br>

We divide Manacher's algorithm into three steps to achieve linear time complexity:

1. Center and Right Boundary: We track the center `C` and right boundary `R` of the rightmost palindrome found so far. For each position `i`, we check if it falls within the current right boundary. If it does, we use previously computed information to estimate the length of the palindrome centered at `i`.

2. Mirror Property: If a position `i` is within the right boundary of a known palindrome, we can infer the length of the palindrome centered at `i` from its mirrored position relative to the current center `C`. This way we reduce the need for direct expansion by leveraging previously computed palindromes to quickly estimate lengths.

3. Expand Around Center: For positions where the estimated palindrome length based on the mirror property is not accurate, we perform direct expansion to find the exact length of the palindrome centered at `i`. We update the center and right boundary if the newly found palindrome extends beyond the current right boundary.

</br>

After computing the array `P`, we can determine the longest palindromic prefix of the original string. The longest palindromic substring in the transformed string that corresponds to a prefix of the original string gives us the longest palindromic prefix.

To form the shortest palindrome, identify the part of the original string that does not contribute to this longest palindromic prefix. Reverse this non-matching segment and prepend it to the original string.

With the string `"aacecaaa"`, after preprocessing to `"#a#a#c#e#c#a#a#a#"`, Manacherâ€™s algorithm identifies `"aacecaaa"` as the longest palindromic prefix. Reversing the remaining part (`"a"`) and prepending it results in `"aaacecaaa"`.

We highly recommend solving the [longest palindromic substring problem using Manacherâ€™s algorithm](https://leetcode.com/problems/longest-palindromic-substring/editorial/). It is extremely efficient and ideal for solving palindrome-related problems.

This algorithm is complex, so review various sources to gain a better understanding. It's normal if you donâ€™t grasp it right away, so give yourself time.

#### Algorithm

- `shortestPalindrome` function:
  - If the input string `s` is null or empty, return `s` immediately.
  - Preprocess the string `s` by calling `preprocessString(s)` to handle edge cases and simplify palindrome detection.
    - `preprocessString` function:
      - Initialize a string with a starting character `^`.
      - Append a `#` followed by each character in `s` to string.
      - Append a trailing `#` and a dollar sign to complete the modified string.
      - Return the modified string which includes special boundary characters.
  - Initialize an integer array `palindromeRadiusArray` to store the radius of the palindrome centered at each character in the modified string.
  - Initialize `center` and `rightBoundary` to track the center and right boundary of the current longest palindrome found.
  - Initialize `maxPalindromeLength` to track the length of the longest palindrome that touches the start of the string.

  - Iterate through each character `i` in the modified string (excluding the boundary characters):
    - Calculate the `mirrorIndex` as `2 * center - i` to utilize previously computed palindromes.
    - If `rightBoundary` is greater than `i`, update `palindromeRadiusArray[i]` to the minimum of the remaining length to the `rightBoundary` or the radius of the palindrome at `mirrorIndex`.
    - Expand around the center `i` while the characters match and update `palindromeRadiusArray[i]` accordingly.
    - If the expanded palindrome extends beyond `rightBoundary`, update `center` and `rightBoundary` to the new values.
    - If the palindrome touches the start of the string (`i - palindromeRadiusArray[i] == 1`), update `maxPalindromeLength` with the maximum length found.

  - Extract the suffix of the original string starting from `maxPalindromeLength` and reverse it.
  - Concatenate the reversed suffix with the original string and return the result.

#### Implementation

[code](https://leetcode.com/playground/ZT8yYNFz/shared)

#### Complexity Analysis

Let $n$ be the length of the input string.

- Time complexity: $O(n)$

    The `preprocessString` method adds boundaries and separators to the input string. This takes linear time, $O(n)$, where $n$ is the length of the input string.

    The core algorithm iterates through the characters of the modified string once. The expansion step and the updates of the center and right boundary each take constant time in the average case for each character. Thus, this step has a time complexity of $O(m)$, where $m$ is the length of the modified string.

    Since the length of the modified string is $2n + 1 \, (\text{for separators}) + 2 \, (\text{for boundaries}) = 2n + 3$ , the time complexity of Manacher's algorithm is $O(n)$.

    Constructing the result involves reversing the suffix of the original string and concatenating it with the original string, both of which take linear time, $O(n)$.

    Combining these steps, the total time complexity is $O(n)$.

- Space complexity: $O(n)$

    The space used to store the modified string is proportional to its length, which is $2n + 3$. Therefore, the space complexity for storing this string is $O(n)$.

    The `palindromeRadiusArray` is used to store the radius of palindromes for each character in the modified string, which is $O(m)$. Since $m$ is $2n + 3$, the space complexity for this array is $O(n)$.

    The additional space used for temporary variables, and other operations is constant, $O(1)$.

    Combining these factors, the total space complexity is $O(n)$.

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/string-matching-in-an-array/description" target="_blank" rel="noopener noreferrer">String Matching in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of string <code>words</code>, return all strings in<em> </em><code>words</code><em> </em>that are a <span data-keyword="substring-nonempty">substring</span> of another word. You can return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;]
<strong>Output:</strong> [&quot;as&quot;,&quot;hero&quot;]
<strong>Explanation:</strong> &quot;as&quot; is substring of &quot;mass&quot; and &quot;hero&quot; is substring of &quot;superhero&quot;.
[&quot;hero&quot;,&quot;as&quot;] is also a valid answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;]
<strong>Output:</strong> [&quot;et&quot;,&quot;code&quot;]
<strong>Explanation:</strong> &quot;et&quot;, &quot;code&quot; are substring of &quot;leetcode&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;]
<strong>Output:</strong> []
<strong>Explanation:</strong> No string of words is substring of another string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
	<li><code>words[i]</code> contains only lowercase English letters.</li>
	<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of strings called <code>words</code>. The task is to find and return all the strings from <code>words</code> that appear as substrings within any other string in the same array. To put it simply, we are looking for any string in <code>words</code> that can be found within a different string in <code>words</code>.</p>
<p>Let's consider an example, where <code>words = [&quot;this&quot;, &quot;is&quot;, &quot;the&quot;, &quot;weather&quot;, &quot;fish&quot;]</code>.</p>
<ul>
<li><code>&quot;this&quot;</code> does not appear as a substring of any other string.</li>
<li><code>&quot;is&quot;</code> is a substring of <code>&quot;this&quot;</code> and <code>&quot;fish&quot;</code>.</li>
<li><code>&quot;the&quot;</code> is a substring of <code>&quot;weather&quot;</code>.</li>
<li><code>&quot;weather&quot;</code> is not a substring of any other word.</li>
<li><code>&quot;fish&quot;</code> is not a substring of any other string.</li>
</ul>
<p>Therefore, the answer to this example is the array: <code>[&quot;is&quot;, &quot;the&quot;]</code>.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The intuition for this approach is pretty straightforward: We examine all strings one by one and find if each of them appears as a substring within any other string in the list.</p>
<p>A string <code>sub</code> is considered a substring of another string <code>main</code>, if there exists a starting index <code>startIndex</code> such that for every position <code>subIndex</code> from <code>0</code> to <code>sub.size() - 1</code>, the characters match: <code>main[startIndex + subIndex] == sub[subIndex]</code>. In simpler terms, <code>sub</code> must fit continuously within <code>main</code> without any gaps.  To check if <code>sub</code> is a substring of <code>main</code>, we iterate over all possible starting indices in <code>main</code> and verify if <code>sub</code> can fit starting from each of those indices.</p>
<p>In Python, things become more simple thanks to the built-in operation <code>sub in main</code>, which evaluates to <code>True</code> if <code>sub</code> is a substring of <code>main</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a function <code>isSubstringOf(sub, main)</code> that returns <code>true</code> if the string <code>sub</code> is a substring of the string <code>main</code> and <code>false</code> otherwise. If the language you are using offers a built-in function for this operation, you can ignore this step.
<ul>
<li>Loop over all possible starting indices with <code>startIndex</code> from <code>0</code> to <code>main.size() - 1</code>:
<ul>
<li>Initialize a flag <code>subFits</code> to <code>true</code>.</li>
<li>Loop over all characters in <code>sub</code> with <code>subIndex</code> from <code>0</code> to <code>sub.size() - 1</code>:
<ul>
<li>If <code>startIndex + subIndex &gt;= main.size()</code> or <code>main[startIndex + subIndex] != sub[subIndex]</code>, set <code>subFits</code> to <code>false</code> and break; we have reached the end of <code>main</code> or the characters don't match, so don't search further.</li>
</ul>
</li>
<li>If <code>subFits</code>, a valid starting index is found; return <code>true</code>.</li>
</ul>
</li>
<li>If the loop ends and <code>sub</code> does not fit for any <code>startIndex</code>, return <code>false</code>.</li>
</ul>
</li>
<li>In the main <code>stringMatching</code> function:
<ul>
<li>Initialize an empty array of strings, named <code>matchingWords</code>.
<ul>
<li>Iterate over the <code>words</code> with <code>currentWordIndex</code> from <code>0</code> to <code>words.size() - 1</code>:
<ul>
<li>For every other word in <code>words</code>, i.e., for <code>otherWordIndex</code> from <code>0</code> to <code>words.size() - 1</code>:</li>
<li>If <code>currentWordIndex == otherWordIndex</code>, continue; skip the same word.</li>
<li>If <code>isSubstringOf(words[currentWordIndex], words[otherWordIndex])</code>, push <code>words[currentWordIndex]</code> to the <code>matchingWords</code> and break.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>matchingWords</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ejT2MmV4/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>words</code> array and <span class="math inline">\(m\)</span> be the length of the longest string in <code>words</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m^2 \times n^2)\)</span></p>
<p>The <code>isSubstringOf</code> function iterates through all possible starting indices of the <code>main</code> string to check whether each index is a valid starting point for the <code>sub</code> string. This is done using a nested loop that examines each character in the <code>sub</code> string. Therefore, the <code>isSubstringOf</code> function has a time complexity of <span class="math inline">\(O(m^2)\)</span>.</p>
<p>In the <code>stringMatching</code> function, we call <code>isSubstringOf</code> for every pair of strings within the <code>words</code> array. This results in <span class="math inline">\(O(n^2)\)</span> calls to <code>isSubstringOf</code>. Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m^2 \times n^2)\)</span>.</p>
<p>The Python implementation, which uses the optimized built-in operation for substring checks, has a time complexity of <span class="math inline">\(O(m \times n^2)\)</span>, as the built-in operation performs more efficiently than the naive approach.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We create a string array, <code>matchingWords</code>, to store the strings that are identified as substrings of other words. In the worst case, this array may need to store all the strings from the <code>words</code> array, meaning it could grow to a size of <span class="math inline">\(O(m \times n)\)</span>. Beyond this, the algorithm only uses a fixed number of variables (<code>subFits</code>, <code>currentWordIndex</code>), which contribute <span class="math inline">\(O(1)\)</span> auxiliary space. Therefore, the <em>auxiliary space complexity</em>â€”the extra space used during execution excluding input and outputâ€”is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-kmp-algorithm">Approach 2: KMP Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The inefficiency of the naive algorithm lies in how it handles mismatches. When a mismatch occurs, the algorithm shifts the starting index in the <code>main</code> string by one position and restarts the comparison from the first character of <code>sub</code>, even though parts of <code>sub</code> may have already matched. Let's take a look at a worst-case example for the brute-force algorithm:</p>
<p>!?!../Documents/1408/1408_brute_force_fix.json:784,384!?!</p>
<p>The algorithm redundantly rechecks the prefix <code>&quot;aaa&quot;</code> for different starting positions in <code>main</code>. Instead of restarting the comparison every time, we can remember that the prefix <code>&quot;aaa&quot;</code> is already a match. For the next attempt, we shift <code>sub</code> and continue matching from where we left off.</p>
<p>To achieve this, we use the <em>LPS (Longest Prefix Suffix) table</em>.<br />
The LPS table helps us skip unnecessary comparisons when a mismatch occurs. It stores, for each prefix of sub, the length of the longest proper prefix that is also a suffix.</p>
<blockquote>
<p>Proper prefix: A prefix of a string that is not the entire string itself.</p>
</blockquote>
<p>For example, for <code>sub = &quot;ababaca&quot;</code>, the LPS table is:</p>
<p><img src="../Figures/1408/1408_lps_fix.png" alt="Longest Prefix Suffix Table" /></p>
<p>When a mismatch occurs at position <code>subIndex</code> in <code>sub</code>, the LPS value at <code>subIndex - 1</code> tells us how far to shift <code>sub</code>. This avoids rechecking characters already matched, improving efficiency.</p>
<p>!?!../Documents/1408/1408_kmp_fix.json:784,384!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="computelpsarraysub-function"><code>computeLPSArray(sub)</code> function</h5>
<ul>
<li>Initialize <code>lps</code> as an array of size <code>sub.size()</code> filled with <code>0</code>.</li>
<li>Initialize <code>currentIndex</code> as <code>1</code> and <code>len</code> as <code>0</code> to track the length of the current longest prefix.</li>
<li>Loop over the string <code>sub</code>:
<ul>
<li>If the current character continues the prefix-suffix match, i.e., <code>sub[currentIndex] == sub[len]</code>, extend the longest prefix.
<ul>
<li>Increment <code>len</code> by <code>1</code>.</li>
<li>Set <code>lps[currentIndex] = len</code>, to store the length of the matching prefix up to the current character.</li>
<li>Increment <code>currentIndex</code> by <code>1</code>, to move on to the next character.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>If there's some prefix-suffix match already, try reducing it using the previously computed LPS values, i.e., <code>len &gt; 0</code>.
<ul>
<li>Set <code>len = lps[len - 1]</code>.</li>
</ul>
</li>
<li>Otherwise, no prefix-suffix match exists, so start from the next character.
<ul>
<li>Increment <code>currentIndex</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>lps</code> array.</li>
</ul>
<h5 id="issubstringofsub-main-lps-function"><code>isSubstringOf(sub, main, lps)</code> function</h5>
<ul>
<li>Initialize <code>mainIndex = 0</code> and <code>subIndex = 0</code> to iterate through <code>main</code> and <code>sub</code>.</li>
<li>Loop while <code>mainIndex &lt; main.size()</code>:
<ul>
<li>If <code>main[mainIndex] == sub[subIndex]</code>, characters match, so increment both <code>mainIndex</code> and <code>subIndex</code>:
<ul>
<li>If <code>subIndex == sub.size()</code>, return <code>true</code> (match found).</li>
</ul>
</li>
<li>If there is a mismatch, use the lps values to jump to the next best match of the <code>sub</code> string:
<ul>
<li>If <code>subIndex &gt; 0</code>, set <code>subIndex = lps[subIndex - 1]</code>.</li>
<li>Otherwise, increment <code>mainIndex</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If the loop completes and no match is found, return <code>false</code>.</li>
</ul>
<h5 id="main-wordsmatchingwords-function">Main <code>wordsMatching(words)</code> function</h5>
<ul>
<li>Initialize an empty array <code>matchingWords</code>.</li>
<li>Iterate over <code>words</code> with <code>currentWordIndex</code> from <code>0</code> to <code>words.size() - 1</code>:
<ul>
<li>Compute the LPS array for the current word, <code>lps = computeLPSArray(words[currentWordIndex])</code>.</li>
<li>For every other word in words, i.e., for <code>otherWordIndex</code> from <code>0</code> to <code>words.size() - 1</code>:
<ul>
<li>If <code>currentWordIndex == otherWordIndex</code>, continue; skip comparing the same word.</li>
<li>If <code>isSubstringOf(words[currentWordIndex], words[otherWordIndex])</code>, add <code>words[currentWordIndex]</code> to <code>matchingWords</code> and break.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>matchingWords</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YRKX7hnF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>words</code> array and <span class="math inline">\(m\)</span> be the length of the longest string in <code>words</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n^2)\)</span></p>
<p>We compute the LPS array in a loop that iterates through the <code>sub</code> string. The loop runs from <code>1</code> to <code>sub.size() - 1</code> and processes a constant amount of work on each iteration (comparing characters and updating the LPS array), so it has a time complexity of <span class="math inline">\(O(m)\)</span>.</p>
<p>Once the LPS array is computed, we use it in the main loop to compare each word in <code>words</code> with every other word. For each pair <code>(currentWordIndex, otherWordIndex)</code> where <code>currentWordIndex != otherWordIndex</code>, we check if <code>words[currentWordIndex]</code> is a substring of <code>words[otherWordIndex]</code> using the LPS-based KMP algorithm. Each comparison takes <span class="math inline">\(O(m)\)</span> time (due to LPS array lookup and comparison). There are <span class="math inline">\(n^2\)</span> such comparisons since we check all pairs of words.</p>
<p>Therefore, the total time complexity of the algorithm is <span class="math inline">\(O(m \times n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>Like in the previous approach, we create a string array, <code>matchingWords</code>, to store the strings that are identified as substrings of other words. In the worst case, this array may need to store all the strings from the <code>words</code> array, meaning it could grow to a size of <span class="math inline">\(O(m \times n)\)</span>. The LPS array of <code>sub</code> has a length equal to <code>sub.size()</code>, so it adds a factor of <span class="math inline">\(m\)</span> to the total space complexity, which is however dominated by the <code>matchingWords</code> array and remains <span class="math inline">\(O(m \times n)\)</span>. Once again, excluding the input and the output, we get the auxiliary space complexity of the algorithm, which is equal to <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-suffix-trie">Approach 3: Suffix Trie</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this approach, we will use a Trie to store all suffixes of any word in <code>words</code> and then determine for each word if it appears as part of any suffix in the Trie.</p>
<blockquote>
<p>A Trie is a tree-like data structure used to store substrings. If you are new to Tries, you might want to check out the <a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card ðŸ”—</a>. This resource provides an in-depth look at the trie data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>Each node (<code>TrieNode</code>) represents a substring. A <code>TrieNode</code> has:</p>
<ul>
<li>A <code>frequency</code> that keeps track of how many times the substring, represented by the path from the root to that node, has appeared as a suffix.</li>
<li>A map to store its child nodes, representing the next characters of the substring.</li>
</ul>
<p>After defining our <code>TrieNode</code> class, we go over every <code>word</code> in <code>words</code> and insert each suffix of it into the Trie. To insert a string <code>word</code> into the Trie, we start from the root (which represents an empty string <code>&quot;&quot;</code>) and check if a child node exists for the first character of the <code>word</code>. If yes, then we move to that child node, incrementing its frequency and we repeat the same for the second character of the <code>word</code>. Otherwise, we create a new <code>TrieNode</code> and add it to the children of the current node. We repeat this process, until we reach the end of the <code>word</code>, meaning that we have efficiently inserted it into the Trie.</p>
<p>After inserting all suffixes of each word, the Trie essentially stores all possible substrings as paths from the root to a leaf node. The frequency count at each node reflects how many words in the array share that particular substring.</p>
<p>Now, to determine whether a word appears as a substring within the <code>words</code> array, we iterate over all characters of the word, traversing the Trie. When we reach the end of the word, we check the frequency of the node we are currently at. If it is greater than 1, this means that the word is present as a substring of another word as well, not just itself, so we count it to the result.</p>
<h4 id="algorithm-2">Algorithm</h4>
<h5 id="trienode-class"><code>TrieNode</code> class.</h5>
<p>Each <code>TrieNode</code> has:</p>
<ul>
<li>A counter, <code>frequency</code>, to track the number of times the corresponding string occurs within <code>words</code>.</li>
<li>A map of characters to <code>TrieNodes</code>, named <code>childNodes</code>.</li>
</ul>
<h5 id="insertwordroot-word-function"><code>insertWord(root, word)</code> function</h5>
<ul>
<li>Initialize <code>currentNode</code> to <code>root</code>.</li>
<li>For every character, <code>c</code> of <code>word</code>:
<ul>
<li>If <code>c</code> is a child node of <code>currentNode</code>:
<ul>
<li>Move <code>currentNode</code> to the child node corresponding to <code>c</code>.</li>
<li>Increment the frequency of <code>currentNode</code>.</li>
</ul>
</li>
<li>Otherwise,
<ul>
<li>Create a new <code>TrieNode</code>, initialize its frequency to <code>1</code> and set it as the child of the <code>currentNode</code> for character <code>c</code>.</li>
<li>Move <code>currentNode</code> to new node.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="issubstringroot-word-function"><code>isSubstring(root, word)</code> function</h5>
<ul>
<li>Initialize <code>currentNode</code> to <code>root</code>.</li>
<li>For every character, <code>c</code> of <code>word</code>:<br />
-   Move <code>currentNode</code> to the child node corresponding to <code>c</code>.</li>
<li>Check the frequency of the <code>currentNode</code>:
<ul>
<li>If it is greater than <code>1</code>, return <code>true</code>.</li>
<li>Otherwise, return <code>false</code>.</li>
</ul>
</li>
</ul>
<h5 id="main-stringmatching-function">Main <code>stringMatching</code> function:</h5>
<ul>
<li>Initialize an empty array of strings, named <code>matchingWords</code>.</li>
<li>Initialize the <code>root</code> of the Trie.</li>
<li>For every <code>word</code> in <code>words</code>:
<ul>
<li>Loop with <code>startIndex</code> from <code>0</code> to <code>word.size() - 1</code>:
<ul>
<li>Insert the suffix <code>word[startIndex:]</code> to the Trie.</li>
</ul>
</li>
</ul>
</li>
<li>For every <code>word</code> in <code>words</code>:
<ul>
<li>If <code>isSubstring(root, word)</code>, insert <code>word</code> into <code>matchingWords</code>.</li>
</ul>
</li>
<li>Return <code>matchingWords</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YnLcbr3D/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>words</code> array and <span class="math inline">\(m\)</span> be the length of the longest string in <code>words</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m^2 \times n)\)</span></p>
<p>The <code>insertWord(root, word)</code> and the <code>isSubstring(word)</code> functions involve a loop over the characters of <code>word</code>, so they have a time complexity of <span class="math inline">\(O(m)\)</span>. We insert every suffix of every string of <code>words</code> into the Trie, resulting in <span class="math inline">\(O(n \times m)\)</span> insertions. Therefore, the overall time complexity is <span class="math inline">\(O(m \times n \times m) = O(m^2 \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m^2 \times n)\)</span></p>
<p>In the worst case, all suffixes of all words are unique and must be stored separately in the Trie. Each word has <span class="math inline">\(O(m)\)</span> suffixes, each of which requires <span class="math inline">\(O(m)\)</span> <code>TrieNodes</code>. Therefore, the Trie can grow up to <span class="math inline">\(O(m^2 \times n)\)</span> in size. The <code>matchingWords</code> array has a size of <span class="math inline">\(O(m \times n)\)</span> and hence, it does not increase the total space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/string-transformation/description" target="_blank" rel="noopener noreferrer">String Transformation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code> of equal length <code>n</code>. You can perform the following operation on the string <code>s</code>:</p>

<ul>
	<li>Remove a <strong>suffix</strong> of <code>s</code> of length <code>l</code> where <code>0 &lt; l &lt; n</code> and append it at the start of <code>s</code>.<br />
	For example, let <code>s = &#39;abcd&#39;</code> then in one operation you can remove the suffix <code>&#39;cd&#39;</code> and append it in front of <code>s</code> making <code>s = &#39;cdab&#39;</code>.</li>
</ul>

<p>You are also given an integer <code>k</code>. Return <em>the number of ways in which </em><code>s</code> <em>can be transformed into </em><code>t</code><em> in <strong>exactly</strong> </em><code>k</code><em> operations.</em></p>

<p>Since the answer can be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;cdab&quot;, k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
First way:
In first operation, choose suffix from index = 3, so resulting s = &quot;dabc&quot;.
In second operation, choose suffix from index = 3, so resulting s = &quot;cdab&quot;.

Second way:
In first operation, choose suffix from index = 1, so resulting s = &quot;bcda&quot;.
In second operation, choose suffix from index = 1, so resulting s = &quot;cdab&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ababab&quot;, t = &quot;ababab&quot;, k = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
First way:
Choose suffix from index = 2, so resulting s = &quot;ababab&quot;.

Second way:
Choose suffix from index = 4, so resulting s = &quot;ababab&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>
	<li><code>s.length == t.length</code></li>
	<li><code>s</code> and <code>t</code> consist of only lowercase English alphabets.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/substring-matching-pattern/description" target="_blank" rel="noopener noreferrer">Substring Matching Pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a pattern string <code>p</code>, where <code>p</code> contains <strong>exactly one</strong> <code>&#39;*&#39;</code> character.</p>

<p>The <code>&#39;*&#39;</code> in <code>p</code> can be replaced with any sequence of zero or more characters.</p>

<p>Return <code>true</code> if <code>p</code> can be made a <span data-keyword="substring-nonempty">substring</span> of <code>s</code>, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;leetcode&quot;, p = &quot;ee*e&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>By replacing the <code>&#39;*&#39;</code> with <code>&quot;tcod&quot;</code>, the substring <code>&quot;eetcode&quot;</code> matches the pattern.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;car&quot;, p = &quot;c*v&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no substring matching the pattern.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;luck&quot;, p = &quot;u*&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The substrings <code>&quot;u&quot;</code>, <code>&quot;uc&quot;</code>, and <code>&quot;uck&quot;</code> match the pattern.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 50</code></li>
	<li><code>1 &lt;= p.length &lt;= 50 </code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
	<li><code>p</code> contains only lowercase English letters and exactly one <code>&#39;*&#39;</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subtree-of-another-tree/description" target="_blank" rel="noopener noreferrer">Subtree of Another Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">string matching</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of<code> subRoot</code> and <code>false</code> otherwise.</p>

<p>A subtree of a binary tree <code>tree</code> is a tree that consists of a node in <code>tree</code> and all of this node&#39;s descendants. The tree <code>tree</code> could also be considered as a subtree of itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" style="width: 532px; height: 400px;" />
<pre>
<strong>Input:</strong> root = [3,4,5,1,2], subRoot = [4,1,2]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg" style="width: 502px; height: 458px;" />
<pre>
<strong>Input:</strong> root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the <code>root</code> tree is in the range <code>[1, 2000]</code>.</li>
	<li>The number of nodes in the <code>subRoot</code> tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= root.val &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= subRoot.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-scores-of-built-strings/description" target="_blank" rel="noopener noreferrer">Sum of Scores of Built Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">suffix array</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are <strong>building</strong> a string <code>s</code> of length <code>n</code> <strong>one</strong> character at a time, <strong>prepending</strong> each new character to the <strong>front</strong> of the string. The strings are labeled from <code>1</code> to <code>n</code>, where the string with length <code>i</code> is labeled <code>s<sub>i</sub></code>.</p>

<ul>
	<li>For example, for <code>s = &quot;abaca&quot;</code>, <code>s<sub>1</sub> == &quot;a&quot;</code>, <code>s<sub>2</sub> == &quot;ca&quot;</code>, <code>s<sub>3</sub> == &quot;aca&quot;</code>, etc.</li>
</ul>

<p>The <strong>score</strong> of <code>s<sub>i</sub></code> is the length of the <strong>longest common prefix</strong> between <code>s<sub>i</sub></code> and <code>s<sub>n</sub></code> (Note that <code>s == s<sub>n</sub></code>).</p>

<p>Given the final string <code>s</code>, return<em> the <strong>sum</strong> of the <strong>score</strong> of every </em><code>s<sub>i</sub></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;babab&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong>
For s<sub>1</sub> == &quot;b&quot;, the longest common prefix is &quot;b&quot; which has a score of 1.
For s<sub>2</sub> == &quot;ab&quot;, there is no common prefix so the score is 0.
For s<sub>3</sub> == &quot;bab&quot;, the longest common prefix is &quot;bab&quot; which has a score of 3.
For s<sub>4</sub> == &quot;abab&quot;, there is no common prefix so the score is 0.
For s<sub>5</sub> == &quot;babab&quot;, the longest common prefix is &quot;babab&quot; which has a score of 5.
The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;azbazbzaz&quot;
<strong>Output:</strong> 14
<strong>Explanation:</strong> 
For s<sub>2</sub> == &quot;az&quot;, the longest common prefix is &quot;az&quot; which has a score of 2.
For s<sub>6</sub> == &quot;azbzaz&quot;, the longest common prefix is &quot;azb&quot; which has a score of 3.
For s<sub>9</sub> == &quot;azbazbzaz&quot;, the longest common prefix is &quot;azbazbzaz&quot; which has a score of 9.
For all other s<sub>i</sub>, the score is 0.
The sum of the scores is 2 + 3 + 9 = 14, so we return 14.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>