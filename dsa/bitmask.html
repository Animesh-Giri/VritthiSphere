<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bitmask - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>bitmask</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">67</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Alice and GCD</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-1" class="toc-link">A minimum sorting</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-2" class="toc-link">AND Subsequence</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-3" class="toc-link">A XOR challenge</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-4" class="toc-link">Beautiful Arrangement</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Can I Win</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Closest Subsequence Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Compatibility Queries</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-8" class="toc-link">Concatenated Divisibility</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Costliest Data Plan</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-10" class="toc-link">Count Paths That Can Form a Palindrome in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Count Subtrees With Max Distance Between Cities</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Count the Number of Square-Free Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Distribute Repeating Integers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Even sum in a matrix</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-15" class="toc-link">Fair Distribution of Cookies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Find Minimum Time to Finish All Jobs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Find Sum of Array Product of Magical Sequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Find the Minimum Cost Array Permutation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Find the Shortest Superstring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Hamming Sort</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-21" class="toc-link">Help the King Maximize Profit</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-22" class="toc-link">Longest Palindromic Path in Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Matchsticks to Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Maximize Grid Happiness</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Maximize Score After N Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Maximize the Number of Partitions After Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Maximum AND Sum of Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Maximum Compatibility Score Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Maximum Good Subtree Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Maximum Number of Groups Getting Fresh Donuts</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Maximum Number of Moves to Kill All Pawns</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Maximum Product of the Length of Two Palindromic Subsequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Maximum Profit from Valid Topological Order in DAG</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Maximum Score Words Formed by Letters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Maximum Students Taking Exam</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Minimum Cost to Connect Two Groups of Points</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Minimum Incompatibility</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Minimum Increments for Target Multiples in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Minimum Number of Work Sessions to Finish the Tasks</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Minimum Time to Break Locks I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Minimum Time to Transport All Individuals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Minimum XOR Sum of Two Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Number of Squareful Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Number of Ways to Wear Different Hats to Each Other</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Optimal Way</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-46" class="toc-link">Palindrome lover</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-47" class="toc-link">Parallel Courses II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Parity-Binary Sort</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-49" class="toc-link">Partition Array Into Two Arrays to Minimize Sum Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Partition to K Equal Sum Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Prefix GCD Maximization</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-52" class="toc-link">Prefix XOR Sum</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-53" class="toc-link">Reduce the Array</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-54" class="toc-link">Select Cells in Grid With Maximum Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Shift String</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-56" class="toc-link">Shopping Offers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Shortest Path Visiting All Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Smallest Sufficient Team</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Special Permutations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Split Array With Same Average</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Split Permutation</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-62" class="toc-link">Splitting Candies</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-63" class="toc-link">Stickers to Spell Word</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">The Number of Good Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Tree Trips</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-66" class="toc-link">XOR of numbers</a> <span class="toc-platform">HackerEarth</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/alice-and-gcd-3-3d854e90/" target="_blank" rel="noopener noreferrer">Alice and GCD</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">dynamicprogrammingandbitmasking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice has been given an array <span class="mathjax-latex">\(A\)</span> of <span class="mathjax-latex">\(N\)</span> integers where <span class="mathjax-latex">\(N\)</span> is even.</p>

<p>In each round Alice can choose any two integers from the array and delete them.</p>

<p>Points Alice will get in each round will be the <span class="mathjax-latex">\(gcd(num1,num2)*round\)</span></p>

<p><span class="mathjax-latex">\(num1\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(num2\)</span>&nbsp;are the integers which Alice has chosen and turn is the current round. Alice total score is the sum of scores that Alice has obtained in each round.</p>

<p>Determine the maximum total Score which Alice can get.</p>

<p><strong>Constraints:</strong></p>

<p><span class="mathjax-latex">\(1 \leq N \leq 20 \\ 1 \leq A[i] \leq 10^9 \\\)</span></p>

<p><strong>Input Format:</strong></p>

<p>The first line contains an integer <span class="mathjax-latex">\(N\)</span> which denotes the length of array <span class="mathjax-latex">\(A\)</span>.</p>

<p>The second line contains&nbsp;<span class="mathjax-latex">\(N\)</span> space separated positive integers, denoting elements of array <span class="mathjax-latex">\(A\)</span></p>

<p><strong>Output Format:</strong><br>
An integer denoting the maximum total score which Alice can achieve</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Round1 : select num1 = 4, num2=5 . gcd(num1,num2)*round = 1*1=1.<br>
Round2 : select num1 = 3, num2=9 . gcd(num1,num2)*round = 3*2=6.<br>
Maximum total score = 6+1 = 7</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/minimum-sorting-5b67382a/" target="_blank" rel="noopener noreferrer">A minimum sorting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">dynamicprogrammingandbitmasking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays <span class="mathjax-latex">\(A\)</span> and <span class="mathjax-latex">\(B\)</span> of size <span class="mathjax-latex">\(N\)</span>. Your task is to sort array A (non-decreasing) by using the following operation for the minimum number of times.</p>

<p>Operation steps are: </p>

<ol>
	<li>Select any index <span class="mathjax-latex">\(i\)</span> such that <span class="mathjax-latex">\(1\le i&lt;N\)</span>.</li>
	<li>Swap <span class="mathjax-latex">\(A_i\)</span> and <span class="mathjax-latex">\(B_{i+1}\)</span>.</li>
	<li>Swap <span class="mathjax-latex">\(A_{i+1}\)</span> and <span class="mathjax-latex">\(B_i\)</span>.</li>
</ol>

<p>If there is a way to sort array <span class="mathjax-latex">\(A\)</span> using the above operation, then find the minimum number of operations that must be performed. If it is impossible to sort the array, then print <strong>-1</strong>.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains an integer <span class="mathjax-latex">\(T\)</span> denoting the number of test cases. For each test case:</li>
	<li>The first line of each test case contains an integer <span class="mathjax-latex">\(N\)</span> denoting the number of elements in arrays <span class="mathjax-latex">\(A\)</span> and <span class="mathjax-latex">\(B\)</span>.</li>
	<li>The second line of each test case contains <span class="mathjax-latex">\(N\)</span> space-separated integers of array <span class="mathjax-latex">\(A\)</span>.</li>
	<li>The third line of each test case contains <span class="mathjax-latex">\(N\)</span> space-separated integers of array <span class="mathjax-latex">\(B\)</span>.</li>
</ul>

<p><strong>Output format</strong></p>

<p>For each test case, print a single line indicating the minimum number of operations if sorting can be done. If it is not possible to sort the array, print <strong>-1</strong>.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \leq T \leq 5\)</span></p>

<p><span class="mathjax-latex">\(1 \leq N \leq 16\)</span></p>

<p><span class="mathjax-latex">\(1 \leq A_i , B_i \leq 100\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p><strong>First test case:</strong><br>
                       The array A is already sorted, so we don't need to perform any operation.</p>

<p><br>
<strong>Second test case:</strong><br>
                       The array A is initially not sorted, A={8,7} and B={7,8}, we need to perform operation. We have no other choice than choosing index as 1, according to operation we need to swap A<sub>1</sub> and B<sub>2</sub> and swap A<sub>2</sub> and B<sub>1 </sub>, after performing  array A={8,7} and B={7,8} remains the same and we have no other options, so it is impossible to sort the array.</p>

<p><strong>Third test case:<br>
                       </strong> A={2,3,2} and B={2,1,2} and let us choose i=1, according to operation we need to swap A<sub>1</sub> and B<sub>2</sub> and swap A<sub>2</sub> and B<sub>1 </sub>, after performing  array A={1,2,2} and B={3,2,2} and now note that array A is sorted. Number of operations in this case are 1.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/and-subsequence-9682a719/" target="_blank" rel="noopener noreferrer">AND Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge"></span> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">linearsearch</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <span class="mathjax-latex">\(A\)</span> having <span class="mathjax-latex">\(N\)</span> integers and an integer <span class="mathjax-latex">\(X\)</span>. Find the length of the longest non-empty subsequence of the array <span class="mathjax-latex">\(A\)</span> such that the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" target="_blank">Bitwise AND</a> of the elements of the subsequence is greater than or equal to <span class="mathjax-latex">\(X\)</span>. Print&nbsp;<span class="mathjax-latex">\(-1\)</span> if no such subsequence exists.</p>

<p>A subsequence is<strong>&nbsp;</strong>a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line of input contains an integer&nbsp;<span class="mathjax-latex">\(T\)</span>&nbsp;denoting the number of test cases. The description of each test case is as follows:</li>
	<li>The first line of each test case contains two integers&nbsp;<span class="mathjax-latex">\(N\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(X\)</span>.</li>
	<li>The second line of each test case contains <span class="mathjax-latex">\(N\)</span> integers&nbsp;<span class="mathjax-latex">\(A_1, A_2,\dots, A_N\)</span>.</li>
</ul>

<p><strong>Output format</strong></p>

<p>For each test case, print&nbsp;<span class="mathjax-latex">\(-1\)</span> if no subsequence satisfies the given condition. Otherwise, print the length of the longest non-empty subsequence in a separate line.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1\le T \le 10^4 \\ 1 \leq N \le 10^5\\ 1\le A_i , X\lt 2^{30}\\ \text{Sum of $N$ over all test cases does not exceed }3\cdot 10^5.\)</span></p>

<p>&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><ul>
	<li>In the first test case, it is optimal to take&nbsp;<span class="mathjax-latex">\(A_2, A_3\)</span>&nbsp;in the chosen subsequence because&nbsp;<span class="mathjax-latex">\(A_2 \; \&amp;\; A_3 = 2 \; \&amp; \; 3 = 2 \ge X = 2\)</span>.</li>
	<li>In the second test case, it is optimal to take in the chosen subsequence because&nbsp;<span class="mathjax-latex">\(A_1 \; \&amp; \; A_3 \; \&amp;\; A_3 = 6 \; \&amp; \; 7 \; \&amp; \; 4 = 4 \ge X = 3\)</span>.</li>
	<li>In the third test case, it is impossible to choose any non-empty subsequence that satisfies the given conditions.</li>
</ul></div>
				</div>
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/xor-challenge-2420f189/" target="_blank" rel="noopener noreferrer">A XOR challenge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">greedyalgorithms</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <span class="mathjax-latex">\(C\)</span> such that the XOR of two integers <span class="mathjax-latex">\((A, B)\)</span> is <span class="mathjax-latex">\(C\)</span>. In short <span class="mathjax-latex">\(A ⊕ B = C\)</span> (⊕ denotes the bitwise the XOR operation).</p>

<p>Out of all possible pairs of <span class="mathjax-latex">\(A\)</span> and <span class="mathjax-latex">\(B\)</span>, you must find two integers such that their product is maximum.&nbsp;</p>

<p>Let us&nbsp;define <span class="mathjax-latex">\(L(A)\)</span> as&nbsp;the length of <span class="mathjax-latex">\(A\)</span> in its binary representation. Then, <span class="mathjax-latex">\(L(A) \le L(C)\)</span> and <span class="mathjax-latex">\(L(B) \le L(C)\)</span>.</p>

<p><strong>Input format&nbsp;</strong></p>

<p>A single integer representing <span class="mathjax-latex">\(C\)</span> (<span class="mathjax-latex">\(0⩽C⩽10^5\)</span>)</p>

<p><strong>Output format&nbsp;</strong></p>

<p>Print the maximum product you can achieve under the given conditions.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The binary representation of 13 is "1101".</p>

<p>We can use A=10 ("1010" in binary) and B=7 ("0111" in binary). This gives us the product 70. No other valid pair (A,B) can give us a larger product.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/beautiful-arrangement/description" target="_blank" rel="noopener noreferrer">Beautiful Arrangement</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Suppose you have <code>n</code> integers labeled <code>1</code> through <code>n</code>. A permutation of those <code>n</code> integers <code>perm</code> (<strong>1-indexed</strong>) is considered a <strong>beautiful arrangement</strong> if for every <code>i</code> (<code>1 &lt;= i &lt;= n</code>), <strong>either</strong> of the following is true:</p>

<ul>
	<li><code>perm[i]</code> is divisible by <code>i</code>.</li>
	<li><code>i</code> is divisible by <code>perm[i]</code>.</li>
</ul>

<p>Given an integer <code>n</code>, return <em>the <strong>number</strong> of the <strong>beautiful arrangements</strong> that you can construct</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 2
<b>Explanation:</b> 
The first beautiful arrangement is [1,2]:
    - perm[1] = 1 is divisible by i = 1
    - perm[2] = 2 is divisible by i = 2
The second beautiful arrangement is [2,1]:
    - perm[1] = 2 is divisible by i = 1
    - i = 2 is divisible by perm[2] = 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 15</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h3>
<h4 id="algorithm">Algorithm</h4>
<p>In the brute force method, we can find out all the arrays that can be formed using the numbers from 1 to N(by creating every possible permutation of the given elements). Then, we iterate over all the elements of every permutation generated and check for the required conditions of divisibility.</p>
<p>In order to generate all the possible pairings, we make use of a function <code>permute(nums, current_index)</code>. This function creates all the possible permutations of the elements of the given array.</p>
<p>To do so, <code>permute</code> takes the index of the current element <span class="math inline">\(current_index\)</span> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p>
<p>Thus, when we reach the end of the array, a new ordering of the array's elements is generated. The following animation depicts the process of generating the permutations.</p>
<p>!?!../Documents/561_Array.json:1000,563!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5cbz54de/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n!)\)</span>. A total of <span class="math inline">\(n!\)</span> permutations will be generated for an array of length <span class="math inline">\(n\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The depth of the recursion tree can go upto <span class="math inline">\(n\)</span>. <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h3>
<h4 id="algorithm-1">Algorithm</h4>
<p>In the brute force approach, we create the full array for every permutation and then check the array for the given divisibilty conditions. But this method can be optimized to a great extent. To do so, we can keep checking the elements while being added to the permutation array at every step for the divisibility condition and  can stop creating it any further as soon as we find out the element just added to the permutation violates the divisiblity condition.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/D4dVJwn7/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(k)\)</span>. <span class="math inline">\(k\)</span> refers to the number of valid permutations.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The depth of recursion tree can go upto <span class="math inline">\(n\)</span>. Further, <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> is used, where, <span class="math inline">\(n\)</span> is the given number.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-backtracking-accepted">Approach #3 Backtracking [Accepted]</h3>
<h4 id="algorithm-2">Algorithm</h4>
<p>The idea behind this approach is simple. We try to create all the permutations of numbers from 1 to N. We can fix one number at a particular position and check for the divisibility criteria of that number at the particular position. But, we need to keep a track of the numbers which have already been considered earlier so that they aren't reconsidered while generating the permutations. If the current<br />
number doesn't satisfy the divisibility criteria, we can leave all the permutations that can be generated with that number at the particular position. This helps to prune the search space of the permutations to a great extent. We do so by trying to place each of the numbers at each position.</p>
<p>We make use of a visited array of size <span class="math inline">\(N\)</span>. Here, <span class="math inline">\(visited[i]\)</span> refers to the <span class="math inline">\(i^{th}\)</span> number being already placed/not placed in the array being formed till now(True indicates that the number has already been placed).</p>
<p>We make use of a <code>calculate</code> function, which puts all the numbers pending numbers from 1 to N(i.e. not placed till now in the array), indicated by a <span class="math inline">\(False\)</span> at the corresponding <span class="math inline">\(visited[i]\)</span> position, and tries to create all the permutations with those numbers starting from the <span class="math inline">\(pos\)</span> index onwards in the current array. While putting the <span class="math inline">\(pos^{th}\)</span> number, we check whether the <span class="math inline">\(i^{th}\)</span> number satisfies the divisibility criteria on the go i.e. we continue forward with creating the permutations with the number <span class="math inline">\(i\)</span> at the <span class="math inline">\(pos^{th}\)</span> position only if the number <span class="math inline">\(i\)</span> and <span class="math inline">\(pos\)</span> satisfy the given criteria. Otherwise, we continue with putting the next numbers at the same position and keep on generating the permutations.</p>
<p>Look at the animation below for a better understanding of the methodology:</p>
<p>!?!../Documents/526_Beautiful.json:1000,563!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/EVQebXTW/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(k)\)</span>. <span class="math inline">\(k\)</span> refers to the number of valid permutations.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(visited\)</span> array of size <span class="math inline">\(n\)</span> is used. The depth of recursion tree will also go upto <span class="math inline">\(n\)</span>. Here, <span class="math inline">\(n\)</span> refers to the given integer <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/can-i-win/description" target="_blank" rel="noopener noreferrer">Can I Win</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In the &quot;100 game&quot; two players take turns adding, to a running total, any integer from <code>1</code> to <code>10</code>. The player who first causes the running total to <strong>reach or exceed</strong> 100 wins.</p>

<p>What if we change the game so that players <strong>cannot</strong> re-use integers?</p>

<p>For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.</p>

<p>Given two integers <code>maxChoosableInteger</code> and <code>desiredTotal</code>, return <code>true</code> if the first player to move can force a win, otherwise, return <code>false</code>. Assume both players play <strong>optimally</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 11
<strong>Output:</strong> false
<strong>Explanation:</strong>
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 0
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 1
<strong>Output:</strong> true
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li>
	<li><code>0 &lt;= desiredTotal &lt;= 300</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-subsequence-sum/description" target="_blank" rel="noopener noreferrer">Closest Subsequence Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>goal</code>.</p>

<p>You want to choose a subsequence of <code>nums</code> such that the sum of its elements is the closest possible to <code>goal</code>. That is, if the sum of the subsequence&#39;s elements is <code>sum</code>, then you want to <strong>minimize the absolute difference</strong> <code>abs(sum - goal)</code>.</p>

<p>Return <em>the <strong>minimum</strong> possible value of</em> <code>abs(sum - goal)</code>.</p>

<p>Note that a subsequence of an array is an array formed by removing some elements <strong>(possibly all or none)</strong> of the original array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,-7,3,5], goal = 6
<strong>Output:</strong> 0
<strong>Explanation:</strong> Choose the whole array as a subsequence, with a sum of 6.
This is equal to the goal, so the absolute difference is 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,-9,15,-2], goal = -5
<strong>Output:</strong> 1
<strong>Explanation:</strong> Choose the subsequence [7,-9,-2], with a sum of -4.
The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], goal = -7
<strong>Output:</strong> 7
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 40</code></li>
	<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= goal &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/compatibility-queries-0c068f8f/" target="_blank" rel="noopener noreferrer">Compatibility Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">1-d</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">dynamicprogrammingandbitmasking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Any integer <span class="mathjax-latex">\(A\)</span> is said to be compatible with&nbsp; another integer <span class="mathjax-latex">\(B\)</span> if <strong><em><span class="mathjax-latex">\(A|B=A+B\)</span></em></strong> where <strong><span class="mathjax-latex">\(A|B\)</span></strong> is the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#OR" target="_blank">Bitwise OR</a> of <span class="mathjax-latex">\(A\)</span> and <span class="mathjax-latex">\(B\)</span>.</p>

<p>You are given an array <span class="mathjax-latex">\(A\)</span> of <strong><span class="mathjax-latex">\(N\)</span></strong> integers. You are also given <strong><span class="mathjax-latex">\(Q\)</span></strong> queries where each query has a single integer <strong><span class="mathjax-latex">\(X\)</span></strong>. For each&nbsp;query find the sum of all the array elements which are compatible with <span class="mathjax-latex">\(X\)</span>.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains a single integer <strong><span class="mathjax-latex">\(N\)</span></strong>.</li>
	<li>The second line, contains <strong><span class="mathjax-latex">\(N\)</span></strong> space-separated integers, the array elements.&nbsp;</li>
	<li>The third line contains a single integer <strong><span class="mathjax-latex">\(Q\)</span></strong>.</li>
	<li>The next <strong><span class="mathjax-latex">\(Q\)</span></strong> lines contain a single integer each, the value of <span class="mathjax-latex">\(X\)</span>.</li>
</ul>

<p><strong>Output format</strong></p>

<p>Print the answer for each query in a separate line —&nbsp;the sum of all the array elements which are compatible with <span class="mathjax-latex">\(X\)</span>.</p>

<p><strong>Constraints</strong></p>

<p><strong><span class="mathjax-latex">\(1 \leq N \leq 10^6 \\ 1 \leq A_i \leq 10^6 \\ 1 \leq Q \leq 10^6 \\ 1 \leq X \leq 10^6\)</span></strong><br>
&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The array is <span class="mathjax-latex">\([1,2,3]\)</span>. There are 3 queries.</p>

<ul>
	<li>In the first query, only <span class="mathjax-latex">\(2\)</span> from the array is compatible with <span class="mathjax-latex">\(1\)</span> so the answer for the first query is <span class="mathjax-latex">\(2\)</span>.</li>
	<li>In the second query, only <span class="mathjax-latex">\(1\)</span> from the array is compatible with <span class="mathjax-latex">\(2\)</span> so the answer for the second query is <span class="mathjax-latex">\(1\)</span>.</li>
	<li>In the third query, no element from the array is compatible with <span class="mathjax-latex">\(3\)</span> so the answer for the third query is <span class="mathjax-latex">\(0\)</span>.</li>
</ul></div>
				</div>
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/concatenated-divisibility/description" target="_blank" rel="noopener noreferrer">Concatenated Divisibility</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="378" data-start="31">You are given an array of positive integers <code data-end="85" data-start="79">nums</code> and a positive integer <code data-end="112" data-start="109">k</code>.</p>

<p data-end="378" data-start="31">A <span data-keyword="permutation-array">permutation</span> of <code data-end="137" data-start="131">nums</code> is said to form a <strong data-end="183" data-start="156">divisible concatenation</strong> if, when you <em>concatenate</em> <em>the decimal representations</em> of the numbers in the order specified by the permutation, the resulting number is <strong>divisible by</strong> <code data-end="359" data-start="356">k</code>.</p>

<p data-end="561" data-start="380">Return the <strong><span data-keyword="lexicographically-smaller-string">lexicographically smallest</span></strong> permutation (when considered as a list of integers) that forms a <strong>divisible concatenation</strong>. If no such permutation exists, return an empty list.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,12,45], k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,12,45]</span></p>

<p><strong>Explanation:</strong></p>

<table data-end="896" data-start="441" node="[object Object]" style="border: 1px solid black;">
	<thead data-end="497" data-start="441">
		<tr data-end="497" data-start="441">
			<th data-end="458" data-start="441" style="border: 1px solid black;">Permutation</th>
			<th data-end="479" data-start="458" style="border: 1px solid black;">Concatenated Value</th>
			<th data-end="497" data-start="479" style="border: 1px solid black;">Divisible by 5</th>
		</tr>
	</thead>
	<tbody data-end="896" data-start="555">
		<tr data-end="611" data-start="555">
			<td style="border: 1px solid black;">[3, 12, 45]</td>
			<td style="border: 1px solid black;">31245</td>
			<td style="border: 1px solid black;">Yes</td>
		</tr>
		<tr data-end="668" data-start="612">
			<td style="border: 1px solid black;">[3, 45, 12]</td>
			<td style="border: 1px solid black;">34512</td>
			<td style="border: 1px solid black;">No</td>
		</tr>
		<tr data-end="725" data-start="669">
			<td style="border: 1px solid black;">[12, 3, 45]</td>
			<td style="border: 1px solid black;">12345</td>
			<td style="border: 1px solid black;">Yes</td>
		</tr>
		<tr data-end="782" data-start="726">
			<td style="border: 1px solid black;">[12, 45, 3]</td>
			<td style="border: 1px solid black;">12453</td>
			<td style="border: 1px solid black;">No</td>
		</tr>
		<tr data-end="839" data-start="783">
			<td style="border: 1px solid black;">[45, 3, 12]</td>
			<td style="border: 1px solid black;">45312</td>
			<td style="border: 1px solid black;">No</td>
		</tr>
		<tr data-end="896" data-start="840">
			<td style="border: 1px solid black;">[45, 12, 3]</td>
			<td style="border: 1px solid black;">45123</td>
			<td style="border: 1px solid black;">No</td>
		</tr>
	</tbody>
</table>

<p data-end="1618" data-start="1525">The lexicographically smallest permutation that forms a divisible concatenation is <code>[3,12,45]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [10,5], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">[5,10]</span></p>

<p><strong>Explanation:</strong></p>

<table data-end="1421" data-start="1200" node="[object Object]" style="border: 1px solid black;">
	<thead data-end="1255" data-start="1200">
		<tr data-end="1255" data-start="1200">
			<th data-end="1216" data-start="1200" style="border: 1px solid black;">Permutation</th>
			<th data-end="1237" data-start="1216" style="border: 1px solid black;">Concatenated Value</th>
			<th data-end="1255" data-start="1237" style="border: 1px solid black;">Divisible by 10</th>
		</tr>
	</thead>
	<tbody data-end="1421" data-start="1312">
		<tr data-end="1366" data-start="1312">
			<td style="border: 1px solid black;">[5, 10]</td>
			<td style="border: 1px solid black;">510</td>
			<td style="border: 1px solid black;">Yes</td>
		</tr>
		<tr data-end="1421" data-start="1367">
			<td style="border: 1px solid black;">[10, 5]</td>
			<td style="border: 1px solid black;">105</td>
			<td style="border: 1px solid black;">No</td>
		</tr>
	</tbody>
</table>

<p data-end="2011" data-start="1921">The lexicographically smallest permutation that forms a divisible concatenation is <code>[5,10]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3], k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>

<p><strong>Explanation:</strong></p>

<p>Since no permutation of <code data-end="177" data-start="171">nums</code> forms a valid divisible concatenation, return an empty list.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 13</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/costliest-data-plan-422373b5/" target="_blank" rel="noopener noreferrer">Costliest Data Plan</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Pawan has a finite number of friends, each friend has a unique non-negative number associated with him. (0, 1, 2..)<br>
Pawan plans to host a party and has to send notifications to his friends.<br>
A friend attends the party if he receives at least 1 notification from Pawan.<br>
To send notifications, Pawan buys data plans&nbsp;<br>
Pawan can send notifications using data plan <span class="mathjax-latex">\(X\)</span> in the following way:<br>
Let's say Data plan <span class="mathjax-latex">\(X\)</span> costs&nbsp;<span class="mathjax-latex">\(Y\)</span>.<br>
Then a friend associated with the number&nbsp;<span class="mathjax-latex">\(i\)</span>&nbsp;will receive a notification if and only if the&nbsp;<span class="mathjax-latex">\(i^{th}\)</span> bit in <span class="mathjax-latex">\(Y\)</span> is set.<br>
Now Pawan wonders if he can cut costs. Let him know <strong>the maximum cost</strong> that he can cut by removing <strong>at most 1</strong> data plan and still being able to invite all the friends <strong>he could invite earlier</strong></p>

<p>&nbsp;</p>

<p><strong>Input</strong></p>

<p>Each test contains multiple test cases. The first line contains a single integer&nbsp;<em>t (1≤t≤100)</em>&nbsp;— the number of test cases. Description of the test cases follows.</p>

<p>The first line of each test case contains one integer <em><span class="mathjax-latex">\(N\)</span>&nbsp;-&nbsp;&nbsp;</em>the number of data plans&nbsp;</p>

<p>The second line of each test case contains&nbsp;<em><span class="mathjax-latex">\(N\)</span></em> integers&nbsp;<em>a1,a2,…,an</em>&nbsp;— the cost of data plans array.</p>

<p>It is guaranteed that the sum of&nbsp;<span class="mathjax-latex">\(N\)</span> over all test cases does not exceed <span class="mathjax-latex">\(10^5\)</span></p>

<p><strong>Output</strong></p>

<p>For each test case, print a line containing a single integer – the maximum possible money that Pawan can save (print 0 if no data plan can be removed)</p>

<p><strong>Constraints</strong></p>

<p><strong><em><span class="mathjax-latex">\(1 &lt;= T &lt;= 100\)</span></em></strong></p>

<p><em><em><span class="mathjax-latex">\(1 &lt;= N &lt;= 10^5\)</span></em></em></p>

<p><em><span class="mathjax-latex">\(0&lt;=a_i&lt;=10^9\)</span></em></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the first case, the data plans cost 10rs and 5rs, With the first data plan(10rs) we can invite 1st and the 3rd friend because in the binary representation of 10&nbsp; (1010) the first and the third bit are set, and with the second data plan (5rs), we can invite 0th and the 2nd friend because in the binary representation of 5(101), the 0th and the 2nd bit is set</p>

<p>Now with all the data plans, we could invite the 0th, 1st,2nd, and 3rd friends, but if we remove any data plans, there will be a friend who will be left. Therefore the answer is 0rs</p>

<p>In the second case, the cost of all the data plans is the same, so if we remove any one data plan, we will still be able to invite all the friends we invited before. Therefore the answer is 9rs</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-paths-that-can-form-a-palindrome-in-a-tree/description" target="_blank" rel="noopener noreferrer">Count Paths That Can Form a Palindrome in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>tree</strong> (i.e. a connected, undirected graph that has no cycles) <strong>rooted</strong> at node <code>0</code> consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The tree is represented by a <strong>0-indexed</strong> array <code>parent</code> of size <code>n</code>, where <code>parent[i]</code> is the parent of node <code>i</code>. Since node <code>0</code> is the root, <code>parent[0] == -1</code>.</p>

<p>You are also given a string <code>s</code> of length <code>n</code>, where <code>s[i]</code> is the character assigned to the edge between <code>i</code> and <code>parent[i]</code>. <code>s[0]</code> can be ignored.</p>

<p>Return <em>the number of pairs of nodes </em><code>(u, v)</code><em> such that </em><code>u &lt; v</code><em> and the characters assigned to edges on the path from </em><code>u</code><em> to </em><code>v</code><em> can be <strong>rearranged</strong> to form a <strong>palindrome</strong></em>.</p>

<p>A string is a <strong>palindrome</strong> when it reads the same backwards as forwards.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/07/15/treedrawio-8drawio.png" style="width: 281px; height: 181px;" /></p>

<pre>
<strong>Input:</strong> parent = [-1,0,0,1,1,2], s = &quot;acaabc&quot;
<strong>Output:</strong> 8
<strong>Explanation:</strong> The valid pairs are:
- All the pairs (0,1), (0,2), (1,3), (1,4) and (2,5) result in one character which is always a palindrome.
- The pair (2,3) result in the string &quot;aca&quot; which is a palindrome.
- The pair (1,5) result in the string &quot;cac&quot; which is a palindrome.
- The pair (3,5) result in the string &quot;acac&quot; which can be rearranged into the palindrome &quot;acca&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> parent = [-1,0,0,0,0], s = &quot;aaaaa&quot;
<strong>Output:</strong> 10
<strong>Explanation:</strong> Any pair of nodes (u,v) where u &lt; v is valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == parent.length == s.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for all <code>i &gt;= 1</code></li>
	<li><code>parent[0] == -1</code></li>
	<li><code>parent</code> represents a valid tree.</li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-subtrees-with-max-distance-between-cities/description" target="_blank" rel="noopener noreferrer">Count Subtrees With Max Distance Between Cities</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities numbered from <code>1</code> to <code>n</code>. You are given an array <code>edges</code> of size <code>n-1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> represents a bidirectional edge between cities <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>. There exists a unique path between each pair of cities. In other words, the cities form a <strong>tree</strong>.</p>

<p>A <strong>subtree</strong> is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.</p>

<p>For each <code>d</code> from <code>1</code> to <code>n-1</code>, find the number of subtrees in which the <strong>maximum distance</strong> between any two cities in the subtree is equal to <code>d</code>.</p>

<p>Return <em>an array of size</em> <code>n-1</code> <em>where the </em><code>d<sup>th</sup></code><em> </em><em>element <strong>(1-indexed)</strong> is the number of subtrees in which the <strong>maximum distance</strong> between any two cities is equal to </em><code>d</code>.</p>

<p><strong>Notice</strong>&nbsp;that&nbsp;the <strong>distance</strong> between the two cities is the number of edges in the path between them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/p1.png" style="width: 161px; height: 181px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[2,3],[2,4]]
<strong>Output:</strong> [3,4,0]
<strong>Explanation:
</strong>The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.
The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.
No subtree has two nodes where the max distance between them is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, edges = [[1,2]]
<strong>Output:</strong> [1]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[1,2],[2,3]]
<strong>Output:</strong> [2,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 15</code></li>
	<li><code>edges.length == n-1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li>All pairs <code>(u<sub>i</sub>, v<sub>i</sub>)</code> are distinct.</li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-square-free-subsets/description" target="_blank" rel="noopener noreferrer">Count the Number of Square-Free Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <strong>0-indexed</strong>&nbsp;array <code>nums</code>.</p>

<p>A subset of the array <code>nums</code> is <strong>square-free</strong> if the product of its elements is a <strong>square-free integer</strong>.</p>

<p>A <strong>square-free integer</strong> is an integer that is divisible by no square number other than <code>1</code>.</p>

<p>Return <em>the number of square-free non-empty subsets of the array</em> <strong>nums</strong>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>non-empty</strong>&nbsp;<strong>subset</strong> of <code>nums</code> is an array that can be obtained by deleting some (possibly none but not all) elements from <code>nums</code>. Two subsets are different if and only if the chosen indices to delete are different.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,4,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 square-free subsets in this example:
- The subset consisting of the 0<sup>th</sup> element [3]. The product of its elements is 3, which is a square-free integer.
- The subset consisting of the 3<sup>rd</sup> element [5]. The product of its elements is 5, which is a square-free integer.
- The subset consisting of 0<sup>th</sup> and 3<sup>rd</sup> elements [3,5]. The product of its elements is 15, which is a square-free integer.
It can be proven that there are no more than 3 square-free subsets in the given array.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is 1 square-free subset in this example:
- The subset consisting of the 0<sup>th</sup> element [1]. The product of its elements is 1, which is a square-free integer.
It can be proven that there is no more than 1 square-free subset in the given array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length&nbsp;&lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 30</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/distribute-repeating-integers/description" target="_blank" rel="noopener noreferrer">Distribute Repeating Integers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <code>n</code> integers, <code>nums</code>, where there are at most <code>50</code> unique values in the array. You are also given an array of <code>m</code> customer order quantities, <code>quantity</code>, where <code>quantity[i]</code> is the amount of integers the <code>i<sup>th</sup></code> customer ordered. Determine if it is possible to distribute <code>nums</code> such that:</p>

<ul>
	<li>The <code>i<sup>th</sup></code> customer gets <strong>exactly</strong> <code>quantity[i]</code> integers,</li>
	<li>The integers the <code>i<sup>th</sup></code> customer gets are <strong>all equal</strong>, and</li>
	<li>Every customer is satisfied.</li>
</ul>

<p>Return <code>true</code><em> if it is possible to distribute </em><code>nums</code><em> according to the above conditions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], quantity = [2]
<strong>Output:</strong> false
<strong>Explanation:</strong> The 0<sup>th</sup> customer cannot be given two different integers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,3], quantity = [2]
<strong>Output:</strong> true
<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [3,3]. The integers [1,2] are not used.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,2], quantity = [2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [1,1], and the 1st customer is given [2,2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>m == quantity.length</code></li>
	<li><code>1 &lt;= m &lt;= 10</code></li>
	<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>
	<li>There are at most <code>50</code> unique values in <code>nums</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/even-sum-on-matrix-a7c49e3f/" target="_blank" rel="noopener noreferrer">Even sum in a matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">math</span> <span class="topic-badge">mathbasic</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a matrix&nbsp;<span class="mathjax-latex">\(A\)</span><em>&nbsp;</em>containing&nbsp;<span class="mathjax-latex">\(N \times M\)</span>&nbsp;elements. You are required to find the number of rectangular submatrices of this matrix such&nbsp;that the sum of the elements in each such submatrix is even.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line of input&nbsp;given two numbers <span class="mathjax-latex">\(N\ and\ M\)</span>&nbsp;denoting&nbsp;the dimensions of the matrix.</li>
	<li>The next <span class="mathjax-latex">\(N\)</span> lines contain space-separated&nbsp;<span class="mathjax-latex">\(M\)</span> numbers.</li>
</ul>

<p><strong>Output format</strong></p>

<p>Print a number denoting the number of rectangular submatrices, the sum of the elements of each is even.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1≤N,M≤2000\)</span></p>

<p><span class="mathjax-latex">\(1≤A_i,_j≤10^9\)</span>,&nbsp;<span class="mathjax-latex">\(1≤i≤N,1≤j≤M\)</span></p>

<p>&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The following sub-matrices are suitable for us:</p>

<p><span class="mathjax-latex">\(\begin{pmatrix} 2 \end{pmatrix}\)</span>, <span class="mathjax-latex">\(\begin{pmatrix} 4 \end{pmatrix}\)</span>,<span class="mathjax-latex">\(\begin{pmatrix} 6 \end{pmatrix}\)</span>,<span class="mathjax-latex">\(\begin{pmatrix} 1,2,3 \end{pmatrix}\)</span></p>

<p><span class="mathjax-latex">\(\begin{pmatrix} 1, 2\\ 4, 5\\ \end{pmatrix}\)</span>, <span class="mathjax-latex">\(\begin{pmatrix} 2,3 \\ 5, 6\\ \end{pmatrix}\)</span></p>

<p>Count submatrices = 6.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/fair-distribution-of-cookies/description" target="_blank" rel="noopener noreferrer">Fair Distribution of Cookies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>cookies</code>, where <code>cookies[i]</code> denotes the number of cookies in the <code>i<sup>th</sup></code> bag. You are also given an integer <code>k</code> that denotes the number of children to distribute <strong>all</strong> the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.</p>

<p>The <strong>unfairness</strong> of a distribution is defined as the <strong>maximum</strong> <strong>total</strong> cookies obtained by a single child in the distribution.</p>

<p>Return <em>the <strong>minimum</strong> unfairness of all distributions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cookies = [8,15,10,20,8], k = 2
<strong>Output:</strong> 31
<strong>Explanation:</strong> One optimal distribution is [8,15,8] and [10,20]
- The 1<sup>st</sup> child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.
- The 2<sup>nd</sup> child receives [10,20] which has a total of 10 + 20 = 30 cookies.
The unfairness of the distribution is max(31,30) = 31.
It can be shown that there is no distribution with an unfairness less than 31.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cookies = [6,1,3,2,2,4,1,2], k = 3
<strong>Output:</strong> 7
<strong>Explanation:</strong> One optimal distribution is [6,1], [3,2,2], and [4,1,2]
- The 1<sup>st</sup> child receives [6,1] which has a total of 6 + 1 = 7 cookies.
- The 2<sup>nd</sup> child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.
- The 3<sup>rd</sup> child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.
The unfairness of the distribution is max(7,7,7) = 7.
It can be shown that there is no distribution with an unfairness less than 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= cookies.length &lt;= 8</code></li>
	<li><code>1 &lt;= cookies[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= k &lt;= cookies.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-backtracking">Approach: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with recursion, please refer to our explore cards <a href="https://leetcode.com/explore/featured/card/recursion-i/">Recursion Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>The concept of backtracking involves attempting all possible distributions of cookies. We distribute the current cookie to each child and recursively repeat the process with the next cookie until all the cookies are distributed. Once all the cookies have been distributed, we compute the unfairness of the current distribution and update the minimum unfairness encountered.</p>
<p>Let’s take a look at a scenario with 3 cookies and 3 children that serves as a great example of this.</p>
<p>Initially, we move along the path in yellow by distributing all 3 cookies to child 0, but it is not a valid distribution as child 1 and child 2 receive no cookies.</p>
<p><img src="../Figures/2305/3.png" alt="img" /></p>
<p>As a result, we backtrack to the next possible distribution (by distributing the last cookie to child 1) and repeat this process.</p>
<p><img src="../Figures/2305/4.png" alt="img" /></p>
<p>After distributing all cookies, we will determine if the current distribution is valid, and if so, we will calculate the unfairness of this distribution.</p>
<p>To optimize the backtracking approach, we can use an early stop technique. Consider the same example in the image below: suppose that we have already distributed the first 2 cookies to child 0. When we come to the last cookie, should we continue the recursion process by distributing it to any child?</p>
<p>The answer is NO, because child 1 and child 2 require at least two cookies, and at this point, we only have one cookie remaining. Consequently, no matter how we distribute this last cookie, it will inevitably lead to an invalid distribution. Therefore, we can discard this path and not proceed further with it.</p>
<p><img src="../Figures/2305/5.png" alt="img" /></p>
<p>To implement the early stop technique, we will introduce a parameter named <code>zero_count</code> that represents <strong>the number of children without a cookie</strong>. During the backtracking process, if we have fewer undistributed cookies than <code>zero_count</code>, it means that some children will always end up with no cookie. At this point, we can terminate the recursion because it becomes impossible to obtain a valid distribution. The image below illustrates this concept, where the red states are not computed thanks to the early stop, significantly reducing unnecessary recursion steps.</p>
<p><img src="../Figures/2305/6.png" alt="img" /></p>
<p>Therefore, the algorithm only tracks the paths that lead to valid distributions and updates the global minimum by the maximum unfairness of each valid distribution.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Create an array <code>distribute</code> of length <code>k</code> initialized with all zeros, which represents the unfairness of each child.</p>
</li>
<li>
<p>Define the recursive function <code>dfs(i, zero_count)</code> to distribute the <span class="math inline">\(i^{th}\)</span> cookie:</p>
<ul>
<li>If the number of undistributed cookies is less than <code>zero_count</code>, which is <code>n - i &lt; zero_count</code>, return a large integer like <code>float('inf')</code>, implying that the current distribution is invalid.</li>
<li>If <code>i = n</code>, return the maximum value of <code>distribute</code> which is the unfairness of this distribution.</li>
<li>Otherwise, set <code>answer</code> as <code>float('inf')</code> and continue with step 3.</li>
</ul>
</li>
<li>
<p>Iterate through <code>distribute</code> and for each child <code>j</code>:</p>
<ul>
<li>Increment <code>distribute[j]</code> by <code>cookie[i]</code>, if <code>distribute[i]</code> is 0 before the distribution, decrement <code>zero_count</code> by 1.</li>
<li>Recursively call <code>dfs(i + 1, zero_count)</code> and update <code>answer</code> as the minimum unfairness encountered, <code>answer = min(answer, dfs(i + 1, zero_count))</code>.</li>
<li>Decrement <code>distribute[j]</code> by <code>cookie[i]</code>, if <code>distribute[i]</code> is 0 after the process, increment <code>zero_count</code> by 1. (This is the backtrack step)</li>
</ul>
<p>Return <code>answer</code> after the iteration is complete.</p>
</li>
<li>
<p>Return <code>dfs(0, distribute)</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NJKWuHZS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>cookies</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k^n)\)</span></p>
<ul>
<li>The algorithm attempts to distribute each of the <span class="math inline">\(n\)</span> cookies to each of the <span class="math inline">\(k\)</span> children, resulting in at most <span class="math inline">\(O(k^n)\)</span> distinct distributions.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k + n)\)</span></p>
<ul>
<li>The array <code>distribute</code> represents the status of <span class="math inline">\(k\)</span> children, thus taking up <span class="math inline">\(O(k)\)</span> space.</li>
<li>The space complexity of a recursive call depends on the maximum depth of the recursive call stack, which is at most <span class="math inline">\(n\)</span>. As each recursive call increments <code>i</code> by 1. Therefore, at most <span class="math inline">\(n\)</span> levels of recursion will be created, and each level consumes a constant amount of space.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Finish All Jobs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>jobs</code>, where <code>jobs[i]</code> is the amount of time it takes to complete the <code>i<sup>th</sup></code> job.</p>

<p>There are <code>k</code> workers that you can assign jobs to. Each job should be assigned to <strong>exactly</strong> one worker. The <strong>working time</strong> of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the <strong>maximum working time</strong> of any worker is <strong>minimized</strong>.</p>

<p><em>Return the <strong>minimum</strong> possible <strong>maximum working time</strong> of any assignment. </em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> jobs = [3,2,3], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> By assigning each person one job, the maximum time is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> jobs = [1,2,4,7,8], k = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong> Assign the jobs the following way:
Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)
Worker 2: 4, 7 (working time = 4 + 7 = 11)
The maximum working time is 11.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= jobs.length &lt;= 12</code></li>
	<li><code>1 &lt;= jobs[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-sum-of-array-product-of-magical-sequences/description" target="_blank" rel="noopener noreferrer">Find Sum of Array Product of Magical Sequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers, <code>m</code> and <code>k</code>, and an integer array <code>nums</code>.</p>
A sequence of integers <code>seq</code> is called <strong>magical</strong> if:

<ul>
	<li><code>seq</code> has a size of <code>m</code>.</li>
	<li><code>0 &lt;= seq[i] &lt; nums.length</code></li>
	<li>The <strong>binary representation</strong> of <code>2<sup>seq[0]</sup> + 2<sup>seq[1]</sup> + ... + 2<sup>seq[m - 1]</sup></code> has <code>k</code> <strong>set bits</strong>.</li>
</ul>

<p>The <strong>array product</strong> of this sequence is defined as <code>prod(seq) = (nums[seq[0]] * nums[seq[1]] * ... * nums[seq[m - 1]])</code>.</p>

<p>Return the <strong>sum</strong> of the <strong>array products</strong> for all valid <strong>magical</strong> sequences.</p>

<p>Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>set bit</strong> refers to a bit in the binary representation of a number that has a value of 1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">m = 5, k = 5, nums = [1,10,100,10000,1000000]</span></p>

<p><strong>Output:</strong> <span class="example-io">991600007</span></p>

<p><strong>Explanation:</strong></p>

<p>All permutations of <code>[0, 1, 2, 3, 4]</code> are magical sequences, each with an array product of 10<sup>13</sup>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">m = 2, k = 2, nums = [5,4,3,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">170</span></p>

<p><strong>Explanation:</strong></p>

<p>The magical sequences are <code>[0, 1]</code>, <code>[0, 2]</code>, <code>[0, 3]</code>, <code>[0, 4]</code>, <code>[1, 0]</code>, <code>[1, 2]</code>, <code>[1, 3]</code>, <code>[1, 4]</code>, <code>[2, 0]</code>, <code>[2, 1]</code>, <code>[2, 3]</code>, <code>[2, 4]</code>, <code>[3, 0]</code>, <code>[3, 1]</code>, <code>[3, 2]</code>, <code>[3, 4]</code>, <code>[4, 0]</code>, <code>[4, 1]</code>, <code>[4, 2]</code>, and <code>[4, 3]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">m = 1, k = 1, nums = [28]</span></p>

<p><strong>Output:</strong> <span class="example-io">28</span></p>

<p><strong>Explanation:</strong></p>

<p>The only magical sequence is <code>[0]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= m &lt;= 30</code></li>
	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-minimum-cost-array-permutation/description" target="_blank" rel="noopener noreferrer">Find the Minimum Cost Array Permutation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> which is a <span data-keyword="permutation">permutation</span> of <code>[0, 1, 2, ..., n - 1]</code>. The <strong>score</strong> of any permutation of <code>[0, 1, 2, ..., n - 1]</code> named <code>perm</code> is defined as:</p>

<p><code>score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|</code></p>

<p>Return the permutation <code>perm</code> which has the <strong>minimum</strong> possible score. If <em>multiple</em> permutations exist with this score, return the one that is <span data-keyword="lexicographically-smaller-array">lexicographically smallest</span> among them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,0,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,1,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/04/example0gif.gif" style="width: 235px; height: 235px;" /></strong></p>

<p>The lexicographically smallest permutation with minimum cost is <code>[0,1,2]</code>. The cost of this permutation is <code>|0 - 0| + |1 - 2| + |2 - 1| = 2</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,2,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/04/example1gif.gif" style="width: 235px; height: 235px;" /></strong></p>

<p>The lexicographically smallest permutation with minimum cost is <code>[0,2,1]</code>. The cost of this permutation is <code>|0 - 1| + |2 - 2| + |1 - 0| = 2</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 14</code></li>
	<li><code>nums</code> is a permutation of <code>[0, 1, 2, ..., n - 1]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-shortest-superstring/description" target="_blank" rel="noopener noreferrer">Find the Shortest Superstring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>words</code>, return <em>the smallest string that contains each string in</em> <code>words</code> <em>as a substring</em>. If there are multiple valid strings of the smallest length, return <strong>any of them</strong>.</p>

<p>You may assume that no string in <code>words</code> is a substring of another string in <code>words</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot;]
<strong>Output:</strong> &quot;alexlovesleetcode&quot;
<strong>Explanation:</strong> All permutations of &quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot; would also be accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;catg&quot;,&quot;ctaagt&quot;,&quot;gcta&quot;,&quot;ttca&quot;,&quot;atgcatc&quot;]
<strong>Output:</strong> &quot;gctaagttcatgcatc&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 12</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<p><strong>Intuition</strong></p>
<p>We have to put the words into a row, where each word may overlap the previous word.  This is because no word is contained in any word.</p>
<p>Also, it is sufficient to try to maximize the total overlap of the words.</p>
<p>Say we have put some words down in our row, ending with word <code>A[i]</code>.  Now say we put down word <code>A[j]</code> as the next word, where word <code>j</code> hasn't been put down yet.  The overlap increases by <code>overlap(A[i], A[j])</code>.</p>
<p>We can use dynamic programming to leverage this recursion.  Let <code>dp(mask, i)</code> be the total overlap after putting some words down (represented by a bitmask <code>mask</code>), for which <code>A[i]</code> was the last word put down.  Then, the key recursion is <code>dp(mask ^ (1&lt;&lt;j), j) = max(overlap(A[i], A[j]) + dp(mask, i))</code>, where the <code>j</code>th bit is not set in mask, and <code>i</code> ranges over all bits set in <code>mask</code>.</p>
<p>Of course, this only tells us what the maximum overlap is for each set of words.  We also need to remember each choice along the way (ie. the specific <code>i</code> that made <code>dp(mask ^ (1&lt;&lt;j), j)</code> achieve a minimum) so that we can reconstruct the answer.</p>
<p><strong>Algorithm</strong></p>
<p>Our algorithm has 3 main components:</p>
<ul>
<li>Precompute <code>overlap(A[i], A[j])</code> for all possible <code>i, j</code>.</li>
<li>Calculate <code>dp[mask][i]</code>, keeping track of the &quot;<code>parent</code>&quot; <code>i</code> for each <code>j</code> as described above.</li>
<li>Reconstruct the answer using <code>parent</code> information.</li>
</ul>
<p>Please see the implementation for more details about each section.</p>
<p><a href="https://leetcode.com/playground/n5UnrAXW/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2 (2^N + W))\)</span>, where <span class="math inline">\(N\)</span> is the number of words, and <span class="math inline">\(W\)</span> is the maximum length of each word.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N (2^N + W))\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/hamming-sort-09045827/" target="_blank" rel="noopener noreferrer">Hamming Sort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">mergesort</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers, denoted as <span class="mathjax-latex">\(A\)</span>, and an integer <span class="mathjax-latex">\(K\)</span>, your task is to implement a sorting algorithm. The goal is to arrange the elements in <span class="mathjax-latex">\(A\)</span> based on their Hamming Distance from the integer <span class="mathjax-latex">\(K\)</span>.</p>
<p>The <strong>Hamming Distance</strong> is defined as the count of differing bits in the binary representations of two integers.</p>
<p>The sorting should be done in ascending order of Hamming distance, and in case of a tie in Hamming Distances, the elements should be sorted in ascending numerical order.</p>
<p><u><strong>Input Format:</strong></u></p>
<p><strong><em>Note</em>:</strong> <em>This is the input format that you must use to provide custom input (available above the Compile and Test button).</em></p>
<p>The first line contains <em><em><em><em><em><em><em><em><span class="mathjax-latex">\(T\)</span></em></em></em></em></em></em></em></em> denoting the number of test cases. <em><em><em><em><em><em><em><em><span class="mathjax-latex">\(T\)</span></em></em></em></em></em></em></em></em> also specifies the number of times you have to run the solve function on a different set of inputs. For each test case:</p>
<ul>
<li>The first line contains the integer <em><em><em><em><em><em><em><em><span class="mathjax-latex">\(N\)</span></em></em></em></em></em></em></em></em> and <span class="mathjax-latex">\(K\)</span>.</li>
<li>The second line contains the array <span class="mathjax-latex">\(A\)</span> of length <em><em><em><em><em><em><em><em><span class="mathjax-latex">\(N\)</span></em></em></em></em></em></em></em></em></li>
</ul>
<p><u><strong>Output Format:</strong></u> For each test case, print the answer in a new line. </p>
<p><u><strong>Constraints:</strong></u></p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><span class="mathjax-latex">\(1 \leq T \leq 10 \\ 1 \leq N \leq 10^5 \\ 1 \leq K \leq 10^5 \\ 1 \leq A[i] \leq 10^5\)</span></strong></strong></strong></strong></strong></strong></strong></strong></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the example, binary representation of <span class="mathjax-latex">\(K = 2\)</span> is "<span class="mathjax-latex">\(10\)</span>". Similarly for array <span class="mathjax-latex">\([4,5,6]\)</span>, the binary representation is <span class="mathjax-latex">\( [100, 101, 110]\)</span>. Now the hamming distance of each element of the array with <span class="mathjax-latex">\(K\)</span> are <span class="mathjax-latex">\([2,3,1]\)</span>. Hence sorting on the basis of Hamming Distance, the final output comes out to be <span class="mathjax-latex">\([6,4,5]\)</span>.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/help-the-king-maximize-profit-d6306247/" target="_blank" rel="noopener noreferrer">Help the King Maximize Profit</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">dynamicprogrammingandbitmasking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A king possesses vacant houses within his town, arranged in an <span class="mathjax-latex">\(N*M\)</span> matrix. Each house is currently unoccupied. Within the town, there are introverted and extroverted individuals seeking residence.</p>

<p>When the king allocates a house to an introvert, he gains <strong><span class="mathjax-latex">\(360\)</span></strong> rupees; if given to an extrovert, he gains <span class="mathjax-latex">\(120\)</span> rupees.</p>

<p>However, for each person residing near an introvert, the king incurs a loss of <span class="mathjax-latex">\(90\)</span> rupees, whereas for each person near an extrovert, he gains <span class="mathjax-latex">\(60\)</span> rupees.</p>

<p>The objective is to determine the maximum profit achievable by the king. The allocation of accommodation to all individuals is not mandatory; the primary goal is to optimize the king's profit.</p>

<p>A person is called residing near another person if they live in the directly adjacent cells north, east, south, and west of a person's cell.</p>

<p><u><strong>Input Format:</strong></u></p>

<p>The one and only line contains <span class="mathjax-latex">\(4\)</span> integers <span class="mathjax-latex">\(N\)</span>, <span class="mathjax-latex">\(M\)</span>, <span class="mathjax-latex">\(X\)</span>&nbsp;(no of introverts) and&nbsp;<span class="mathjax-latex">\(Y\)</span>&nbsp;(no of extroverts).</p>

<p><u><strong>Output Format:</strong></u></p>

<p>Print one integer -&nbsp;the maximum profit achievable by the king</p>

<p><u><strong>Constraints:</strong></u><br>
<span class="mathjax-latex">\(1 \leq N,M \leq 5 \\ 0 \leq X,Y \leq 6\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p><img alt="" height="177" src="https://he-s3.s3.amazonaws.com/media/uploads/88da6d25-1e20-45b7-bf0a-ef9d2f32551e.png" width="500"></p>

<p>The Introvert will give 360 rupees while each extrovert will give 120 rupees. Since both the extroverts have 1 person next to them the king will gain (60*2) rupees more and hence the total profit is 720 rupees. It can be shown that no other combination can gain more than 720 rupees.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-palindromic-path-in-graph/description" target="_blank" rel="noopener noreferrer">Longest Palindromic Path in Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an <strong>undirected</strong> graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code> and a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>You are also given a string <code>label</code> of length <code>n</code>, where <code>label[i]</code> is the character associated with node <code>i</code>.</p>

<p>You may start at any node and move to any adjacent node, visiting each node <strong>at most</strong> once.</p>

<p>Return the <strong>maximum</strong> possible length of a <strong><span data-keyword="palindrome-string">palindrome</span></strong> that can be formed by visiting a set of <strong>unique</strong> nodes along a valid path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1],[1,2]], label = &quot;aba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Exp</strong><strong>lanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/13/screenshot-2025-06-13-at-230714.png" style="width: 250px; height: 85px;" /></p>

<ul>
	<li>The longest palindromic path is from node 0 to node 2 via node 1, following the path <code>0 &rarr; 1 &rarr; 2</code> forming string <code>&quot;aba&quot;</code>.</li>
	<li>This is a valid palindrome of length 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1],[0,2]], label = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/13/screenshot-2025-06-13-at-230017.png" style="width: 200px; height: 150px;" /></p>

<ul>
	<li>No path with more than one node forms a palindrome.</li>
	<li>The best option is any single node, giving a palindrome of length 1.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,2],[0,3],[3,1]], label = &quot;bbac&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/06/13/screenshot-2025-06-13-at-230508.png" style="width: 200px; height: 200px;" /></p>

<ul>
	<li>The longest palindromic path is from node 0 to node 1, following the path <code>0 &rarr; 3 &rarr; 1</code>, forming string <code>&quot;bcb&quot;</code>.</li>
	<li>This is a valid palindrome of length 3.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 14</code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>label.length == n</code></li>
	<li><code>label</code> consists of lowercase English letters.</li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/matchsticks-to-square/description" target="_blank" rel="noopener noreferrer">Matchsticks to Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>matchsticks</code> where <code>matchsticks[i]</code> is the length of the <code>i<sup>th</sup></code> matchstick. You want to use <strong>all the matchsticks</strong> to make one square. You <strong>should not break</strong> any stick, but you can link them up, and each matchstick must be used <strong>exactly one time</strong>.</p>

<p>Return <code>true</code> if you can make this square and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> matchsticks = [1,1,2,2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> You can form a square with length 2, one side of the square came two sticks with length 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matchsticks = [3,3,3,3,4]
<strong>Output:</strong> false
<strong>Explanation:</strong> You cannot find a way to form a square with all the matchsticks.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= matchsticks.length &lt;= 15</code></li>
	<li><code>1 &lt;= matchsticks[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Suppose we have <code>1,1,1,1,2,2,2,2,3,3,3,3</code> as our set of matchsticks. In this case a square of side <span class="math inline">\(6\)</span> can be formed and we have 4 matchsticks each of 1, 2 and 3 and so we can have each square side formed by <code>3 + 2 + 1 = 6</code>.</p>
<center>
<img src="../Figures/473/473_Matchsticks-In-Square-Diag-1.png" height="400"></center>
<p>We can clearly see in the diagram above that the 3 matchsticks of sizes <code>1</code>, <code>2</code> and <code>3</code> combine to give one side of our resulting square.</p>
<p>This problem boils down to splitting an array of integers into <span class="math inline">\(4\)</span> subsets where all of these subsets are:</p>
<ul>
<li>mutually exclusive i.e. no specific element of the array is shared by any two of these subsets, and</li>
<li>have the same sum which is equal to the side of our square.</li>
</ul>
<p>We know that we will have <span class="math inline">\(4\)</span> different subsets. The sum of elements of these subsets would be <span class="math inline">\(\frac{1}{4}\sum_{}^{} arr\)</span>. If the sum if not divisible by <span class="math inline">\(4\)</span>, that implies that <span class="math inline">\(4\)</span> subsets of equal value are not possible and we don't need to do any further processing on this.</p>
<p>The only question that remains now for us to solve is:</p>
<blockquote>
<p>what subset a particular element belongs to?</p>
</blockquote>
<p>If we are able to figure that out, then there's nothing else left to do. But, since we can't say which of the <span class="math inline">\(4\)</span> subsets would contain a particular element, we try out all the options.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>It is possible that a matchstick <em><strong>can</strong></em> be a part of any of the 4 sides of the resulting square, but which one of these choices leads to an actual square is something we don't know.</p>
<p>This means that for every matchstick in our given array, we have <span class="math inline">\(4\)</span> different options each representing the side of the square or subset that this matchstick can be a part of.</p>
<p>We try out all of them and keep on doing this recursively until we exhaust all of the possibilities or until we find an arrangement of our matchsticks such that they form the square.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>As discussed previously, we will follow a recursive, depth first approach to solve this problem. So, we have a function that takes the current matchstick index we are to process and also the number of sides of the square that are completely formed till now.</p>
</li>
<li>
<p>If all of the matchsticks have been used up and 4 sides have been completely formed, that implies our square is completely formed. This is the base case for the recursion.</p>
</li>
<li>
<p>For the current matchstick we have 4 different options. This matchstick at <span class="math inline">\(index\)</span> can be a part of any of the sides of the square. We try out the 4 options by recursing on them.</p>
<ul>
<li>If any of these recursive calls returns <span class="math inline">\(True\)</span>, then we return from there, else we return <span class="math inline">\(False\)</span></li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LGi7CtY9/shared">code</a></p>
<p>This solution is very slow as is. However, we can speed it up considerably by a small trick and that is to <code>sort our matchsticks sizes in reverse order before processing them recursively</code>.</p>
<p>The reason for this is that if there is no solution, trying a longer matchstick first will get to negative conclusion earlier.</p>
<p>e.g. <span class="math inline">\([8,4,4,4]\)</span>. In this case we can have a square of size 5 but the largest side 8 doesn't fit in anywhere i.e. cannot be a part of any of the sides (because we can't break matchsticks according to the question) and hence we can simply return <span class="math inline">\(False\)</span> without even considering the remaining matchsticks.</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(4^N)\)</span> because we have a total of <span class="math inline">\(N\)</span> sticks and for each one of those matchsticks, we have <span class="math inline">\(4\)</span> different possibilities for the subsets they might belong to or the side of the square they might be a part of.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>. For recursive solutions, the space complexity is the stack space occupied by all the recursive calls. The deepest recursive call here would be of size <span class="math inline">\(N\)</span> and hence the space complexity is <span class="math inline">\(O(N)\)</span>. There is no additional space other than the recursion stack in this solution.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In any dynamic programming problem, what's important is that our problem must be breakable into smaller subproblems and also, these subproblems show some sort of overlap which we can save upon by caching or memoization.</p>
<p>Suppose we have <code>3,3,4,4,5,5</code> as our matchsticks that have been used already to construct some of the sides of our square (<strong>Note:</strong> not all the sides may be completely constructed at all times.)</p>
<p>If the square side is <span class="math inline">\(8\)</span>, then there are many possibilities for how the sides can be constructed using the matchsticks above. We can have</p>
<pre>
  (4, 4), (3, 5), (3, 5) -----------> 3 sides fully constructed.
  (3, 4), (3, 5), (4), (5) ---------> 0 sides completely constructed.
  (3, 3), (4, 4), (5), (5) ---------> 1 side completely constructed.
</pre>
<p>As we can see above, there are multiple ways to use the same set of matchsticks and land up in completely different recursion states.</p>
<p>This means that if we just keep track of what all matchsticks have been used and which all are remaining, it won't properly define the state of recursion we are in or what subproblem we are solving.</p>
<p>A single set of used matchsticks can represent multiple different unrelated subproblems and that is just not right.</p>
<p>We also need to keep track of number of sides of the square that have been <strong>completely</strong> formed till now.</p>
<p>Also, an important thing to note in the example we just considered was that if the matchsticks being used are <span class="math inline">\([3,3,4,4,5,5]\)</span> and the side of the square is <code>8</code>, then we will always consider that arrangement that forms the most number of complete sides over that arrangement that leads to incomplete sides. Hence, the optimal arrangement here is <span class="math inline">\((4, 4), (3, 5), (3, 5)\)</span> with 3 complete sides of the square.</p>
<p>Let us take a look at the following recursion tree to see if in-fact we can get overlapping subproblems.</p>
<center>
<img src="../Figures/473/473_Matchsticks-In-Square-Diag-2.png" width="500"></center>
<p><strong>Note:</strong> Not all subproblems have been shown in this figure. The thing we wanted to point out was overlapping subproblems.</p>
<p>We know that the overall sum of these matchsticks can be split equally into 4 halves. The only thing we don't know is if 4 <strong>equal</strong> halves can be carved out of the given set of matchsticks. For that also we need to keep track of the number of sides completely formed at any point in time. <em><strong>If we end up forming 4 equal sides successfully then naturally we would have used up all of the matchsticks each being used exactly once and we would have formed a square</strong></em>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Let us first look at the pseudo-code for this problem before looking at the exact implementation details for the same.</p>
<pre>
let square_side = sum(matchsticks) / 4
func recurse(matchsticks_used, sides_formed) {
    if sides_formed == 4, then {
        Square Formed!!
    }
    for match in matchsticks available, do {
          add match to matchsticks_used
          let result = recurse(matchsticks_used, sides_formed)
          if result == True, then {
              return True
          }
          remove match from matchsticks_used
    }
    return False
}
</pre>
<p>This is the overall structure of our dynamic programming solution. Of course, a lot of implementation details are missing here that we will address now.</p>
<br />
<p>It is very clear from the pseudo-code above that the state of a recursion is defined by two variables <code>matchsticks_used</code> and <code>sides_formed</code>. Hence, these are the two variables that will be used to <strong>memoize</strong> or cache the results for that specific subproblem.</p>
<p>The question however is how do we actually store all the matchsticks that have been used? We want a memory efficient solution for this.</p>
<p>If we look at the question's constraints, we find that the max number of matchsticks we can have are <span class="math inline">\(15\)</span>. That's a pretty small number and we can make use of this constraint.</p>
<p>All we need to store is which of the matchsticks from the original list have been used. <code>We can use a Bit-Map for this</code></p>
<p>We will use <span class="math inline">\(N\)</span> number of bits, one for each of the matchsticks (<span class="math inline">\(N\)</span> is at max 15 according to the question's constraints). Initially we will start with a bit mask of <code>all 1s</code> and then as we keep on using the matchsticks, we will keep on setting their corresponding bits to <code>0</code>.</p>
<p>This way, we just have to hash an integer value which represents our bit-map and the max value for this mask would be <span class="math inline">\(2^{15}\)</span>.</p>
<br />
<p><strong>Do we really need to see if all 4 sides have been completely formed ?</strong></p>
<p>Another implementation trick that helps optimize this solution is that we don't really need to see if 4 sides have been completely formed.</p>
<p>This is because, we already know that the sum of all the matchsticks is divisible by 4. So, <em>if 3 equal sides have been formed by using some of the matchsticks, then the remaining matchsticks would definitely form the remaining side of our square.</em></p>
<p>Hence, we only need to check if 3 sides of our square can be formed or not.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/kKkAjm9e/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \times 2^N)\)</span>. At max <span class="math inline">\(2^N\)</span> unique bit masks are possible and during every recursive call, we iterate our original matchsticks array to sum up the values of matchsticks used to update the <code>sides_formed</code> variable.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N + 2^N)\)</span> because <span class="math inline">\(N\)</span> is the stack space taken up by recursion and <span class="math inline">\(4 \times 2^N\)</span> = <span class="math inline">\(O(2^N)\)</span> is the max possible size of our cache for memoization.</p>
<ul>
<li>The size of the cache is defined by the two variables <code>sides_formed</code> and <code>mask</code>. The number of different values that <code>sides_formed</code> can take = 4 and number of unique values of <code>mask</code> = <span class="math inline">\(2^N\)</span>.</li>
</ul>
<br />
<br /></li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-grid-happiness/description" target="_blank" rel="noopener noreferrer">Maximize Grid Happiness</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given four integers, <code>m</code>, <code>n</code>, <code>introvertsCount</code>, and <code>extrovertsCount</code>. You have an <code>m x n</code> grid, and there are two types of people: introverts and extroverts. There are <code>introvertsCount</code> introverts and <code>extrovertsCount</code> extroverts.</p>

<p>You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you <strong>do not</strong> have to have all the people living in the grid.</p>

<p>The <strong>happiness</strong> of each person is calculated as follows:</p>

<ul>
	<li>Introverts <strong>start</strong> with <code>120</code> happiness and <strong>lose</strong> <code>30</code> happiness for each neighbor (introvert or extrovert).</li>
	<li>Extroverts <strong>start</strong> with <code>40</code> happiness and <strong>gain</strong> <code>20</code> happiness for each neighbor (introvert or extrovert).</li>
</ul>

<p>Neighbors live in the directly adjacent cells north, east, south, and west of a person&#39;s cell.</p>

<p>The <strong>grid happiness</strong> is the <strong>sum</strong> of each person&#39;s happiness. Return<em> the <strong>maximum possible grid happiness</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/grid_happiness.png" style="width: 261px; height: 121px;" />
<pre>
<strong>Input:</strong> m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
<strong>Output:</strong> 240
<strong>Explanation:</strong> Assume the grid is 1-indexed with coordinates (row, column).
We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).
- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120
- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
The grid happiness is 120 + 60 + 60 = 240.
The above figure shows the grid in this example with each person&#39;s happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
<strong>Output:</strong> 260
<strong>Explanation:</strong> Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).
- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80
- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
The grid happiness is 90 + 80 + 90 = 260.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
<strong>Output:</strong> 240
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 5</code></li>
	<li><code>0 &lt;= introvertsCount, extrovertsCount &lt;= min(m * n, 6)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-score-after-n-operations/description" target="_blank" rel="noopener noreferrer">Maximize Score After N Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>nums</code>, an array of positive integers of size <code>2 * n</code>. You must perform <code>n</code> operations on this array.</p>

<p>In the <code>i<sup>th</sup></code> operation <strong>(1-indexed)</strong>, you will:</p>

<ul>
	<li>Choose two elements, <code>x</code> and <code>y</code>.</li>
	<li>Receive a score of <code>i * gcd(x, y)</code>.</li>
	<li>Remove <code>x</code> and <code>y</code> from <code>nums</code>.</li>
</ul>

<p>Return <em>the maximum score you can receive after performing </em><code>n</code><em> operations.</em></p>

<p>The function <code>gcd(x, y)</code> is the greatest common divisor of <code>x</code> and <code>y</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong>&nbsp;The optimal choice of operations is:
(1 * gcd(1, 2)) = 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,6,8]
<strong>Output:</strong> 11
<strong>Explanation:</strong>&nbsp;The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6]
<strong>Output:</strong> 14
<strong>Explanation:</strong>&nbsp;The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 7</code></li>
	<li><code>nums.length == 2 * n</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-number-of-partitions-after-operations/description" target="_blank" rel="noopener noreferrer">Maximize the Number of Partitions After Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and an integer <code>k</code>.</p>

<p>First, you are allowed to change <strong>at most</strong> <strong>one</strong> index in <code>s</code> to another lowercase English letter.</p>

<p>After that, do the following partitioning operation until <code>s</code> is <strong>empty</strong>:</p>

<ul>
	<li>Choose the <strong>longest</strong> <strong>prefix</strong> of <code>s</code> containing at most <code>k</code> <strong>distinct</strong> characters.</li>
	<li><strong>Delete</strong> the prefix from <code>s</code> and increase the number of partitions by one. The remaining characters (if any) in <code>s</code> maintain their initial order.</li>
</ul>

<p>Return an integer denoting the <strong>maximum</strong> number of resulting partitions after the operations by optimally choosing at most one index to change.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;accca&quot;, k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal way is to change <code>s[2]</code> to something other than a and c, for example, b. then it becomes <code>&quot;acbca&quot;</code>.</p>

<p>Then we perform the operations:</p>

<ol>
	<li>The longest prefix containing at most 2 distinct characters is <code>&quot;ac&quot;</code>, we remove it and <code>s</code> becomes <code>&quot;bca&quot;</code>.</li>
	<li>Now The longest prefix containing at most 2 distinct characters is <code>&quot;bc&quot;</code>, so we remove it and <code>s</code> becomes <code>&quot;a&quot;</code>.</li>
	<li>Finally, we remove <code>&quot;a&quot;</code> and <code>s</code> becomes empty, so the procedure ends.</li>
</ol>

<p>Doing the operations, the string is divided into 3 partitions, so the answer is 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aabaab&quot;, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>Initially&nbsp;<code>s</code>&nbsp;contains 2 distinct characters, so whichever character we change, it will contain at most 3 distinct characters, so the longest prefix with at most 3 distinct characters would always be all of it, therefore the answer is 1.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;xxyz&quot;, k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal way is to change&nbsp;<code>s[0]</code>&nbsp;or&nbsp;<code>s[1]</code>&nbsp;to something other than characters in&nbsp;<code>s</code>, for example, to change&nbsp;<code>s[0]</code>&nbsp;to&nbsp;<code>w</code>.</p>

<p>Then&nbsp;<code>s</code>&nbsp;becomes <code>&quot;wxyz&quot;</code>, which consists of 4 distinct characters, so as <code>k</code> is 1, it will divide into 4 partitions.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= k &lt;= 26</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-and-sum-of-array/description" target="_blank" rel="noopener noreferrer">Maximum AND Sum of Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and an integer <code>numSlots</code> such that <code>2 * numSlots &gt;= n</code>. There are <code>numSlots</code> slots numbered from <code>1</code> to <code>numSlots</code>.</p>

<p>You have to place all <code>n</code> integers into the slots such that each slot contains at <strong>most</strong> two numbers. The <strong>AND sum</strong> of a given placement is the sum of the <strong>bitwise</strong> <code>AND</code> of every number with its respective slot number.</p>

<ul>
	<li>For example, the <strong>AND sum</strong> of placing the numbers <code>[1, 3]</code> into slot <u><code>1</code></u> and <code>[4, 6]</code> into slot <u><code>2</code></u> is equal to <code>(1 AND <u>1</u>) + (3 AND <u>1</u>) + (4 AND <u>2</u>) + (6 AND <u>2</u>) = 1 + 1 + 0 + 2 = 4</code>.</li>
</ul>

<p>Return <em>the maximum possible <strong>AND sum</strong> of </em><code>nums</code><em> given </em><code>numSlots</code><em> slots.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6], numSlots = 3
<strong>Output:</strong> 9
<strong>Explanation:</strong> One possible placement is [1, 4] into slot <u>1</u>, [2, 6] into slot <u>2</u>, and [3, 5] into slot <u>3</u>. 
This gives the maximum AND sum of (1 AND <u>1</u>) + (4 AND <u>1</u>) + (2 AND <u>2</u>) + (6 AND <u>2</u>) + (3 AND <u>3</u>) + (5 AND <u>3</u>) = 1 + 0 + 2 + 2 + 3 + 1 = 9.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,10,4,7,1], numSlots = 9
<strong>Output:</strong> 24
<strong>Explanation:</strong> One possible placement is [1, 1] into slot <u>1</u>, [3] into slot <u>3</u>, [4] into slot <u>4</u>, [7] into slot <u>7</u>, and [10] into slot <u>9</u>.
This gives the maximum AND sum of (1 AND <u>1</u>) + (1 AND <u>1</u>) + (3 AND <u>3</u>) + (4 AND <u>4</u>) + (7 AND <u>7</u>) + (10 AND <u>9</u>) = 1 + 1 + 3 + 4 + 7 + 8 = 24.
Note that slots 2, 5, 6, and 8 are empty which is permitted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= numSlots &lt;= 9</code></li>
	<li><code>1 &lt;= n &lt;= 2 * numSlots</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 15</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-compatibility-score-sum/description" target="_blank" rel="noopener noreferrer">Maximum Compatibility Score Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a survey that consists of <code>n</code> questions where each question&#39;s answer is either <code>0</code> (no) or <code>1</code> (yes).</p>

<p>The survey was given to <code>m</code> students numbered from <code>0</code> to <code>m - 1</code> and <code>m</code> mentors numbered from <code>0</code> to <code>m - 1</code>. The answers of the students are represented by a 2D integer array <code>students</code> where <code>students[i]</code> is an integer array that contains the answers of the <code>i<sup>th</sup></code> student (<strong>0-indexed</strong>). The answers of the mentors are represented by a 2D integer array <code>mentors</code> where <code>mentors[j]</code> is an integer array that contains the answers of the <code>j<sup>th</sup></code> mentor (<strong>0-indexed</strong>).</p>

<p>Each student will be assigned to <strong>one</strong> mentor, and each mentor will have <strong>one</strong> student assigned to them. The <strong>compatibility score</strong> of a student-mentor pair is the number of answers that are the same for both the student and the mentor.</p>

<ul>
	<li>For example, if the student&#39;s answers were <code>[1, <u>0</u>, <u>1</u>]</code> and the mentor&#39;s answers were <code>[0, <u>0</u>, <u>1</u>]</code>, then their compatibility score is 2 because only the second and the third answers are the same.</li>
</ul>

<p>You are tasked with finding the optimal student-mentor pairings to <strong>maximize</strong> the<strong> sum of the compatibility scores</strong>.</p>

<p>Given <code>students</code> and <code>mentors</code>, return <em>the <strong>maximum compatibility score sum</strong> that can be achieved.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
<strong>Output:</strong> 8
<strong>Explanation:</strong>&nbsp;We assign students to mentors in the following way:
- student 0 to mentor 2 with a compatibility score of 3.
- student 1 to mentor 0 with a compatibility score of 2.
- student 2 to mentor 1 with a compatibility score of 3.
The compatibility score sum is 3 + 2 + 3 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The compatibility score of any student-mentor pair is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == students.length == mentors.length</code></li>
	<li><code>n == students[i].length == mentors[j].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 8</code></li>
	<li><code>students[i][k]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>mentors[j][k]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-good-subtree-score/description" target="_blank" rel="noopener noreferrer">Maximum Good Subtree Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected tree rooted at node 0 with <code>n</code> nodes numbered from 0 to <code>n - 1</code>. Each node <code>i</code> has an integer value <code>vals[i]</code>, and its parent is given by <code>par[i]</code>.</p>

<p>A <strong>subset</strong> of nodes within the <strong>subtree</strong> of a node is called <strong>good</strong> if every digit from 0 to 9 appears <strong>at most</strong> once in the decimal representation of the values of the selected nodes.</p>

<p>The <strong>score</strong> of a good subset is the sum of the values of its nodes.</p>

<p>Define an array <code>maxScore</code> of length <code>n</code>, where <code>maxScore[u]</code> represents the <strong>maximum</strong> possible sum of values of a good subset of nodes that belong to the subtree rooted at node <code>u</code>, including <code>u</code> itself and all its descendants.</p>

<p>Return the sum of all values in <code>maxScore</code>.</p>

<p>Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">vals = [2,3], par = [-1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/29/screenshot-2025-04-29-at-150754.png" style="height: 84px; width: 180px;" /></p>

<ul>
	<li>The subtree rooted at node 0 includes nodes <code>{0, 1}</code>. The subset <code>{2, 3}</code> is<i> </i>good as the digits 2 and 3 appear only once. The score of this subset is <code>2 + 3 = 5</code>.</li>
	<li>The subtree rooted at node 1 includes only node <code>{1}</code>. The subset <code>{3}</code> is<i> </i>good. The score of this subset is 3.</li>
	<li>The <code>maxScore</code> array is <code>[5, 3]</code>, and the sum of all values in <code>maxScore</code> is <code>5 + 3 = 8</code>. Thus, the answer is 8.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">vals = [1,5,2], par = [-1,0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">15</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2025/04/29/screenshot-2025-04-29-at-151408.png" style="width: 205px; height: 140px;" /></strong></p>

<ul>
	<li>The subtree rooted at node 0 includes nodes <code>{0, 1, 2}</code>. The subset <code>{1, 5, 2}</code> is<i> </i>good as the digits 1, 5 and 2 appear only once. The score of this subset is <code>1 + 5 + 2 = 8</code>.</li>
	<li>The subtree rooted at node 1 includes only node <code>{1}</code>. The subset <code>{5}</code> is<i> </i>good. The score of this subset is 5.</li>
	<li>The subtree rooted at node 2 includes only node <code>{2}</code>. The subset <code>{2}</code> is<i> </i>good. The score of this subset is 2.</li>
	<li>The <code>maxScore</code> array is <code>[8, 5, 2]</code>, and the sum of all values in <code>maxScore</code> is <code>8 + 5 + 2 = 15</code>. Thus, the answer is 15.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">vals = [34,1,2], par = [-1,0,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">42</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/29/screenshot-2025-04-29-at-151747.png" style="height: 80px; width: 256px;" /></p>

<ul>
	<li>The subtree rooted at node 0 includes nodes <code>{0, 1, 2}</code>. The subset <code>{34, 1, 2}</code> is<i> </i>good as the digits 3, 4, 1 and 2 appear only once. The score of this subset is <code>34 + 1 + 2 = 37</code>.</li>
	<li>The subtree rooted at node 1 includes node <code>{1, 2}</code>. The subset <code>{1, 2}</code> is<i> </i>good as the digits 1 and 2 appear only once. The score of this subset is <code>1 + 2 = 3</code>.</li>
	<li>The subtree rooted at node 2 includes only node <code>{2}</code>. The subset <code>{2}</code> is<i> </i>good. The score of this subset is 2.</li>
	<li>The <code>maxScore</code> array is <code>[37, 3, 2]</code>, and the sum of all values in <code>maxScore</code> is <code>37 + 3 + 2 = 42</code>. Thus, the answer is 42.</li>
</ul>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">vals = [3,22,5], par = [-1,0,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">18</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The subtree rooted at node 0 includes nodes <code>{0, 1, 2}</code>. The subset <code>{3, 22, 5}</code> is<i> </i>not good, as digit 2 appears twice. Therefore, the subset <code>{3, 5}</code> is valid. The score of this subset is <code>3 + 5 = 8</code>.</li>
	<li>The subtree rooted at node 1 includes nodes <code>{1, 2}</code>. The subset <code>{22, 5}</code> is<i> </i>not good, as digit 2 appears twice. Therefore, the subset <code>{5}</code> is valid. The score of this subset is 5.</li>
	<li>The subtree rooted at node 2 includes <code>{2}</code>. The subset <code>{5}</code> is<i> </i>good. The score of this subset is 5.</li>
	<li>The <code>maxScore</code> array is <code>[8, 5, 5]</code>, and the sum of all values in <code>maxScore</code> is <code>8 + 5 + 5 = 18</code>. Thus, the answer is 18.</li>
</ul>

<ul>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == vals.length &lt;= 500</code></li>
	<li><code>1 &lt;= vals[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>par.length == n</code></li>
	<li><code>par[0] == -1</code></li>
	<li><code>0 &lt;= par[i] &lt; n</code> for <code>i</code> in <code>[1, n - 1]</code></li>
	<li>The input is generated such that the parent array <code>par</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/description" target="_blank" rel="noopener noreferrer">Maximum Number of Groups Getting Fresh Donuts</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a donuts shop that bakes donuts in batches of <code>batchSize</code>. They have a rule where they must serve <strong>all</strong> of the donuts of a batch before serving any donuts of the next batch. You are given an integer <code>batchSize</code> and an integer array <code>groups</code>, where <code>groups[i]</code> denotes that there is a group of <code>groups[i]</code> customers that will visit the shop. Each customer will get exactly one donut.</p>

<p>When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.</p>

<p>You can freely rearrange the ordering of the groups. Return <em>the <strong>maximum</strong> possible number of happy groups after rearranging the groups.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> batchSize = 3, groups = [1,2,3,4,5,6]
<strong>Output:</strong> 4
<strong>Explanation:</strong> You can arrange the groups as [6,2,4,5,1,3]. Then the 1<sup>st</sup>, 2<sup>nd</sup>, 4<sup>th</sup>, and 6<sup>th</sup> groups will be happy.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> batchSize = 4, groups = [1,3,2,5,2,2,1,6]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= batchSize &lt;= 9</code></li>
	<li><code>1 &lt;= groups.length &lt;= 30</code></li>
	<li><code>1 &lt;= groups[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-moves-to-kill-all-pawns/description" target="_blank" rel="noopener noreferrer">Maximum Number of Moves to Kill All Pawns</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <code>50 x 50</code> chessboard with <strong>one</strong> knight and some pawns on it. You are given two integers <code>kx</code> and <code>ky</code> where <code>(kx, ky)</code> denotes the position of the knight, and a 2D array <code>positions</code> where <code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> denotes the position of the pawns on the chessboard.</p>

<p>Alice and Bob play a <em>turn-based</em> game, where Alice goes first. In each player&#39;s turn:</p>

<ul>
	<li>The player <em>selects </em>a pawn that still exists on the board and captures it with the knight in the <strong>fewest</strong> possible <strong>moves</strong>. <strong>Note</strong> that the player can select <strong>any</strong> pawn, it <strong>might not</strong> be one that can be captured in the <strong>least</strong> number of moves.</li>
	<li><span>In the process of capturing the <em>selected</em> pawn, the knight <strong>may</strong> pass other pawns <strong>without</strong> capturing them</span>. <strong>Only</strong> the <em>selected</em> pawn can be captured in <em>this</em> turn.</li>
</ul>

<p>Alice is trying to <strong>maximize</strong> the <strong>sum</strong> of the number of moves made by <em>both</em> players until there are no more pawns on the board, whereas Bob tries to <strong>minimize</strong> them.</p>

<p>Return the <strong>maximum</strong> <em>total</em> number of moves made during the game that Alice can achieve, assuming both players play <strong>optimally</strong>.</p>

<p>Note that in one <strong>move, </strong>a chess knight has eight possible positions it can move to, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.</p>

<p><img src="https://assets.leetcode.com/uploads/2024/08/01/chess_knight.jpg" style="width: 275px; height: 273px;" /></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">kx = 1, ky = 1, positions = [[0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/16/gif3.gif" style="width: 275px; height: 275px;" /></p>

<p>The knight takes 4 moves to reach the pawn at <code>(0, 0)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">kx = 0, ky = 2, positions = [[1,1],[2,2],[3,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/08/16/gif4.gif" style="width: 320px; height: 320px;" /></strong></p>

<ul>
	<li>Alice picks the pawn at <code>(2, 2)</code> and captures it in two moves: <code>(0, 2) -&gt; (1, 4) -&gt; (2, 2)</code>.</li>
	<li>Bob picks the pawn at <code>(3, 3)</code> and captures it in two moves: <code>(2, 2) -&gt; (4, 1) -&gt; (3, 3)</code>.</li>
	<li>Alice picks the pawn at <code>(1, 1)</code> and captures it in four moves: <code>(3, 3) -&gt; (4, 1) -&gt; (2, 2) -&gt; (0, 3) -&gt; (1, 1)</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">kx = 0, ky = 0, positions = [[1,2],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Alice picks the pawn at <code>(2, 4)</code> and captures it in two moves: <code>(0, 0) -&gt; (1, 2) -&gt; (2, 4)</code>. Note that the pawn at <code>(1, 2)</code> is not captured.</li>
	<li>Bob picks the pawn at <code>(1, 2)</code> and captures it in one move: <code>(2, 4) -&gt; (1, 2)</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= kx, ky &lt;= 49</code></li>
	<li><code>1 &lt;= positions.length &lt;= 15</code></li>
	<li><code>positions[i].length == 2</code></li>
	<li><code>0 &lt;= positions[i][0], positions[i][1] &lt;= 49</code></li>
	<li>All <code>positions[i]</code> are unique.</li>
	<li>The input is generated such that <code>positions[i] != [kx, ky]</code> for all <code>0 &lt;= i &lt; positions.length</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/description" target="_blank" rel="noopener noreferrer">Maximum Product of the Length of Two Palindromic Subsequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, find two <strong>disjoint palindromic subsequences</strong> of <code>s</code> such that the <strong>product</strong> of their lengths is <strong>maximized</strong>. The two subsequences are <strong>disjoint</strong> if they do not both pick a character at the same index.</p>

<p>Return <em>the <strong>maximum</strong> possible <strong>product</strong> of the lengths of the two palindromic subsequences</em>.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is <strong>palindromic</strong> if it reads the same forward and backward.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example-1" src="https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png" style="width: 550px; height: 124px;" />
<pre>
<strong>Input:</strong> s = &quot;leetcodecom&quot;
<strong>Output:</strong> 9
<strong>Explanation</strong>: An optimal solution is to choose &quot;ete&quot; for the 1<sup>st</sup> subsequence and &quot;cdc&quot; for the 2<sup>nd</sup> subsequence.
The product of their lengths is: 3 * 3 = 9.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bb&quot;
<strong>Output:</strong> 1
<strong>Explanation</strong>: An optimal solution is to choose &quot;b&quot; (the first character) for the 1<sup>st</sup> subsequence and &quot;b&quot; (the second character) for the 2<sup>nd</sup> subsequence.
The product of their lengths is: 1 * 1 = 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;accbcaxxcxx&quot;
<strong>Output:</strong> 25
<strong>Explanation</strong>: An optimal solution is to choose &quot;accca&quot; for the 1<sup>st</sup> subsequence and &quot;xxcxx&quot; for the 2<sup>nd</sup> subsequence.
The product of their lengths is: 5 * 5 = 25.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 12</code></li>
	<li><code>s</code> consists of lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-profit-from-valid-topological-order-in-dag/description" target="_blank" rel="noopener noreferrer">Maximum Profit from Valid Topological Order in DAG</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>Directed Acyclic Graph (DAG)</strong> with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates a directed edge from node <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code>. Each node has an associated <strong>score</strong> given in an array <code>score</code>, where <code>score[i]</code> represents the score of node <code>i</code>.</p>

<p>You must process the nodes in a <strong>valid topological order</strong>. Each node is assigned a <strong>1-based position</strong> in the processing order.</p>

<p>The <strong>profit</strong> is calculated by summing up the product of each node&#39;s score and its position in the ordering.</p>

<p>Return the <strong>maximum </strong>possible profit achievable with an optimal topological order.</p>

<p>A <strong>topological order</strong> of a DAG is a linear ordering of its nodes such that for every directed edge <code>u &rarr; v</code>, node <code>u</code> comes before <code>v</code> in the ordering.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1]], score = [2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-021131.png" style="width: 200px; height: 89px;" /></p>

<p>Node 1 depends on node 0, so a valid order is <code>[0, 1]</code>.</p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Node</th>
			<th style="border: 1px solid black;">Processing Order</th>
			<th style="border: 1px solid black;">Score</th>
			<th style="border: 1px solid black;">Multiplier</th>
			<th style="border: 1px solid black;">Profit Calculation</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1st</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2 &times; 1 = 2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2nd</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3 &times; 2 = 6</td>
		</tr>
	</tbody>
</table>

<p>The maximum total profit achievable over all valid topological orders is <code>2 + 6 = 8</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1],[0,2]], score = [1,6,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">25</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-023558.png" style="width: 200px; height: 124px;" /></p>

<p>Nodes 1 and 2 depend on node 0, so the most optimal valid order is <code>[0, 2, 1]</code>.</p>

<table data-end="1197" data-start="851" node="[object Object]" style="border: 1px solid black;">
	<thead data-end="920" data-start="851">
		<tr data-end="920" data-start="851">
			<th data-end="858" data-start="851" style="border: 1px solid black;">Node</th>
			<th data-end="877" data-start="858" style="border: 1px solid black;">Processing Order</th>
			<th data-end="885" data-start="877" style="border: 1px solid black;">Score</th>
			<th data-end="898" data-start="885" style="border: 1px solid black;">Multiplier</th>
			<th data-end="920" data-start="898" style="border: 1px solid black;">Profit Calculation</th>
		</tr>
	</thead>
	<tbody data-end="1197" data-start="991">
		<tr data-end="1059" data-start="991">
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1st</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1 &times; 1 = 1</td>
		</tr>
		<tr data-end="1128" data-start="1060">
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2nd</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3 &times; 2 = 6</td>
		</tr>
		<tr data-end="1197" data-start="1129">
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">3rd</td>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">6 &times; 3 = 18</td>
		</tr>
	</tbody>
</table>

<p>The maximum total profit achievable over all valid topological orders is <code>1 + 6 + 18 = 25</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == score.length &lt;= 22</code></li>
	<li><code>1 &lt;= score[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a directed edge from <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code>.</li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-words-formed-by-letters/description" target="_blank" rel="noopener noreferrer">Maximum Score Words Formed by Letters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a list of <code>words</code>, list of&nbsp; single&nbsp;<code>letters</code> (might be repeating)&nbsp;and <code>score</code>&nbsp;of every character.</p>

<p>Return the maximum score of <strong>any</strong> valid set of words formed by using the given letters (<code>words[i]</code> cannot be used two&nbsp;or more times).</p>

<p>It is not necessary to use all characters in <code>letters</code> and each letter can only be used once. Score of letters&nbsp;<code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, ... ,<code>&#39;z&#39;</code> is given by&nbsp;<code>score[0]</code>, <code>score[1]</code>, ... , <code>score[25]</code> respectively.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
<strong>Output:</strong> 23
<strong>Explanation:</strong>
Score  a=1, c=9, d=5, g=3, o=2
Given letters, we can form the words &quot;dad&quot; (5+1+5) and &quot;good&quot; (3+2+2+5) with a score of 23.
Words &quot;dad&quot; and &quot;dog&quot; only get a score of 21.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;xxxz&quot;,&quot;ax&quot;,&quot;bx&quot;,&quot;cx&quot;], letters = [&quot;z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;x&quot;,&quot;x&quot;,&quot;x&quot;], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
<strong>Output:</strong> 27
<strong>Explanation:</strong>
Score  a=4, b=4, c=4, x=5, z=10
Given letters, we can form the words &quot;ax&quot; (4+5), &quot;bx&quot; (4+5) and &quot;cx&quot; (4+5) with a score of 27.
Word &quot;xxxz&quot; only get a score of 25.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;leetcode&quot;], letters = [&quot;l&quot;,&quot;e&quot;,&quot;t&quot;,&quot;c&quot;,&quot;o&quot;,&quot;d&quot;], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
Letter &quot;e&quot; can only be used once.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 14</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 15</code></li>
	<li><code>1 &lt;= letters.length &lt;= 100</code></li>
	<li><code>letters[i].length == 1</code></li>
	<li><code>score.length ==&nbsp;26</code></li>
	<li><code>0 &lt;= score[i] &lt;= 10</code></li>
	<li><code>words[i]</code>, <code>letters[i]</code>&nbsp;contains only lower case English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given a list of <code>words</code>, we need to find the maximum subset score using the given set of <code>letters</code>. Each letter has a score tied to it, which is provided in <code>score</code>. Each entry in <code>words</code> can only be used once, although the same word can occur as multiple entries. Each character in <code>letters</code> can be used at most once.</p>
<p>This problem tests your ability to implement an algorithm that efficiently maintains a maximum score over all subsets of a set of words. The two main ways to do this are using an iterative loop and a recursive search method.</p>
<hr />
<h3 id="approach-1-iterative-loop-for-every-subset">Approach 1: Iterative Loop for Every Subset</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the size of the input is very small, a brute-force solution is feasible. We can check all subsets of <code>words</code> and return the largest score among subsets that can be constructed with the given <code>letters</code>.</p>
<p>Let's create a frequency array <code>freq</code> that stores the frequency of each letter in <code>letters</code>, which is needed to track how many copies of each letter we can use. For every subset of words, let's also create a <code>subsetLetters</code> array that stores the frequency of each letter of every word in the subset. The <code>subsetLetters</code> array is used to track the current state of words and how many copies of each letter are needed to build the current subset. Specifically, this subset can be constructed if and only if <code>freq[c] &lt;= subsetLetters[c]</code> for all letters <code>c</code>. If a subset is valid, its score is equal to the sum of <code>subsetLetters[c] * score[c]</code> for all <code>c</code>.</p>
<p>Now that we have a strategy to check the validity and score of a subset, we need to generate and check the subsets. For this approach, we'll use a for loop that iterates through every integer <code>mask</code> whose binary representation corresponds to a subset of <code>words</code>. The <span class="math inline">\(i^{\texttt{th}}\)</span> bit in <code>mask</code> equals <code>1</code> if this subset contains <code>words[i]</code>, and <code>0</code> otherwise.</p>
<p>Example binary representations of subsets:</p>
<p><img src="../Figures/1255/1255_words_example_updated.png" alt="figA" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Generate a frequency array where <code>freq[c]</code> is the number of times letter <code>c</code> appears in <code>letters</code>.</li>
<li>Initialize <code>maxScore</code> to store the largest score among valid subsets.</li>
<li>Use a for loop that goes from <span class="math inline">\(0\)</span> (inclusive) to <span class="math inline">\(2^W\)</span> (exclusive) where <span class="math inline">\(W\)</span> is the length of <code>words</code> to iterate over every subset using masks. For each mask, word <span class="math inline">\(i\)</span> is in this subset if the <span class="math inline">\(i^{\texttt{th}}\)</span> bit is set in the current mask.</li>
<li>For each word in the current subset, increment <code>subsetLetters[c]</code> for each letter <code>c</code> in the word.</li>
<li>Declare a helper function, <code>subsetScore,</code> that checks if the subset can be built out of the given letters and calculates the score:
<ul>
<li>Initialize a variable <code>totalScore</code> to <code>0</code>.</li>
<li>For each character in the alphabet, compute the score of this subset by adding <code>score[c]</code> for every occurrence of <code>c</code> in this subset, and add it to <code>totalScore</code>.  If <code>freq[c] &lt; subsetLetters[c]</code> holds true for any letter <code>c</code>, then return <span class="math inline">\(0\)</span>, as this subset is impossible to construct with the given letters.</li>
<li>Return <code>totalScore</code>.</li>
</ul>
</li>
<li>If <code>maxScore</code> is less than the result of <code>subsetScore</code>, update <code>maxScore</code>.</li>
<li>Return <code>maxScore</code> after all subsets are checked.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Rkobsw98/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(W\)</span> be the length of <code>words</code>, <span class="math inline">\(L\)</span> be the maximum length of any word in <code>words</code>, and <span class="math inline">\(A\)</span> be the size of the alphabet (in this case, <span class="math inline">\(A = 26\)</span>).</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(2^W \cdot (WL + A))\)</span>.</li>
</ul>
<p>For each subset, we need to iterate through every string in this subset, which takes <span class="math inline">\(WL\)</span> time. Additionally, <span class="math inline">\(A\)</span> operations are needed to populate the <code>subsetLetters</code> array for each subset.</p>
<p>We have two choices for each word: it belongs in the subset, or it doesn't. This gives a total of <span class="math inline">\(2^W\)</span> possible subsets for <span class="math inline">\(W\)</span> words. Therefore, this yields a complexity of <span class="math inline">\(O(2^W(WL + A))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(A)\)</span>.</li>
</ul>
<p>In this implementation, only two arrays of length <span class="math inline">\(A\)</span> are created: the <code>freq</code> array, which stores the frequencies of characters in <code>letters</code>, and the <code>subsetLetters</code> array, which stores letter frequencies for the current subset.</p>
<hr />
<h3 id="approach-2-backtracking">Approach 2: Backtracking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Suppose the set of usable letters in a given input does not contain the letter &quot;d&quot;, and the set of words is <code>[&quot;abcd&quot;, &quot;acc&quot;, &quot;abb&quot;, &quot;bc&quot;]</code>. Note that any subset containing the word &quot;abcd&quot; is always invalid, because the word contains letter &quot;d&quot;. The iterative approach will continue to check every subset that contains &quot;abcd&quot;, which results in a considerable amount of unnecessary computation. What if we had a way to prune all subsets containing the word &quot;abcd&quot;? This is where a recursive solution comes into play.</p>
<p>Rather than iteratively checking every subset of words, we can use a recursive function to choose whether we include or exclude the current word in a candidate subset. If we pass the <code>subsetLetters</code> array as a parameter throughout every recursive call, after the addition of a word to a subset, we can check if there is a letter <code>c</code> where <code>subsetLetters[c]</code> exceeds <code>freq[c]</code> (see the <code>isValidWord</code> method). Once a recursive call terminates, we can roll back any changes made by the current recursive call to extensively search for all possibilities.</p>
<p>This approach is called backtracking, which is a search strategy that visits states and rolls back changes to return to a previous state. Doing so allows you to explore all branches from one state. For more details, see our <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">backtracking explore card</a>.</p>
<p>The base case is when all words have been considered for the subset, which is handled by comparing <code>maxScore</code> with <code>totalScore</code> and updating <code>maxScore</code> if <code>totalScore</code> is larger. The recursive case considers two choices: adding the <span class="math inline">\(i^{\texttt{th}}\)</span> word or not adding the <span class="math inline">\(i^{\texttt{th}}\)</span> word. This generates the subsets that will eventually either reach the base case or get pruned because that subset is not valid.</p>
<p>One notable merit of this backtracking solution lies in the pruning of bad subsets. If there is a set of subsets that share the same words that break the limits imposed by the given letters, the recursive algorithm can choose not to continue the search down this branch. For example, if the first word cannot be constructed, this recursive algorithm would immediately cut out any subset containing the first word, whereas an iterative solution would still check every subset that contains the first word.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Generate a frequency array where <code>freq[c]</code> is the number of times letter <code>c</code> appears in <code>letters</code>.</li>
<li>Initialize <code>maxScore</code> to store the largest score among valid subsets.</li>
<li>Call a recursive subroutine <code>check</code> that passes <code>w</code> (the index of the current word), <code>words</code>, <code>score</code>, <code>subsetLetters</code>, and <code>totalScore</code> (the sum of word scores in the subset) as parameters. Steps 4-10 describe the <code>check</code> method.</li>
<li>If <code>w</code> equals <span class="math inline">\(-1\)</span>, all words have been considered, and we should update <code>maxScore</code> to <code>totalScore</code> if <code>maxScore</code> is less than <code>totalScore</code>.</li>
<li>Otherwise, we need to consider two possible recursive calls: one that adds <code>words[w]</code> to the subset, and one that doesn't.</li>
<li>To account for not adding a word, call <code>check(w - 1, words, score, subsetLetters, totalScore)</code>.</li>
<li>To add <code>words[w]</code> to the subset, update <code>subsetLetters</code> and <code>totalScore</code> to include the word.</li>
<li>If the addition of <code>words[w]</code> does not violate letter limits imposed by <code>freq</code>, make the recursive call <code>check(w - 1, words, score, subsetLetters, totalScore)</code>. To check for validity, we define the <code>isValidWord</code> method as follows:
<ul>
<li>For each character in the alphabet, check if <code>freq[c] &lt; subsetLetters[c]</code>. If there exists such <code>c</code>, return <code>false</code>.</li>
<li>Return <code>true</code> if the subset can be built out of the given letters.</li>
</ul>
</li>
<li>Roll back the changes to <code>subsetLetters</code> and <code>totalScore</code> immediately after making this recursive call.</li>
<li>Call <code>check(W - 1, words, score, subsetLetters, 0)</code>, where <code>subsetLetters</code> is initially all zeros.</li>
<li>Return <code>maxScore</code> as the result.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nZ2w8A7G/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(W\)</span> be the length of <code>words</code>, <span class="math inline">\(L\)</span> be the maximum length of any word in <code>words</code>, and <span class="math inline">\(A\)</span> be the size of the alphabet (in this case, <span class="math inline">\(A = 26\)</span>).</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(2^W \cdot (L + A))\)</span>.</li>
</ul>
<p>There are a total of <span class="math inline">\(2^W\)</span> subsets that could be checked, and the <code>check</code> function could be called for each one, or up to <span class="math inline">\(2^W\)</span> times. Inside the <code>check</code> function, we iterate through the current word's letters to determine if the subset it currently belongs in is valid, which takes <span class="math inline">\(L\)</span> time. Additionally, the <code>isValidWord</code> function takes <span class="math inline">\(A\)</span> time because we compare the count of each letter in the alphabet with the frequency. This yields a complexity of <span class="math inline">\(O(2^W(L + A)\)</span>.</p>
<p>While the worst-case runtime of backtracking matches the worst-case runtime of the iterative solution, in practice, the backtracking solution will prune many subset possibilities that break the limits imposed by the given letters and will run significantly faster than the iterative solution.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(A + W)\)</span>.</li>
</ul>
<p>In this implementation, only two arrays of length <span class="math inline">\(A\)</span> are created: the <code>freq</code> array that stores the frequencies of characters in <code>letters</code>, and the <code>subsetLetters</code> array that stores letter frequencies for the current subset. Additionally, the <code>check</code> method is called with and without each element in <code>words</code>, which incurs <span class="math inline">\(O(W)\)</span> space on the recursive call stack.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-students-taking-exam/description" target="_blank" rel="noopener noreferrer">Maximum Students Taking Exam</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m&nbsp;* n</code>&nbsp;matrix <code>seats</code>&nbsp;&nbsp;that represent seats distributions&nbsp;in a classroom.&nbsp;If a seat&nbsp;is&nbsp;broken, it is denoted by <code>&#39;#&#39;</code> character otherwise it is denoted by a <code>&#39;.&#39;</code> character.</p>

<p>Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting&nbsp;directly in front or behind him. Return the <strong>maximum </strong>number of students that can take the exam together&nbsp;without any cheating being possible.</p>

<p>Students must be placed in seats in good condition.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img height="200" src="https://assets.leetcode.com/uploads/2020/01/29/image.png" width="339" />
<pre>
<strong>Input:</strong> seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],
&nbsp;               [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;],
&nbsp;               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Teacher can place 4 students in available seats so they don&#39;t cheat on the exam. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> seats = [[&quot;.&quot;,&quot;#&quot;],
&nbsp;               [&quot;#&quot;,&quot;#&quot;],
&nbsp;               [&quot;#&quot;,&quot;.&quot;],
&nbsp;               [&quot;#&quot;,&quot;#&quot;],
&nbsp;               [&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Place all students in available seats. 

</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> seats = [[&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;],
&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],
&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;],
&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],
&nbsp;               [&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> 10
<strong>Explanation:</strong> Place students in available seats in column 1, 3 and 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>seats</code>&nbsp;contains only characters&nbsp;<code>&#39;.&#39;<font face="sans-serif, Arial, Verdana, Trebuchet MS">&nbsp;and</font></code><code>&#39;#&#39;.</code></li>
	<li><code>m ==&nbsp;seats.length</code></li>
	<li><code>n ==&nbsp;seats[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 8</code></li>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Connect Two Groups of Points</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two groups of points where the first group has <code>size<sub>1</sub></code> points, the second group has <code>size<sub>2</sub></code> points, and <code>size<sub>1</sub> &gt;= size<sub>2</sub></code>.</p>

<p>The <code>cost</code> of the connection between any two points are given in an <code>size<sub>1</sub> x size<sub>2</sub></code> matrix where <code>cost[i][j]</code> is the cost of connecting point <code>i</code> of the first group and point <code>j</code> of the second group. The groups are connected if <strong>each point in both groups is connected to one or more points in the opposite group</strong>. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.</p>

<p>Return <em>the minimum cost it takes to connect the two groups</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/ex1.jpg" style="width: 322px; height: 243px;" />
<pre>
<strong>Input:</strong> cost = [[15, 96], [36, 2]]
<strong>Output:</strong> 17
<strong>Explanation</strong>: The optimal way of connecting the groups is:
1--A
2--B
This results in a total cost of 17.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/ex2.jpg" style="width: 322px; height: 403px;" />
<pre>
<strong>Input:</strong> cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
<strong>Output:</strong> 4
<strong>Explanation</strong>: The optimal way of connecting the groups is:
1--A
2--B
2--C
3--A
This results in a total cost of 4.
Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
<strong>Output:</strong> 10
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>size<sub>1</sub> == cost.length</code></li>
	<li><code>size<sub>2</sub> == cost[i].length</code></li>
	<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>
	<li><code>size<sub>1</sub> &gt;= size<sub>2</sub></code></li>
	<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-incompatibility/description" target="_blank" rel="noopener noreferrer">Minimum Incompatibility</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>​​​ and an integer <code>k</code>. You are asked to distribute this array into <code>k</code> subsets of <strong>equal size</strong> such that there are no two equal elements in the same subset.</p>

<p>A subset&#39;s <strong>incompatibility</strong> is the difference between the maximum and minimum elements in that array.</p>

<p>Return <em>the <strong>minimum possible sum of incompatibilities</strong> of the </em><code>k</code> <em>subsets after distributing the array optimally, or return </em><code>-1</code><em> if it is not possible.</em></p>

<p>A subset is a group integers that appear in the array with no particular order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,4], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> The optimal distribution of subsets is [1,2] and [1,4].
The incompatibility is (2-1) + (4-1) = 4.
Note that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,3,8,1,3,1,2,2], k = 4
<strong>Output:</strong> 6
<strong>Explanation:</strong> The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].
The incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,3,6,3,3], k = 3
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>
	<li><code>nums.length</code> is divisible by <code>k</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-increments-for-target-multiples-in-an-array/description" target="_blank" rel="noopener noreferrer">Minimum Increments for Target Multiples in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays, <code>nums</code> and <code>target</code>.</p>

<p>In a single operation, you may increment any element of <code>nums</code> by 1.</p>

<p>Return <strong>the minimum number</strong> of operations required so that each element in <code>target</code> has <strong>at least</strong> one multiple in <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3], target = [4]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum number of operations required to satisfy the condition is 1.</p>

<ul>
	<li>Increment 3 to 4 with just one operation, making 4 a multiple of itself.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [8,4], target = [10,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum number of operations required to satisfy the condition is 2.</p>

<ul>
	<li>Increment 8 to 10 with 2 operations, making 10 a multiple of both 5 and 10.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [7,9,10], target = [7]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>Target 7 already has a multiple in nums, so no additional operations are needed.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= target.length &lt;= 4</code></li>
	<li><code>target.length &lt;= nums.length</code></li>
	<li><code>1 &lt;= nums[i], target[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/description" target="_blank" rel="noopener noreferrer">Minimum Number of Work Sessions to Finish the Tasks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> tasks assigned to you. The task times are represented as an integer array <code>tasks</code> of length <code>n</code>, where the <code>i<sup>th</sup></code> task takes <code>tasks[i]</code> hours to finish. A <strong>work session</strong> is when you work for <strong>at most</strong> <code>sessionTime</code> consecutive hours and then take a break.</p>

<p>You should finish the given tasks in a way that satisfies the following conditions:</p>

<ul>
	<li>If you start a task in a work session, you must complete it in the <strong>same</strong> work session.</li>
	<li>You can start a new task <strong>immediately</strong> after finishing the previous one.</li>
	<li>You may complete the tasks in <strong>any order</strong>.</li>
</ul>

<p>Given <code>tasks</code> and <code>sessionTime</code>, return <em>the <strong>minimum</strong> number of <strong>work sessions</strong> needed to finish all the tasks following the conditions above.</em></p>

<p>The tests are generated such that <code>sessionTime</code> is <strong>greater</strong> than or <strong>equal</strong> to the <strong>maximum</strong> element in <code>tasks[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [1,2,3], sessionTime = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can finish the tasks in two work sessions.
- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.
- Second work session: finish the third task in 3 hours.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [3,1,3,1,1], sessionTime = 8
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can finish the tasks in two work sessions.
- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.
- Second work session: finish the last task in 1 hour.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tasks = [1,2,3,4,5], sessionTime = 15
<strong>Output:</strong> 1
<strong>Explanation:</strong> You can finish all the tasks in one work session.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == tasks.length</code></li>
	<li><code>1 &lt;= n &lt;= 14</code></li>
	<li><code>1 &lt;= tasks[i] &lt;= 10</code></li>
	<li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-break-locks-i/description" target="_blank" rel="noopener noreferrer">Minimum Time to Break Locks I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Bob is stuck in a dungeon and must break <code>n</code> locks, each requiring some amount of <strong>energy</strong> to break. The required energy for each lock is stored in an array called <code>strength</code> where <code>strength[i]</code> indicates the energy needed to break the <code>i<sup>th</sup></code> lock.</p>

<p>To break a lock, Bob uses a sword with the following characteristics:</p>

<ul>
	<li>The initial energy of the sword is 0.</li>
	<li>The initial factor <code><font face="monospace">x</font></code> by which the energy of the sword increases is 1.</li>
	<li>Every minute, the energy of the sword increases by the current factor <code>x</code>.</li>
	<li>To break the <code>i<sup>th</sup></code> lock, the energy of the sword must reach <strong>at least</strong> <code>strength[i]</code>.</li>
	<li>After breaking a lock, the energy of the sword resets to 0, and the factor <code>x</code> increases by a given value <code>k</code>.</li>
</ul>

<p>Your task is to determine the <strong>minimum</strong> time in minutes required for Bob to break all <code>n</code> locks and escape the dungeon.</p>

<p>Return the <strong>minimum </strong>time required for Bob to break all <code>n</code> locks.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">strength = [3,4,1], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Time</th>
			<th style="border: 1px solid black;">Energy</th>
			<th style="border: 1px solid black;">x</th>
			<th style="border: 1px solid black;">Action</th>
			<th style="border: 1px solid black;">Updated x</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Break 3<sup>rd</sup> Lock</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">Break 2<sup>nd</sup> Lock</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">Break 1<sup>st</sup> Lock</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
	</tbody>
</table>

<p>The locks cannot be broken in less than 4 minutes; thus, the answer is 4.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">strength = [2,5,4], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Time</th>
			<th style="border: 1px solid black;">Energy</th>
			<th style="border: 1px solid black;">x</th>
			<th style="border: 1px solid black;">Action</th>
			<th style="border: 1px solid black;">Updated x</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Break 1<sup>st</sup> Lock</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">Break 2<sup>n</sup><sup>d</sup> Lock</td>
			<td style="border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">Break 3<sup>r</sup><sup>d</sup> Lock</td>
			<td style="border: 1px solid black;">7</td>
		</tr>
	</tbody>
</table>

<p>The locks cannot be broken in less than 5 minutes; thus, the answer is 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == strength.length</code></li>
	<li><code>1 &lt;= n &lt;= 8</code></li>
	<li><code>1 &lt;= K &lt;= 10</code></li>
	<li><code>1 &lt;= strength[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-transport-all-individuals/description" target="_blank" rel="noopener noreferrer">Minimum Time to Transport All Individuals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">shortest-path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>n</code> individuals at a base camp who need to cross a river to reach a destination using a single boat. The boat can carry at most <code>k</code> people at a time. The trip is affected by environmental conditions that vary <strong>cyclically</strong> over <code>m</code> stages.</p>

<p>Each stage <code>j</code> has a speed multiplier <code>mul[j]</code>:</p>

<ul>
	<li>If <code>mul[j] &gt; 1</code>, the trip slows down.</li>
	<li>If <code>mul[j] &lt; 1</code>, the trip speeds up.</li>
</ul>

<p>Each individual <code>i</code> has a rowing strength represented by <code>time[i]</code>, the time (in minutes) it takes them to cross alone in neutral conditions.</p>

<p><strong>Rules:</strong></p>

<ul>
	<li>A group <code>g</code> departing at stage <code>j</code> takes time equal to the <strong>maximum</strong> <code>time[i]</code> among its members, multiplied by <code>mul[j]</code> minutes to reach the destination.</li>
	<li>After the group crosses the river in time <code>d</code>, the stage advances by <code>floor(d) % m</code> steps.</li>
	<li>If individuals are left behind, one person must return with the boat. Let <code>r</code> be the index of the returning person, the return takes <code>time[r] &times; mul[current_stage]</code>, defined as <code>return_time</code>, and the stage advances by <code>floor(return_time) % m</code>.</li>
</ul>

<p>Return the <strong>minimum</strong> total time required to transport all individuals. If it is not possible to transport all individuals to the destination, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 1, k = 1, m = 2, time = [5], mul = [1.0,1.3]</span></p>

<p><strong>Output:</strong> <span class="example-io">5.00000</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Individual 0 departs from stage 0, so crossing time = <code>5 &times; 1.00 = 5.00</code> minutes.</li>
	<li>All team members are now at the destination. Thus, the total time taken is <code>5.00</code> minutes.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, k = 2, m = 3, time = [2,5,8], mul = [1.0,1.5,0.75]</span></p>

<p><strong>Output:</strong> <span class="example-io">14.50000</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal strategy is:</p>

<ul>
	<li>Send individuals 0 and 2 from the base camp to the destination from stage 0. The crossing time is <code>max(2, 8) &times; mul[0] = 8 &times; 1.00 = 8.00</code> minutes. The stage advances by <code>floor(8.00) % 3 = 2</code>, so the next stage is <code>(0 + 2) % 3 = 2</code>.</li>
	<li>Individual 0 returns alone from the destination to the base camp from stage 2. The return time is <code>2 &times; mul[2] = 2 &times; 0.75 = 1.50</code> minutes. The stage advances by <code>floor(1.50) % 3 = 1</code>, so the next stage is <code>(2 + 1) % 3 = 0</code>.</li>
	<li>Send individuals 0 and 1 from the base camp to the destination from stage 0. The crossing time is <code>max(2, 5) &times; mul[0] = 5 &times; 1.00 = 5.00</code> minutes. The stage advances by <code>floor(5.00) % 3 = 2</code>, so the final stage is <code>(0 + 2) % 3 = 2</code>.</li>
	<li>All team members are now at the destination. The total time taken is <code>8.00 + 1.50 + 5.00 = 14.50</code> minutes.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, k = 1, m = 2, time = [10,10], mul = [2.0,2.0]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1.00000</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Since the boat can only carry one person at a time, it is impossible to transport both individuals as one must always return. Thus, the answer is <code>-1.00</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == time.length &lt;= 12</code></li>
	<li><code>1 &lt;= k &lt;= 5</code></li>
	<li><code>1 &lt;= m &lt;= 5</code></li>
	<li><code>1 &lt;= time[i] &lt;= 100</code></li>
	<li><code>m == mul.length</code></li>
	<li><code>0.5 &lt;= mul[i] &lt;= 2.0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-xor-sum-of-two-arrays/description" target="_blank" rel="noopener noreferrer">Minimum XOR Sum of Two Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of length <code>n</code>.</p>

<p>The <strong>XOR sum</strong> of the two integer arrays is <code>(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])</code> (<strong>0-indexed</strong>).</p>

<ul>
	<li>For example, the <strong>XOR sum</strong> of <code>[1,2,3]</code> and <code>[3,2,1]</code> is equal to <code>(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4</code>.</li>
</ul>

<p>Rearrange the elements of <code>nums2</code> such that the resulting <strong>XOR sum</strong> is <b>minimized</b>.</p>

<p>Return <em>the <strong>XOR sum</strong> after the rearrangement</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2], nums2 = [2,3]
<strong>Output:</strong> 2
<b>Explanation:</b> Rearrange <code>nums2</code> so that it becomes <code>[3,2]</code>.
The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,0,3], nums2 = [5,3,4]
<strong>Output:</strong> 8
<b>Explanation:</b> Rearrange <code>nums2</code> so that it becomes <code>[5,4,3]</code>. 
The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length</code></li>
	<li><code>n == nums2.length</code></li>
	<li><code>1 &lt;= n &lt;= 14</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-squareful-arrays/description" target="_blank" rel="noopener noreferrer">Number of Squareful Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An array is <strong>squareful</strong> if the sum of every pair of adjacent elements is a <strong>perfect square</strong>.</p>

<p>Given an integer array nums, return <em>the number of permutations of </em><code>nums</code><em> that are <strong>squareful</strong></em>.</p>

<p>Two permutations <code>perm1</code> and <code>perm2</code> are different if there is some index <code>i</code> such that <code>perm1[i] != perm2[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,17,8]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [1,8,17] and [17,8,1] are the valid permutations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 12</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/description" target="_blank" rel="noopener noreferrer">Number of Ways to Wear Different Hats to Each Other</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> people and <code>40</code> types of hats labeled from <code>1</code> to <code>40</code>.</p>

<p>Given a 2D integer array <code>hats</code>, where <code>hats[i]</code> is a list of all hats preferred by the <code>i<sup>th</sup></code> person.</p>

<p>Return the number of ways that <code>n</code> people can wear <strong>different</strong> hats from each other.</p>

<p>Since the answer may be too large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> hats = [[3,4],[4,5],[5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is only one way to choose hats given the conditions. 
First person choose hat 3, Second person choose hat 4 and last one hat 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> hats = [[3,5,1],[3,5]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 ways to choose hats:
(3,5), (5,3), (1,3) and (1,5)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
<strong>Output:</strong> 24
<strong>Explanation:</strong> Each person can choose hats labeled from 1 to 4.
Number of Permutations of (1,2,3,4) = 24.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == hats.length</code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>1 &lt;= hats[i].length &lt;= 40</code></li>
	<li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>
	<li><code>hats[i]</code> contains a list of <strong>unique</strong> integers.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-top-down-dynamic-programming--bitmasks">Approach 1: Top-Down Dynamic Programming + Bitmasks</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>In this editorial, we will assume that you are already familiar with the principles of dynamic programming, such as breaking problems into subproblems, base cases, and recurrence relations. If you are not already familiar with dynamic programming, we recommend checking out the <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming explore card</a> and practicing other DP problems first, as this problem is very difficult.</p>
</blockquote>
<p>An intuitive way to solve this problem would be to iterate over the people, and for each person, select one of their preferred hats. We keep track of hats that have already been placed and only select a preferred hat if it is free. If we manage to select a hat for each person, we have found a way to place the hats.</p>
<p>The problem with this approach is that there can be up to <span class="math inline">\(40\)</span> hats. Each of the hats can either be taken or free, which means there would be <span class="math inline">\(2^{40}\)</span> states regarding the hats, which is over 1 trillion. This is way too big and will certainly TLE.</p>
<p>Notice that the constraints state that while there can be up to <span class="math inline">\(40\)</span> hats, there can only be up to <span class="math inline">\(10\)</span> people. How can we use this to our advantage?</p>
<p>Instead of tracking which hats are free, let's instead track which people don't have a hat yet. Instead of iterating over the people to select a hat, we will iterate over the hats and select people.</p>
<p>This would change our strategy. In the slow approach, we iterate over each person, and for the current person, select any hat that is preferred and free. In the new approach, we iterate over the hats, and for each hat, place it on any person that prefers it and does not already have a hat. The key difference is that in the slow approach, we need to track which hats are free, and in the new approach, we need to track which people don't already have a hat.</p>
<table>
<thead>
<tr>
<th align="center">Idea</th>
<th align="center">Slow approach</th>
<th align="center">New approach</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Strategy</td>
<td align="center">Iterate over people, select a free and preferred hat</td>
<td align="center">Iterate over hats, select a person that prefers the current hat and isn't already wearing one</td>
</tr>
<tr>
<td align="center">Tracking</td>
<td align="center">Keep track of which hats are free</td>
<td align="center">Keep track of which people don't have a hat yet</td>
</tr>
<tr>
<td align="center">State space</td>
<td align="center"><span class="math inline">\(n \cdot 2^k \leq 10^{13}\)</span></td>
<td align="center"><span class="math inline">\(k \cdot 2^n \leq 40960\)</span></td>
</tr>
</tbody>
</table>
<br>
<p>Given <span class="math inline">\(n \leq 10\)</span> as the number of people and <span class="math inline">\(k \leq 40\)</span> as the number of hats, the new approach is many orders of magnitudes faster.</p>
<p>To implement this new approach, we will need to map each hat to a list of people that prefer the hat. Let's use a hash map <code>hatsToPeople</code> for this. It maps an integer <code>hat</code> to a list of integers that represents all the people that prefer <code>hat</code>.</p>
<p><img src="../Figures/1434/1.png" width="960"> <br></p>
<p>Now that we have <code>hatsToPeople</code>, we can delve into our DP strategy.</p>
<p>Let's define a function <code>dp(hat, mask)</code>. <code>hat</code> represents the current hat we are trying to place. <code>mask</code> is a bitmask that denotes which people are already wearing a hat. <code>dp</code> will return how many ways there are to place the hats in the range <code>[hat, 40]</code> such that everyone will end up wearing a hat. The answer to our problem will be <code>dp(1, 0)</code>. We start with the first hat, and nobody is wearing a hat initially. Here, the <span class="math inline">\(i^{th}\)</span> bit of <code>mask</code> is set if the <span class="math inline">\(i^{th}\)</span> person is wearing a hat.</p>
<details>
    <summary>
        <b> &ensp; If you are not familiar with bit manipulation, click here to expand. </b>
    </summary>
<br />
<p>Bit manipulation is the act of manipulating bits, like changing bits of an integer.<br />
At the heart of bit manipulation are the bit-wise operators:</p>
<p><strong>NOT (~):</strong> Bitwise NOT is a unary operator that flips the bits of the number i.e., if the current bit is <span class="math inline">\(0\)</span>, it will change it to <span class="math inline">\(1\)</span> and vice versa.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>N = 5 = 101 (in binary)
</span></span><span style="display:flex;"><span>~N = ~(101) = 010 = 2 (in decimal)
</span></span></code></pre><p><strong>AND (&amp;):</strong> In bitwise AND if both bits in the compared position of the bit patterns are <span class="math inline">\(1\)</span>, the bit in the resulting bit pattern is <span class="math inline">\(1\)</span>, otherwise <span class="math inline">\(0\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 5 = 101 (in binary)
</span></span><span style="display:flex;"><span>B = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A &amp; B = 101 &amp; 001 = 001 = 1 (in decimal)
</span></span></code></pre><p><strong>OR ( | ):</strong> Bitwise OR is also similar to bitwise AND. If both bits in the compared position of the bit patterns are <span class="math inline">\(0\)</span>, the bit in the resulting bit pattern is <span class="math inline">\(0\)</span>, otherwise <span class="math inline">\(1\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 5 = 101 (in binary) 
</span></span><span style="display:flex;"><span>B = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A | B = 101 | 001 = 101 = 5 (in decimal)
</span></span></code></pre><p><strong>XOR (^):</strong> In bitwise XOR if both bits are <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>, the result will be <span class="math inline">\(0\)</span>, otherwise <span class="math inline">\(1\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 5 = 101 (in binary) 
</span></span><span style="display:flex;"><span>B = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A ^ B = 101 ^ 001 = 100 = 4 (in decimal)
</span></span></code></pre><p><strong>Left Shift (&lt;&lt;):</strong> Left shift operator is a binary operator which shifts some number of bits to the left and appends <span class="math inline">\(0\)</span> at the end. One left shift is equivalent to multiplying the bit pattern with <span class="math inline">\(2\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A &lt;&lt; 1 = 001 &lt;&lt; 1 = 010 = 2 (in decimal)
</span></span><span style="display:flex;"><span>A &lt;&lt; 2 = 001 &lt;&lt; 2 = 100 = 4 (in decimal)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B = 5 = 00101 (in binary)
</span></span><span style="display:flex;"><span>B &lt;&lt; 1 = 00101 &lt;&lt; 1 = 01010 = 10 (in decimal)
</span></span><span style="display:flex;"><span>B &lt;&lt; 2 = 00101 &lt;&lt; 2 = 10100 = 20 (in decimal)
</span></span></code></pre><p><strong>Right Shift (&gt;&gt;):</strong> Right shift operator is a binary operator which shifts some number of bits to the right and appends <span class="math inline">\(0\)</span> at the left side. One right shift is equivalent to dividing the bit pattern with <span class="math inline">\(2\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 4 = 100 (in binary) 
</span></span><span style="display:flex;"><span>A &gt;&gt; 1 = 100 &gt;&gt; 1 = 010 = 2 (in decimal)
</span></span><span style="display:flex;"><span>A &gt;&gt; 2 = 100 &gt;&gt; 2 = 001 = 1 (in decimal)
</span></span><span style="display:flex;"><span>A &gt;&gt; 3 = 100 &gt;&gt; 3 = 000 = 0 (in decimal)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B = 5 = 00101 (in binary)
</span></span><span style="display:flex;"><span>B &gt;&gt; 1 = 00101 &gt;&gt; 1 = 00010 = 2 (in decimal)
</span></span></code></pre></details>
<br />
<p>Let's talk about the recurrence relation now. Given a state <code>(hat, mask)</code>, we have two options. Place the hat on someone or skip it. If we skip it, there are <code>dp(hat + 1, mask)</code> ways to solve the problem. We simply move on to the next hat without changing <code>mask</code>.</p>
<p>The other option is to place the hat. We iterate over <code>hatsToPeople[hat]</code>, which holds a list of all the people that prefer this hat. For each <code>person</code>, we check if the bit at position <code>person</code> is set in <code>mask</code>. If it's not set, it means <code>person</code> both prefers <code>hat</code> and is also not currently wearing a hat - therefore we could place <code>hat</code> on <code>person</code>. To do this, we need to set the bit in <code>mask</code>, which we can do with <code>mask | (1 &lt;&lt; person)</code>. There are <code>dp(hat + 1, mask | (1 &lt;&lt; person))</code> ways to solve the problem after this decision.</p>
<p>The answer to a state <code>(hat, mask)</code> is the sum of all these possibilities.</p>
<p>Our <code>dp</code> function has two base cases.</p>
<p>First, if we manage to give everyone a hat, then we <code>return 1</code>. We can detect this by checking if all bits in <code>mask</code> are set. We initialize a value <code>done</code> which is equal to <span class="math inline">\(2^n - 1\)</span>, where <span class="math inline">\(n\)</span> is the number of people. If <code>mask == done</code>, it means everyone has a hat.</p>
<p>Second, if <code>hat &gt; 40</code>, we have run out of hats. It is impossible to complete the task now, so we <code>return 0</code>.</p>
<p>Don't forget to memoize the function and perform all arithmetic mod <span class="math inline">\(10^9 + 7\)</span>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a few variables:
<ul>
<li><code>n</code> as the number of people.</li>
<li><code>done</code> as <span class="math inline">\(2^n - 1\)</span>.</li>
<li><code>MOD</code> as <span class="math inline">\(10^9 + 7\)</span>.</li>
<li><code>memo</code> as a 2D array of size <code>41 * done</code> (in Python we don't need to do this as we will use <code>@functools.cache</code> to memoize).</li>
<li><code>hatsToPeople</code> as a hash map that maps integers to lists of integers.</li>
</ul>
</li>
<li>Fill <code>memo</code> with <code>-1</code> to denote that a given state has not yet been calculated.</li>
<li>Iterate over <code>hats</code> and populate <code>hatsToPeople</code> by mapping each <code>hat</code> to the people that prefer it.</li>
</ol>
<p>Now, we can implement the <code>dp(hat, mask)</code> function.</p>
<ul>
<li>If <code>mask == done</code>, then <code>return 1</code>.</li>
<li>If <code>hat &gt; 40</code>, then <code>return 0</code>.</li>
<li>If <code>memo[hat][mask] != -1</code>, then return it as we have already calculated this state.</li>
<li>Otherwise, we need to calculate this state. Initialize <code>ans = dp(hat + 1, mask)</code> which skips this hat.</li>
<li>Iterate over <code>hatsToPeople[hat]</code>. For each <code>person</code> that prefers <code>hat</code>:
<ul>
<li>Check if the bit at position <code>person</code> is set. You can do this with <code>mask &amp; (1 &lt;&lt; person)</code>.</li>
<li>If it isn't set, then add <code>dp(hat + 1, mask | (1 &lt;&lt; person))</code> to <code>ans</code> and take it <code>% MOD</code>.</li>
</ul>
</li>
<li>Set <code>memo[hat][mask] = ans</code> and return it.</li>
</ul>
<ol start="4">
<li>Return <code>dp(1, 0)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>We are using <a href="https://docs.python.org/3/library/functools.html">@functools.cache</a> in Python for memoization.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/b7LeTJPj/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of people and <span class="math inline">\(k\)</span> as the number of hats,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \cdot n \cdot 2^n)\)</span></p>
<p>There are <span class="math inline">\(k\)</span> states for <code>hat</code> and <span class="math inline">\(2^n\)</span> states for <code>mask</code>. This gives us <span class="math inline">\(k \cdot 2^n\)</span> states in total for our DP. We never calculate a state more than once due to memoization. For each state, we iterate over <code>hatsToPeople</code>, which in the worst-case scenario costs <span class="math inline">\(O(n)\)</span>. This gives us a time complexity of <span class="math inline">\(O(k \cdot n \cdot 2^n)\)</span>.</p>
<p>Note that in this problem, <span class="math inline">\(k = 40\)</span> so one could argue the time complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>. However, it's good to maintain generality in case a follow-up states that <span class="math inline">\(k\)</span> could be variable.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k \cdot 2^n)\)</span></p>
<p>For memoization, we store the answer to states. As mentioned above, there can be up to <span class="math inline">\(O(k \cdot 2^n)\)</span> states. We also use additional space for <code>hatsToPeople</code> and the recursion call stack, but both of these are dominated by memoization.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-bottom-up-dynamic-programming">Approach 2: Bottom-Up Dynamic Programming</h3>
<p><strong>Intuition</strong></p>
<p>This is the same algorithm as in the previous approach, except we will implement it iteratively.</p>
<p>To convert a top-down algorithm to a bottom-up one, we use the same recurrence relation and base cases. However, we must be careful about the order in which we calculate the states. We need to start at the base cases and work our way up to the final answer <code>(hat = 1, mask = 0)</code>.</p>
<p>We use a nested for loop to iterate over each state of <code>(hat, mask)</code>. For the <code>hat</code> for loop, we start at <code>40</code> and iterate until <code>1</code>. For the <code>mask</code> for loop, we start at <code>done</code> and iterate until <code>0</code>.</p>
<p>Each iteration inside this nested for loop represents a state <code>(hat, mask)</code> which is equivalent to a function call in the previous approach. As such, we can basically copy paste the same logic in, as you'll see in the implementation section.</p>
<p>Note: when sizing our 2D <code>dp</code> array, we will need to have a size of <code>42 * (done + 1)</code>. It needs to be <code>42</code> because for hat <code>40</code>, we will reference <code>hat + 1</code> which is hat <code>41</code>. Of course, <code>dp</code> is 0-indexed, so accessing <code>dp[41]</code> will require a size of <code>42</code>. Similarly, accessing <code>dp[...][done]</code> will require that the inner arrays are sized <code>done + 1</code>.</p>
<p>Before initializing the <code>dp</code> calculation, we compute <code>hatsToPeople</code> just like we did in the previous approach and also set the base cases: <code>dp[hat][done] = 1</code> for all values of <code>hat</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a few variables:
<ul>
<li><code>n</code> as the number of people.</li>
<li><code>done</code> as <span class="math inline">\(2^n - 1\)</span>.</li>
<li><code>MOD</code> as <span class="math inline">\(10^9 + 7\)</span>.</li>
<li><code>hatsToPeople</code> as a hash map that maps integers to lists of integers.</li>
</ul>
</li>
<li>Iterate over <code>hats</code> and populate <code>hatsToPeople</code> by mapping each <code>hat</code> to the people that prefer it.</li>
<li>Initialize <code>dp</code> as a 2D array of size <code>42 * (done + 1)</code>. Fill in the base cases: <code>dp[hat][done] = 1</code> for all values of <code>hat</code>.</li>
</ol>
<p>Now, we can calculate <code>dp</code>. Use a nested for loop over <code>hat</code> and <code>mask</code>. Start <code>hat</code> at <code>40</code> and iterate until <code>1</code>. Start <code>mask</code> at <code>done</code> and iterate until <code>0</code>. For each iteration (<code>hat, mask</code>):</p>
<ul>
<li>Initialize <code>ans = dp[hat + 1][mask]</code>.</li>
<li>Iterate over <code>hatsToPeople[hat]</code>. For each <code>person</code> that prefers <code>hat</code>:
<ul>
<li>Check if the bit at position <code>person</code> is set. You can do this with <code>mask &amp; (1 &lt;&lt; person)</code>.</li>
<li>If it isn't set, then add <code>dp[hat + 1][mask | (1 &lt;&lt; person)]</code> to <code>ans</code> and take it <code>% MOD</code>.</li>
</ul>
</li>
<li>Set <code>dp[hat][mask] = ans</code>.</li>
</ul>
<ol start="4">
<li>Return <code>dp[1][0]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/WVF5MZE2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of people and <span class="math inline">\(k\)</span> as the number of hats,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \cdot n \cdot 2^n)\)</span></p>
<p>The time complexity is the same as the previous approach for the same reason. We calculate each state at most once, and each state requires up to <span class="math inline">\(O(n)\)</span> to calculate.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k \cdot 2^n)\)</span></p>
<p>The space complexity is the same as the previous approach for the same reason. We are storing the answer to all the states.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/temp-12-d2ff2715/" target="_blank" rel="noopener noreferrer">Optimal Way</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">introductiontodynamicprogramming1</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are provided an array <span class="mathjax-latex">\(Arr \)</span> of non-negative integers of size <span class="mathjax-latex">\(2*K\)</span>. In each round, pick any two integers from the array <span class="mathjax-latex">\(Arr \)</span> (<span class="mathjax-latex">\(number1\)</span> and <span class="mathjax-latex">\(number2\)</span>) and then eliminate both of them.&nbsp;<br>
The formula for your score in each round is =&nbsp;<span class="mathjax-latex">\(RoundNumber\)</span><span class="mathjax-latex">\(*( \)</span><span class="mathjax-latex">\(number1\)</span><span class="mathjax-latex">\(\&amp;\)</span><span class="mathjax-latex">\(number2). \)</span><br>
RoundNumber will start from <span class="mathjax-latex">\(1\)</span> till <span class="mathjax-latex">\(K\)</span>, and "<span class="mathjax-latex">\(number1\)</span><span class="mathjax-latex">\(\&amp;\)</span><span class="mathjax-latex">\(number2\)</span>" represents bitwise AND of <span class="mathjax-latex">\(number1\)</span> and <span class="mathjax-latex">\(number2 \)</span>. The total number of rounds is <span class="mathjax-latex">\(K\)</span>. The sum of the scores you will receive in each round will represent your final score. Return the maximum possible final score.&nbsp;<br>
<br>
<u><strong>Input Format:</strong></u></p>

<ul>
	<li>The first line contains an integer <span class="mathjax-latex">\(N\)</span>, where <span class="mathjax-latex">\(N\)</span> denotes the size of the array <span class="mathjax-latex">\(Arr\)</span>.</li>
	<li>The second line contains an interger <span class="mathjax-latex">\(K\)</span>.</li>
</ul>

<p><u><strong>Output Format:</strong></u></p>

<ul>
	<li>Print the maximum possible final score.</li>
</ul>

<p><u><strong>Constraints:</strong></u></p>

<ul>
	<li><span class="mathjax-latex">\(1 \le K \le 10\)</span></li>
	<li><span class="mathjax-latex">\(1 \leq N \leq 20\)</span></li>
	<li><span class="mathjax-latex">\(1 \le Arr[i] \le 10^7\)</span></li>
	<li><span class="mathjax-latex">\(N = 2*K\)</span></li>
</ul>

<p>&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Example: <span class="mathjax-latex">\(K\)</span> = 2, <span class="mathjax-latex">\(H\)</span> = [3,4,5,9].&nbsp;<br>
RoundNumber = 1, choose {3,9}, Score = 1*(3&amp;9) = 1*(1) = 1.<br>
RoundNumber = 2, choose {4,5}, Score = 2*(4&amp;5) = 2*(4) = 8.<br>
Final score = 1 + 8 = 9. The maximum possible final score is 9.&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/palindrome-lover-d7beb2b0/" target="_blank" rel="noopener noreferrer">Palindrome lover</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of <span class="mathjax-latex">\(N\)</span> integers</p>

<p>You have to transform the array, for every <span class="mathjax-latex">\(i (1 \leq i \leq N)\)</span><em><strong>:</strong> <span class="mathjax-latex">\(a[i] = a[i] \%2\)</span></em></p>

<p><strong>For example:</strong> if the given array is 3,4,5 then after the transformation the array will be 1,0,1</p>

<p><br>
Your task is to convert the array into a palindrome and for that you can re-arrange the elements however you wish</p>

<p>Is it possible to convert the array into a palindrome?</p>

<p><br>
<strong>Input :</strong><br>
The first line contains <em><span class="mathjax-latex">\(T\)</span></em>, the number of test cases <span class="mathjax-latex">\(1 \leq T \leq 10^3\)</span><br>
The second line contains<em> <span class="mathjax-latex">\(N\)</span></em>, the number of array elements <span class="mathjax-latex">\(1 \leq N \leq 10^5\)</span><br>
The third line contains<em> <span class="mathjax-latex">\(N\)</span></em> integers, the array elements <span class="mathjax-latex">\(1 \leq a[i] \leq 10^9\)</span></p>

<p><br>
<strong>Output:</strong><br>
For all test cases print <span class="mathjax-latex">\(1\)</span> if the array can be converted into a palindrome or else print <span class="mathjax-latex">\(0\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>For test case 1, the array will be transformed into 1,1,1 after mod with 2,<br>
The array is already a palindrome, so the output is 1</p>

<p>For test case 2, the array after transformation will be 1,0,1,1,1,1</p>

<p>Now no matter how you try to arrange them, it is impossible to convert the array into a palindrome,that's why the output is 0</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/parallel-courses-ii/description" target="_blank" rel="noopener noreferrer">Parallel Courses II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, which indicates that there are <code>n</code> courses labeled from <code>1</code> to <code>n</code>. You are also given an array <code>relations</code> where <code>relations[i] = [prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code>, representing a prerequisite relationship between course <code>prevCourse<sub>i</sub></code> and course <code>nextCourse<sub>i</sub></code>: course <code>prevCourse<sub>i</sub></code> has to be taken before course <code>nextCourse<sub>i</sub></code>. Also, you are given the integer <code>k</code>.</p>

<p>In one semester, you can take <strong>at most</strong> <code>k</code> courses as long as you have taken all the prerequisites in the <strong>previous</strong> semesters for the courses you are taking.</p>

<p>Return <em>the <strong>minimum</strong> number of semesters needed to take all courses</em>. The testcases will be generated such that it is possible to take every course.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_1.png" style="width: 269px; height: 147px;" />
<pre>
<strong>Input:</strong> n = 4, relations = [[2,1],[3,1],[1,4]], k = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> The figure above represents the given graph.
In the first semester, you can take courses 2 and 3.
In the second semester, you can take course 1.
In the third semester, you can take course 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_2.png" style="width: 271px; height: 211px;" />
<pre>
<strong>Input:</strong> n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> The figure above represents the given graph.
In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.
In the second semester, you can take course 4.
In the third semester, you can take course 1.
In the fourth semester, you can take course 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 15</code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li><code>0 &lt;= relations.length &lt;= n * (n-1) / 2</code></li>
	<li><code>relations[i].length == 2</code></li>
	<li><code>1 &lt;= prevCourse<sub>i</sub>, nextCourse<sub>i</sub> &lt;= n</code></li>
	<li><code>prevCourse<sub>i</sub> != nextCourse<sub>i</sub></code></li>
	<li>All the pairs <code>[prevCourse<sub>i</sub>, nextCourse<sub>i</sub>]</code> are <strong>unique</strong>.</li>
	<li>The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/parity-binary-sort-ea768e57/" target="_blank" rel="noopener noreferrer">Parity-Binary Sort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">implementation</span> <span class="topic-badge">mergesort</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <span class="mathjax-latex">\(A \)</span>&nbsp;of <span class="mathjax-latex">\(N\)</span> integers. Your task is to implement a sorting algorithm that arranges the numbers in the array based on following conditions and return that array:<br>
1. Numbers with an <strong>even </strong>count of set bits should appear first in <strong>ascending </strong>order.<br>
2. Following that, numbers with an <strong>odd</strong> count of set bits should be arranged in <strong>ascending </strong>order.</p>

<p><u><strong>Input Format:</strong></u></p>

<p><strong><em>Note</em>:</strong> <em>This is the input format that you must use to provide custom input (available above the Compile and Test button).</em></p>

<p>The first line contains <em><em><em><em><span class="mathjax-latex">\(T\)</span></em></em></em></em> denoting the number of test cases. <em><em><em><em><span class="mathjax-latex">\(T\)</span></em></em></em></em> also specifies the number of times you have to run the solve function on a different set of inputs.<br>
For each test case:</p>

<ul>
	<li>The first line contains the integer <em><em><em><em><span class="mathjax-latex">\(N\)</span></em></em></em></em>.</li>
	<li>The second line contains the array&nbsp;<span class="mathjax-latex">\(A\)</span>&nbsp;of length&nbsp;<em><em><em><em><span class="mathjax-latex">\(N\)</span></em></em></em></em></li>
</ul>

<p><u><strong>Output Format:</strong></u><br>
For each test case, print the answer in a new line.&nbsp;</p>

<p><u><strong>Constraints:</strong></u></p>

<p><strong><strong><strong><strong><span class="mathjax-latex">\(1 \leq T \leq 10 \\ 1 \leq N \leq 10^5 \\ 1 \leq A[i] \leq 10^5\)</span></strong></strong></strong></strong></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Given the input array [5, 2, 8, 12, 7, 6], the output should be [5, 6, 12, 2, 7, 8], as:<br>
Numbers with an even count of set bits: 5(101), 6(110), 12(1100)<br>
Numbers with an odd count of set bits: 2(10), 7(111), 8(100)</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/description" target="_blank" rel="noopener noreferrer">Partition Array Into Two Arrays to Minimize Sum Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">ordered-set</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of <code>2 * n</code> integers. You need to partition <code>nums</code> into <strong>two</strong> arrays of length <code>n</code> to <strong>minimize the absolute difference</strong> of the <strong>sums</strong> of the arrays. To partition <code>nums</code>, put each element of <code>nums</code> into <strong>one</strong> of the two arrays.</p>

<p>Return <em>the <strong>minimum</strong> possible absolute difference</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example-1" src="https://assets.leetcode.com/uploads/2021/10/02/ex1.png" style="width: 240px; height: 106px;" />
<pre>
<strong>Input:</strong> nums = [3,9,7,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> One optimal partition is: [3,9] and [7,3].
The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-36,36]
<strong>Output:</strong> 72
<strong>Explanation:</strong> One optimal partition is: [-36] and [36].
The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="example-3" src="https://assets.leetcode.com/uploads/2021/10/02/ex3.png" style="width: 316px; height: 106px;" />
<pre>
<strong>Input:</strong> nums = [2,-1,0,4,-2,-9]
<strong>Output:</strong> 0
<strong>Explanation:</strong> One optimal partition is: [2,4,-9] and [-1,0,-2].
The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 15</code></li>
	<li><code>nums.length == 2 * n</code></li>
	<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-to-k-equal-sum-subsets/description" target="_blank" rel="noopener noreferrer">Partition to K Equal Sum Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if it is possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,3,5,2,1], k = 4
<strong>Output:</strong> true
<strong>Explanation:</strong> It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], k = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li>The frequency of each element is in the range <code>[1, 4]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/prefix-gcd-maximization-932aa648/" target="_blank" rel="noopener noreferrer">Prefix GCD Maximization</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">1-d</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">dynamicprogrammingandbitmasking</span> <span class="topic-badge">introductiontodynamicprogramming1</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of size <strong><strong><span class="mathjax-latex">\(N\)</span></strong></strong>. Rearrange it in such a manner that the sum of the <strong>GCD</strong> over all the non-empty prefixes of the array is maximum.</p>

<p><strong>GCD</strong> here means greatest common divisior. It is the largest number which divides any set of numbers without leaving any remainder with any of them.</p>

<p><u><strong>Input format:</strong></u></p>

<ul>
	<li>The first line contains a single integer <strong><strong><span class="mathjax-latex">\(N\)</span></strong></strong>.</li>
	<li>The second line, contains <strong><strong><span class="mathjax-latex">\(N\)</span></strong></strong> space-separated integers, the array elements.&nbsp;</li>
</ul>

<p><u><strong>Output format:</strong></u></p>

<p>Print the answer —&nbsp;the maximum possible sum of all the prefix <strong>GCD</strong>'s of the rearranged array.</p>

<p><u><strong>Constraints:</strong></u></p>

<p><strong><strong><span class="mathjax-latex">\(1 \leq N \leq 20 \\ 1 \leq A_i \leq 10^9 \\ \)</span></strong></strong></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Here we can rearrange the array as <strong>12 6 8</strong>. This arrangemment the sum of the GCD of the prefix will be <strong>gcd(12)+gcd(12,6)+gcd(12,6,8).&nbsp;</strong>This would have the maximum possible sum of 20.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/prefix-xor-sum-0e16e052/" target="_blank" rel="noopener noreferrer">Prefix XOR Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">introductiontodynamicprogramming1</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <span class="mathjax-latex">\(A\)</span> containing <span class="mathjax-latex">\(N\)</span> integers and <span class="mathjax-latex">\(Q\)</span> queries. Each query is denoted by two integers <span class="mathjax-latex">\(L, R\)</span>. The answer to a query is&nbsp;<span class="mathjax-latex">\(A_L + (A_L \oplus A_{L+1}) + \dots + (A_L \oplus A_{L+1} \oplus \dots \oplus A_R)\)</span>, where&nbsp;<span class="mathjax-latex">\(\oplus\)</span>&nbsp;denotes the bitwise XOR operator.&nbsp;</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains two integers&nbsp;<span class="mathjax-latex">\(N\)</span><em>&nbsp;</em>denoting the size of array&nbsp;<em>A </em>and<em> </em>&nbsp;<span class="mathjax-latex">\(Q\)</span>&nbsp; denoting the number of queries:</li>
	<li>The second line contains&nbsp;<span class="mathjax-latex">\(N\)</span>&nbsp;space-separated integers <em><em><em><em><em><em><em><em><span class="mathjax-latex">\(A_1, A_2, \dots, A_N\)</span></em></em></em></em></em></em></em> </em>-&nbsp;denoting the elements of<em>&nbsp;A</em>.</li>
	<li>Each of the next&nbsp;<span class="mathjax-latex">\(Q\)</span>&nbsp; lines contains two integers&nbsp;<span class="mathjax-latex">\(L, R.\)</span></li>
</ul>

<p><strong>Output format</strong></p>

<p>For each test query, print the answer in a separate line.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \leq N, Q \leq 2\cdot 10^5\\ \\0\leq A_i \lt 2^{30} \\ 1 \le L \le R \le N\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The answer to the first query is&nbsp;<span class="mathjax-latex">\( = A_3 + (A_3 \oplus A_4) = 2 + (2 \oplus 6) = 2 + 4 = 6.\)</span></p>

<p>The answer to the second query is&nbsp;<span class="mathjax-latex">\( = A_1 + (A_1 \oplus A_2) + (A_1 \oplus A_2 \oplus A_3) = 1 + (1 \oplus 7) + (1 \oplus 7 \oplus 2) = 1 + 6 + 4 = 11.\)</span></p></div>
				</div>
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/reduce-the-array-2-2a1e3e02/" target="_blank" rel="noopener noreferrer">Reduce the Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">disjointsetunion</span> <span class="topic-badge">graphs</span> <span class="topic-badge">minimumspanningtree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <span class="mathjax-latex">\(N\)</span> numbers, and you are asked to minimize the total "<span class="mathjax-latex">\(OR \ \ cost\)</span>" incurred when reducing the array to a single number. To achieve this, you need to follow these steps:</p>

<ol>
	<li>Select any two numbers <span class="mathjax-latex">\(P\)</span> and <span class="mathjax-latex">\(Q\)</span> from the array. The cost of selecting these two numbers is <span class="mathjax-latex">\(((P + Q) + (P | Q) - (P &amp; Q))\)</span>, where "|" denotes the bitwise <span class="mathjax-latex">\(OR\)</span> operator, and "&amp;" denotes the bitwise <span class="mathjax-latex">\(AND\)</span> operator.</li>
	<li>
	<p>Choose one of the two numbers you selected in the previous step and remove it from the array. Concatenate the remaining numbers.</p>
	</li>
	<li>
	<p>Repeat the above two steps until the array is reduced to a single number.</p>
	</li>
</ol>

<p>The "<span class="mathjax-latex">\(OR\)</span> <span class="mathjax-latex">\(cost\)</span>" is defined as the bitwise <span class="mathjax-latex">\(OR\)</span> of all the costs incurred in reducing the array to a single number.</p>

<p>&nbsp;</p>

<p><u><strong>Input Format :</strong></u></p>

<p>An integer <span class="mathjax-latex">\(N\)</span> denoting the size of the array</p>

<p><span class="mathjax-latex">\(N\)</span> integers denoting the elements of the array</p>

<p><u><strong>Output Format :</strong></u></p>

<p>Print one integer, the minimum&nbsp;<span class="mathjax-latex">\(OR \ \ cost\)</span></p>

<p><u><strong>Constraints :</strong></u></p>

<p><u><strong><span class="mathjax-latex">\(1 \leq N \leq 10^3\)</span></strong></u></p>

<p><span class="mathjax-latex">\(1 \leq a_i \leq 10^6\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Sure, here's a possible rephrased version of the explanation:</p>

<p>Consider the following example array: [1, 5, 2, 3]. To minimize the total "OR cost," we can follow these steps:</p>

<ol>
	<li>
	<p>Select 1 and 5. Remove 5 from the array, and concatenate the remaining numbers [1, 2, 3]. The cost incurred is&nbsp;<span class="mathjax-latex">\(((1 + 5) + (1 | 5) - (1 &amp; 5)) = 10.\)</span></p>
	</li>
	<li>
	<p>Select 1 and 2. Remove 2 from the array, and concatenate the remaining numbers [1, 3]. The cost incurred is <span class="mathjax-latex">\(((1 + 2) + (1 | 2) - (1 &amp; 2)) = 6.\)</span></p>
	</li>
	<li>
	<p>Select 1 and 3. Remove 1 from the array, and concatenate the remaining numbers [3]. The cost incurred is <span class="mathjax-latex">\(((1 + 3) + (1 | 3) - (1 &amp; 3)) = 6.\)</span></p>
	</li>
</ol>

<p>Thus, the total "OR cost" is the bitwise OR of the individual costs incurred, which is <span class="mathjax-latex">\((10 | 6 | 6)\)</span> = 14. It can be shown that we can never achieve a total cost less than 14 for this particular array.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/select-cells-in-grid-with-maximum-score/description" target="_blank" rel="noopener noreferrer">Select Cells in Grid With Maximum Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D matrix <code>grid</code> consisting of positive integers.</p>

<p>You have to select <em>one or more</em> cells from the matrix such that the following conditions are satisfied:</p>

<ul>
	<li>No two selected cells are in the <strong>same</strong> row of the matrix.</li>
	<li>The values in the set of selected cells are <strong>unique</strong>.</li>
</ul>

<p>Your score will be the <strong>sum</strong> of the values of the selected cells.</p>

<p>Return the <strong>maximum</strong> score you can achieve.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,3],[4,3,2],[1,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/29/grid1drawio.png" /></p>

<p>We can select the cells with values 1, 3, and 4 that are colored above.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[8,7,6],[8,3,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">15</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/29/grid8_8drawio.png" style="width: 170px; height: 114px;" /></p>

<p>We can select the cells with values 7 and 8 that are colored above.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[i].length &lt;= 10</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/shift-string-2-e1383bdd/" target="_blank" rel="noopener noreferrer">Shift String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-firstsearch</span> <span class="topic-badge">brute-forcesearch</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">dynamicprogrammingandbitmasking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string,&nbsp;<span class="mathjax-latex">\(s\)</span>, of length,&nbsp;<span class="mathjax-latex">\(n\)</span>,&nbsp;and a list of&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;strings, <span class="mathjax-latex">\(x_{1}, x_{2}, ..., x_{m}\)</span>.&nbsp; All <span class="mathjax-latex">\(m\)</span> strings in the list are distinct and have length <span class="mathjax-latex">\(n\)</span>&nbsp;<strong>i.e</strong> <span class="mathjax-latex">\(\forall i \hspace{0.1cm} |x_{i}| = n\)</span>, and none of the given strings is equal to&nbsp;<span class="mathjax-latex">\(s\)</span>.</p>

<p>You can perform any number of operations <span class="mathjax-latex">\(s\)</span>.</p>

<p>In an operation you are allowed to choose <strong>one</strong> position in the string, <span class="mathjax-latex">\(s\)</span>, and change the character at the position to the next or previous character in the English alphabet <strong>cyclically </strong>(<em>'<strong>a'</strong></em><strong><strong>&nbsp;</strong>-&gt;</strong>&nbsp;<strong><em>'b'</em></strong>, <strong><em>'b'</em></strong>&nbsp;<strong>-&gt;</strong> <strong><em>'c'</em></strong>, <strong><em>'c'</em></strong>&nbsp;<strong>-&gt;</strong> <strong><em>'d'</em></strong>, ...,&nbsp;<strong><em>'z'</em> -&gt; <em>'a', 'b' -&gt; 'a', ...</em></strong>).</p>

<p>What is the minimum number of operations that you have to perform on, <span class="mathjax-latex">\(s\)</span>, so for all the given&nbsp;<span class="mathjax-latex">\(m\)</span> strings,&nbsp;<span class="mathjax-latex">\(s\)</span> becomes <span class="mathjax-latex">\(x_{i}\)</span> at least once after one of the performed operations.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>INPUT FORMAT&nbsp;</strong></p>

<p>The first line of the input contains an integer,&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;<span class="mathjax-latex">\((1 &lt;= n &lt;= 5)\)</span>&nbsp;&nbsp; - denoting the length of the string <span class="mathjax-latex">\(s\)</span>.&nbsp;</p>

<p>The second line of the input contains a string, <span class="mathjax-latex">\(s\)</span>&nbsp;- denoting the string which you can perform operations on. Each character in <span class="mathjax-latex">\(s\)</span>&nbsp;is a lowercase English alphabet (<em><strong>'a' - 'z'</strong></em>).&nbsp;</p>

<p>The next line of the input contains an integer, <span class="mathjax-latex">\(m\)</span> <span class="mathjax-latex">\((1 &lt;= m &lt;= 15)\)</span>&nbsp;- denoting the number of strings that will be in the list.</p>

<p>The next&nbsp;<span class="mathjax-latex">\(m\)</span> lines <strong>distinct</strong> strings,&nbsp;<span class="mathjax-latex">\(x_{i}\)</span>&nbsp;(<span class="mathjax-latex">\(|x_{i}| = n\)</span>, <span class="mathjax-latex">\(x_{i} \neq s\)</span>)&nbsp; &nbsp;- denoting a string in the list. Each character in&nbsp;<span class="mathjax-latex">\(x_{i}\)</span>&nbsp;is a lowercase english alphabet (<em><strong>'a' - 'z'</strong></em>)</p>

<p>&nbsp;</p>

<p><strong>OUTPUT FORMAT&nbsp;</strong></p>

<p>The output should contain one line denoting the minimum amount of operations that need to be performed on <span class="mathjax-latex">\(s\)</span>, to reach each of the <span class="mathjax-latex">\(m\)</span> strings at least once.&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the sample input,&nbsp;<span class="mathjax-latex">\(s\)</span>&nbsp;= <strong>abc</strong>, and we have <strong>3</strong> strings <em><strong>zbe</strong></em>, <em><strong>zbc</strong></em>, and <em><strong>abd</strong></em>, that&nbsp;<span class="mathjax-latex">\(s\)</span> must become at least once, in one of the operations.&nbsp;</p>

<p>One way of reaching all <span class="mathjax-latex">\(3\)</span> strings using the minimum number of operations is:&nbsp;</p>

<ul>
	<li><strong>OPERATION 1: </strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> forward, <strong>s</strong> becomes = <strong>"abd" (s has now become <strong><span class="mathjax-latex">\(x_{3}\)</span></strong>)</strong>.&nbsp;</li>
	<li><strong>OPERATION 2:&nbsp;</strong>shift index <strong>0</strong> (0-indexed) in <strong>s</strong> backward, <strong>s</strong> becomes = <strong>"zbd"</strong>.</li>
	<li><strong>OPERATION 3:&nbsp;</strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> forward, <strong>s</strong> becomes = <strong>"zbe" (s has now become&nbsp;<strong><span class="mathjax-latex">\(x_{1}\)</span></strong>).</strong></li>
	<li><strong>OPERATION 4:&nbsp;</strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> backward, <strong>s</strong> becomes <strong>"zbd".</strong></li>
	<li><strong>OPERATION 5:&nbsp;</strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> backward, <strong>s</strong> becomes <strong>"zbc" (s has now become&nbsp;<strong><span class="mathjax-latex">\(x_{2}\)</span></strong>).</strong></li>
</ul>

<p>It is not possible to reach all&nbsp;<span class="mathjax-latex">\(3\)</span> strings using less than&nbsp;<span class="mathjax-latex">\(5\)</span> operations. Hence, the answer to this input is <span class="mathjax-latex">\(5\)</span>.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shopping-offers/description" target="_blank" rel="noopener noreferrer">Shopping Offers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In LeetCode Store, there are <code>n</code> items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p>

<p>You are given an integer array <code>price</code> where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> item, and an integer array <code>needs</code> where <code>needs[i]</code> is the number of pieces of the <code>i<sup>th</sup></code> item you want to buy.</p>

<p>You are also given an array <code>special</code> where <code>special[i]</code> is of size <code>n + 1</code> where <code>special[i][j]</code> is the number of pieces of the <code>j<sup>th</sup></code> item in the <code>i<sup>th</sup></code> offer and <code>special[i][n]</code> (i.e., the last integer in the array) is the price of the <code>i<sup>th</sup></code> offer.</p>

<p>Return <em>the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers</em>. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
<strong>Output:</strong> 14
<strong>Explanation:</strong> There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == price.length == needs.length</code></li>
	<li><code>1 &lt;= n &lt;= 6</code></li>
	<li><code>0 &lt;= price[i], needs[i] &lt;= 10</code></li>
	<li><code>1 &lt;= special.length &lt;= 100</code></li>
	<li><code>special[i].length == n + 1</code></li>
	<li><code>0 &lt;= special[i][j] &lt;= 50</code></li>
	<li>The input is generated that at least one of <code>special[i][j]</code> is non-zero for <code>0 &lt;= j &lt;= n - 1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-visiting-all-nodes/description" target="_blank" rel="noopener noreferrer">Shortest Path Visiting All Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have an undirected, connected graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an array <code>graph</code> where <code>graph[i]</code> is a list of all the nodes connected with node <code>i</code> by an edge.</p>

<p>Return <em>the length of the shortest path that visits every node</em>. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg" style="width: 222px; height: 183px;" />
<pre>
<strong>Input:</strong> graph = [[1,2,3],[0],[0],[0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [1,0,2,0,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg" style="width: 382px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [0,1,4,2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>1 &lt;= n &lt;= 12</code></li>
	<li><code>0 &lt;= graph[i].length &lt;&nbsp;n</code></li>
	<li><code>graph[i]</code> does not contain <code>i</code>.</li>
	<li>If <code>graph[a]</code> contains <code>b</code>, then <code>graph[b]</code> contains <code>a</code>.</li>
	<li>The input graph is always connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-sufficient-team/description" target="_blank" rel="noopener noreferrer">Smallest Sufficient Team</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a project, you have a list of required skills <code>req_skills</code>, and a list of people. The <code>i<sup>th</sup></code> person <code>people[i]</code> contains a list of skills that the person has.</p>

<p>Consider a sufficient team: a set of people such that for every required skill in <code>req_skills</code>, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.</p>

<ul>
	<li>For example, <code>team = [0, 1, 3]</code> represents the people with skills <code>people[0]</code>, <code>people[1]</code>, and <code>people[3]</code>.</li>
</ul>

<p>Return <em>any sufficient team of the smallest possible size, represented by the index of each person</em>. You may return the answer in <strong>any order</strong>.</p>

<p>It is <strong>guaranteed</strong> an answer exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
<strong>Output:</strong> [0,2]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
<strong>Output:</strong> [1,2]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= req_skills.length &lt;= 16</code></li>
	<li><code>1 &lt;= req_skills[i].length &lt;= 16</code></li>
	<li><code>req_skills[i]</code> consists of lowercase English letters.</li>
	<li>All the strings of <code>req_skills</code> are <strong>unique</strong>.</li>
	<li><code>1 &lt;= people.length &lt;= 60</code></li>
	<li><code>0 &lt;= people[i].length &lt;= 16</code></li>
	<li><code>1 &lt;= people[i][j].length &lt;= 16</code></li>
	<li><code>people[i][j]</code> consists of lowercase English letters.</li>
	<li>All the strings of <code>people[i]</code> are <strong>unique</strong>.</li>
	<li>Every skill in <code>people[i]</code> is a skill in <code>req_skills</code>.</li>
	<li>It is guaranteed a sufficient team exists.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<blockquote>
<p><strong>Note.</strong> For this problem, we assume that you already know the fundamentals of dynamic programming and are figuring out how to apply it to a wide range of problems, such as this one. If you are not yet at this stage, we recommend checking out our relevant <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Explore Card content on dynamic programming</a> before coming back to this article.</p>
</blockquote>
<p>One of the first things you should notice in the statement are the constraints – they may hint at the time complexity of the intended algorithm.</p>
<hr />
<h3 id="approach-1-bottom-up-dynamic-programming-with-bitmasks">Approach 1: Bottom-Up Dynamic Programming with Bitmasks</h3>
<h4 id="intuition">Intuition</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of people and <span class="math inline">\(m\)</span> be the number of required skills.</p>
<p>In this problem, <span class="math inline">\(m\)</span> is very small – up to <span class="math inline">\(16\)</span>. It alludes to track which skills have been covered so far, which is possible to do efficiently with a bitmask.</p>
<p>First, let's make our lives easier by dealing with indices instead of strings for the required skills. We use a hash map <code>skillId</code> that keeps the index for each skill. We initialize <span class="math inline">\(\text{skillId}[\text{req\_skills}[i]] = i\)</span> for all <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(m - 1\)</span>.</p>
<p>Now, when each skill has its number, we can represent every set of skills with a bitmask – an integer between <span class="math inline">\(0\)</span> and <span class="math inline">\(2^m - 1\)</span>.</p>
<p>How do we associate a set and an integer exactly? We look at the binary representation of the integer. If the <span class="math inline">\(i^\text{th}\)</span> bit is <span class="math inline">\(1\)</span>, element <span class="math inline">\(i\)</span> belongs to the set. Otherwise, it does not.</p>
<blockquote>
<p><strong>Examples</strong></p>
<ul>
<li><span class="math inline">\(101111_2=2^0+2^1+2^2+2^3+2^5=47\)</span> represents the set <span class="math inline">\(\{0, 1, 2, 3, 5\}\)</span>.</li>
<li><span class="math inline">\(1001010_2=2^1+2^3+2^6=74\)</span> represents the set <span class="math inline">\(\{1, 3, 6\}\)</span>.</li>
<li><span class="math inline">\(0\)</span> represents an empty set.</li>
<li><span class="math inline">\(2^0+2^1+2^2+\dots+2^{m-1}=2^m-1\)</span> represents <span class="math inline">\(\{0, 1, 2, \dots, m - 1\}\)</span>.</li>
</ul>
</blockquote>
<p>The problem asks to find the smallest team such that the union of the skill sets of its members is the set of all required skills <span class="math inline">\(\{0, 1, 2, \dots, m - 1\}\)</span>.</p>
<p>One can reformulate the statement in terms of bitmasks: we need to find the smallest team such that the bitwise OR of the bitmasks representing the skill sets of its members is <span class="math inline">\(2^m - 1\)</span> (which is the representation of <span class="math inline">\(\{0, 1, 2, \dots, m - 1\}\)</span>).</p>
<p>We will solve this problem using dynamic programming.</p>
<p>Let <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> be a bitmask representing the smallest team that possesses all the skills from <span class="math inline">\(\text{skillsMask}\)</span>. The value of <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> is a bitmask that represents the set of team members. If there are multiple smallest teams, <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> may represent any of them.</p>
<p>We are using bitmasks to represent <code>skillsMask</code>, but we can also use bitmasks to represent a set of people. <span class="math inline">\(\text{skillsMask}\)</span> represents the set of skills, and <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> represents the set of people on the team. Similar to how we treat the <code>skillsMask</code> bitmask, the bitmask representing people has the <span class="math inline">\(i^\text{th}\)</span> bit set if the <span class="math inline">\(i^\text{th}\)</span> person is on the team.</p>
<blockquote>
<p>See an example with five people having the following skills masks.</p>
<ul>
<li>Person <span class="math inline">\(0\)</span>: <span class="math inline">\(0110\)</span>.</li>
<li>Person <span class="math inline">\(1\)</span>: <span class="math inline">\(1010\)</span>.</li>
<li>Person <span class="math inline">\(2\)</span>: <span class="math inline">\(0001\)</span>.</li>
<li>Person <span class="math inline">\(3\)</span>: <span class="math inline">\(0101\)</span>.</li>
<li>Person <span class="math inline">\(4\)</span>: <span class="math inline">\(0100\)</span>.</li>
</ul>
<p>Consider values of <span class="math inline">\(\text{dp}\)</span> for several different <span class="math inline">\(\text{skillsMask}\)</span>.</p>
<ul>
<li>To obtain <span class="math inline">\(\text{skillsMask} = 0110\)</span>, it is sufficient to take only the person <span class="math inline">\(0\)</span> to a team. The mask representing the team containing only the person <span class="math inline">\(0\)</span> is <span class="math inline">\(00001_2 = 2^0 = 1\)</span>. Thus <span class="math inline">\(\text{dp}[0110] = 00001\)</span>.</li>
<li>Similarly, <span class="math inline">\(\text{dp}[0101] = 01000_2 = 2^3 = 8\)</span> – the person <span class="math inline">\(3\)</span> can cover the skills mask <span class="math inline">\(0101\)</span> by themselves.</li>
<li>To cover <span class="math inline">\(1110\)</span>, one person is insufficient, and we need two people with indices <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>: <span class="math inline">\(\text{dp}[1110] = 00011_2 = 2^0 + 2^1 = 3\)</span>.</li>
<li>Two people <span class="math inline">\(1\)</span> and <span class="math inline">\(3\)</span> can cover <span class="math inline">\(1111\)</span> together which implies <span class="math inline">\(\text{dp}[1111] = 01010_2 = 2^1 + 2^3 = 10\)</span>.</li>
</ul>
</blockquote>
<p>The base case of this dynamic programming (DP) problem is when <span class="math inline">\(\text{skillsMask} = 0\)</span>, which represents an empty set of skills. When no skills are required, we can form an empty team, and thus, we set <span class="math inline">\(\text{dp}[0] = 0\)</span> – a bitmask representing an empty set of people.</p>
<p>Now we need to write down the transitions of this DP.</p>
<p>For a given <span class="math inline">\(\text{skillsMask} \ne 0\)</span>, there must be at least one person in a team. Since we need to find the minimal team, we initialize <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> with a large value, like the team of all people <span class="math inline">\(2^n - 1\)</span>.</p>
<p>Then we iterate over all people and for each person, try to update <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> with a team containing this person.</p>
<p>The <span class="math inline">\(i^\text{th}\)</span> person or at least one other team member must possess the skills in <span class="math inline">\(\text{skillsMask}\)</span>.</p>
<p>Let <span class="math inline">\(\text{skillsMaskOfPerson}[i]\)</span> denote the bitmask representing the skills set of the <span class="math inline">\(i^\text{th}\)</span> person. We can precompute this to make the algorithm more efficient.</p>
<blockquote>
<p>To summarize, we have 3 types of bitmasks. First, the keys to <code>dp</code>, which is <code>skillsMask</code>. This represents the set of skills that a team covers. Next, the <code>dp</code> values represent a set of people on a team. Finally, we are using <code>skillsMaskOfPerson</code> to represent the skills that a given person possesses, which is given in the input – we just need to convert it using <code>skillId</code>, which we defined at the start.</p>
</blockquote>
<p>Although the other team members may possess the skills from <span class="math inline">\(\text{skillsMaskOfPerson}[i]\)</span>, it is not necessary. However, they must have the skills from <span class="math inline">\(\text{skillsMask}\)</span> that are not present in <span class="math inline">\(\text{skillsMaskOfPerson}[i]\)</span>.</p>
<p>The set <span class="math inline">\(\text{smallerSkillsMask} = \text{skillsMask} \setminus \text{skillsMaskOfPerson}[i]\)</span>, where <span class="math inline">\(\setminus\)</span> denotes the set difference, contains the required skills that the <span class="math inline">\(i^\text{th}\)</span> person does not possess. The other team members must possess these skills.</p>
<p>In a code, a neat trick to calculate <span class="math inline">\(\text{smallerSkillsMask}\)</span> is <code>skills_mask &amp; ~skills_mask_of_person[i]</code>. Alternatively, one could calculate it manually by checking each bit one by one, but this trick is cleaner.</p>
<p>We will update <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> with the bitmask <span class="math inline">\(\text{dp}[\text{smallerSkillsMask}] \text{ OR } 2^i\)</span> – add the <span class="math inline">\(i^\text{th}\)</span> person to the team and cover the remaining skills with the smallest possible set of people, which is defined as  <span class="math inline">\(\text{dp}[\text{smallerSkillsMask}]\)</span>. This update only makes sense if <span class="math inline">\(\text{smallerSkillsMask} \ne \text{skillsMask}\)</span> because otherwise, the <span class="math inline">\(i^\text{th}\)</span> person would not contribute any new skills to the team.</p>
<p>The answer to the problem is <span class="math inline">\(\text{dp}[2^m - 1]\)</span> – the smallest team that possesses all the required skills.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Set <span class="math inline">\(n\)</span> to the number of people.</li>
<li>Set <span class="math inline">\(m\)</span> to the number of required skills.</li>
<li>Declare the hash map <span class="math inline">\(\text{skillId}\)</span>.</li>
<li>Iterate <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(m - 1\)</span>.
<ul>
<li>Set <span class="math inline">\(\text{skillId}[\text{req\_skills}[i]] = i\)</span>.</li>
</ul>
</li>
<li>Declare and initialize the array <span class="math inline">\(\text{skillsMaskOfPerson}\)</span>.</li>
<li>Iterate <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(n - 1\)</span>.
<ul>
<li>Iterate <span class="math inline">\(\text{skill}\)</span> over <span class="math inline">\(\text{people}[i]\)</span>.
<ul>
<li>Set the bit <span class="math inline">\(\text{skillId}[\text{skill}]\)</span> in the bitmask <span class="math inline">\(\text{skillsMaskOfPerson}[i]\)</span>.</li>
</ul>
</li>
</ul>
</li>
<li>Declare the array <span class="math inline">\(\text{dp}\)</span> of size <span class="math inline">\(2^m\)</span> and initialize it with the values of <span class="math inline">\(2^n - 1\)</span>.</li>
<li>Set <span class="math inline">\(\text{dp}[0] = 0\)</span>. (The base case of the DP.)</li>
<li>Iterate <span class="math inline">\(\text{skillsMask}\)</span> from <span class="math inline">\(1\)</span> to <span class="math inline">\(2^m - 1\)</span>.
<ul>
<li>Iterate <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(n - 1\)</span>.
<ul>
<li>Set <span class="math inline">\(\text{smallerSkillsMask} = \text{skillsMask} \setminus \text{skillsMaskOfPerson}[i]\)</span>.</li>
<li>If <span class="math inline">\(\text{smallerSkillsMask} \ne \text{skillsMask}\)</span>.
<ul>
<li>Set <span class="math inline">\(\text{peopleMask}\)</span> to <span class="math inline">\(\text{dp}[\text{smallerSkillsMask}] \text{ OR } 2^i\)</span>. This is the mask that represents the new team once you add the current person.</li>
<li>Update <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> with <span class="math inline">\(\text{peopleMask}\)</span>, if it is better (has fewer bits set).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the array containing the elements from the bitmask <span class="math inline">\(\text{dp}[2^m - 1]\)</span>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note that in Java and C++ we need to use long for the masks representing teams because according to the constraints, there could be at most 60 people, and <span class="math inline">\(2^{60}\)</span> is too large for int.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/HeDnwKSJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time complexity: <span class="math inline">\(O(2^m \cdot n)\)</span>.</li>
</ul>
<p>There are two nested for loops: <code>for skillsMask</code>, which performs <span class="math inline">\(O(2^m)\)</span> iterations, and <code>for i</code>, which performs <span class="math inline">\(O(n)\)</span> iterations. We process each transition inside these loops in <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(2^m)\)</span>.</li>
</ul>
<p>We store a DP array of size <span class="math inline">\(2^m\)</span>.</p>
<hr />
<h3 id="approach-2-top-down-dynamic-programming-memoization">Approach 2: Top-Down Dynamic Programming (Memoization)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we will calculate the same DP as in the previous one, but the manner of organizing computations will differ.</p>
<p>We will use the recursive function <span class="math inline">\(f(\text{skillsMask})\)</span> that returns the value of <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span>.</p>
<p>One can rewrite the DP recurrence relation in terms of <span class="math inline">\(f\)</span> as follows. For all <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(n - 1\)</span>, update <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> with the bitmask <span class="math inline">\(f(\text{smallerSkillsMask}) \text{ OR } 2^i\)</span>.</p>
<p>When we call <span class="math inline">\(f(\text{skillsMask})\)</span> for the first time, we calculate the result for <span class="math inline">\(\text{skillsMask}\)</span> and write it into <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span>. When we call <span class="math inline">\(f(\text{skillsMask})\)</span> after that, we immediately return <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> computed earlier.</p>
<p>The answer to the problem is the team <span class="math inline">\(f(2^m - 1) = \text{dp}[2^m - 1]\)</span>.</p>
<p>There remains one small technical question: how to know whether we call <span class="math inline">\(f(\text{skillsMask})\)</span> for the first time and need to compute the result, or we call it later and can return <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> found earlier? One can handle this by initializing the <span class="math inline">\(\text{dp}\)</span> array with the value of <span class="math inline">\(-1\)</span>. Then <span class="math inline">\(\text{dp}[\text{skillsMask}] = -1\)</span> will mean that we have not calculated <span class="math inline">\(f(\text{skillsMask})\)</span> yet. As soon as we find the result of <span class="math inline">\(f(\text{skillsMask})\)</span>, we will write it into <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span>, and this value will not be <span class="math inline">\(-1\)</span> anymore.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>The function <span class="math inline">\(f\)</span> takes a parameter <span class="math inline">\(\text{skillsMask}\)</span>.</p>
<ol>
<li>If <span class="math inline">\(\text{dp}[\text{skillsMask}] \ne -1\)</span>, return <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> (the value computed earlier).</li>
<li>Iterate <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(n - 1\)</span>. Try to update <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> with a team containing the <span class="math inline">\(i^\text{th}\)</span> person.
<ul>
<li>Set <span class="math inline">\(\text{smallerSkillsMask} = \text{skillsMask} \setminus \text{skillsMaskOfPerson}[i]\)</span>.</li>
<li>If <span class="math inline">\(\text{smallerSkillsMask} \ne \text{skillsMask}\)</span>.
<ul>
<li>Set <span class="math inline">\(\text{peopleMask} = f(\text{smallerSkillsMask})\)</span>.</li>
<li>If <span class="math inline">\(\text{dp}[\text{skillsMask}] = -1\)</span> (we have not found any team for <span class="math inline">\(\text{skillsMask}\)</span> yet) or <span class="math inline">\(\text{peopleMask} \text{ OR } 2^i\)</span> is smaller than the current team <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span>, update <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> with <span class="math inline">\(\text{peopleMask} \text{ OR } 2^i\)</span>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span>.</li>
</ol>
<p>Before calling <span class="math inline">\(f\)</span> we need to precalculate <span class="math inline">\(\text{skillsMaskOfPerson}[i]\)</span> for all <span class="math inline">\(i\)</span>. Also, we initialize <span class="math inline">\(\text{dp}[0] = 0\)</span> as the base case and all other elements to <code>-1</code>.</p>
<p>The answer to the problem is <span class="math inline">\(f(2^m - 1)\)</span>.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ErDF2hwQ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>Time complexity: <span class="math inline">\(O(2^m \cdot n)\)</span>.</li>
</ul>
<p>Even though we changed the order of calculating DP, the time complexity is the same as in the previous approach: for each <span class="math inline">\(\text{skillsMask}\)</span>, we compute <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> in <span class="math inline">\(O(n)\)</span>. Since we store the results in memory, we will calculate each <span class="math inline">\(\text{dp}[\text{skillsMask}]\)</span> only once.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(2^m)\)</span>.</li>
</ul>
<p>We store a DP array of size <span class="math inline">\(2^m\)</span>.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/special-permutations/description" target="_blank" rel="noopener noreferrer">Special Permutations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a&nbsp;<strong>0-indexed</strong>&nbsp;integer array&nbsp;<code>nums</code>&nbsp;containing&nbsp;<code>n</code>&nbsp;<strong>distinct</strong> positive integers. A permutation of&nbsp;<code>nums</code>&nbsp;is called special if:</p>

<ul>
	<li>For all indexes&nbsp;<code>0 &lt;= i &lt; n - 1</code>, either&nbsp;<code>nums[i] % nums[i+1] == 0</code>&nbsp;or&nbsp;<code>nums[i+1] % nums[i] == 0</code>.</li>
</ul>

<p>Return&nbsp;<em>the total number of special permutations.&nbsp;</em>As the answer could be large, return it&nbsp;<strong>modulo&nbsp;</strong><code>10<sup>9&nbsp;</sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,6]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [3,6,2] and [2,6,3] are the two special permutations of nums.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [3,1,4] and [4,1,3] are the two special permutations of nums.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 14</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-array-with-same-average/description" target="_blank" rel="noopener noreferrer">Split Array With Same Average</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>.</p>

<p>You should move each element of <code>nums</code> into one of the two arrays <code>A</code> and <code>B</code> such that <code>A</code> and <code>B</code> are non-empty, and <code>average(A) == average(B)</code>.</p>

<p>Return <code>true</code> if it is possible to achieve that and <code>false</code> otherwise.</p>

<p><strong>Note</strong> that for an array <code>arr</code>, <code>average(arr)</code> is the sum of all the elements of <code>arr</code> over the length of <code>arr</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6,7,8]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 30</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/split-permutation-12616373/" target="_blank" rel="noopener noreferrer">Split Permutation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">greedyalgorithm</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array&nbsp;<span class="mathjax-latex">\(A\)</span> of <strong>distinct</strong> integers and another array <span class="mathjax-latex">\(B\)</span> which is a permutation of array <span class="mathjax-latex">\(A\)</span>. Find the <strong>maximum</strong> number of segments array <span class="mathjax-latex">\(A\)</span> could be split such that within each segment, Array <span class="mathjax-latex">\(B\)</span> is a permutation of array <span class="mathjax-latex">\(A\)</span>.</p>

<p><strong>&nbsp;INPUT FORMAT</strong></p>

<p>The first line contains an integer,&nbsp;<span class="mathjax-latex">\(t\)</span>&nbsp;- denoting the number of test cases.</p>

<p>The first line of each test case contains two integers <em><em><em><em><span class="mathjax-latex">\(n\)</span></em></em></em></em><em>&nbsp;</em>- denoting the length of the array <span class="mathjax-latex">\(A\)</span>.</p>

<p>The second line of each test case&nbsp;contains&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;integers — elements of array&nbsp;<span class="mathjax-latex">\(A\)</span>.</p>

<p>The second line of each test case&nbsp;contains&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;integers — elements of array&nbsp;<span class="mathjax-latex">\(B\)</span>&nbsp;which is a permutation of array <span class="mathjax-latex">\(A\)</span>.</p>

<p><strong>OUTPUT FORMAT</strong></p>

<p>For each test case, print the answer in a new line.</p>

<p><strong>&nbsp;Constraints</strong></p>

<p><span class="mathjax-latex">\(1&lt;=t&lt;=1000\)</span></p>

<p><span class="mathjax-latex">\(1&lt;=n&lt;=10^6\)</span>, sum of <span class="mathjax-latex">\(n\)</span>&nbsp;across all test cases &lt;= <span class="mathjax-latex">\(10^6\)</span></p>

<p><span class="mathjax-latex">\(-10^{9} ≤ A_i ,B_i≤ 10^{9}\)</span></p>

<p>Array <span class="mathjax-latex">\(B\)</span> is a permutation of array <span class="mathjax-latex">\(A\)</span>.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p><strong>Test case 1:</strong>&nbsp;We split array into following 2 segments -&nbsp;&nbsp;<span class="mathjax-latex">\([0:0]+[1:1]\)</span></p>

<p>such that&nbsp;<span class="mathjax-latex">\(A[0:0] = [1] \)</span>&nbsp;is permutation of&nbsp;<span class="mathjax-latex">\(B[0:0] = [1]\)</span>&nbsp;and&nbsp;&nbsp;<span class="mathjax-latex">\(A[1:1] = [2]\)</span>&nbsp;is permutation of&nbsp;<span class="mathjax-latex">\(B[1:1] = [2]\)</span>.</p>

<p><strong>Test case&nbsp;2:</strong>&nbsp;There is no way to split, hence only 1 segment -&nbsp;&nbsp;<span class="mathjax-latex">\([0:1]\)</span></p>

<p>such that&nbsp;<span class="mathjax-latex">\(A[0:1] = [1,2]\)</span>&nbsp; is permutation of&nbsp;<span class="mathjax-latex">\(B[0:1] = [2,1]\)</span>.</p>

<p><strong>Test case&nbsp;3:</strong>&nbsp;We split array into following 3 segments-&nbsp;&nbsp;<span class="mathjax-latex">\([0:1]+[2:2]+[3:5]\)</span></p>

<p>such that&nbsp;<span class="mathjax-latex">\(A[0:1] = [1,2]\)</span>&nbsp;is permutation of <span class="mathjax-latex">\(B[0:1] = [2,1]\)</span>,&nbsp;<span class="mathjax-latex">\(A[2:2] = [3]\)</span> is permutation of <span class="mathjax-latex">\(B[2:2] = [3]\)</span>&nbsp;and&nbsp;&nbsp;<span class="mathjax-latex">\(A[3:5] = [4,5,6]\)</span>&nbsp;is permutation of&nbsp;<span class="mathjax-latex">\(B[3:5] = [5,6,4]\)</span>.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/andy-and-string-operations-941f4415/" target="_blank" rel="noopener noreferrer">Splitting Candies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">dynamicprogrammingandbitmasking</span> <span class="topic-badge">segmenttree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a sequence of <strong>N</strong> candies in the store. There are different types of candies, the type of the <strong>i</strong>-th candy is denoted by <strong>A</strong><sub><strong>i</strong></sub>.</p>

<p>Andy decided to split the sequence into continuous subarrays so that all the following conditions are satisfied</p>

<ul>
	<li>Each candy is contained in <strong>exactly one</strong> subarray</li>
	<li>The size of each subarray is <strong>no more than K</strong></li>
	<li>For each subarray there is<strong> at most one</strong> type of candy which is contained an odd<strong>&nbsp;</strong>number of times</li>
</ul>

<p>The value of subarray <strong>A</strong><sub><strong>L</strong></sub><strong>, A</strong><sub><strong>L+1</strong></sub><strong>, ..., A</strong><sub><strong>R</strong></sub> is defined as<strong> A</strong><sub><strong>L</strong></sub><strong>+A</strong><sub><strong>R</strong></sub>. The value of splitting is defined as the sum of values of the subarrays.</p>

<p>Output the <strong>minimum possible value </strong>of splitting.</p>

<p>As the answer can be pretty large output it <strong>modulo 1000000007</strong> (10<sup>9</sup>+7)</p>

<p>&nbsp;</p>

<p><strong>&nbsp;Input format</strong></p>

<ul>
	<li>The first line contains N denoting&nbsp;the number of candies</li>
	<li>The second line contains an integer K denoting the maximum size of a subarray.</li>
	<li>Each of the next N lines contains one integer, the type of each candy.</li>
</ul>

<p>&nbsp;</p>

<p><strong>Output format</strong></p>

<p>&nbsp;An integer denoting the minimum value of splitting&nbsp;<strong>modulo 1000000007</strong> (10<sup>9</sup>+7)</p>

<p>&nbsp;</p>

<p><strong>Constraints</strong></p>

<p>1 ≤ <strong>N</strong> ≤50000</p>

<p>1 ≤ <strong>K </strong>≤ N</p>

<p>1 ≤&nbsp;<strong>A<sub>i&nbsp;</sub></strong> ≤ 5</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><pre>K = 3
A = [1, 1, 3, 1, 3]
The optimal splitting will be [1, 1][3, 1, 3] with (A<sub>1</sub>+A<sub>2</sub>)+(A<sub>3</sub>+A<sub>5</sub>) = 1 + 1 + 3 + 3 = 8 as the value of splitting</pre></div>
				</div>
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stickers-to-spell-word/description" target="_blank" rel="noopener noreferrer">Stickers to Spell Word</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are given <code>n</code> different types of <code>stickers</code>. Each sticker has a lowercase English word on it.</p>

<p>You would like to spell out the given string <code>target</code> by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.</p>

<p>Return <em>the minimum number of stickers that you need to spell out </em><code>target</code>. If the task is impossible, return <code>-1</code>.</p>

<p><strong>Note:</strong> In all test cases, all words were chosen randomly from the <code>1000</code> most common US English words, and <code>target</code> was chosen as a concatenation of two random words.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stickers = [&quot;with&quot;,&quot;example&quot;,&quot;science&quot;], target = &quot;thehat&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong>
We can use 2 &quot;with&quot; stickers, and 1 &quot;example&quot; sticker.
After cutting and rearrange the letters of those stickers, we can form the target &quot;thehat&quot;.
Also, this is the minimum number of stickers necessary to form the target string.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stickers = [&quot;notice&quot;,&quot;possible&quot;], target = &quot;basicbasic&quot;
<strong>Output:</strong> -1
Explanation:
We cannot form the target &quot;basicbasic&quot; from cutting letters from the given stickers.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stickers.length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>
	<li><code>1 &lt;= target.length &lt;= 15</code></li>
	<li><code>stickers[i]</code> and <code>target</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-optimized-exhaustive-search">Approach 1: Optimized Exhaustive Search</h3>
<br>
<p><strong>Intuition</strong></p>
<p>A natural answer is to exhaustively search for combinations of stickers. Because the data is randomized, there are many heuristics available to us that will make this faster.</p>
<ul>
<li>
<p>For all stickers, we can ignore any letters that are not in the target word.</p>
</li>
<li>
<p>When our candidate's answer won't be smaller than an answer we have already found, we can stop searching this path.</p>
</li>
<li>
<p>We should try to have our exhaustive search bound to the answer as soon as possible, so the effect described in the above point happens more often.</p>
</li>
<li>
<p>When a sticker dominates another, we shouldn't include the dominant sticker in our sticker collection.  [Here, we say a sticker <code>A</code> dominates <code>B</code> if <code>A.count(letter) &gt;= B.count(letter)</code> for all letters.]</p>
</li>
</ul>
<br>
<p><strong>Algorithm</strong></p>
<p>Firstly, for each sticker, let's create a count of that sticker (a mapping <code>letter -&gt; sticker.count(letter)</code>) that does not consider letters not in the target word.  Let <code>A</code> be an array of these counts.  Also, let's create <code>t_count</code>, a count of our <code>target</code> word.</p>
<p>Secondly, let's remove dominated stickers. Because dominance is a transitive relation, we only need to check if a sticker is not dominated by any other sticker once - the ones that aren't dominated are included in our collection.</p>
<p>We are now ready to begin our exhaustive search. A call to <code>search(ans)</code> denotes that we want to decide the minimum number of stickers we can use in <code>A</code> to satisfy the target count <code>t_count</code>. <code>ans</code> will store the currently formed answer, and <code>best</code> will store the current best answer.</p>
<p>If our current answer can't beat our current best answer, we should stop searching.  Also, if there are no stickers left and our target is satisfied, we should update our answer.</p>
<p>Otherwise, we want to know the maximum number of these stickers we can use. For example, if this sticker is <code>'abb'</code> and our target is <code>'aaabbbbccccc'</code>, then we could use a maximum of 3 stickers.  This is the maximum of <code>math.ceil(target.count(letter) / sticker.count(letter))</code>, taken over all <code>letter</code>s in <code>sticker</code>.  Let's call this quantity <code>used</code>.</p>
<p>After, for the sticker we are currently considering, we try to use <code>used</code> of them, then <code>used - 1</code>, <code>used - 2</code>, and so on. The reason we do it in this order is so that we can arrive at a value for <code>best</code> more quickly, which will stop other branches of our exhaustive search from continuing.</p>
<p>The Python version of this solution showcases using <code>collections.Counter</code> as a way to simplify some code sections, whereas the Java solution sticks to arrays.</p>
<p><a href="https://leetcode.com/playground/KP3fS7G3/shared">code</a></p>
<br>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: Let <span class="math inline">\(N\)</span> be the number of stickers, and <span class="math inline">\(T\)</span> be the number of letters in the target word. A bound for time complexity is <span class="math inline">\(O(N^{T+1} T^2)\)</span>: for each sticker, we'll have to try using it up to <span class="math inline">\(T+1\)</span> times, and updating our target count costs <span class="math inline">\(O(T)\)</span>, which we do up to <span class="math inline">\(T\)</span> times. Alternatively, since the answer is bounded at <span class="math inline">\(T\)</span>, we can prove that we can only search up to <span class="math inline">\(\binom{N+T-1}{T-1}\)</span> times. This would be <span class="math inline">\(O(\binom{N+T-1}{T-1} T^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N+T)\)</span>, to store <code>stickersCount</code>, <code>targetCount</code>, and handle the recursive call stack when calling <code>search</code>.</p>
</li>
</ul>
<br>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<br>
<p><strong>Intuition</strong></p>
<p>Suppose we need <code>dp[state]</code> stickers to satisfy all <code>target[i]</code>'s for which the <code>i</code>-th bit of <code>state</code> is set. We would like to know <code>dp[(1 &lt;&lt; len(target)) - 1]</code>.</p>
<br>
<p><strong>Algorithm</strong></p>
<p>For each <code>state</code>, let's work with it as <code>now</code> and look at what happens to it after applying a sticker. For each letter in the sticker that can satisfy an unset bit of <code>state</code>, we set the bit (<code>now |= 1 &lt;&lt; i</code>). In the end, we know <code>now</code> is the result of applying that sticker to <code>state</code>, and we update our <code>dp</code> appropriately.</p>
<p>When using Python, we will need some extra techniques from <em>Approach #1</em> to pass in time.</p>
<p><a href="https://leetcode.com/playground/JTZ2SYco/shared">code</a></p>
<br>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(2^T * S * T)\)</span> where <span class="math inline">\(S\)</span> is the total number of letters in all stickers, and <span class="math inline">\(T\)</span> is the number of letters in the target word. We can examine each loop carefully to arrive at this conclusion.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(2^T)\)</span>, the space used by <code>dp</code>.</p>
</li>
</ul>
<br></div>
				</div>
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-number-of-good-subsets/description" target="_blank" rel="noopener noreferrer">The Number of Good Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. We call a subset of <code>nums</code> <strong>good</strong> if its product can be represented as a product of one or more <strong>distinct prime</strong> numbers.</p>

<ul>
	<li>For example, if <code>nums = [1, 2, 3, 4]</code>:

	<ul>
		<li><code>[2, 3]</code>, <code>[1, 2, 3]</code>, and <code>[1, 3]</code> are <strong>good</strong> subsets with products <code>6 = 2*3</code>, <code>6 = 2*3</code>, and <code>3 = 3</code> respectively.</li>
		<li><code>[1, 4]</code> and <code>[4]</code> are not <strong>good</strong> subsets with products <code>4 = 2*2</code> and <code>4 = 2*2</code> respectively.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the number of different <strong>good</strong> subsets in </em><code>nums</code><em> <strong>modulo</strong> </em><code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>subset</strong> of <code>nums</code> is any array that can be obtained by deleting some (possibly none or all) elements from <code>nums</code>. Two subsets are different if and only if the chosen indices to delete are different.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The good subsets are:
- [1,2]: product is 2, which is the product of distinct prime 2.
- [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [1,3]: product is 3, which is the product of distinct prime 3.
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [3]: product is 3, which is the product of distinct prime 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,3,15]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The good subsets are:
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.
- [3]: product is 3, which is the product of distinct prime 3.
- [15]: product is 15, which is the product of distinct primes 3 and 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 30</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/tree-journeys-fd9f8f9c/" target="_blank" rel="noopener noreferrer">Tree Trips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-firstsearch</span> <span class="topic-badge">bruteforce</span> <span class="topic-badge">depthfirstsearch</span> <span class="topic-badge">disjointsetunion</span> <span class="topic-badge">graphs</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Bob is going to make <span class="mathjax-latex">\(m\)</span>&nbsp;trips on a <strong>tree</strong>. During each trip he goes from a node, <span class="mathjax-latex">\(x_{i}\)</span>,&nbsp;to another node, <span class="mathjax-latex">\(y_{i}\)</span>, using the simple path between the two nodes.&nbsp;</p>

<p>Alice is jealous of Bob, and doesn't want him to be able to go on any of the <span class="mathjax-latex">\(m\)</span> trips. Before Bob wakes up, Alice plans to remove some edges in the tree, in a way that Bob wouldn't be able to make <strong>any of the <span class="mathjax-latex">\(m\)</span> trips</strong>.&nbsp;</p>

<p>Please, help Alice find out the <strong>minimum </strong>number of edges she should remove from the tree, so Bob cannot make any of the trips.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>INPUT FORMAT</strong></p>

<p>The first line of input contains two integers,&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;<span class="mathjax-latex">\((2 &lt;= n &lt;= 15)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;<span class="mathjax-latex">\((1 &lt;= m &lt;= \frac{n(n - 1)}{2})\)</span>&nbsp;- denoting the number of nodes in the tree, and the number of trips Bob wants to make.&nbsp;</p>

<p>The next&nbsp;<span class="mathjax-latex">\(n - 1\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(u_{i} (1 &lt;= u_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(v_{i} (1 &lt;= v_{i} &lt;= n)\)</span>&nbsp;(<span class="mathjax-latex">\(u_{i} &lt; v_{i}\)</span>)&nbsp;- denoting the edges in the tree.&nbsp;</p>

<p>The last&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(x_{i} (1 &lt;= x_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(y_{i} (1 &lt;= y_{i} &lt;= n)\)</span>&nbsp;<span class="mathjax-latex">\((x_{i} \neq y_{i})\)</span>&nbsp;- denoting start and end nodes of the trips Bob wants to make.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>OUTPUT FORMAT</strong></p>

<p>The minimum number of edges Alice should remove from the tree to make the trips impossible.&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the sample input we have a tree with <span class="mathjax-latex">\(4\)</span> edges <span class="mathjax-latex">\((1, 2)\)</span>, <span class="mathjax-latex">\((1, 3)\)</span>, <span class="mathjax-latex">\((1, 4)\)</span> and <span class="mathjax-latex">\((1, 5)\)</span>.</p>

<p>The tree looks like:&nbsp;</p>

<p><img alt="" height="300" src="https://he-s3.s3.amazonaws.com/media/uploads/1bff5952-4c0f-4a7b-a0c2-0aee81416da9.png" width="318"></p>

<p>Bob wants to make the following trips <strong>2 -&gt; 3&nbsp;</strong>and <strong>3 -&gt; 4</strong>.&nbsp;</p>

<p>It is easy to see that if we remove the edge <span class="mathjax-latex">\((1, 3)\)</span>, then he can't make any of those trips. The resulting graphs looks like:&nbsp;</p>

<p><img alt="" height="280" src="https://he-s3.s3.amazonaws.com/media/uploads/216160d7-496e-4da9-a8b5-558d32c189b1.png" width="325"></p>

<p>Hence, the answer for this input is <span class="mathjax-latex">\(1\)</span>.&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/yasser-and-xor-c7c23323/" target="_blank" rel="noopener noreferrer">XOR of numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">basicsofbitmanipulation</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">prefix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array $$a$$ of $$n$$ numbers and $$q$$ queries. In each query, $$l$$, $$r$$ find $$XOR$$ of all $$n$$ numbers except the range $$[l, r]$$.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains two integers $$n$$&nbsp;denoting the number of elements and $$q$$ denoting the number of test cases.</li>
	<li>The second line of each test case&nbsp;contains&nbsp;$$n$$&nbsp;space-separated integers.</li>
	<li>The next $$q$$ lines contain two integers $$l$$ and $$r$$.</li>
</ul>

<p><strong>Output format</strong></p>

<p>For each test case, print the answer as described in the problem statement.</p>

<p><strong>Example</strong>&nbsp;</p>

<p>Let the array $$a$$ be $$[1, 2, 3, 4]$$ and you are given a query $$(2, 3)$$, then print the $${XOR}$$ of all the array $$a$$ without the range $$[2, 3]$$.</p>

<p>Hence, the answer will be $$1 $${XOR}$$ 4$$.&nbsp;</p>

<p><strong>Constraints</strong></p>

<p>$$1 \le&nbsp; &nbsp;n&nbsp; \le&nbsp; 10^5$$</p>

<p>$$1 \le&nbsp; &nbsp;q&nbsp; &nbsp; \le&nbsp; {10^5}$$</p>

<p>$$1 \le&nbsp; a_i&nbsp; \le {10^9}$$</p>

<p>$$1 \le&nbsp; l, r&nbsp; \le&nbsp; n$$</p>

<p>&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the first test case, the XOR of the array without the numbers in the range $$[2, 3]$$. So, compute XOR of $${1, 4, 5}$$ it equals to $$0$$.</p>

<p>&nbsp;</p></div>
				</div>
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>