<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>trie - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>trie</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">73</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Camel Case</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-1" class="toc-link">Camelcase Matching</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">CamelCase Pattern Matching</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-3" class="toc-link">Concatenated Words</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Contiguous Elements XOR</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-5" class="toc-link">Count of distinct substrings</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-6" class="toc-link">Count Pairs With XOR in a Range</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Count Prefix and Suffix Pairs I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Count Prefix and Suffix Pairs II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Count words in a Trie</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-10" class="toc-link">Delete Duplicate Folders in System</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Design Add and Search Words Data Structure</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Design Add and Search Words Data Structure</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-13" class="toc-link">Distinct Echo Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Encrypt and Decrypt Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Extra Characters in a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Find duplicate rows in a binary matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-17" class="toc-link">Find the Length of the Longest Common Prefix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Find the longest string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-19" class="toc-link">Geek and Strings</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-20" class="toc-link">Implement Magic Dictionary</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Implement Trie</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-22" class="toc-link">Implement Trie (Prefix Tree)</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">K Divisible Elements Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">K-th Smallest in Lexicographical Order</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">LCP</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-26" class="toc-link">Lexicographical Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Longest Common Prefix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Longest Common Prefix of K Strings After Removal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Longest Common Suffix Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Longest Word in Dictionary</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Map Sum Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Maximum Genetic Difference Query</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Maximum Strong Pair XOR I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Maximum Strong Pair XOR II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Maximum XOR of Two Numbers in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Maximum XOR subarray</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-37" class="toc-link">Maximum XOR With an Element From Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Minimum Cost to Convert String II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Minimum Number of Valid Strings to Form Target I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Minimum XOR value pair</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-41" class="toc-link">Most frequent word in an array of strings</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-42" class="toc-link">Number of Matching Subsequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Number of Valid Words for Each Puzzle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Open the gates</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-45" class="toc-link">Palindrome Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Palindrome Pairs</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-47" class="toc-link">Partition String </a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Phone directory</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-49" class="toc-link">Prefix and Suffix Search</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Prefix match with other strings</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-51" class="toc-link">Prefix Suffix String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-52" class="toc-link">Remove Sub-Folders from the Filesystem</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Renaming Cities</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-54" class="toc-link">Replace Words</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Search Query Auto Complete</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-56" class="toc-link">Search Query for Strings</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-57" class="toc-link">Search Suggestions System</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Short Encoding of Words</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Shortest Uncommon Substring in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Shortest Unique prefix for every word</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-61" class="toc-link">Stream of Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Sum of Prefix Scores of Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Top K Frequent Words</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Trie | (Delete)</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-65" class="toc-link">Unique rows in boolean matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-66" class="toc-link">Word Boggle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-67" class="toc-link">Word Break</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Word Break II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Word Break (Trie)</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-70" class="toc-link">Word Search II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Word Search II</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-72" class="toc-link">Words Within Two Edits of Dictionary</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/camel-case04234120/1" target="_blank" rel="noopener noreferrer">Camel Case</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a dictionary of words <strong>dict </strong>where each word follows CamelCase notation, print all words in the dictionary that match with a given <strong>pattern </strong>consisting of uppercase characters only.<br />
<em>CamelCase is the practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter. Common examples include: &ldquo;PowerPoint&rdquo; and &ldquo;WikiPedia&rdquo;, &ldquo;GeeksForGeeks&rdquo;, &ldquo;CodeBlocks&rdquo;, etc.</em><br />
<br />
<strong>Note: </strong>The order should be such that the output strings should be sorted by the lexicographic order of their abbreviations. For strings with same abbreviations the strings should be sorted by the usual lexicographic order. So, if Output Strings are Hi and HelloWorld, Hi should come first as H lexiographically is smaller than HW.</span></p>

<p><br />
<strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:
</span></strong><span style="font-size:18px">n = 8
dict[] = {Hi,Hello,HelloWorld,HiTech
HiGeek,HiTechWorld,HiTechCity,HiTechLab}
pattern = HA
<strong>Output: </strong>No match found</span>
</pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:
</span></strong><span style="font-size:18px">n = 3
dict[]={WelcomeGeek,WelcomeToGeeksForGeeks
GeeksForGeeks}
pattern = WTG
<strong>Output: </strong>WelcomeToGeeksForGeeks<strong>
Explanation: </strong>WTG occurs in
<strong>W</strong>elcome<strong>T</strong>o<strong>G</strong>eeksForGeeks.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
Complete <strong>findAllWords()&nbsp;</strong>function and print as mentioned. If the pattern is not found, print &quot;<strong>No match found&quot;</strong> (without quotes) in the function itself. The new line is provided by the driver code.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(N * WORD_LEN).<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N * WORD_LEN).</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N &lt;= 100<br />
1 &lt;= length of pattern &lt;= length of string &lt;= 100</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/camelcase-matching/description" target="_blank" rel="noopener noreferrer">Camelcase Matching</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>queries</code> and a string <code>pattern</code>, return a boolean array <code>answer</code> where <code>answer[i]</code> is <code>true</code> if <code>queries[i]</code> matches <code>pattern</code>, and <code>false</code> otherwise.</p>

<p>A query word <code>queries[i]</code> matches <code>pattern</code> if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters <strong>at all</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;
<strong>Output:</strong> [true,false,true,true,false]
<strong>Explanation:</strong> &quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.
&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.
&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;
<strong>Output:</strong> [true,false,true,false,false]
<strong>Explanation:</strong> &quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.
&quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;
<strong>Output:</strong> [false,true,false,false,false]
<strong>Explanation:</strong> &quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pattern.length, queries.length &lt;= 100</code></li>
	<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>
	<li><code>queries[i]</code> and <code>pattern</code> consist of English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/camelcase-pattern-matching2259/1" target="_blank" rel="noopener noreferrer">CamelCase Pattern Matching</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a dictionary of words&nbsp;</span><strong style="font-size: 18px;">arr[]</strong><span style="font-size: 18px;">&nbsp;where each word follows&nbsp;</span><strong style="font-size: 18px;">CamelCase&nbsp;</strong><span style="font-size: 18px;">notation, print all words in the dictionary that match with a given pattern </span><strong style="font-size: 18px;">pat</strong><span style="font-size: 18px;">&nbsp;consisting of&nbsp;</span><strong style="font-size: 18px;">uppercase&nbsp;</strong><span style="font-size: 18px;">characters only.</span></p>
<blockquote>
<p><strong style="font-size: 18px;"><span style="font-family: arial, helvetica, sans-serif;">CamelCase is the practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter. Common examples include PowerPoint and Wikipedia, GeeksForGeeks, CodeBlocks, etc</span><em style="font-weight: 400;">.</em></strong></p>
</blockquote>
<p><span style="font-size: 18px;">Example</span><span style="font-size: 18px;">: "GeeksForGeeks" matches the pattern "GFG", because if we combine all the capital letters in "GeeksForGeeks" they become "GFG". Also note "GeeksForGeeks" matches with the pattern "GFG" and also "GF", but <strong>does</strong></span><strong style="font-size: 18px;">&nbsp;not&nbsp;</strong><span style="font-size: 18px;">match with "FG".</span></p>
<p><span style="font-size: 18px;">Note: The driver code will sort your answer before checking and return the answer in any order.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = ["WelcomeGeek", "WelcomeToGeeksForGeeks", "GeeksForGeeks"], pat = "WTG"
<strong>Output: </strong>["WelcomeToGeeksForGeeks"]
<strong>Explanation: </strong>Since only "WelcomeToGeeksForGeeks" matches the pattern, it is the only answer.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = ["Hi", "Hello", "HelloWorld", "HiTech", "HiGeek", "HiTechWorld", "HiTechCity", "HiTechLab"], pat = "HA"
<strong>Output: </strong>[]
<strong>Explanation: </strong>None of the words matches the given pattern.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;= arr.size() &lt;=1000<br />1&lt;= pat.size() &lt;=100<br />1&lt;= arr[i].size()</span><span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;">&lt;=100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/concatenated-words/description" target="_blank" rel="noopener noreferrer">Concatenated Words</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p>

<p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)&nbsp;in the given array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]
<strong>Output:</strong> [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]
<strong>Explanation:</strong> &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; 
&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; 
&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]
<strong>Output:</strong> [&quot;catdog&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
	<li><code>words[i]</code> consists of only lowercase English letters.</li>
	<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>
	<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<p>The main logic of the solutions is similar to the question <a href="https://leetcode.com/problems/word-break/">Word Break</a>.</p>
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Consider the word list as a dictionary, then the problem is: which words can be created by concatenating two or more words in the dictionary?</p>
<p>This is a famous &quot;reachability&quot; problem and it can be solved by DP(dynamic programming), BFS and/or DFS. Though they seem to be different, the core idea behind them is the same. Namely, if a given <code>word</code> can be created by concatenating the given words, we can split it into 2 parts, the prefix and the suffix, the prefix is a shorter word which can be got by concatenating the given words and the suffix is a given word.</p>
<p>Namely, <code>word</code> = (another shorter word that can be created by concatenation) + (a given word in the dictionary). We can enumerate the suffix and look it up in the dictionary and the prefix part is just a sub-problem to solve.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="state-definition">State definition</h5>
<p>Formally, for each word, let's define the sub-problem as whether a (possibly empty) prefix can be created by concatenation. So the state of the dynamic programming algorithm can be defined as a boolean array:<br />
let <span class="math inline">\(dp[i]\)</span> denote whether word's prefix of length i (index range [0, i - 1]) can be created by concatenation.</p>
<h5 id="induction">Induction</h5>
<p>We need to calculate <span class="math inline">\(dp[i]\)</span> for each i in range [0, word.length]. Let's do it by induction.</p>
<p>The base case is simple: <span class="math inline">\(dp[0]\)</span> = true, since it's the empty string that can always be created without using any words in the dictionary.</p>
<p>Now, let's consider the value of <span class="math inline">\(dp[i]\)</span> for i &gt; 0.</p>
<p>If <span class="math inline">\(dp[i]\)</span> is true, as mentioned before, we can split this prefix into 2 parts, a prefix of length j &lt; i which can be created by the words in the dictionary, and the remaining suffix which is exactly a single word in the dictionary.</p>
<p><span class="math inline">\(dp[i]\)</span> is true if and only if there is an integer j, such that 0 &lt;= j &lt; i and the word's substring (index range [j, i - 1]) is in the dictionary.</p>
<p><strong>Note: There is an corner case, when i == length, since we don't want to use the word in the dictionary directly, we should check 1 &lt;= j &lt; i instead.</strong></p>
<h4 id="the-answer">The answer</h4>
<p><span class="math inline">\(dp[word.length]\)</span> tells if the word can be created by concatenation.</p>
<p>Here is how the algorithm works with &quot;catsdogcats&quot; if we have &quot;cats&quot; and &quot;dog&quot; in the dictionary.</p>
<center>
<img src="../Figures/472/472_Concatenated_Words.png" width="500"/>
</center>
<br>
<p>For instance, <span class="math inline">\(dp[7]\)</span> tells if we can create &quot;catsdogs&quot; (the first 7 letters). It's true because we can split it into a prefix &quot;cats&quot; which we know we can create because <span class="math inline">\(dp[4]\)</span> is true, and a suffix &quot;dogs&quot;, which is in dictionary.</p>
<h4 id="steps">Steps</h4>
<ol>
<li>Put all the words into a HashSet as a <code>dictionary</code>.</li>
<li>Create an empty list <code>answer</code>.</li>
<li>For each <code>word</code> in the <code>words</code> create a boolean array <code>dp</code> of length = <code>word.length + 1</code>, and set dp[0] = true.</li>
<li>For each index <code>i</code> from 1 to <code>word.length</code>, set <code>dp[i]</code> to true if we can find a value <code>j</code> from 0 (1 if i == <code>word.length</code>) such that dp[j] = true and <code>word.substring(j, i)</code> is in the <code>dictionary</code>.</li>
<li>Put <code>word</code> into <code>answer</code> if dp[word.length] = true.</li>
<li>After processing all the <code>words</code>, return <code>answer</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HGHNkVYa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the total number of strings in the array <code>words</code>, namely <code>words.length</code>, and <span class="math inline">\(M\)</span> is the length of the longest string in the array <code>words</code>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(M ^ 3 \cdot N)\)</span>.</li>
</ul>
<p>Although we use HashSet, we need to consider the cost to calculate the hash value of a string internally which would be <span class="math inline">\(O(M)\)</span>. So putting all words into the HashSet takes <span class="math inline">\(O(N * M)\)</span>.<br />
For each word, the i and j loops take <span class="math inline">\(O(M ^ 2)\)</span>. The internal logic to take the substring and search in the HashSet needs to calculate the hash value for the substring too, and it should take another <span class="math inline">\(O(M)\)</span>, so for each word, the time complexity is <span class="math inline">\(O(M^3)\)</span> and the total time complexity for <span class="math inline">\(N\)</span> words is <span class="math inline">\(O(M ^ 3 \cdot N)\)</span></p>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>This is just the space to save all words in the <code>dictionary</code>, if we don't take <span class="math inline">\(M\)</span> as a constant.</p>
</li>
</ul>
<h3 id="approach-2-dfs">Approach 2: DFS</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As mentioned before, this problem can be transformed into a reachability problem and thus can be solved by a DFS (or BFS) algorithm. For each word, we construct a directed graph with all prefixes as nodes. For simplicity, we can represent each prefix by its length.</p>
<p>So the graph contains (word.length + 1) nodes.<br />
For edges, consider 2 prefixes i and j with 0 &lt;= i &lt; j &lt;= word.length, if prefix j can be created by concatenating prefix i and a word in the dictionary, we add a directed edge from node i to node j.</p>
<blockquote>
<p>When i = 0, we require <code>j &lt; word.length</code> as there should be an edge from node <code>0</code> to node <code>word.length</code>.<br />
Determining whether a word can be created by concatenating 2 or more words in the dictionary is the same as determining whether there is a path from node <code>0</code> to node <code>word.length</code> in the graph.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<p>For each word, construct the implicit graph mentioned above, then add it to the answer if the node <code>word.length</code> can be reached from node <code>0</code> in the graph which can be checked using DFS.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/E6gRtdWh/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the total number of strings in the array <code>words</code>, namely <code>words.length</code>, and <span class="math inline">\(M\)</span> is the length of the longest string in the array <code>words</code>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(M ^ 3 \cdot N)\)</span>.</li>
</ul>
<p>For each word, the constructed graph has <span class="math inline">\(M\)</span> nodes and <span class="math inline">\(O(M ^ 2)\)</span> edges, and the DFS algorithm for reachability is <span class="math inline">\(O(M ^ 2)\)</span> without considering the time complexities of substring and HashSet. If we consider everything, the time complexity to check one word is <span class="math inline">\(O(M ^ 3)\)</span> and the total time complexity to check all words is <span class="math inline">\(O(M ^ 3 \cdot N)\)</span>.</p>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>This is the space to save all words in the <code>dictionary</code>, if we don't take <span class="math inline">\(M\)</span> as a constant, there is also <span class="math inline">\(O(M)\)</span> for the call stack to execute DFS, which wouldn't affect the space complexity anyways.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/contiguous-elements-xor4151/1" target="_blank" rel="noopener noreferrer">Contiguous Elements XOR</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an array <strong>arr</strong>[] of <strong>N</strong> positive integers. This time you are supposed to choose numbers from a contiguous sub-sequence of the given array, so that <a href="https://www.geeksforgeeks.org/find-xor-of-two-number-without-using-xor-operator/"><strong>BITWISE XOR</strong></a> of all the chosen numbers is maximum.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 4
arr[] = {8,1,2,12}
<strong>Output: </strong>15<strong>
Explanation: 1</strong>, <strong>2</strong> and <strong>12</strong> can be chosen
from the array as contiguous sub
sequence which given us maximum
XOR value equal to 15.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 4
arr[] = {1,2,3,4}
<strong>Output: </strong>7<strong>
Explanation: 3</strong> and <strong>4</strong> from the array
can be chosen&nbsp; as contiguous sub
sequence which given us maximum XOR
value equal to 7.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />Complete <strong>maxSubarrayXOR&nbsp;</strong>function and return&nbsp;the maximum XOR value.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>5</sup><br />1 &lt;= arr[i] &lt;= 10<sup>6</sup> (Must be in range of 32 bits signed integer)</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity</strong> : O(NlogN)<br /><strong>Expected Auxilliary Space </strong>: O(N)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-of-distinct-substrings/1" target="_blank" rel="noopener noreferrer">Count of distinct substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a string of length <strong>N</strong> of lowercase alphabet characters. The task is to complete the function <strong>countDistinctSubstring(),</strong> which returns&nbsp;the count of <strong>total number of distinct substrings</strong> of this string.</span></p>

<p><span style="font-size:18px"><strong>Input:</strong><br />
The first line of input contains an integer <strong>T,</strong> denoting the number of test cases. Then T test cases follow. Each test case contains a string <strong>str</strong>.</span></p>

<p><span style="font-size:18px"><strong>Output:</strong><br />
For each test case in a new line, output will be an integer denoting&nbsp;count of total number of distinct substrings of this string.</span></p>

<p><span style="font-size:18px"><strong>User Task:</strong><br />
Since this is a functional problem you don&#39;t have to worry about input, you just have to complete the function <strong>countDistinctSubstring().</strong></span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le;&nbsp;T &le; 10<br />
1 &le;&nbsp;N &le;&nbsp;1000</span></p>

<p><span style="font-size:18px"><strong>Example(To be used only for expected output):<br />
Input:</strong><br />
2<br />
ab<br />
ababa</span></p>

<p><span style="font-size:18px"><strong>Output:</strong><br />
4<br />
10</span></p>

<p><span style="font-size:18px"><strong>Exaplanation:<br />
Testcase 1:</strong> For the given string &quot;ab&quot; the total distinct substrings are: &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;.</span><br />
&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-with-xor-in-a-range/description" target="_blank" rel="noopener noreferrer">Count Pairs With XOR in a Range</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>(0-indexed)</strong> integer array <code>nums</code> and two integers <code>low</code> and <code>high</code>, return <em>the number of <strong>nice pairs</strong></em>.</p>

<p>A <strong>nice pair</strong> is a pair <code>(i, j)</code> where <code>0 &lt;= i &lt; j &lt; nums.length</code> and <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,2,7], low = 2, high = 6
<strong>Output:</strong> 6
<strong>Explanation:</strong> All nice pairs (i, j) are as follows:
    - (0, 1): nums[0] XOR nums[1] = 5 
    - (0, 2): nums[0] XOR nums[2] = 3
    - (0, 3): nums[0] XOR nums[3] = 6
    - (1, 2): nums[1] XOR nums[2] = 6
    - (1, 3): nums[1] XOR nums[3] = 3
    - (2, 3): nums[2] XOR nums[3] = 5
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,8,4,2,1], low = 5, high = 14
<strong>Output:</strong> 8
<strong>Explanation:</strong> All nice pairs (i, j) are as follows:
​​​​​    - (0, 2): nums[0] XOR nums[2] = 13
&nbsp;   - (0, 3): nums[0] XOR nums[3] = 11
&nbsp;   - (0, 4): nums[0] XOR nums[4] = 8
&nbsp;   - (1, 2): nums[1] XOR nums[2] = 12
&nbsp;   - (1, 3): nums[1] XOR nums[3] = 10
&nbsp;   - (1, 4): nums[1] XOR nums[4] = 9
&nbsp;   - (2, 3): nums[2] XOR nums[3] = 6
&nbsp;   - (2, 4): nums[2] XOR nums[4] = 5</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= low &lt;= high &lt;= 2 * 10<sup>4</sup></code></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-prefix-and-suffix-pairs-i/description" target="_blank" rel="noopener noreferrer">Count Prefix and Suffix Pairs I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>

<ul>
	<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword="string-prefix">prefix</span> and a <span data-keyword="string-suffix">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>
</ul>

<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>

<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i, j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.
i = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.
i = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.
i = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.
Therefore, the answer is 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.
i = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.
Therefore, the answer is 2.  </pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]
<strong>Output:</strong> 0
<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.
Therefore, the answer is 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 50</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to count pairs of words where one word is both a prefix and a suffix of the other. A prefix of a string is a part of the string that appears at the start, and a suffix is a part of the string that appears at the end. For example, in the word <code>&quot;ababa&quot;</code>, <code>&quot;aba&quot;</code> is both a prefix and a suffix.</p>
<p>A simple logical solution is to use a brute-force approach, which involves comparing all pairs of words and checking if one word is a prefix and a suffix of the other.</p>
<blockquote>
<p>To check if one string is a prefix or suffix of another, we can use specific built-in functions in different programming languages:</p>
<ul>
<li>In C++, the <code>find</code> function checks if a string appears at the start, and <code>rfind</code> checks if it appears at the end.</li>
<li>In Java and Python3, the <code>startsWith</code> method verifies if a string appears at the start, and the <code>endsWith</code> method checks if it appears at the end.</li>
</ul>
</blockquote>
<p>To implement this, we loop through all pairs of words (<code>i</code>, <code>j</code>) and:</p>
<ul>
<li>For each pair, if <code>str1</code> is longer than <code>str2</code>, we skip that pair because <code>str1</code> cannot be a prefix or suffix of a smaller string.</li>
<li>If <code>str1</code> is both a prefix and a suffix of <code>str2</code>, we increment our count.</li>
</ul>
<p>We repeat this process until we exhaust all possibilities.</p>
<p>This works well for small inputs but becomes inefficient for larger input sizes because of the repeated checks for each pair of words.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of the list of words and <code>count</code> as <code>0</code> to track prefix-suffix pairs.</p>
</li>
<li>
<p>Iterate over all pairs of words:</p>
<ul>
<li>For each word at index <code>i</code>, iterate over all words at index <code>j</code> where <code>j &gt; i</code>.</li>
</ul>
</li>
<li>
<p>For each pair of words (<code>word1</code> and <code>word2</code>):</p>
<ul>
<li>Skip the pair if the length of <code>word1</code> is greater than the length of <code>word2</code>.</li>
<li>Check if <code>word1</code> is both a prefix and a suffix of <code>word2</code>:
<ul>
<li>Verify if <code>word2</code> starts with <code>word1</code>.</li>
<li>Verify if <code>word2</code> ends with <code>word1</code>.</li>
</ul>
</li>
<li>If both conditions are satisfied, increment <code>count</code>.</li>
</ul>
</li>
<li>
<p>Return <code>count</code> as the total number of prefix-suffix pairs.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5w2vLK3F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of words in the input array <code>words</code>, and let <span class="math inline">\(m\)</span> be the average length of the words.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m)\)</span></p>
<p>The algorithm involves a nested loop where the outer loop runs <span class="math inline">\(n\)</span> times and the inner loop runs <span class="math inline">\(n - i - 1\)</span> times for each iteration of the outer loop. For each pair of elements, the algorithm performs two operations:</p>
<ol>
<li>A prefix check using a substring search.</li>
<li>A suffix check using a reverse substring search.</li>
</ol>
<p>Both operations take <span class="math inline">\(O(m)\)</span> time in the worst case, where <span class="math inline">\(m\)</span> is the length of the element being processed. Therefore, the overall time complexity is <span class="math inline">\(O(n^2 \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm uses a fixed amount of extra space, regardless of the input size. The only additional space used is for the loop variables and the <code>count</code> variable, which do not depend on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dual-trie">Approach 2: Dual Trie</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The main challenge in the brute force approach is repeatedly checking for prefixes and suffixes for each word pair. This brings us to the idea of improving efficiency by using a Trie, a data structure that helps with fast prefix matching.</p>
<h5 id="what-is-a-trie">What is a Trie?</h5>
<p>A Trie is a tree-like structure where each node represents a character. When we insert words into a Trie, common prefixes are shared, allowing for efficient prefix lookups. For example, if we store <code>&quot;bat&quot;</code> and <code>&quot;ball&quot;</code>, the Trie would look like this:</p>
<pre><code>      (root)
       |
       b
       |
       a
      / \
     t   l
          \
           l
</code></pre>
<p>Notice how <code>&quot;b&quot;</code> and <code>&quot;a&quot;</code> are shared to save space.</p>
<p>Tries are useful in everyday examples like autocomplete, dictionaries, and word games:</p>
<ul>
<li>Autocomplete: When you type &quot;ca&quot; on your phone, it suggests words like &quot;cat&quot;, &quot;car&quot;, or &quot;can&quot;. It does this by looking up all the words that start with &quot;ca&quot; in a Trie.</li>
<li>Dictionaries: If you’re searching for words that begin with &quot;app&quot;, a Trie quickly finds options like &quot;apple&quot;, &quot;apply&quot;, and &quot;application&quot; without going through the whole list.</li>
<li>Word Games: In games like Scrabble or Boggle, Tries help check if a word is real or suggest possible words from your letters. Some puzzles, like Sudoku, use them too.</li>
</ul>
<p>When inserting a word into the prefix Trie, we are essentially storing all possible prefixes of that word. For example, if the word is <code>&quot;abzdcabz&quot;</code>, we add the following prefixes to the Trie: [<code>&quot;a&quot;</code>, <code>&quot;ab&quot;</code>, <code>&quot;abz&quot;</code>, <code>&quot;abzd&quot;</code>, <code>&quot;abzdc&quot;</code>, <code>&quot;abzdca&quot;</code>, <code>&quot;abzdcab&quot;</code>, <code>&quot;abzdcabz&quot;</code>]. This allows us to quickly determine if any other word starts with the same prefix.</p>
<p>For suffixes, rather than directly storing and checking suffixes (which would require reversing and checking repeatedly for every comparison), we use a trick to convert them to a prefix Trie:</p>
<ol>
<li>Reverse the word.</li>
<li>Insert the reversed word into a separate Trie.</li>
</ol>
<p>By treating the reversed word as a prefix, the suffix-checking problem is reduced to a prefix-matching problem. This allows us to use the same Trie structure for both tasks.</p>
<p>With both the prefix Trie and the suffix Trie set up, we can efficiently check for valid word pairs:</p>
<ul>
<li>For a given word <code>word[i]</code>, use the prefix Trie to check if another word shares the same prefix.</li>
<li>Use the suffix Trie to check if another word shares the same suffix (by checking the reversed version of the word).</li>
</ul>
<p>Let's check if <code>&quot;abz&quot;</code> is both a prefix and a suffix of <code>&quot;abzdcabz&quot;</code>.</p>
<p>First, we insert the string <code>&quot;abzdcabz&quot;</code> into a prefix Trie. This allows us to check if any prefix of a word matches the start of <code>&quot;abzdcabz&quot;</code>. Next, we reverse the string to <code>&quot;zbacdzba&quot;</code> and insert this reversed version into a suffix Trie. This enables us to check if any prefix of a word matches the reversed suffix of <code>&quot;abzdcabz&quot;</code>.</p>
<p>In this way:</p>
<ul>
<li>The prefix Trie for <code>&quot;abzdcabz&quot;</code> stores <code>&quot;abzdcabz&quot;</code>, <code>&quot;abzdcab&quot;</code>, <code>&quot;abzdc&quot;</code>, and so on.</li>
<li>The suffix Trie for <code>&quot;abzdcabz&quot;</code> stores <code>&quot;zbacdzba&quot;</code>, <code>&quot;zbacdzb&quot;</code>, <code>&quot;zbacdz&quot;</code>, and so on.</li>
</ul>
<p>Now, we check each previous word (where <code>j &lt; i</code>). For instance, let's consider <code>&quot;abz&quot;</code> as a previous word.</p>
<p>To verify, we check whether <code>&quot;abz&quot;</code> is a prefix in the prefix Trie and whether <code>&quot;zba&quot;</code> (the reverse of <code>&quot;abz&quot;</code>) is a prefix in the suffix Trie.</p>
<p>In this case:</p>
<ul>
<li><code>&quot;abz&quot;</code> is a prefix of <code>&quot;abzdcabz&quot;</code>, and</li>
<li><code>&quot;zba&quot;</code> (the reversed <code>&quot;abz&quot;</code>) is a prefix of <code>&quot;zbacdzba&quot;</code>, the reversed string of <code>&quot;abzdcabz&quot;</code>.</li>
</ul>
<p>Thus, we count this pair as valid.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/3042/trie.json:805,355!?!</p>
<blockquote>
<p>For a more comprehensive understanding of tries, check out the <a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card 🔗</a>. This resource provides an in-depth look at the trie data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="trie-initialization">Trie Initialization:</h5>
<ul>
<li>Define a <code>Node</code> class that represents each node in the Trie. Each node contains an array <code>links[26]</code> to represent links to <code>26</code> lowercase letters (<code>a</code> - <code>z</code>).</li>
<li>Provide functions:
<ul>
<li><code>contains(c)</code>: Check if a link for character <code>c</code> exists.</li>
<li><code>put(c, node)</code>: Insert a new node for character <code>c</code>.</li>
<li><code>next(c)</code>: Get the next node for character <code>c</code>.</li>
</ul>
</li>
</ul>
<h5 id="trie-insertions--prefix-search">Trie Insertions / Prefix Search:</h5>
<ul>
<li>
<p>Define a <code>Trie</code> class which contains a root node and provides the function <code>insert(word)</code> to insert a word into the Trie and <code>startsWith(prefix)</code> for prefix search:</p>
</li>
<li>
<p><code>insert(word)</code> function:</p>
<ul>
<li>For each character in the word, check if it already exists as a link from the current node. If not, create a new node.</li>
<li>Move to the next node for each character until the entire word is inserted.</li>
</ul>
</li>
<li>
<p><code>startsWith(prefix)</code> function:</p>
<ul>
<li>Traverse the Trie from the root, following the links for each character in the prefix.</li>
<li>If a character link does not exist, return <code>false</code>, indicating the prefix doesn't exist in the Trie.</li>
<li>If the traversal finishes successfully, return <code>true</code>, indicating the prefix exists.</li>
</ul>
</li>
</ul>
<h5 id="main-algorithm-countprefixsuffixpairs">Main Algorithm (countPrefixSuffixPairs):</h5>
<ul>
<li>
<p>Initialize a counter <code>count</code> to 0.</p>
</li>
<li>
<p>For each word in <code>words</code>, do the following:</p>
<ul>
<li>Create two Tries: <code>prefixTrie</code> for storing prefixes of the word and <code>suffixTrie</code> for storing reversed suffixes.</li>
<li>Insert the word into <code>prefixTrie</code> and its reversed version into <code>suffixTrie</code>.</li>
</ul>
</li>
<li>
<p>For each word <code>words[j]</code> (where <code>j &lt; i</code>), check the following:</p>
<ul>
<li>If the length of <code>words[j]</code> is greater than <code>words[i]</code>, skip to the next <code>j</code>.</li>
<li>Extract the prefix <code>prefixWord</code> from <code>words[j]</code> and reverse it to get <code>revPrefixWord</code>.</li>
<li>Check if <code>prefixWord</code> exists in the <code>prefixTrie</code> and <code>revPrefixWord</code> exists in the <code>suffixTrie</code>:
<ul>
<li>If both are true, increment the <code>count</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>count</code> of prefix-suffix pairs.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/egLL23Vb/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of words in the input array <code>words</code>, and let <span class="math inline">\(m\)</span> be the average length of the words.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m)\)</span></p>
<p>The algorithm involves a nested loop where the outer loop runs <span class="math inline">\(n\)</span> times and the inner loop runs <span class="math inline">\(i\)</span> times for each iteration of the outer loop. For each pair of words, the <code>insert</code> and <code>startsWith</code> operations are performed on the Trie. The <code>insert</code> operation takes <span class="math inline">\(O(m)\)</span> time, and the <code>startsWith</code> operation also takes <span class="math inline">\(O(m)\)</span> time. Therefore, the overall time complexity is <span class="math inline">\(O(n^2 \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is determined by the space used by the Tries. Each Trie can store up to <span class="math inline">\(m\)</span> nodes (one for each character in the word), and since there are <span class="math inline">\(n\)</span> words, the total space required for the Tries is <span class="math inline">\(O(n \cdot m)\)</span>. Additionally, the algorithm uses a constant amount of extra space for variables and temporary storage, but this is dominated by the space used by the Tries.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-prefix-and-suffix-pairs-ii/description" target="_blank" rel="noopener noreferrer">Count Prefix and Suffix Pairs II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>

<ul>
	<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword="string-prefix">prefix</span> and a <span data-keyword="string-suffix">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>
</ul>

<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>

<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i<em>, </em>j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.
i = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.
i = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.
i = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.
Therefore, the answer is 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.
i = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.
Therefore, the answer is 2.  </pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]
<strong>Output:</strong> 0
<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.
Therefore, the answer is 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10<sup>5</sup></code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li>The sum of the lengths of all <code>words[i]</code> does not exceed <code>5 * 10<sup>5</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-words-in-a-trie/1" target="_blank" rel="noopener noreferrer">Count words in a Trie</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an array of strings <strong>s</strong> which is converted into a Trie <strong>root</strong>. You need to use the given trie root to count and return the <strong>number of words</strong> stored in the trie.<br /><strong><br />Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> s[ ] = ["the", "a", "there", "answer", "any", "by", "bye", "their"]<br /><strong>Output:</strong> 8<br /><strong>Explanation: </strong>The given array of string is converted into a trie. Now, the number of words in the trie are 8, which is the total number of words given in the array s.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/876295/Web/Other/blobid2_1729009957.png" alt="" width="101" height="266" /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>&nbsp;s[ ] = [</span><span style="font-size: 18.6667px;">"go", </span><span style="font-size: 18.6667px;">"good", </span><span style="font-size: 18.6667px;">"pin", </span><span style="font-size: 18.6667px;">"pink", </span><span style="font-size: 14pt;">"brown"</span><span style="font-size: 14pt;">]<br /><strong>Output:</strong> 5<br /><strong>Explanation:&nbsp;</strong>The given array of string is converted into a trie. Now, the number of words in the trie are 5, which is the total number of words given in the array s.<br /></span><br /><span style="font-size: 14pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/876295/Web/Other/blobid3_1729009957.png" alt="" width="97" height="295" /><br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:&nbsp;</strong><br />1 &lt;= s.size() &lt;= 10<sup>3</sup><br />1 &lt;= s[i] &lt;= 10<sup>3</sup><br />s[i] contains only small case English alphabets</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-duplicate-folders-in-system/description" target="_blank" rel="noopener noreferrer">Delete Duplicate Folders in System</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Due to a bug, there are many duplicate folders in a file system. You are given a 2D array <code>paths</code>, where <code>paths[i]</code> is an array representing an absolute path to the <code>i<sup>th</sup></code> folder in the file system.</p>

<ul>
	<li>For example, <code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code> represents the path <code>&quot;/one/two/three&quot;</code>.</li>
</ul>

<p>Two folders (not necessarily on the same level) are <strong>identical</strong> if they contain the <strong>same non-empty</strong> set of identical subfolders and underlying subfolder structure. The folders <strong>do not</strong> need to be at the root level to be identical. If two or more folders are <strong>identical</strong>, then <strong>mark</strong> the folders as well as all their subfolders.</p>

<ul>
	<li>For example, folders <code>&quot;/a&quot;</code> and <code>&quot;/b&quot;</code> in the file structure below are identical. They (as well as their subfolders) should <strong>all</strong> be marked:

	<ul>
		<li><code>/a</code></li>
		<li><code>/a/x</code></li>
		<li><code>/a/x/y</code></li>
		<li><code>/a/z</code></li>
		<li><code>/b</code></li>
		<li><code>/b/x</code></li>
		<li><code>/b/x/y</code></li>
		<li><code>/b/z</code></li>
	</ul>
	</li>
	<li>However, if the file structure also included the path <code>&quot;/b/w&quot;</code>, then the folders <code>&quot;/a&quot;</code> and <code>&quot;/b&quot;</code> would not be identical. Note that <code>&quot;/a/x&quot;</code> and <code>&quot;/b/x&quot;</code> would still be considered identical even with the added folder.</li>
</ul>

<p>Once all the identical folders and their subfolders have been marked, the file system will <strong>delete</strong> all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted.</p>

<p>Return <em>the 2D array </em><code>ans</code> <em>containing the paths of the <strong>remaining</strong> folders after deleting all the marked folders. The paths may be returned in <strong>any</strong> order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg" style="width: 200px; height: 218px;" />
<pre>
<strong>Input:</strong> paths = [[&quot;a&quot;],[&quot;c&quot;],[&quot;d&quot;],[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;d&quot;,&quot;a&quot;]]
<strong>Output:</strong> [[&quot;d&quot;],[&quot;d&quot;,&quot;a&quot;]]
<strong>Explanation:</strong> The file structure is as shown.
Folders &quot;/a&quot; and &quot;/c&quot; (and their subfolders) are marked for deletion because they both contain an empty
folder named &quot;b&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg" style="width: 200px; height: 355px;" />
<pre>
<strong>Input:</strong> paths = [[&quot;a&quot;],[&quot;c&quot;],[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;x&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;],[&quot;w&quot;],[&quot;w&quot;,&quot;y&quot;]]
<strong>Output:</strong> [[&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;]]
<strong>Explanation: </strong>The file structure is as shown. 
Folders &quot;/a/b/x&quot; and &quot;/w&quot; (and their subfolders) are marked for deletion because they both contain an empty folder named &quot;y&quot;.
Note that folders &quot;/a&quot; and &quot;/c&quot; are identical after the deletion, but they are not deleted because they were not marked beforehand.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg" style="width: 200px; height: 201px;" />
<pre>
<strong>Input:</strong> paths = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;],[&quot;c&quot;],[&quot;a&quot;]]
<strong>Output:</strong> [[&quot;c&quot;],[&quot;c&quot;,&quot;d&quot;],[&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;]]
<strong>Explanation:</strong> All folders are unique in the file system.
Note that the returned array can be in a different order as the order does not matter.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= paths[i].length &lt;= 500</code></li>
	<li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>
	<li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>path[i][j]</code> consists of lowercase English letters.</li>
	<li>No two paths lead to the same folder.</li>
	<li>For any folder not at the root level, its parent folder will also be in the input.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-serialization-based-representation-of-subtrees">Approach: Serialization-Based Representation of Subtrees</h3>
<h4 id="intuition">Intuition</h4>
<p>We can approach this problem at an abstract level (without worrying about implementation details at first) in three main steps:</p>
<ol>
<li>
<p>Build a tree representation of the file system using the input <span class="math inline">\(\textit{paths}\)</span>. This tree is a multi-way tree rooted at /, where each non-root node represents a folder.</p>
</li>
<li>
<p>Traverse the tree starting from the root. As stated in the problem, if two nodes <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> contain subfolders with the same structure (i.e., the same nested arrangement of subfolders, recursively), then both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> must be deleted. Therefore, to determine the structure of a node’s subtree, we must first traverse all its children and then backtrack to process the node itself. This corresponds to a post-order traversal of a multi-way tree.</p>
</li>
</ol>
<p>While backtracking to a node, we serialize its structure and store it in a data structure for later comparison with other nodes.</p>
<ol start="3">
<li>Traverse the tree again from the root. When visiting a node <span class="math inline">\(x\)</span>, if its serialized structure appears more than once in the data structure, it means a duplicate exists, and we delete <span class="math inline">\(x\)</span> (i.e., skip it). Otherwise, <span class="math inline">\(x\)</span> is unique, and we record the path from the root to <span class="math inline">\(x\)</span> in the final answer, then recursively visit its children.</li>
</ol>
<p>After this second traversal, all duplicate folders will have been removed, and we will have collected the remaining unique folder paths.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Let’s now solve these three steps one by one:</p>
<p><strong>Step 1: Build the Tree</strong></p>
<p>We define a class to represent the nodes of the tree. We create a root node, and for each path in <span class="math inline">\(\textit{paths}\)</span>, we insert its folders into the tree. If you're familiar with the Trie data structure, this step will feel familiar.</p>
<p><strong>Step 2: Serialize and Identify Duplicates</strong></p>
<p>The challenge here is not the post-order traversal itself, but rather how to represent the &quot;structure&quot; of a node in a way that can be used to compare nodes.</p>
<p>To do this, we adopt a serialization approach similar to what is used in <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">&quot;297. Serialize and Deserialize Binary Tree&quot;</a>. Let <span class="math inline">\(\text{serial}(x)\)</span> represent the serialized structure of node <span class="math inline">\(x\)</span>. We define it as follows:</p>
<ul>
<li>
<p>If <span class="math inline">\(x\)</span> is a leaf node (i.e., has no children), then <span class="math inline">\(\text{serial}(x)\)</span> is an empty string <code>&quot;&quot;</code>. For instance, in Example 1, the three leaf nodes <code>b</code>, <code>b</code>, and <code>a</code> all serialize to <code>&quot;&quot;</code>.</p>
</li>
<li>
<p>If <span class="math inline">\(x\)</span> has children <span class="math inline">\(y_1, y_2, \dots, y_k\)</span>, then:</p>
<p><span class="math display">\[\text{serial}(x) = y_1(\text{serial}(y_1))y_2(\text{serial}(y_2))\cdots y_k(\text{serial}(y_k))
\]</span></p>
<p>In words, we recursively serialize each child, attach its folder name in front of its serialization, and wrap its structure in parentheses. The result is a string representing the structure of <span class="math inline">\(x\)</span>'s subtree.</p>
<p>However, this naive approach can be order-sensitive. If <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> have the same children but in different orders, their serializations will differ, even though their structures are equivalent. To handle this, we sort the serialized representations of children before concatenating. This ensures consistent serialization for equivalent subtrees.</p>
</li>
</ul>
<p>After a single post-order traversal of the tree, we can record all serializations in a hash map, where the key is the serialization and the value is its frequency.</p>
<p><strong>Step 3: Collect Unique Paths</strong></p>
<p>We now perform another DFS traversal from the root. We maintain a list path that tracks the current folder path. At each node:</p>
<ul>
<li>If the node’s serialization appears more than once in the map, it is a duplicate and should be skipped.</li>
<li>Otherwise, the path to this node is added to the final answer, and we recursively traverse its children.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>The C++ code below builds the tree, serializes it using post-order traversal, and collects the unique folder paths. Note: this version does <strong>not free memory</strong> after execution; in an interview, you may ask whether tree destruction is required.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/74j7V8qy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity analysis</h4>
<p>We focus here on the time required to compute the serialization of all node structures and the space required to store them in a hash map. All other operations, whether time- or space-related, are asymptotically smaller and can therefore be ignored.</p>
<p>In the worst case, each node in the tree has a unique serialized structure. Thus, the time and space complexities are both proportional to the total length of all serialized strings. Our task is to find an upper bound on this total length.</p>
<p>To do this, we use an important and intuitive result from tree theory:</p>
<blockquote>
<p>Let <span class="math inline">\(T\)</span> be an unordered rooted tree. For a node <span class="math inline">\(x\)</span> in <span class="math inline">\(T\)</span>, define:</p>
<ul>
<li><span class="math inline">\(\textit{dist}[x]\)</span>: the number of nodes on the path from the root to <span class="math inline">\(x\)</span></li>
<li><span class="math inline">\(\textit{size}[x]\)</span>: the size of the subtree rooted at <span class="math inline">\(x\)</span><br />
Then:</li>
</ul>
<p><span class="math display">\[\sum_{x \in T} \textit{dist}[x] = \sum_{x \in T} \textit{size}[x]
\]</span></p>
</blockquote>
<p><strong>Why this holds:</strong><br />
For any node <span class="math inline">\(x'\)</span>, it contributes to the subtree size of each of its ancestors (including itself). Therefore, <span class="math inline">\(x'\)</span> appears once in the subtree size of every node along its path from the root. So the total number of appearances of all nodes across all subtree sizes equals the sum of all distances from the root.</p>
<p>Now, returning to our problem:</p>
<ul>
<li>
<p>The input array paths encodes the full paths from the root to each folder, and the total number of characters across all paths is bounded by <span class="math inline">\(2 \times 10^5\)</span>.</p>
</li>
<li>
<p>So <span class="math inline">\(\sum \textit{dist}[x] \leq 2 \times 10^5\)</span></p>
</li>
<li>
<p>And therefore <span class="math inline">\(\sum \textit{size}[x] \leq 2 \times 10^5\)</span></p>
</li>
</ul>
<p>For each node <span class="math inline">\(x\)</span>, the length of its serialized string representation includes two components:</p>
<ol>
<li>
<p>The sum of the lengths of the folder names of all its subfolders. Each subfolder name can have at most 10 characters, so this part is bounded by <span class="math inline">\(10 \cdot \textit{size}[x]\)</span>.</p>
</li>
<li>
<p>The number of parentheses used for structural disambiguation. Each subfolder is wrapped in a pair of parentheses, contributing at most <span class="math inline">\(2 \cdot \textit{size}[x]\)</span> characters.</p>
</li>
</ol>
<p>Thus, for any node <span class="math inline">\(x\)</span>, the total serialization length is at most:</p>
<p><span class="math display">\[12 \cdot \textit{size}[x]
\]</span></p>
<p>So the total length of all serialized strings across the entire tree is:</p>
<p><span class="math display">\[12 \cdot \sum_{x \in T} \textit{size}[x] \leq 12 \cdot 2 \times 10^5 = 2.4 \times 10^6
\]</span></p>
<p>Hence, the space complexity is <span class="math inline">\(\mathcal{O}(10^6)\)</span> in the worst case.</p>
<p>As for the time complexity, even if we account for sorting the child structures (which adds an extra <span class="math inline">\(\log\)</span> factor), the total operations remain bounded by around <span class="math inline">\(10^7\)</span>, which comfortably fits within the time limits.</p>
<p>It's worth noting that this upper-bound analysis assumes extremely pessimistic and adversarial cases. In practical scenarios, the actual runtime is significantly lower, and this method performs very efficiently.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-add-and-search-words-data-structure/description" target="_blank" rel="noopener noreferrer">Design Add and Search Words Data Structure</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>

<p>Implement the <code>WordDictionary</code> class:</p>

<ul>
	<li><code>WordDictionary()</code>&nbsp;Initializes the object.</li>
	<li><code>void addWord(word)</code> Adds <code>word</code> to the data structure, it can be matched later.</li>
	<li><code>bool search(word)</code>&nbsp;Returns <code>true</code> if there is any string in the data structure that matches <code>word</code>&nbsp;or <code>false</code> otherwise. <code>word</code> may contain dots <code>&#39;.&#39;</code> where dots can be matched with any letter.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example:</strong></p>

<pre>
<strong>Input</strong>
[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]
[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]
<strong>Output</strong>
[null,null,null,null,false,true,true,true]

<strong>Explanation</strong>
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord(&quot;bad&quot;);
wordDictionary.addWord(&quot;dad&quot;);
wordDictionary.addWord(&quot;mad&quot;);
wordDictionary.search(&quot;pad&quot;); // return False
wordDictionary.search(&quot;bad&quot;); // return True
wordDictionary.search(&quot;.ad&quot;); // return True
wordDictionary.search(&quot;b..&quot;); // return True
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 25</code></li>
	<li><code>word</code> in <code>addWord</code> consists of lowercase English letters.</li>
	<li><code>word</code> in <code>search</code> consist of <code>&#39;.&#39;</code> or lowercase English letters.</li>
	<li>There will be at most <code>2</code> dots in <code>word</code> for <code>search</code> queries.</li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>addWord</code> and <code>search</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/design-add-and-search-words-data-structure--154618/1" target="_blank" rel="noopener noreferrer">Design Add and Search Words Data Structure</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Design a data structure that supports adding new words and finding if a string matches any already existing string.<br /><br /></span><span style="font-size: 14pt;">Implement the <strong>WordDictionary</strong> class:</span></p>
<ul>
<li><span style="font-size: 14pt;"><strong>WordDictionary()</strong>: Initializes the object</span></li>
<li><span style="font-size: 14pt;"><strong>void addWord(word)</strong>: Adds <strong>word</strong> to the data structure</span></li>
<li><span style="font-size: 14pt;"><strong>bool search(word)</strong>: Returns <strong>true</strong> if <strong>word</strong> exists in the data structure or <strong>false</strong> otherwise, <strong>word</strong> may contain dosts <strong>'.'</strong> which can be matched with any letter.</span></li>
</ul>
<p><strong><span style="font-size: 14pt;">Example:</span></strong></p>
<pre><strong><span style="font-size: 14pt;">Input: <br /></span></strong><span style="font-size: 14pt;">Function calls - </span><span style="font-size: 14pt;">[ "WordDictionary", "addWord", "addWord", "addWord", "search", "search", "search", "search" ]<br /></span><span style="font-size: 14pt;">word passed - [ [""], ["bad"], ["dad"], ["mad"], ["pad"], ["bad"], [".ad"], ["b.."] ] </span><br /><strong><span style="font-size: 14pt;">Output:</span></strong><span style="font-size: 14pt;"> [ null, null, null, null, false, true, true, true]</span><br /><strong><span style="font-size: 14pt;">Explanation: <br /></span></strong><span style="font-size: 14pt;">WordDictionary wd = new WordDictionary(); // Class Object created</span><br /><span style="font-size: 14pt;">wd.addWord("bad"); // word inserted</span><br /><span style="font-size: 14pt;">wd.addWord("dad"); // word inserted</span><br /><span style="font-size: 14pt;">wd.addWord("mad"); // word inserted</span><br /><span style="font-size: 14pt;">wd.search("pad"); // no match found // return false</span><br /><span style="font-size: 14pt;">wd.search("bad"); // match found // return true</span><br /><span style="font-size: 14pt;">wd.search(".ad"); // matches found ( "bad", "dad", "mad" ) // return true</span><br /><span style="font-size: 14pt;">wd.search("b.."); // match found ( "bad" ) // return true</span></pre>
<pre><strong><span style="font-size: 14pt;">Input: <br /></span></strong><span style="font-size: 14pt;">Function calls - </span><span style="font-size: 14pt;">[ "WordDictionary", "addWord", "addWord", "search", "search", "addWord", "search" ]<br /></span><span style="font-size: 14pt;">word passed - [ [""], ["apple"], ["bread"], ["apple"], ["b.oad"], ["chair"], ["bread"], ["table"] ] </span><br /><strong><span style="font-size: 14pt;">Output:</span></strong><span style="font-size: 14pt;"> [ null, null, null, true, false, null, true]</span><br /><strong><span style="font-size: 14pt;">Explanation: <br /></span></strong><span style="font-size: 14pt;">WordDictionary wd = new WordDictionary(); // Class Object created<br /></span><span style="font-size: 14pt;">wd.addWord("apple"); // word inserted</span><br /><span style="font-size: 14pt;">wd.addWord("bread"); // word inserted</span><br /><span style="font-size: 14pt;">wd.search("apple"); // match found // return true</span><br /><span style="font-size: 14pt;">wd.search("b.oad"); // no match found // return false</span><br /><span style="font-size: 14pt;">wd.addWord("chair"); // word inserted</span><br /><span style="font-size: 14pt;">wd.search("table"); // matche found // return true</span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1&nbsp; &lt;=&nbsp; word.length&nbsp; &lt;=&nbsp; 25<br /><strong>word</strong> in <strong>addWord</strong> consists of only lowercase letters<br /><strong>word</strong> in <strong>search</strong> consists of '.' and lowercase letters<br />There will be atmost <strong>2</strong> dots <strong>'.'</strong> in <strong>word</strong> for <strong>search</strong> queries<br />Atmost <strong>10<sup>4</sup></strong> calls will be made for <strong>addWord</strong> and <strong>search</strong> queries<sup>&nbsp;&nbsp;</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/distinct-echo-substrings/description" target="_blank" rel="noopener noreferrer">Distinct Echo Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Return the number of <strong>distinct</strong> non-empty substrings of <code>text</code>&nbsp;that can be written as the concatenation of some string with itself (i.e. it can be written as <code>a + a</code>&nbsp;where <code>a</code> is some string).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;abcabcabc&quot;
<strong>Output:</strong> 3
<b>Explanation: </b>The 3 substrings are &quot;abcabc&quot;, &quot;bcabca&quot; and &quot;cabcab&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;leetcodeleetcode&quot;
<strong>Output:</strong> 2
<b>Explanation: </b>The 2 substrings are &quot;ee&quot; and &quot;leetcodeleetcode&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length &lt;= 2000</code></li>
	<li><code>text</code>&nbsp;has only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/encrypt-and-decrypt-strings/description" target="_blank" rel="noopener noreferrer">Encrypt and Decrypt Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a character array <code>keys</code> containing <strong>unique</strong> characters and a string array <code>values</code> containing strings of length 2. You are also given another string array <code>dictionary</code> that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a <strong>0-indexed</strong> string.</p>

<p>A string is <strong>encrypted</strong> with the following process:</p>

<ol>
	<li>For each character <code>c</code> in the string, we find the index <code>i</code> satisfying <code>keys[i] == c</code> in <code>keys</code>.</li>
	<li>Replace <code>c</code> with <code>values[i]</code> in the string.</li>
</ol>

<p>Note that in case a character of the string is <strong>not present</strong> in <code>keys</code>, the encryption process cannot be carried out, and an empty string <code>&quot;&quot;</code> is returned.</p>

<p>A string is <strong>decrypted</strong> with the following process:</p>

<ol>
	<li>For each substring <code>s</code> of length 2 occurring at an even index in the string, we find an <code>i</code> such that <code>values[i] == s</code>. If there are multiple valid <code>i</code>, we choose <strong>any</strong> one of them. This means a string could have multiple possible strings it can decrypt to.</li>
	<li>Replace <code>s</code> with <code>keys[i]</code> in the string.</li>
</ol>

<p>Implement the <code>Encrypter</code> class:</p>

<ul>
	<li><code>Encrypter(char[] keys, String[] values, String[] dictionary)</code> Initializes the <code>Encrypter</code> class with <code>keys, values</code>, and <code>dictionary</code>.</li>
	<li><code>String encrypt(String word1)</code> Encrypts <code>word1</code> with the encryption process described above and returns the encrypted string.</li>
	<li><code>int decrypt(String word2)</code> Returns the number of possible strings <code>word2</code> could decrypt to that also appear in <code>dictionary</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Encrypter&quot;, &quot;encrypt&quot;, &quot;decrypt&quot;]
[[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], [&quot;ei&quot;, &quot;zf&quot;, &quot;ei&quot;, &quot;am&quot;], [&quot;abcd&quot;, &quot;acbd&quot;, &quot;adbc&quot;, &quot;badc&quot;, &quot;dacb&quot;, &quot;cadb&quot;, &quot;cbda&quot;, &quot;abad&quot;]], [&quot;abcd&quot;], [&quot;eizfeiam&quot;]]
<strong>Output</strong>
[null, &quot;eizfeiam&quot;, 2]

<strong>Explanation</strong>
Encrypter encrypter = new Encrypter([[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], [&quot;ei&quot;, &quot;zf&quot;, &quot;ei&quot;, &quot;am&quot;], [&quot;abcd&quot;, &quot;acbd&quot;, &quot;adbc&quot;, &quot;badc&quot;, &quot;dacb&quot;, &quot;cadb&quot;, &quot;cbda&quot;, &quot;abad&quot;]);
encrypter.encrypt(&quot;abcd&quot;); // return &quot;eizfeiam&quot;. 
&nbsp;                          // &#39;a&#39; maps to &quot;ei&quot;, &#39;b&#39; maps to &quot;zf&quot;, &#39;c&#39; maps to &quot;ei&quot;, and &#39;d&#39; maps to &quot;am&quot;.
encrypter.decrypt(&quot;eizfeiam&quot;); // return 2. 
                              // &quot;ei&quot; can map to &#39;a&#39; or &#39;c&#39;, &quot;zf&quot; maps to &#39;b&#39;, and &quot;am&quot; maps to &#39;d&#39;. 
                              // Thus, the possible strings after decryption are &quot;abad&quot;, &quot;cbad&quot;, &quot;abcd&quot;, and &quot;cbcd&quot;. 
                              // 2 of those strings, &quot;abad&quot; and &quot;abcd&quot;, appear in dictionary, so the answer is 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= keys.length == values.length &lt;= 26</code></li>
	<li><code>values[i].length == 2</code></li>
	<li><code>1 &lt;= dictionary.length &lt;= 100</code></li>
	<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>
	<li>All <code>keys[i]</code> and <code>dictionary[i]</code> are <strong>unique</strong>.</li>
	<li><code>1 &lt;= word1.length &lt;= 2000</code></li>
	<li><code>2 &lt;= word2.length &lt;= 200</code></li>
	<li>All <code>word1[i]</code> appear in <code>keys</code>.</li>
	<li><code>word2.length</code> is even.</li>
	<li><code>keys</code>, <code>values[i]</code>, <code>dictionary[i]</code>, <code>word1</code>, and <code>word2</code> only contain lowercase English letters.</li>
	<li>At most <code>200</code> calls will be made to <code>encrypt</code> and <code>decrypt</code> <strong>in total</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/extra-characters-in-a-string/description" target="_blank" rel="noopener noreferrer">Extra Characters in a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code> and a dictionary of words <code>dictionary</code>. You have to break <code>s</code> into one or more <strong>non-overlapping</strong> substrings such that each substring is present in <code>dictionary</code>. There may be some <strong>extra characters</strong> in <code>s</code> which are not present in any of the substrings.</p>

<p>Return <em>the <strong>minimum</strong> number of extra characters left over if you break up </em><code>s</code><em> optimally.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetscode&quot;, dictionary = [&quot;leet&quot;,&quot;code&quot;,&quot;leetcode&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can break s in two substrings: &quot;leet&quot; from index 0 to 3 and &quot;code&quot; from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.

</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;sayhelloworld&quot;, dictionary = [&quot;hello&quot;,&quot;world&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can break s in two substrings: &quot;hello&quot; from index 3 to 7 and &quot;world&quot; from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 50</code></li>
	<li><code>1 &lt;= dictionary.length &lt;= 50</code></li>
	<li><code>1 &lt;= dictionary[i].length &lt;= 50</code></li>
	<li><code>dictionary[i]</code>&nbsp;and <code>s</code> consists of only lowercase English letters</li>
	<li><code>dictionary</code> contains distinct words</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem is about breaking a given string, <code>s</code> of length <code>n</code>, into non-overlapping substrings such that each substring is present in a given <code>dictionary</code> of words. The objective is to minimize the number of extra characters left over after the string is broken up optimally. The maximum number of characters that could possibly be left over after breaking up the string is <code>n</code>. This is the case where we find no match in the <code>dictionary</code> and all the characters must be removed. In the best-case scenario, no characters need to be removed (i.e. we can match every character to a non overlapping substring)</p>
<hr />
<h3 id="approach-1-top-down-dynamic-programming-with-substring-method">Approach 1: Top Down Dynamic Programming with Substring Method</h3>
<h4 id="intuition">Intuition</h4>
<p>We will consider breaking the given string into non-overlapping substrings that exist in the dictionary while minimizing the number of extra characters left over.</p>
<p>To solve this problem, we can utilize a recursive approach with memoization. We define a recursive function <code>dp</code> that takes an index <code>start</code> as a parameter. This index represents the current position in the string where we are considering adding characters to form a valid word. The function <code>dp</code> returns the minimum number of extra characters needed to form a valid concatenation of words starting from the <code>start</code> index.</p>
<p>The <code>dp</code> function represents the dynamic programming approach used to solve the problem. It takes a single argument, <code>start</code>, which represents the index in the string <code>s</code> that we are currently considering. We will try to find a word in <code>dictionary</code> that <strong>starts</strong> at this index.</p>
<p>The function <code>dp</code> returns the minimum number of extra characters needed to form a valid concatenation of words starting from the <code>start</code> index.</p>
<p>The recurrence relation in the <code>dp</code> function is as follows:</p>
<ul>
<li>If the <code>start</code> index reaches the end of the string (<code>start == n</code>), indicating that we have considered all characters in <code>s</code>, the function returns 0, as no extra characters are needed.</li>
<li>If the <code>start</code> index is not at the end of the string, the function considers two possibilities:
<ol>
<li>Counting the current character at <code>start</code> as an extra character by recursively calling <code>dp</code> with the next index (<code>start + 1</code>). This corresponds to the case where the current character is not part of any valid word in the dictionary. The result is incremented by 1, as we are counting the current character as an extra.</li>
<li>Iterating over all possible <code>end</code> indices from <code>start</code> to the end of the string. For each <code>end</code>, the function checks if the substring <code>s[start:end+1]</code> exists in <code>dictionary</code>. We can convert <code>dictionary</code> to a set before starting the DP to make these checks more efficient. If it does, the function recursively calls <code>dp</code> with the next index after the valid word's end index, <code>end + 1</code>. The result is updated to the minimum value between the current minimum and the value returned from the recursive call.</li>
</ol>
</li>
</ul>
<p>For each recursive call, we keep track of the minimum number of extra characters needed to form a valid concatenation. We update this minimum by considering both possibilities and selecting the option with the minimum number of extra characters.</p>
<p>To optimize the solution, we use memoization, which allows us to avoid redundant calculations. By caching the results of previously computed recursive calls, we can retrieve them directly instead of recomputing them, which significantly improves the efficiency of the algorithm.</p>
<p>The initial call to the recursive function is made with <code>start</code> set to 0, indicating that we start from the beginning of the string. The result of the function is the minimum number of extra characters needed to form a valid concatenation of words from the dictionary.</p>
<p>Here's how this algorithm will work for the string s <code>&quot;LTSCD&quot;</code> and dictionary <code>[&quot;LT&quot;, &quot;CD&quot;]</code>:</p>
<p><img src="../Figures/2707/FigA.png" alt="figA" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>To achieve <code>O(1)</code> lookups, convert the list of strings in the dictionary to a set.</li>
<li>Define a recursive function called <code>dp</code> that takes the starting index of the substring as a parameter.</li>
<li>At each recursive call of <code>dp</code> check if the starting index <code>start</code> has reached the end of the string <code>s</code>. If so, return 0.</li>
<li>Set <code>ans</code>, the answer for the current state, to <code>dp(start + 1) + 1</code>.</li>
<li>If the starting index is not at the end of the string, explore all possible substrings starting from the current index <code>start</code>.</li>
<li>For each possible substring, checks if it exists in the <code>dictionary</code>. If it does, recursively calculate the minimum number of extra characters starting from the next index <code>dp(end + 1)</code>.</li>
<li>Keep track of the minimum number of extra characters encountered so far (<code>ans</code>) and update it whenever a lower value is found.</li>
<li>To optimize the solution and avoid redundant computations, utilize memoization. Store the results of previously computed subproblems in a separate data structure.</li>
<li>Finally, call the <code>dp</code> function with the starting index set to 0.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: In Python, we are using <code>@functools.cache</code> to perform the memoization.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/4Utr3H9x/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the total characters in the string.<br />
Let <span class="math inline">\(M\)</span> be the average length of the strings in <code>dictionary</code>.<br />
Let <span class="math inline">\(K\)</span> be the length of the <code>dictionary</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3)\)</span>. There can be <span class="math inline">\(N + 1\)</span> unique states of the <code>dp</code> method. In each state of <code>dp</code>, we iterate over <code>end</code>, which is <span class="math inline">\(O(N)\)</span> iterations. In each of these iterations, we create a substring, which costs <span class="math inline">\(O(N)\)</span>. Hence, the overall cost of the <code>dp</code> method is <span class="math inline">\(O(N^3)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + M \cdot K)\)</span>. The HashSet used to store the strings in the <code>dictionary</code> will incur a cost of <span class="math inline">\(O(M \cdot K)\)</span>. Additionally, the <code>dp</code> method will consume stack space and traverse to a depth of <span class="math inline">\(N\)</span> in the worst case scenario, resulting in a cost of <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bottom-up-dynamic-programming-with-substring-method">Approach 2: Bottom Up Dynamic Programming with Substring Method</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As shown in the first approach to solve this problem, we can utilize a dynamic programming approach. But this time bottom up. This solution converts the top down approach used above to a bottom up approach. We start by initializing a dynamic programming table <code>dp</code> with values corresponding to the minimum number of extra characters at each position in the string. Notice that here, <code>dp[start]</code> is equal to <code>dp(start)</code> from the previous approach.</p>
<p>With bottom up, we need to start from the base case. The base case we defined above is when <code>start = n</code>. Thus, we iterate through the string backward (starting from <code>n - 1</code>), considering each position as a potential starting point for a substring. For each position, we can apply the same recurrence from the previous approach - explore all possible substrings starting from that point and calculate the minimum number of extra characters associated with each substring. We update the dynamic programming table accordingly.</p>
<p>By the end of the iteration, the value at the first position of the dynamic programming table represents the minimum number of extra characters left over after breaking the string optimally. This value is our desired result, which we return as the output.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>To achieve <code>O(1)</code> lookups, convert the list of strings in the dictionary to a set.</li>
<li>Create a dynamic programming array <code>dp</code> of size <code>n + 1</code>.</li>
<li>Iterate over the string <code>s</code> from right to left, starting from last character (<code>n - 1</code>) down to the first character (<code>0</code>).</li>
<li>Initialize <code>dp[start]</code> by <code>dp[start] + 1</code> to consider the case where the character at index <code>start</code> is an extra character.</li>
<li>For each starting index <code>start</code>, consider all possible substrings starting from <code>start</code> and ending at various indices <code>end</code> from <code>start</code> to <code>n - 1</code>.</li>
<li>If the substring from <code>start</code> to <code>end</code> is found in the <code>dictionary</code> set, update <code>dp[start]</code> by taking the minimum of its current value and <code>dp[end + 1]</code>.</li>
<li>Finally, return the value at <code>dp[0]</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7uuyviFJ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the total characters in the string.<br />
Let <span class="math inline">\(M\)</span> be the average length of the strings in <code>dictionary</code>.<br />
Let <span class="math inline">\(K\)</span> be the length of the <code>dictionary</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3)\)</span>. The two nested loops used to perform the dynamic programming operation cost <span class="math inline">\(O(N^2)\)</span>. The substring method inside the inner loop costs another <span class="math inline">\(O(N)\)</span>. Hence, the overall time complexity is <span class="math inline">\(O(N^3)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + M \cdot K)\)</span>. The HashSet used to store the strings in the <code>dictionary</code> will incur a cost of <span class="math inline">\(O(M \cdot K)\)</span>. The <code>dp</code> array will incur a cost of <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-top-down-dynamic-programming-with-trie">Approach 3: Top Down Dynamic Programming with Trie</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To optimize the top down dynamic programming approach shared earlier we can try to get rid of the <code>substring</code> method. If we can get rid of the <code>substring</code> method we can reduce the time complexity to <span class="math inline">\(O(N^2)\)</span>. We can use the <a href="https://en.wikipedia.org/wiki/Trie">trie</a> data structure to reduce the time complexity of the algorithm. If you are not familiar with tries, we highly recommend you solve <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">this problem</a> first. In this article, we will assume you are already familiar with tries.</p>
<p>First, we create a trie data structure by building a trie from the given dictionary of words. Each <code>TrieNode</code> represents a character, and we connect the nodes to form a hierarchical structure based on the characters in the words. We mark the nodes that correspond to the end of a word.</p>
<p>To find the minimum number of extra characters, we use the same recursive function <code>dp</code> from the first approach, with a few modifications. It takes an index representing the starting position in the string.</p>
<p>Like in the first approach, we initialize the answer for a given <code>start</code> index as <code>dp(start + 1) + 1</code>. Then we try all possible <code>end</code> positions by iteration over the string starting from <code>end = start</code>. As we iterate, we traverse the Trie data structure to check if the characters in the string exist in the trie.</p>
<p>If we encounter a TrieNode marked as the end of a word, we update the minimum count by recursively calling <code>dp</code> on the next index without adding any extra characters. If we find that no TrieNode exists at all for a character, we can immediately break since no words will exist beyond this point.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Start by defining a <code>TrieNode</code> class with <code>children</code> and <code>is_word</code> attributes. Each node represents a character in the trie.</li>
<li>The <code>buildTrie</code> function is used to construct the trie by iterating through each word in the dictionary and adding it to the trie character by character.</li>
<li>Define a recursive helper function called <code>dp</code>.</li>
<li>At each recursive call of <code>dp</code> check if the starting index <code>start</code> has reached the end of the string <code>s</code>. If so, return 0.</li>
<li>The base case of the recursion is when the starting index reaches the end of the string, in which case it returns 0.</li>
<li>Traverse the trie starting from the root and follow the characters of the substring, checking if each character exists in the trie.</li>
<li>If a character is not found in the trie, break out of the loop.</li>
<li>If a valid substring is found in the trie (<code>node.is_word == true</code>), call <code>dp(end + 1)</code>.</li>
<li>Track the minimum number of extra characters encountered so far(<code>ans</code>) and update it whenever a lower value is found.</li>
<li>To optimize the solution, apply memoization. Store the results of previously computed subproblems in a separate data structure.</li>
<li>Finally, call <code>dp</code> with the starting index set to 0.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/exdfhkAT/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the total characters in the string.<br />
Let <span class="math inline">\(M\)</span> be the average length of the strings in <code>dictionary</code>.<br />
Let <span class="math inline">\(K\)</span> be the length of the <code>dictionary</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2 + M \cdot K)\)</span>. There can be <span class="math inline">\(N + 1\)</span> unique states of the <code>dp</code> method. Each state of the <code>dp</code> method costs <span class="math inline">\(O(N)\)</span> to compute. Hence, the overall cost of the <code>dp</code> method is <span class="math inline">\(O((N + 1) \cdot N)\)</span> or simply <span class="math inline">\(O(N^2)\)</span>. Building the trie costs <span class="math inline">\(O(M \cdot K)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + M \cdot K)\)</span>. The Trie used to store the strings in the <code>dictionary</code> will incur a cost of <span class="math inline">\(O(M \cdot K)\)</span>. Additionally, the <code>dp</code> method will consume stack space and traverse to a depth of <span class="math inline">\(N\)</span>, resulting in a cost of <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-bottom-up-dynamic-programming-with-trie">Approach 4: Bottom Up Dynamic Programming with Trie</h3>
<h4 id="intuition-3">Intuition</h4>
<p>We can optimize the bottom up approach the same way we optimized the top down approach, by using a Trie to avoid needing to create substrings.</p>
<p>We initialize a dynamic programming table, <code>dp</code>, where each position represents the minimum number of extra characters starting from that index. This is the same table as the one from approach 2.</p>
<p>For each index <code>start</code>, we initialize <code>dp[start] = dp[start + 1] + 1</code> as the base case. Then we iterate backward through the string, starting from the last index. For each index, we update the corresponding value in the <code>dp</code> table by considering all possible substrings starting from that position. We traverse the Trie data structure, checking if the characters in the string exist in the Trie. If a character doesn't exist in the Trie, we can immediately break.</p>
<p>If we encounter a TrieNode marked as the end of a word during traversal, we update the <code>dp</code> value at the start index by taking the minimum between the current value and the value at the end index without adding any extra characters.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p>The algorithm used in the solution can be explained in the following short points:</p>
<ol>
<li>Define a <code>TrieNode</code> class with <code>children</code> and <code>is_word</code> attributes. Each node represents a character in the trie.</li>
<li>The <code>buildTrie</code> function is used to construct the trie by iterating through each word in the dictionary and adding it to the trie character by character.</li>
<li>Initialize the root of the trie, the length of the input string, and a dynamic programming array <code>dp</code> of size <code>n + 1</code>.</li>
<li>Iterate over the string <code>s</code> from right to left, starting from the last character down to the first character.</li>
<li>For each starting index <code>start</code>, calculate the minimum number of extra characters needed to break down the substring from <code>start</code> to the end of the string.</li>
<li>Initialize <code>dp[start]</code> with <code>dp[start + 1] + 1</code>.</li>
<li>Traverse the trie starting from the root and follow the characters of the substring, checking if each character exists in the trie.</li>
<li>If a character is not found in the trie, break out of the for loop.</li>
<li>If a valid substring is found in the trie (<code>node.is_word == true</code>), update <code>dp[start]</code> by taking the minimum of its current value and <code>dp[end + 1]</code>.</li>
<li>Finally, return the value at <code>dp[0]</code>.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/jZ8RYQGN/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the total characters in the string.<br />
Let <span class="math inline">\(M\)</span> be the average length of the strings in <code>dictionary</code>.<br />
Let <span class="math inline">\(K\)</span> be the length of the <code>dictionary</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2 + M \cdot K)\)</span>. The two nested for loops that are being used for the dynamic programming operation cost <span class="math inline">\(O(N^2)\)</span>. Building the trie costs <span class="math inline">\(O(M \cdot K)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + M \cdot K)\)</span>. The Trie used to store the strings in <code>dictionary</code> will incur a cost of <span class="math inline">\(O(M \cdot K)\)</span>. The <code>dp</code> array will incur a cost of <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-duplicate-rows-in-a-binary-matrix/1" target="_blank" rel="noopener noreferrer">Find duplicate rows in a binary matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>boolean</strong> matrix of size <strong>RxC</strong> where each cell contains either 0 or 1, find the row numbers&nbsp;</span><span style="font-size: 18px;">(0-based)</span><span style="font-size: 18px;">&nbsp;of row which already exists or are repeated.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
R = 2, C = 2
matrix[][] = {{1, 0},
            {1, 0}}
<strong>Output: </strong>
1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong>
Row 1 is duplicate of Row 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
R = 4, C = 3
matrix[][] = {{ 1, 0, 0},
            { 1, 0, 0},
            { 0, 0, 0},
            { 0, 0, 0}}</span>
<span style="font-size: 18px;"><strong>Output: </strong>
</span><span style="font-size: 18px;">1 3</span> 
<span style="font-size: 18px;"><strong>Explanation:</strong>
Row 1 and Row 3 are duplicates of Row 0 and 2 respectively. </span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You dont need to read input or print anything. Complete the function <strong>repeatedRows()</strong> that takes the matrix as input parameter and returns a list of row numbers which are duplicate rows.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(R * C)<br /><strong>Expected Auxiliary Space:</strong> O(R * C) </span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; R, C &le; 10<sup>3</sup></span><br /><span style="font-size: 18px;">0 &le; matrix[i][j] &le; 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-length-of-the-longest-common-prefix/description" target="_blank" rel="noopener noreferrer">Find the Length of the Longest Common Prefix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays with <strong>positive</strong> integers <code>arr1</code> and <code>arr2</code>.</p>

<p>A <strong>prefix</strong> of a positive integer is an integer formed by one or more of its digits, starting from its <strong>leftmost</strong> digit. For example, <code>123</code> is a prefix of the integer <code>12345</code>, while <code>234</code> is <strong>not</strong>.</p>

<p>A <strong>common prefix</strong> of two integers <code>a</code> and <code>b</code> is an integer <code>c</code>, such that <code>c</code> is a prefix of both <code>a</code> and <code>b</code>. For example, <code>5655359</code> and <code>56554</code> have common prefixes <code>565</code> and <code>5655</code> while <code>1223</code> and <code>43456</code> <strong>do not</strong> have a common prefix.</p>

<p>You need to find the length of the <strong>longest common prefix</strong> between all pairs of integers <code>(x, y)</code> such that <code>x</code> belongs to <code>arr1</code> and <code>y</code> belongs to <code>arr2</code>.</p>

<p>Return <em>the length of the <strong>longest</strong> common prefix among all pairs</em>.<em> If no common prefix exists among them</em>, <em>return</em> <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,10,100], arr2 = [1000]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 pairs (arr1[i], arr2[j]):
- The longest common prefix of (1, 1000) is 1.
- The longest common prefix of (10, 1000) is 10.
- The longest common prefix of (100, 1000) is 100.
The longest common prefix is 100 with a length of 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,2,3], arr2 = [4,4,4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0.
Note that common prefixes between elements of the same array do not count.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr1.length, arr2.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= arr1[i], arr2[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-hash-table">Approach 1: Using Hash Table</h3>
<h4 id="intuition">Intuition</h4>
<p>We want to find the longest common prefix between numbers in two arrays. A prefix is formed from the digits of a number, starting from the left. To solve this, the key observation is that the prefix of a number can be reduced by removing its last digit repeatedly. By storing these reduced forms, we can efficiently check for common prefixes.</p>
<blockquote>
<p>Note: In this context, a &quot;prefix&quot; refers to the sequence of digits that starts at the beginning of an integer and can be any length up to the full length of that integer. For example, 12 is a prefix of 123. A common prefix is one that appears at the start of both integers from <code>arr1</code> and <code>arr2</code>.</p>
</blockquote>
<p>The idea is to first create a hash table to hold all possible prefixes of the numbers from the first array (<code>arr1</code>). For each number in <code>arr1</code>, we break it down digit by digit, storing every prefix form (by dividing it by 10). This way, the hash table contains all possible digit patterns that could match any part of a number in <code>arr2</code>.</p>
<p>Next, for each number in <code>arr2</code>, we try to match it against the prefixes stored in the hash table. We keep reducing the number, removing digits from the end, until we find a match. Once we find a match, we compute the length of that prefix by counting its digits. The process repeats for all numbers in <code>arr2</code>, and we track the longest common prefix found across all comparisons.</p>
<p>Rather than comparing each number digit by digit across both arrays, we reduce the problem to prefix matching by storing all prefixes in a hash table and checking against it.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Step 1: Build Prefixes from <code>arr1</code>:</p>
<ul>
<li>Initialize an empty set <code>arr1Prefixes</code> to store all prefixes derived from <code>arr1</code>.</li>
<li>Iterate over each value <code>val</code> in <code>arr1</code>:
<ul>
<li>While <code>val</code> is not in <code>arr1Prefixes</code> and <code>val</code> is greater than 0:
<ul>
<li>Add <code>val</code> to <code>arr1Prefixes</code> (storing <code>val</code> as a prefix).</li>
<li>Update <code>val</code> to the next shorter prefix by removing the last digit (<code>val /= 10</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Step 2: Find the Longest Matching Prefix in <code>arr2</code>:</p>
<ul>
<li>Initialize <code>longestPrefix</code> to 0 to keep track of the length of the longest common prefix found.</li>
<li>Iterate over each value <code>val</code> in <code>arr2</code>:
<ul>
<li>While <code>val</code> is not in <code>arr1Prefixes</code> and <code>val</code> is greater than 0:
<ul>
<li>Reduce <code>val</code> by removing the last digit (<code>val /= 10</code>).</li>
</ul>
</li>
<li>If <code>val</code> is greater than 0 (i.e., a matching prefix is found):
<ul>
<li>Update <code>longestPrefix</code> to the maximum of its current value and the length of the matched prefix (calculated using <code>log10(val) + 1</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the length of the longest common prefix found.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/bhmjPra9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of <code>arr1</code>, <span class="math inline">\(n\)</span> be the length of <code>arr2</code>, <span class="math inline">\(M\)</span> be the maximum value in <code>arr1</code>, and <span class="math inline">\(N\)</span> be the maximum value in <code>arr2</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot \log_{10} M + n \cdot \log_{10} N)\)</span></p>
<p>For each number in <code>arr1</code>, we repeatedly divide the number by 10 to generate its prefixes. Since dividing a number by 10 reduces the number of digits logarithmically, this process takes <span class="math inline">\(O(\log_{10} M)\)</span> for each number in <code>arr1</code>. Hence, for <span class="math inline">\(m\)</span> numbers, the total time complexity is <span class="math inline">\(O(m \cdot \log_{10} M)\)</span>.</p>
<p>Similarly, for each number in <code>arr2</code>, we reduce it by repeatedly dividing it by 10 to check if it matches any prefix in the set. This also takes <span class="math inline">\(O(\log_{10} N)\)</span> for each number in <code>arr2</code>. Hence, for <span class="math inline">\(n\)</span> numbers, the total time complexity is <span class="math inline">\(O(n \cdot \log_{10} N)\)</span>.</p>
<p>Overall, the total time complexity is <span class="math inline">\(O(m \cdot \log_{10} M + n \cdot \log_{10} N)\)</span>.</p>
</li>
<li>
<p>Space Complexit: <span class="math inline">\(O(m \cdot \log_{10} M)\)</span></p>
<p>Each number in <code>arr1</code> contributes <span class="math inline">\(O(\log_{10} M)\)</span> space to the set, as it generates prefixes proportional to the number of digits (logarithmic in the value of the number with base 10). With <span class="math inline">\(m\)</span> numbers in <code>arr1</code>, the total space complexity for the set is <span class="math inline">\(O(m \cdot \log_{10} M)\)</span>.</p>
<p>The algorithm uses constant space for variables like <code>longestPrefix</code> and loop variables, so this doesn’t contribute significantly to the space complexity.</p>
<p>Thus, the total space complexity is <span class="math inline">\(O(m \cdot \log_{10} M)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-trie">Approach 2: Trie</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of using a set, we build a Trie to store all numbers from <code>arr1</code> in a trie form that allows for efficient prefix lookups.</p>
<p>A <a href="https://leetcode.com/explore/learn/card/trie/">Trie</a> can store digit sequences. Each path in the Trie represents a sequence of digits that corresponds to a prefix. As we insert each number from <code>arr1</code>, we break it down into individual digits and store them along a path in the Trie. This allows us to quickly check if a number from <code>arr2</code> shares a prefix with any number from <code>arr1</code>.</p>
<p>For every number in <code>arr2</code>, we traverse the Trie digit by digit. The traversal stops when a digit doesn't match, and we count how many digits we managed to match as the length of the common prefix. Like the first approach, we repeat this process for all numbers in <code>arr2</code> and track the longest common prefix.</p>
<p>Instead of reducing numbers manually like in the first approach, the Trie helps us handle digit sequences directly, which makes the solution both elegant and efficient. It avoids the need to store all possible prefixes explicitly, focusing instead on a structured search through the Trie.</p>
<p><img src="../Figures/3043/3043_trie.png" alt="Trie" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p><code>Trie</code> class:</p>
<ul>
<li>
<p>Initialize the <code>Trie</code> with a root node, which is an instance of <code>TrieNode</code>.</p>
</li>
<li>
<p>Inner <code>TrieNode</code> class:</p>
<ul>
<li>Each <code>TrieNode</code> has an array <code>children</code> of size 10 (for digits 0-9), initialized to null in the constructor to represent an empty node.</li>
</ul>
</li>
<li>
<p>Initialize the <code>Trie</code> with a root node, which is an instance of <code>TrieNode</code>.</p>
</li>
<li>
<p><code>insert</code> function:</p>
<ul>
<li>Convert the integer <code>num</code> to its string representation <code>numStr</code>.</li>
<li>Iterate over each character <code>digit</code> in <code>numStr</code>:
<ul>
<li>Convert <code>digit</code> to its integer index <code>idx</code>.</li>
<li>If <code>node.children[idx]</code> is null, create a new <code>TrieNode</code> and assign it to <code>node.children[idx]</code>.</li>
<li>Move to the child node at <code>node.children[idx]</code>.</li>
</ul>
</li>
<li>Insert all digits of <code>num</code> into the Trie.</li>
</ul>
</li>
<li>
<p><code>findLongestPrefix</code> function:</p>
<ul>
<li>Convert the integer <code>num</code> to its string representation <code>numStr</code>.</li>
<li>Initialize <code>len</code> to 0 to keep track of the length of the common prefix.</li>
<li>Iterate over each character <code>digit</code> in <code>numStr</code>:
<ul>
<li>Convert <code>digit</code> to its integer index <code>idx</code>.</li>
<li>If <code>node.children[idx]</code> exists, increment <code>len</code> and move to the child node at <code>node.children[idx]</code>.</li>
<li>If <code>node.children[idx]</code> is null, break the loop as the prefix match ends.</li>
</ul>
</li>
<li>Return <code>len</code> which represents the length of the longest common prefix.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>longestCommonPrefix</code> function:</p>
<ul>
<li>Create an instance of <code>Trie</code>.</li>
<li>Insert all numbers from <code>arr1</code> into the Trie.</li>
<li>Initialize <code>longestPrefix</code> to 0.</li>
<li>For each number <code>num</code> in <code>arr2</code>:
<ul>
<li>Call <code>trie.findLongestPrefix(num)</code> to find the length of the longest prefix for <code>num</code> in the Trie.</li>
<li>Update <code>longestPrefix</code> with the maximum value between <code>longestPrefix</code> and the result from <code>findLongestPrefix</code>.</li>
</ul>
</li>
<li>Return <code>longestPrefix</code> as the result, which is the length of the longest common prefix between numbers in <code>arr1</code> and <code>arr2</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/m4uCV6pd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of <code>arr1</code>, <span class="math inline">\(n\)</span> be the length of <code>arr2</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot d + n \cdot d) = O(m + n)\)</span></p>
<p>For each number in <code>arr1</code>, we insert it into the Trie by processing each digit. Since each number has up to <span class="math inline">\(d\)</span> digits, inserting a single number takes <span class="math inline">\(O(d)\)</span> time. Therefore, inserting all <span class="math inline">\(m\)</span> numbers from <code>arr1</code> into the Trie takes <span class="math inline">\(O(m \cdot d)\)</span> time.</p>
<p>For each number in <code>arr2</code>, we check how long its prefix matches with any prefix in the Trie. This involves traversing up to <span class="math inline">\(d\)</span> digits of the number, which takes <span class="math inline">\(O(d)\)</span> time per number. For all <span class="math inline">\(n\)</span> numbers in <code>arr2</code>, the time complexity for this step is <span class="math inline">\(O(n \cdot d)\)</span>.</p>
<p>Overall, the total time complexity is <span class="math inline">\(O(m \cdot d + n \cdot d) = O(m + n)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot d) = O(m)\)</span></p>
<p>Each node in the Trie represents a digit (0-9), and each number from <code>arr1</code> can contribute up to <span class="math inline">\(d\)</span> nodes. Thus, the total space used by the Trie for storing all prefixes is <span class="math inline">\(O(m \cdot d)\)</span>.</p>
<p>The algorithm uses constant space for variables like <code>longestPrefix</code> and loop variables, which is negligible compared to the space used by the Trie.</p>
<p>Thus, the total space complexity is <span class="math inline">\(O(m \cdot d) = O(m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-longest-string--170645/1" target="_blank" rel="noopener noreferrer">Find the longest string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="font-size: 18px;">Given an array of strings&nbsp;<strong>words</strong></span><strong style="font-size: 18px;">[]</strong><span style="font-size: 18px;">. Find the </span><strong style="font-size: 18px;">longest</strong><span style="font-size: 18px;"> string in words[] such that </span><strong style="font-size: 18px;">every prefix</strong><span style="font-size: 18px;"> of it is also present in the array words[].&nbsp;</span><br /></span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><strong>Note:&nbsp;</strong></span></span><span style="font-size: 18px;">If multiple strings have the same maximum length, return the <strong>lexicographically smallest one</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> words[] = ["p", "pr", "pro", "probl", "problem", "pros", "process", "processor"]</span>
<span style="font-size: 18px;"><strong>Output:</strong> pros</span>
<strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">"pros" is the longest word with all prefixes ("p", "pr", "pro", "pros") present in the array words[].</span></pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">words[] = ["</span><span style="font-size: 18px;">ab", "a", "abc", "abd"]</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">abc</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong><span style="font-size: 18px;"> Both "abc" and "abd" has all the prefixes in words[]. Since, "abc" is lexicographically smaller than "abd", so the output is "abc".
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; words.length() &le; 10<sup>3</sup><br />1 &le; words[i].length &le; </span><span style="font-size: 18px;">10</span><sup>3</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/geek-and-strings3030/1" target="_blank" rel="noopener noreferrer">Geek and Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geek has a list Li containing (not necessarily distinct) N words and Q queries. Each query consists of a string x. For each query, find how many strings in the List Li has the string x as its prefix.&nbsp;</span></p>

<p><br />
<strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>
N = 5, Q = 5
li[] = {&#39;abracadabra&#39;, &#39;geeksforgeeks&#39;, 
      &#39;abracadabra&#39;, &#39;geeks&#39;, &#39;geeksthrill&#39;}
query[] = {&#39;abr&#39;, &#39;geeks&#39;, &#39;geeksforgeeks&#39;, 
&nbsp;        &#39;ge&#39;, &#39;gar&#39;}</span>

<span style="font-size:18px"><strong>Output:</strong> 2 3 1 3 0</span>

<span style="font-size:18px"><strong>Explaination: </strong>
<strong>Query 1: </strong>The string &#39;abr&#39; is prefix of 
two &#39;abracadabra&#39;. 
<strong>Query 2: </strong>The string &#39;geeks&#39; is prefix of three 
strings &#39;geeksforgeeks&#39;, &#39;geeks&#39; and &#39;geeksthrill&#39;. 
<strong>Query 3: </strong>The string &#39;geeksforgeeks&#39; is prefix 
of itself present in li. 
<strong>Query 4: </strong>The string &#39;ge&#39; also is prefix of three 
strings &#39;geeksforgeeeks&#39;, &#39;geeks&#39;, &#39;geeksthrill&#39;. 
<strong>Query 5: </strong>The string &#39;gar&#39; is not a prefix of any 
string in li.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You do not need to read input or print anything. Your task is to complete the function <strong>prefixCount() </strong>which takes N, Q, li[] and query[] as input parameters and returns a list containing the count of prefixes for each query.&nbsp;</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(Q*x) + O(N*L) Where Q is the number of queries, x is the longest word in the query, N = number of words inserted in Trie and L = length of longest word inserted in Trie.<br />
<strong>Expected Auxiliary Space:</strong> O(N*List [i])</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 3 x 10<sup>4</sup><br />
1 &le; Q &le; 10<sup>4</sup><br />
1 &le; |li[i]|, |x| &le; 100 &nbsp;</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/implement-magic-dictionary/description" target="_blank" rel="noopener noreferrer">Implement Magic Dictionary</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure that is initialized with a list of <strong>different</strong> words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.</p>

<p>Implement the&nbsp;<code>MagicDictionary</code>&nbsp;class:</p>

<ul>
	<li><code>MagicDictionary()</code>&nbsp;Initializes the object.</li>
	<li><code>void buildDict(String[]&nbsp;dictionary)</code>&nbsp;Sets the data structure&nbsp;with an array of distinct strings <code>dictionary</code>.</li>
	<li><code>bool search(String searchWord)</code> Returns <code>true</code> if you can change <strong>exactly one character</strong> in <code>searchWord</code> to match any string in the data structure, otherwise returns <code>false</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]
[[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]
<strong>Output</strong>
[null, null, false, true, false, false]

<strong>Explanation</strong>
MagicDictionary magicDictionary = new MagicDictionary();
magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);
magicDictionary.search(&quot;hello&quot;); // return False
magicDictionary.search(&quot;hhllo&quot;); // We can change the second &#39;h&#39; to &#39;e&#39; to match &quot;hello&quot; so we return True
magicDictionary.search(&quot;hell&quot;); // return False
magicDictionary.search(&quot;leetcoded&quot;); // return False
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;=&nbsp;dictionary.length &lt;= 100</code></li>
	<li><code>1 &lt;=&nbsp;dictionary[i].length &lt;= 100</code></li>
	<li><code>dictionary[i]</code> consists of only lower-case English letters.</li>
	<li>All the strings in&nbsp;<code>dictionary</code>&nbsp;are <strong>distinct</strong>.</li>
	<li><code>1 &lt;=&nbsp;searchWord.length &lt;= 100</code></li>
	<li><code>searchWord</code>&nbsp;consists of only lower-case English letters.</li>
	<li><code>buildDict</code>&nbsp;will be called only once before <code>search</code>.</li>
	<li>At most <code>100</code> calls will be made to <code>search</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/trie-insert-and-search0651/1" target="_blank" rel="noopener noreferrer">Implement Trie</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">design-pattern</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Implement&nbsp;<strong>Trie</strong>&nbsp;class and complete&nbsp;<strong>insert(),</strong>&nbsp;<strong>search()&nbsp;</strong>and<strong>&nbsp;isPrefix()&nbsp;</strong>function for the following queries :</span></p>
<ul>
<li><span style="font-size: 14pt;">Type 1 : (1, word), calls insert(word) function and insert word in the Trie</span></li>
<li><span style="font-size: 14pt;">Type 2 : (2, word), calls search(word) function and check whether word exists in Trie or not.</span></li>
<li><span style="font-size: 14pt;">Type 3 : (3, word), calls isPrefix(word) function and check whether word exists as a prefix of any string in Trie or not.</span></li>
</ul>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>query[][] = [[1, "abcd"], [1, "abc"], [1, "bcd"], [2, "bc"], [3, "bc"], [2, "abc"]]</span><br /><span style="font-size: 14pt;"><strong>Output: </strong>[false, true, true]</span><br /><span style="font-size: 14pt;"><strong>Explanation: </strong>string "bc" <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">does not exist in the trie, "bc" exists as prefix of the word "bcd" in the trie, and "abc" also exists in the trie.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>query[][] = [[1, "gfg"], [1, "geeks"], [3, "fg"], [3, "geek"], [2, "for"]]</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> [false, true, false]</span><br /><span style="font-size: 14pt;"><strong>Explanation:</strong> The string "for" is not present in the trie, "fg" is not a valid prefix, while "geek" is a valid prefix of the word "geeks" in the trie.</span></pre>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;"><span style="font-size: 14pt;"><strong>Constraints:<br /></strong></span><span style="font-size: 14pt;">1 &le; query.size() &le; 10</span><sup>4<br /></sup><span style="font-size: 14pt;">1 &le; word.size() &le; 10</span><sup>3</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/implement-trie-prefix-tree/description" target="_blank" rel="noopener noreferrer">Implement Trie (Prefix Tree)</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <a href="https://en.wikipedia.org/wiki/Trie" target="_blank"><strong>trie</strong></a> (pronounced as &quot;try&quot;) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>

<p>Implement the Trie class:</p>

<ul>
	<li><code>Trie()</code> Initializes the trie object.</li>
	<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>
	<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>
	<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]
[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]
<strong>Output</strong>
[null, null, true, false, true, null, true]

<strong>Explanation</strong>
Trie trie = new Trie();
trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // return True
trie.search(&quot;app&quot;);     // return False
trie.startsWith(&quot;app&quot;); // return True
trie.insert(&quot;app&quot;);
trie.search(&quot;app&quot;);     // return True
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
	<li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li>
	<li>At most <code>3 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-divisible-elements-subarrays/description" target="_blank" rel="noopener noreferrer">K Divisible Elements Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and two integers <code>k</code> and <code>p</code>, return <em>the number of <strong>distinct subarrays,</strong> which have <strong>at most</strong></em> <code>k</code> <em>elements </em>that are <em>divisible by</em> <code>p</code>.</p>

<p>Two arrays <code>nums1</code> and <code>nums2</code> are said to be <strong>distinct</strong> if:</p>

<ul>
	<li>They are of <strong>different</strong> lengths, or</li>
	<li>There exists <strong>at least</strong> one index <code>i</code> where <code>nums1[i] != nums2[i]</code>.</li>
</ul>

<p>A <strong>subarray</strong> is defined as a <strong>non-empty</strong> contiguous sequence of elements in an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [<u><strong>2</strong></u>,3,3,<u><strong>2</strong></u>,<u><strong>2</strong></u>], k = 2, p = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong>
The elements at indices 0, 3, and 4 are divisible by p = 2.
The 11 distinct subarrays which have at most k = 2 elements divisible by 2 are:
[2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], [3,2,2], and [2,2].
Note that the subarrays [2] and [3] occur more than once in nums, but they should each be counted only once.
The subarray [2,3,3,2,2] should not be counted because it has 3 elements that are divisible by 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], k = 4, p = 1
<strong>Output:</strong> 10
<strong>Explanation:</strong>
All element of nums are divisible by p = 1.
Also, every subarray of nums will have at most 4 elements that are divisible by 1.
Since all subarrays are distinct, the total number of subarrays satisfying all the constraints is 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 200</code></li>
	<li><code>1 &lt;= nums[i], p &lt;= 200</code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<p>Can you solve this problem in O(n<sup>2</sup>) time complexity?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-th-smallest-in-lexicographical-order/description" target="_blank" rel="noopener noreferrer">K-th Smallest in Lexicographical Order</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integers <code>n</code> and <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>lexicographically smallest integer in the range</em> <code>[1, n]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 13, k = 2
<strong>Output:</strong> 10
<strong>Explanation:</strong> The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1, k = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find the <code>K</code>-th smallest number in lexicographical order within the range <code>[1, n]</code>. At first, this might seem like a simple sorting problem. We could list all the numbers, sort them in lexicographical order, and pick the <code>K</code>-th number. However, for large values of <code>n</code>, this becomes impractical due to the sheer size of the list we'd need to create.</p>
<p>Instead of generating and sorting all the numbers, we can treat numbers as trees, where each node represents a number and its children represent numbers with the same prefix. Structuring numbers this way allows us to find the <code>K</code>-th smallest more efficiently.</p>
<p>For example, the number <code>1</code> has children <code>10</code>, <code>11</code>, <code>12</code>, ..., up to <code>19</code>. Similarly, <code>2</code> has children <code>20</code>, <code>21</code>,  ..., up to <code>29</code> and so on for other numbers. This gives us a prefix tree like structure where each node corresponds to a number and branches out to other numbers by appending digits. If we traverse this tree in lexicographical order, it’s as if we’re listing all numbers in their proper order.</p>
<p><img src="../Figures/440/lexico_number_tree.png" alt="digit tree" /></p>
<hr />
<h3 id="approach-prefix-tree">Approach: Prefix Tree</h3>
<h4 id="intuition">Intuition</h4>
<p>We begin by selecting the smallest lexicographical number, which is <code>1</code>. Since we've already counted <code>1</code> as the first number, we subtract <code>1</code> from <code>k</code> to account for that.</p>
<p>Next, we calculate how many numbers exist in the subtree rooted at <code>curr</code> by defining a helper function <code>countSteps</code>, which counts the numbers between two prefixes [<code>curr</code> and <code>curr + 1</code>). It calculates numbers at each level, expanding the prefix as we go deeper.</p>
<p>We know the <code>k</code>-th number is not in this subtree if the number of steps (or numbers) under <code>curr</code> is smaller than or equal to <code>k</code>. Under these circumstances, we skip to the next sibling (<code>curr++</code>) and subtract the number of steps from <code>k</code> because we've skipped those numbers.</p>
<p>On the other hand, if the number of steps is larger than <code>k</code>, we know the <code>k</code>-th number is in the subtree rooted at <code>curr</code>. In that case, we move down one level by multiplying <code>curr</code> by 10, effectively moving to the next digit in the lexicographical tree. We also decrease <code>k</code> by 1 because we've taken one step deeper into the tree.</p>
<p>We repeat this process until <code>k</code> becomes zero, at which point we've found the <code>k</code>-th number, and we return <code>curr</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>curr</code> to 1 (current prefix) and decrement <code>k</code> by 1.</p>
</li>
<li>
<p>While <code>k</code> is greater than 0:</p>
<ul>
<li>Calculate the number of steps in the subtree rooted at <code>curr</code> using <code>countSteps(n, curr, curr + 1)</code>.</li>
<li>If the number of steps is less than or equal to <code>k</code>:
<ul>
<li>Increment <code>curr</code> by 1 to move to the next prefix.</li>
<li>Decrement <code>k</code> by the number of skipped steps (i.e., <code>k -= step</code>).</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Multiply <code>curr</code> by 10 to move to the next level in the tree (i.e., <code>curr *= 10</code>).</li>
<li>Decrement <code>k</code> by 1 to account for the current level.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the value of <code>curr</code> as the <code>k</code>-th smallest number in lexicographical order.</p>
</li>
<li>
<p><code>countSteps</code> function:</p>
<ul>
<li>Initialize <code>steps</code> to 0 to keep track of the count of numbers in the range.</li>
<li>While <code>prefix1</code> is less than or equal to <code>n</code>:
<ul>
<li>Add the number of integers between <code>prefix1</code> and <code>prefix2</code> to <code>steps</code> using <code>steps += Math.min(n + 1, prefix2) - prefix1</code>. This ensures the count does not exceed <code>n</code> by capping <code>prefix2</code> at <code>n + 1</code> if <code>prefix2</code> is larger than <code>n</code>.</li>
<li>Multiply <code>prefix1</code> and <code>prefix2</code> by 10 to move to the next level in the tree.</li>
</ul>
</li>
<li>Return the total number of steps counted.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/KYViuAd9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the input number.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log(n)^2)\)</span></p>
<p>The outer <code>while</code> loop runs as long as <code>k &gt; 0</code>. In the worst case, it runs <span class="math inline">\(O(\log n)\)</span> times, because at each step, we either move to the next prefix or move deeper into the tree (multiplying the current prefix by 10).</p>
<p>The <code>countSteps</code> function, which calculates the number of steps between two prefixes, runs in <span class="math inline">\(O(\log n)\)</span> time, as it traverses deeper levels of the number range by multiplying the prefixes by 10 in each iteration.</p>
<p>Since the <code>countSteps</code> function is called inside the <code>while</code> loop, which also runs <span class="math inline">\(O(\log n)\)</span> times, the overall time complexity is <span class="math inline">\(O(\log(n) \times \log(n)) = O(\log(n)^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(1)\)</span> because we're only using a constant amount of additional space for variables like <code>curr</code>, <code>k</code>, <code>step</code>, <code>prefix1</code>, <code>prefix2</code>, etc. We're not using any data structures that grow with the input size.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/lcp--170637/1" target="_blank" rel="noopener noreferrer">LCP</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px"><strong>Note: This&nbsp;<a href="http://practice.geeksforgeeks.org/problem-of-the-day">POTD</a>&nbsp;is a part of&nbsp;<a href="https://practice.geeksforgeeks.org/summer-carnival-2022?utm_source=potd&amp;utm_medium=problempage&amp;utm_campaign=gsc22">Geek Summer Carnival</a>. Solve all POTD consecutively from 5th to 10th April and get a chance to win exclusive discount vouchers on our GfG courses.</strong></span></p>

<hr />
<p><span style="font-size:18px">Geek is at the geek summer carnival. He is given an array of N strings. To unlock exclusive course discounts he needs to find the longest common prefix among all strings present in the array. Can you help him ?</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px">Input:
N = 4
ar[] = {geeksforgeeks, geeks, geek, geezer}</span>

<span style="font-size:18px">Output:
gee</span>

<span style="font-size:18px">Explanation: 
Longest common prefix in all the given string is gee. </span></pre>

<p>&nbsp;</p>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px">Input:
N = 3
ar[] = {apple, ape, april}</span>

<span style="font-size:18px">Output:
ap</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Complete the function LCP() that takes integer n and ar[] as input parameters and return the LCP (in case there is no common prefix return -1).&nbsp;</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected time complexity: </strong>O(NlogN)<br />
<strong>Expected space complexity:</strong> O(string length)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N &lt;= 10^3<br />
1 &lt;= String Length &lt;= 100</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lexicographical-numbers/description" target="_blank" rel="noopener noreferrer">Lexicographical Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return all the numbers in the range <code>[1, n]</code> sorted in lexicographical order.</p>

<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and uses <code>O(1)</code> extra space.&nbsp;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> n = 13
<strong>Output:</strong> [1,10,11,12,13,2,3,4,5,6,7,8,9]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> n = 2
<strong>Output:</strong> [1,2]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to create a list of integers from 1 to <span class="math inline">\(n\)</span> and sort them in lexicographical order. Lexicographical order is similar to dictionary order, where the sequence is based on how words are arranged alphabetically. For numbers, this means sorting them as if they were strings. For example, <code>'10'</code> comes before <code>'2'</code> because <code>'1'</code> is less than <code>'2'</code>.</p>
<p>The solution must be efficient, with a time complexity of <span class="math inline">\(O(n)\)</span>. This means the algorithm should handle the input size directly without any nested loops that could slow it down. Additionally, the solution should use constant extra space, <span class="math inline">\(O(1)\)</span>, which means it should not require extra memory beyond the output list itself.</p>
<hr />
<h3 id="approach-1-dfs-approach">Approach 1: DFS Approach</h3>
<h4 id="intuition">Intuition</h4>
<p>We can think of generating numbers in lexicographical order by imagining how they would appear in a dictionary. The first number is <code>1</code>, followed by <code>10</code>, <code>11</code>, <code>12</code>, and so on, before moving to <code>2</code>, then <code>20</code>, <code>21</code>, and so forth. The key is that smaller numbers starting with a particular digit should be fully explored before moving to the next starting digit.</p>
<p>Now, to translate this thinking into an algorithm, consider each number as part of a tree. For instance, <code>1</code> has children like <code>10</code>, <code>11</code>, <code>12</code>, and so on, while <code>2</code> has children <code>20</code>, <code>21</code>, and so forth. This naturally suggests a depth-first search (DFS) approach: we explore each number and its children before moving to the next digit.</p>
<p>We start with the numbers <code>1</code> through <code>9</code> as the roots of the tree. For each of these, we generate their children by appending digits from <code>0</code> to <code>9</code>, as long as the resulting number remains within the range <code>[1, n]</code>. Once we exhaust one branch (e.g., numbers starting with <code>1</code> that exceed <code>n</code>), we move to the next root (i.e., <code>2</code>) and repeat the process. In this way, we progressively build the lexicographical order.</p>
<p><img src="../Figures/386/lexico_tree.png" alt="lexico_tree" /></p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty array <code>lexicographicalNumbers</code> to store the result.</p>
</li>
<li>
<p>Iterate over each starting number from 1 to 9:</p>
<ul>
<li>For each <code>start</code>, call <code>generateLexicalNumbers</code> with the current <code>start</code>, limit <code>n</code>, and <code>lexicographicalNumbers</code> array.</li>
</ul>
</li>
<li>
<p><code>generateLexicalNumbers</code> function:</p>
<ul>
<li>
<p>If <code>currentNumber</code> exceeds the <code>limit</code>, return from the function to stop recursion.</p>
</li>
<li>
<p>Add the <code>currentNumber</code> to the <code>result</code> array.</p>
</li>
<li>
<p>Iterate over digits from 0 to 9 to try appending them to <code>currentNumber</code>:</p>
<ul>
<li>Calculate <code>nextNumber</code> by appending the digit to <code>currentNumber</code>.</li>
<li>If <code>nextNumber</code> is within the <code>limit</code>, recursively call <code>generateLexicalNumbers</code> with <code>nextNumber</code>, <code>limit</code>, and <code>result</code>.</li>
<li>If <code>nextNumber</code> exceeds the <code>limit</code>, break the loop to avoid unnecessary further recursion.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>lexicographicalNumbers</code> array containing numbers in lexicographical order.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/B6EiUFeW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm generates all numbers from 1 to n in lexicographical order. Each number is visited exactly once and added to the result list. The total number of operations is proportional to the number of elements generated, which is n.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log_{10}(n))\)</span></p>
<p>We only consider the recursion stack depth. The depth of recursion is proportional to the number of digits <span class="math inline">\(d\)</span> in <span class="math inline">\(n\)</span>. Given that the maximum value for <span class="math inline">\(n\)</span> is 50,000, the maximum number of digits <span class="math inline">\(d\)</span> is 5. Thus, the recursion stack depth and corresponding space complexity is <span class="math inline">\(O(d)\)</span>, which simplifies to <span class="math inline">\(O(\log_{10}(n))\)</span>, but with a maximum constant value of 5 for practical constraints. It can also be argued as <span class="math inline">\(O(1)\)</span>. This is because, when substituting <span class="math inline">\(n\)</span> as 50,000, the result is approximately 5 (specifically <span class="math inline">\(4.698970004336\)</span>), which is extremely small and does not significantly affect the overall complexity in this range.</p>
</li>
</ul>
<blockquote>
<p>The space complexity analysis does not account for the result list itself, as the problem requires returning a list with <span class="math inline">\(n\)</span> elements. Since we are only storing the elements in the list without performing additional operations on it, the space used by the list is not considered in the complexity analysis.</p>
</blockquote>
<hr />
<h3 id="approach-2-iterative-approach">Approach 2: Iterative Approach</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can do the same thing iterative, the overall concept remains the same as DFS approach. The difference will be how we organize and implement it.</p>
<p>We initialize the current number as <code>1</code>, which is the first number in lexicographical order, and set up a loop that runs <code>n</code> times because we want to generate exactly <code>n</code> numbers.</p>
<p>In each iteration, we add the current number to the result list. After that, we check if we can go deeper by multiplying the current number by <code>10</code>, appending a zero to the current number, giving us the lexicographically smallest possible next number. If the result is still less than or equal to <code>n</code>, we update the current number to this new value and continue.</p>
<p>If multiplying by <code>10</code> would exceed <code>n</code>, we increment the current number. However, this increment can’t always happen directly. If the current number ends in <code>9</code> or goes beyond the next &quot;root&quot; (like moving from <code>19</code> to <code>2</code>), we divide by <code>10</code> to move up a level and strip off the last digit. This way we make sure we don’t skip any numbers.</p>
<p>After incrementing, if the new current number ends in a zero (like <code>20</code>), we continue removing zeroes, dividing by <code>10</code>, until we get a valid number. This ensures we stay in lexicographical order as we move forward.</p>
<p>This way, we mimic the way we would manually write numbers in lexicographical order. We move from one number to the next by considering when to go deeper (appending digits) and when to backtrack (moving to the next root). Unlike the recursive method, which explores each branch of the tree by diving deeper, this method keeps track of the current number and directly adjusts it. This makes it more space-efficient, with essentially no extra space overhead, and runs in <span class="math inline">\(O(n)\)</span> time.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty array <code>lexicographicalNumbers</code> to store the results.</p>
</li>
<li>
<p>Start with <code>currentNumber</code> set to 1.</p>
</li>
<li>
<p>Generate numbers from 1 to <code>n</code>:</p>
<ul>
<li>
<p>Add <code>currentNumber</code> to the <code>lexicographicalNumbers</code> array.</p>
</li>
<li>
<p>If multiplying <code>currentNumber</code> by 10 is less than or equal to <code>n</code> (i.e., <code>currentNumber * 10 &lt;= n</code>), multiply <code>currentNumber</code> by 10 to move to the next lexicographical number (i.e., go deeper into the tree of numbers).</p>
</li>
<li>
<p>Otherwise:</p>
<ul>
<li>Adjust <code>currentNumber</code> to move to the next valid lexicographical number:
<ul>
<li>While <code>currentNumber</code> ends with a 9 or is greater than or equal to <code>n</code>:
<ul>
<li>Divide <code>currentNumber</code> by 10 to remove the last digit.</li>
</ul>
</li>
<li>Increment <code>currentNumber</code> by 1 to move to the next number in the sequence.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>lexicographicalNumbers</code> array containing the numbers in lexicographical order from 1 to <code>n</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YCsNLk2u/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm generates numbers in lexicographical order and iterates up to <span class="math inline">\(n\)</span> times to populate the <code>lexicographicalNumbers</code> array. Each iteration involves constant-time operations (checking conditions and updating <code>currentNumber</code>). Thus, the time complexity is linear in terms of <span class="math inline">\(n\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of additional space for variables like <code>currentNumber</code> and loop counters. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<blockquote>
<p>The space complexity analysis does not account for the result list itself, as the problem requires returning a list with <span class="math inline">\(n\)</span> elements. Since we are only storing the elements in the list without performing additional operations on it, the space used by the list is not considered in the complexity analysis.</p>
</blockquote>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-common-prefix/description" target="_blank" rel="noopener noreferrer">Longest Common Prefix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write a function to find the longest common prefix string amongst an array of strings.</p>

<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
<strong>Output:</strong> &quot;fl&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> There is no common prefix among the input strings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strs.length &lt;= 200</code></li>
	<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
	<li><code>strs[i]</code> consists of only lowercase English letters if it is non-empty.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-horizontal-scanning">Approach 1: Horizontal scanning</h3>
<h4 id="intuition">Intuition</h4>
<p>For a start we will describe a simple way of finding the longest prefix shared by a set of strings <span class="math inline">\(LCP(S_1  \ldots  S_n)\)</span>.<br />
We will use the observation that :</p>
<p><span class="math display">\[
#### Algorithm

 To employ this idea, the algorithm iterates through the strings $$[S_1  \ldots  S_n]$$, finding at each iteration $$i$$ the longest common prefix of strings $$LCP(S_1  \ldots  S_i)$$ When $$LCP(S_1  \ldots  S_i)$$ is an empty string, the algorithm ends. Otherwise after $$n$$ iterations, the algorithm returns $$LCP(S_1  \ldots  S_n)$$.

 ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_basic.png){:width="539px"}
 

 *Figure 1. Finding the longest common prefix (Horizontal scanning)*
 
#### Implementation

[code](https://leetcode.com/playground/Eyfryo9Z/shared)

#### Complexity Analysis

* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.

    In the worst case all $$n$$ strings are the same. The algorithm compares the string $$S1$$ with the other strings $$[S_2 \ldots S_n]$$ There are $$S$$ character comparisons, where $$S$$ is the sum of all characters in the input array.

* Space complexity : $$O(1)$$. We only used constant extra space.

---

### Approach 2: Vertical scanning

#### Algorithm

Imagine a very short string is the common prefix at the end of the array. The above approach will still do $$S$$ comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.

#### Implementation

[code](https://leetcode.com/playground/WSSYVp4m/shared)

#### Complexity Analysis

* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.
In the worst case there will be $$n$$ equal strings with length $$m$$ and the algorithm performs  $$S = m \cdot n$$ character comparisons.
Even though the worst case is still the same as [Approach 1](#approach-1-horizontal-scanning), in the best case there are at most $$n \cdot minLen$$ comparisons where $$minLen$$ is the length of the shortest string in the array.
* Space complexity : $$O(1)$$. We only used constant extra space.

---

### Approach 3: Divide and conquer

#### Intuition

The idea of the algorithm comes from the associative property of LCP operation. We notice that :
$$LCP(S_1 \ldots S_n) = LCP(LCP(S_1 \ldots S_k), LCP (S_{k+1} \ldots S_n))$$
, where $$LCP(S_1 \ldots S_n)$$ is the longest common prefix in set of strings $$[S_1 \ldots S_n]$$ , $$1 < k < n$$

#### Algorithm

To apply the observation above, we use divide and conquer technique, where we split the $$LCP(S_i \ldots S_j)$$ problem into two subproblems $$LCP(S_i \ldots S_{mid})$$   and $$LCP(S_{mid+1} \ldots S_j)$$, where `mid` is $$\frac{i + j}{2}$$. We use their solutions `lcpLeft` and `lcpRight` to construct the solution of the main problem $$LCP(S_i \ldots S_j)$$. To accomplish this we compare one by one the characters of `lcpLeft` and `lcpRight` till there is no character match. The found common prefix of `lcpLeft` and `lcpRight` is the solution of the  $$LCP(S_i \ldots S_j)$$.

![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png){:width="539px"}


*Figure 2. Finding the longest common prefix of strings using divide and conquer technique*

#### Implementation

[code](https://leetcode.com/playground/DR56kG9E/shared)

#### Complexity Analysis

In the worst case we have $$n$$ equal strings with length $$m$$

* Time complexity : $$O(S)$$, where $$S$$ is the number of all characters in the array, $$S = m \cdot n$$
 Time complexity is $$2 \cdot T\left ( \frac{n}{2} \right ) + O(m)$$. Therefore time complexity is $$O(S)$$.
  In the best case this algorithm performs  $$O(minLen \cdot n)$$ comparisons, where  $$minLen$$ is the shortest string of the array

* Space complexity : $$O(m \cdot \log n)$$

    There is a memory overhead since we store recursive calls in the execution stack. There are $$\log n$$ recursive calls, each store need $$m$$ space to store the result,  so space complexity is $$O(m \cdot \log n)$$


---

### Approach 4: Binary search

#### Intuition

The idea is to apply binary search method to find the string with maximum value `L`, which is common prefix of all of the strings. The algorithm searches space is the interval $$(0 \ldots minLen)$$, where `minLen` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:
* `S[1...mid]` is not a common string. This means that for each `j > i S[1..j]` is not a common string and we discard the second half of the  search space.
* `S[1...mid]` is common string. This means that for each `i < j S[1..i]` is a common string and we discard the first half of the search space, because we try to find longer common prefix.

![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_binary_search.png){:width="539px"}


*Figure 3. Finding the longest common prefix of strings using binary search technique*

#### Implementation

[code](https://leetcode.com/playground/M2tJuDXZ/shared)

#### Complexity Analysis

In the worst case we have $$n$$ equal strings with length $$m$$

* Time complexity : $$O(S \cdot \log m)$$, where $$S$$ is the sum of all characters in all strings.

    The algorithm makes $$\log m$$ iterations, for each of them there are $$S = m \cdot n$$ comparisons, which gives in total $$O(S \cdot \log m)$$ time complexity.

* Space complexity : $$O(1)$$. We only used constant extra space.

---

### Further Thoughts / Follow up

Let's take a look at a slightly different problem:

> Given a set of keys S = $$[S_1,S_2 \ldots S_n]$$, find the longest common prefix among a string `q` and S. This LCP query will be called frequently.

We could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article [Implement a trie (Prefix trie)](https://leetcode.com/articles/implement-trie-prefix-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string `q` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:
* it is prefix of query string `q`
* each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.
* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.

#### Algorithm

The only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from $$[S_1 \ldots   S_n]$$ strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.

![Finding the longest common prefix using Trie](../Figures/14/14_lcp_trie_fix.png)

*Figure 4. Finding the longest common prefix of strings using Trie*

#### Implementation

[code](https://leetcode.com/playground/bcDyZ5WU/shared)

#### Complexity Analysis

In the worst case query $$q$$ has length $$m$$ and it is equal to all $$n$$ strings of the array.

* Time complexity : preprocessing $$O(S)$$, where $$S$$ is the number of all characters in the array, LCP query $$O(m)$$.

    Trie build has $$O(S)$$ time complexity. To find the common prefix of $$q$$ in the Trie takes in the worst case $$O(m)$$.

* Space complexity : $$O(S)$$. We only used additional  $$S$$ extra space for the Trie.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-common-prefix-of-k-strings-after-removal/description" target="_blank" rel="noopener noreferrer">Longest Common Prefix of K Strings After Removal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and an integer <code>k</code>.</p>

<p>For each index <code>i</code> in the range <code>[0, words.length - 1]</code>, find the <strong>length</strong> of the <strong>longest common <span data-keyword="string-prefix">prefix</span></strong> among any <code>k</code> strings (selected at <strong>distinct indices</strong>) from the remaining array after removing the <code>i<sup>th</sup></code> element.</p>

<p>Return an array <code>answer</code>, where <code>answer[i]</code> is the answer for <code>i<sup>th</sup></code> element. If removing the <code>i<sup>th</sup></code> element leaves the array with fewer than <code>k</code> strings, <code>answer[i]</code> is 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;jump&quot;,&quot;run&quot;,&quot;run&quot;,&quot;jump&quot;,&quot;run&quot;], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,4,4,3,4]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Removing index 0 (<code>&quot;jump&quot;</code>):

	<ul>
		<li><code>words</code> becomes: <code>[&quot;run&quot;, &quot;run&quot;, &quot;jump&quot;, &quot;run&quot;]</code>. <code>&quot;run&quot;</code> occurs 3 times. Choosing any two gives the longest common prefix <code>&quot;run&quot;</code> (length 3).</li>
	</ul>
	</li>
	<li>Removing index 1 (<code>&quot;run&quot;</code>):
	<ul>
		<li><code>words</code> becomes: <code>[&quot;jump&quot;, &quot;run&quot;, &quot;jump&quot;, &quot;run&quot;]</code>. <code>&quot;jump&quot;</code> occurs twice. Choosing these two gives the longest common prefix <code>&quot;jump&quot;</code> (length 4).</li>
	</ul>
	</li>
	<li>Removing index 2 (<code>&quot;run&quot;</code>):
	<ul>
		<li><code>words</code> becomes: <code>[&quot;jump&quot;, &quot;run&quot;, &quot;jump&quot;, &quot;run&quot;]</code>. <code>&quot;jump&quot;</code> occurs twice. Choosing these two gives the longest common prefix <code>&quot;jump&quot;</code> (length 4).</li>
	</ul>
	</li>
	<li>Removing index 3 (<code>&quot;jump&quot;</code>):
	<ul>
		<li><code>words</code> becomes: <code>[&quot;jump&quot;, &quot;run&quot;, &quot;run&quot;, &quot;run&quot;]</code>. <code>&quot;run&quot;</code> occurs 3 times. Choosing any two gives the longest common prefix <code>&quot;run&quot;</code> (length 3).</li>
	</ul>
	</li>
	<li>Removing index 4 (&quot;run&quot;):
	<ul>
		<li><code>words</code> becomes: <code>[&quot;jump&quot;, &quot;run&quot;, &quot;run&quot;, &quot;jump&quot;]</code>. <code>&quot;jump&quot;</code> occurs twice. Choosing these two gives the longest common prefix <code>&quot;jump&quot;</code> (length 4).</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;dog&quot;,&quot;racer&quot;,&quot;car&quot;], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,0,0]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Removing any index results in an answer of 0.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10<sup>4</sup></code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li>The sum of <code>words[i].length</code> is smaller than or equal <code>10<sup>5</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-common-suffix-queries/description" target="_blank" rel="noopener noreferrer">Longest Common Suffix Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays of strings <code>wordsContainer</code> and <code>wordsQuery</code>.</p>

<p>For each <code>wordsQuery[i]</code>, you need to find a string from <code>wordsContainer</code> that has the <strong>longest common suffix</strong> with <code>wordsQuery[i]</code>. If there are two or more strings in <code>wordsContainer</code> that share the longest common suffix, find the string that is the <strong>smallest</strong> in length. If there are two or more such strings that have the <strong>same</strong> smallest length, find the one that occurred <strong>earlier</strong> in <code>wordsContainer</code>.</p>

<p>Return <em>an array of integers </em><code>ans</code><em>, where </em><code>ans[i]</code><em> is the index of the string in </em><code>wordsContainer</code><em> that has the <strong>longest common suffix</strong> with </em><code>wordsQuery[i]</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">wordsContainer = [&quot;abcd&quot;,&quot;bcd&quot;,&quot;xbcd&quot;], wordsQuery = [&quot;cd&quot;,&quot;bcd&quot;,&quot;xyz&quot;]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p>Let&#39;s look at each <code>wordsQuery[i]</code> separately:</p>

<ul>
	<li>For <code>wordsQuery[0] = &quot;cd&quot;</code>, strings from <code>wordsContainer</code> that share the longest common suffix <code>&quot;cd&quot;</code> are at indices 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.</li>
	<li>For <code>wordsQuery[1] = &quot;bcd&quot;</code>, strings from <code>wordsContainer</code> that share the longest common suffix <code>&quot;bcd&quot;</code> are at indices 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.</li>
	<li>For <code>wordsQuery[2] = &quot;xyz&quot;</code>, there is no string from <code>wordsContainer</code> that shares a common suffix. Hence the longest common suffix is <code>&quot;&quot;</code>, that is shared with strings at index 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">wordsContainer = [&quot;abcdefgh&quot;,&quot;poiuygh&quot;,&quot;ghghgh&quot;], wordsQuery = [&quot;gh&quot;,&quot;acbfgh&quot;,&quot;acbfegh&quot;]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,0,2]</span></p>

<p><strong>Explanation:</strong></p>

<p>Let&#39;s look at each <code>wordsQuery[i]</code> separately:</p>

<ul>
	<li>For <code>wordsQuery[0] = &quot;gh&quot;</code>, strings from <code>wordsContainer</code> that share the longest common suffix <code>&quot;gh&quot;</code> are at indices 0, 1, and 2. Among these, the answer is the string at index 2 because it has the shortest length of 6.</li>
	<li>For <code>wordsQuery[1] = &quot;acbfgh&quot;</code>, only the string at index 0 shares the longest common suffix <code>&quot;fgh&quot;</code>. Hence it is the answer, even though the string at index 2 is shorter.</li>
	<li>For <code>wordsQuery[2] = &quot;acbfegh&quot;</code>, strings from <code>wordsContainer</code> that share the longest common suffix <code>&quot;gh&quot;</code> are at indices 0, 1, and 2. Among these, the answer is the string at index 2 because it has the shortest length of 6.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= wordsContainer.length, wordsQuery.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= wordsContainer[i].length &lt;= 5 * 10<sup>3</sup></code></li>
	<li><code>1 &lt;= wordsQuery[i].length &lt;= 5 * 10<sup>3</sup></code></li>
	<li><code>wordsContainer[i]</code> consists only of lowercase English letters.</li>
	<li><code>wordsQuery[i]</code> consists only of lowercase English letters.</li>
	<li>Sum of <code>wordsContainer[i].length</code> is at most <code>5 * 10<sup>5</sup></code>.</li>
	<li>Sum of <code>wordsQuery[i].length</code> is at most <code>5 * 10<sup>5</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-word-in-dictionary/description" target="_blank" rel="noopener noreferrer">Longest Word in Dictionary</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>words</code> representing an English Dictionary, return <em>the longest word in</em> <code>words</code> <em>that can be built one character at a time by other words in</em> <code>words</code>.</p>

<p>If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.</p>

<p>Note that the word should be built from left to right with each additional character being added to the end of a previous word.&nbsp;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;,&quot;world&quot;]
<strong>Output:</strong> &quot;world&quot;
<strong>Explanation:</strong> The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;banana&quot;,&quot;app&quot;,&quot;appl&quot;,&quot;ap&quot;,&quot;apply&quot;,&quot;apple&quot;]
<strong>Output:</strong> &quot;apple&quot;
<strong>Explanation:</strong> Both &quot;apply&quot; and &quot;apple&quot; can be built from other words in the dictionary. However, &quot;apple&quot; is lexicographically smaller than &quot;apply&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>For each word, check if all prefixes <code>word[:k]</code> are present. We can use a <code>Set</code> structure to check this quickly.</p>
<p><strong>Algorithm</strong></p>
<p>Whenever our found word would be superior, we check if all its prefixes are present, then replace our answer.</p>
<p>Alternatively, we could have sorted the words beforehand, so that we knew the word we were considering would be the answer if all its prefixes were present.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">longestWord</span>(<span style="color:#999">self</span>, words):
</span></span><span style="display:flex;"><span>    ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    wordset <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">set</span>(words)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> word <span style="color:#000;font-weight:bold">in</span> words:
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#0086b3">len</span>(word) <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#0086b3">len</span>(ans) <span style="color:#000;font-weight:bold">or</span> <span style="color:#0086b3">len</span>(word) <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">len</span>(ans) <span style="color:#000;font-weight:bold">and</span> word <span style="color:#000;font-weight:bold">&lt;</span> ans:
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#0086b3">all</span>(word[:k] <span style="color:#000;font-weight:bold">in</span> wordset <span style="color:#000;font-weight:bold">for</span> k <span style="color:#000;font-weight:bold">in</span> xrange(<span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(word))):
</span></span><span style="display:flex;"><span>                ans <span style="color:#000;font-weight:bold">=</span> word
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> ans
</span></span></code></pre><p><em>Alternate Implementation</em></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">longestWord</span>(<span style="color:#999">self</span>, words):
</span></span><span style="display:flex;"><span>        wordset <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">set</span>(words)
</span></span><span style="display:flex;"><span>        words<span style="color:#000;font-weight:bold">.</span>sort(key <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span> c: (<span style="color:#000;font-weight:bold">-</span><span style="color:#0086b3">len</span>(c), c))
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> word <span style="color:#000;font-weight:bold">in</span> words:
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#0086b3">all</span>(word[:k] <span style="color:#000;font-weight:bold">in</span> wordset <span style="color:#000;font-weight:bold">for</span> k <span style="color:#000;font-weight:bold">in</span> xrange(<span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(word))):
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> word
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#d14">&#34;&#34;</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> String <span style="color:#900;font-weight:bold">longestWord</span><span style="color:#000;font-weight:bold">(</span>String<span style="color:#000;font-weight:bold">[]</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        String ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;&#34;</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        Set<span style="color:#000;font-weight:bold">&lt;</span>String<span style="color:#000;font-weight:bold">&gt;</span> wordset <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashSet<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span>String word<span style="color:#000;font-weight:bold">:</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            wordset<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>word<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span>String word<span style="color:#000;font-weight:bold">:</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">&gt;</span> ans<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">||</span>
</span></span><span style="display:flex;"><span>                    word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">==</span> ans<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">compareTo</span><span style="color:#000;font-weight:bold">(</span>ans<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&lt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">boolean</span> good <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> k <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> k <span style="color:#000;font-weight:bold">&lt;</span> word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#000;font-weight:bold">++</span>k<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(!</span>wordset<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">contains</span><span style="color:#000;font-weight:bold">(</span>word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">substring</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">,</span> k<span style="color:#000;font-weight:bold">)))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                        good <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">false</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#000;font-weight:bold">break</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>good<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    ans <span style="color:#000;font-weight:bold">=</span> word<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>    
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><em>Alternate Implementation</em></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> String <span style="color:#900;font-weight:bold">longestWord</span><span style="color:#000;font-weight:bold">(</span>String<span style="color:#000;font-weight:bold">[]</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        Set<span style="color:#000;font-weight:bold">&lt;</span>String<span style="color:#000;font-weight:bold">&gt;</span> wordset <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashSet<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span>String word<span style="color:#000;font-weight:bold">:</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            wordset<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>word<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">sort</span><span style="color:#000;font-weight:bold">(</span>words<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">,</span> b<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">-&gt;</span> a<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">==</span> b<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">?</span> a<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">compareTo</span><span style="color:#000;font-weight:bold">(</span>b<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">:</span> b<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">-</span> a<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span>String word<span style="color:#000;font-weight:bold">:</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">boolean</span> good <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> k <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> k <span style="color:#000;font-weight:bold">&lt;</span> word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#000;font-weight:bold">++</span>k<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(!</span>wordset<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">contains</span><span style="color:#000;font-weight:bold">(</span>word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">substring</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">,</span> k<span style="color:#000;font-weight:bold">)))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    good <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">false</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">break</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>good<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> word<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#d14">&#34;&#34;</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(\sum w_i^2)\)</span>, where <span class="math inline">\(w_i\)</span> is the length of <code>words[i]</code>. Checking whether all prefixes of <code>words[i]</code> are in the set is <span class="math inline">\(O(\sum w_i^2)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\sum w_i^2)\)</span> to create the substrings.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-trie--depth-first-search-accepted">Approach #2: Trie + Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>As prefixes of strings are involved, this is usually a natural fit for a <em>trie</em> (a prefix tree.)</p>
<p><strong>Algorithm</strong></p>
<p>Put every word in a trie, then depth-first-search from the start of the trie, only searching nodes that ended a word. Every node found (except the root, which is a special case) then represents a word with all its prefixes present.  We take the best such word.</p>
<p>In Python, we showcase a method using defaultdict, while in Java, we stick to a more general object-oriented approach.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">longestWord</span>(<span style="color:#999">self</span>, words):
</span></span><span style="display:flex;"><span>        Trie <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">lambda</span>: collections<span style="color:#000;font-weight:bold">.</span>defaultdict(Trie)
</span></span><span style="display:flex;"><span>        trie <span style="color:#000;font-weight:bold">=</span> Trie()
</span></span><span style="display:flex;"><span>        END <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i, word <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(words):
</span></span><span style="display:flex;"><span>            reduce(<span style="color:#0086b3">dict</span><span style="color:#000;font-weight:bold">.</span>__getitem__, word, trie)[END] <span style="color:#000;font-weight:bold">=</span> i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        stack <span style="color:#000;font-weight:bold">=</span> trie<span style="color:#000;font-weight:bold">.</span>values()
</span></span><span style="display:flex;"><span>        ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> stack:
</span></span><span style="display:flex;"><span>            cur <span style="color:#000;font-weight:bold">=</span> stack<span style="color:#000;font-weight:bold">.</span>pop()
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> END <span style="color:#000;font-weight:bold">in</span> cur:
</span></span><span style="display:flex;"><span>                word <span style="color:#000;font-weight:bold">=</span> words[cur[END]]
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#0086b3">len</span>(word) <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#0086b3">len</span>(ans) <span style="color:#000;font-weight:bold">or</span> <span style="color:#0086b3">len</span>(word) <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">len</span>(ans) <span style="color:#000;font-weight:bold">and</span> word <span style="color:#000;font-weight:bold">&lt;</span> ans:
</span></span><span style="display:flex;"><span>                    ans <span style="color:#000;font-weight:bold">=</span> word
</span></span><span style="display:flex;"><span>                stack<span style="color:#000;font-weight:bold">.</span>extend([cur[letter] <span style="color:#000;font-weight:bold">for</span> letter <span style="color:#000;font-weight:bold">in</span> cur <span style="color:#000;font-weight:bold">if</span> letter <span style="color:#000;font-weight:bold">!=</span> END])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> String <span style="color:#900;font-weight:bold">longestWord</span><span style="color:#000;font-weight:bold">(</span>String<span style="color:#000;font-weight:bold">[]</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        Trie trie <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Trie<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> index <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span>String word<span style="color:#000;font-weight:bold">:</span> words<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            trie<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">insert</span><span style="color:#000;font-weight:bold">(</span>word<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">++</span>index<span style="color:#000;font-weight:bold">);</span> <span style="color:#998;font-style:italic">//indexed by 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        trie<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">words</span> <span style="color:#000;font-weight:bold">=</span> words<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> trie<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">dfs</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Node</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> c<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    HashMap<span style="color:#000;font-weight:bold">&lt;</span>Character<span style="color:#000;font-weight:bold">,</span> Node<span style="color:#000;font-weight:bold">&gt;</span> children <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashMap<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> end<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#900;font-weight:bold">Node</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">char</span> c<span style="color:#000;font-weight:bold">){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">this</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">c</span> <span style="color:#000;font-weight:bold">=</span> c<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Trie</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    Node root<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    String<span style="color:#000;font-weight:bold">[]</span> words<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#900;font-weight:bold">Trie</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        root <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Node<span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#39;0&#39;</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">insert</span><span style="color:#000;font-weight:bold">(</span>String word<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> index<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        Node cur <span style="color:#000;font-weight:bold">=</span> root<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">char</span> c<span style="color:#000;font-weight:bold">:</span> word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">toCharArray</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            cur<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">children</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">putIfAbsent</span><span style="color:#000;font-weight:bold">(</span>c<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">new</span> Node<span style="color:#000;font-weight:bold">(</span>c<span style="color:#000;font-weight:bold">));</span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">children</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>c<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        cur<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">end</span> <span style="color:#000;font-weight:bold">=</span> index<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> String <span style="color:#900;font-weight:bold">dfs</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        String ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;&#34;</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        Stack<span style="color:#000;font-weight:bold">&lt;</span>Node<span style="color:#000;font-weight:bold">&gt;</span> stack <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> Stack<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        stack<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">push</span><span style="color:#000;font-weight:bold">(</span>root<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(!</span>stack<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">empty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            Node node <span style="color:#000;font-weight:bold">=</span> stack<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">pop</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>node<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">end</span> <span style="color:#000;font-weight:bold">&gt;</span> 0 <span style="color:#000;font-weight:bold">||</span> node <span style="color:#000;font-weight:bold">==</span> root<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>node <span style="color:#000;font-weight:bold">!=</span> root<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    String word <span style="color:#000;font-weight:bold">=</span> words<span style="color:#000;font-weight:bold">[</span>node<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">end</span> <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">&gt;</span> ans<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">||</span>
</span></span><span style="display:flex;"><span>                            word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">==</span> ans<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> word<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">compareTo</span><span style="color:#000;font-weight:bold">(</span>ans<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&lt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                        ans <span style="color:#000;font-weight:bold">=</span> word<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span>Node nei<span style="color:#000;font-weight:bold">:</span> node<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">children</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">values</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    stack<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">push</span><span style="color:#000;font-weight:bold">(</span>nei<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(\sum w_i)\)</span>, where <span class="math inline">\(w_i\)</span> is the length of <code>words[i]</code>. This is the complexity to build the trie and to search it.</p>
<p>If we used a BFS instead of a DFS and ordered the children in an array, we could drop the need to check whether the candidate word at each node is better than the answer, by forcing that the last node visited will be the best answer.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\sum w_i)\)</span>, the space used by our trie.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/map-sum-pairs/description" target="_blank" rel="noopener noreferrer">Map Sum Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a map that allows you to do the following:</p>

<ul>
	<li>Maps a string key to a given value.</li>
	<li>Returns the sum of the values that have a key with a prefix equal to a given string.</li>
</ul>

<p>Implement the <code>MapSum</code> class:</p>

<ul>
	<li><code>MapSum()</code> Initializes the <code>MapSum</code> object.</li>
	<li><code>void insert(String key, int val)</code> Inserts the <code>key-val</code> pair into the map. If the <code>key</code> already existed, the original <code>key-value</code> pair will be overridden to the new one.</li>
	<li><code>int sum(string prefix)</code> Returns the sum of all the pairs&#39; value whose <code>key</code> starts with the <code>prefix</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]
[[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]
<strong>Output</strong>
[null, null, 3, null, 5]

<strong>Explanation</strong>
MapSum mapSum = new MapSum();
mapSum.insert(&quot;apple&quot;, 3);  
mapSum.sum(&quot;ap&quot;);           // return 3 (<u>ap</u>ple = 3)
mapSum.insert(&quot;app&quot;, 2);    
mapSum.sum(&quot;ap&quot;);           // return 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>
	<li><code>key</code> and <code>prefix</code> consist of only lowercase English letters.</li>
	<li><code>1 &lt;= val &lt;= 1000</code></li>
	<li>At most <code>50</code> calls will be made to <code>insert</code> and <code>sum</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>For each key in the map, if that key starts with the given prefix, then add it to the answer.</p>
<p><a href="https://leetcode.com/playground/jNhyy639/shared">code</a><br />
<strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: Every insert operation is <span class="math inline">\(O(1)\)</span>. Every sum operation is <span class="math inline">\(O(N * P)\)</span> where <span class="math inline">\(N\)</span> is the number of items in the map, and <span class="math inline">\(P\)</span> is the length of the input prefix.</p>
</li>
<li>
<p>Space Complexity: The space used by <code>map</code> is linear in the size of all input <code>key</code> and <code>val</code> values combined.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-hashmap-accepted">Approach #2: Prefix Hashmap [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can remember the answer for all possible prefixes in a HashMap <code>score</code>. When we get a new <code>(key, val)</code> pair, we update every prefix of <code>key</code> appropriately: each prefix will be changed by <code>delta = val - map[key]</code>, where <code>map</code> is the previously associated value of <code>key</code> (zero if undefined.)</p>
<p><a href="https://leetcode.com/playground/QYzALHGM/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: Every insert operation is <span class="math inline">\(O(K^2)\)</span>, where <span class="math inline">\(K\)</span> is the length of the key, as <span class="math inline">\(K\)</span> strings are made of an average length of <span class="math inline">\(K\)</span>.  Every sum operation is <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space Complexity: The space used by <code>map</code> and <code>score</code> is linear in the size of all input <code>key</code> and <code>val</code> values combined.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-trie-accepted">Approach #3: Trie [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Since we are dealing with prefixes, a Trie (prefix tree) is a natural data structure to approach this problem. For every node of the trie corresponding to some prefix, we will remember the desired answer (score) and store it at this node.  As in <em>Approach #2</em>, this involves modifying each node by <code>delta = val - map[key]</code>.</p>
<p><a href="https://leetcode.com/playground/FbmbbgFJ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: Every insert operation is <span class="math inline">\(O(K)\)</span>, where <span class="math inline">\(K\)</span> is the length of the key. Every sum operation is <span class="math inline">\(O(K)\)</span>.</p>
</li>
<li>
<p>Space Complexity: The space used is linear in the size of the total input.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-genetic-difference-query/description" target="_blank" rel="noopener noreferrer">Maximum Genetic Difference Query</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a rooted tree consisting of <code>n</code> nodes numbered <code>0</code> to <code>n - 1</code>. Each node&#39;s number denotes its <strong>unique genetic value</strong> (i.e. the genetic value of node <code>x</code> is <code>x</code>). The <strong>genetic difference</strong> between two genetic values is defined as the <strong>bitwise-</strong><strong>XOR</strong> of their values. You are given the integer array <code>parents</code>, where <code>parents[i]</code> is the parent for node <code>i</code>. If node <code>x</code> is the <strong>root</strong> of the tree, then <code>parents[x] == -1</code>.</p>

<p>You are also given the array <code>queries</code> where <code>queries[i] = [node<sub>i</sub>, val<sub>i</sub>]</code>. For each query <code>i</code>, find the <strong>maximum genetic difference</strong> between <code>val<sub>i</sub></code> and <code>p<sub>i</sub></code>, where <code>p<sub>i</sub></code> is the genetic value of any node that is on the path between <code>node<sub>i</sub></code> and the root (including <code>node<sub>i</sub></code> and the root). More formally, you want to maximize <code>val<sub>i</sub> XOR p<sub>i</sub></code>.</p>

<p>Return <em>an array </em><code>ans</code><em> where </em><code>ans[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/c1.png" style="width: 118px; height: 163px;" />
<pre>
<strong>Input:</strong> parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
<strong>Output:</strong> [2,3,7]
<strong>Explanation: </strong>The queries are processed as follows:
- [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.
- [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.
- [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/c2.png" style="width: 256px; height: 221px;" />
<pre>
<strong>Input:</strong> parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
<strong>Output:</strong> [6,14,7]
<strong>Explanation: </strong>The queries are processed as follows:
- [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.
- [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.
- [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= parents.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= parents[i] &lt;= parents.length - 1</code> for every node <code>i</code> that is <strong>not</strong> the root.</li>
	<li><code>parents[root] == -1</code></li>
	<li><code>1 &lt;= queries.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= node<sub>i</sub> &lt;= parents.length - 1</code></li>
	<li><code>0 &lt;= val<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-strong-pair-xor-i/description" target="_blank" rel="noopener noreferrer">Maximum Strong Pair XOR I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. A pair of integers <code>x</code> and <code>y</code> is called a <strong>strong</strong> pair if it satisfies the condition:</p>

<ul>
	<li><code>|x - y| &lt;= min(x, y)</code></li>
</ul>

<p>You need to select two integers from <code>nums</code> such that they form a strong pair and their bitwise <code>XOR</code> is the <strong>maximum</strong> among all strong pairs in the array.</p>

<p>Return <em>the <strong>maximum</strong> </em><code>XOR</code><em> value out of all possible strong pairs in the array</em> <code>nums</code>.</p>

<p><strong>Note</strong> that you can pick the same integer twice to form a pair.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 11 strong pairs in the array <code>nums</code>: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).
The maximum XOR possible from these pairs is 3 XOR 4 = 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,100]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are 2 strong pairs in the array <code>nums</code>: (10, 10) and (100, 100).
The maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,6,25,30]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 6 strong pairs in the array <code>nums</code>: (5, 5), (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).
The maximum XOR possible from these pairs is 25 XOR 30 = 7 since the only other non-zero XOR value is 5 XOR 6 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-strong-pair-xor-ii/description" target="_blank" rel="noopener noreferrer">Maximum Strong Pair XOR II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. A pair of integers <code>x</code> and <code>y</code> is called a <strong>strong</strong> pair if it satisfies the condition:</p>

<ul>
	<li><code>|x - y| &lt;= min(x, y)</code></li>
</ul>

<p>You need to select two integers from <code>nums</code> such that they form a strong pair and their bitwise <code>XOR</code> is the <strong>maximum</strong> among all strong pairs in the array.</p>

<p>Return <em>the <strong>maximum</strong> </em><code>XOR</code><em> value out of all possible strong pairs in the array</em> <code>nums</code>.</p>

<p><strong>Note</strong> that you can pick the same integer twice to form a pair.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 11 strong pairs in the array <code>nums</code>: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).
The maximum XOR possible from these pairs is 3 XOR 4 = 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,100]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are 2 strong pairs in the array nums: (10, 10) and (100, 100).
The maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [500,520,2500,3000]
<strong>Output:</strong> 1020
<strong>Explanation:</strong> There are 6 strong pairs in the array nums: (500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).
The maximum XOR possible from these pairs is 500 XOR 520 = 1020 since the only other non-zero XOR value is 2500 XOR 3000 = 636.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2<sup>20</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description" target="_blank" rel="noopener noreferrer">Maximum XOR of Two Numbers in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>the maximum result of </em><code>nums[i] XOR nums[j]</code>, where <code>0 &lt;= i &lt;= j &lt; n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,10,5,25,2,8]
<strong>Output:</strong> 28
<strong>Explanation:</strong> The maximum result is 5 XOR 25 = 28.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [14,70,53,83,49,91,36,80,92,51,66,70]
<strong>Output:</strong> 127
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-xor-subarray--141631/1" target="_blank" rel="noopener noreferrer">Maximum XOR subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[]&nbsp;</strong>of size,&nbsp;<strong>N.</strong>&nbsp;Find the subarray with maximum XOR</span>. <span style="font-size: 18px;">A subarray is a contiguous part of the array.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong></span>:
<span style="font-size: 18px;">N = 4
arr[] = {1,2,3,4}
<strong>Output:</strong>&nbsp;7
<strong>Explanation</strong>: 
The subarray {3,4} has maximum xor 
value equal to 7.<br /><br /></span></pre>
<p style="font-family: sans-serif; font-size: medium; white-space: normal;"><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>:
N = 3
arr[] = {1,4,3}
<strong>Output:</strong>&nbsp;7
<strong>Explanation</strong>: 
 There are 6 possible subarrays:
 subarray            XOR value
 [1]                     1
 [4]                     4
 [3]                     3
 [1, 4]                  5 (1^4)
 [4, 3]                  7 (4^3)
 [1, 4, 3]               6 (1^4^3)

 [4, 3] subarray has maximum XOR value. So, return 7.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>maxSubarrayXOR()</strong>&nbsp;which takes the array arr[], its size N<strong> </strong>as input parameters&nbsp;and returns the maximum xor of any subarray.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N)<br /><strong>Expected Auxiliary Space:</strong> O(N)</span><br /><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>5</sup></span><br /><span style="font-size: 18px;">1<sup> </sup>&lt;= arr[i] &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-xor-with-an-element-from-array/description" target="_blank" rel="noopener noreferrer">Maximum XOR With an Element From Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> consisting of non-negative integers. You are also given a <code>queries</code> array, where <code>queries[i] = [x<sub>i</sub>, m<sub>i</sub>]</code>.</p>

<p>The answer to the <code>i<sup>th</sup></code> query is the maximum bitwise <code>XOR</code> value of <code>x<sub>i</sub></code> and any element of <code>nums</code> that does not exceed <code>m<sub>i</sub></code>. In other words, the answer is <code>max(nums[j] XOR x<sub>i</sub>)</code> for all <code>j</code> such that <code>nums[j] &lt;= m<sub>i</sub></code>. If all elements in <code>nums</code> are larger than <code>m<sub>i</sub></code>, then the answer is <code>-1</code>.</p>

<p>Return <em>an integer array </em><code>answer</code><em> where </em><code>answer.length == queries.length</code><em> and </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
<strong>Output:</strong> [3,3,7]
<strong>Explanation:</strong>
1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
<strong>Output:</strong> [15,-1,5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length, queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= nums[j], x<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-convert-string-ii/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Convert String II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>source</code> and <code>target</code>, both of length <code>n</code> and consisting of <strong>lowercase</strong> English characters. You are also given two <strong>0-indexed</strong> string arrays <code>original</code> and <code>changed</code>, and an integer array <code>cost</code>, where <code>cost[i]</code> represents the cost of converting the string <code>original[i]</code> to the string <code>changed[i]</code>.</p>

<p>You start with the string <code>source</code>. In one operation, you can pick a <strong>substring</strong> <code>x</code> from the string, and change it to <code>y</code> at a cost of <code>z</code> <strong>if</strong> there exists <strong>any</strong> index <code>j</code> such that <code>cost[j] == z</code>, <code>original[j] == x</code>, and <code>changed[j] == y</code>. You are allowed to do <strong>any</strong> number of operations, but any pair of operations must satisfy <strong>either</strong> of these two conditions:</p>

<ul>
	<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with either <code>b &lt; c</code> <strong>or</strong> <code>d &lt; a</code>. In other words, the indices picked in both operations are <strong>disjoint</strong>.</li>
	<li>The substrings picked in the operations are <code>source[a..b]</code> and <code>source[c..d]</code> with <code>a == c</code> <strong>and</strong> <code>b == d</code>. In other words, the indices picked in both operations are <strong>identical</strong>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> cost to convert the string </em><code>source</code><em> to the string </em><code>target</code><em> using <strong>any</strong> number of operations</em>. <em>If it is impossible to convert</em> <code>source</code> <em>to</em> <code>target</code>,<em> return</em> <code>-1</code>.</p>

<p><strong>Note</strong> that there may exist indices <code>i</code>, <code>j</code> such that <code>original[j] == original[i]</code> and <code>changed[j] == changed[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcd&quot;, target = &quot;acbe&quot;, original = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;d&quot;], changed = [&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;e&quot;,&quot;b&quot;,&quot;e&quot;], cost = [2,5,5,1,2,20]
<strong>Output:</strong> 28
<strong>Explanation:</strong> To convert &quot;abcd&quot; to &quot;acbe&quot;, do the following operations:
- Change substring source[1..1] from &quot;b&quot; to &quot;c&quot; at a cost of 5.
- Change substring source[2..2] from &quot;c&quot; to &quot;e&quot; at a cost of 1.
- Change substring source[2..2] from &quot;e&quot; to &quot;b&quot; at a cost of 2.
- Change substring source[3..3] from &quot;d&quot; to &quot;e&quot; at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28. 
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;acdeeghh&quot;, original = [&quot;bcd&quot;,&quot;fgh&quot;,&quot;thh&quot;], changed = [&quot;cde&quot;,&quot;thh&quot;,&quot;ghh&quot;], cost = [1,3,5]
<strong>Output:</strong> 9
<strong>Explanation:</strong> To convert &quot;abcdefgh&quot; to &quot;acdeeghh&quot;, do the following operations:
- Change substring source[1..3] from &quot;bcd&quot; to &quot;cde&quot; at a cost of 1.
- Change substring source[5..7] from &quot;fgh&quot; to &quot;thh&quot; at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.
- Change substring source[5..7] from &quot;thh&quot; to &quot;ghh&quot; at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.
The total cost incurred is 1 + 3 + 5 = 9.
It can be shown that this is the minimum possible cost.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> source = &quot;abcdefgh&quot;, target = &quot;addddddd&quot;, original = [&quot;bcd&quot;,&quot;defgh&quot;], changed = [&quot;ddd&quot;,&quot;ddddd&quot;], cost = [100,1578]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to convert &quot;abcdefgh&quot; to &quot;addddddd&quot;.
If you select substring source[1..3] as the first operation to change &quot;abcdefgh&quot; to &quot;adddefgh&quot;, you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.
If you select substring source[3..7] as the first operation to change &quot;abcdefgh&quot; to &quot;abcddddd&quot;, you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= source.length == target.length &lt;= 1000</code></li>
	<li><code>source</code>, <code>target</code> consist only of lowercase English characters.</li>
	<li><code>1 &lt;= cost.length == original.length == changed.length &lt;= 100</code></li>
	<li><code>1 &lt;= original[i].length == changed[i].length &lt;= source.length</code></li>
	<li><code>original[i]</code>, <code>changed[i]</code> consist only of lowercase English characters.</li>
	<li><code>original[i] != changed[i]</code></li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-i/description" target="_blank" rel="noopener noreferrer">Minimum Number of Valid Strings to Form Target I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>target</code>.</p>

<p>A string <code>x</code> is called <strong>valid</strong> if <code>x</code> is a <span data-keyword="string-prefix">prefix</span> of <strong>any</strong> string in <code>words</code>.</p>

<p>Return the <strong>minimum</strong> number of <strong>valid</strong> strings that can be <em>concatenated</em> to form <code>target</code>. If it is <strong>not</strong> possible to form <code>target</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abc&quot;,&quot;aaaaa&quot;,&quot;bcdef&quot;], target = &quot;aabcdabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 2 of <code>words[1]</code>, i.e. <code>&quot;aa&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[2]</code>, i.e. <code>&quot;bcd&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[0]</code>, i.e. <code>&quot;abc&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abababab&quot;,&quot;ab&quot;], target = &quot;ababaababa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abcdef&quot;], target = &quot;xyz&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>3</sup></code></li>
	<li>The input is generated such that <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>3</sup></code></li>
	<li><code>target</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-xor-value-pair/1" target="_blank" rel="noopener noreferrer">Minimum XOR value pair</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an array of&nbsp;integers of size N find minimum xor of any 2 elements.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong></span>:
<span style="font-size:18px">N = 3
arr[] = {9,5,3}
<strong>Output:</strong>&nbsp;6
<strong>Explanation</strong>: 
There are 3 pairs -
9^5 = 12
5^3 = 6
9^3 = 10
Therefore output is 6.
</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>minxorpair()</strong>&nbsp;which takes the array arr[], its size N<strong> </strong>as input parameters&nbsp;and returns the minimum value of xor of any 2 elements.</span><br />
<br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span><br />
<br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N &lt;= 10<sup>5</sup></span><br />
<span style="font-size:18px">1<sup> </sup>&lt;= arr[i] &lt;= 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/most-frequent-word-in-an-array-of-strings3528/1" target="_blank" rel="noopener noreferrer">Most frequent word in an array of strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr </strong>containing <strong>N</strong> words consisting <strong>of lowercase characters</strong>. Your task is to find the <strong>most frequent</strong> word in the array. If <strong>multiple </strong>words have same frequency, then print the<strong> word whose first occurence occurs last</strong> in the array as compared to the other strings with same frequency.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 3
arr[] = {geeks,for,geeks}
<strong>Output: </strong>geeks<strong>
Explanation: </strong>"geeks" comes 2 times.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 2
arr[] = {hello,world}
<strong>Output: </strong>world<strong>
Explanation: </strong>"hello" and "world" both
have 1 frequency. We print world as
its first occurence comes last in the
input array.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />Complete<strong>&nbsp;mostFrequentWord&nbsp;</strong>function which takes array of strings and its length as arguments and returns the most frequent word. The printing is done by the driver code.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N * WORD_LEN).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N * WORD_LEN).</span></p>
<div><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 50000<br />1 &lt;= |each string| &lt;= 50</span></div>
<div><span style="font-size: 18px;">Sum of length of every string does not exceed&nbsp;5*10<sup>5</sup></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-matching-subsequences/description" target="_blank" rel="noopener noreferrer">Number of Matching Subsequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and an array of strings <code>words</code>, return <em>the number of</em> <code>words[i]</code> <em>that is a subsequence of</em> <code>s</code>.</p>

<p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>

<ul>
	<li>For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcde&quot;, words = [&quot;a&quot;,&quot;bb&quot;,&quot;acd&quot;,&quot;ace&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three strings in words that are a subsequence of s: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dsahjpjauf&quot;, words = [&quot;ahjpjau&quot;,&quot;ja&quot;,&quot;ahbwzgqnuk&quot;,&quot;tnmlanowax&quot;]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words.length &lt;= 5000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 50</code></li>
	<li><code>s</code> and <code>words[i]</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-valid-words-for-each-puzzle/description" target="_blank" rel="noopener noreferrer">Number of Valid Words for Each Puzzle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section">With respect to a given <code>puzzle</code> string, a <code>word</code> is <em>valid</em> if both the following conditions are satisfied:
<ul>
	<li><code>word</code> contains the first letter of <code>puzzle</code>.</li>
	<li>For each letter in <code>word</code>, that letter is in <code>puzzle</code>.
	<ul>
		<li>For example, if the puzzle is <code>&quot;abcdefg&quot;</code>, then valid words are <code>&quot;faced&quot;</code>, <code>&quot;cabbage&quot;</code>, and <code>&quot;baggage&quot;</code>, while</li>
		<li>invalid words are <code>&quot;beefed&quot;</code> (does not include <code>&#39;a&#39;</code>) and <code>&quot;based&quot;</code> (includes <code>&#39;s&#39;</code> which is not in the puzzle).</li>
	</ul>
	</li>
</ul>
Return <em>an array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the number of words in the given word list </em><code>words</code><em> that is valid with respect to the puzzle </em><code>puzzles[i]</code>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]
<strong>Output:</strong> [1,1,3,2,4,0]
<strong>Explanation:</strong> 
1 valid word for &quot;aboveyz&quot; : &quot;aaaa&quot; 
1 valid word for &quot;abrodyz&quot; : &quot;aaaa&quot;
3 valid words for &quot;abslute&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;
2 valid words for &quot;absoryz&quot; : &quot;aaaa&quot;, &quot;asas&quot;
4 valid words for &quot;actresz&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;
There are no valid words for &quot;gaswxyz&quot; cause none of the words in the list contains letter &#39;g&#39;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;apple&quot;,&quot;pleas&quot;,&quot;please&quot;], puzzles = [&quot;aelwxyz&quot;,&quot;aelpxyz&quot;,&quot;aelpsxy&quot;,&quot;saelpxy&quot;,&quot;xaelpsy&quot;]
<strong>Output:</strong> [0,1,3,2,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>4 &lt;= words[i].length &lt;= 50</code></li>
	<li><code>1 &lt;= puzzles.length &lt;= 10<sup>4</sup></code></li>
	<li><code>puzzles[i].length == 7</code></li>
	<li><code>words[i]</code> and <code>puzzles[i]</code> consist of lowercase English letters.</li>
	<li>Each <code>puzzles[i] </code>does not contain repeated characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-boggle-ii--141631/1" target="_blank" rel="noopener noreferrer">Open the gates</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">recursion</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Geek and his friends went on a trip to one of the hill stations in Geekland. While trekking they found a treasure map, it was in the form of <strong>r x c</strong> size board, each cell on the <strong>map</strong> denotes a latin uppercase letter. On the bottom of the map it was written that there are <strong>n gates</strong> with a specific name and if they could find out the name of the gate on the map that gate would open. Help Geek and his friends to find out the gates they could possibly open with the map they found.&nbsp;</span></p>
<p><span style="font-size: 14pt;">A name can be formed by a sequence of adjacent characters on the map. We can move to any of 8 adjacent characters. While forming a word we can move to any of the 8 adjacent cells. A cell can be used only once in one name.</span></p>
<p><span style="font-size: 14pt;">&nbsp;<strong>NOTE</strong>: All gate names returned must be different even it occurs multiple times in the input.</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: 
</strong>n = 3
gate_names = {"ZARA", "ZETH", "MYTH"}
r = 3, c = 3
map = A Z E<br />       R Y T<br />       M A H
<strong>Output:</strong>
{"ZARA", "ZETH", "MYTH"}
<strong>Explanation</strong>: <br /><span style="color: #e03e2d;"><span style="color: #000000;">Opening gate ZARA</span><br />A</span> <span style="color: #e03e2d;">Z</span> E<br /><span style="color: #e03e2d;">R</span> Y T<br />M <span style="color: #e03e2d;">A</span> H<br />Opening gate ZETH<br />A <span style="color: #3598db;">Z</span> <span style="color: #3598db;">E</span><br />R Y <span style="color: #3598db;">T</span><br />M A <span style="color: #3598db;">H</span><br />Opening gate MYTH<br />A Z E<br />R <span style="color: #2dc26b;">Y</span> <span style="color: #2dc26b;">T</span><br /><span style="color: #2dc26b;">M</span> A <span style="color: #2dc26b;">H</span>
</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
n = 5
gate_names = {"NYX","ONYX","VIRA","KARA", "NYX"}
r = 3, c = 3 
map = N O A<br />       P Y V<br />       K R X
<strong>Output:</strong>
{"NYX", "ONYX"}
<strong>Explanation</strong>: <br /><span style="color: #000000;">Opening gate NYX<br /><span style="color: #e03e2d;">N</span> O A<br />P <span style="color: #e03e2d;">Y</span> V<br />K R <span style="color: #e03e2d;">X</span><br />Opening gate ONYX<br /><span style="color: #3598db;">N</span> <span style="color: #3598db;">O</span> A<br />P <span style="color: #3598db;">Y</span> V<br />K R <span style="color: #3598db;">X<br /><strong><span style="color: #000000;">Note that NYX is counted only once.</span></strong></span></span></span></pre>
<p><span style="font-size: 14pt;"><strong>Your task:</strong><br />You don&rsquo;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>openGates()</strong> which takes the <strong>gate_names</strong> contaning <strong>n</strong> space-separated strings and <strong>r*c map</strong> as input parameters and returns a list of gate names that can be opened</span></p>
<p><span style="font-size: 14pt;"><strong>Expected Time Complexity: </strong>O(4^(N^2))<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N^2)</span></p>
<div><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n &le; 15<br />1 &le; r, c &le; 50<br />1 &le; length of each gate name &le; 60</span></div>
<div><span style="font-size: 14pt;">All words of gate_names and all characters of map are uppercase letters from <strong>'A'</strong> to <strong>'Z'</strong></span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/palindrome-pairs/description" target="_blank" rel="noopener noreferrer">Palindrome Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <strong>unique</strong> strings <code>words</code>.</p>

<p>A <strong>palindrome pair</strong> is a pair of integers <code>(i, j)</code> such that:</p>

<ul>
	<li><code>0 &lt;= i, j &lt; words.length</code>,</li>
	<li><code>i != j</code>, and</li>
	<li><code>words[i] + words[j]</code> (the concatenation of the two strings) is a <span data-keyword="palindrome-string">palindrome</span>.</li>
</ul>

<p>Return <em>an array of all the <strong>palindrome pairs</strong> of </em><code>words</code>.</p>

<p>You must write an algorithm with&nbsp;<code>O(sum of words[i].length)</code>&nbsp;runtime complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]
<strong>Output:</strong> [[0,1],[1,0],[3,2],[2,4]]
<strong>Explanation:</strong> The palindromes are [&quot;abcddcba&quot;,&quot;dcbaabcd&quot;,&quot;slls&quot;,&quot;llssssll&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]
<strong>Output:</strong> [[0,1],[1,0]]
<strong>Explanation:</strong> The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;&quot;]
<strong>Output:</strong> [[0,1],[1,0]]
<strong>Explanation:</strong> The palindromes are [&quot;a&quot;,&quot;a&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 5000</code></li>
	<li><code>0 &lt;= words[i].length &lt;= 300</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/palindrome-pairs/1" target="_blank" rel="noopener noreferrer">Palindrome Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array of strings arr[] of size N, find if there exists 2 strings arr[i] and arr[j] such that arr[i]+arr[j] is a palindrome i.e the concatenation of string arr[i] and arr[j] results into a palindrome.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong></span>:
<span style="font-size: 18px;">N = 6
arr[] = {"geekf", "geeks", "or","keeg", "abc", 
          "bc"}
<strong>Output:</strong>&nbsp;1&nbsp;
<strong>Explanation</strong>: There is a pair "geekf"
and "keeg".</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 5
arr[] = {"abc", "xyxcba", "geekst", "or", "bc"}
<strong>Output:&nbsp;</strong>1
<strong>Explanation</strong>: There is a pair "abc"
and "xyxcba".</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>palindromepair()</strong>&nbsp;which takes the array arr[], its size N<strong> </strong>and returns true if palindrome pair exists and returns false otherwise.<br />The driver code itself prints 1 if returned value is true and prints 0 if returned value is false.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N*l<sup>2</sup>) where l = length of longest string in arr[]<br /><strong>Expected Auxiliary Space:</strong> O(N*l<sup>2</sup>) where l = length of longest string in arr[]</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 2*10<sup>4</sup></span><br /><span style="font-size: 18px;">1 &le; |arr[i]| &le; 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-string/description" target="_blank" rel="noopener noreferrer">Partition String </a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, partition it into <strong>unique segments</strong> according to the following procedure:</p>

<ul>
	<li>Start building a segment beginning at index 0.</li>
	<li>Continue extending the current segment character by character until the current segment has not been seen before.</li>
	<li>Once the segment is unique, add it to your list of segments, mark it as seen, and begin a new segment from the next index.</li>
	<li>Repeat until you reach the end of <code>s</code>.</li>
</ul>

<p>Return an array of strings <code>segments</code>, where <code>segments[i]</code> is the <code>i<sup>th</sup></code> segment created.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abbccccd&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[&quot;a&quot;,&quot;b&quot;,&quot;bc&quot;,&quot;c&quot;,&quot;cc&quot;,&quot;d&quot;]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Index</th>
			<th style="border: 1px solid black;">Segment After Adding</th>
			<th style="border: 1px solid black;">Seen Segments</th>
			<th style="border: 1px solid black;">Current Segment Seen Before?</th>
			<th style="border: 1px solid black;">New Segment</th>
			<th style="border: 1px solid black;">Updated Seen Segments</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">&quot;a&quot;</td>
			<td style="border: 1px solid black;">[]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">&quot;b&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">&quot;b&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;]</td>
			<td style="border: 1px solid black;">Yes</td>
			<td style="border: 1px solid black;">&quot;b&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">&quot;bc&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">&quot;c&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">&quot;c&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;]</td>
			<td style="border: 1px solid black;">Yes</td>
			<td style="border: 1px solid black;">&quot;c&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">&quot;cc&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;cc&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">7</td>
			<td style="border: 1px solid black;">&quot;d&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;cc&quot;]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;cc&quot;, &quot;d&quot;]</td>
		</tr>
	</tbody>
</table>

<p>Hence, the final output is <code>[&quot;a&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;cc&quot;, &quot;d&quot;]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aaaa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[&quot;a&quot;,&quot;aa&quot;]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Index</th>
			<th style="border: 1px solid black;">Segment After Adding</th>
			<th style="border: 1px solid black;">Seen Segments</th>
			<th style="border: 1px solid black;">Current Segment Seen Before?</th>
			<th style="border: 1px solid black;">New Segment</th>
			<th style="border: 1px solid black;">Updated Seen Segments</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">&quot;a&quot;</td>
			<td style="border: 1px solid black;">[]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">&quot;a&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;]</td>
			<td style="border: 1px solid black;">Yes</td>
			<td style="border: 1px solid black;">&quot;a&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">&quot;aa&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;]</td>
			<td style="border: 1px solid black;">No</td>
			<td style="border: 1px solid black;">&quot;&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;aa&quot;]</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">&quot;a&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;aa&quot;]</td>
			<td style="border: 1px solid black;">Yes</td>
			<td style="border: 1px solid black;">&quot;a&quot;</td>
			<td style="border: 1px solid black;">[&quot;a&quot;, &quot;aa&quot;]</td>
		</tr>
	</tbody>
</table>

<p>Hence, the final output is <code>[&quot;a&quot;, &quot;aa&quot;]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> contains only lowercase English letters. </li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/phone-directory4628/1" target="_blank" rel="noopener noreferrer">Phone directory</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">map</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a list of contacts <strong>contact[]</strong>&nbsp;of length <strong>n</strong>&nbsp;where each contact is a string which exist in a phone directory and a query string <strong>s</strong>. The task is to implement a search query for the phone directory. Run a search query for each prefix <strong>p</strong> of the query string <strong>s&nbsp;</strong>(<em>i.e.</em> from&nbsp; index 1 to |s|) that prints all the distinct contacts which have the same prefix as p&nbsp;in <strong>lexicographical increasing&nbsp;order</strong>.&nbsp;Please refer the explanation part for better understanding.</span><br /><span style="font-size: 18px;"><strong>Note: </strong>If there is no match between query and contacts, print "0".</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> 
n = 3
contact[] = {"geeikistest", "geeksforgeeks", 
"geeksfortest"}
s = "geeips"
<strong>Output:</strong>
geeikistest geeksforgeeks geeksfortest
geeikistest geeksforgeeks geeksfortest
geeikistest geeksforgeeks geeksfortest
geeikistest
0
0
<strong>Explaination:</strong> By running the search query on 
contact list for "g" we get: "geeikistest", 
"geeksforgeeks" and "geeksfortest".
By running the search query on contact list 
for "ge" we get: "geeikistest" "geeksforgeeks"
and "geeksfortest".
By running the search query on contact list 
for "gee" we get: "geeikistest" "geeksforgeeks"
and "geeksfortest".
By running the search query on contact list 
for "geei" we get: "geeikistest".
No results found for "geeip", so print "0". 
No results found for "geeips", so print "0".</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You&nbsp;do not need to read input or print anything. Your task is to complete the function <strong>displayContacts()</strong> which takes <strong>n, contact[ ] </strong>and<strong> s</strong> as input parameters and returns a list of list of strings for required prefixes. If some prefix has no matching contact return&nbsp;"0" on that list.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(|s| * n * max|contact[i]|)<br /><strong>Expected Auxiliary Space:</strong> O(n * max|contact[i]|)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; T&nbsp;&le; 100, T = number of test cases<br />1 &le;&nbsp;n &le;&nbsp;50<br />1 &le; |contact[i]| &le;&nbsp;50<br />1 &le;&nbsp;|s| &le;&nbsp;6&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/prefix-and-suffix-search/description" target="_blank" rel="noopener noreferrer">Prefix and Suffix Search</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a special dictionary that searches the words in it by a prefix and a suffix.</p>

<p>Implement the <code>WordFilter</code> class:</p>

<ul>
	<li><code>WordFilter(string[] words)</code> Initializes the object with the <code>words</code> in the dictionary.</li>
	<li><code>f(string pref, string suff)</code> Returns <em>the index of the word in the dictionary,</em> which has the prefix <code>pref</code> and the suffix <code>suff</code>. If there is more than one valid index, return <strong>the largest</strong> of them. If there is no such word in the dictionary, return <code>-1</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;WordFilter&quot;, &quot;f&quot;]
[[[&quot;apple&quot;]], [&quot;a&quot;, &quot;e&quot;]]
<strong>Output</strong>
[null, 0]
<strong>Explanation</strong>
WordFilter wordFilter = new WordFilter([&quot;apple&quot;]);
wordFilter.f(&quot;a&quot;, &quot;e&quot;); // return 0, because the word at index 0 has prefix = &quot;a&quot; and suffix = &quot;e&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
	<li><code>1 &lt;= pref.length, suff.length &lt;= 7</code></li>
	<li><code>words[i]</code>, <code>pref</code> and <code>suff</code> consist of lowercase English letters only.</li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to the function <code>f</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-trie--set-intersection-time-limit-exceeded">Approach #1: Trie + Set Intersection [Time Limit Exceeded]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We use two tries to separately find all words that match the prefix, plus all words that match the suffix. Then, we try to find the highest-weight element in the intersection of these sets.</p>
<p>Of course, these sets could still be large, so we might TLE if we aren't careful.</p>
<p><a href="https://leetcode.com/playground/kYz9yLtz/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(NK + Q(N+K))\)</span> where <span class="math inline">\(N\)</span> is the number of words, <span class="math inline">\(K\)</span> is the maximum length of a word, and <span class="math inline">\(Q\)</span> is the number of queries. If we use memoization in our solution, we could produce tighter bounds for this complexity, as the complex queries are somewhat disjoint.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(NK)\)</span>, the size of the tries.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-paired-trie-accepted">Approach #2: Paired Trie [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Say we are inserting the word <code>apple</code>.  We could insert <code>('a', 'e'), ('p', 'l'), ('p', 'p'), ('l', 'p'), ('e', 'a')</code> into our trie. Then, if we had equal length queries like <code>prefix = &quot;ap&quot;, suffix = &quot;le&quot;</code>, we could find the node <code>trie['a', 'e']['p', 'l']</code> in our trie.  This seems promising.</p>
<p>What about queries that aren't equal?  We should just insert them like normal. For example, to capture a case like <code>prefix = &quot;app&quot;, suffix = &quot;e&quot;</code>, we could create nodes <code>trie['a', 'e']['p', None]['p', None]</code>.</p>
<p>After inserting these pairs into our trie, our searches are straightforward.</p>
<p><a href="https://leetcode.com/playground/HUwJpYcH/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(NK^2 + QK)\)</span> where <span class="math inline">\(N\)</span> is the number of words, <span class="math inline">\(K\)</span> is the maximum length of a word, and <span class="math inline">\(Q\)</span> is the number of queries.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(NK^2)\)</span>, the size of the trie.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-trie-of-suffix-wrapped-words-accepted">Approach #3: Trie of Suffix Wrapped Words [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Consider the word <code>'apple'</code>. For each suffix of the word, we could insert that suffix, followed by <code>'#'</code>, followed by the word, all into the trie.</p>
<p>For example, we will insert <code>'#apple', 'e#apple', 'le#apple', 'ple#apple', 'pple#apple', 'apple#apple'</code> into the trie.  Then for a query like <code>prefix = &quot;ap&quot;, suffix = &quot;le&quot;</code>, we can find it by querying our trie for <code>le#ap</code>.</p>
<p><a href="https://leetcode.com/playground/EQGJp4E3/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(NK^2 + QK)\)</span> where <span class="math inline">\(N\)</span> is the number of words, <span class="math inline">\(K\)</span> is the maximum length of a word, and <span class="math inline">\(Q\)</span> is the number of queries.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(NK^2)\)</span>, the size of the trie.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/prefix-match-with-other-strings/1" target="_blank" rel="noopener noreferrer">Prefix match with other strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array of strings <strong>arr[]</strong> of size <strong>n, </strong>a string <strong>str</strong> and an integer <strong>k</strong>. The task is to find the count of strings in <strong>arr[]</strong> whose <strong>prefix of length</strong> <strong>k</strong> matches with the <strong>k-length prefix</strong> of <strong>str</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples<br /></strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong></span>: <span style="font-size: 18px;">n = 6 </span><span style="font-size: 18px;">arr[] = {&ldquo;abba&rdquo;, &ldquo;abbb&rdquo;, &ldquo;abbc&rdquo;, &ldquo;abbd&rdquo;, &ldquo;abaa&rdquo;, &ldquo;abca&rdquo;} str = &ldquo;abbg&rdquo; k = 3
<strong>Output:</strong> 4&nbsp;
<strong>Explanation</strong>: &ldquo;abba&rdquo;, &ldquo;abbb&rdquo;, &ldquo;abbc&rdquo; and &ldquo;abbd&rdquo; have their prefix of length 3 equal to 3-length prefix of <strong>str</strong> i.e., <strong>"abb".</strong></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 3 arr[] = {&ldquo;geeks&rdquo;, &ldquo;geeksforgeeks&rdquo;, &ldquo;forgeeks&rdquo;} str = &ldquo;ge&rdquo; k = 5
<strong>Output:&nbsp;</strong>0</span><br /><span style="font-size: 14pt;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">: </span>There do not exists any prefix of <strong>str</strong> with length <strong>5.</strong> So, there are no matches possible.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>klengthpref()</strong>&nbsp;which takes the array of strings arr[], its size <strong>n </strong>and an integer <strong>k, </strong>a string<strong> str </strong>as input parameters&nbsp;and returns the </span><span style="font-size: 18px;">count of strings in <strong>arr[]</strong> whose prefix of length <strong>k</strong> matches with the <strong>k</strong> length prefix of <strong>str</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(n*l) where l is the length of the longest word in arr[].<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(n*l) where l is the length of the longest word in arr[].<br /></span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 1000</span><br /><span style="font-size: 18px;">1<sup> </sup>&lt;= |arr[i]| , |str| &lt;= 1000</span><br /><span style="font-size: 18px;">1 &lt;= k &lt;= 1000<br />arr[i], str must contain only lowercase English alphabets</span><br />&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/prefix-suffix-string--170647/1" target="_blank" rel="noopener noreferrer">Prefix Suffix String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given two Lists of <strong>strings s1 </strong>and <strong>s2</strong>, you have to count the number&nbsp;of strings in <strong>s2 </strong>which is either a <strong>suffix </strong>or <strong>prefix </strong>of at least one string of <strong>s1</strong>.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px">s1 = [&quot;cat&quot;, &quot;catanddog&quot;, &quot;lion&quot;]
s2 = [&quot;cat&quot;, &quot;dog&quot;, &quot;rat&quot;]</span>
<span style="font-size:18px"><strong>Output: 
2</strong></span>
<span style="font-size:18px"><strong>Explanation:</strong> 
String &quot;cat&quot; of s2 is prefix of &quot;catand<strong>dog</strong>&quot;
&amp; string &quot;dog&quot; of s2 is suffix of &quot;catand<strong>dog</strong>&quot; </span>
</pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span> 
<span style="font-size:18px">s1 = [&quot;jrjiml&quot;, &quot;tchetn&quot;, &quot;ucrhye&quot;, &quot;ynayhy&quot;, 
&nbsp;      &quot;cuhffd&quot;, &quot;cvgpoiu&quot;, &quot;znyadv&quot;]
s2 = [&quot;jr&quot;, &quot;ml&quot;, &quot;cvgpoi&quot;, &quot;gpoiu&quot;, &quot;wnmkmluc&quot;, 
&nbsp;     &quot;geheqe&quot;, &quot;uglxagyl&quot;, &quot;uyxdroj&quot;]</span> 
<span style="font-size:18px"><strong>Output: 
4
Explanation:</strong> 
String &quot;jr&quot; of s2 is prefix of &quot;<strong>jr</strong>jiml&quot;, 
&quot;ml&quot; of s2 is suffix of &quot;jrji<strong>ml</strong>&quot;, 
&quot;cvgpoi&quot; of s2 is prefix of &quot;<strong>cvgpoi</strong>u&quot; &amp;
&quot;gpoiu&quot; of s2 is suffix of &quot;cv<strong>gpoiu</strong>&quot;</span><strong>
</strong></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong></span><br />
<span style="font-size:18px">You don&#39;t need to read input or print anything. Your task is to complete the function prefixSuffixString(), which takes 2 strings s1 and s2&nbsp;as input and returns an integer value as the number of strings in s2 which is a prefix or suffix in s1.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity</strong>: O(max(len(s1) , len(s2) ))<br />
<strong>Expected Space Complexity</strong>: O(1)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
&nbsp;&nbsp;&nbsp;1 &lt;= s1,s2&nbsp;&lt; 5&nbsp;* 10^3<br />
&nbsp; &nbsp;5 &lt;= len(s1[i]), len(s2[i]) &lt; 25</span><br />
&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-sub-folders-from-the-filesystem/description" target="_blank" rel="noopener noreferrer">Remove Sub-Folders from the Filesystem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a list of folders <code>folder</code>, return <em>the folders after removing all <strong>sub-folders</strong> in those folders</em>. You may return the answer in <strong>any order</strong>.</p>

<p>If a <code>folder[i]</code> is located within another <code>folder[j]</code>, it is called a <strong>sub-folder</strong> of it. A sub-folder of <code>folder[j]</code> must start with <code>folder[j]</code>, followed by a <code>&quot;/&quot;</code>. For example, <code>&quot;/a/b&quot;</code> is a sub-folder of <code>&quot;/a&quot;</code>, but <code>&quot;/b&quot;</code> is not a sub-folder of <code>&quot;/a/b/c&quot;</code>.</p>

<p>The format of a path is one or more concatenated strings of the form: <code>&#39;/&#39;</code> followed by one or more lowercase English letters.</p>

<ul>
	<li>For example, <code>&quot;/leetcode&quot;</code> and <code>&quot;/leetcode/problems&quot;</code> are valid paths while an empty string and <code>&quot;/&quot;</code> are not.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]
<strong>Output:</strong> [&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]
<strong>Explanation:</strong> Folders &quot;/a/b&quot; is a subfolder of &quot;/a&quot; and &quot;/c/d/e&quot; is inside of folder &quot;/c/d&quot; in our filesystem.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> folder = [&quot;/a&quot;,&quot;/a/b/c&quot;,&quot;/a/b/d&quot;]
<strong>Output:</strong> [&quot;/a&quot;]
<strong>Explanation:</strong> Folders &quot;/a/b/c&quot; and &quot;/a/b/d&quot; will be removed because they are subfolders of &quot;/a&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> folder = [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]
<strong>Output:</strong> [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= folder.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>2 &lt;= folder[i].length &lt;= 100</code></li>
	<li><code>folder[i]</code> contains only lowercase letters and <code>&#39;/&#39;</code>.</li>
	<li><code>folder[i]</code> always starts with the character <code>&#39;/&#39;</code>.</li>
	<li>Each folder name is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-set">Approach 1: Using Set</h3>
<h4 id="intuition">Intuition</h4>
<p>The challenge is to efficiently determine when one folder is a sub-folder of another by finding folder paths and identifying hierarchical relationships. We can achieve this by storing all folder paths in a set, allowing us to quickly check if a folder is nested within another.</p>
<p>Once we have the set, the next logical step is to look at each folder in the list and check its “parent” paths by trimming off one part of the path at a time. For instance, if we have a folder <code>&quot;/a/b/c&quot;</code>, we’d first check <code>&quot;/a/b&quot;</code>, then <code>&quot;/a&quot;</code>. If any of these exist in the set, it means the current folder is a sub-folder, so we can skip it. On the other hand, if no parent path exists in the set, we can conclude it’s an independent folder and add it to our result.</p>
<p>By breaking each folder down like this, we can establish a relationship between folders and sub-folders. This approach is straightforward to understand if we’re dealing with a small number of folders, but it's not very efficient for large inputs since it involves checking multiple prefixes for each folder.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create a set <code>folderSet</code> containing all folder paths from the <code>folder</code> array for quick look-up.</p>
</li>
<li>
<p>Initialize an empty array <code>result</code> to store folders that are not sub-folders.</p>
</li>
<li>
<p>For each folder <code>f</code> in <code>folder</code>:</p>
<ul>
<li>
<p>Set a flag <code>isSubFolder</code> to <code>false</code>.</p>
</li>
<li>
<p>Initialize <code>prefix</code> with the value of <code>f</code> to represent the current folder path.</p>
</li>
<li>
<p>Use a loop to check each parent path of <code>prefix</code>:</p>
<ul>
<li>
<p>Find the position of the last <code>/</code> in <code>prefix</code> and remove everything after it to get the parent path.</p>
</li>
<li>
<p>If no <code>/</code> is found, break out of the loop (no more parent paths).</p>
</li>
<li>
<p>Check if this parent path exists in <code>folderSet</code>:</p>
<ul>
<li>If it does, mark <code>isSubFolder</code> as <code>true</code> and exit the loop since <code>f</code> is a sub-folder.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If <code>isSubFolder</code> is still <code>false</code> after checking all parent paths, add <code>f</code> to <code>result</code>.</p>
</li>
</ul>
</li>
<li>
<p>After all, folders have been processed, return <code>result</code> which contains only the top-level folders (non-sub-folders).</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/WTTqXHwm/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of folders and <span class="math inline">\(L\)</span> be the maximum length of a folder path.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot L + N \cdot L^2) = O(N \cdot L^2)\)</span></p>
<p>Constructing the unordered set <code>folderSet</code> from the input array <code>folder</code> takes <span class="math inline">\(O(N)\)</span>. However, each string insertion requires <span class="math inline">\(O(L)\)</span>. So, initializing the set takes <span class="math inline">\(O(N \cdot L)\)</span>.</p>
<p>The primary operation involves iterating over each folder path in the <code>folder</code> array, which is <span class="math inline">\(O(N)\)</span>.</p>
<ul>
<li>For each folder, the algorithm checks all possible prefixes (up to <code>L</code> levels deep) in the <code>folderSet</code>. This involves:</li>
<li>Finding the position of the last '/' character in the <code>prefix</code> string, which takes <span class="math inline">\(O(L)\)</span> in the worst case.</li>
<li>Creating a substring for each prefix level, which is also <span class="math inline">\(O(L)\)</span>.</li>
<li>Searching for each prefix in the set, which is <span class="math inline">\(O(L)\)</span>.</li>
</ul>
<p>Therefore, checking all prefixes of one folder takes <span class="math inline">\(O(L^2)\)</span>, and for <span class="math inline">\(N\)</span> folders, this results in <span class="math inline">\(O(N \cdot L^2)\)</span>.</p>
<p>The initialization and main loop lead to a time complexity of <span class="math inline">\(O(N \cdot L + N \cdot L^2) \approx O(N \cdot L^2)\)</span>, as <span class="math inline">\(O(N \cdot L^2)\)</span> dominates.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot L)\)</span></p>
<p>The <code>folderSet</code> stores each of the <span class="math inline">\(N\)</span> folder paths. Each path can be as long as <span class="math inline">\(L\)</span>, so the space complexity for the set is <span class="math inline">\(O(N \cdot L)\)</span>.</p>
<p>The array <code>result</code> stores each non-subfolder path. In the worst case, if none of the folders are subfolders, this array also takes <span class="math inline">\(O(N \cdot L)\)</span> space.</p>
<p>Minor additional space is used for variables like <code>isSubFolder</code> and <code>prefix</code>. This additional space is constant, <span class="math inline">\(O(1)\)</span>, and does not affect the overall complexity.</p>
<p>The dominant space usage is from the <code>folderSet</code> and <code>result</code> array, leading to a total space complexity of <span class="math inline">\(O(N \cdot L)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-sorting">Approach 2: Using Sorting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To filter out sub-folders, we can take advantage of the natural order of paths by sorting the list of folders alphabetically. In this order, any sub-folder will appear directly after its parent folder. We can then filter sub-folders in a single pass through the sorted list.</p>
<p>Starting with an empty result list, we add the first folder. As we continue through the list, each folder is either a sub-folder of the last added folder (if it starts with that path plus a <code>/</code>) or it's an independent folder. For example, if the last added folder was <code>&quot;/a&quot;</code>, any folder beginning with <code>&quot;/a/&quot;</code> is a sub-folder and can be skipped. Otherwise, we add the folder to the result list.</p>
<p>!?!../Documents/1233/approach2.json:985,735!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Sort the <code>folder</code> array alphabetically so that any sub-folder appears immediately after its parent folder.</p>
</li>
<li>
<p>Initialize an empty array <code>result</code> to store non-sub-folder paths and add the first folder in <code>folder</code> to <code>result</code> as a baseline.</p>
</li>
<li>
<p>For each folder <code>folder[i]</code> starting from the second folder:</p>
<ul>
<li>
<p>Retrieve the last folder path added to <code>result</code> and append a <code>/</code> to it, storing it as <code>lastFolder</code>.</p>
</li>
<li>
<p>Check if <code>folder[i]</code> starts with <code>lastFolder</code>:</p>
<ul>
<li>If it does, skip this folder since it is a sub-folder of <code>lastFolder</code>.</li>
<li>Otherwise, add <code>folder[i]</code> to <code>result</code> because it is not a sub-folder.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After iterating through all folders, return <code>result</code>, which contains only the top-level folders (non-sub-folders).</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Eu4kVp7L/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of folders and <span class="math inline">\(L\)</span> be the maximum length of a folder path.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot L \log N)\)</span></p>
<p>Sorting takes <span class="math inline">\(O(N \cdot \log N)\)</span> comparisons, but each comparison can involve up to <span class="math inline">\(L\)</span> characters (the maximum length of a folder path). Therefore, this step has a time complexity of <span class="math inline">\(O(N \cdot L \log N)\)</span>.</p>
<p>The loop runs <span class="math inline">\(N-1\)</span> times. For each folder, it does the following:</p>
<ul>
<li>Retrieves the last folder from <code>result</code> and appends a <code>'/'</code> to it, which takes <span class="math inline">\(O(L)\)</span> time.</li>
<li>Uses compare to check if the current folder starts with the last added folder. This comparison will take <span class="math inline">\(O(L)\)</span> time in the worst case.<br />
Thus, the overall time complexity for this part is: <span class="math inline">\(O(N \cdot L)\)</span></li>
</ul>
<p>Therefore, combining the sorting and iteration steps, the total time complexity is: <span class="math inline">\(O(N \cdot L \log N) + O(N \cdot L)\)</span></p>
<p>Since <span class="math inline">\(O(N \cdot L \log N)\)</span> dominates <span class="math inline">\(O(N \cdot L)\)</span>, we can simplify the time complexity to <span class="math inline">\(O(N \cdot L \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot L)\)</span></p>
<p>The <code>result</code> array stores each folder that is not a sub-folder. In the worst case, every folder is added to <code>result</code>, which requires <span class="math inline">\(O(N \cdot L)\)</span> space.</p>
<p>The space taken by the sorting algorithm depends on the language of implementation:</p>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log N)\)</span>.<br />
In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log N)\)</span>.<br />
In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(N)\)</span>.</p>
<p>Thus, the total space complexity is <span class="math inline">\(O(N \cdot L)\)</span></p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-trie">Approach 3: Using Trie</h3>
<h4 id="intuition-2">Intuition</h4>
<p>A Trie is well-suited for this problem because it allows us to build folder paths incrementally, marking endpoints where folders end. With this structure, any folder that tries to extend beyond an endpoint can be identified as a sub-folder.</p>
<p>We start with an empty Trie and insert folder paths by splitting each path into its components (e.g., <code>&quot;/a/b/c&quot;</code> becomes <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>). As we insert each part, we check if we’ve reached an endpoint in the Trie. If so, we can skip the current folder as it’s a sub-folder. Otherwise, we continue inserting the remaining parts. At the end of each path, we mark it as an endpoint.</p>
<p>This way, any future folder that follows an existing path will encounter the endpoint, confirming it as a sub-folder. This is extremely effective for handling deeply nested folder structures.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define a <code>TrieNode</code> class with:</p>
<ul>
<li>A boolean <code>isEndOfFolder</code> to indicate if the node marks the end of a folder.</li>
<li>A map called <code>children</code> to store child folder nodes.</li>
</ul>
</li>
<li>
<p>Create a <code>TrieNode</code> root in the <code>Solution</code> class to start building the Trie.</p>
</li>
<li>
<p>The <code>removeSubfolders</code> method:</p>
<ul>
<li>For each folder path in <code>folder</code>:
<ul>
<li>Split the path into folder names using <code>/</code> as the delimiter.</li>
<li>Start from the root node and traverse through the folder names:
<ul>
<li>For each folder, if it is not an empty string:
<ul>
<li>If the current folder does not exist in the children, add it as a new <code>TrieNode</code>.</li>
<li>Move to the child node corresponding to the current folder.</li>
</ul>
</li>
</ul>
</li>
<li>Mark the last node of the path as <code>isEndOfFolder = true</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize an empty array called <code>result</code> to store non-sub-folder paths.</p>
</li>
<li>
<p>For each folder path in <code>folder</code> again:</p>
<ul>
<li>Split the path into folder names.</li>
<li>Initialize a boolean <code>isSubfolder</code> to <code>false</code> to track if the current path is a sub-folder.</li>
<li>Start from the root node and traverse through the folder names:
<ul>
<li>For each folder, if it is not an empty string:
<ul>
<li>Retrieve the next node corresponding to the current folder name.</li>
<li>If <code>nextNode.isEndOfFolder</code> is <code>true</code> and it is not the last folder in the path, mark <code>isSubfolder</code> as <code>true</code> and break the loop.</li>
</ul>
</li>
<li>If the path is not a sub-folder, add it to <code>result</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, which contains only the top-level folders (non-sub-folders).</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/ArGwbzYZ/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of folders and <span class="math inline">\(L\)</span> be the maximum length of a folder path.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \times L)\)</span></p>
<p>For each folder path in <code>folderPaths</code>, the algorithm parses the path and inserts it into the Trie. Parsing each path takes <span class="math inline">\(O(L)\)</span> time.</p>
<p>For each segment, checking and inserting into Trie’s map also takes <span class="math inline">\(O(L)\)</span> time on average due to hash table operations (insertions and lookups in the map). Therefore, building the Trie for all <span class="math inline">\(N\)</span> paths results in a total time complexity of <span class="math inline">\(O(N \times L)\)</span>.</p>
<p>For each folder path, the algorithm traverses the Trie to check if it is a subfolder. Again, parsing the path takes <span class="math inline">\(O(L)\)</span>, and each lookup in the map takes <span class="math inline">\(O(1)\)</span> on average. Therefore, checking all <span class="math inline">\(N\)</span> folder paths also requires <span class="math inline">\(O(N \times L)\)</span> time.</p>
<p>Overall, both the Trie-building and subfolder-checking phases have a time complexity of <span class="math inline">\(O(N \times L)\)</span>, so the total time complexity is: <span class="math inline">\(O(N \times L)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N \times L)\)</span></p>
<p>Each folder path can create up to <span class="math inline">\(L\)</span> nodes in the Trie, depending on the path depth. In the worst case, if all folder paths are unique, we would end up storing all <span class="math inline">\(N \times L\)</span> segments. Therefore, the space required for the Trie structure is <span class="math inline">\(O(N \times L)\)</span>.</p>
<p>The <code>result</code> array stores up to <span class="math inline">\(N\)</span> folder paths, so its space requirement is <span class="math inline">\(O(N)\)</span>. Intermediate variables like <code>iss</code> and <code>string</code> use <span class="math inline">\(O(L)\)</span> space for each folder path.</p>
<p>Since the Trie is the most space-consuming data structure in this solution, the overall space complexity is: <span class="math inline">\(O(N \times L)\)</span></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/renaming-cities28581833/1" target="_blank" rel="noopener noreferrer">Renaming Cities</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Some cities are going to be renamed and accordingly name of their railway stations will also change. Changing the name of railway station should also result in changed station code.&nbsp;Railways have an idea that station code should be the shortest prefix out of all railway stations renamed prior to this. If some city has same name, then&nbsp;prefix will be the name with suffix as the count of occurence of that city prior to this and including this, seperated with spaces.</span></p>

<p><span style="font-size:18px">Given&nbsp;N&nbsp;renamed cities consisting of lowercase alphabets only. The task is to generate a&nbsp;station ID&nbsp;for all the stations.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 6
Cities[] = {shimla,safari,jammu,delhi,
                jammu,dehradun}
<strong>Output:
</strong>s
sa
j
d
jammu 2
deh<strong>
Explanation: </strong>Till&nbsp;shimla, no stations are there.
So, it&#39;s first character will be the unique
smallest prefix. For safari, first character of
shimla matches, so unique smallest prefix is&nbsp;sa
Similarly,&nbsp;j&nbsp;is smallest unique prefix for&nbsp;jammu
and&nbsp;d&nbsp;is for delhi. For last city&nbsp;jammu, we have
countered&nbsp;jammu before, and therefor no smallest
prefix is possible. So, we can generate its code
as jammu with suffix equal to the count of jammu,
i.e, 2. Smallest unique prefix is&nbsp;jammu2. Now,
delhi can be renamed as d, and dehradun can be
renamed as deh, since deh is the smallest non
matching prefix.&nbsp;</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
Complete&nbsp;<strong>check</strong>&nbsp;function which takes&nbsp;array of strings&nbsp;and&nbsp;number of string&nbsp;&#39;n&#39; as arguments and print the require answer in the function itself. You have to provide new line in the function itself.</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N &lt;= 10<sup>6</sup><br />
1 &lt;= Word Length &lt;= 100</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(N *&nbsp;WORD_LEN).<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N * WORD_LEN).</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/replace-words/description" target="_blank" rel="noopener noreferrer">Replace Words</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In English, we have a concept called <strong>root</strong>, which can be followed by some other word to form another longer word - let&#39;s call this word <strong>derivative</strong>. For example, when the <strong>root</strong> <code>&quot;help&quot;</code> is followed by the word <code>&quot;ful&quot;</code>, we can form a derivative <code>&quot;helpful&quot;</code>.</p>

<p>Given a <code>dictionary</code> consisting of many <strong>roots</strong> and a <code>sentence</code> consisting of words separated by spaces, replace all the derivatives in the sentence with the <strong>root</strong> forming it. If a derivative can be replaced by more than one <strong>root</strong>, replace it with the <strong>root</strong> that has <strong>the shortest length</strong>.</p>

<p>Return <em>the <code>sentence</code></em> after the replacement.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;
<strong>Output:</strong> &quot;the cat was rat by the bat&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], sentence = &quot;aadsfasf absbs bbab cadsfafs&quot;
<strong>Output:</strong> &quot;a a b c&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>
	<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>
	<li><code>dictionary[i]</code> consists of only lower-case letters.</li>
	<li><code>1 &lt;= sentence.length &lt;= 10<sup>6</sup></code></li>
	<li><code>sentence</code> consists of only lower-case letters and spaces.</li>
	<li>The number of words in <code>sentence</code> is in the range <code>[1, 1000]</code></li>
	<li>The length of each word in <code>sentence</code> is in the range <code>[1, 1000]</code></li>
	<li>Every two consecutive words in <code>sentence</code> will be separated by exactly one space.</li>
	<li><code>sentence</code> does not have leading or trailing spaces.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-hash-set">Approach 1: Hash Set</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute force approach of searching the entire dictionary for every possible root of every word in the sentence would be inefficient. Instead, we can preprocess the dictionary by creating a hash set, <code>dictSet</code>, containing all the words from the dictionary. The <code>dictSet</code> will allow us to check if a word has a root in the dictionary in constant time.</p>
<p>For a word in the sentence, its root will be found at the beginning of the word. This means that a word's root is a prefix of the word. The possible prefixes for a word are the set of substrings that start at the beginning of the word and end at any index of the word. For example, the prefixes for &quot;cat&quot; are &quot;c&quot;, &quot;ca&quot;, and &quot;cat&quot;.</p>
<p>To solve the problem, we break it down into two sub-problems:</p>
<ol>
<li>
<p>Finding the shortest root in the <code>dictSet</code> that matches a prefix of a given word.</p>
</li>
<li>
<p>Replacing the word with its shortest root.</p>
</li>
</ol>
<p>We can create a helper function, <code>shortestRoot</code>, to solve the first subproblem. For each word in the sentence, we check if the <code>dictSet</code> contains any words that qualify as roots for the word. If any of the prefixes of the word matches a root word, we return the shortest one. If not, we return the full word.</p>
<p>Below is an image showing the process for finding the shortest root:</p>
<p><img src="../Figures/648/shortest_rootA.png" alt="Shortest Root A" /></p>
<p>Below is an image showing the process for finding the shortest root when the <code>word</code> has no corresponding root:</p>
<p><img src="../Figures/648/shortest_rootB.png" alt="Shortest Root B" /></p>
<p>To solve the second subproblem, we will create a data structure to store each word from the sentence. Then, we use the <code>shortestRoot</code> function to find the corresponding shortest root for each word and replace the word with the root.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a data structure <code>wordArray</code> that contains each word from the <code>sentence</code>.</li>
<li>Create a hash set <code>dictSet</code> containing each word from the dictionary.</li>
<li>Define a helper function <code>shortestRoot</code> that finds the shortest corresponding root word in the given dictionary for a given <code>word</code>.
<ul>
<li>For each index of <code>word</code>, save the substring of <code>word</code> that starts at the beginning of <code>word</code> and ends at the index as <code>root</code>. If the <code>dictSet</code> contains <code>root</code>, return <code>root</code>.</li>
<li>Return <code>word</code> if there is not a corresponding root in the dictionary.</li>
</ul>
</li>
<li>For each index <code>word</code> in <code>wordArray</code>:
<ul>
<li>Search for the corresponding shortest root using the helper function and set <code>wordArray[word]</code> to the shortest root.</li>
</ul>
</li>
<li>Convert <code>wordArray</code> to a string and return.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><strong>Note:</strong> The C++ implementation uses <code>istringstream</code> instead of an array to store the words in the sentence because there is no built-in way to create an array of words from a string by splitting at the spaces. It also uses a string to build the result.</p>
<p><a href="https://leetcode.com/playground/cjSqDM4T/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(d\)</span> be the number of words in the dictionary, <span class="math inline">\(s\)</span> be the number of words in the sentence, and <span class="math inline">\(w\)</span> be the average length of each word.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(d \cdot w + s \cdot w^2)\)</span></p>
<p>Creating a set from the dictionary takes <span class="math inline">\(O(d \cdot w)\)</span>. Creating the data structure that stores the words in the sentence takes <span class="math inline">\(O(s \cdot w)\)</span>.</p>
<p>The loop in the helper function runs once for each letter in the word. Building each substring takes the helper function <span class="math inline">\(O(w)\)</span>. Hash set lookups take <span class="math inline">\(O(1)\)</span> in the average case. Therefore, the time complexity of the helper function is <span class="math inline">\(O(w^2)\)</span>.</p>
<p>The main loop calls the helper function once for each word in the sentence, so it takes <span class="math inline">\(O(s \cdot w^2)\)</span>.</p>
<p>Converting the result to a string takes <span class="math inline">\(O(s \cdot w)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(d \cdot w + s \cdot w^2)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(d \cdot w + s \cdot w)\)</span></p>
<p>The set that stores the dictionary requires <span class="math inline">\(O(d \cdot w)\)</span> space. The data structure that stores the words in the sentence uses <span class="math inline">\(O(s \cdot w)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-trie">Approach 2: Prefix Trie</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the above approach, we searched for each prefix of each word separately in the hash set. We created a new substring for each prefix, which is inefficient because each prefix differs from the previous by just one letter.</p>
<p>Instead of using a hashmap to store the dictionary, we can use a Trie, sometimes known as a Prefix Trie.</p>
<blockquote>
<p>A Trie is a tree-based data structure where each node represents a character in a word, and the path from the root to a leaf node represents a complete word. Tries allow for efficient word lookup and prefix matching.</p>
</blockquote>
<p>Below is an image of a Trie storing the dictionary [&quot;to&quot;, &quot;too&quot;, &quot;the&quot;, &quot;that&quot;, &quot;toe&quot;, &quot;theatre&quot;, &quot;apple&quot;, &quot;pen&quot;, &quot;pencil&quot;, &quot;pineapple&quot;, &quot;pine&quot;]:</p>
<p><img src="../Figures/648/prefix_trie.png" alt="Trie" /></p>
<p>If you are unfamiliar with the Trie data structure, we recommend you read our <a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card</a></p>
<p>The Trie is made up of TrieNodes, which each consist of a boolean flag that is set to <code>true</code> when the node represents the end of a word and an array with pointers to the child nodes.</p>
<p>Some implementations of Trie use a hashmap to store pointers to the children nodes instead, which uses less space but may take more time. We chose to use an array because we are working with a relatively small set of characters, the lowercase English alphabet.</p>
<p>A Trie has a root and a constructor. Our implementation of Trie uses two additional functions:</p>
<ol>
<li>
<p><code>insert</code>, which inserts a word into the Trie.</p>
</li>
<li>
<p><code>shortestRoot</code>, which finds the shortest corresponding root for a given <code>word</code>.</p>
</li>
</ol>
<p>We will focus our discussion on the <code>shortestRoot</code> function because it is unique to this problem. This function is similar to searching in a Trie.</p>
<p>The basic idea is to start at the root and progress to the child node that corresponds to the next character in <code>word</code> until we either reach the end of the given <code>word</code>, or the current character in the <code>word</code> is not in the Trie. In either case, we return <code>word</code>.</p>
<p>During the search process, the first node with the <code>isEnd</code> flag set to <code>true</code> is the shortest root. We return the substring of the word that ends after the current index.</p>
<p>The <code>replaceWords</code> function is very similar to the previous approach, except we use our Trie class and its <code>shortestRoot</code> function instead of a hash set and a helper function.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong>A. Implement the <code>TrieNode</code> class:</strong></p>
<p>Properties:<br />
<code>isEnd</code>: A boolean value indicating whether the node marks the end of a word.<br />
<code>children</code>: An array of size 26 (the number of lowercase English letters) to store pointers to child nodes.</p>
<p>Constructor:<br />
The constructor initializes <code>isEnd</code> to false and all elements in the <code>children</code> array to <code>null</code>.</p>
<p><strong>B. Implement the <code>Trie</code> class:</strong></p>
<p>Properties:<br />
<code>root</code>: A <code>TrieNode</code> that points to the root of the Trie.</p>
<p>Constructor:<br />
The constructor initializes the <code>root</code> with a new TrieNode object. The <code>root</code> is associated with an empty string.</p>
<p><code>insert</code> function:<br />
Inserts the given <code>word</code> in the <code>Trie</code>.</p>
<ol>
<li>Set a TrieNode <code>current</code> to <code>root</code>.</li>
<li>For each character <code>c</code> in the <code>word</code>:
<ul>
<li>If the child node for <code>c</code> doesn't exist, create a new TrieNode and insert it into the <code>children</code> array.</li>
<li>Move to the child node for <code>c</code>.</li>
</ul>
</li>
<li>After processing all the characters, mark <code>isEnd</code> as true for the current node.</li>
</ol>
<p><code>shortestRoot</code> function:<br />
Finds the shortest corresponding root for a given <code>word</code>.</p>
<ol>
<li>Set a TrieNode <code>current</code> to <code>root</code>.</li>
<li>For each index in the word:
<ul>
<li>Set a character <code>c</code> to the current character.</li>
<li>If the child node for <code>c</code> doesn't exist, return <code>word</code>.</li>
<li>Move to the child node for <code>c</code>.</li>
<li>If <code>current</code> is the end of a word, return the substring of <code>word</code> from the start of the word through the current index.</li>
</ul>
</li>
<li>After processing all the characters, return <code>word</code> if there is no corresponding root.</li>
</ol>
<p><strong>C. Implement the <code>replaceWords</code> function:</strong></p>
<ol>
<li>Create a data structure <code>wordArray</code> that contains each word from the <code>sentence</code>.</li>
<li>Create a Trie <code>dictTree</code> and insert each word from the dictionary.</li>
<li>For each index <code>word</code> in <code>wordArray</code>:
<ul>
<li>Search for the corresponding shortest root using <code>dictTree.shortestRoot</code> and set <code>wordArray[word]</code> to the shortest root.</li>
</ul>
</li>
<li>Convert <code>wordArray</code> to a string and return.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/W5cSaBcY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(d\)</span> be the number of words in the dictionary, <span class="math inline">\(s\)</span> be the number of words in the sentence, and <span class="math inline">\(w\)</span> be the average length of each word.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(d \cdot w + s \cdot w)\)</span></p>
<p>Creating the Trie takes <span class="math inline">\(O(d \cdot w)\)</span>. Creating the data structure that stores the words in the sentence takes <span class="math inline">\(O(s \cdot w)\)</span>.</p>
<p>The loop in the <code>shortestRoot</code> function runs once for each letter in the word. If a corresponding prefix is found, it creates one substring, which takes <span class="math inline">\(O(w)\)</span>. Therefore, the time complexity of finding the shortest root is <span class="math inline">\(O(w)\)</span>.</p>
<p>The main loop calls the <code>shortestRoot</code> function once for each word in the sentence, so it takes <span class="math inline">\(O(s \cdot w)\)</span>.</p>
<p>Converting the result to a string takes <span class="math inline">\(O(s \cdot w)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(d \cdot w + 2 \cdot s \cdot w)\)</span>, which we can simplify to <span class="math inline">\(O(d \cdot w + s \cdot w)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(d \cdot w + s \cdot w)\)</span></p>
<p>The Trie may store up to <span class="math inline">\(O(d \cdot w)\)</span> nodes, and each node stores an array with <span class="math inline">\(26\)</span> pointers, so the Trie requires <span class="math inline">\(O(d \cdot w \cdot 26)\)</span> space. <span class="math inline">\(26\)</span> is a constant factor, so we can simplify this to <span class="math inline">\(O(d \cdot w)\)</span>. The data structure that stores the words in the sentence uses <span class="math inline">\(O(s \cdot w)\)</span> space.</p>
<blockquote>
<p>Note: Though the space complexity looks similar to the above approach, this approach will usually require less space because when any words have the same prefix, it stores the prefix only once, while the hash set stores words like &quot;semicircle&quot; and &quot;semitruck&quot; separately.</p>
</blockquote>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-query-auto-complete/1" target="_blank" rel="noopener noreferrer">Search Query Auto Complete</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Design a search query autocomplete system for a search engine. </span></p>
<p><span style="font-size: 18px;">The users will input a sentence ( which may have multiple words and ends with special character '<code>#</code>').</span></p>
<p><span style="font-size: 18px;">For each character they type except '<code>#</code>', you need to return the top 3 previously entered&nbsp;and most frequently queried&nbsp;sentences that have prefix the same as the part of sentence already typed. </span></p>
<p><span style="font-size: 18px;">Here are the specific rules:</span></p>
<ol>
<li><span style="font-size: 18px;">The frequency&nbsp;for a sentence is defined as the number of times a user typed the exactly same sentence before.</span></li>
<li><span style="font-size: 18px;">The returned top 3 sentences should be sorted by frequency&nbsp;(The first is the most frequent).&nbsp; If several sentences have the same frequency, you need to use ASCII-code order (smaller one appears first).</span></li>
<li><span style="font-size: 18px;">If less than 3 valid&nbsp;sentences exist, then just return as many as you can.</span></li>
<li><span style="font-size: 18px;">When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list. </span></li>
</ol>
<p>&nbsp;</p>
<p><span style="font-size: 18px;">Your job is to implement the methods of the AutoCompleteSystem:</span></p>
<ul>
<li><span style="font-size: 18px;"><code>AutoCompleteSystem(String[] sentences, int[] times):</code> This is the constructor. The input is previously used&nbsp;data. Sentences is a string array consists of previously typed sentences. Times is the corresponding times a sentence has been typed. Your system should record these historical sentences.</span></li>
</ul>
<p><span style="font-size: 18px;">Now, the user wants to input a new sentence. The following function will provide the next character the user types:</span></p>
<ul>
<li><span style="font-size: 18px;"><code>String[]&nbsp;input(char c):</code>&nbsp;The input c is the next character typed by the user. The character will only be lower-case letters ('a' to 'z'), blank space (' ') or a special character ('<code>#</code>'). Also, the previously typed sentence should be recorded in your system. The output an array&nbsp;will be the top 3 historical sentences that have prefix the same as the part of sentence already typed.</span></li>
</ul>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">Example:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Operation</strong>:
AutoCompleteSystem(["i love you", "island",
"ironman", "i love geeksforgeeks"], [5,3,2,2])

The system have already tracked down the 
following sentences and their corresponding 
times: 
"i love you" : 5 times 
"island" : 3 times 
"ironman" : 2 times 
"i love geeksforgeeks" : 2 times 

Now, the user begins another search: 

<strong>Operation</strong>: input('i') 
<strong>Output</strong>: 
["i love you", "island","i love 
&nbsp;                      geeksforgeeks"] 

<strong>Explanation</strong>: 
There are four sentences that have prefix 
"i". Among them, "ironman" and "i love 
geeksforgeeks" have same frequency. Since 
' ' has ASCII code 32 and 'r' has ASCII code
 114, "i love geeksforgeeks" should be in 
front of "ironman". Also we only need to 
output top 3 most frequent sentences, so 
"ironman" will be ignored. 

<strong>Operation</strong>: input(' ') 
<strong>Output</strong>: ["i love you","i love geeksforgeeks"] 
<strong>Explanation</strong>: 
There are only two sentences that have prefix 
"i ". 

<strong>Operation</strong>: input('a') 
<strong>Output</strong>: [] 
<strong>Explanation</strong>: 
There are no sentences that have prefix "i a"

<strong>Operation</strong>: input('#') 
<strong>Output</strong>: [] 
<strong>Explanation</strong>: 
The user finished the input, the sentence 
"i a" should be saved as a historical 
sentence in system. And the next input 
will be counted as a new search.
</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">You don't need to take inputs or give outputs . You just have to complete the <strong>input()</strong>&nbsp;method and the&nbsp;<strong>constructor</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(n*max|L|), per input query where n represents the number of historical sentences in the system and L&nbsp;is the maximum&nbsp;length of the words.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong> </span></p>
<ul>
<li><span style="font-size: 18px;">The input sentence will always start with a letter and end with '<code>#</code>', and at most&nbsp;one blank space will exist between two words. </span></li>
<li><span style="font-size: 18px;">The number of complete sentences that to be searched won't exceed 10<sup>2</sup>.</span></li>
<li><span style="font-size: 18px;">The length of each sentence including those in the historical data and query data&nbsp;won't exceed 10<sup>2</sup>. </span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-query-for-strings5049/1" target="_blank" rel="noopener noreferrer">Search Query for Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Trie is an efficient information retrieval data structure. Use this data structure to store strings and search strings. In this problem, you are given an array of strings (consisting of lowercase characters) <strong>arr</strong>[] of size <strong>N</strong>. Also, you will be given some queries <strong>Q</strong> and for each query a string is given and your task is to check if the given string is in the string array or not.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> <strong>Each word</strong> in the array of string can be of size <strong>10<sup>3</sup></strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">N = 8, Q = 3
words[] = {the,a,there,answer,any,by,bye
their}
Queries[] = {the,an,any}
<strong>Output:
</strong>1
0
1<strong>
Explanation: </strong>After inserting words in the
array,all the words will be stored. Now
searching for the will result in 1
(present), an will resultin 0(not present)
and any will result in 1 (present).</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />Complete <strong>insert </strong>and <strong>search,&nbsp;</strong>return <strong>true</strong>&nbsp;if the given string is present in the TRIE, else <strong>false</strong> in search function.&nbsp; 1 is printed by the driver's code if the value returned is true, 0 otherwise.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N).<br />N = length of the string</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>3</sup><br />1 &lt;= Q &lt;= 10<sup>3</sup></span></p>
<p>&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-suggestions-system/description" target="_blank" rel="noopener noreferrer">Search Suggestions System</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.</p>

<p>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums products.</p>

<p>Return <em>a list of lists of the suggested products after each character of </em><code>searchWord</code><em> is typed</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;
<strong>Output:</strong> [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]]
<strong>Explanation:</strong> products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;].
After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;].
After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> products = [&quot;havana&quot;], searchWord = &quot;havana&quot;
<strong>Output:</strong> [[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]]
<strong>Explanation:</strong> The only word &quot;havana&quot; will be always suggested while typing the search word.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= products.length &lt;= 1000</code></li>
	<li><code>1 &lt;= products[i].length &lt;= 3000</code></li>
	<li><code>1 &lt;= sum(products[i].length) &lt;= 2 * 10<sup>4</sup></code></li>
	<li>All the strings of <code>products</code> are <strong>unique</strong>.</li>
	<li><code>products[i]</code> consists of lowercase English letters.</li>
	<li><code>1 &lt;= searchWord.length &lt;= 1000</code></li>
	<li><code>searchWord</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>Since the question asks for the result in a sorted order, let's start with sorting <code>products</code>.<br />
An advantage that comes with sorting is <code>Binary Search</code>, we can binary search for the prefix. Once we locate the first match of prefix, all we need to do is to add the next 3 words into the result (if there are any), since we sorted the words beforehand.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort the input <code>products</code>.</li>
<li>Iterate each character of the <code>searchWord</code> adding it to the <code>prefix</code> to search for.</li>
<li>After adding the current character to the <code>prefix</code> binary search for the <code>prefix</code> in the input.</li>
<li>Add next 3 strings from the current binary search <code>start</code> index till the prefix remains same.</li>
<li>Another optimization that can be done is reducing the binary search space to current <code>start</code> index (This is due to the fact that adding more characters to the prefix will make the next search result's index be at least &gt; current search's index).</li>
</ol>
<p><a href="https://leetcode.com/playground/NCPdFYJE/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(nlog(n)) + O(mlog(n))\)</span>. Where <code>n</code> is the length of <code>products</code> and <code>m</code> is the length of the search word. Here we treat string comparison in sorting as  <span class="math inline">\(O(1)\)</span>.  <span class="math inline">\(O(nlog(n))\)</span> comes from the sorting and <span class="math inline">\(O(mlog(n))\)</span> comes from running <code>binary search</code> on products <code>m</code> times.</p>
<ul>
<li>In Java there is an additional complexity of <span class="math inline">\(O(m^2)\)</span> due to Strings being immutable, here <code>m</code> is the length of <code>searchWord</code>.</li>
</ul>
</li>
<li>
<p>Space complexity : Varies between <span class="math inline">\(O(1)\)</span> and <span class="math inline">\(O(n)\)</span> where <code>n</code> is the length of <code>products</code>, as it depends on the implementation used for sorting. We ignore the space required for output as it does not affect the algorithm's space complexity. See <a href="https://www.geeksforgeeks.org/internal-details-of-stdsort-in-c/">Internal details of std::sort</a>.<br />
Space required for output is <span class="math inline">\(O(m)\)</span> where <code>m</code> is the length of the search word.</p>
</li>
</ul>
<br />
<hr />
<h3 id="approach-2-trie--dfs">Approach 2: Trie + DFS</h3>
<p><strong>Intuition</strong></p>
<p>Whenever we come across questions with multiple strings, it is best to think if <a href="https://en.wikipedia.org/wiki/Trie">Trie</a> can help us. What we need here is a way to search for all the words with given prefix, this is a well known problem that trie can solve. The question also asks for a sorted results, if you look closely a trie word is represented by it's preorder traversal. It is also worth noting that a preorder traversal of a trie will always result in a sorted traversal of results, thus all we need to do is limit the word traversal to 3.</p>
<p>Questions using Trie:</p>
<p><a href="https://leetcode.com/problems/word-search">79. Word Search</a></p>
<p><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure">211. Design Add and Search Words Data Structure</a></p>
<p><img src="../Figures/1268/Trie.png" alt="diff" /><br />
<em>Figure 1. A trie made from <code>words</code></em></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a Trie from the given products input.</li>
<li>Iterate each character of the <code>searchWord</code> adding it to the <code>prefix</code> to search for.</li>
<li>After adding the current character to the <code>prefix</code> traverse the <code>trie</code> pointer to the node representing <code>prefix</code>.</li>
<li>Now traverse the tree from <code>curr</code> pointer in a preorder fashion and record whenever we encounter a complete word.</li>
<li>Limit the result to 3 and return <code>dfs</code> once reached this limit.</li>
<li>Add the words to the final result.</li>
</ol>
<p><a href="https://leetcode.com/playground/RSAV9EQc/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(M)\)</span> to build the <code>trie</code> where <code>M</code> is total number of characters in <code>products</code> For each <code>prefix</code> we find its representative node in <span class="math inline">\(O(\text{len(prefix)})\)</span> and dfs to find at most 3 words which is an <code>O(1)</code> operation. Thus the overall complexity is dominated by the time required to build the <code>trie</code>.</p>
<ul>
<li>In Java there is an additional complexity of <span class="math inline">\(O(m^2)\)</span> due to Strings being immutable, here <code>m</code> is the length of <code>searchWord</code>.</li>
</ul>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(26n)=O(n)\)</span>. Here <code>n</code> is the number of nodes in the <code>trie</code>. <code>26</code> is the alphabet size.<br />
Space required for output is <span class="math inline">\(O(m)\)</span> where <code>m</code> is the length of the search word.</p>
</li>
</ul>
</br></div>
				</div>
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/short-encoding-of-words/description" target="_blank" rel="noopener noreferrer">Short Encoding of Words</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>valid encoding</strong> of an array of <code>words</code> is any reference string <code>s</code> and array of indices <code>indices</code> such that:</p>

<ul>
	<li><code>words.length == indices.length</code></li>
	<li>The reference string <code>s</code> ends with the <code>&#39;#&#39;</code> character.</li>
	<li>For each index <code>indices[i]</code>, the <strong>substring</strong> of <code>s</code> starting from <code>indices[i]</code> and up to (but not including) the next <code>&#39;#&#39;</code> character is equal to <code>words[i]</code>.</li>
</ul>

<p>Given an array of <code>words</code>, return <em>the <strong>length of the shortest reference string</strong> </em><code>s</code><em> possible of any <strong>valid encoding</strong> of </em><code>words</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]
<strong>Output:</strong> 10
<strong>Explanation:</strong> A valid encoding would be s = <code>&quot;time#bell#&quot; and indices = [0, 2, 5</code>].
words[0] = &quot;time&quot;, the substring of s starting from indices[0] = 0 to the next &#39;#&#39; is underlined in &quot;<u>time</u>#bell#&quot;
words[1] = &quot;me&quot;, the substring of s starting from indices[1] = 2 to the next &#39;#&#39; is underlined in &quot;ti<u>me</u>#bell#&quot;
words[2] = &quot;bell&quot;, the substring of s starting from indices[2] = 5 to the next &#39;#&#39; is underlined in &quot;time#<u>bell</u>#&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;t&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> A valid encoding would be s = &quot;t#&quot; and indices = [0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 2000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
	<li><code>words[i]</code> consists of only lowercase letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-store-prefixes-accepted">Approach #1: Store Prefixes [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>First, let's remove the duplicate strings since it is not optimal to include two or more of the same string in the final answer. We can do this with a set.</p>
<p>Next, let's handle the suffix relationship.</p>
<p>In this article, a &quot;proper suffix&quot; will refer to a suffix that is not an empty string and not equal to the string itself.</p>
<p>An observation is that if the word <code>X</code> is a proper suffix of <code>Y</code>, then it does not need to be considered, as the encoding of <code>Y</code> in the reference string will also encode <code>X</code>.  For example, if <code>&quot;me&quot;</code> and <code>&quot;time&quot;</code> are in <code>words</code>, we can discard <code>&quot;me&quot;</code> without changing the answer.</p>
<p>If a word <code>Y</code> does not have any other word <code>X</code> (in the list of <code>words</code>) that is a proper suffix of <code>Y</code>, then <code>Y</code> must be part of the reference string.</p>
<p>Thus, the goal is to remove words from the list such that no word is a proper suffix of another.  The final answer would be <code>sum(word.length + 1 for word in words)</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Since a word has at most 6 proper suffixes (as <code>words[i].length &lt;= 7</code>), let's iterate over all of them.  For each proper suffix, we'll try to remove it from our <code>words</code> list.  For efficiency, we'll make <code>words</code> a set.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/Z8Dj9oFn/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(\sum w_i^2)\)</span>, where <span class="math inline">\(w_i\)</span> is the length of <code>words[i]</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\sum w_i)\)</span>, the space used in storing suffixes.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-trie-accepted">Approach #2: Trie [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>As in <em>Approach #1</em>, the goal is to remove words that are proper suffixes of another word in the list.</p>
<p><strong>Algorithm</strong></p>
<p>To find whether different words have the same suffix, let's put them backwards into a trie (prefix tree).  For example, if we have <code>&quot;time&quot;</code> and <code>&quot;me&quot;</code>, we will put <code>&quot;emit&quot;</code> and <code>&quot;em&quot;</code> into our trie.</p>
<p>After, the leaves of this trie (nodes with no children) represent words that have no proper suffix, and we will count <code>sum(word.length + 1 for word in words)</code>.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/BGN8P3v3/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(\sum w_i)\)</span>, where <span class="math inline">\(w_i\)</span> is the length of <code>words[i]</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\sum w_i)\)</span>, the space used by the trie.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-uncommon-substring-in-an-array/description" target="_blank" rel="noopener noreferrer">Shortest Uncommon Substring in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>arr</code> of size <code>n</code> consisting of <strong>non-empty</strong> strings.</p>

<p>Find a string array <code>answer</code> of size <code>n</code> such that:</p>

<ul>
	<li><code>answer[i]</code> is the <strong>shortest</strong> <span data-keyword="substring">substring</span> of <code>arr[i]</code> that does <strong>not</strong> occur as a substring in any other string in <code>arr</code>. If multiple such substrings exist, <code>answer[i]</code> should be the <span data-keyword="lexicographically-smaller-string">lexicographically smallest</span>. And if no such substring exists, <code>answer[i]</code> should be an empty string.</li>
</ul>

<p>Return <em>the array </em><code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;cab&quot;,&quot;ad&quot;,&quot;bad&quot;,&quot;c&quot;]
<strong>Output:</strong> [&quot;ab&quot;,&quot;&quot;,&quot;ba&quot;,&quot;&quot;]
<strong>Explanation:</strong> We have the following:
- For the string &quot;cab&quot;, the shortest substring that does not occur in any other string is either &quot;ca&quot; or &quot;ab&quot;, we choose the lexicographically smaller substring, which is &quot;ab&quot;.
- For the string &quot;ad&quot;, there is no substring that does not occur in any other string.
- For the string &quot;bad&quot;, the shortest substring that does not occur in any other string is &quot;ba&quot;.
- For the string &quot;c&quot;, there is no substring that does not occur in any other string.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;abc&quot;,&quot;bcd&quot;,&quot;abcd&quot;]
<strong>Output:</strong> [&quot;&quot;,&quot;&quot;,&quot;abcd&quot;]
<strong>Explanation:</strong> We have the following:
- For the string &quot;abc&quot;, there is no substring that does not occur in any other string.
- For the string &quot;bcd&quot;, there is no substring that does not occur in any other string.
- For the string &quot;abcd&quot;, the shortest substring that does not occur in any other string is &quot;abcd&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == arr.length</code></li>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= arr[i].length &lt;= 20</code></li>
	<li><code>arr[i]</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-unique-prefix-for-every-word/1" target="_blank" rel="noopener noreferrer">Shortest Unique prefix for every word</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array of words, find all shortest unique prefixes to represent each word in the given array. Assume that no word is prefix of another.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>N = 4
arr[] = {"zebra", "dog", "duck", "dove"}
<strong>Output: </strong>z dog du dov
<strong>Explanation: </strong>
z =&gt; zebra 
dog =&gt; dog 
duck =&gt; du 
dove =&gt; dov </span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>N = 3
arr[] =  {"geeksgeeks", "geeksquiz",
                       "geeksforgeeks"};
<strong>Output: </strong>geeksg geeksq geeksf
<strong>Explanation: </strong>
geeksgeeks =&gt; geeksg 
geeksquiz =&gt; geeksq 
geeksforgeeks =&gt; geeksf</span></pre>
<div><span style="font-size: 18px;"><strong>Your task:</strong></span></div>
<div><span style="font-size: 18px;">You don't have to read input or print anything. Your task is to complete the function <strong>findPrefixes()</strong> which takes the array of strings and it's size N as input and returns a list of shortest unique prefix for each word </span></div>
<div>&nbsp;</div>
<div><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N*length of each word)</span></div>
<div><span style="font-size: 18px;"><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*length of each word)</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 18px;"><strong>Constraints:</strong></span></div>
<div><span style="font-size: 18px;">1 &le; N, Length of each word &le; 1000</span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stream-of-characters/description" target="_blank" rel="noopener noreferrer">Stream of Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings <code>words</code>.</p>

<p>For example, if <code>words = [&quot;abc&quot;, &quot;xyz&quot;]</code>&nbsp;and the stream added the four characters (one by one) <code>&#39;a&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;y&#39;</code>, and <code>&#39;z&#39;</code>, your algorithm should detect that the suffix <code>&quot;xyz&quot;</code> of the characters <code>&quot;axyz&quot;</code> matches <code>&quot;xyz&quot;</code> from <code>words</code>.</p>

<p>Implement the <code>StreamChecker</code> class:</p>

<ul>
	<li><code>StreamChecker(String[] words)</code> Initializes the object with the strings array <code>words</code>.</li>
	<li><code>boolean query(char letter)</code> Accepts a new character from the stream and returns <code>true</code> if any non-empty suffix from the stream forms a word that is in <code>words</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;StreamChecker&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;]
[[[&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]], [&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;], [&quot;d&quot;], [&quot;e&quot;], [&quot;f&quot;], [&quot;g&quot;], [&quot;h&quot;], [&quot;i&quot;], [&quot;j&quot;], [&quot;k&quot;], [&quot;l&quot;]]
<strong>Output</strong>
[null, false, false, false, true, false, true, false, false, false, false, false, true]

<strong>Explanation</strong>
StreamChecker streamChecker = new StreamChecker([&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]);
streamChecker.query(&quot;a&quot;); // return False
streamChecker.query(&quot;b&quot;); // return False
streamChecker.query(&quot;c&quot;); // return False
streamChecker.query(&quot;d&quot;); // return True, because &#39;cd&#39; is in the wordlist
streamChecker.query(&quot;e&quot;); // return False
streamChecker.query(&quot;f&quot;); // return True, because &#39;f&#39; is in the wordlist
streamChecker.query(&quot;g&quot;); // return False
streamChecker.query(&quot;h&quot;); // return False
streamChecker.query(&quot;i&quot;); // return False
streamChecker.query(&quot;j&quot;); // return False
streamChecker.query(&quot;k&quot;); // return False
streamChecker.query(&quot;l&quot;); // return True, because &#39;kl&#39; is in the wordlist
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 2000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 200</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li><code>letter</code> is a lowercase English letter.</li>
	<li>At most <code>4 * 10<sup>4</sup></code> calls will be made to query.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-prefix-scores-of-strings/description" target="_blank" rel="noopener noreferrer">Sum of Prefix Scores of Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>words</code> of size <code>n</code> consisting of <strong>non-empty</strong> strings.</p>

<p>We define the <strong>score</strong> of a string <code>term</code> as the <strong>number</strong> of strings <code>words[i]</code> such that <code>term</code> is a <strong>prefix</strong> of <code>words[i]</code>.</p>

<ul>
	<li>For example, if <code>words = [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;cab&quot;]</code>, then the score of <code>&quot;ab&quot;</code> is <code>2</code>, since <code>&quot;ab&quot;</code> is a prefix of both <code>&quot;ab&quot;</code> and <code>&quot;abc&quot;</code>.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the <strong>sum</strong> of scores of every <strong>non-empty</strong> prefix of </em><code>words[i]</code>.</p>

<p><strong>Note</strong> that a string is considered as a prefix of itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abc&quot;,&quot;ab&quot;,&quot;bc&quot;,&quot;b&quot;]
<strong>Output:</strong> [5,4,3,2]
<strong>Explanation:</strong> The answer for each string is the following:
- &quot;abc&quot; has 3 prefixes: &quot;a&quot;, &quot;ab&quot;, and &quot;abc&quot;.
- There are 2 strings with the prefix &quot;a&quot;, 2 strings with the prefix &quot;ab&quot;, and 1 string with the prefix &quot;abc&quot;.
The total is answer[0] = 2 + 2 + 1 = 5.
- &quot;ab&quot; has 2 prefixes: &quot;a&quot; and &quot;ab&quot;.
- There are 2 strings with the prefix &quot;a&quot;, and 2 strings with the prefix &quot;ab&quot;.
The total is answer[1] = 2 + 2 = 4.
- &quot;bc&quot; has 2 prefixes: &quot;b&quot; and &quot;bc&quot;.
- There are 2 strings with the prefix &quot;b&quot;, and 1 string with the prefix &quot;bc&quot;.
The total is answer[2] = 2 + 1 = 3.
- &quot;b&quot; has 1 prefix: &quot;b&quot;.
- There are 2 strings with the prefix &quot;b&quot;.
The total is answer[3] = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abcd&quot;]
<strong>Output:</strong> [4]
<strong>Explanation:</strong>
&quot;abcd&quot; has 4 prefixes: &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, and &quot;abcd&quot;.
Each prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-tries">Approach: Tries</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given an array of strings called <code>words</code>. Our task is to find the score for each string, where the score is defined as the number of times a string appears as a prefix for all strings in <code>words</code>. We need to return an array where each element is the total score of the corresponding string in <code>words</code>.</p>
<p>One way to approach this is by using a hashmap to store the frequency of each prefix. We would count how often each prefix appears and then sum these counts for each string. However, this method can be improved with a trie data structure.</p>
<p>A trie, or prefix tree, helps in searching for prefixes efficiently. If you are not familiar with tries, it would be useful to review an introduction to tries, such as the one in the <a href="https://leetcode.com/problems/implement-trie-prefix-tree/solution">Implement trie prefix tree</a>. For now, we'll assume you have a basic understanding of tries.</p>
<p>A trie is a tree where each node represents a character. The path from the root to a leaf node forms a complete word. This structure is effective for problems involving prefix matching because all descendants of a node share the same prefix. This aligns with our goal of counting matching prefixes.</p>
<p>To implement this, we start by building a trie and inserting each prefix of every string into the trie, character by character. We will keep track of how many times each prefix appears.</p>
<p><img src="../Figures/2416/Slide2.png" alt="fig" /></p>
<p>We need to find the total of all these counts for all prefixes of every string in <code>words</code>. Therefore, we can iterate through the <code>words</code> array, iterate through the prefixes of all strings, appending one character at a time, and calculate the running sum for the count value of these prefixes. Store these running sum values in an array and return it as the answer. Checkout the example below to understand the counting process:</p>
<p><img src="../Figures/2416/Slide1.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<p><code>TrieNode Structure</code></p>
<ul>
<li>Each <code>TrieNode</code> has two properties:
<ul>
<li><code>next</code>: An array of size 26 (for lowercase English letters) to store pointers to child nodes.</li>
<li><code>cnt</code>: An integer value initialized to <code>0</code> to store the count of words that pass through the node.</li>
</ul>
</li>
<li>The constructor initializes all elements in the <code>next</code> array to <code>null</code> and <code>cnt</code> to <code>0</code>.</li>
</ul>
<p><code>Insert(string word)</code></p>
<ul>
<li>Starts from the <code>root</code> node.</li>
<li>For each character <code>c</code> in the word:
<ul>
<li>Calculate the index corresponding to the character (<code>c - 'a'</code>).</li>
<li>If the child node at the calculated index doesn't exist, create a new <code>TrieNode</code> and assign it to that index.</li>
<li>Increment the count (<code>cnt</code>) for the child node.</li>
<li>Move to the child node.</li>
</ul>
</li>
</ul>
<p><code>Count(string s)</code></p>
<ul>
<li>Starts iterating from the <code>root</code> node.</li>
<li>Initialize an integer <code>ans</code> to store the sum of prefix counts.</li>
<li>For each character <code>c</code> in the string <code>s</code>:
<ul>
<li>Calculate the index corresponding to the character (<code>c - 'a'</code>).</li>
<li>Add the <code>cnt</code> value of the child node at the calculated index to <code>ans</code>.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
<p><code>Main function - sumPrefixScores(words)</code></p>
<ul>
<li>For each <code>word</code> in <code>words</code>:
<ul>
<li>Call <code>Insert(word)</code>.</li>
</ul>
</li>
<li>Initialize an array <code>scores</code> of size equal to the number of words, with all elements set to <code>0</code>.</li>
<li>For each <code>word</code> in <code>words</code>:
<ul>
<li>Store <code>Count(word)</code> in <code>scores[i]</code>.</li>
</ul>
</li>
<li>Return the <code>scores</code> array.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/25cczCT5/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>words</code> array, and <span class="math inline">\(M\)</span> be the average length of the strings in <code>words</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot M)\)</span></p>
<p>The insert operation takes <span class="math inline">\(O(length)\)</span> time for a string of size <code>length</code>. The total time taken to perform the insert operations on the strings of the <code>words</code> array is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>Similarly, the count operation takes <span class="math inline">\(O(length)\)</span> time for a string of size <code>length</code>. The total time taken to perform the count operations on the strings of the <code>words</code> array is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot M)\)</span></p>
<p>The insert operation takes <span class="math inline">\(O(length)\)</span> space for a string of size <code>length</code>. The total space taken to perform the insert operations on the strings of the <code>words</code> array is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>The count operation does not use any additional space. Therefore, the total time complexity is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/top-k-frequent-words/description" target="_blank" rel="noopener noreferrer">Top K Frequent Words</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bucket sort</span> <span class="topic-badge">counting</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p>

<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2
<strong>Output:</strong> [&quot;i&quot;,&quot;love&quot;]
<strong>Explanation:</strong> &quot;i&quot; and &quot;love&quot; are the two most frequent words.
Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4
<strong>Output:</strong> [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;]
<strong>Explanation:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 500</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li><code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/trie-delete/1" target="_blank" rel="noopener noreferrer">Trie | (Delete)</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">design-pattern</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Trie is an efficient information retrieval data structure. This data structure is used to store Strings and search strings, String stored can also be deleted. Given a Trie <strong>root</strong> for a larger string <strong>super&nbsp;</strong>and a string <strong>key, </strong>delete all the occurences of <strong>key&nbsp;</strong>in the Trie.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 8
super = &quot;the a there answer any by bye their&quot; 
key = &quot;the&quot; </span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong></span></p>

<p><span style="font-size:18px">Complete the function <strong>deleteKey()</strong> to delete the given string <strong>key</strong>.The String <strong>key</strong>&nbsp;if exists&nbsp;in the larger string <strong>super</strong>,&nbsp;must be deleted from Trie <strong>root</strong>. The larger string <strong>super</strong>&nbsp;contains space separated small strings.&nbsp;And if the string is deleted successfully than 1 will be printed.<br />
If any other string other than String A is deleted, you will get wrong answer.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1&le; T &le;200<br />
1&le; N, |A| &le;20</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/unique-rows-in-boolean-matrix/1" target="_blank" rel="noopener noreferrer">Unique rows in boolean matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">set</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary matrix your task is to find all unique rows of the given matrix in the order of their appearance in the matrix. </span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>row = 3, col = 4 
M[][] = {{1 1 0 1},{1 0 0 1},{1 1 0 1}}
<strong>Output: </strong>$1 1 0 1 $1 0 0 1 $<strong>
Explanation: </strong>Above the matrix of size 3x4
looks like
1 1 0 1
1 0 0 1
1 1 0 1
The two unique rows are R<sub>1</sub>: {1 1 0 1} and R<sub>2</sub>: {1 0 0 1}. <br />As R<sub>1 </sub>first appeared at row-0 and R<sub>2</sub> appeared at row-1, in the resulting list, R<sub>1</sub> is kept before R<sub>2</sub>.</span></pre>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: medium; white-space: normal;"><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><strong>Input:
</strong>row = 2, col = 4 
M[][] = {{0 0 0 1}, {0 0 0 1}}
<strong>Output: $</strong>0 0 0 1 $<strong>
Explanation: </strong>Above the matrix of size 2x4
looks like
0 0 0 1
0 0 0 1
Only unique row is $0 0 0 1 $</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You only need to implement the given function&nbsp;<strong>uniqueRow()</strong>.&nbsp;The function takes three arguments the first argument is a matrix <strong>M</strong> and the next two arguments are <strong>row</strong>&nbsp;and <strong>col</strong>&nbsp;denoting the rows and columns&nbsp;of the matrix.&nbsp;The function should <strong>return</strong> the list of the unique row of the matrix. Do not read input, instead use the arguments given in the function.</span></p>
<p><span style="font-size: 18px;"><strong>Note:&nbsp;</strong>The driver code prints the rows "$" separated. You have to just return list of rows, you do not have to worry about printing anything.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(row * col)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(row * col)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=row,col&lt;=40<br />0&lt;=M[][]&lt;=1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-boggle4143/1" target="_blank" rel="noopener noreferrer">Word Boggle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">recursion</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a dictionary of distinct <strong>words</strong> and an <strong>M x N</strong> board where every cell has one character. Find all possible words from the dictionary that can be formed by a sequence of adjacent characters on the board. We can move to any of 8 adjacent characters</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;While forming a word we can move to&nbsp;any of the 8 adjacent cells. A&nbsp;cell can be used&nbsp;only once in one word.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>N = 1
dictionary = {"CAT"}
R = 3, C = 3
board = {{C,A,P},{A,N,D},{T,I,E}}
<strong>Output:</strong>
CAT
<strong>Explanation</strong>: 
<span style="color: #800080;">C</span> A P
<span style="color: #800080;">A</span> N D
<span style="color: #800080;">T</span> I E
Words we got is denoted using same color.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 4
dictionary = {"GEEKS","FOR","QUIZ","GO"}
R = 3, C = 3 
board = {{G,I,Z},{U,E,K},{Q,S,E}}
<strong>Output:</strong>
GEEKS QUIZ
<strong>Explanation</strong>: 
<span style="color: #ff8c00;">G</span> <span style="color: #0000cd;">I</span> <span style="color: #0000cd;">Z</span>
<span style="color: #0000cd;">U</span> <span style="color: #ff8c00;">E</span> <span style="color: #ff8c00;">K</span>
<span style="color: #0000cd;">Q</span> <span style="color: #ff8c00;">S</span> <span style="color: #ff8c00;">E</span> 
Words we got is denoted using same color.</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your task:</strong><br />You dont need to read input or print anything. Your task is to complete the function&nbsp;<strong>wordBoggle()</strong>&nbsp;which takes the dictionary contaning N&nbsp;space-separated strings and R*C board </span><span style="font-size: 18px;">as input parameters and returns a list of&nbsp;words that exist on the board in <strong>lexicographical order</strong>.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(N*W + R*C^2)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*W + R*C)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N&nbsp;&le; 15<br />1 &le; R, C&nbsp;&le; 50<br />1 &le; length of Word&nbsp;&le; 60<br />Each word can consist of both lowercase and uppercase letters.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-break/description" target="_blank" rel="noopener noreferrer">Word Break</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>

<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.
Note that you are allowed to reuse a dictionary word.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 300</code></li>
	<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
	<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
	<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>
	<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth-First Search</h3>
<p><strong>Intuition</strong></p>
<p>Let's imagine the indices of <code>s</code> as a graph. Each index can be thought of as a node, which represents building <code>s</code> up to the index.</p>
<p>Adding a word to an existing string is like an edge between nodes. For a node <code>start</code>, we can move to node <code>end</code> if the substring of <code>s</code> between <code>start, end</code> exists in <code>wordDict</code>.</p>
<p>For example, let's say we have <code>s = &quot;leetcode&quot;</code> and <code>wordDict = [&quot;leet&quot;, &quot;code&quot;]</code>. We are currently at node <code>4</code>, which implies that we have built <code>&quot;leet&quot;</code> (the first 4 characters of <code>s</code>). We can move to node <code>8</code>, because the substring of <code>s</code> with indices <code>[4, 8)</code> is <code>&quot;code&quot;</code>, which is in <code>wordDict</code>.</p>
<p>We start at node <code>0</code>, which represents the empty string. We want to reach node <code>s.length</code>, which implies that we have built the entire string. We can run a BFS to accomplish this traversal. If you're not familiar with BFS, check out the relevant <a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/">Explore Card</a>.</p>
<p>At each node <code>start</code>, we iterate over all the nodes <code>end</code> that come after <code>start</code>. For each <code>end</code>, we check if the substring between <code>start, end</code> is in <code>wordDict</code>. If it is, we can add <code>end</code> to the queue.</p>
<p>We will first convert <code>wordDict</code> into a set so that we can perform the checks in constant time. We will also use a data structure <code>seen</code> to prevent us from visiting a node more than once.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Convert <code>wordDict</code> into a set <code>words</code>.</li>
<li>Initialize a <code>queue</code> with <code>0</code> and a set <code>seen</code>.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Remove the first element, <code>start</code>.</li>
<li>If <code>start == s.length</code>, return <code>true</code>.</li>
<li>Iterate <code>end</code> from <code>start + 1</code> up to and including <code>s.length</code>. For each <code>end</code>, if <code>end</code> has not been visited yet,
<ul>
<li>Check the substring starting at <code>start</code> and ending before <code>end</code>. If it is in <code>words</code>, add <code>end</code> to the queue and mark it in <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>false</code> if the BFS finishes without reaching the final node.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/evkSf6sx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>, <span class="math inline">\(m\)</span> as the length of <code>wordDict</code>, and <span class="math inline">\(k\)</span> as the average length of the words in <code>wordDict</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3 + m \cdot k)\)</span></p>
<p>There are <span class="math inline">\(O(n)\)</span> nodes. Because of <code>seen</code>, we never visit a node more than once. At each node, we iterate over the nodes in front of the current node, of which there are <span class="math inline">\(O(n)\)</span>. For each node <code>end</code>, we create a substring, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, handling a node costs <span class="math inline">\(O(n^2)\)</span>, so the BFS could cost up to <span class="math inline">\(O(n^3)\)</span>. Finally, we also spent <span class="math inline">\(O(m \cdot k)\)</span> to create the set <code>words</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m \cdot k)\)</span></p>
<p>We use <span class="math inline">\(O(n)\)</span> space for <code>queue</code> and <code>seen</code>. We use <span class="math inline">\(O(m \cdot k)\)</span> space for the set <code>words</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-top-down-dynamic-programming">Approach 2: Top-Down Dynamic Programming</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you're not familiar with dynamic programming, we recommend checking out the <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming explore card</a>. This problem is on the difficult side, so we will assume that readers are already familiar with the principles of DP.</p>
</blockquote>
<p>Let's have a function <code>dp</code> that returns a boolean indicating if it is possible to build <code>s</code> up to and including the index <code>i</code>.</p>
<p>For example, given <code>s = &quot;leetcode&quot;</code> and <code>wordDict = [&quot;leet&quot;, &quot;code&quot;]</code>, <code>dp(3)</code> would return <code>true</code>. <code>s</code> up to index <code>3</code> is <code>&quot;leet&quot;</code>, and we can build <code>&quot;leet&quot;</code> using the words in <code>wordDict</code>. The answer to the problem would be <code>dp(s.length - 1)</code>, which represents if we can build <code>s</code>.</p>
<p>The base case of this function is when <code>i &lt; 0</code>. This would represent an empty string, and we can always build an empty string by doing nothing. Therefore, <code>dp(i) = true</code> for <code>i &lt; 0</code>.</p>
<p>Given an index <code>i</code>, we need a recurrence relation to determine if <code>dp(i)</code> is <code>true</code> or <code>false</code>. For <code>dp(i)</code> to be <code>true</code>, there are two requirements:</p>
<ol>
<li>First, there needs to be a <code>word</code> from <code>wordDict</code> that <strong>ends</strong> at index <code>i</code>. Given a <code>word</code>, the substring of <code>s</code> from indices <code>i - word.length + 1</code> up to and including <code>i</code> should match <code>word</code>. We can check every <code>word</code> for this.</li>
<li>If we manage to find a <code>word</code> that <strong>ends</strong> at index <code>i</code>, we would need to add it on top of another string (since we are building <code>s</code> by joining words together one by one). We need to make sure that the string we are adding onto is also buildable. If we find a <code>word</code> that passes the first check, it means <code>word</code> would start at index <code>i - word.length + 1</code>. The index before that is <code>i - word.length</code>. To check if the string ending at that index is buildable, we can refer to <code>dp(i - word.length)</code>.</li>
</ol>
<p>This gives us our recurrence relation:</p>
<p><span class="math display">\[
That is, there exists any `word` that satisfies both of the listed conditions.

We can implement a recursive function `dp(i)` that implements the base cases and recurrence. We need to use memoization to avoid repeated computation.

!?!../Documents/139.json:960,540!?!

**Algorithm**

1. Declare a data structure `memo` that stores the values of `dp` for each index.
2. Create a function `dp(i)`:
    - If `i < 0`, return `true`.
    - If we already calculated `i`, return the value stored in `memo`.
    - Iterate over `wordDict`. For each `word`:
        - Check the substring of `s` ending at `i` with the same length as `word`. If the substring matches, and `dp(i - word.length)` is `true`, return `true`.
    - If no `word` satisfying the criteria was found, return `false`.
3. Return `dp(s.length - 1)`.

**Implementation**

> In Python, the <a href="https://docs.python.org/3/library/functools.html" target="_blank" rel="noopener noreferrer">functools</a> module provides super handy tools that automatically memoize a function for us. We're going to use the `@cache` decorator in the Python implementation.
>
> In Java and C++, we will use an array `memo` to save values. `memo[i] = -1` if we haven't calculated yet, `memo[i] = 0` if `dp(i) = false`, and `memo[i] = 1` if `dp(i) = true`.

[code](https://leetcode.com/playground/4pvUY8Eg/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n \cdot m \cdot k)$$

    There are $$n$$ states of `dp(i)`. Because of memoization, we only calculate each state once. To calculate a state, we iterate over $$m$$ words, and for each word perform some substring operations which costs $$O(k)$$. Therefore, calculating a state costs $$O(m \cdot k)$$, and we need to calculate $$O(n)$$ states. 

* Space complexity: $$O(n)$$

    The data structure we use for memoization and the recursion call stack can use up to $$O(n)$$ space.
    
<br/>

---

### Approach 3: Bottom-Up Dynamic Programming

**Intuition**

The same algorithm can be implemented iteratively. Instead of using a function `dp(i)`, we will use an array `dp` where `dp[i]` represents the same thing that `dp(i)` did. We can use the same recurrence relation:

$$\large{\text{dp[i]} = \text{any}(\text{s}[\text{i - word.length + 1, i}] == \text{word \&\& dp[i - \text{word.length}]})}$$

In top-down, we started at the top (`s.length - 1`) and work our way down to the base cases. In bottom-up, we start at the bottom `(i = 0)` and work our way up to the top.

Before we check `dp[i - word.length]`, we should check if `i == word.length - 1`. This would mean that the current `word` we are placing to end at index `i` is the first word. `i - word.length` would be negative, so we need to separately check this case.

**Algorithm**

1. Initialize an array `dp` with the same length as `s` and all values initially set to `false`.
2. Iterate `i` over the indices of `s`. At each `i`:
    - Iterate over each `word` in `wordDict`:
        - Check if `i == word.length - 1` or `dp[i - word.length] = true`.
        - If so, and the substring of `s` ending at `i` with the same length as `word` matches, set `dp[i] = true` and `break`.
3. Return `dp[s.length - 1]`.

**Implementation**

[code](https://leetcode.com/playground/EWiwhkJC/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n \cdot m \cdot k)$$

    The logic behind the time complexity is identical to the previous approach. It costs us $$O(m \cdot k)$$ to calculate each state, and we calculate $$O(n)$$ states in total. 

* Space complexity: $$O(n)$$

    We use an array `dp` of length $$n$$.
    
<br/>

---

### Approach 4: Trie Optimization 

**Intuition**

In the previous approach, we iterated over each state `i` and then calculated `dp[i]`. To calculate a given `dp[i]`, we did the following:

- Iterate over every `word` in `wordDict`
- Check if each `word` ended at the current index

This cost us $$O(m \cdot k)$$. In the problem constraints, we can see that the maximum value of $$m \cdot k$$ is `20,000`, so this is expensive. We can optimize the time it takes to calculate a given `dp[i]` by using a trie.

A trie is a data structure that can be used to efficiently search for strings. If you are not familiar with tries, we highly recommend you read the official solution to [this problem](https://leetcode.com/problems/implement-trie-prefix-tree/solution) before proceeding with this approach.

To summarize, a trie is a tree where each node is labeled. Here, we label each node with a character. The path from the root to any node represents the string that is built by the nodes on the path. The root represents the empty string.

<img src="../Figures/139/4.png" width="960"> <br>

We can start by building a trie from the words in `wordDict`. Each trie node will have an additional attribute `isWord` which indicates if the current node represents a word from `wordDict`. Then, we will calculate the same `dp` array as in the previous approach. We will calculate each state as follows:

- First, check if `i == 0` (placing first word) or `dp[i - 1]` (we could build the string up to this point). If neither are true, move on to the next state `i + 1`.
- Otherwise, we see if `dp[i]` can be `true`. Initialize a node `curr` at the `root` of the trie.
- Start iterating with a variable `j` from index `i`. For each character `s[j]`, check if we can traverse the trie.
- If we can't traverse the trie, it means no words exist starting at index `i` and ending at index `j` or beyond. We can break from the loop and move on to the next state `i + 1`.
- If we can traverse the trie, we move to the child node. We check the child's `isWord` attribute. If it is `true`, it means there is a word in `wordDict` starting at index `i` and ending at index `j`. We set `dp[j] = true`.
- We continue traversing the trie until we reach a dead end or `j` reaches the end of the string.

This allows us to handle each state in $$O(n)$$ instead of $$O(m \cdot k)$$, which is a big improvement since $$n \leq 300$$.

**Algorithm**

1. Build a trie from `wordDict`. Each node should also have an `isWord` attribute. Store the root of the trie in `root`.
2. Initialize an array `dp` with the same length as `s` and all values initially set to `false`.
3. Iterate `i` over the indices of `s`. At each `i`:
    - Check if `i == 0` or `dp[i - 1] = true`. If not, continue to the next `i`.
    - Set `curr = root`. Iterate `j` over the indices of `s`, starting from `i`. At each `j`,
        - Get the character at index `j` as `c = s[j]`.
        - If `c` is not in the children of `curr`, we can `break` from the loop.
        - Otherwise, move `curr` to the child labeled `c`.
        - If `curr.isWord`, set `dp[j] = true`.
4. Return `dp[s.length - 1]`.

**Implementation**

[code](https://leetcode.com/playground/FhHxmwHE/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n^2 + m \cdot k)$$

    Building the trie involves iterating over all characters of all words. This costs $$O(m \cdot k)$$.

    Once we build the trie, we calculate `dp`. For each `i`, we iterate over all the indices after `i`. We have a basic nested for loop which costs $$O(n^2)$$ to handle all `dp[i]`.

* Space complexity: $$O(n + m \cdot k)$$

    The `dp` array takes $$O(n)$$ space. The trie can have up to $$m \cdot k$$ nodes in it.
    
<br/>

---

### Approach 5: A Different DP

**Intuition**

> In this approach, we will take a look at another way to implement the DP algorithm. Note that this approach is the one covered in the video.

Here, we let `dp[i]` hold the answer to the question: "is it possible to form `s` up to a length of `i`? To find the answer for each index, instead of iterating over the words in `wordDict` and checking if a `word` ends at the current index `i`, we will instead iterate over **all substrings that end before index `i`**. If we find one of these substrings is in `wordDict` **and** we can form the string prior to the substring, then `dp[i] = true`.

The reason we are checking for **before** index `i` is because we have slightly changed our `dp` definition here. In the previous problem, `i` represented the index of the last character. Here, `i` represents the length, so we are offset by one.

Before starting the DP, we first convert `wordsDict` to a set so that we can perform the checks in $O(1)$. The rest of the algorithm follows similarly to the previous approaches.

**Algorithm**

1. Convert `wordsDict` to a set `words`.
2. Initialize an array `dp` of length `n + 1` with all values set to `false`.
3. Iterate `i` from `1` until and including `n`. Here, `i` represents the length of the string starting from the beginning.
    - Iterate `j` from `0` until `i`. Here, `j` represents the first index of the substring we are checking.
    - If `dp[j]` is true AND the substring `s[j:i]` is in `words`, set `dp[i] = true` and break. Note that `s[j:i]` represents the substring starting at `j` and ending at `i - 1`.
4. Return `dp[n]`.

**Implementation**

[code](https://leetcode.com/playground/eiTDAMA4/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n^3 + m \cdot k)$$

    First, we spend $$O(m \cdot k)$$ to convert `wordDict` into a set. Then we have a nested loop over `n`, which iterates $$O(n^2)$$ times. For each iteration, we have a substring operation which could cost up to $$O(n)$$. Thus this nested loop costs $$O(n^3)$$.

* Space complexity: $$O(n + m \cdot k)$$

    The `dp` array takes $$O(n)$$ space. The set `words` takes up $$O(m \cdot k)$$ space.
    
<br/>

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-break-ii/description" target="_blank" rel="noopener noreferrer">Word Break II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>

<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]
<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]
<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]
<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 20</code></li>
	<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
	<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>
	<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>
	<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>
	<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have a string <code>s</code> and a dictionary of strings <code>wordDict</code>. The task is to add spaces in <code>s</code> to construct valid sentences where each word is present in <code>wordDict</code> and return all possible valid sentences. The same word from the dictionary can be reused multiple times.</p>
<p>This problem is an extension of <a href="https://leetcode.com/problems/word-break/description/">Problem 139. Word Break I</a>, where the goal was to determine if a word could be segmented into other words from a given dictionary. In this problem, however, we need to find all possible ways to split the word into valid statements. To understand this problem, it is beneficial to be familiar with <a href="https://leetcode.com/problems/word-break/description/">Problem 139. Word Break I</a> as well as <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Problem 208. Implement Trie Prefix Tree</a>, as those questions provide the foundational concepts and intuition necessary for solving this problem.</p>
<p>Here, we will focus on the applications of recursion, dynamic programming, and tries, rather than on understanding their underlying mechanisms.</p>
<p>To gain an understanding of their underlying mechanisms, we suggest you check out these explore cards:</p>
<ol>
<li><a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">Backtracking Explore Card</a>.</li>
<li><a href="https://leetcode.com/explore/learn/card/dynamic-programming/">Dynamic Programming Explore Card</a>.</li>
<li><a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card</a>.</li>
</ol>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>Initially, we might think of a brute-force approach where we systematically explore all possible ways to break the string into words from the dictionary. This leads us to the backtracking strategy, where we recursively try to form words from the string and add them to a current sentence if they are in the dictionary. If the current prefix doesn't lead to a valid solution, we backtrack by removing the last added word and trying the next possible word. This ensures we explore all possible segmentations of the string.</p>
<p>At each step, we consider all possible end indices for substrings starting from the current index. For each substring, we check if it exists in the dictionary. If the substring is a valid word, we append it to the current sentence and recursively call the function with the updated index, which is the end index of the substring plus one.</p>
<p>If we reach the end of the string, it means we have found a valid segmentation, and we can add the current sentence to the results. However, if we encounter a substring that is not a valid word, we backtrack by returning from that recursive call and trying the next possible end index.</p>
<p>The backtracking approach will be inefficient due to the large number of recursive calls, especially for longer strings. To increase efficiency, we will convert the word dictionary into a set for constant-time lookups. However, the overall time complexity remains high because we explore all possible partitions.</p>
<p>The process is visualized below:</p>
<p><img src="../Figures/140/backtrack.png" alt="backtrack" /></p>
<h4 id="algorithm">Algorithm</h4>
<p><strong><code>wordBreak</code> Function:</strong></p>
<ul>
<li>Convert the <code>wordDict</code> array into an unordered set <code>wordSet</code> for efficient lookups.</li>
<li>Initialize an empty array <code>results</code> to store valid sentences.</li>
<li>Initialize an empty string <code>currentSentence</code> to keep track of the sentence being constructed.</li>
<li>Call the <code>backtrack</code> function with the input string <code>s</code>, <code>wordSet</code>, <code>currentSentence</code>, <code>results</code>, and a starting index set to 0, the beginning of the input string.</li>
<li>Return <code>results</code>.</li>
</ul>
<p><strong><code>backtrack</code> Function:</strong></p>
<ul>
<li>Base Case: If the <code>startIndex</code> is equal to the length of the string, add the <code>currentSentence</code> to <code>results</code> and return as it means that <code>currentSentence</code> represents a valid sentence.</li>
<li>Iterate over possible <code>endIndex</code> values from <code>startIndex + 1</code> to the end of the string.
<ul>
<li>Extract the substring <code>word</code> from <code>startIndex</code> to <code>endIndex - 1</code>.</li>
<li>If <code>word</code> is found in <code>wordSet</code>:
<ul>
<li>Store the current <code>currentSentence</code> in <code>originalSentence</code>.</li>
<li>Append <code>word</code> to <code>currentSentence</code> (with a space if needed).</li>
<li>Recursively call <code>backtrack</code> with the updated <code>currentSentence</code> and <code>endIndex</code>.</li>
<li>Reset <code>currentSentence</code> to its original value (<code>originalSentence</code>) to backtrack and try the next <code>endIndex</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return from the <code>backtrack</code> function.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/izdRa3p9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The algorithm explores all possible ways to break the string into words. In the worst case, where each character can be treated as a word, the recursion tree has <span class="math inline">\(2^n\)</span> leaf nodes, resulting in an exponential time complexity. For each leaf node, <span class="math inline">\(O(n)\)</span> work is performed, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2^n)\)</span></p>
<p>The recursion stack can grow up to a depth of <span class="math inline">\(n\)</span>, where each recursive call consumes additional space for storing the current state.</p>
<p>Since each position in the string can be a split point or not, and for <span class="math inline">\(n\)</span> positions, there are <span class="math inline">\(2^n\)</span> possible combinations of splits. Thus, in the worst case, each combination generates a different sentence that needs to be stored, leading to exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming---memoization">Approach 2: Dynamic Programming - Memoization</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them.</p>
<p>We use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a dictionary or hash table).</p>
<p>If the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them.</p>
<p>By memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong><code>wordBreak</code> Function:</strong></p>
<ul>
<li>Convert the <code>wordDict</code> array into an unordered set <code>wordSet</code> for efficient lookups.</li>
<li>Initialize an empty unordered map <code>memoization</code> to store the results of subproblems.</li>
<li>Call the <code>dfs</code> function with the input string <code>s</code>, <code>wordSet</code>, and <code>memoization</code>.</li>
</ul>
<p><strong><code>dfs</code> Function:</strong></p>
<ul>
<li>Check if the answer for the current <code>remainingStr</code>(the remaining part of the string to be processed) are already in <code>memoization</code>. If so, return them.</li>
<li>Base Case: If <code>remainingStr</code> is empty, it means that all characters have been processed. An empty string represents a valid sentence so return an array containing the empty string.</li>
<li>Initialize an empty array <code>results</code>.</li>
<li>Iterate from 1 to the length of <code>remainingStr</code>:
<ul>
<li>Extract the substring <code>currentWord</code> from 0 to <code>i</code> to check if it is a valid word.</li>
<li>If <code>currentWord</code> is found in <code>wordSet</code>:
<ul>
<li>Recursively call <code>dfs</code> with <code>remainingStr.substr(i)</code>, <code>wordSet</code>, and <code>memoization</code>.</li>
<li>Append <code>currentWord</code> and the recursive results to <code>results</code>(with a space if needed) to form valid sentences.</li>
</ul>
</li>
</ul>
</li>
<li>Store the <code>results</code> for <code>remainingStr</code> in <code>memoization</code>.</li>
<li>Return <code>results</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ri3aMwXd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>While memoization avoids redundant computations, it does not change the overall number of subproblems that need to be solved. In the worst case, there are still unique <span class="math inline">\(2^n\)</span> possible substrings that need to be explored, leading to an exponential time complexity. For each subproblem, <span class="math inline">\(O(n)\)</span> work is performed, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The recursion stack can grow up to a depth of <span class="math inline">\(n\)</span>, where each recursive call consumes additional space for storing the current state.</p>
<p>The memoization map needs to store the results for all possible substrings, which can be up to <span class="math inline">\(2^n\)</span> substrings of size <span class="math inline">\(n\)</span> in the worst case, resulting in an exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming---tabulation">Approach 3: Dynamic Programming - Tabulation</h3>
<h4 id="intuition-2">Intuition</h4>
<p>While memoization improves the backtracking approach, we might consider an alternative approach using dynamic programming principles. This leads us to the tabulation method, which builds a table (or map) of valid sentences for each starting index in the string.</p>
<p>The tabulation approach is often more efficient than backtracking and memoization in terms of time and space complexity because it avoids the overhead of recursive calls and stack usage. It also eliminates the need for a separate memoization map, as the table itself serves as the storage for the subproblem solutions.</p>
<p>The tabulation approach works in a bottom-up manner, iterating from the end of the string towards the beginning. At each step, we construct all possible sentences that can be formed starting from the current index by checking if substrings form valid words in the dictionary.</p>
<p>If a valid word is found, we combine it with the valid sentences formed from the remaining substring. This process continues until we reach the beginning of the string, building up the table of valid sentences for each starting index.</p>
<p>The key idea behind tabulation is that we ensure all subproblems are solved before they are needed, enabling the construction of complete solutions in an organized manner. By iterating from the end to the beginning of the string, we guarantee that the necessary subproblems have already been solved when we need them.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize an empty unordered map <code>dp</code> to store the results of subproblems.</li>
<li>Iterate from the end of the string to the beginning (<code>startIdx</code> from <code>s.size()</code> to 0):
<ul>
<li>Initialize an empty array <code>validSentences</code> to store all valid sentences starting from that index.</li>
<li>Iterate from <code>startIdx</code> to the end of the string (<code>endIdx</code>):
<ul>
<li>Extract the substring <code>currentWord</code> from <code>startIdx</code> to <code>endIdx</code>.</li>
<li>If <code>currentWord</code> is a valid word in <code>wordDict</code>:
<ul>
<li>If <code>endIdx</code> is the last index, add <code>currentWord</code> to <code>validSentences</code>.</li>
<li>Else, append <code>currentWord</code> to each sentence formed by the remaining substring (<code>sentencesFromNextIndex</code>) from <code>dp[endIdx + 1]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Store <code>validSentences</code> in <code>dp[startIdx]</code>.</li>
</ul>
</li>
<li>Return <code>dp[0]</code> (valid sentences formed from the entire string).</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/140/tabulation.json:976,631!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/gWJckozB/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Similar to memoization, the tabulation approach still needs to explore all possible substrings, which can be up to <span class="math inline">\(2^n\)</span> in the worst case, leading to an exponential time complexity. <span class="math inline">\(O(n)\)</span> work is performed to explore each substring, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The dynamic programming table or map needs to store the valid sentences for all possible starting indices, which can be up to <span class="math inline">\(2^n\)</span> strings of size <span class="math inline">\(n\)</span> in the worst case, resulting in an exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-trie-optimization">Approach 4: Trie Optimization</h3>
<h4 id="intuition-3">Intuition</h4>
<p>While the previous approaches focus on optimizing the search and computation process, we can also consider leveraging efficient data structures to enhance the word lookup process. This leads us to the trie-based approach, which uses a trie data structure to store the word dictionary, allowing efficient word lookup and prefix matching.</p>
<blockquote>
<p>The trie, also known as a prefix tree, is a tree-based data structure where each node represents a character in a word, and the path from the root to a leaf node represents a complete word. This structure is particularly useful for problems involving word segmentation because it allows for efficient prefix matching.</p>
</blockquote>
<p>Here, we first build a trie from the dictionary words. Each word is represented as a path in the trie, where each node corresponds to a character in the word.</p>
<p>By using the trie, we can quickly determine whether a substring can form a valid word without having to perform linear searches or set lookups. This reduces the search space and improves the efficiency of the algorithm.</p>
<p>In this approach, instead of recursively exploring the remaining substring and using memoization, we iterate from the end of the input string to the beginning (in reverse order). For each starting index (<code>startIdx</code>), we attempt to find valid sentences that can be formed from that index by iterating through the string and checking if the current substring forms a valid word using the trie data structure.<br />
When a valid word is encountered in the trie, we append it to the list of valid sentences for the current starting index. If the current valid word is not the last word in the sentence, we combine it with the valid sentences formed from the next index (<code>endIdx + 1</code>), which are retrieved from the <code>dp</code> dictionary.</p>
<p>The valid sentences for each starting index are stored in the <code>dp</code> dictionary, ensuring that previously computed results are reused. By using tabulation and storing the valid sentences for each starting index, we avoid redundant computations and achieve significant time and space efficiency improvements compared to the standard backtracking method with memoization.</p>
<p>The trie-based approach offers advantages in terms of efficient word lookup and prefix matching, making it particularly suitable for problems involving word segmentation or string manipulation. However, it comes with the additional overhead of constructing and maintaining the trie data structure, which can be more memory-intensive for large dictionaries.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p><strong>Initialize TrieNode Structure</strong></p>
<ul>
<li>Each TrieNode has two properties:</li>
<li><code>isEnd</code>: A boolean value indicating if the node marks the end of a word.</li>
<li><code>children</code>: An array of size 26 (for lowercase English letters) to store pointers to child nodes.</li>
<li>The constructor initializes <code>isEnd</code> to <code>false</code> and all elements in <code>children</code> to <code>null</code>.</li>
</ul>
<p><strong>Trie Class</strong></p>
<ul>
<li>The Trie class has a <code>root</code> pointer of type <code>TrieNode</code>.</li>
<li>The constructor initializes the <code>root</code> with a new <code>TrieNode</code> object.</li>
<li>The <code>insert</code> function:</li>
<li>Takes a string <code>word</code> as input.</li>
<li>Starts from the <code>root</code> node.</li>
<li>For each character <code>c</code> in the <code>word</code>:
<ul>
<li>Calculate the index corresponding to the character.</li>
<li>If the child node at the calculated index doesn't exist, create a new <code>TrieNode</code> and assign it to that index.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>After processing all characters, mark the current node's <code>isEnd</code> as <code>true</code>.</li>
</ul>
<p><strong>wordBreak Function</strong></p>
<ul>
<li>Create a <code>Trie</code> object.</li>
<li>Insert all words from <code>wordDict</code> into the trie using the <code>insert</code> function.</li>
<li>Initialize a map <code>dp</code> to store the results of subproblems.</li>
<li>Iterate from the end of the string <code>s</code> to the beginning (in reverse order).</li>
<li>For each starting index <code>startIdx</code>:
<ul>
<li>Initialize a vector <code>validSentences</code> to store valid sentences starting from <code>startIdx</code>.</li>
<li>Initialize a <code>current_node</code> pointer to the <code>root</code> of the trie.</li>
<li>Iterate from <code>startIdx</code> to the end of the string.
<ul>
<li>For each character <code>c</code> in the string:
<ul>
<li>Calculate the index corresponding to <code>c</code>.</li>
<li>Check if the child node at the calculated index exists in the trie.</li>
<li>If the child node doesn't exist, break out of the inner loop. This means that the current substring cannot form a valid word, so there is no need to continue checking the remaining characters.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>Check if the current node's <code>isEnd</code> is <code>true</code>, indicating a valid word.</li>
<li>If a valid word is found:
<ul>
<li>Extract the current word from the string using <code>substr</code>.</li>
<li>If it's the last word in the sentence (<code>endIdx</code> is the last index):
<ul>
<li>Add the current word to <code>validSentences</code>.</li>
</ul>
</li>
<li>If it's not the last word:
<ul>
<li>Retrieve the valid sentences formed by the remaining substring from <code>dp[endIdx + 1]</code>.</li>
<li>Combine the current word with each sentence and add it to <code>validSentences</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Store the <code>validSentences</code> for the current <code>startIdx</code> in <code>dp</code>.</li>
</ul>
</li>
<li>Return the valid sentences stored in <code>dp[0]</code>, which represents the valid sentences formed from the entire string.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/YBoyT88T/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Even though the trie-based approach uses an efficient data structure for word lookup, it still needs to explore all possible ways to break the string into words. In the worst case, there are <span class="math inline">\(2^n\)</span> unique possible partitions, leading to an exponential time complexity. <span class="math inline">\(O(n)\)</span> work is performed for each partition, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The trie data structure itself can have a maximum of <span class="math inline">\(2^n\)</span> nodes in the worst case, where each character in the string represents a separate word. Additionally, the tabulation map used in this approach can also store up to <span class="math inline">\(2^n\)</span> strings of size <span class="math inline">\(n\)</span>, resulting in an overall exponential space complexity.</p>
</li>
</ul>
<hr />
<p><strong>Further Thoughts On Complexity Analysis:</strong></p>
<p>The complexity of this problem cannot be reduced from <span class="math inline">\(n \cdot 2^n\)</span>; the worst-case scenario will still be <span class="math inline">\((n \cdot 2^n)\)</span>. However, using dynamic programming (DP) will make it a bit more efficient than backtracking overall because of the below test case.</p>
<p>Consider the input <code>&quot;aaaaaa&quot;</code>, with <code>wordDict = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;, &quot;aaaaa&quot;, &quot;aaaaa&quot;]</code>.<br />
Every possible partition is a valid sentence, and there are <span class="math inline">\(2^{n-1}\)</span> such partitions. The algorithms cannot perform better than this since they must generate all valid sentences. The cost of iterating over cached results will be exponential, as every possible partition will be cached, resulting in the same runtime as regular backtracking. Likewise, the space complexity will also be <span class="math inline">\(O(n \cdot 2^n)\)</span> for the same reason—every partition is stored in memory.</p>
<p>Another way to explain why the worst-case complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span> for all the algorithms is that, given an array of length <span class="math inline">\(n\)</span>, there are <span class="math inline">\(n+1\)</span> ways/intervals to partition it into two parts. Each interval has two choices: to split or not to split. In the worst case, we will have to check all possibilities, which results in a time complexity of <span class="math inline">\(O(n \cdot 2^{n+1})\)</span>, which simplifies to <span class="math inline">\(O(n \cdot 2^n)\)</span>. This analysis is extremely similar to palindrome partitioning.</p>
<p>Overall, this question is interesting because of the nature of this complexity. In an interview setting, if an interviewer asks this question, the most expected solutions would be Backtracking and Trie, as they become natural choices for the conditions and outputs we need.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-break-trie--141631/1" target="_blank" rel="noopener noreferrer">Word Break (Trie)</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a string <strong>A </strong>and a dictionary of n words <strong>B</strong>, find out if A&nbsp;can be segmented into a space-separated sequence of dictionary words.&nbsp;</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 12
B = { &quot;i&quot;, &quot;like&quot;, &quot;sam&quot;, &quot;sung&quot;, &quot;samsung&quot;,
&quot;mobile&quot;,&quot;ice&quot;,&quot;cream&quot;, &quot;icecream&quot;, &quot;man&quot;,
&quot;go&quot;, &quot;mango&quot; }, A = &quot;ilike&quot;
<strong>Output:</strong> 1
<strong>Explanation: </strong>The string can be segmented as
&quot;i like&quot;.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>: </span>
<span style="font-size:18px">n = 12 </span>
<span style="font-size:18px">B = { &quot;i&quot;, &quot;like&quot;, &quot;sam&quot;, &quot;sung&quot;, &quot;samsung&quot;,
&quot;mobile&quot;,&quot;ice&quot;,&quot;cream&quot;, &quot;icecream&quot;, &quot;man&quot;, 
&quot;go&quot;, &quot;mango&quot; }, A = &quot;ilikesamsung&quot; </span>
<span style="font-size:18px"><strong>Output:</strong> 1</span>
<span style="font-size:18px"><strong>Explanation</strong>: The string can be segmented as 
&quot;i like samsung&quot; or &quot;i like sam sung&quot;.</span>

</pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
Complete&nbsp;<strong>wordBreak()</strong>&nbsp;function which takes a string and list of strings as a parameter&nbsp;and returns 1 if it is possible to break words, else return&nbsp;0. You don&#39;t need to read any input or print any output, it is done by driver code.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected time complexity:&nbsp;</strong>O(n*l+|A|<sup>2</sup>) where l is the leght of longest string present in the dictionary and |A| is the length of&nbsp;string A</span><br />
<span style="font-size:18px"><strong>Expected auxiliary space:</strong>&nbsp;O(|A| + k) , where k = sum of length of all strings present in B</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints</strong>:<br />
1 &lt;= N &lt;= 12<br />
1 &lt;= s &lt;=1000 , where s =&nbsp;length of string A<br />
&nbsp;The length of each word is less than 15.</span></p>

<p>&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-search-ii/description" target="_blank" rel="noopener noreferrer">Word Search II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>

<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" style="width: 322px; height: 322px;" />
<pre>
<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]
<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" style="width: 162px; height: 162px;" />
<pre>
<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 12</code></li>
	<li><code>board[i][j]</code> is a lowercase English letter.</li>
	<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li>All the strings of <code>words</code> are unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-search-ii/1" target="_blank" rel="noopener noreferrer">Word Search II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>2-D board </strong>of characters of size <strong>n</strong>x<strong>m</strong> and a list of string <strong>words</strong>. Return a list of words that are present in the board in <strong>any</strong> order.</span></p>
<p><span style="font-size: 14pt;">Each word must be constructed from letters of sequentially <strong>adjacent</strong> cells, where adjacent cells are <strong>horizontally</strong> or <strong>vertically</strong> connected.&nbsp;<br />The same letter cell cannot be used more than once in a word. A single-letter cell can be used for many different words.</span></p>
<p><span style="font-size: 14pt;">Note: Driver code will sort the returned list before printing.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">board[][] = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']], words[] = ["oath", "pea", "eat", "rain"]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/876764/Web/Other/blobid0_1732516922.jpg" width="312" height="276" /><br /><strong>Output: </strong>["eat", "oath"]<br /></span></pre>
<pre><strong><span style="font-size: 14pt;">Input:</span></strong><span style="font-size: 14pt;"> board[][] = [['a', 'b'],['c', 'd']], words[] = ["abcb"]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/876764/Web/Other/blobid0_1732517302.jpg" height="100" /><br /><strong>Output: </strong>[]</span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1&nbsp; &lt;=&nbsp; n, m&nbsp; &lt;=&nbsp; 12</span><span style="font-size: 14pt;"><br />1&nbsp; &lt;=&nbsp; words.size() &nbsp;&lt;=&nbsp; 3*10<sup>4</sup><br />1&nbsp; &lt;=&nbsp; words[i].length() &nbsp;&lt;=&nbsp; 10<br />All strings of words are <strong>unique</strong> and only consist of <strong>lowercase</strong> English letters</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/words-within-two-edits-of-dictionary/description" target="_blank" rel="noopener noreferrer">Words Within Two Edits of Dictionary</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two string arrays, <code>queries</code> and <code>dictionary</code>. All words in each array comprise of lowercase English letters and have the same length.</p>

<p>In one <strong>edit</strong> you can take a word from <code>queries</code>, and change any letter in it to any other letter. Find all words from <code>queries</code> that, after a <strong>maximum</strong> of two edits, equal some word from <code>dictionary</code>.</p>

<p>Return<em> a list of all words from </em><code>queries</code><em>, </em><em>that match with some word from </em><code>dictionary</code><em> after a maximum of <strong>two edits</strong></em>. Return the words in the <strong>same order</strong> they appear in <code>queries</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;word&quot;,&quot;note&quot;,&quot;ants&quot;,&quot;wood&quot;], dictionary = [&quot;wood&quot;,&quot;joke&quot;,&quot;moat&quot;]
<strong>Output:</strong> [&quot;word&quot;,&quot;note&quot;,&quot;wood&quot;]
<strong>Explanation:</strong>
- Changing the &#39;r&#39; in &quot;word&quot; to &#39;o&#39; allows it to equal the dictionary word &quot;wood&quot;.
- Changing the &#39;n&#39; to &#39;j&#39; and the &#39;t&#39; to &#39;k&#39; in &quot;note&quot; changes it to &quot;joke&quot;.
- It would take more than 2 edits for &quot;ants&quot; to equal a dictionary word.
- &quot;wood&quot; can remain unchanged (0 edits) and match the corresponding dictionary word.
Thus, we return [&quot;word&quot;,&quot;note&quot;,&quot;wood&quot;].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;yes&quot;], dictionary = [&quot;not&quot;]
<strong>Output:</strong> []
<strong>Explanation:</strong>
Applying any two edits to &quot;yes&quot; cannot make it equal to &quot;not&quot;. Thus, we return an empty array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= queries.length, dictionary.length &lt;= 100</code></li>
	<li><code>n == queries[i].length == dictionary[j].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li>All <code>queries[i]</code> and <code>dictionary[j]</code> are composed of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>