<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>counting - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>counting</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">150</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">3Sum With Multiplicity</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Apply Operations to Make String Empty</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Best Poker Hand</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Bulls and Cows</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Change Minimum Characters to Satisfy One of Three Conditions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Check if All Characters Have Equal Number of Occurrences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Check if Any Element Has Prime Frequency</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Check If Array Pairs Are Divisible by k</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Check if Number Has Equal Digit Count and Digit Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Check if One String Swap Can Make Strings Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Check Whether Two Strings are Almost Equivalent</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Construct K Palindrome Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Construct String With Repeat Limit</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Count Almost Equal Pairs I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Count Almost Equal Pairs II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Count Anagrams</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Count Common Words With One Occurrence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Count Elements With Maximum Frequency</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Count Elements With Strictly Smaller and Greater Elements </a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Count Nice Pairs in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Count Number of Bad Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Count Number of Distinct Integers After Reverse Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Count Number of Pairs With Absolute Difference K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Count Pairs Of Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Count Pairs Of Similar Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Count Pairs That Form a Complete Day I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Count Pairs That Form a Complete Day II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Count Servers that Communicate</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Count Special Triplets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Count Substrings Starting and Ending with Given Character</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Count Tested Devices After Test Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Count the Number of Consistent Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Count the Number of Vowel Strings in Range</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Design Parking System</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Destroy Sequential Targets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Detect Squares</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Determine if String Halves Are Alike</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Determine if Two Strings Are Close</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Distant Barcodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Divide Array Into Equal Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Equal Sum Arrays With Minimum Number of Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Find All Lonely Numbers in the Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Find Consecutive Integers from a Data Stream</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Find Longest Special Substring That Occurs Thrice I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Find Longest Special Substring That Occurs Thrice II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Find Lucky Integer in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Find Most Frequent Vowel and Consonant</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Find Players With Zero or One Losses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Find the Most Common Response</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Find the Number of Winning Players</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Find Valid Pair of Adjacent Digits in String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Find Words That Can Be Formed by Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">First Letter to Appear Twice</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">First Unique Character in a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Furthest Point From Origin</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Identify the Largest Outlier in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Increasing Decreasing String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Intersection of Multiple Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Kth Distinct String in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Largest Color Value in a Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Largest Combination With Bitwise AND Greater Than Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Largest Palindromic Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Largest Values From Labels</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Least Number of Unique Integers after K Removals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Letter Tile Possibilities</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Longest Harmonious Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Longest Palindrome by Concatenating Two Letter Words</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Longest Subsequence Repeated k Times</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Majority Element</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Majority Element II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Make Number of Distinct Characters Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Maximum Count of Positive Integer and Negative Integer</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Maximum Difference Between Even and Odd Frequency I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Maximum Manhattan Distance After K Changes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Maximum Number of Balloons</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Maximum Number of Balls in a Box</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Maximum Number of Operations to Move Ones to the End</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Maximum Number of Pairs in Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Maximum Number of Ways to Partition an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Maximum Palindromes After Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Maximum Population Year</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-81" class="toc-link">Maximum Total Damage With Spell Casting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Minimum Array Length After Pair Removals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Minimum Cost to Split an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-84" class="toc-link">Minimum Deletions for At Most K Distinct Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-85" class="toc-link">Minimum Deletions to Make String K-Special</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">Minimum Increment to Make Array Unique</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Minimum Length of Anagram Concatenation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Minimum Length of String After Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Minimum Number of Frogs Croaking</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Minimum Number of Operations to Make Array Empty</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-91" class="toc-link">Minimum Number of Operations to Make Word K-Periodic</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">Minimum Number of Pushes to Type Word II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Minimum Number of Steps to Make Two Strings Anagram</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-94" class="toc-link">Minimum Number of Steps to Make Two Strings Anagram II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Minimum Operations to Make Character Frequencies Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-96" class="toc-link">Minimum Operations to Make the Array Alternating</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-97" class="toc-link">Minimum Operations to Write the Letter Y on a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-98" class="toc-link">Minimum Rounds to Complete All Tasks</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Minimum Substring Partition of Equal Character Frequency</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-100" class="toc-link">Minimum Total Cost to Make Arrays Unequal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Most Common Word</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Most Frequent Even Element</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-103" class="toc-link">Most Frequent Number Following Key In an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Most Frequent Prime</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">Next Greater Numerically Balanced Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Number of Beautiful Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-107" class="toc-link">Number of Different Subsequences GCDs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Number of Equivalent Domino Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Number of Good Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Number of Nodes in the Sub-Tree With the Same Label</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Number of Pairs of Interchangeable Rectangles</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Number of Pairs of Strings With Concatenation Equal to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Pairs of Songs With Total Durations Divisible by 60</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Rank Teams by Votes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Ransom Note</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Rearrange Characters to Make Target String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Redistribute Characters to Make All Strings Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-118" class="toc-link">Remove Letter To Equalize Frequency</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Reordered Power of 2</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">Reorganize String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Replace Question Marks in String to Minimize Its Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-122" class="toc-link">Right Triangles</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">RLE Iterator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Sender With Largest Word Count</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Smallest Palindromic Rearrangement II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Sort Characters By Frequency</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-127" class="toc-link">Sorted GCD Pair Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Sort Integers by The Number of 1 Bits</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-129" class="toc-link">Split a String in Balanced Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Split the Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Stone Game IX</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Subarrays with K Different Integers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Subdomain Visit Count</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Substrings of Size Three with Distinct Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Sum of Beauty of All Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Sum of Digit Differences of All Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">Sum of Prefix Scores of Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-138" class="toc-link">Sum of Unique Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-139" class="toc-link">Task Scheduler</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-140" class="toc-link">The Number of Good Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-141" class="toc-link">Threshold Majority Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-142" class="toc-link">Top K Frequent Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-143" class="toc-link">Top K Frequent Words</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-144" class="toc-link">Total Characters in String After Transformations I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-145" class="toc-link">Total Characters in String After Transformations II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-146" class="toc-link">Transform Array by Parity</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-147" class="toc-link">Tuple with Same Product</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Uncommon Words from Two Sentences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-149" class="toc-link">X of a Kind in a Deck of Cards</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/3sum-with-multiplicity/description" target="_blank" rel="noopener noreferrer">3Sum With Multiplicity</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>arr</code>, and an integer <code>target</code>, return the number of tuples <code>i, j, k</code> such that <code>i &lt; j &lt; k</code> and <code>arr[i] + arr[j] + arr[k] == target</code>.</p>

<p>As the answer can be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,1,2,2,3,3,4,4,5,5], target = 8
<strong>Output:</strong> 20
<strong>Explanation: </strong>
Enumerating by the values (arr[i], arr[j], arr[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,1,2,2,2,2], target = 5
<strong>Output:</strong> 12
<strong>Explanation: </strong>
arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,1,3], target = 6
<strong>Output:</strong> 1
<strong>Explanation:</strong> (1, 2, 3) occured one time in the array so we return 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= arr.length &lt;= 3000</code></li>
	<li><code>0 &lt;= arr[i] &lt;= 100</code></li>
	<li><code>0 &lt;= target &lt;= 300</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/apply-operations-to-make-string-empty/description" target="_blank" rel="noopener noreferrer">Apply Operations to Make String Empty</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>.</p>

<p>Consider performing the following operation until <code>s</code> becomes <strong>empty</strong>:</p>

<ul>
	<li>For <strong>every</strong> alphabet character from <code>&#39;a&#39;</code> to <code>&#39;z&#39;</code>, remove the <strong>first</strong> occurrence of that character in <code>s</code> (if it exists).</li>
</ul>

<p>For example, let initially <code>s = &quot;aabcbbca&quot;</code>. We do the following operations:</p>

<ul>
	<li>Remove the underlined characters <code>s = &quot;<u><strong>a</strong></u>a<strong><u>bc</u></strong>bbca&quot;</code>. The resulting string is <code>s = &quot;abbca&quot;</code>.</li>
	<li>Remove the underlined characters <code>s = &quot;<u><strong>ab</strong></u>b<u><strong>c</strong></u>a&quot;</code>. The resulting string is <code>s = &quot;ba&quot;</code>.</li>
	<li>Remove the underlined characters <code>s = &quot;<u><strong>ba</strong></u>&quot;</code>. The resulting string is <code>s = &quot;&quot;</code>.</li>
</ul>

<p>Return <em>the value of the string </em><code>s</code><em> right <strong>before</strong> applying the <strong>last</strong> operation</em>. In the example above, answer is <code>&quot;ba&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabcbbca&quot;
<strong>Output:</strong> &quot;ba&quot;
<strong>Explanation:</strong> Explained in the statement.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;
<strong>Output:</strong> &quot;abcd&quot;
<strong>Explanation:</strong> We do the following operation:
- Remove the underlined characters s = &quot;<u><strong>abcd</strong></u>&quot;. The resulting string is s = &quot;&quot;.
The string just before the last operation is &quot;abcd&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/best-poker-hand/description" target="_blank" rel="noopener noreferrer">Best Poker Hand</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>ranks</code> and a character array <code>suits</code>. You have <code>5</code> cards where the <code>i<sup>th</sup></code> card has a rank of <code>ranks[i]</code> and a suit of <code>suits[i]</code>.</p>

<p>The following are the types of <strong>poker hands</strong> you can make from best to worst:</p>

<ol>
	<li><code>&quot;Flush&quot;</code>: Five cards of the same suit.</li>
	<li><code>&quot;Three of a Kind&quot;</code>: Three cards of the same rank.</li>
	<li><code>&quot;Pair&quot;</code>: Two cards of the same rank.</li>
	<li><code>&quot;High Card&quot;</code>: Any single card.</li>
</ol>

<p>Return <em>a string representing the <strong>best</strong> type of <strong>poker hand</strong> you can make with the given cards.</em></p>

<p><strong>Note</strong> that the return values are <strong>case-sensitive</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ranks = [13,2,3,1,9], suits = [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]
<strong>Output:</strong> &quot;Flush&quot;
<strong>Explanation:</strong> The hand with all the cards consists of 5 cards with the same suit, so we have a &quot;Flush&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ranks = [4,4,2,4,4], suits = [&quot;d&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
<strong>Output:</strong> &quot;Three of a Kind&quot;
<strong>Explanation:</strong> The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a &quot;Three of a Kind&quot;.
Note that we could also make a &quot;Pair&quot; hand but &quot;Three of a Kind&quot; is a better hand.
Also note that other cards could be used to make the &quot;Three of a Kind&quot; hand.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> ranks = [10,10,2,12,9], suits = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;d&quot;]
<strong>Output:</strong> &quot;Pair&quot;
<strong>Explanation:</strong> The hand with the first and second card consists of 2 cards with the same rank, so we have a &quot;Pair&quot;.
Note that we cannot make a &quot;Flush&quot; or a &quot;Three of a Kind&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>ranks.length == suits.length == 5</code></li>
	<li><code>1 &lt;= ranks[i] &lt;= 13</code></li>
	<li><code>&#39;a&#39; &lt;= suits[i] &lt;= &#39;d&#39;</code></li>
	<li>No two cards have the same rank and suit.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/bulls-and-cows/description" target="_blank" rel="noopener noreferrer">Bulls and Cows</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are playing the <strong><a href="https://en.wikipedia.org/wiki/Bulls_and_Cows" target="_blank">Bulls and Cows</a></strong> game with your friend.</p>

<p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p>

<ul>
	<li>The number of &quot;bulls&quot;, which are digits in the guess that are in the correct position.</li>
	<li>The number of &quot;cows&quot;, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</li>
</ul>

<p>Given the secret number <code>secret</code> and your friend&#39;s guess <code>guess</code>, return <em>the hint for your friend&#39;s guess</em>.</p>

<p>The hint should be formatted as <code>&quot;xAyB&quot;</code>, where <code>x</code> is the number of bulls and <code>y</code> is the number of cows. Note that both <code>secret</code> and <code>guess</code> may contain duplicate digits.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> secret = &quot;1807&quot;, guess = &quot;7810&quot;
<strong>Output:</strong> &quot;1A3B&quot;
<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:
&quot;1807&quot;
  |
&quot;<u>7</u>8<u>10</u>&quot;</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> secret = &quot;1123&quot;, guess = &quot;0111&quot;
<strong>Output:</strong> &quot;1A1B&quot;
<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:
&quot;1123&quot;        &quot;1123&quot;
  |      or     |
&quot;01<u>1</u>1&quot;        &quot;011<u>1</u>&quot;
Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>
	<li><code>secret.length == guess.length</code></li>
	<li><code>secret</code> and <code>guess</code> consist of digits only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/description" target="_blank" rel="noopener noreferrer">Change Minimum Characters to Satisfy One of Three Conditions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">prefix-sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>a</code> and <code>b</code> that consist of lowercase letters. In one operation, you can change any character in <code>a</code> or <code>b</code> to <strong>any lowercase letter</strong>.</p>

<p>Your goal is to satisfy <strong>one</strong> of the following three conditions:</p>

<ul>
	<li><strong>Every</strong> letter in <code>a</code> is <strong>strictly less</strong> than <strong>every</strong> letter in <code>b</code> in the alphabet.</li>
	<li><strong>Every</strong> letter in <code>b</code> is <strong>strictly less</strong> than <strong>every</strong> letter in <code>a</code> in the alphabet.</li>
	<li><strong>Both</strong> <code>a</code> and <code>b</code> consist of <strong>only one</strong> distinct letter.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations needed to achieve your goal.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;aba&quot;, b = &quot;caa&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Consider the best way to make each condition true:
1) Change b to &quot;ccc&quot; in 2 operations, then every letter in a is less than every letter in b.
2) Change a to &quot;bbb&quot; and b to &quot;aaa&quot; in 3 operations, then every letter in b is less than every letter in a.
3) Change a to &quot;aaa&quot; and b to &quot;aaa&quot; in 2 operations, then a and b consist of one distinct letter.
The best way was done in 2 operations (either condition 1 or condition 3).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;dabadd&quot;, b = &quot;cda&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The best way is to make condition 1 true by changing b to &quot;eee&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>
	<li><code>a</code> and <code>b</code> consist only of lowercase letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/description" target="_blank" rel="noopener noreferrer">Check if All Characters Have Equal Number of Occurrences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>good</strong> string, or </em><code>false</code><em> otherwise</em>.</p>

<p>A string <code>s</code> is <strong>good</strong> if <strong>all</strong> the characters that appear in <code>s</code> have the <strong>same</strong> number of occurrences (i.e., the same frequency).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abacbc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The characters that appear in s are &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. All characters occur 2 times in s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaabb&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> The characters that appear in s are &#39;a&#39; and &#39;b&#39;.
&#39;a&#39; occurs 3 times while &#39;b&#39; occurs 2 times, which is not the same number of times.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-any-element-has-prime-frequency/description" target="_blank" rel="noopener noreferrer">Check if Any Element Has Prime Frequency</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>.</p>

<p>Return <code>true</code> if the frequency of any element of the array is <strong>prime</strong>, otherwise, return <code>false</code>.</p>

<p>The <strong>frequency</strong> of an element <code>x</code> is the number of times it occurs in the array.</p>

<p>A prime number is a natural number greater than 1 with only two factors, 1 and itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4,5,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>4 has a frequency of two, which is a prime number.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>All elements have a frequency of one.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,2,2,4,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>Both 2 and 4 have a prime frequency.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/description" target="_blank" rel="noopener noreferrer">Check If Array Pairs Are Divisible by k</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>arr</code> of even length <code>n</code> and an integer <code>k</code>.</p>

<p>We want to divide the array into exactly <code>n / 2</code> pairs such that the sum of each pair is divisible by <code>k</code>.</p>

<p>Return <code>true</code><em> If you can find a way to do that or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4,5,10,6,7,8,9], k = 5
<strong>Output:</strong> true
<strong>Explanation:</strong> Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4,5,6], k = 7
<strong>Output:</strong> true
<strong>Explanation:</strong> Pairs are (1,6),(2,5) and(3,4).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4,5,6], k = 10
<strong>Output:</strong> false
<strong>Explanation:</strong> You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>arr.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>n</code> is even.</li>
	<li><code>-10<sup>9</sup> &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-hashing--counting">Approach 1: Hashing / Counting</h3>
<h4 id="intuition">Intuition</h4>
<p>We have an array of size <code>n</code> and need to divide it into exactly <code>n/2</code> pairs. The goal is to ensure that the sum of each pair is divisible by <code>k</code>. We will return <code>true</code> if we can make these pairs and <code>false</code> otherwise.</p>
<p>To form a pair, we first pick an integer from the array and calculate its value modulo <code>k</code>, which we will call <code>mod</code>. To find a suitable partner for this integer, we look for another element with a modulo value of <code>k - mod</code>. This can be explained with the proof given below:</p>
<p>Let the array be <span class="math inline">\(A = [a_1, a_2, ..., a_n]\)</span> and the divisor be <span class="math inline">\(k\)</span>. We need to form pairs such that:</p>
<p><span class="math inline">\((ai + aj) \% k = 0\)</span></p>
<p>This can be rewritten as:</p>
<p><span class="math inline">\((ai \% k + aj \% k) \% k = 0\)</span></p>
<p>For each element in the array, its remainder when divided by <span class="math inline">\(k\)</span> lies in the range <span class="math inline">\([0, k-1]\)</span>. Let's denote the remainder of an element <span class="math inline">\(a_i\)</span> by <span class="math inline">\(mod_i = a_i \% k\)</span>. To form a valid pair <span class="math inline">\((ai, aj)\)</span>, we need:</p>
<p><span class="math inline">\((mod_i + mod_j) \% k = 0\)</span></p>
<p>This implies:</p>
<p><span class="math inline">\(mod_j = k - mod_i\)</span></p>
<p>If <code>mod</code> is 0, we need to pair this element with another that is also 0. This is because the sum of two numbers divisible by <code>k</code> is also divisible by <code>k</code>. Therefore, the count of elements that yield a modulo of 0 must be even to form valid pairs.</p>
<p>To efficiently track the modulo values, we can use a hashmap called <code>remainderCount</code>. This hashmap will store the counts of each modulo value. We will then iterate through the array to check if we can successfully form pairs based on these counts.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a hashmap <code>remainderCount</code> to store the count of remainders when dividing elements of <code>arr</code> by <code>k</code>.</li>
<li>Iterate through the array <code>arr</code>:
<ul>
<li>For each element <code>i</code>, compute the remainder as <code>(x % k + k) % k</code> to handle both positive and negative values.</li>
<li>Increment the count of this remainder in <code>remainderCount</code>.</li>
</ul>
</li>
<li>Iterate through the array <code>arr</code> again:
<ul>
<li>For each element <code>i</code>, compute the remainder as <code>(i % k + k) % k</code>.</li>
<li>If the remainder is 0, check if the count of this remainder in <code>remainderCount</code> is even:
<ul>
<li>If it is odd, return <code>false</code> (no valid pairs).</li>
</ul>
</li>
<li>For all other remainders <code>rem</code>, check if the count of <code>rem</code> is equal to the count of <code>k - rem</code>:
<ul>
<li>If they are not equal, return <code>false</code> (no valid pairs).</li>
</ul>
</li>
</ul>
</li>
<li>If all checks pass, return <code>true</code> (valid pairs can be made).</li>
</ol>
<p>!?!../Documents/1497_rename/slideshow1_rename.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cMDdbuuu/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>arr</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The loop traverses the array twice, and all search, insert operations performed on the hashmap take constant time. Therefore, the time complexity is linear.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k)\)</span></p>
<p>Inserting the modulo values in the hashmap requires exactly <code>k</code> unique values from <code>0</code> to <code>k-1</code>, so the space complexity is given by <span class="math inline">\(O(k)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting-and-two-pointers">Approach 2: Sorting and Two-Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we focused on finding pairs with their modulo <code>k</code> values expressed as <span class="math inline">\(\text{mod}\)</span> and <span class="math inline">\(k - \text{mod}\)</span>. When we sort the array by these modulo values, we notice that pairs will be located at opposite ends. For instance, after pairing elements with modulo 0, elements with modulo 1 will pair with those at <code>k - 1</code>, which are at the end of the array since modulo values range from 0 to <code>k - 1</code>.</p>
<p>To solve this, we can use a two-pointer technique. After handling the case for modulo 0  value, we set two pointers, <code>i</code> at the start and <code>j</code> at the end of the array. If the values at <code>i</code> and <code>j</code> form a valid pair, we move <code>i</code> to the next index and <code>j</code> to the previous index. If they do not form a pair, we return false. If <code>i</code> and <code>j</code> converge at the same index, we return true.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Define a custom comparator to sort the array based on the remainder when dividing elements by <code>k</code>.
<ul>
<li>The comparator will return <code>true</code> if the modulo of the first element is less than the second, taking into account negative values by using <code>(k + i % k) % k</code>.</li>
</ul>
</li>
<li>Sort the array <code>arr</code> using the custom comparator.</li>
<li>Initialize two pointers <code>start</code> and <code>end</code>:
<ul>
<li><code>start</code> starts from the beginning of the array and <code>end</code> starts from the end of the array.</li>
</ul>
</li>
<li>While <code>start</code> is less than <code>end</code>:
<ul>
<li>If the element at index <code>start</code> is not divisible by <code>k</code>, break the loop.</li>
<li>If the next element (<code>start + 1</code>) is not divisible by <code>k</code>, return <code>false</code> (invalid pairing).</li>
<li>Increment <code>start</code> by 2.</li>
</ul>
</li>
<li>For the remaining elements:
<ul>
<li>If the sum of the two elements is not divisible by <code>k</code>, return <code>false</code> (invalid pairing).</li>
<li>Increment <code>start</code> and decrement <code>end</code> to continue pairing.</li>
</ul>
</li>
<li>If all pairs are valid, return <code>true</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/2SEmtqFU/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>arr</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>Sorting the array takes <span class="math inline">\(O(n \cdot \log n)\)</span> time. All other operations are linear or constant time.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n\cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
<p>The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/description" target="_blank" rel="noopener noreferrer">Check if Number Has Equal Digit Count and Digit Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>num</code> of length <code>n</code> consisting of digits.</p>

<p>Return <code>true</code> <em>if for <strong>every</strong> index </em><code>i</code><em> in the range </em><code>0 &lt;= i &lt; n</code><em>, the digit </em><code>i</code><em> occurs </em><code>num[i]</code><em> times in </em><code>num</code><em>, otherwise return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;1210&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong>
num[0] = &#39;1&#39;. The digit 0 occurs once in num.
num[1] = &#39;2&#39;. The digit 1 occurs twice in num.
num[2] = &#39;1&#39;. The digit 2 occurs once in num.
num[3] = &#39;0&#39;. The digit 3 occurs zero times in num.
The condition holds true for every index in &quot;1210&quot;, so return true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;030&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong>
num[0] = &#39;0&#39;. The digit 0 should occur zero times, but actually occurs twice in num.
num[1] = &#39;3&#39;. The digit 1 should occur three times, but actually occurs zero times in num.
num[2] = &#39;0&#39;. The digit 2 occurs zero times in num.
The indices 0 and 1 both violate the condition, so return false.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == num.length</code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>num</code> consists of digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/description" target="_blank" rel="noopener noreferrer">Check if One String Swap Can Make Strings Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s1</code> and <code>s2</code> of equal length. A <strong>string swap</strong> is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.</p>

<p>Return <code>true</code> <em>if it is possible to make both strings equal by performing <strong>at most one string swap </strong>on <strong>exactly one</strong> of the strings. </em>Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;bank&quot;, s2 = &quot;kanb&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> For example, swap the first character with the last character of s2 to make &quot;bank&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;attack&quot;, s2 = &quot;defend&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to make them equal with one string swap.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;kelb&quot;, s2 = &quot;kelb&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The two strings are already equal, so no string swap operation is required.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>
	<li><code>s1.length == s2.length</code></li>
	<li><code>s1</code> and <code>s2</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two strings <code>s1</code> and <code>s2</code> and want to determine if it is possible to make the strings equal by performing at most one string swap on one of the strings. A string swap involves choosing any two indices in the string and swapping the characters at these positions.</p>
<hr />
<h3 id="approach-1-frequency-map--check-differences">Approach 1: Frequency Map + Check Differences</h3>
<h4 id="intuition">Intuition</h4>
<p>To start, consider the example where <code>s1 = &quot;bank&quot;</code> and <code>s2 = &quot;kanb&quot;</code>. If we swap the first and last characters of <code>s1</code>, we get <code>&quot;kanb&quot;</code>, which matches <code>s2</code>. Alternatively, we could swap the first and last characters of <code>s2</code> to get <code>&quot;bank&quot;</code>, which matches <code>s1</code>. One observation we can make is that this swapping only works if the two strings share the same characters and frequencies. The only difference would be the ordering of characters.</p>
<p>In other words, it is necessary for the two strings to be anagrams for a string swap to be possible. Otherwise, one string will have a certain character that the other is missing, and no amount of swapping can make them equal.</p>
<p>However, two strings being anagrams is not enough to ensure swapping will make them equal. Let's consider another example: <code>s1 = hello</code> and <code>s2 = olleh</code>. We know that the two strings are anagrams, but it is still not possible for a single string swap to make <code>s1</code> equal to <code>s2</code> or vice versa. If we were to compare each character of <code>s1</code>, <code>s1[i]</code>, to its corresponding character in <code>s2</code>, <code>s2[i]</code>, we see that there is a total of 4 differences at indices <code>i = 0, 1, 3, 4</code>. One string swap can only resolve two differences, so they cannot be made equal. This leads us to our second requirement for a string swap to be possible: If there are any differences, the total number of character-by-character differences has to be exactly 2. Note the edge case where <code>s1</code> and <code>s2</code> are already equal, in which there are 0 character-by-character differences and no string swaps are needed.</p>
<p>Now, we have fully developed a rule for determining if the two strings can be made equal:</p>
<ul>
<li>If <code>s1</code> and <code>s2</code> are already equal, then no string swap is needed and we know it's trivially possible for the strings to be equal.</li>
<li>If <code>s1</code> and <code>s2</code> have the same set of character frequencies (i.e. are anagrams) and have exactly 2 character-by-character differences, then we know it's possible to make the strings equal with 1 string swap.</li>
<li>Otherwise, the two strings can't be made equal with one string swap.</li>
</ul>
<p>To implement these checks, we can use two frequency maps <code>s1FrequencyMap</code> and <code>s2FrequencyMap</code> to keep track of the frequency of each letter for the two strings. As we go through the characters of the two strings and populate the frequency maps, we can also maintain counter <code>numDiffs</code> that counts the number of differences at corresponding indices. If the two strings are anagrams and <code>numDiffs</code> equals 2, we know that one swap can resolve the differences.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Check edge case: if <code>s1</code> and <code>s2</code> are already equal, then return <code>true</code>.</li>
<li>Initialize the frequency maps for each string: <code>s1FrequencyMap</code> and <code>s2FrequencyMap</code> are character arrays of size 26.</li>
<li>Initialize the counter <code>numDiffs</code> to maintain the number of character differences between the two strings.</li>
<li>Iterate through the characters of <code>s1</code> and <code>s2</code>:
<ul>
<li>Let <code>s1Char</code> and <code>s2Char</code> be the current characters of <code>s1</code> and <code>s2</code>, respectively.</li>
<li>If <code>s1Char != s2Char</code>, then increment <code>numDiffs</code>. If <code>numDiffs</code> is now greater than <code>2</code>, then we know one string swap will not make the strings equal, so return <code>false</code>.</li>
<li>Update the frequency maps by incrementing the frequency of <code>s1Char</code> and <code>s2Char</code>: <code>s1FrequencyMap[s1Char]++</code> and <code>s2FrequencyMap[s2Char]++</code>.</li>
</ul>
</li>
<li>Now, the strings are equal only if the frequency maps are equal (at this point, we know <code>numDiffs</code> is exactly 2): If <code>s1FrequencyMap</code> and <code>s2FrequencyMap</code> have the same frequencies, then return <code>true</code>. Otherwise, return <code>false</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fyr4jYXS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of <code>s1</code> and <code>s2</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>Iterating through <code>s1</code> and <code>s2</code> takes <span class="math inline">\(O(N)\)</span> time. For each character we iterate, updating the frequency maps and diff counter takes <span class="math inline">\(O(1)\)</span> constant time. Thus, the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Each frequency map has a fixed size of 26, regardless of the length of <code>s1</code> and <code>s2</code>. Thus, the space complexity is <span class="math inline">\(O(1)\)</span> constant time.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-only-check-differences">Approach 2: Only Check Differences</h3>
<h4 id="intuition-1">Intuition</h4>
<p>For our previous approach, we already achieved an efficient constant space complexity. However, let's try to optimize further and see if we can check if the two strings can be made equal without using the frequency maps.</p>
<p>Let's take another look at the example <code>s1 = bank</code> and <code>s2 = kanb</code>. We previously established that there are exactly 2 character differences: at index 0 and index 3. This makes it possible for one string swap to make the strings equal.</p>
<p>However, we can make a more specific observation: This swap only works because the character at index 0 of <code>s1</code> matches the character at index 3 of <code>s2</code>. Similarly, the character at index 3 for <code>s1</code> is equal to the character at index 0 for <code>s2</code>. In other words, if the characters in the mismatched positions &quot;cross-match&quot;, a swap will be able to make the strings equal.</p>
<p><img src="../Figures/1790/swap.png" alt="Swap matching" /></p>
<p>This leads us to a stricter rule:</p>
<ul>
<li>For the strings to be equal after a single swap, there must be exactly two mismatched indices, <code>i</code> and <code>j</code>, such that:
<ol>
<li><code>s1[i] == s2[j]</code></li>
<li><code>s1[j] == s2[i]</code></li>
</ol>
</li>
</ul>
<p>Similar to before, if the strings are already identical, no swap is needed. In all other cases, equality is not possible.</p>
<p>For this rule, we can simply introduce two new variables <code>firstIndexDiff</code> and <code>secondIndexDiff</code> to keep track of the indices of differences. We continue to use <code>numDiffs</code> to make sure the <code>numDiffs</code> doesn't surpass 2. We will iterate through <code>s1</code> and <code>s2</code> like we do in approach 1, except we now update <code>firstIndexDiff</code>, <code>secondIndexDiff</code>, and <code>numDiffs</code> when we see a character difference.</p>
<blockquote>
<p>Note: For this approach's implementation, observe that we do not have to explicitly check the trivial edge case where <code>s1</code> and <code>s2</code> are equal. If the two strings are equal, then no diffs are found, and <code>s1[firstIndexDiff] == s2[secondIndexDiff] &amp;&amp; s1[secondIndexDiff] == s2[firstIndexDiff]</code> will always be true, assuming the default initialized values of <code>firstIndexDiff</code> and <code>secondIndexDiff</code> are valid (they can just be 0).</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>firstIndexDiff</code>, <code>secondIndexDiff</code>, and <code>numDiffs</code> all to 0.</li>
<li>Iterate through the characters of <code>s1</code> and <code>s2</code>:
<ul>
<li>Let <code>s1Char</code> and <code>s2Char</code> be the current characters of <code>s1</code> and <code>s2</code> at index <code>i</code>, respectively.</li>
<li>If <code>s1Char != s2Char</code>:
<ul>
<li>Increment <code>numDiffs</code>.</li>
<li>If <code>numDiffs</code> is now greater than <code>2</code>, then we know one string swap will not make the strings equal, so return <code>false</code>.</li>
<li>If <code>numDiffs</code> is now equal to <code>1</code>, then we have found our first difference: assign <code>firstIndexDiff = i</code>.</li>
<li>Otherwise, <code>numDiffs</code> is <code>2</code> so we have found our second difference: assign <code>secondIndexDiff = i</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>s1[firstIndexDiff] == s2[secondIndexDiff] &amp;&amp; s1[secondIndexDiff] == s2[firstIndexDiff]</code></li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Gz6kKpTf/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>Iterating through <code>s1</code> and <code>s2</code> takes <span class="math inline">\(O(N)\)</span> time. For each character we iterate, updating <code>numDiffs</code>, <code>firstIndexDiff</code>, <code>secondIndexDiff</code> takes <span class="math inline">\(O(1)\)</span> constant time. Thus, the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use 3 integer variables, so the space complexity is constant <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/description" target="_blank" rel="noopener noreferrer">Check Whether Two Strings are Almost Equivalent</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Two strings <code>word1</code> and <code>word2</code> are considered <strong>almost equivalent</strong> if the differences between the frequencies of each letter from <code>&#39;a&#39;</code> to <code>&#39;z&#39;</code> between <code>word1</code> and <code>word2</code> is <strong>at most</strong> <code>3</code>.</p>

<p>Given two strings <code>word1</code> and <code>word2</code>, each of length <code>n</code>, return <code>true</code> <em>if </em><code>word1</code> <em>and</em> <code>word2</code> <em>are <strong>almost equivalent</strong>, or</em> <code>false</code> <em>otherwise</em>.</p>

<p>The <strong>frequency</strong> of a letter <code>x</code> is the number of times it occurs in the string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;aaaa&quot;, word2 = &quot;bccb&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> There are 4 &#39;a&#39;s in &quot;aaaa&quot; but 0 &#39;a&#39;s in &quot;bccb&quot;.
The difference is 4, which is more than the allowed 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abcdeef&quot;, word2 = &quot;abaaacc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The differences between the frequencies of each letter in word1 and word2 are at most 3:
- &#39;a&#39; appears 1 time in word1 and 4 times in word2. The difference is 3.
- &#39;b&#39; appears 1 time in word1 and 1 time in word2. The difference is 0.
- &#39;c&#39; appears 1 time in word1 and 2 times in word2. The difference is 1.
- &#39;d&#39; appears 1 time in word1 and 0 times in word2. The difference is 1.
- &#39;e&#39; appears 2 times in word1 and 0 times in word2. The difference is 2.
- &#39;f&#39; appears 1 time in word1 and 0 times in word2. The difference is 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;cccddabba&quot;, word2 = &quot;babababab&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The differences between the frequencies of each letter in word1 and word2 are at most 3:
- &#39;a&#39; appears 2 times in word1 and 4 times in word2. The difference is 2.
- &#39;b&#39; appears 2 times in word1 and 5 times in word2. The difference is 3.
- &#39;c&#39; appears 3 times in word1 and 0 times in word2. The difference is 3.
- &#39;d&#39; appears 2 times in word1 and 0 times in word2. The difference is 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == word1.length == word2.length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>word1</code> and <code>word2</code> consist only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-array">Approach: Array</h3>
<p><strong>Intuition</strong></p>
<p>We are given two strings <code>word1</code> and <code>word2</code>, both having the same length. We should return <code>true</code> if for each letter the difference in the frequency between <code>word1</code> and <code>word2</code> is not greater than <code>3</code>.</p>
<p>We can have an array of size <code>26</code> (as the strings can only have lowercase English letters), and store the frequency of the letters in the string <code>word1</code>. Then, we do the same with the string <code>word2</code> and store its frequencies in another array. We can then iterate over each letter to find the difference and check if any of them exceeds <code>3</code>, if yes we will return <code>false</code> and <code>true</code> otherwise.</p>
<p>Since we don't care about the actual frequencies in each string but rather the difference, we can use the same array for both words. For string <code>word1</code> we will increment the count for each letter, and for <code>word2</code> letters we will decrement the count. This way we will be able to find the difference between the frequencies on the fly and would only need one array. Also, since the length of both strings is the same, instead of doing it in two iterations, one for <code>word1</code> and another for <code>word2</code> we can do it in one.</p>
<p><img src="../Figures/2068/2068A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialise an empty array <code>cnt</code> of size <code>26</code> to store the difference of frequencies for each letter.</li>
<li>Iterate over the indices and for each index <code>i</code>:</li>
<li>Increment the count of the letter <code>word1[i]</code> by 1 and,</li>
<li>Decrement the count of <code>word2[i]</code> by 1.</li>
<li>In the end, iterate over the letters from <code>0</code> to <code>26</code> for each:</li>
<li>Check if the absolute value in the <code>cnt</code> is more than <code>3</code>.</li>
<li>If yes, return <code>false</code>.</li>
<li>Return <code>true</code> when the iteration is complete because that means there are no letters with a difference of more than <code>3</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/QimwNWn4/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the length of the string <code>word1</code> and <code>word2</code>, and <span class="math inline">\(K\)</span> is the number of unique characters in these strings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We iterate over each letter in the strings <code>word1</code> and <code>word2</code> to store the frequency difference, this takes <span class="math inline">\(O(N)\)</span> operations. Then we iterate over each letter to check if the difference is more than <code>3</code>, this takes <span class="math inline">\(O(K)\)</span> operations. Hence, the total time complexity is equal to <span class="math inline">\(O(N + K)\)</span>. The number of unique characters in the string cannot be more than the string of length itself, hence <span class="math inline">\(K <= N\)</span>. Therefore the time complexity can be simplified as <span class="math inline">\(O(N)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We need an array <code>cnt</code> to store the frequency difference for each letter, hence it would take an array of size <span class="math inline">\(K\)</span>. In this problem, <span class="math inline">\(K = 26\)</span>. Hence, the space complexity is constant.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-k-palindrome-strings/description" target="_blank" rel="noopener noreferrer">Construct K Palindrome Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and an integer <code>k</code>, return <code>true</code> if you can use all the characters in <code>s</code> to construct <strong>non-empty</strong> <code>k</code> <span data-keyword="palindrome-string">palindrome strings</span> or <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;annabelle&quot;, k = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> You can construct two palindromes using all characters in s.
Some possible constructions &quot;anna&quot; + &quot;elble&quot;, &quot;anbna&quot; + &quot;elle&quot;, &quot;anellena&quot; + &quot;b&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, k = 3
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to construct 3 palindromes using all the characters of s.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;true&quot;, k = 4
<strong>Output:</strong> true
<strong>Explanation:</strong> The only possible solution is to put each character in a separate string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> composed of lowercase letters and an integer <code>k</code>. Our goal is to determine if it's possible to rearrange the characters of the string into exactly <code>k</code> palindromic substrings.</p>
<p>A palindrome is a string that reads the same forward and backward, showing symmetry with respect to its center. For example, the string <code>&quot;babac&quot;</code> can form 5 palindromic groupings, such as:</p>
<ul>
<li>1 part: <code>&quot;bacab&quot;</code></li>
<li>2 parts: <code>&quot;aca&quot;</code> + <code>&quot;bb&quot;</code></li>
<li>3 parts: <code>&quot;aa&quot;</code> + <code>&quot;bb&quot;</code> + <code>&quot;c&quot;</code></li>
<li>4 parts: <code>&quot;aa&quot;</code> + <code>&quot;b&quot;</code> + <code>&quot;b&quot;</code> + <code>&quot;c&quot;</code></li>
<li>5 parts: <code>&quot;a&quot;</code> + <code>&quot;a&quot;</code> + <code>&quot;b&quot;</code> + <code>&quot;b&quot;</code> + <code>&quot;c&quot;</code></li>
</ul>
<p>In order to approach this problem, we need to understand the properties of palindromes, especially how character frequencies determine if a string can be rearranged into a palindrome. The key properties are:</p>
<ol>
<li><strong>Single Character Strings:</strong> Any string of length 1 is a palindrome. For example, the string <code>&quot;a&quot;</code> is a palindrome.</li>
<li><strong>Even Frequency Characters:</strong> A palindrome can have characters that all appear an even number of times, which allows them to form symmetric halves around the center. For example, <code>&quot;aabb&quot;</code> can form the palindrome <code>&quot;abba&quot;</code>.</li>
<li><strong>One Odd Frequency Character:</strong> A palindrome can have exactly one character with an odd frequency, which will sit at the center of the string, with the other characters forming symmetric halves. For example, <code>&quot;abcba&quot;</code> has the center <code>&quot;c&quot;</code> and symmetric halves <code>&quot;ab&quot;</code> and <code>&quot;ba&quot;</code>.</li>
</ol>
<p>Knowing this, we can determine whether forming exactly <code>k</code> palindromes is possible by analyzing the frequencies of the characters within the string.</p>
<hr />
<h3 id="approach-1-count-odd-frequencies">Approach 1: Count Odd Frequencies</h3>
<h4 id="intuition">Intuition</h4>
<p>To approach this problem, we need to consider how the frequencies of characters in the string <code>s</code> affect the ability to form palindromes.</p>
<p>What key insight can we gain from knowing that a single character can be a palindrome? If every individual character in the string can be a palindrome, then the maximum number of palindromes we can form is the length of the string <code>s</code>. If <code>k</code> is greater than the length of <code>s</code>, it’s impossible to form <code>k</code> palindromes, so the answer will be <code>false</code>. Similarly, if <code>k</code> equals the length of <code>s</code>, we can form <code>k</code> palindromes, with each character of <code>s</code> forming its own palindrome.</p>
<p>Next, consider even-frequency characters. These characters can be used to form the mirrored halves of palindromes, meaning we can freely distribute them across multiple palindromes without any issue. Thus, even-frequency characters do not limit the number of palindromes we can form.</p>
<p>The real challenge lies with odd-frequency characters. A palindrome can only have one odd-frequency character at its center; the rest must appear in even numbers. Therefore, the number of odd-frequency characters in the string determines how many palindromes we can form. Specifically, the minimum number of palindromes we can make is equal to the number of odd-frequency characters, because each odd-frequency character requires its own palindrome.</p>
<p>Thus, if the number of odd-frequency characters is greater than <code>k</code>, it’s impossible to form <code>k</code> palindromes, so we return <code>false</code>. If the number of odd-frequency characters is less than or equal to <code>k</code>, we can form <code>k</code> palindromes, and the answer will be <code>true</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Handle initial edge cases, comparing the length of <code>s</code> to <code>k</code>.
<ul>
<li>If the length of <code>s</code> is less than k, we return <code>false</code>, as we do not have enough characters to form k palindromes.</li>
<li>If the length of <code>s</code> is equal to <code>k</code>, we return <code>true</code>, as we can simply use each character of <code>s</code> to form a palindrome.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>an array <code>freq</code> of size <code>26</code>, representing the frequencies of each alphabetical character.</li>
<li>an integer <code>oddCount</code>, representing the number of odd frequencies found in the string.</li>
</ul>
</li>
<li>Iterate through <code>s</code>, incrementing the value of the index in <code>freq</code> corresponding to the character.</li>
<li>Iterate through the <code>freq</code>, incrementing <code>oddCount</code> when a frequency is odd.</li>
<li>Return <code>true</code> if <code>oddCount</code> is less than or equal to <code>k</code>; return <code>false</code> otherwise.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kc6UYhBH/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse the string of length <span class="math inline">\(n\)</span> only once.</p>
<p>All other operations performed happen in constant time. This includes traversing <code>freq</code>, as the size of the array is a fixed size of <code>26</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space required does not depend on the size of the input string, so only constant space is used.</p>
<p>Since we are limited to only lowercase letters in <code>s</code>, we can store the frequencies in constant space with an array of size <code>26</code>, <code>freq</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bit-manipulation">Approach 2: Bit Manipulation</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous solution, we tracked the frequency of each character and checked whether they were even or odd. However, we can optimize this approach by focusing only on whether the frequencies are even or odd, without needing to store the full count for each character. This way we can avoid the overhead of storing and counting individual frequencies.</p>
<p>We know that a palindrome can have at most one character with an odd frequency. This observation allows us to simplify the problem by only tracking the parity (even or odd) of the character frequencies. We don't need to store the actual frequency of each character - just whether it's odd or even is enough to solve the problem.</p>
<p>To efficiently track whether a character's frequency is even or odd, we can use bit manipulation. We can represent the frequencies as bits in an integer, where each bit corresponds to whether a particular character has an odd or even frequency. By toggling the corresponding bit for each character, we can keep track of the number of characters with odd frequencies.</p>
<p>Once we've processed the entire string, the number of odd-frequency characters is simply the count of <code>1</code> bits in the bitmask. If the number of odd-frequency characters is greater than <code>k</code>, it's impossible to form <code>k</code> palindromes, so we return <code>false</code>. If the number of odd-frequency characters is less than or equal to <code>k</code>, we can form <code>k</code> palindromes, and the answer will be <code>true</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Handle initial edge cases, comparing the length of <code>s</code> to <code>k</code>.
<ul>
<li>If the length of <code>s</code> is less than <code>k</code>, we return <code>false</code>, as we do not have enough characters to form k palindromes.</li>
<li>If the length of <code>s</code> is equal to <code>k</code>, we return <code>true</code>, as we can simply use each character of <code>s</code> to form a palindrome.</li>
</ul>
</li>
<li>Initialize an integer <code>oddCount</code>, which is used as a bitmask to track characters with odd frequencies</li>
<li>Iterate through <code>s</code>. For each character, we flip the bit tracking that character, with a set bit of <code>1</code> representing an odd frequency and a cleared bit <code>0</code> representing an even frequency</li>
<li>Return <code>true</code> if the number of <code>1</code> bits is less than or equal to <code>k</code>; return <code>false</code> otherwise.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/hynx4AUn/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The loop iterates over each character in the string <code>s</code>, which takes <span class="math inline">\(O(n)\)</span> time. The built-in function to count bits operates in <span class="math inline">\(O(1)\)</span> time since it works on a fixed-size integer (32 bits). Therefore, the overall time complexity is dominated by the loop, resulting in <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space required does not depend on the size of the input string, so only constant space is used.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-string-with-repeat-limit/description" target="_blank" rel="noopener noreferrer">Construct String With Repeat Limit</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and an integer <code>repeatLimit</code>. Construct a new string <code>repeatLimitedString</code> using the characters of <code>s</code> such that no letter appears <strong>more than</strong> <code>repeatLimit</code> times <strong>in a row</strong>. You do <strong>not</strong> have to use all characters from <code>s</code>.</p>

<p>Return <em>the <strong>lexicographically largest</strong> </em><code>repeatLimitedString</code> <em>possible</em>.</p>

<p>A string <code>a</code> is <strong>lexicographically larger</strong> than a string <code>b</code> if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears later in the alphabet than the corresponding letter in <code>b</code>. If the first <code>min(a.length, b.length)</code> characters do not differ, then the longer string is the lexicographically larger one.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cczazcc&quot;, repeatLimit = 3
<strong>Output:</strong> &quot;zzcccac&quot;
<strong>Explanation:</strong> We use all of the characters from s to construct the repeatLimitedString &quot;zzcccac&quot;.
The letter &#39;a&#39; appears at most 1 time in a row.
The letter &#39;c&#39; appears at most 3 times in a row.
The letter &#39;z&#39; appears at most 2 times in a row.
Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.
The string is the lexicographically largest repeatLimitedString possible so we return &quot;zzcccac&quot;.
Note that the string &quot;zzcccca&quot; is lexicographically larger but the letter &#39;c&#39; appears more than 3 times in a row, so it is not a valid repeatLimitedString.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aababab&quot;, repeatLimit = 2
<strong>Output:</strong> &quot;bbabaa&quot;
<strong>Explanation:</strong> We use only some of the characters from s to construct the repeatLimitedString &quot;bbabaa&quot;. 
The letter &#39;a&#39; appears at most 2 times in a row.
The letter &#39;b&#39; appears at most 2 times in a row.
Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.
The string is the lexicographically largest repeatLimitedString possible so we return &quot;bbabaa&quot;.
Note that the string &quot;bbabaaa&quot; is lexicographically larger but the letter &#39;a&#39; appears more than 2 times in a row, so it is not a valid repeatLimitedString.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= repeatLimit &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to construct the longest possible string under specific constraints, where no character can appear consecutively more than a given limit. A real-life application of this problem could be in designing passwords, where specific characters (letters, numbers, or symbols) need to be distributed without excessive repetition while adhering to complexity rules.</p>
<hr />
<h3 id="approach-1-greedy-character-frequency-distribution">Approach 1: Greedy Character Frequency Distribution</h3>
<h4 id="intuition">Intuition</h4>
<p>The key to solving this problem is to focus on the largest letters first, as they help create a string that’s lexicographically larger. However, we need to be careful not to use the same letter too many times in a row due to the limit on consecutive usage. To handle this, we should alternate between letters to avoid hitting the limit. This involves keeping track of how many times each letter has been used and strategically choosing the largest permissible letter at each step.</p>
<p>The process works like this: we start with the largest letter available and add as many of it as we can, stopping just before we reach the limit. Once we hit the limit, we switch to a smaller letter to &quot;break the streak&quot;. After adding the smaller letter, we can go back to the larger letter if it’s still available.</p>
<p>To switch to a smaller letter, we need to have one available as a &quot;breaker&quot;. If we run out of smaller letters to alternate with, we have to stop, because adding more characters would break the rule.</p>
<p>!?!../Documents/2182/2182.json:3000,1687!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create a frequency array (<code>freq</code>) of size 26 to count the occurrences of each character in the string.</p>
</li>
<li>
<p>Iterate over the string, mapping each character to its corresponding index, and increment the respective value in <code>freq</code>.</p>
</li>
<li>
<p>Initialize an empty list (<code>result</code>) to build the final result string.</p>
</li>
<li>
<p>Set a pointer (<code>current_char_index</code>) to 25, representing the largest character (<code>z</code>).</p>
</li>
<li>
<p>While <code>current_char_index</code> is greater than or equal to 0:</p>
<ul>
<li>If the frequency of the current character is zero, decrement <code>current_char_index</code> to move to the next smaller character and continue.</li>
<li>Determine how many times the current character can be added to the result consecutively (<code>use</code>), which is the minimum of its frequency and <code>repeatLimit</code>.</li>
<li>Append <code>use</code> instances of the character to the <code>result</code> list.</li>
<li>Subtract <code>use</code> from the frequency of the current character in <code>freq</code>.</li>
<li>If the current character still has remaining occurrences:
<ul>
<li>Find a smaller character to act as a breaker (<code>smaller_char_index</code>), starting from <code>current_char_index - 1</code>.</li>
<li>Decrement <code>smaller_char_index</code> until a character with a non-zero frequency is found.</li>
<li>If no such smaller character exists (all smaller frequencies are zero), break the loop as further construction of the result is not possible.</li>
<li>Append one instance of the smaller character to the <code>result</code>.</li>
<li>Decrement the frequency of the smaller character in <code>freq</code> by 1.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Join the characters in <code>result</code> to form the final string and return it.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/YqTEVUde/shared">code</a></p>
<p>Let <span class="math inline">\(N\)</span> be the length of <code>s</code> and <span class="math inline">\(K\)</span> be the number of unique characters in <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot K)\)</span></p>
<p>The time complexity of the approach is <span class="math inline">\(O(N \cdot K)\)</span>. The initial loop that counts character frequencies runs in <span class="math inline">\(O(N)\)</span> time.</p>
<p>The outer while loop executes at most <span class="math inline">\(K\)</span> times, which is at most 26 times for this problem since there are at most 26 unique characters in the input string. The inner while loop, which finds the next available character with a non-zero frequency, runs at most 25 times in the worst case.</p>
<p>For instance, consider the string <code>s = &quot;zzzzzzzaaaaaaa&quot;</code> with <code>repeatLimit = 1</code>. After exhausting the repeat limit for <code>z</code>, the inner loop iterates to locate <code>a</code>, which involves up to 25 steps. This results in an <span class="math inline">\(O(N \cdot K)\)</span> time complexity because for each character in the string of length <span class="math inline">\(N\)</span>, we may need to perform up to K operations to find the next available character.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(K)\)</span></p>
<p>The space used by the <code>freq</code> array is <span class="math inline">\(O(K)\)</span>, where <span class="math inline">\(K\)</span> is 26 characters at most.</p>
<p>The <code>result</code> will store the final string, which in the worst case will be of size <code>N</code>, but this is not considered in the space complexity analysis as it is part of the output.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(K)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-heap-optimized-greedy-character-frequency-distribution">Approach 2: Heap-Optimized Greedy Character Frequency Distribution</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The previous approach has a time complexity of <span class="math inline">\(O(N \cdot K)\)</span>, where <span class="math inline">\(K\)</span> represents the number of unique characters in <code>s</code>. Given that <span class="math inline">\(K\)</span> is small for this problem (a maximum of 26 unique characters), this time complexity is manageable. However, this method will become less efficient if we need to handle a larger set of unique characters. So, let's explore ways to optimize it further.</p>
<p>Since the main goal is to consistently pick the largest available character, it’s better to use a data structure that lets us quickly access and update the count of the character with the highest priority. A priority queue (or max heap) is perfect for this because it dynamically keeps the characters organized by priority. This way, instead of scanning all characters repeatedly, we can focus only on the most relevant ones.</p>
<p>As we build the string, we always pick the largest character first and add as many of it as the repeat limit allows. Once we hit the limit, we face the challenge of finding a &quot;breaker&quot; — a different character to interrupt the sequence.</p>
<p>To find this breaker, we look for the next largest character in the priority queue. If one is available, we add it to the string and decrease its count. After using it, we check if it still has more occurrences left; if it does, we put it back into the priority queue for future use.</p>
<p>If no breaker is available, the construction of the string stops. This happens because no other characters can be inserted without violating the constraints, making it impossible to continue building the string while maintaining both the repeat limit and lexicographical order.</p>
<blockquote>
<p>For a more comprehensive understanding of heaps and priority queues, check out the <a href="https://leetcode.com/explore/learn/card/heap/">Heap Explore Card 🔗</a>. This resource provides an in-depth look at heap-based algorithms, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Create a frequency map (<code>freq</code>) to count the occurrences of each character in the string.</p>
</li>
<li>
<p>Initialize a max-heap (<code>maxHeap</code>) to store the characters, ordered by their natural descending order.</p>
</li>
<li>
<p>Add all characters from the frequency map to the max-heap.</p>
</li>
<li>
<p>Initialize a string (<code>result</code>) to build the final result.</p>
</li>
<li>
<p>While the max-heap is not empty:</p>
<ul>
<li>Poll the character with the highest lexicographical value (<code>ch</code>) from the heap.</li>
<li>Retrieve its count from the frequency map (<code>freq</code>).</li>
<li>Determine the number of times the character can be used (<code>use</code>) as the minimum of <code>count</code> and <code>repeatLimit</code>.</li>
<li>Append <code>ch</code> to <code>result</code> exactly <code>use</code> times.</li>
<li>Update the frequency map for <code>ch</code> by subtracting <code>use</code>.</li>
<li>If <code>ch</code> still has remaining occurrences and the max-heap is not empty:
<ul>
<li>Poll the next character with the highest lexicographical value (<code>nextCh</code>) from the heap.</li>
<li>Append <code>nextCh</code> to <code>result</code>.</li>
<li>Decrease its frequency in the map by 1.</li>
<li>If <code>nextCh</code> still has occurrences remaining, reinsert it into the max-heap.</li>
<li>Reinsert <code>ch</code> into the max-heap to process its remaining occurrences.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the string representation of <code>result</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p><strong>Note:</strong> In the Python solution, we store the negative of the character's ordinal value (<code>-ord(c)</code>) in the heap to simulate a max-heap. This is necessary because Python's <code>heapq</code> library implements a min-heap by default. By negating the ordinal value, we ensure that characters with higher ASCII values (e.g., 'z') are prioritized when elements are popped from the heap, effectively mimicking the behavior of a max-heap.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/af9rN872/shared">code</a></p>
<p>Let <span class="math inline">\(N\)</span> be the length of <code>s</code> and <span class="math inline">\(K\)</span> be the number of unique characters in <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot \log K)\)</span></p>
<p>The time complexity of this approach is dominated by the operations on the heap, which is used to efficiently access and modify the most frequent characters. The size of the heap is bounded by the number of unique characters, denoted as <span class="math inline">\(K\)</span>, so the heap operations (push and pop) take <span class="math inline">\(O(\log K)\)</span> time.</p>
<p>In the worst case, we perform two heap operations for every character in the string, resulting in <span class="math inline">\(O(N)\)</span> heap operations. Each heap operation involves pushing or popping an element, which takes <span class="math inline">\(O(\log K)\)</span> time.</p>
<p>Therefore, the overall time complexity of the solution is <span class="math inline">\(O(N \cdot \log K)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(K)\)</span></p>
<p>The space complexity of this approach is <span class="math inline">\(O(K)\)</span>. This is because the heap and the frequency counter stores up to <span class="math inline">\(K\)</span> values.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-almost-equal-pairs-i/description" target="_blank" rel="noopener noreferrer">Count Almost Equal Pairs I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> consisting of positive integers.</p>

<p>We call two integers <code>x</code> and <code>y</code> in this problem <strong>almost equal</strong> if both integers can become equal after performing the following operation <strong>at most once</strong>:</p>

<ul>
	<li>Choose <strong>either</strong> <code>x</code> or <code>y</code> and swap any two digits within the chosen number.</li>
</ul>

<p>Return the number of indices <code>i</code> and <code>j</code> in <code>nums</code> where <code>i &lt; j</code> such that <code>nums[i]</code> and <code>nums[j]</code> are <strong>almost equal</strong>.</p>

<p><strong>Note</strong> that it is allowed for an integer to have leading zeros after performing an operation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,12,30,17,21]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The almost equal pairs of elements are:</p>

<ul>
	<li>3 and 30. By swapping 3 and 0 in 30, you get 3.</li>
	<li>12 and 21. By swapping 1 and 2 in 12, you get 21.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,1,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">10</span></p>

<p><strong>Explanation:</strong></p>

<p>Every two elements in the array are almost equal.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [123,231]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>We cannot swap any two digits of 123 or 231 to reach the other.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-almost-equal-pairs-ii/description" target="_blank" rel="noopener noreferrer">Count Almost Equal Pairs II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><strong>Attention</strong>: In this version, the number of operations that can be performed, has been increased to <strong>twice</strong>.<!-- notionvc: 278e7cb2-3b05-42fa-8ae9-65f5fd6f7585 --></p>

<p>You are given an array <code>nums</code> consisting of positive integers.</p>

<p>We call two integers <code>x</code> and <code>y</code> <strong>almost equal</strong> if both integers can become equal after performing the following operation <strong>at most <u>twice</u></strong>:</p>

<ul>
	<li>Choose <strong>either</strong> <code>x</code> or <code>y</code> and swap any two digits within the chosen number.</li>
</ul>

<p>Return the number of indices <code>i</code> and <code>j</code> in <code>nums</code> where <code>i &lt; j</code> such that <code>nums[i]</code> and <code>nums[j]</code> are <strong>almost equal</strong>.</p>

<p><strong>Note</strong> that it is allowed for an integer to have leading zeros after performing an operation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1023,2310,2130,213]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The almost equal pairs of elements are:</p>

<ul>
	<li>1023 and 2310. By swapping the digits 1 and 2, and then the digits 0 and 3 in 1023, you get 2310.</li>
	<li>1023 and 213. By swapping the digits 1 and 0, and then the digits 1 and 2 in 1023, you get 0213, which is 213.</li>
	<li>2310 and 213. By swapping the digits 2 and 0, and then the digits 3 and 2 in 2310, you get 0213, which is 213.</li>
	<li>2310 and 2130. By swapping the digits 3 and 1 in 2310, you get 2130.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,10,100]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The almost equal pairs of elements are:</p>

<ul>
	<li>1 and 10. By swapping the digits 1 and 0 in 10, you get 01 which is 1.</li>
	<li>1 and 100. By swapping the second 0 with the digit 1 in 100, you get 001, which is 1.</li>
	<li>10 and 100. By swapping the first 0 with the digit 1 in 100, you get 010, which is 10.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>1 &lt;= nums[i] &lt; 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-anagrams/description" target="_blank" rel="noopener noreferrer">Count Anagrams</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">combinatorics</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> containing one or more words. Every consecutive pair of words is separated by a single space <code>&#39; &#39;</code>.</p>

<p>A string <code>t</code> is an <strong>anagram</strong> of string <code>s</code> if the <code>i<sup>th</sup></code> word of <code>t</code> is a <strong>permutation</strong> of the <code>i<sup>th</sup></code> word of <code>s</code>.</p>

<ul>
	<li>For example, <code>&quot;acb dfe&quot;</code> is an anagram of <code>&quot;abc def&quot;</code>, but <code>&quot;def cab&quot;</code>&nbsp;and <code>&quot;adc bef&quot;</code> are not.</li>
</ul>

<p>Return <em>the number of <strong>distinct anagrams</strong> of </em><code>s</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;too hot&quot;
<strong>Output:</strong> 18
<strong>Explanation:</strong> Some of the anagrams of the given string are &quot;too hot&quot;, &quot;oot hot&quot;, &quot;oto toh&quot;, &quot;too toh&quot;, and &quot;too oht&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aa&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is only one anagram possible for the given string.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters and spaces <code>&#39; &#39;</code>.</li>
	<li>There is single space between consecutive words.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-common-words-with-one-occurrence/description" target="_blank" rel="noopener noreferrer">Count Common Words With One Occurrence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two string arrays <code>words1</code> and <code>words2</code>, return <em>the number of strings that appear <strong>exactly once</strong> in <b>each</b>&nbsp;of the two arrays.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words1 = [&quot;leetcode&quot;,&quot;is&quot;,&quot;amazing&quot;,&quot;as&quot;,&quot;is&quot;], words2 = [&quot;amazing&quot;,&quot;leetcode&quot;,&quot;is&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
- &quot;leetcode&quot; appears exactly once in each of the two arrays. We count this string.
- &quot;amazing&quot; appears exactly once in each of the two arrays. We count this string.
- &quot;is&quot; appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.
- &quot;as&quot; appears once in words1, but does not appear in words2. We do not count this string.
Thus, there are 2 strings that appear exactly once in each of the two arrays.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words1 = [&quot;b&quot;,&quot;bb&quot;,&quot;bbb&quot;], words2 = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no strings that appear in each of the two arrays.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words1 = [&quot;a&quot;,&quot;ab&quot;], words2 = [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;ab&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only string that appears exactly once in each of the two arrays is &quot;ab&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words1.length, words2.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words1[i].length, words2[j].length &lt;= 30</code></li>
	<li><code>words1[i]</code> and <code>words2[j]</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-elements-with-maximum-frequency/description" target="_blank" rel="noopener noreferrer">Count Elements With Maximum Frequency</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> consisting of <strong>positive</strong> integers.</p>

<p>Return <em>the <strong>total frequencies</strong> of elements in</em><em> </em><code>nums</code>&nbsp;<em>such that those elements all have the <strong>maximum</strong> frequency</em>.</p>

<p>The <strong>frequency</strong> of an element is the number of occurrences of that element in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,3,1,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> 5
<strong>Explanation:</strong> All elements of the array have a frequency of 1 which is the maximum.
So the number of elements in the array with maximum frequency is 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array, <code>nums</code>, of positive integers.</p>
<blockquote>
<p>The <strong>frequency</strong> of an element is the number of occurrences of that element in the array.</p>
</blockquote>
<p>To solve the problem, we need to determine the element with the maximum frequency. Then, we need to find the sum of the number of occurrences of all elements that have the maximum frequency.</p>
<p>We can break this problem down into three main steps:</p>
<ol>
<li>Find the frequency of each element in <code>nums</code>.</li>
<li>Determine the maximum frequency.</li>
<li>Calculate the total frequencies of elements with the maximum frequency.</li>
</ol>
<hr />
<h3 id="approach-1-count-frequency-and-max-frequency">Approach 1: Count Frequency and Max Frequency</h3>
<h4 id="intuition">Intuition</h4>
<h5 id="1-find-the-frequency-of-each-element-in-nums">1. Find the frequency of each element in <code>nums</code>.</h5>
<p>The frequency of an element is the count of occurrences of that element. We can find the frequency of each element in <code>nums</code> by counting the number of occurrences of each element. We can create a map <code>frequencies</code> to store the frequency of each element. The key is the element, and the value is its frequency. To calculate the frequencies, we iterate through <code>nums</code>, incrementing the frequency of each number in <code>nums</code> by <code>1</code>.</p>
<h5 id="2-determine-the-maximum-frequency">2. Determine the maximum frequency.</h5>
<p>To find the maximum frequency, we iterate over <code>frequencies</code>, comparing each frequency to <code>maxFrequency</code> and updating <code>maxFrequency</code> each time we find a larger frequency.</p>
<h5 id="3-calculate-the-total-frequencies-of-elements-with-the-maximum-frequency">3. Calculate the total frequencies of elements with the maximum frequency.</h5>
<p>To find total frequencies, we can count the number of elements that have the maximum frequency. We can store the running count in the variable <code>frequencyOfMaxFrequency</code>.</p>
<p>To find <code>frequencyOfMaxFrequency</code>, we iterate over <code>frequencies</code>, incrementing <code>frequencyOfMaxFrequency</code> by <code>1</code> for all elements with the frequency <code>maxFrequency</code>.</p>
<p>We multiply <code>frequencyOfMaxFrequency</code> by <code>maxFrequency</code> to calculate the total frequencies of elements with the maximum frequency.</p>
<h6 id="example">Example:</h6>
<blockquote>
<p><strong>Input:</strong> nums = [1, 2, 2, 3, 1, 4]</p>
<p><strong>Step 1</strong><br />
Frequency Map:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>Frequency</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><strong>Step 2</strong><br />
<code>maxFrequency = 2</code></p>
<p><strong>Step 3</strong><br />
<code>frequencyOfMaxFrequency = 2</code><br />
<code>frequencyOfMaxFrequency * maxFrequency = 2 * 2 = 4</code></p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a map <code>frequencies</code> to store the frequency of each element. The key is the element, and the value is its frequency.</li>
<li>For each number in <code>nums</code>:
<ol>
<li>Increment its frequency by <code>1</code> for each occurrence.</li>
</ol>
</li>
<li>Initialize a variable <code>maxFrequency</code> to <code>0</code>.</li>
<li>For each <code>frequency</code> in <code>frequencies</code>:
<ol>
<li>Calculate the maximum between the <code>frequency</code> and <code>maxFrequency</code>, updating <code>maxFrequency</code> when we find a larger frequency.</li>
</ol>
</li>
<li>Initialize a variable <code>frequencyOfMaxFrequency</code> to <code>0</code>.</li>
<li>For each frequency in <code>frequencies</code>:
<ol>
<li>If <code>frequency</code> equals <code>maxFrequency</code>:
<ol>
<li>Increment <code>frequencyOfMaxFrequency</code> by <code>1</code>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <code>frequencyOfMaxFrequency * maxFrequency</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/h6Jbtdmx/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Calculating the frequency of each element in <code>nums</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Finding the maximum frequency takes <span class="math inline">\(O(e)\)</span> where <span class="math inline">\(e\)</span> is the number of distinct elements in <code>nums</code>. At worst, there can be <span class="math inline">\(n\)</span> distinct elements, so this step takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Calculating total frequencies takes <span class="math inline">\(O(e)\)</span> where <span class="math inline">\(e\)</span> is the number of distinct elements in <code>nums</code>. At worst, there can be <span class="math inline">\(n\)</span> distinct elements, so this step takes <span class="math inline">\(O(n)\)</span>.</p>
<p>The total time complexity will be <span class="math inline">\(O(3n)\)</span>, which we can simplify to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use a few variables and the map <code>frequencies</code>, which is size <span class="math inline">\(O(e)\)</span> where <span class="math inline">\(e\)</span> is the number of distinct elements in <code>nums</code>. At worst, there can be <span class="math inline">\(n\)</span> distinct elements, so the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sort-frequencies-and-sum-max-frequencies">Approach 2: Sort Frequencies and Sum Max Frequencies</h3>
<h4 id="intuition-1">Intuition</h4>
<h5 id="1-find-the-frequency-of-each-element-in-nums-1">1. Find the frequency of each element in <code>nums</code>.</h5>
<p>We can find the frequency of each element in <code>nums</code> by counting the number of occurrences of each element. An alternative to using a map is an array <code>frequencies</code> to store the frequency of each element. The frequency of an element is stored at <code>frequency[element - 1]</code>.</p>
<p>Since the array is zero-indexed, the frequency of <code>1</code> is stored at <code>frequencies[0]</code>, the frequency of <code>2</code> is stored at <code>frequencies[1]</code>, and the frequency of <code>100</code> is stored at <code>frequencies[99]</code>. We will initialize <code>frequencies</code> to size <code>100</code>, because the maximum element in nums is guaranteed to be between <code>1</code> and <code>100</code> inclusive according to the constraints. To calculate the frequencies, we iterate through <code>nums</code>, incrementing the frequency of the current element by <code>1</code>.</p>
<p><strong>Note:</strong></p>
<p>Using an array for frequency counting has a constant time complexity for both insertion and retrieval operations, which can be faster than the average case time complexity of hashmap operations. However, this advantage comes with a trade-off—arrays are only suitable when the range of values is relatively small and can be mapped directly to array indices.</p>
<p>If your input values can be negative or have a very large range, using a hashmap might be a more flexible and efficient option. Hashmaps generally have an average-case time complexity of <span class="math inline">\(O(1)\)</span> for insertion and retrieval operations, but they may have a higher constant factor compared to array operations.</p>
<h5 id="2-determine-the-maximum-frequency-1">2. Determine the maximum frequency.</h5>
<p>To find the maximum frequency, we sort <code>frequencies</code>, which will group all of the elements occurring <code>maxFrequency</code> times towards the end of the array.</p>
<p>The last index of <code>frequencies</code> contains the element with the maximum frequency.</p>
<p><strong>Note:</strong> Once <code>frequencies</code> have been sorted, the index of a particular element no longer corresponds to the frequency of that element. The array essentially becomes an array of frequencies. The final answer only concerns frequencies and not the values of the elements, so this does not cause an issue.</p>
<h5 id="3-calculate-the-total-frequencies-of-elements-with-the-maximum-frequency-1">3. Calculate the total frequencies of elements with the maximum frequency.</h5>
<p>To find <code>totalFrequencies</code>, we iterate over <code>frequencies</code>, starting with the last index. We traverse over frequencies from right to left, adding the frequency of all elements with the frequency <code>maxFrequency</code> to <code>totalFrequencies</code>. Once we reach a frequency less than <code>maxFrequency</code>, we return <code>totalFrequencies</code>; no other elements will have <code>maxFrequency</code>, since the frequencies are sorted.</p>
<h5 id="example-1">Example:</h5>
<blockquote>
<p><strong>Input:</strong> nums = [1, 2, 2, 3, 1, 4]</p>
<p><strong>Step 1</strong><br />
Frequency Array:</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>...</th>
<th>99</th>
</tr>
</thead>
<tbody>
<tr>
<td>Element</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>...</td>
<td>100</td>
</tr>
<tr>
<td>Frequency</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>...</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><strong>Step 2</strong><br />
Frequency Array Sorted:</p>
<table>
<thead>
<tr>
<th>Frequency</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>...</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>2</th>
</tr>
</thead>
</table>
<p><code>totalFrequencies = 2</code> // Initialized to the maximum frequency</p>
<p><strong>Step 3</strong><br />
<code>totalFrequencies = 2 + 2 = 4</code></p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an array <code>frequencies</code> of size <code>100</code> to store the frequency of each element. The frequency of an element is stored at <code>frequency[element - 1]</code></li>
<li>For each number in <code>nums</code>:
<ol>
<li>Increment its frequency by <code>1</code> for each occurrence.</li>
</ol>
</li>
<li>Sort <code>frequencies</code>.</li>
<li>Initialize a variable <code>maxFreqIndex</code> to the last index of <code>frequencies</code>, where the maximum frequency is stored.</li>
<li>Initialize a variable <code>totalFrequencies</code> to <code>frequencies[maxFreqIndex]</code>, which is the maximum frequency.</li>
<li>Iterate through <code>frequencies</code>, starting from <code>maxFreqIndex</code>and traversing right to left. While <code>frequency</code> equals <code>maxFrequency</code>:
<ol>
<li>Add <code>frequency</code> to <code>totalFrequencies</code>.</li>
<li>Decrement <code>maxFreqIndex</code> by <code>1</code>.</li>
</ol>
</li>
<li>When we break from the loop, return <code>totalFrequencies</code>, because if the current frequency isn't the max frequency, none of the following will be either, since the array is sorted.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GvAFYwyj/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums</code>. Let <span class="math inline">\(m\)</span> be the maximum value in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \log m)\)</span></p>
<p>Calculating the frequency of each element in <code>nums</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p><code>frequencies</code> is of size <span class="math inline">\(m\)</span>, so sorting <code>frequencies</code> takes <span class="math inline">\(O(m \log m)\)</span>.</p>
<p>Calculating total frequencies takes <span class="math inline">\(O(m)\)</span> in the worst case when each element occurs the same number of times.</p>
<p>The total time complexity will be <span class="math inline">\(O(n + m \log m + m)\)</span>, which we can simplify to <span class="math inline">\(O(n + m \log m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>We use a few variables and the array <code>frequencies</code>, which is size <span class="math inline">\(O(m)\)</span></p>
<p>Note that some extra space is used when we sort <code>frequencies</code> in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(m)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log m)\)</span> for sorting an array.</li>
<li>In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log m )\)</span>.</li>
</ul>
<p>The dominating term is <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-one-pass-sum-max-frequencies">Approach 3: One-Pass Sum Max Frequencies</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The above approaches both iterate through <code>nums</code> once and through an array or map <code>frequencies</code> at least once.</p>
<blockquote>
<p>Is it possible to solve this problem in just one pass?</p>
</blockquote>
<h5 id="1-find-the-frequency-of-each-element-in-nums-2">1. Find the frequency of each element in <code>nums</code>.</h5>
<p>We must iterate through <code>nums</code> to determine the frequency of each element. In this approach, saving the frequencies in an additional data structure, an array or map <code>frequencies</code> is still useful.</p>
<h5 id="2-determine-the-maximum-frequency-2">2. Determine the maximum frequency.</h5>
<blockquote>
<p>Can we determine the maximum frequency during the same pass as finding the frequencies of the elements?</p>
</blockquote>
<p>We just need to update <code>maxFrequency</code> each time we find a frequency that is larger than the current <code>maxFrequency</code>.</p>
<h5 id="3-calculate-the-total-frequencies-of-elements-with-the-maximum-frequency-2">3. Calculate the total frequencies of elements with the maximum frequency.</h5>
<blockquote>
<p>Can we calculate the total frequencies during the same pass as finding the frequencies of the elements?</p>
</blockquote>
<blockquote>
<p>What if we discover an element with the same frequency as the maximum frequency?</p>
</blockquote>
<p>Each time we find an element with a frequency that equals the max frequency, we can add the frequency of that element to <code>totalFrequency</code>.</p>
<blockquote>
<p>What if we discover a higher-frequency element?</p>
</blockquote>
<p>We will update <code>maxFrequency</code> as stated above. We can also re-set <code>totalFrequencies</code> to the element's frequency, because when we discover a new <code>maxFrequency</code>, there is only one element so far with that frequency, and all previous elements with the previous <code>maxFrequency</code> are no longer relevant.</p>
<p>After iterating through <code>nums</code> once, we will have calculated <code>totalFrequencies</code> accurately and can return.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/3005/3005_slideshow.json:960,540!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize a map <code>frequencies</code> to store the frequency of each element. The key is the element, and the value is its frequency.</li>
<li>Initialize a variable <code>maxFrequency</code> to <code>0</code>.</li>
<li>Initialize a variable <code>totalFrequencies</code> to <code>0</code>.</li>
<li>For each number in <code>nums</code>:
<ol>
<li>Increment its frequency by <code>1</code> for each occurrence.</li>
<li>Initialize a variable <code>frequency</code> storing the current element's frequency.</li>
<li>If <code>frequency</code> is greater than <code>maxFrequency</code>:
<ol>
<li>Update <code>maxFrequency</code> with <code>frequency</code>.</li>
<li>Set <code>totalFrequencies</code> to <code>frequency</code>. This will reset the sum to the current highest frequency since any previous highest frequencies are no longer the max.</li>
</ol>
</li>
<li>Else if <code>frequency</code> equals <code>maxFrequency</code>:
<ol>
<li>Add <code>frequency</code> to <code>totalFrequencies</code>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <code>totalFrequencies</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/6txG2r4t/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over <code>nums</code> once and perform <span class="math inline">\(O(1)\)</span> work with each operation, so the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use a few variables and the map <code>frequencies</code>, which is size <span class="math inline">\(O(e)\)</span> where <span class="math inline">\(e\)</span> is the number of distinct elements in <code>nums</code>. At worst, there can be <span class="math inline">\(n\)</span> distinct elements, so the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/description" target="_blank" rel="noopener noreferrer">Count Elements With Strictly Smaller and Greater Elements </a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>the number of elements that have <strong>both</strong> a strictly smaller and a strictly greater element appear in </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [11,7,2,15]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.
Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.
In total there are 2 elements having both a strictly smaller and a strictly greater element appear in <code>nums</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-3,3,3,90]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.
Since there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in <code>nums</code>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-nice-pairs-in-an-array/description" target="_blank" rel="noopener noreferrer">Count Nice Pairs in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> that consists of non-negative integers. Let us define <code>rev(x)</code> as the reverse of the non-negative integer <code>x</code>. For example, <code>rev(123) = 321</code>, and <code>rev(120) = 21</code>. A pair of indices <code>(i, j)</code> is <strong>nice</strong> if it satisfies all of the following conditions:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; nums.length</code></li>
	<li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li>
</ul>

<p>Return <em>the number of nice pairs of indices</em>. Since that number can be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [42,11,1,97]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The two pairs are:
 - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
 - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [13,10,35,24,76]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-counting-with-hash-map">Approach: Counting With Hash Map</h3>
<p><strong>Intuition</strong></p>
<p>In this problem, we are presented with the following formula:</p>
<p><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></p>
<p>Let's denote <code>x = nums[i]</code> and <code>y = nums[j]</code> and rewrite the formula:</p>
<p><code>x + rev(y) == y + rev(x)</code></p>
<p>Now, let's rearrange the formula so that all terms involving <code>x</code> are on one side and all terms involving <code>y</code> are on the other:</p>
<p><code>x - rev(x) == y - rev(y)</code></p>
<p>We have simplified the problem. As you can see, for a given <code>num</code>, we are interested in <code>num - rev(num)</code>. Let's define a new array <code>arr</code> with the same length as <code>nums</code> where:</p>
<p><code>arr[i] = nums[i] - rev(nums[i])</code></p>
<p><img src="../Figures/1814/1.png" alt="example" /><br />
<br></p>
<p>To reverse the digits of a given integer <code>num</code> as described by the problem, we can initialize an integer <code>result = 0</code> as the reversed number. We then continuously take the last digit of <code>num</code> using the modulo operator <code>%</code> and append it to <code>result</code> as the least significant digit, this could be done by multiplying <code>result</code> by 10 and adding the last digit. Then we remove the last digit from <code>num</code> by dividing it by 10.</p>
<p>The process above continues until <code>num</code> becomes 0, at which point, <code>result</code> contains the reversed integer.</p>
<p>Now, the problem becomes &quot;how many pairs in <code>arr</code> are equal?&quot;. This can be solved using a counting trick with a hash map. We will iterate over <code>arr</code> and keep a hash map <code>dic</code> (short for dictionary) that keeps track of how many times we have seen a number. For each <code>num</code> we iterate over, we check how many times we have already seen <code>num</code>. Each <code>num</code> we had already seen earlier can be paired with the current <code>num</code> to form a pair. Thus, we would add <code>dic[num]</code> to the answer, and finally increment <code>dic[num]</code> by 1, keeping track of the current <code>num</code>.</p>
<p>The following animation demonstrates this counting process using an arbitrary <code>arr</code>:</p>
<p>!?!../Documents/1814.json:960,540!?!<br />
<br></p>
<p><strong>Algorithm</strong></p>
<p>Note: to avoid overflow, calculating the answer should be done MOD <span class="math inline">\(10^9 + 7\)</span>.</p>
<ol>
<li>Implement the function <code>rev</code> as described by the problem description.</li>
<li>Create <code>arr</code>, where <code>arr[i] = nums[i] - rev(nums[i])</code>.</li>
<li>Initialize an empty hash map <code>dic</code> and the answer variable, <code>ans</code>.</li>
<li>Iterate over each <code>num</code> in <code>arr</code>:
<ul>
<li>Add <code>dic[num]</code> to <code>ans</code>.</li>
<li>Increment <code>dic[num]</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/99Zk9bgZ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>First, we create <code>arr</code> which costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we iterate over <code>arr</code> which has a length of <code>n</code>. At each iteration, we perform <span class="math inline">\(O(1)\)</span> work, so this costs <span class="math inline">\(O(n)\)</span> as well.</p>
<p>Note that <code>rev(num)</code> has a cost that is logarithmic with <code>num</code>. However, it is standard on LeetCode to treat the size of integers and mathematical operations performed on them as <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>arr</code> uses <span class="math inline">\(O(n)\)</span> space. In the scenario where all <code>num - rev(num)</code> is unique, then <code>dic</code> will also grow to a size of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-number-of-bad-pairs/description" target="_blank" rel="noopener noreferrer">Count Number of Bad Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. A pair of indices <code>(i, j)</code> is a <strong>bad pair</strong> if <code>i &lt; j</code> and <code>j - i != nums[j] - nums[i]</code>.</p>

<p>Return<em> the total number of <strong>bad pairs</strong> in </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,1,3,3]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.
The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.
The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.
The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.
The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.
There are a total of 5 bad pairs, so we return 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no bad pairs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-hash-map">Approach: Hash Map</h3>
<h4 id="intuition">Intuition</h4>
<p>First, let's understand what makes a pair &quot;good&quot; rather than &quot;bad&quot;. For any two positions <code>i</code> and <code>j</code> in our array, they form a good pair if the difference between their positions equals the difference between their values. Mathematically, we can write this as: <code>j - i = nums[j] - nums[i]</code>.</p>
<p>Rearranging this equation gives us:</p>
<p><span class="math display">\[\begin{aligned}
j - nums[j] = i - nums[i]
\end{aligned}
\]</span></p>
<p>This transformation highlights a key insight: for two positions to form a good pair, the difference between their position and their value (<code>position - value</code>) must be the same. In other words, the value of <code>j - nums[j]</code> must match the value of <code>i - nums[i]</code>. This &quot;<code>position - value</code>&quot; difference is the key to identifying good pairs.</p>
<p>For example, if the array is <code>nums = [1, 1, 2, 1]</code> at positions <code>0, 1, 2, 3</code>, then calculating <code>position - number</code> gives us <code>[-1, 0, 0, 2]</code>. Here, positions <code>1</code> and <code>2</code> both have the same tag <code>0</code>, forming a good pair.</p>
<p>As the number of bad pairs would be the total number of pairs minus the number of good pairs, let's focus on finding the number of good pairs each element can make. Since an element can form a good pair only with elements occurring before it, we can iterate over the <code>nums</code> array and keep a running count of all the good pairs we find.</p>
<p>We can use a hash map to keep track of the counts of each <code>position - number</code> value as we iterate through the array. For each index <code>j</code>, the value <code>j - nums[j]</code> tells us how many indices before <code>j</code> could form good pairs with it. These counts are stored in the hash map.</p>
<ul>
<li>For an index <code>j</code>, all previous indices <code>0</code> to <code>j - 1</code> can potentially form pairs with it. This means <code>j</code> total pairs are possible.</li>
<li>Out of these, the number of good pairs is determined by the count of <code>j - nums[j]</code> stored in the hash map.</li>
<li>The difference between the total pairs (<code>j</code>) and the good pairs gives the number of bad pairs contributed by <code>nums[j]</code>.</li>
</ul>
<p>As we iterate, we keep updating the hash map with the current <code>position - number</code> values and accumulate the count of bad pairs. After processing the entire array, we return the total count of bad pairs.</p>
<p>The slideshow below demonstrates the algorithm in action:</p>
<p>!?!../Documents/2364/slideshow.json:710,862!?!</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card 🔗</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize:</p>
<ul>
<li>a variable <code>badPairs</code> to <code>0</code> to keep track of the total count of bad pairs.</li>
<li>a hash map <code>diffCount</code> to store the frequency of differences between position and value.</li>
</ul>
</li>
<li>
<p>For each position <code>pos</code> from <code>0</code> to the length of the array:</p>
<ul>
<li>Calculate the difference between the current position and its value (<code>pos - nums[pos]</code>).</li>
<li>Get the count of previous positions that had the same difference value, defaulting to <code>0</code> if not found.</li>
<li>Add to <code>badPairs</code> the number of total possible pairs up to the current position (<code>pos</code>) minus the count of good pairs (<code>goodPairsCount</code>).</li>
<li>Update the frequency map by incrementing the count for the current difference by <code>1</code>.</li>
</ul>
</li>
<li>
<p>Return the total count of bad pairs stored in <code>badPairs</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/WwHyeiak/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the array exactly once. At each position, the operations performed (calculating difference, accessing, and updating the hash map) are all <span class="math inline">\(O(1)\)</span> on average. Therefore, the total time complexity is linear with respect to the array length.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a hash map to store differences between position and value. In the worst case, each position could have a unique difference value, causing the hash map to store <span class="math inline">\(n\)</span> key-value pairs. No other data structures that scale with input size are used. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-number-of-distinct-integers-after-reverse-operations/description" target="_blank" rel="noopener noreferrer">Count Number of Distinct Integers After Reverse Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> consisting of <strong>positive</strong> integers.</p>

<p>You have to take each integer in the array, <strong>reverse its digits</strong>, and add it to the end of the array. You should apply this operation to the original integers in <code>nums</code>.</p>

<p>Return <em>the number of <strong>distinct</strong> integers in the final array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,13,10,12,31]
<strong>Output:</strong> 6
<strong>Explanation:</strong> After including the reverse of each number, the resulting array is [1,13,10,12,31,<u>1,31,1,21,13</u>].
The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1.
The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31).</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> After including the reverse of each number, the resulting array is [2,2,2,<u>2,2,2</u>].
The number of distinct integers in this array is 1 (The number 2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/description" target="_blank" rel="noopener noreferrer">Count Number of Pairs With Absolute Difference K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of pairs</em> <code>(i, j)</code> <em>where</em> <code>i &lt; j</code> <em>such that</em> <code>|nums[i] - nums[j]| == k</code>.</p>

<p>The value of <code>|x|</code> is defined as:</p>

<ul>
	<li><code>x</code> if <code>x &gt;= 0</code>.</li>
	<li><code>-x</code> if <code>x &lt; 0</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,1], k = 1
<strong>Output:</strong> 4
<strong>Explanation:</strong> The pairs with an absolute difference of 1 are:
- [<strong><u>1</u></strong>,<strong><u>2</u></strong>,2,1]
- [<strong><u>1</u></strong>,2,<strong><u>2</u></strong>,1]
- [1,<strong><u>2</u></strong>,2,<strong><u>1</u></strong>]
- [1,2,<strong><u>2</u></strong>,<strong><u>1</u></strong>]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3], k = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no pairs with an absolute difference of 3.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1,5,4], k = 2
<strong>Output:</strong> 3
<b>Explanation:</b> The pairs with an absolute difference of 2 are:
- [<strong><u>3</u></strong>,2,<strong><u>1</u></strong>,5,4]
- [<strong><u>3</u></strong>,2,1,<strong><u>5</u></strong>,4]
- [3,<strong><u>2</u></strong>,1,5,<strong><u>4</u></strong>]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 200</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= 99</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-of-nodes/description" target="_blank" rel="noopener noreferrer">Count Pairs Of Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">graph</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected graph defined by an integer <code>n</code>, the number of nodes, and a 2D integer array <code>edges</code>, the edges in the graph, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an <strong>undirected</strong> edge between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>. You are also given an integer array <code>queries</code>.</p>

<p>Let <code>incident(a, b)</code> be defined as the <strong>number of edges</strong> that are connected to <strong>either</strong> node <code>a</code> or <code>b</code>.</p>

<p>The answer to the <code>j<sup>th</sup></code> query is the <strong>number of pairs</strong> of nodes <code>(a, b)</code> that satisfy <strong>both</strong> of the following conditions:</p>

<ul>
	<li><code>a &lt; b</code></li>
	<li><code>incident(a, b) &gt; queries[j]</code></li>
</ul>

<p>Return <em>an array </em><code>answers</code><em> such that </em><code>answers.length == queries.length</code><em> and </em><code>answers[j]</code><em> is the answer of the </em><code>j<sup>th</sup></code><em> query</em>.</p>

<p>Note that there can be <strong>multiple edges</strong> between the same two nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/winword_2021-06-08_00-58-39.png" style="width: 529px; height: 305px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
<strong>Output:</strong> [6,5]
<strong>Explanation:</strong> The calculations for incident(a, b) are shown in the table above.
The answers for each of the queries are as follows:
- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.
- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
<strong>Output:</strong> [10,10,9,8,6]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>0 &lt;= queries[j] &lt; edges.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-of-similar-strings/description" target="_blank" rel="noopener noreferrer">Count Pairs Of Similar Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Two strings are <strong>similar</strong> if they consist of the same characters.</p>

<ul>
	<li>For example, <code>&quot;abca&quot;</code> and <code>&quot;cba&quot;</code> are similar since both consist of characters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</li>
	<li>However, <code>&quot;abacba&quot;</code> and <code>&quot;bcfd&quot;</code> are not similar since they do not consist of the same characters.</li>
</ul>

<p>Return <em>the number of pairs </em><code>(i, j)</code><em> such that </em><code>0 &lt;= i &lt; j &lt;= word.length - 1</code><em> and the two strings </em><code>words[i]</code><em> and </em><code>words[j]</code><em> are similar</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aba&quot;,&quot;aabb&quot;,&quot;abcd&quot;,&quot;bac&quot;,&quot;aabc&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 pairs that satisfy the conditions:
- i = 0 and j = 1 : both words[0] and words[1] only consist of characters &#39;a&#39; and &#39;b&#39;. 
- i = 3 and j = 4 : both words[3] and words[4] only consist of characters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aabb&quot;,&quot;ab&quot;,&quot;ba&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 pairs that satisfy the conditions:
- i = 0 and j = 1 : both words[0] and words[1] only consist of characters &#39;a&#39; and &#39;b&#39;. 
- i = 0 and j = 2 : both words[0] and words[2] only consist of characters &#39;a&#39; and &#39;b&#39;.
- i = 1 and j = 2 : both words[1] and words[2] only consist of characters &#39;a&#39; and &#39;b&#39;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;nba&quot;,&quot;cba&quot;,&quot;dba&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since there does not exist any pair that satisfies the conditions, we return 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
	<li><code>words[i]</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-that-form-a-complete-day-i/description" target="_blank" rel="noopener noreferrer">Count Pairs That Form a Complete Day I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>hours</code> representing times in <strong>hours</strong>, return an integer denoting the number of pairs <code>i</code>, <code>j</code> where <code>i &lt; j</code> and <code>hours[i] + hours[j]</code> forms a <strong>complete day</strong>.</p>

<p>A <strong>complete day</strong> is defined as a time duration that is an <strong>exact</strong> <strong>multiple</strong> of 24 hours.</p>

<p>For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">hours = [12,12,30,24,24]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The pairs of indices that form a complete day are <code>(0, 1)</code> and <code>(3, 4)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">hours = [72,48,24,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The pairs of indices that form a complete day are <code>(0, 1)</code>, <code>(0, 2)</code>, and <code>(1, 2)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= hours.length &lt;= 100</code></li>
	<li><code>1 &lt;= hours[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-that-form-a-complete-day-ii/description" target="_blank" rel="noopener noreferrer">Count Pairs That Form a Complete Day II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>hours</code> representing times in <strong>hours</strong>, return an integer denoting the number of pairs <code>i</code>, <code>j</code> where <code>i &lt; j</code> and <code>hours[i] + hours[j]</code> forms a <strong>complete day</strong>.</p>

<p>A <strong>complete day</strong> is defined as a time duration that is an <strong>exact</strong> <strong>multiple</strong> of 24 hours.</p>

<p>For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">hours = [12,12,30,24,24]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong> The pairs of indices that form a complete day are <code>(0, 1)</code> and <code>(3, 4)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">hours = [72,48,24,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong> The pairs of indices that form a complete day are <code>(0, 1)</code>, <code>(0, 2)</code>, and <code>(1, 2)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= hours.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= hours[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-servers-that-communicate/description" target="_blank" rel="noopener noreferrer">Count Servers that Communicate</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a map of a server center, represented as a <code>m * n</code> integer matrix&nbsp;<code>grid</code>, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.<br />
<br />
Return the number of servers&nbsp;that communicate with any other server.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-6.jpg" style="width: 202px; height: 203px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,1]]
<strong>Output:</strong> 0
<b>Explanation:</b>&nbsp;No servers can communicate with others.</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/11/13/untitled-diagram-4.jpg" style="width: 203px; height: 203px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[1,1]]
<strong>Output:</strong> 3
<b>Explanation:</b>&nbsp;All three servers can communicate with at least one other server.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-1-3.jpg" style="width: 443px; height: 443px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
<strong>Output:</strong> 4
<b>Explanation:</b>&nbsp;The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 250</code></li>
	<li><code>1 &lt;= n &lt;= 250</code></li>
	<li><code>grid[i][j] == 0 or 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a grid representing a server center in the form of a matrix of size <code>m x n</code>. Each cell of the matrix contains either a <code>1</code>, indicating the presence of a server, or a <code>0</code>, indicating an empty space.</p>
<p>We need to return the number of servers that can communicate with at least one other server. This excludes servers that are isolated, i.e., those that do not share a row or column with any other server.</p>
<p>The first thing to note is that a server can communicate with another server if they are located either in the same row or the same column. Thus, the key observation here is that we only need to check rows and columns to determine if a server is communicable. If there’s at least one other server in the same row or column, then this server is communicable.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute-Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We know that each cell either contains a server (represented by <code>1</code>) or is empty (represented by <code>0</code>). So, we start by going through each cell to see if there is a server at that position. If the current cell contains a server, we then check if this server can communicate with any other server. If it can, we count it as communicable.</p>
<p>Once we find a server, we check if there is any other server in the same row that can communicate with it. We do this by iterating through all the other cells in the same row. If we find another server in the same row, we can immediately mark it as communicable.</p>
<p>If we do not find any other server in the row, we proceed to check the column. We iterate through all the other rows in the same column to see if there is another server. If a server is found in the same column, we know this server can communicate and is communicable.</p>
<p>As soon as we determine that a server can communicate (either in the same row or column), we increment the total communicable servers count. Once we finish checking the entire grid, we return the count of communicable servers.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>numRows</code> and <code>numCols</code> to represent the number of rows and columns in the grid.</p>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will keep track of the count of communicable servers.</p>
</li>
<li>
<p>Traverse through the grid:</p>
<ul>
<li>For each server at position <code>(row, col)</code> where <code>grid[row][col] == 1</code>:
<ul>
<li>Set <code>canCommunicate</code> to <code>false</code>.</li>
<li>Check for communication in the same row:
<ul>
<li>Iterate through each column <code>otherCol</code> in the same row:
<ul>
<li>If <code>otherCol</code> is not equal to <code>col</code> and <code>grid[row][otherCol] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
<li>If no communication was found in the same row, check for communication in the same column:
<ul>
<li>Iterate through each row <code>otherRow</code> in the same column:
<ul>
<li>If <code>otherRow</code> is not equal to <code>row</code> and <code>grid[otherRow][col] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DouY2Fzd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span></p>
<p>The algorithm traverses through each cell in the grid using nested loops, where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). For each cell containing a server (<code>grid[row][col] == 1</code>), it performs two additional checks:</p>
<ol>
<li>It checks the entire row to see if there is another server in the same row. This involves iterating over <span class="math inline">\(n\)</span> columns.</li>
<li>If no server is found in the same row, it checks the entire column to see if there is another server in the same column. This involves iterating over <span class="math inline">\(m\)</span> rows.</li>
</ol>
<p>Since these checks are performed for each server, the worst-case time complexity is <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only maintains a few variables (<code>numRows</code>, <code>numCols</code>, <code>communicableServersCount</code>, <code>canCommunicate</code>, etc.). No additional data structures are used that scale with the input size. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-track-using-two-arrays">Approach 2: Track Using Two Arrays</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To optimize the checking process, the first step is to count how many servers exist in each row and each column before we start checking individual servers.</p>
<p>We don’t need to check the entire row and column every time for every server. Instead, we can track the number of servers in each row and column using two arrays: <code>rowCounts</code> and <code>colCounts</code>. We loop over the grid once, and for each server (<code>grid[row][col] == 1</code>), we increment the count for the corresponding row and column. This precomputes how many servers are present in each row and column.</p>
<p>The advantage of this approach is that we know in advance how many servers are in a given row or column, so when we encounter a server, we can quickly determine if it’s communicable by checking these precomputed values.</p>
<p>Once we have the counts of servers in each row and column, the next task is to identify which servers are communicable. For a server at position <code>(row, col)</code>, we need to check:</p>
<ul>
<li>If the row has more than one server (i.e., <code>rowCounts[row] &gt; 1</code>), which means there are other servers in the same row.</li>
<li>If the column has more than one server (i.e., <code>colCounts[col] &gt; 1</code>), which means there are other servers in the same column.</li>
</ul>
<p>If either condition is true, the server can communicate, and we increment the count of communicable servers.</p>
<p>Once we’ve checked all servers and counted the communicable ones, we simply return the count.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize two arrays, <code>rowCounts</code> and <code>colCounts</code>, of appropriate sizes to keep track of the server counts in each row and column.</p>
</li>
<li>
<p>Count servers in each row and column:</p>
<ul>
<li>Iterate through each row (<code>row</code>), and for each row, iterate through each column (<code>col</code>):
<ul>
<li>If there’s a server at <code>grid[row][col]</code>, increment the corresponding values in <code>rowCounts[row]</code> and <code>colCounts[col]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will store the count of servers that can communicate.</p>
</li>
<li>
<p>Count servers that can communicate (i.e., those in the same row or column as another server):</p>
<ul>
<li>Iterate again through each row and column:
<ul>
<li>If there’s a server at <code>grid[row][col]</code>, check if it can communicate with another server (i.e., if <code>rowCounts[row] &gt; 1</code> or <code>colCounts[col] &gt; 1</code>).</li>
<li>If so, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7NwwDvo6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The first nested loop iterates over each row in the grid to count the number of servers in each row and column. The outer loop runs <span class="math inline">\(m\)</span> times (for each row), and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second nested loop also iterates over each row in the grid to determine if a server can communicate with others in its row or column. This again involves an outer loop running <span class="math inline">\(m\)</span> times and an inner loop running <span class="math inline">\(n\)</span> times, resulting in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Since both loops are independent and each has a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional arrays:<br />
- <code>rowCounts</code> of size <span class="math inline">\(n\)</span> (number of columns) to store the count of servers in each column.<br />
- <code>colCounts</code> of size <span class="math inline">\(m\)</span> (number of rows) to store the count of servers in each row.</p>
<p>The space required for these arrays is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-server-grouping">Approach 3: Server Grouping</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In Approach 2, we were repeatedly scanning the entire row and column for each server to check if there were any other servers for communication. While this method works, it is somewhat redundant since we perform the same checks multiple times. The goal now is to micro-optimize the process.</p>
<p>Instead of directly checking the count of servers in every row and column each time we find a server, we aim to track the necessary information during our first pass so that in the second pass, we can make decisions more quickly. This will reduce some runtime redundancy.</p>
<p>We begin by initializing a <code>colCount</code> array, where each entry tracks the number of servers in that row. By maintaining this count, we can easily find if a server can communicate based on the number of servers in the same row.</p>
<p>In addition to counting the servers in each row and column, we use another array, <code>lastServerInRow</code>, to track the position of the last server in each column. This is crucial because if a column has multiple servers, we don’t need to check the entire column again. Instead, we can focus on whether the last server in a column is part of a communicable set (i.e., a row or column with multiple servers). For example, if <code>lastServerInRow[0]</code> is 3, it means the last server in column 0 is at row 3. If this server can communicate, it indicates that there are other servers in that column, and we can mark it as communicable without needing to scan all rows again.</p>
<p>Now we process each server in the grid by iterating over the rows and columns. For each server we encounter, we:</p>
<ul>
<li>Increment the count for that row in the <code>colCount</code> array.</li>
<li>Track the position of the last server in the <code>lastServerInRow</code> array.</li>
</ul>
<p>Thus, we gather all the necessary information about how many servers are in each row and column and the position of the last server.</p>
<p>After collecting this information, we use the <code>colCount</code> and <code>lastServerInRow</code> arrays to identify communicable servers. For each server in the grid, we check if the count of servers in the same row is greater than 1. If it is, we know that this server can communicate with another server in the same row. Similarly, we check if the server’s column has more than one server using the <code>lastServerInRow</code> array. If the server is part of a communicable set (i.e., there are other servers in the same row or column), we increase the count of communicable servers.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1267/server_grouping.json:760,532!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>communicableServersCount</code> to 0 to keep track of servers that can communicate.</li>
<li>Initialize <code>colCount</code> to store the count of servers in each row, and <code>lastServerInRow</code> to track the last server in each column.</li>
</ul>
<h5 id="first-pass-count-servers-in-each-row-and-column">First Pass: Count servers in each row and column</h5>
<ol>
<li>Iterate through each row (<code>row</code>):
<ul>
<li>For each row, initialize <code>serverCountInRow</code> to 0 to track the number of servers in that row.</li>
<li>Iterate through each column (<code>col</code>):
<ul>
<li>If a server is found at <code>grid[row][col]</code>, increment <code>serverCountInRow</code>, update <code>colCount[col]</code>, and set <code>lastServerInRow[col]</code> to <code>row</code>.</li>
</ul>
</li>
<li>If the row has more than one server, increment <code>communicableServersCount</code> by the number of servers in the row and set <code>lastServerInRow[col]</code> to -1 (indicating no servers to communicate in that column).</li>
</ul>
</li>
</ol>
<h5 id="second-pass-check-if-servers-can-communicate">Second Pass: Check if servers can communicate</h5>
<ol start="2">
<li>Iterate again through each column (<code>col</code>):
<ul>
<li>If there is a server at <code>lastServerInRow[col]</code> and the count of servers in the corresponding row (<code>colCount[lastServerInRow[col]]</code>) is greater than one, increment <code>communicableServersCount</code> by 1.</li>
</ul>
</li>
</ol>
<ul>
<li>Finally, return <code>communicableServersCount</code>, the total count of servers that can communicate.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/8eyTWJqP/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm performs two passes over the grid. In the first pass, it iterates over each cell in the grid to count the number of servers in each row and column. This involves nested loops where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second pass iterates over the rows to check if servers can communicate based on the counts computed in the first pass. This pass runs in <span class="math inline">\(O(m)\)</span> time. Since <span class="math inline">\(O(m \cdot n)\)</span> dominates <span class="math inline">\(O(m)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional data structures: <code>colCount</code> and <code>lastServerInRow</code>. The <code>colCount</code> array has a size of <span class="math inline">\(n\)</span> (number of columns), and the <code>lastServerInRow</code> array has a size of <span class="math inline">\(m\)</span> (number of rows). Therefore, the space complexity is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-space-optimized">Approach 4: Space Optimized</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of keeping an array to track the position of the last server in each column, we just count the number of servers directly in each row and perform a simple check when a single server is found, leveraging the grid's structure itself.</p>
<p>We start by iterating over each row in the grid. For each row, we count how many servers are present. As we count, we also keep track of the column index of the first server encountered. This is important because if there’s only one server in the row, we need to check if there’s any other server in the same column.</p>
<p>Once the row is processed, we check if there are multiple servers in that row. If there are, we conclude that all servers in that row can communicate with each other, so we add the count of servers in that row to the total communicable servers count.</p>
<p>If there’s exactly one server in the row, we then check all the other rows to see if there’s any server in the same column as that single server. If such a server exists, then the lone server in that row is communicable, and we add it to the total count.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>rows</code> and <code>cols</code> to the dimensions of the grid, and <code>communicableServersCount</code> to <code>0</code>, which will store the total count of communicable servers.</p>
</li>
<li>
<p>Iterate through each row (<code>rowIndex</code>):</p>
<ul>
<li>
<p>Initialize <code>rowCounts</code> to count the number of servers in the current row, and <code>serverColumnIndex</code> to store the column index of the first server in the row.</p>
</li>
<li>
<p>Count the servers in the current row:</p>
<ul>
<li>Iterate through each column (<code>colIndex</code>):
<ul>
<li>If there's a server (<code>grid[rowIndex][colIndex]</code>), update <code>serverColumnIndex</code> if it is the first server found, and increment <code>rowCounts</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check if the row has more than one server (<code>rowCounts != 1</code>), meaning servers in the row can communicate. If not, check for a server in the same column (<code>serverColumnIndex</code>) in other rows.</p>
</li>
<li>
<p>If the server can communicate (either because there are multiple servers in the row or another server exists in the same column in another row), add <code>rowCounts</code> to <code>communicableServersCount</code>.</p>
</li>
</ul>
</li>
<li>
<p>After iterating through all rows, return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/89oda5wC/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The algorithm iterates over each cell in the grid once to count the number of servers in each row and determine if they can communicate. For each row, it takes <span class="math inline">\(O(n)\)</span> time to count the servers and <span class="math inline">\(O(m)\)</span> time to check if a server in a row can communicate with another server in the same column. Since there are <span class="math inline">\(m\)</span> rows, the total time complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>The nested loops and the checks for communication contribute to this time complexity. The outer loop runs <span class="math inline">\(m\)</span> times, and the inner loops run <span class="math inline">\(n\)</span> times and <span class="math inline">\(m\)</span> times respectively, leading to the overall time complexity of <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm does not allocate any additional memory that depends on the size of the input grid. All operations are performed in-place using a fixed number of variables.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-special-triplets/description" target="_blank" rel="noopener noreferrer">Count Special Triplets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>.</p>

<p>A <strong>special triplet</strong> is defined as a triplet of indices <code>(i, j, k)</code> such that:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; k &lt; n</code>, where <code>n = nums.length</code></li>
	<li><code>nums[i] == nums[j] * 2</code></li>
	<li><code>nums[k] == nums[j] * 2</code></li>
</ul>

<p>Return the total number of <strong>special triplets</strong> in the array.</p>

<p>Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [6,3,6]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The only special triplet is <code>(i, j, k) = (0, 1, 2)</code>, where:</p>

<ul>
	<li><code>nums[0] = 6</code>, <code>nums[1] = 3</code>, <code>nums[2] = 6</code></li>
	<li><code>nums[0] = nums[1] * 2 = 3 * 2 = 6</code></li>
	<li><code>nums[2] = nums[1] * 2 = 3 * 2 = 6</code></li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,1,0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The only special triplet is <code>(i, j, k) = (0, 2, 3)</code>, where:</p>

<ul>
	<li><code>nums[0] = 0</code>, <code>nums[2] = 0</code>, <code>nums[3] = 0</code></li>
	<li><code>nums[0] = nums[2] * 2 = 0 * 2 = 0</code></li>
	<li><code>nums[3] = nums[2] * 2 = 0 * 2 = 0</code></li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [8,4,2,8,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>There are exactly two special triplets:</p>

<ul>
	<li><code>(i, j, k) = (0, 1, 3)</code>

	<ul>
		<li><code>nums[0] = 8</code>, <code>nums[1] = 4</code>, <code>nums[3] = 8</code></li>
		<li><code>nums[0] = nums[1] * 2 = 4 * 2 = 8</code></li>
		<li><code>nums[3] = nums[1] * 2 = 4 * 2 = 8</code></li>
	</ul>
	</li>
	<li><code>(i, j, k) = (1, 2, 4)</code>
	<ul>
		<li><code>nums[1] = 4</code>, <code>nums[2] = 2</code>, <code>nums[4] = 4</code></li>
		<li><code>nums[1] = nums[2] * 2 = 2 * 2 = 4</code></li>
		<li><code>nums[4] = nums[2] * 2 = 2 * 2 = 4</code></li>
	</ul>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-substrings-starting-and-ending-with-given-character/description" target="_blank" rel="noopener noreferrer">Count Substrings Starting and Ending with Given Character</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a character <code>c</code>. Return <em>the total number of <span data-keyword="substring-nonempty">substrings</span> of </em><code>s</code><em> that start and end with </em><code>c</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">s = &quot;abada&quot;, c = &quot;a&quot;</span></p>

<p><strong>Output: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">6</span></p>

<p><strong>Explanation:</strong> Substrings starting and ending with <code>&quot;a&quot;</code> are: <code>&quot;<strong><u>a</u></strong>bada&quot;</code>, <code>&quot;<u><strong>aba</strong></u>da&quot;</code>, <code>&quot;<u><strong>abada</strong></u>&quot;</code>, <code>&quot;ab<u><strong>a</strong></u>da&quot;</code>, <code>&quot;ab<u><strong>ada</strong></u>&quot;</code>, <code>&quot;abad<u><strong>a</strong></u>&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">s = &quot;zzz&quot;, c = &quot;z&quot;</span></p>

<p><strong>Output: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">6</span></p>

<p><strong>Explanation:</strong> There are a total of <code>6</code> substrings in <code>s</code> and all start and end with <code>&quot;z&quot;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>c</code> consist&nbsp;only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-tested-devices-after-test-operations/description" target="_blank" rel="noopener noreferrer">Count Tested Devices After Test Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>batteryPercentages</code> having length <code>n</code>, denoting the battery percentages of <code>n</code> <strong>0-indexed</strong> devices.</p>

<p>Your task is to test each device <code>i</code> <strong>in order</strong> from <code>0</code> to <code>n - 1</code>, by performing the following test operations:</p>

<ul>
	<li>If <code>batteryPercentages[i]</code> is <strong>greater</strong> than <code>0</code>:

	<ul>
		<li><strong>Increment</strong> the count of tested devices.</li>
		<li><strong>Decrease</strong> the battery percentage of all devices with indices <code>j</code> in the range <code>[i + 1, n - 1]</code> by <code>1</code>, ensuring their battery percentage <strong>never goes below</strong> <code>0</code>, i.e, <code>batteryPercentages[j] = max(0, batteryPercentages[j] - 1)</code>.</li>
		<li>Move to the next device.</li>
	</ul>
	</li>
	<li>Otherwise, move to the next device without performing any test.</li>
</ul>

<p>Return <em>an integer denoting the number of devices that will be tested after performing the test operations in order.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> batteryPercentages = [1,1,2,1,3]
<strong>Output:</strong> 3
<strong>Explanation: </strong>Performing the test operations in order starting from device 0:
At device 0, batteryPercentages[0] &gt; 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].
At device 1, batteryPercentages[1] == 0, so we move to the next device without testing.
At device 2, batteryPercentages[2] &gt; 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].
At device 3, batteryPercentages[3] == 0, so we move to the next device without testing.
At device 4, batteryPercentages[4] &gt; 0, so there are now 3 tested devices, and batteryPercentages stays the same.
So, the answer is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> batteryPercentages = [0,1,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Performing the test operations in order starting from device 0:
At device 0, batteryPercentages[0] == 0, so we move to the next device without testing.
At device 1, batteryPercentages[1] &gt; 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].
At device 2, batteryPercentages[2] &gt; 0, so there are now 2 tested devices, and batteryPercentages stays the same.
So, the answer is 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == batteryPercentages.length &lt;= 100 </code></li>
	<li><code>0 &lt;= batteryPercentages[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-consistent-strings/description" target="_blank" rel="noopener noreferrer">Count the Number of Consistent Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>allowed</code> consisting of <strong>distinct</strong> characters and an array of strings <code>words</code>. A string is <strong>consistent </strong>if all characters in the string appear in the string <code>allowed</code>.</p>

<p>Return<em> the number of <strong>consistent</strong> strings in the array </em><code>words</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> allowed = &quot;ab&quot;, words = [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Strings &quot;aaab&quot; and &quot;baa&quot; are consistent since they only contain characters &#39;a&#39; and &#39;b&#39;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> allowed = &quot;abc&quot;, words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;]
<strong>Output:</strong> 7
<strong>Explanation:</strong> All strings are consistent.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> allowed = &quot;cad&quot;, words = [&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Strings &quot;cc&quot;, &quot;acd&quot;, &quot;ac&quot;, and &quot;d&quot; are consistent.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= allowed.length &lt;=<sup> </sup>26</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li>The characters in <code>allowed</code> are <strong>distinct</strong>.</li>
	<li><code>words[i]</code> and <code>allowed</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find how many words in the given array contain only characters from the allowed string. To do this, we will go through each word in the array and check if it meets the condition.</p>
<p>We'll use a counter variable, <code>consistentCount</code>, to keep track of how many words meet the condition. For each word, we'll check every character it contains. If all the characters in a word are present in the <code>allowed</code> string, we'll count that word as consistent and increase our counter.</p>
<p>After checking all the words, we'll return the value of <code>consistentCount</code> as the result.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a variable <code>consistentCount</code> to store the number of consistent strings found.</li>
<li>Iterate through each <code>word</code> in the <code>words</code> array:
<ul>
<li>Initialize a boolean variable <code>isWordConsistent</code> to <code>true</code>.</li>
<li>Start an inner loop to iterate through each character in the current <code>word</code>:
<ul>
<li>Set a boolean variable <code>isCharAllowed</code> to <code>false</code>, assuming the character is not allowed until found in the <code>allowed</code> string.</li>
<li>Start another inner loop to iterate through each character in <code>allowed</code>:
<ul>
<li>Compare the current character from the word with each character in <code>allowed</code>.</li>
<li>If a match is found, set <code>isCharAllowed</code> to <code>true</code> and break out of the inner loop.</li>
</ul>
</li>
<li>If <code>isCharAllowed</code> is still <code>false</code>, set <code>isWordConsistent</code> to <code>false</code> and break out of the character checking loop.</li>
</ul>
</li>
<li>If <code>isWordConsistent</code> is <code>true</code>, increment <code>consistentCount</code> by 1.</li>
</ul>
</li>
<li>Return the final value of <code>consistentCount</code> as the result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/BgxN2SHK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the lengths of <code>allowed</code> and <code>words</code>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot k)\)</span></p>
<p>The outermost loop iterates through each word in the <code>words</code> array, which has <span class="math inline">\(n\)</span> elements. This contributes <span class="math inline">\(O(n)\)</span> to our time complexity.</p>
<p>For each word, the algorithm iterates through its characters. If we denote the length of the longest word as <span class="math inline">\(k\)</span>, this inner loop has a complexity of <span class="math inline">\(O(k)\)</span>.</p>
<p>For each character in a word, in the worst case, we may need to search through the entire allowed string, taking <span class="math inline">\(O(m)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m \cdot n \cdot k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm does not use any data structures that scale with input space. Thus, the space complexity is constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-boolean-array">Approach 2: Boolean Array</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To solve this problem efficiently, we need a better way to check if a string is consistent. The brute-force approach was slow because we kept checking each character against the <code>allowed</code> string. We need a faster method.</p>
<p>The key idea is to use a boolean array to mark which characters are allowed. Since we're only dealing with lowercase English letters, we need an array of size 26. Each index in the array will correspond to a character based on its ASCII value.</p>
<p>Each character has an integer representation called its ASCII value. For example, <code>a</code> has an ASCII value of 97, <code>b</code> is 98, and so on until <code>z</code>, which is 122. We can map each character to an index from 0 to 25 by subtracting the ASCII value of <code>a</code> from the character's ASCII value. For example, <code>c</code> maps to index 2 because the difference between the ASCII values of <code>c</code> (99) and <code>a</code> (97) is 2.</p>
<p>With this setup, we can loop through each character in every word and check in constant time whether that character is allowed. If any character's index in our boolean array is <code>false</code>, the word isn't consistent. If all characters are marked <code>true</code>, we increase our counter of consistent words.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a boolean array <code>isAllowed</code> of size <code>26</code> to store which characters are allowed.</li>
<li>Iterate through each character in the <code>allowed</code> string:
<ul>
<li>Mark the corresponding index in <code>isAllowed</code> as <code>true</code>.</li>
</ul>
</li>
<li>Initialize a variable <code>consistentCount</code> to store the number of consistent strings.</li>
<li>Iterate through each <code>word</code> in the <code>words</code> array:
<ul>
<li>Set a boolean variable <code>isConsistent</code> to <code>true</code>.</li>
<li>Iterate through each character in <code>word</code>:
<ul>
<li>Check if the current character is allowed by accessing the corresponding index in <code>isAllowed</code>:
<ul>
<li>If not allowed, set <code>isConsistent</code> to <code>false</code> and break the inner loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>isConsistent</code> is <code>true</code>, increment <code>consistentCount</code>.</li>
</ul>
</li>
<li>Return the final value of <code>consistentCount</code> as the result.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7GakEK9c/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the lengths of <code>allowed</code> and <code>words</code>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n \cdot k)\)</span></p>
<p>The algorithm iterates over each character in <code>allowed</code> to mark it as <code>true</code>, which takes <span class="math inline">\(O(m)\)</span> time.</p>
<p>The algorithm then iterates through each character of each word in the <code>words</code> array. If <span class="math inline">\(k\)</span> is the length of the longest word, the overall time complexity of this portion is <span class="math inline">\(O(n \cdot k)\)</span>.</p>
<p>Thus, the time complexity of the algorithm is <span class="math inline">\(O(m) + O(n \cdot k) = O(m + n \cdot k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only additional space used by the algorithm is the <code>isAllowed</code> array, which has a constant length of <span class="math inline">\(26\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-hash-set">Approach 3: Hash Set</h3>
<h4 id="intuition-2">Intuition</h4>
<p>An alternative data structure that allows us to quickly check whether a given element exists or not is a hash set.  If you're new to hash sets, this LeetCode <a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1130/">Explore Card</a> provides a detailed explanation.</p>
<p>We'll start by creating a hash set called <code>allowedChars</code> and fill it with characters from the <code>allowed</code> string. This set will act as our lookup table for permitted characters. A key benefit of using a set over a boolean array is its flexibility: a boolean array always has 26 slots, even if <code>allowed</code> has fewer characters. A set, on the other hand, adjusts to only use the space it needs.</p>
<p>Next, we loop through each word in <code>words</code>. For each word, we'll check each character to see if it's in the set. If every character of the word is present, we increment our counter.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a set <code>allowedChars</code> to store the allowed characters.</li>
<li>Iterate through each character in the <code>allowed</code> string and add it to <code>allowedChars</code>.</li>
<li>Initialize a variable <code>consistentCount</code> to store the number of consistent strings.</li>
<li>Iterate through each <code>word</code> in the <code>words</code> array:
<ul>
<li>Set a boolean variable <code>isConsistent</code> to <code>true</code>.</li>
<li>Iterate through each character in <code>word</code>:
<ul>
<li>Check if the current character is contained in <code>allowedChars</code>:
<ul>
<li>If not, set <code>isConsistent</code> to <code>false</code> and break the inner loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>isConsistent</code> is <code>true</code>, increment <code>consistentCount</code>.</li>
</ul>
</li>
<li>Return <code>consistentCount</code> as our answer.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/a9NZ47n5/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the lengths of <code>allowed</code> and <code>words</code>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n \cdot k)\)</span></p>
<p>The algorithm loops over <code>allowed</code> to populate the <code>allowedChars</code> set, taking <span class="math inline">\(O(m)\)</span> time.</p>
<p>The algorithm then iterates over each character of each word in the <code>words</code> array. If the <span class="math inline">\(k\)</span> is the length of the longest word, this takes <span class="math inline">\(O(n \cdot k)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m) + O(n \cdot k) = O(m + n \cdot k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The <code>allowedChars</code> set can have a size of <span class="math inline">\(m\)</span> in the worst case (all characters in <code>allowed</code> are unique). All other variables take constant space.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-bit-manipulation">Approach 4: Bit Manipulation</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In a binary number, each bit can be <code>0</code> or <code>1</code>. A boolean variable can be either <code>true</code> or <code>false</code>. The pattern is clear: each bit in a binary number can represent a boolean value. We can use this to show whether a character is in <code>allowed</code>. This representation is called a bitmask, which will work like the boolean array in the second approach, where each index stands for a character from <code>a</code> to <code>z</code>.</p>
<p>Since there are only 26 possible characters, a 32-bit integer will be enough for our bitmask. We need to perform two main operations with this bitmask:</p>
<ol>
<li>Setting a bit: Each bit will show whether a character from <code>a</code> to <code>z</code> is present (<code>1</code>) or not (<code>0</code>). As in the second approach, the 0th bit will represent <code>a</code>, the 1st bit will represent <code>b</code>, and so on. To mark the presence of a character, we'll set the corresponding bit to <code>1</code>. To set a bit, we use Bitwise OR with <code>1</code> shifted left by that bit's position. For example, to set the 2nd bit in the binary number <code>1000010</code>, we use Bitwise OR with <code>1</code> shifted left by <code>2</code>. Here’s the pseudo-code for setting a bit for a character:</li>
</ol>
<pre><code>If c is the character to be marked:
mask = mask | (1 &lt;&lt; (c - 'a'))
</code></pre>
<p><img src="../Figures/1684/set.png" alt="" /></p>
<ol start="2">
<li>Checking a bit: To see if a character is in <code>allowed</code>, we check the corresponding bit in the bitmask. We can isolate the bit by right-shifting the bitmask by the bit's position and then using Bitwise AND with <code>1</code>. If the result is <code>1</code>, the character is in <code>allowed</code>. For example, to check if the 2nd bit in <code>1000110</code> is set, we right-shift by <code>2</code> and use Bitwise AND with <code>1</code>. This gives us <code>1</code>, so the bit is set. Here’s the pseudo-code for this check:</li>
</ol>
<pre><code>If c is the character to be checked:
bit = (mask &gt;&gt; (c - 'a')) &amp; 1
</code></pre>
<p><img src="../Figures/1684/check.png" alt="" /></p>
<p>Using these methods, we can check each character in a word to see if the word is consistent.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize a variable <code>allowedBits</code> to store the bitmask of allowed characters.</li>
<li>Iterate through each character in the <code>allowed</code> string:
<ul>
<li>Set the corresponding bit in <code>allowedBits</code> for each character.</li>
</ul>
</li>
<li>Initialize a variable <code>consistentCount</code> to store the number of consistent strings.</li>
<li>Iterate through each <code>word</code> in the <code>words</code> array:
<ul>
<li>Initialize a boolean variable <code>isConsistent</code> as <code>true</code>.</li>
<li>Iterate through each character in <code>word</code>:
<ul>
<li>Find the <code>bit</code> corresponding to the character in <code>allowedBits</code>.</li>
<li>If the bit is <code>0</code>:
<ul>
<li>Set <code>isConsistent</code> to <code>false</code> and break the inner loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>isConsistent</code> is <code>true</code>, increment <code>consistentCount</code>.</li>
</ul>
</li>
<li>Return the final value of <code>consistentCount</code> as the result.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/Qjf37a9h/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the lengths of <code>allowed</code> and <code>words</code>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n \cdot k)\)</span></p>
<p>Setting each bit for the characters in <code>allowed</code> takes <span class="math inline">\(O(m)\)</span> time.</p>
<p>If <span class="math inline">\(k\)</span> is the length of the longest word, iterating through each character in each word of the <code>words</code> array takes <span class="math inline">\(O(n \cdot k)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m) + O(n \cdot k) = O(m + n \cdot k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>All variables used by the algorithm take constant space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-vowel-strings-in-range/description" target="_blank" rel="noopener noreferrer">Count the Number of Vowel Strings in Range</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of string <code>words</code> and two integers <code>left</code> and <code>right</code>.</p>

<p>A string is called a <strong>vowel string</strong> if it starts with a vowel character and ends with a vowel character where vowel characters are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>.</p>

<p>Return <em>the number of vowel strings </em><code>words[i]</code><em> where </em><code>i</code><em> belongs to the inclusive range </em><code>[left, right]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;are&quot;,&quot;amy&quot;,&quot;u&quot;], left = 0, right = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- &quot;are&quot; is a vowel string because it starts with &#39;a&#39; and ends with &#39;e&#39;.
- &quot;amy&quot; is not a vowel string because it does not end with a vowel.
- &quot;u&quot; is a vowel string because it starts with &#39;u&#39; and ends with &#39;u&#39;.
The number of vowel strings in the mentioned range is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;hey&quot;,&quot;aeo&quot;,&quot;mu&quot;,&quot;ooo&quot;,&quot;artro&quot;], left = 1, right = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
- &quot;aeo&quot; is a vowel string because it starts with &#39;a&#39; and ends with &#39;o&#39;.
- &quot;mu&quot; is not a vowel string because it does not start with a vowel.
- &quot;ooo&quot; is a vowel string because it starts with &#39;o&#39; and ends with &#39;o&#39;.
- &quot;artro&quot; is a vowel string because it starts with &#39;a&#39; and ends with &#39;o&#39;.
The number of vowel strings in the mentioned range is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of only lowercase English letters.</li>
	<li><code>0 &lt;= left &lt;= right &lt; words.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-parking-system/description" target="_blank" rel="noopener noreferrer">Design Parking System</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">design</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.</p>

<p>Implement the <code>ParkingSystem</code> class:</p>

<ul>
	<li><code>ParkingSystem(int big, int medium, int small)</code> Initializes object of the <code>ParkingSystem</code> class. The number of slots for each parking space are given as part of the constructor.</li>
	<li><code>bool addCar(int carType)</code> Checks whether there is a parking space of <code>carType</code> for the car that wants to get into the parking lot. <code>carType</code> can be of three kinds: big, medium, or small, which are represented by <code>1</code>, <code>2</code>, and <code>3</code> respectively. <strong>A car can only park in a parking space of its </strong><code>carType</code>. If there is no space available, return <code>false</code>, else park the car in that size space and return <code>true</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;ParkingSystem&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;]
[[1, 1, 0], [1], [2], [3], [1]]
<strong>Output</strong>
[null, true, true, false, false]

<strong>Explanation</strong>
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // return true because there is 1 available slot for a big car
parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car
parkingSystem.addCar(3); // return false because there is no available slot for a small car
parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= big, medium, small &lt;= 1000</code></li>
	<li><code>carType</code> is <code>1</code>, <code>2</code>, or <code>3</code></li>
	<li>At most <code>1000</code> calls will be made to <code>addCar</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem is to <strong>design</strong> a parking system.</p>
<blockquote>
<p>A <strong>design</strong> problem is a problem where we have to <strong>implement</strong> a class or a data structure. This class usually has multiple functions that we have to implement. This falls under the category of <a href="https://leetcode.com/tag/oop/"><strong>Object Oriented Programming</strong></a></p>
</blockquote>
<p>In this problem, we have to implement the <code>ParkingSystem</code> class. It will have the following components:</p>
<ul>
<li>
<p><code>ParkingSystem</code> constructor. Whenever any user or test case wants to create a new parking system, they will call this constructor. They need to specify the number of parking slots available for each type of car (<code>small</code>, <code>medium</code>, or <code>large</code>).</p>
<p><strong>We</strong> have to write code to store this information in the class. This information will perhaps be used in other functions.</p>
<blockquote>
<p>Different languages have different ways to implement constructors.</p>
<ul>
<li>In Python, we use <code>__init__</code> function to implement the constructor.</li>
<li>In C++ and Java, the name of the constructor is the same as the name of the class.</li>
</ul>
</blockquote>
</li>
<li>
<p><code>addCar</code> function. Whenever any user or test case wants to add a car to the parking system, they will call this function. They need to specify the type of the car, <code>carType</code> using an integer.</p>
<ul>
<li>if they want to add a <code>big</code> car, they will pass <code>1</code> as the argument.</li>
<li>if they want to add a <code>medium</code> car, they will pass <code>2</code> as the argument.</li>
<li>if they want to add a <code>small</code> car, they will pass <code>3</code> as the argument.</li>
</ul>
  <br/>  
<p><strong>We</strong> have to write code to check if there is a parking slot available for the given type of car.</p>
<ul>
<li>If there is a parking slot available, we have to add the car to the parking system and return <code>true</code>.</li>
<li>Otherwise, we have to return <code>false</code>.</li>
</ul>
</li>
</ul>
<details> <summary> In these problems, users often faces difficulty in understanding the <b>input</b> and <b>output</b> formats. Let's pick one <b>example</b> and understand its <b>input</b> and <b>output</b> structure. If you are not familiar with design problems, it is advisable to expand the section by clicking here.  
<br> 
</summary>   
<p>
<br>
<pre><code class="language-Input">[&quot;ParkingSystem&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;]
[[1, 1, 0], [1], [2], [3], [1]]
</code></pre>
<p>This input is actually <strong>NOT</strong> an array. The array has been given to describe a <strong>sequence of function calls</strong> by the online judge.</p>
<blockquote>
<p>If readers want to explore more, they can read <a href="https://en.wikipedia.org/wiki/Dispatch_table">Dispatch Table</a></p>
</blockquote>
<p>In our code, we <strong>won't be able to access the array</strong>. This array only helps in letting us know the function calls that will be made by the online judge.</p>
<p>More particularly,</p>
<ul>
<li>the first array stores the sequence of function calls, and</li>
<li>the second array stores the <strong>respective</strong> arguments for each function call.</li>
</ul>
<p>Thus, the above input can be interpreted as:</p>
<ul>
<li>
<p>First, the online judge will call the <code>ParkingSystem</code> constructor with arguments <code>1, 1, 0</code>.</p>
<p>We were given in the description that <code>ParkingSystem</code> requires three arguments, <code>big</code>, <code>medium</code>, and <code>small</code>. These <code>[1, 1, 0]</code> are the respective values for these arguments.</p>
<p>Do we have to return anything from the constructor? No. We just have to store some (or all) of these arguments so that we can use them in other functions if needed. Thus, the first element of the <strong>output</strong> array is <code>null</code>.</p>
</li>
<li>
<p>Then, the online judge will call the <code>addCar</code> function with argument <code>1</code>.</p>
<p>We were given in the description that <code>addCar</code> requires one argument, <code>carType</code>. This <code>1</code> is the value for this argument and represents a <code>big</code> car.</p>
<p>This has to be interpreted as, &quot;Is there a parking slot available for a <code>big</code> car?&quot;. If yes, then add the car to the parking system and return <code>true</code>. Otherwise, return <code>false</code>.</p>
<p>Now, we know that while creating our object, we were given that there is <code>1</code> parking slot available for a <code>big</code> car. And we know that no car has been added to the parking system yet. Thus, we will return <code>true</code> and add the car to the slot available for a <code>big</code> car.</p>
<p>Hence, the second element of the <strong>output</strong> array is <code>true</code>.</p>
</li>
<li>
<p>Then, the online judge will call the <code>addCar</code> function with argument <code>2</code>.</p>
<p>This <code>2</code> is the value for this argument and represents a <code>medium</code> car.</p>
<p>This has to be interpreted as, &quot;Is there a parking slot available for a <code>medium</code> car?&quot;. If yes, then add the car to the parking system and return <code>true</code>. Otherwise, return <code>false</code>.</p>
<p>Now, we know that while creating our object, we were given that there is <code>1</code> parking slot available for a <code>medium</code> car. Additionally, we know that no car has been added to the parking system yet. Thus, we will return <code>true</code> and add the car to the slot available for a <code>medium</code> car.</p>
<p>Hence, the third element of the <strong>output</strong> array is <code>true</code>.</p>
</li>
<li>
<p>Then, the online judge will call the <code>addCar</code> function with argument <code>3</code>.</p>
<p>This <code>3</code> is the value for this argument and represents a <code>small</code> car.</p>
<p>This has to be interpreted as, &quot;Is there a parking slot available for a <code>small</code> car?&quot;. If yes, then add the car to the parking system and return <code>true</code>. Otherwise, return <code>false</code>.</p>
<p>Now, we know that while creating our object, we were given that there is <code>0</code> parking slot available for <code>small</code> car. Thus, we cannot add the car to the parking system because no slots are available. Hence, we will return <code>false</code>.</p>
<p>Hence, the fourth element of the <strong>output</strong> array is <code>false</code>.</p>
</li>
<li>
<p>Lastly, the online judge will call the <code>addCar</code> function with argument <code>1</code>.</p>
<p>This <code>1</code> is the value for this argument and represents a <code>big</code> car.</p>
<p>This has to be interpreted as, &quot;Is there a parking slot available for <code>big</code> car?&quot;. If yes, then add the car to the parking system and return <code>true</code>. Otherwise, return <code>false</code>.</p>
<p>Now, we know that while creating our object, we were given that there is <code>1</code> parking slot available for <code>big</code> car. And we know that one car has already been added to the parking system. Thus, we will return <code>false</code> because no slots are available.</p>
<p>Hence, the fifth element of the <strong>output</strong> array is <code>false</code>.</p>
</li>
</ul>
<p>Thus, the <strong>output</strong> array as illustrated in the example is</p>
<pre><code class="language-Output">[null, true, true, false, false]
</code></pre>
<p>It's worth mentioning that we <strong>don't</strong> have to return any array. We just have to make sure that all functions return the correct value. The array is just a representation of the correct output sequence, and need not be explicitly returned.</p>
</p> </details>
<p><span class="math inline">\(\downarrow_{\text{Section below structure}}\)</span></p>
<p>There are tons of similar <a href="https://leetcode.com/tag/design/">Design Problems</a> on LeetCode. A few of them are listed below:</p>
<ul>
<li><a href="https://leetcode.com/problems/lru-cache/">LRU Cache</a></li>
<li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree)</a></li>
<li><a href="https://leetcode.com/problems/implement-stack-using-queues/">Implement Stack using Queues</a></li>
<li><a href="https://leetcode.com/problems/implement-queue-using-stacks/">Implement Queue using Stacks</a></li>
<li><a href="https://leetcode.com/problems/design-browser-history/">Design Browser History</a></li>
<li><a href="https://leetcode.com/problems/design-linked-list/">Design Linked List</a></li>
</ul>
<hr />
<h3 id="approach-array-for-parking-slots">Approach: Array for Parking Slots</h3>
<h4 id="intuition">Intuition</h4>
<p>We want to initialize our object given slots for each type of car.</p>
<p><strong>What exactly do we need to store in our object?</strong><br />
It depends on the desired function of the object. The required function is <code>addCar</code> and we should check if there is a parking space for <code>carType</code>. If so, then we should add the car to the parking system and return <code>true</code>. Otherwise, we should return <code>false</code>.</p>
<p>Thus, while creating an object, we <em>perhaps</em> need to store the</p>
<ul>
<li>Parking limit for <code>big</code> cars</li>
<li>Parking limit for <code>medium</code> cars</li>
<li>Parking limit for <code>small</code> cars</li>
</ul>
<p><strong>Do we need anything else in the constructor?</strong><br />
We know the limits for each type of car. But we don't know the number of cars parked in the parking system. We need to store this information as well.</p>
<p>Therefore, it may also be necessary to store the following three pieces of information in the object:</p>
<ul>
<li>Count of <code>big</code> cars parked in the parking system.</li>
<li>Count of <code>medium</code> cars parked in the parking system.</li>
<li>Count of <code>small</code> cars parked in the parking system.</li>
</ul>
<p>All of them will be initialized to <code>0</code>.</p>
<p>Initially, <strong>constructor</strong> in pseudo-code will look like this:</p>
<pre><code class="language-pseudocode">ParkingSystem(int big, int medium, int small) {

    // Store the parking limit for each type of car
    this.bigLimit = big
    this.mediumLimit = medium
    this.smallLimit = small

    // Store the count of cars parked in the parking system
    this.bigCount = 0
    this.mediumCount = 0
    this.smallCount = 0
}
</code></pre>
<blockquote>
<p>The <code>this</code> keyword is used to access the current object's attributes and methods. Different languages have different ways to access the current object's attributes and methods. For example, in Python, we can use the <code>self</code> keyword to access the current object's attributes and methods.</p>
</blockquote>
<p>We are currently storing the count and limits of cars for each type in six variables. However, what if we have hundreds of types of cars? Is it a good idea to have two variables for each type of car?</p>
<p>It turns out that if data represents the same type of thing <em>(or data is <strong>homogeneous</strong>)</em>, then we can use an array to store them.</p>
<blockquote>
<p>An <a href="https://leetcode.com/explore/learn/card/fun-with-arrays/">Array</a> is a data structure that stores a collection of elements. It is a linear data structure, which means that elements are stored sequentially. Each element in an array is identified by an index. Readers can learn more about Array from <a href="https://leetcode.com/explore/learn/card/fun-with-arrays/">Leetcode Explore Card</a>.</p>
</blockquote>
<p>Thus, we can club the three variables <code>bigCount</code>, <code>mediumCount</code>, and <code>smallCount</code> into one array <code>count</code>. Also, we can club the three variables <code>bigLimit</code>, <code>mediumLimit</code>, and <code>smallLimit</code> into one array <code>limit</code>.</p>
<p>Hence, so far, we are planning to use two arrays, <code>count</code> and <code>limit</code>. Can we brainstorm a way to use only one array?</p>
<p>The condition to check if we can <code>addCar</code> or not will be</p>
<p><span class="math inline">\(\rightsquigarrow\)</span> <code>count[i] &lt; limit[i]</code></p>
<p><span class="math inline">\(\rightsquigarrow\)</span> <code>limit[i] &gt; count[i]</code></p>
<p><span class="math inline">\(\rightsquigarrow\)</span> <code>limit[i] - count[i] &gt; 0</code></p>
<p>What exactly does <code>limit[i] - count[i]</code> represent? It represents the number of empty slots available for a particular type of car. Hence, we can use this value to store the empty slots for each type of car in one array, <code>empty</code>.</p>
<p>Initially, all available slots will be empty. Hence, we can initialize <code>empty</code> with the parking limit of each type of car provided as arguments to the <strong>constructor</strong>.</p>
<p>Now, does the order of these variables matter, or <strong>can we gain any advantage if they are stored in one specific order instead of another?</strong><br />
For answering this, let's re-read the following portion of the problem statement</p>
<blockquote>
<p><code>carType</code> can be of three kinds: big, medium, or small, which are represented by <code>1</code>, <code>2</code>, and <code>3</code> respectively.</p>
</blockquote>
<p>This hints that if we store</p>
<ul>
<li>big cars at index <code>1</code>,</li>
<li>medium cars at index <code>2</code>,</li>
<li>and small cars at index <code>3</code>,</li>
</ul>
<p>then we can directly access the count of cars of a particular type by using <code>carType</code> as the index.</p>
<p><strong>What about index-0, then?</strong></p>
<blockquote>
<p>Arrays in most programming languages are 0-indexed. This means that the first element of the array is stored at index <code>0</code>.</p>
</blockquote>
<p>There are two ways to handle this.</p>
<ol>
<li>
<p>We can allocate an array of size 4, and store the number of empty slots of cars at index <code>1</code>, <code>2</code>, and <code>3</code>. On Index <code>0</code>, we can store some dummy value.</p>
<p>The <code>carType</code> here will directly act as an index.</p>
</li>
<li>
<p>We can allocate an array of size 3, and store the number of empty slots of cars at index <code>0</code>, <code>1</code>, and <code>2</code>.</p>
<p>The <code>carType</code> here will act as an index after subtracting <code>1</code> from it.</p>
</li>
</ol>
<p>Readers can choose any of the two ways. We will proceed with the second way.</p>
<p>Thus, now our <strong>constructor</strong> in pseudo-code will look like this</p>
<pre><code class="language-pseudocode">ParkingSystem(int big, int medium, int small) {

    // Store the empty slots for each type of car
    this.empty = [big, medium, small]
}
</code></pre>
<p>Readers can appreciate the compactness obtained by using an array. We have reduced the number of variables from six to one.</p>
<blockquote>
<p><strong>Interview Tip:</strong> Reading the problem statement multiple times helps to formulate solutions elegantly.</p>
</blockquote>
<p>In the <code>addCar</code> function, we check if the number of empty slots is greater than <code>0</code>. If it is, we add the car and decrement the number of empty slots by <code>1</code>. In this case, we return <code>true</code>. Otherwise, we return <code>false</code>.</p>
<pre><code class="language-pseudocode">boolean addCar(int carType) {

    // Depending on carType, decide
    if empty[carType - 1] &gt; 0 {
        empty[carType - 1] -= 1
        return true
    }
    else {
        return false
    }
}
</code></pre>
<p>Thus using this approach we can solve the problem. Once solved, readers are advised to see codes in other languages and compare how classes and objects are implemented in different languages. Also, it's worth noting that we can also use a Hash map to solve this problem. Readers can try to solve the problem using a Hash map as well.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>In the <strong>constructor</strong>, create one array of size 3. Let's call it <code>empty</code>.</p>
<p><code>empty</code> will store the number of empty slots available for each type of car. Index <code>0</code> will be used for big cars, index <code>1</code> will be used for medium cars, and index <code>2</code> will be used for small cars. These limits will be passed as <code>big</code>, <code>medium</code>, and <code>small</code> respectively as parameters to the <strong>constructor</strong>. Initially, all the empty slots will be equal to the parking limit of each type of car.</p>
</li>
<li>
<p>In the <strong>addCar</strong> function, if the number of empty slots for <code>carType</code> is greater than <code>0</code>, then decrement the number of empty slots by 1 and return <code>true</code>. Else, return <code>false</code>.</p>
<p>The <code>if</code> condition will be similar to <code>if empty[carType - 1] &gt; 0</code>.</p>
</li>
</ol>
<br/>
Here is the visual representation of the above algorithm.   
!?!../Documents/1603/1603_Array.json:1280,720!?!   
<br/>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6FeuyXke/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of function calls.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>.</p>
<ul>
<li>
<p>In the <strong>constructor</strong>, we create one array of constant size, <code>empty</code>. Hence, the time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>In the <strong>addCar</strong> function, we check if the number of empty slots for a particular type of car is greater than <code>0</code>. This is done in constant time.</p>
</li>
</ul>
<p>Hence, the overall time complexity will be <span class="math inline">\(O(N)\)</span> since there are <span class="math inline">\(N\)</span> function-calls.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>
<p>In the <strong>constructor</strong>, we create one array of constant size, <code>empty</code>. Hence, the space complexity will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>In the <strong>addCar</strong> function, we do not use any extra space. Hence, the space complexity will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="extra">Extra</h3>
<details><summary> Many Programming Language has some <b>cool functionalities</b> that can be used to solve problems smartly. While this way is often not beginner-friendly, they often compact the code. Sometimes, they are even faster than conventional approaches. A few times they are slower too.
<br/>
<br/>
These functionalities are not always intuitive and are not always easy to understand. But, they are worth learning. They are often labeled as syntactic sugar.
<br/>
<br/>
Readers can click here to go through some of these cool functionalities. </summary>
<p>
<p>The condition to check if we can <code>addCar</code> was</p>
<pre><code>if empty[carType - 1] &gt; 0
</code></pre>
<p>We can use the decrement operator <code>--</code> to <strong>post</strong>-decrement the value of <code>empty[carType - 1]</code> by <code>1</code> and check if the value is greater than <code>0</code> in a single line. If greater than <code>0</code>, return <code>True</code>, decrementation already happened. Else, return <code>False</code>.</p>
<p>The <code>if</code> condition will be similar to what we have to return. Thus we can compact the code.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">boolean</span> <span style="color:#900;font-weight:bold">addCar</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> carType<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> empty<span style="color:#000;font-weight:bold">[</span>carType <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">]--</span> <span style="color:#000;font-weight:bold">&gt;</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p>This will always decrement the value of <code>empty[carType - 1]</code> by <code>1</code> and then check if the value is positive. The value will be decremented always, even if the condition is <code>false</code>. Thus, <code>empty[carType - 1]</code> may be negative which is absurd logically. Although, the code will still work fine.</p>
<p>Moreover, in the <strong>constraints</strong>, it is mentioned that</p>
<blockquote>
<p>At most <code>1000</code> calls will be made to <code>addCar</code></p>
</blockquote>
<p>If we call <code>addCar</code> 1000 times, then <code>empty[carType - 1]</code> will be decremented 1000 times.</p>
<p>However, if there were more calls than the magnitude of <code>Integer.MIN_VALUE</code>, then the value of <code>empty[carType - 1]</code> from negative may <strong>overflow</strong> to positive. Thus, the code will not work as expected.</p>
<p>A minute change in the condition can solve this problem.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">boolean</span> <span style="color:#900;font-weight:bold">addCar</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> carType<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> empty<span style="color:#000;font-weight:bold">[</span>carType <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">&gt;</span> 0 <span style="color:#000;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">--</span>empty<span style="color:#000;font-weight:bold">[</span>carType <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">&gt;=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p>This uses the <strong>short-circuiting</strong> property of the <code>&amp;&amp;</code> operator. If the first condition is <code>false</code>, then the second condition will not be evaluated. Thus, the value of <code>empty[carType - 1]</code> will not be decremented.</p>
<p>Another minute optimization is that we can use <code>short</code> instead of <code>int</code> for an <code>empty</code> array. This will reduce the space complexity. This we are doing because the parking limit is less than <code>1000</code>. Thus, we can use <code>short</code> instead of <code>int</code>. However, if the parking limit was <code>1000000</code>, then we would have to use <code>int</code> instead of <code>short</code>.</p>
<p>Here is the new code.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">ParkingSystem</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">[]</span> empty<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#900;font-weight:bold">ParkingSystem</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> big<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> medium<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> small<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">this</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">empty</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">[]{(</span><span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">)</span> big<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">)</span> medium<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">)</span> small<span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">boolean</span> <span style="color:#900;font-weight:bold">addCar</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> carType<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> empty<span style="color:#000;font-weight:bold">[</span>carType <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">&gt;</span> 0 <span style="color:#000;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">--</span>empty<span style="color:#000;font-weight:bold">[</span>carType <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">&gt;=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p>Programmers often use the <code>false</code> value of <code>0</code> to check if a variable is <code>false</code>.</p>
<p>Thus, this line in Python3</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> <span style="color:#999">self</span><span style="color:#000;font-weight:bold">.</span>empty[carType <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">0</span>:
</span></span></code></pre><p>can be written as</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> <span style="color:#999">self</span><span style="color:#000;font-weight:bold">.</span>empty[carType <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>]:
</span></span></code></pre><p>All these small things are often impressive. Readers can gain these skills by solving more problems.</p>
</p>
</details>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/destroy-sequential-targets/description" target="_blank" rel="noopener noreferrer">Destroy Sequential Targets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> consisting of positive integers, representing targets on a number line. You are also given an integer <code>space</code>.</p>

<p>You have a machine which can destroy targets. <strong>Seeding</strong> the machine with some <code>nums[i]</code> allows it to destroy all targets with values that can be represented as <code>nums[i] + c * space</code>, where <code>c</code> is any non-negative integer. You want to destroy the <strong>maximum</strong> number of targets in <code>nums</code>.</p>

<p>Return<em> the <strong>minimum value</strong> of </em><code>nums[i]</code><em> you can seed the machine with to destroy the maximum number of targets.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,7,8,1,1,5], space = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> If we seed the machine with nums[3], then we destroy all targets equal to 1,3,5,7,9,... 
In this case, we would destroy 5 total targets (all except for nums[2]). 
It is impossible to destroy more than 5 targets, so we return nums[3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,2,4,6], space = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> Seeding the machine with nums[0], or nums[3] destroys 3 targets. 
It is not possible to destroy more than 3 targets.
Since nums[0] is the minimal integer that can destroy 3 targets, we return 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,2,5], space = 100
<strong>Output:</strong> 2
<strong>Explanation:</strong> Whatever initial seed we select, we can only destroy 1 target. The minimal seed is nums[1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= space &lt;=&nbsp;10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/detect-squares/description" target="_blank" rel="noopener noreferrer">Detect Squares</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">design</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a stream of points on the X-Y plane. Design an algorithm that:</p>

<ul>
	<li><strong>Adds</strong> new points from the stream into a data structure. <strong>Duplicate</strong> points are allowed and should be treated as different points.</li>
	<li>Given a query point, <strong>counts</strong> the number of ways to choose three points from the data structure such that the three points and the query point form an <strong>axis-aligned square</strong> with <strong>positive area</strong>.</li>
</ul>

<p>An <strong>axis-aligned square</strong> is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.</p>

<p>Implement the <code>DetectSquares</code> class:</p>

<ul>
	<li><code>DetectSquares()</code> Initializes the object with an empty data structure.</li>
	<li><code>void add(int[] point)</code> Adds a new point <code>point = [x, y]</code> to the data structure.</li>
	<li><code>int count(int[] point)</code> Counts the number of ways to form <strong>axis-aligned squares</strong> with point <code>point = [x, y]</code> as described above.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/01/image.png" style="width: 869px; height: 504px;" />
<pre>
<strong>Input</strong>
[&quot;DetectSquares&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
<strong>Output</strong>
[null, null, null, null, 1, 0, null, 2]

<strong>Explanation</strong>
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>point.length == 2</code></li>
	<li><code>0 &lt;= x, y &lt;= 1000</code></li>
	<li>At most <code>3000</code> calls <strong>in total</strong> will be made to <code>add</code> and <code>count</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/determine-if-string-halves-are-alike/description" target="_blank" rel="noopener noreferrer">Determine if String Halves Are Alike</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of even length. Split this string into two halves of equal lengths, and let <code>a</code> be the first half and <code>b</code> be the second half.</p>

<p>Two strings are <strong>alike</strong> if they have the same number of vowels (<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;A&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;I&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;U&#39;</code>). Notice that <code>s</code> contains uppercase and lowercase letters.</p>

<p>Return <code>true</code><em> if </em><code>a</code><em> and </em><code>b</code><em> are <strong>alike</strong></em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;book&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> a = &quot;b<u>o</u>&quot; and b = &quot;<u>o</u>k&quot;. a has 1 vowel and b has 1 vowel. Therefore, they are alike.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;textbook&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> a = &quot;t<u>e</u>xt&quot; and b = &quot;b<u>oo</u>k&quot;. a has 1 vowel whereas b has 2. Therefore, they are not alike.
Notice that the vowel o is counted twice.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s.length</code> is even.</li>
	<li><code>s</code> consists of <strong>uppercase and lowercase</strong> letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/determine-if-two-strings-are-close/description" target="_blank" rel="noopener noreferrer">Determine if Two Strings Are Close</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Two strings are considered <strong>close</strong> if you can attain one from the other using the following operations:</p>

<ul>
	<li>Operation 1: Swap any two <strong>existing</strong> characters.

	<ul>
		<li>For example, <code>a<u>b</u>cd<u>e</u> -&gt; a<u>e</u>cd<u>b</u></code></li>
	</ul>
	</li>
	<li>Operation 2: Transform <strong>every</strong> occurrence of one <strong>existing</strong> character into another <strong>existing</strong> character, and do the same with the other character.
	<ul>
		<li>For example, <code><u>aa</u>c<u>abb</u> -&gt; <u>bb</u>c<u>baa</u></code> (all <code>a</code>&#39;s turn into <code>b</code>&#39;s, and all <code>b</code>&#39;s turn into <code>a</code>&#39;s)</li>
	</ul>
	</li>
</ul>

<p>You can use the operations on either string as many times as necessary.</p>

<p>Given two strings, <code>word1</code> and <code>word2</code>, return <code>true</code><em> if </em><code>word1</code><em> and </em><code>word2</code><em> are <strong>close</strong>, and </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abc&quot;, word2 = &quot;bca&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> You can attain word2 from word1 in 2 operations.
Apply Operation 1: &quot;a<u>bc</u>&quot; -&gt; &quot;a<u>cb</u>&quot;
Apply Operation 1: &quot;<u>a</u>c<u>b</u>&quot; -&gt; &quot;<u>b</u>c<u>a</u>&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;a&quot;, word2 = &quot;aa&quot;
<strong>Output:</strong> false
<strong>Explanation: </strong>It is impossible to attain word2 from word1, or vice versa, in any number of operations.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;cabbba&quot;, word2 = &quot;abbccc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> You can attain word2 from word1 in 3 operations.
Apply Operation 1: &quot;ca<u>b</u>bb<u>a</u>&quot; -&gt; &quot;ca<u>a</u>bb<u>b</u>&quot;
Apply Operation 2: &quot;<u>c</u>aa<u>bbb</u>&quot; -&gt; &quot;<u>b</u>aa<u>ccc</u>&quot;
Apply Operation 2: &quot;<u>baa</u>ccc&quot; -&gt; &quot;<u>abb</u>ccc&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>word1</code> and <code>word2</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/distant-barcodes/description" target="_blank" rel="noopener noreferrer">Distant Barcodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a warehouse, there is a row of barcodes, where the <code>i<sup>th</sup></code> barcode is <code>barcodes[i]</code>.</p>

<p>Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> barcodes = [1,1,1,2,2,2]
<strong>Output:</strong> [2,1,2,1,2,1]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> barcodes = [1,1,1,1,2,2,3,3]
<strong>Output:</strong> [1,3,1,3,1,2,1,2]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= barcodes.length &lt;= 10000</code></li>
	<li><code>1 &lt;= barcodes[i] &lt;= 10000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/divide-array-into-equal-pairs/description" target="_blank" rel="noopener noreferrer">Divide Array Into Equal Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> consisting of <code>2 * n</code> integers.</p>

<p>You need to divide <code>nums</code> into <code>n</code> pairs such that:</p>

<ul>
	<li>Each element belongs to <strong>exactly one</strong> pair.</li>
	<li>The elements present in a pair are <strong>equal</strong>.</li>
</ul>

<p>Return <code>true</code> <em>if nums can be divided into</em> <code>n</code> <em>pairs, otherwise return</em> <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,3,2,2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> 
There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.
If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> false
<strong>Explanation:</strong> 
There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>nums.length == 2 * n</code></li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 500</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting">Approach 1: Sorting</h3>
<h4 id="intuition">Intuition</h4>
<p>To begin with, let's think how we would solve the problem manually with a small example, such as <code>[3, 2, 3, 2, 2, 2]</code>. To find matching pairs, we naturally look for equal numbers: &quot;Here's a <code>3</code>, where's another <code>3</code>? Here's a <code>2</code>, where's another <code>2</code>?&quot; This process works intuitively, but implementing it directly would require multiple passes over the array - an approach that quickly becomes inefficient as the array grows larger.</p>
<p>But what if we could somehow arrange the elements of the array so that equal numbers appear next to each other? In that case, checking for matching pairs would become much simpler - we would only need to examine consecutive elements. This insight suggests sorting the array as a solution.</p>
<p>Let's see what happens when we sort our example: <code>[2, 2, 2, 2, 3, 3]</code>. Now the equal numbers are automatically grouped together! This arrangement makes our task much simpler. Instead of searching the entire array for matching pairs, we can just look at adjacent elements.</p>
<p>After sorting, we can iterate through the array two elements at a time, pairing each number with its neighbor. For each pair, we check if both elements are equal. If we ever encounter a pair of consecutive elements that don't match, we know that pairing all elements equally is impossible and can return <code>false</code> immediately.</p>
<p>If we reach the end of the array, without finding any mismatched pairs, all elements were paired with an equal. In that case, we return <code>true</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Sort the array <code>nums</code> in non-decreasing order to group identical elements next to each other.</li>
<li>Iterate through the array <code>nums</code> with a position counter <code>pos</code>.
<ul>
<li>Check if the element <code>nums[pos]</code> matches the element <code>nums[pos + 1]</code>.</li>
<li>If these elements do not match, return <code>false</code> since we cannot form valid pairs.</li>
<li>Move <code>pos</code> forward by <code>2</code> positions to check the next potential pair.</li>
</ul>
</li>
<li>If we successfully checked all pairs without finding any mismatches, return <code>true</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/CqH5Rhw3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(2 \cdot n\)</span> be the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The primary operation in this approach is sorting the array, which takes <span class="math inline">\(O(2n \log (2n))\)</span> time. After sorting, we perform a single pass through the array in increments of <span class="math inline">\(2\)</span>, which requires <span class="math inline">\(O(n)\)</span> operations. Since <span class="math inline">\(O(2n \log (2n))\)</span> dominates <span class="math inline">\(O(n)\)</span>, the overall time complexity remains <span class="math inline">\(O(2n \log (2n))\)</span>, which simplifies to <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(S)\)</span></p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log (2n)) = O(\log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log (2n)) = O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(2n) = O(n)\)</span>.</li>
</ul>
<p>Apart from this, we don't use any extra space that grows with the input size. So, the space complexity is <span class="math inline">\(O(S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-map">Approach 2: Map</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's approach this problem from a different angle. Instead of arranging numbers to find pairs, what if we count how many times each number appears in our array?</p>
<p>For a number to be successfully paired, it needs to appear an even number of times. For example, if we have the number <code>5</code> appearing three times, we can never pair all instances of <code>5</code> because one will always be left over.</p>
<p>Let's look at an example array <code>[1, 2, 2, 1, 3, 3]</code>. When we count, we find two <code>1</code>s, two <code>2</code>s, and two <code>3</code>s. Since each number appears an even number of times, we can pair them all up perfectly. But if we had <code>[1, 2, 2, 2, 1, 3, 3, 3]</code>, we'd run into a problem. While the <code>1</code>s can still be paired, both the <code>2</code>s and the <code>3</code>s appear an odd number of times, leaving one leftover element in each case.</p>
<p>This idea leads us to a frequency-based solution. A popular data structure to count and store the frequency of elements is the hash map. We'll create a hash map called <code>frequency</code>, where the key is the number and the value is how many times it shows up. We'll go through the array once, updating the map each time we see a number.</p>
<p>After we've counted everything, our job becomes simple: we need to check if each number appears an even number of times. If we find any number that shows up an odd number of times, we know right away that perfect pairing is impossible, so we return <code>false</code>. If every number appears an even number of times, we can return <code>true</code>.</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Create a frequency map <code>frequency</code> to store the count of each number in <code>nums</code>.</li>
<li>For each number <code>num</code> in the array <code>nums</code>:
<ul>
<li>If <code>num</code> already exists in <code>frequency</code>, increment its count by <code>1</code>.</li>
<li>Else, add it with a count of <code>1</code>.</li>
</ul>
</li>
<li>For each unique number <code>num</code> in the <code>frequency</code> map:
<ul>
<li>Get the count of this number from <code>frequency</code>.</li>
<li>If the count is not divisible by <code>2</code>, return <code>false</code> since we cannot pair all occurrences.</li>
</ul>
</li>
<li>If we checked all numbers without finding any odd frequencies, return <code>true</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YVFNujtw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(2 \cdot n\)</span> be the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The approach involves two main steps: first, we iterate through <code>nums</code> to build the frequency map, which takes <span class="math inline">\(O(2n) = O(n)\)</span>, as all hashmap operations - including accessing and updating - take constant time on average. Then, we iterate through the keys of the map to check if each count is even, which takes <span class="math inline">\(O(n)\)</span> time in the worst case (when all elements are distinct). Since both steps run sequentially and independently in <span class="math inline">\(O(n)\)</span>, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The frequency map stores at most <span class="math inline">\(O(2n)\)</span> unique keys in the worst case (when all elements are distinct). Since this additional space grows linearly with input size, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-boolean-array">Approach 3: Boolean Array</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Our core task is simple: when we encounter a number for the first time, we need to find a partner for it. When we see it again, we've completed a pair.</p>
<p>Think of it like using a light switch for each number. The first time we see a number, we flip the switch on, indicating that the current element needs to be paired with a matching one. The second time we encounter a number, we flip the switch off, as a pair is successfully formed. If all numbers can be paired, every switch should end up in the off position. Since each light switch can be implemented using a boolean value (<code>true</code> or <code>false</code>), we'll represent the &quot;state&quot; of each number (waiting for a partner or not) using a boolean array.</p>
<p>The boolean array <code>needsPair</code> acts as our set of switches. The index represents the number, and the boolean value represents whether we're currently looking for a partner for that number. When we toggle <code>needsPair[num]</code>, we're essentially saying &quot;I either need a partner for <code>num</code>&quot; (<code>true</code>) or &quot;I've found a complete pair&quot; (<code>false</code>).</p>
<p>Before we start, we need to know how big to make our boolean array. We'll look through <code>nums</code> to find the biggest number, then make our array one element larger than that. This way, we'll have enough room for all possible numbers.</p>
<p>We can then loop over <code>nums</code> and flip the value in the boolean array for each element in <code>nums</code>. Finally, we run another loop over <code>needsPair</code> and check if any value is <code>true</code>. If it is, we immediately return <code>false</code>, since there is an unpaired element remaining. Otherwise, if all the values are <code>false</code>, we can return <code>true</code> as our answer.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a variable <code>maxNum</code> to store the largest value in the array <code>nums</code>.</li>
<li>For each number <code>num</code> in <code>nums</code>:
<ul>
<li>Update <code>maxNum</code> if <code>num</code> is larger than the current <code>maxNum</code>.</li>
</ul>
</li>
<li>Create a boolean array <code>needsPair</code> of size <code>maxNum + 1</code> to track pairing status.</li>
<li>For each number <code>num</code> in <code>nums</code>:
<ul>
<li>Toggle the value at <code>needsPair[num]</code> from <code>true</code> to <code>false</code> or <code>false</code> to <code>true</code>.</li>
</ul>
</li>
<li>For each number <code>num</code> in <code>nums</code>:
<ul>
<li>Check if <code>needsPair[num]</code> is <code>true</code>.</li>
<li>If <code>true</code>, it means this number appeared an odd number of times, so return <code>false</code>.</li>
</ul>
</li>
<li>If no unpaired numbers are found, return <code>true</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/NVEyXgH8/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(2 \cdot n\)</span> be the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The approach consists of three main steps. First, we find the greatest element in <code>nums</code>, which takes <span class="math inline">\(O(n)\)</span> time. Next, we iterate through <code>nums</code> again to toggle the pairing status in the <code>needsPair</code> array, which also takes <span class="math inline">\(O(n)\)</span> time. Finally, we perform another pass through <code>nums</code> to check if any number remains unpaired, requiring another <span class="math inline">\(O(n)\)</span> time. Since all steps run in <span class="math inline">\(O(n)\)</span>, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\text{maxNum})\)</span></p>
<p>The algorithm uses an auxiliary boolean array <code>needsPair</code> of size <span class="math inline">\(\text{maxNum + 1}\)</span>, where <span class="math inline">\(\text{maxNum}\)</span> is the largest number in <code>nums</code>. This means the space usage depends on <span class="math inline">\(\text{maxNum}\)</span>, making the space complexity <span class="math inline">\(O(\text{maxNum})\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-hash-set">Approach 4: Hash Set</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The key idea behind this approach is that when an element finds its matching pair, we no longer need to track either of them. This means we only need to remember which numbers are still looking for their partners.</p>
<p>Let's loop over <code>nums</code> and try to pair each element. We'll maintain another data structure which will hold all elements waiting to find their pairs. For each element in <code>nums</code>, we'll first check if it has a pair available to match. If it does, we can remove the unpaired element, freeing up space. If it doesn't have a matching element, we'll add the element to the data structure for future pairing.</p>
<p>To implement this, we need a data structure that allows us to efficiently look up whether a particular element exists in it or not, along with adding and removing elements. <a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/">Hash sets</a> are perfectly suited for this task. Hash sets allow for the lookup, addition, and removal of elements in constant time.</p>
<p>Once we have looped through the entire array, we check the set. If it is empty, all elements have found a pair, so we return <code>true</code>. If any elements remain in the set, they can't find a pair, so we return <code>false</code>.</p>
<p>The slideshow below demonstrates the algorithm in action:</p>
<p>!?!../Documents/2206/slideshow.json:654,742!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Create a hash set <code>unpaired</code> to track numbers that haven't found their pairs yet.</li>
<li>For each number <code>num</code> in <code>nums</code>:
<ul>
<li>If <code>num</code> is already in <code>unpaired</code>, remove it (we found its pair).</li>
<li>Else, add it to <code>unpaired</code> (waiting for its pair).</li>
</ul>
</li>
<li>Check if <code>unpaired</code> is empty:
<ul>
<li>If empty, return <code>true</code> as all numbers found their pairs.</li>
<li>If not empty, return <code>false</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/RpgUPKtJ/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(2 \cdot n\)</span> be the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The approach iterates through <code>nums</code> once, performing constant-time operations for each element. Checking for an element’s existence in a hash set and adding or removing an element both take <span class="math inline">\(O(1)\)</span> time on average. Since we perform these operations <span class="math inline">\(2n\)</span> times, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The hash set stores at most <span class="math inline">\(O(2n)\)</span> elements in the worst case, where all elements in <code>nums</code> are unique before pairing begins. Since the additional space scales linearly with <span class="math inline">\(2n\)</span>, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h4 id="why-a-bit-manipulation-solution-was-not-included">Why a Bit Manipulation Solution Was Not Included</h4>
<h5 id="xor-approach-limitations">XOR Approach Limitations</h5>
<p>While XOR operations are useful in many bit manipulation problems, they aren't suitable for this particular challenge. Consider the array <code>[1,2,4,7]</code>. If we XOR all elements, we get <code>1^2^4^7 = 0</code>. This result doesn't tell us whether pairs can be formed, as XOR only indicates if each bit position has an even number of <code>1</code>s overall. XOR loses the critical frequency information needed to determine if each element appears exactly twice.</p>
<h5 id="hashmap-as-a-better-alternative">Hashmap as a Better Alternative</h5>
<p>Despite this problem's bit manipulation tag, we opted against using bitsets since they lack universal support across programming languages. A hashmap solution offers better portability and readability while directly addressing the problem's core challenge: tracking how many times each element appears in the array.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/equal-sum-arrays-with-minimum-number-of-operations/description" target="_blank" rel="noopener noreferrer">Equal Sum Arrays With Minimum Number of Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays of integers <code>nums1</code> and <code><font face="monospace">nums2</font></code>, possibly of different lengths. The values in the arrays are between <code>1</code> and <code>6</code>, inclusive.</p>

<p>In one operation, you can change any integer&#39;s value in <strong>any </strong>of the arrays to <strong>any</strong> value between <code>1</code> and <code>6</code>, inclusive.</p>

<p>Return <em>the minimum number of operations required to make the sum of values in </em><code>nums1</code><em> equal to the sum of values in </em><code>nums2</code><em>.</em> Return <code>-1</code>​​​​​ if it is not possible to make the sum of the two arrays equal.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.
- Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [<u><strong>6</strong></u>,1,2,2,2,2].
- Change nums1[5] to 1. nums1 = [1,2,3,4,5,<strong><u>1</u></strong>], nums2 = [6,1,2,2,2,2].
- Change nums1[2] to 2. nums1 = [1,2,<strong><u>2</u></strong>,4,5,1], nums2 = [6,1,2,2,2,2].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,1,1,1,1,1,1], nums2 = [6]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [6,6], nums2 = [1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. 
- Change nums1[0] to 2. nums1 = [<strong><u>2</u></strong>,6], nums2 = [1].
- Change nums1[1] to 2. nums1 = [2,<strong><u>2</u></strong>], nums2 = [1].
- Change nums2[0] to 4. nums1 = [2,2], nums2 = [<strong><u>4</u></strong>].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-lonely-numbers-in-the-array/description" target="_blank" rel="noopener noreferrer">Find All Lonely Numbers in the Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. A number <code>x</code> is <strong>lonely</strong> when it appears only <strong>once</strong>, and no <strong>adjacent</strong> numbers (i.e. <code>x + 1</code> and <code>x - 1)</code> appear in the array.</p>

<p>Return <em><strong>all</strong> lonely numbers in </em><code>nums</code>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,6,5,8]
<strong>Output:</strong> [10,8]
<strong>Explanation:</strong> 
- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.
- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.
- 5 is not a lonely number since 6 appears in nums and vice versa.
Hence, the lonely numbers in nums are [10, 8].
Note that [8, 10] may also be returned.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,3]
<strong>Output:</strong> [1,5]
<strong>Explanation:</strong> 
- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.
- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.
- 3 is not a lonely number since it appears twice.
Hence, the lonely numbers in nums are [1, 5].
Note that [5, 1] may also be returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-consecutive-integers-from-a-data-stream/description" target="_blank" rel="noopener noreferrer">Find Consecutive Integers from a Data Stream</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">data-stream</span> <span class="topic-badge">design</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>For a stream of integers, implement a data structure that checks if the last <code>k</code> integers parsed in the stream are <strong>equal</strong> to <code>value</code>.</p>

<p>Implement the <strong>DataStream</strong> class:</p>

<ul>
	<li><code>DataStream(int value, int k)</code> Initializes the object with an empty integer stream and the two integers <code>value</code> and <code>k</code>.</li>
	<li><code>boolean consec(int num)</code> Adds <code>num</code> to the stream of integers. Returns <code>true</code> if the last <code>k</code> integers are equal to <code>value</code>, and <code>false</code> otherwise. If there are less than <code>k</code> integers, the condition does not hold true, so returns <code>false</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;DataStream&quot;, &quot;consec&quot;, &quot;consec&quot;, &quot;consec&quot;, &quot;consec&quot;]
[[4, 3], [4], [4], [4], [3]]
<strong>Output</strong>
[null, false, false, true, false]

<strong>Explanation</strong>
DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3 
dataStream.consec(4); // Only 1 integer is parsed, so returns False. 
dataStream.consec(4); // Only 2 integers are parsed.
                      // Since 2 is less than k, returns False. 
dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True. 
dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].
                      // Since 3 is not equal to value, it returns False.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= value, num &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>10<sup>5</sup></code> calls will be made to <code>consec</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description" target="_blank" rel="noopener noreferrer">Find Longest Special Substring That Occurs Thrice I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sliding-window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that consists of lowercase English letters.</p>

<p>A string is called <strong>special</strong> if it is made up of only a single character. For example, the string <code>&quot;abc&quot;</code> is not special, whereas the strings <code>&quot;ddd&quot;</code>, <code>&quot;zz&quot;</code>, and <code>&quot;f&quot;</code> are special.</p>

<p>Return <em>the length of the <strong>longest special substring</strong> of </em><code>s</code> <em>which occurs <strong>at least thrice</strong></em>, <em>or </em><code>-1</code><em> if no special substring occurs at least thrice</em>.</p>

<p>A <strong>substring</strong> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaaa&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;aa&quot;: substrings &quot;<u><strong>aa</strong></u>aa&quot;, &quot;a<u><strong>aa</strong></u>a&quot;, and &quot;aa<u><strong>aa</strong></u>&quot;.
It can be shown that the maximum length achievable is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcdef&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> There exists no special substring which occurs at least thrice. Hence return -1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcaba&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;a&quot;: substrings &quot;<u><strong>a</strong></u>bcaba&quot;, &quot;abc<u><strong>a</strong></u>ba&quot;, and &quot;abcab<u><strong>a</strong></u>&quot;.
It can be shown that the maximum length achievable is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 50</code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> consisting of lowercase letters. Our task is to return the length of the longest substring of <code>s</code> that has at least 3 of the same letters - we'll call this a special substring. If no such special substring exists, we should return -1.</p>
<blockquote>
<p>A substring is a contiguous, non-empty sequence of characters within a string.</p>
</blockquote>
<p>The length of the string <code>s</code> can be at most 50. Therefore, we can use brute force techniques to solve this problem. After solving this one, you might want to try the <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/description/">harder version</a> of the problem.</p>
<hr />
<h3 id="approach-1-brute-force-approach">Approach 1: Brute-Force Approach</h3>
<h4 id="intuition">Intuition</h4>
<p>A logical approach would be to generate all substrings of the string <code>s</code> and check if each substring is special or not.</p>
<p>To generate all substrings, we can use two loop pointers: <code>start</code> and <code>end</code>. The <code>start</code> pointer indicates the starting index of the substring, and the <code>end</code> pointer indicates the ending index. We will loop through all possible values of <code>start</code> and <code>end</code> where <code>end</code> is greater than <code>start</code>. For each <code>start</code> and <code>end</code> grouping, we will extract the substring and store it in a string (say <code>currString</code>).</p>
<p>Since appending a character to the end of a list or string takes constant time, we can avoid using another loop to generate the substring. Instead, we will add the character at the <code>end</code> index to <code>currString</code>. While doing this, we can check if the newly added character maintains the &quot;special&quot; property. If the newly added character is not equal to the previous character, we can stop processing this substring further.</p>
<p>For every valid substring, we will increment its frequency in a map, where the substring is the key and its frequency is the value. After processing all substrings, we can find the longest substring in the map that has a frequency of at least three and return its length as the result.</p>
<p><img src="../Figures/2981/image1.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a map <code>count</code> to store the frequency of all substrings.</li>
<li>Iterate over the string <code>s</code> using two nested loops:
<ul>
<li>Outer loop with index <code>start</code> from 0 to the length of the string:
<ul>
<li>Create a string <code>currString</code> to store the substrings.</li>
<li>Inner loop with index <code>end</code> starting from <code>start</code> to the length of the string:
<ul>
<li>If the current substring is empty or the last character matches the current character, append the character to <code>currString</code> and increment its frequency in <code>count</code>.</li>
<li>If the current character does not match the last character, stop processing this substring.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize a variable <code>ans</code> to store the length of the longest substring with a frequency of at least 3.</li>
<li>Iterate over the map <code>count</code>:
<ul>
<li>For each substring, if its frequency is at least 3 and its length is greater than <code>ans</code>, update <code>ans</code> with the length of the substring.</li>
</ul>
</li>
<li>If no substring with the required frequency is found, return -1. Otherwise, return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/K9YykFH9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^3)\)</span></p>
<p>The algorithm generates all substrings of the input string <code>s</code> using two nested loops. The outer loop runs <code>n</code> times. For each iteration of the outer loop, the inner loop iterates <code>n - i</code> times, where <code>i</code> is the index of the outer loop. This means the total number of iterations is the sum of the first <code>n</code> natural numbers, which equals <span class="math inline">\(n \cdot (n+1) / 2\)</span>. Therefore, the time complexity for generating all substrings is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For each substring, the algorithm checks and updates the frequency in a map, which takes <span class="math inline">\(O(size)\)</span> time, where <code>size</code> denotes the length of the substring added in the map.</p>
<p>Therefore, the overall time complexity of the algorithm is given by O(n^3).</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a temporary string, <code>currString</code>, to store substrings. The size of <code>currString</code> varies, but in the worst case, it can hold the entire string, contributing <span class="math inline">\(O(n)\)</span> additional space. Since the string <code>currString</code> is initialized <code>n</code> times, the total space is given by <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The algorithm uses a map to store all unique substrings and their frequencies. In the worst case, such as when all characters in the string are identical, the total number of substrings can go up to <span class="math inline">\(n \cdot (n+1) / 2\)</span>. Additionally, each substring requires space proportional to its length, leading to an overall space requirement of <span class="math inline">\(O(n^2)\)</span> in the worst case.</p>
<p>Therefore, the total space complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-hashing">Approach 2: Optimized Hashing</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we stored substrings in a map with their frequency. Since all special substrings consist of equal characters, we can optimize by storing them as a pair <code>{char character, int substringLength}</code>.</p>
<p>This optimization improves the algorithm because adding a string to the map takes <code>O(substringLength)</code> time. By storing <code>{character, substringLength}</code> as a pair, which behaves like an array of length 2, insertion into the map now takes constant time.</p>
<p>After populating the map with these pairs, we find the maximum <code>substringLength</code> value for any pair with a frequency of at least 3 and return it as the result.</p>
<blockquote>
<p>Note: A frequency array can also be used in this scenario. It is a good choice as it provides an efficient way to count and track occurrences, particularly when the range of values is limited.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a map <code>count</code> of type <code>map&lt;pair&lt;char, int&gt;, int&gt;</code> to store the frequency of substrings, where each key is a pair of a character and the substring length, and the value is its frequency.</li>
<li>Use an outer loop with index <code>start</code> from <code>0</code> to the length of the string (<code>s.length()</code>):
<ul>
<li>Initialize <code>substringLength</code> to <code>0</code> to track the length of the current substring of repeated characters.</li>
<li>Store the current character <code>character = s[start]</code>.</li>
</ul>
</li>
<li>Use an inner loop with index <code>end</code> starting from <code>start</code> and iterating to the end of the string (<code>s.length()</code>):
<ul>
<li>If the character <code>s[end]</code> matches <code>character</code>:
<ul>
<li>Increment <code>substringLength</code>.</li>
<li>Update the frequency of the pair <code>{character, substringLength}</code> in the <code>count</code> map.</li>
</ul>
</li>
<li>If the character <code>s[end]</code> does not match <code>c</code>, break the loop.</li>
</ul>
</li>
<li>Initialize a variable <code>ans</code> to <code>-1</code>.</li>
<li>Iterate over the entries in the <code>count</code> map:
<ul>
<li>For each entry, check if its frequency is at least 3 and its substring length is greater than <code>ans</code>. If both conditions are true, update <code>ans</code> with the length of the substring.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/RTh9x9yB/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm generates all substrings of the input string <code>s</code> using two nested loops. The outer loop runs <code>n</code> times. For each iteration of the outer loop, the inner loop iterates <code>n - end</code> times, where <code>end</code> is the index of the outer loop. This means the total number of iterations is the sum of the first <code>n</code> natural numbers, which equals <span class="math inline">\(n \cdot (n+1) / 2\)</span>. Therefore, the time complexity for generating all substrings is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For each substring, the algorithm checks and updates the frequency of the pair in a map, which takes <span class="math inline">\(O(1)\)</span> time.</p>
<p>Therefore, the overall time complexity of the algorithm is given by O(n^2).</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a map to store all unique substrings and their frequencies. In the worst case, such as when all characters in the string are identical, the total number of substrings can go up to <span class="math inline">\(n \cdot (n+1) / 2\)</span>.</p>
<p>Additionally, each substring requires space proportional to its length, leading to an overall space requirement of <span class="math inline">\(O(n^2)\)</span> in the worst case.</p>
<p>Therefore, the total space complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="further-thoughts">Further Thoughts:</h3>
<p>This problem has solutions with time complexities of <span class="math inline">\(O(n^3)\)</span> and <span class="math inline">\(O(n^2)\)</span>, but there is an even more efficient solution that runs in <span class="math inline">\(O(n)\)</span> time.</p>
<p>The single pass solution will be the focus of the second part of this <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/">problem</a>, which is designed almost the same but with tighter constraints to encourage further optimization. We now recommend attempting to solve the second part using the single pass approach.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/description" target="_blank" rel="noopener noreferrer">Find Longest Special Substring That Occurs Thrice II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sliding-window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that consists of lowercase English letters.</p>

<p>A string is called <strong>special</strong> if it is made up of only a single character. For example, the string <code>&quot;abc&quot;</code> is not special, whereas the strings <code>&quot;ddd&quot;</code>, <code>&quot;zz&quot;</code>, and <code>&quot;f&quot;</code> are special.</p>

<p>Return <em>the length of the <strong>longest special substring</strong> of </em><code>s</code> <em>which occurs <strong>at least thrice</strong></em>, <em>or </em><code>-1</code><em> if no special substring occurs at least thrice</em>.</p>

<p>A <strong>substring</strong> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaaa&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;aa&quot;: substrings &quot;<u><strong>aa</strong></u>aa&quot;, &quot;a<u><strong>aa</strong></u>a&quot;, and &quot;aa<u><strong>aa</strong></u>&quot;.
It can be shown that the maximum length achievable is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcdef&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> There exists no special substring which occurs at least thrice. Hence return -1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcaba&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The longest special substring which occurs thrice is &quot;a&quot;: substrings &quot;<u><strong>a</strong></u>bcaba&quot;, &quot;abc<u><strong>a</strong></u>ba&quot;, and &quot;abcab<u><strong>a</strong></u>&quot;.
It can be shown that the maximum length achievable is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> consisting of lowercase letters. A string is considered special if all its characters are the same. Our task is to find the longest special substring of <code>s</code> that appears at least three times. If no such substring exists, we should return -1.</p>
<blockquote>
<p>A substring is a contiguous, non-empty sequence of characters within a string.</p>
</blockquote>
<p>This problem is a more challenging version of the first part, <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/">2981. Find Longest Special Substring That Occurs Thrice I</a>. The constraints are significantly tighter, with the length of the string <code>s</code> now reaching up to 500,000 characters. This makes the problem more complex and resource-intensive to solve. Before tackling this harder version, it is strongly advised that you first solve the <a href="https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description/">easier version</a> of the problem. Solving the easier version will give you a solid understanding of the core concepts and techniques needed to approach the more demanding iteration.</p>
<p>In the first part, we discussed two solutions: an <span class="math inline">\(O(n^3)\)</span> solution and an <span class="math inline">\(O(n^2)\)</span> solution. Here, we will focus on more optimized versions of these solutions to ensure they can handle the tighter constraints and pass the test cases efficiently.</p>
<hr />
<h3 id="approach-1-hashing">Approach 1: Hashing</h3>
<h4 id="intuition">Intuition</h4>
<p>In the simpler version of this problem, we generated all substrings of <code>s</code> and tracked their counts using a map. However, in this version, we aim to find a more efficient approach—ideally, linear or log-linear. Therefore, we cannot afford to generate all substrings of <code>s</code>.</p>
<p>To optimize, we can focus on the special substrings of <code>s</code>. This means we don't need to generate all substrings and then filter for special ones. Instead, let's analyze some examples to understand the pattern:</p>
<ol>
<li>
<p>Example 1: <code>a</code></p>
<ul>
<li>There is exactly one special substring: <code>a</code>.</li>
</ul>
</li>
<li>
<p>Example 2: <code>aa</code></p>
<ul>
<li>There are three special substrings: <code>a</code>, <code>a</code>, <code>aa</code>.</li>
<li>Here, <code>a</code> appears twice and <code>aa</code> appears once.</li>
</ul>
</li>
<li>
<p>Example 3: <code>aaa</code></p>
<ul>
<li>There are six special substrings: <code>a</code>, <code>a</code>, <code>a</code>, <code>aa</code>, <code>aa</code>, <code>aaa</code>.</li>
<li>Here, <code>a</code> appears thrice, <code>aa</code> appears twice, and <code>aaa</code> appears once.</li>
</ul>
</li>
</ol>
<p>From these examples, we can make an observation:<br />
When a new character is added to <code>s</code>, if the length of the longest special substring ending at this character increases to <code>substringLength</code>, then the count of all shorter special substrings of length less than <code>substringLength</code> also increments by 1. This happens because new substrings can be formed by appending the current character to previously existing substrings.</p>
<p>While iterating through the string <code>s</code>, <code>substringLength</code> represents the length of the longest special substring ending at the current character. We can store the count of characters in <code>s</code> with the longest special substring length <code>substringLength</code> using a mapping, <code>frequency[character][substringLength]</code>.</p>
<p>As discussed, all substrings of lengths less than <code>substringLength</code> should also be incremented by the value of <code>frequency[character][substringLength]</code>. However, updating the frequencies for all lengths down to <code>1</code> each time a new character is processed would be inefficient.</p>
<p>To optimize this, we can calculate the cumulative sum of frequencies starting from the longest <code>substringLength</code> down to <code>1</code>, after processing all the characters of the string. If the cumulative sum reaches a value of <code>3</code> at any point, we can immediately conclude that there are at least <code>3</code> substrings of that length. We can repeat this process for all the possible <code>character</code> values and return the maximum result among them.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a map <code>frequency</code> to store the frequency of substrings.
<ul>
<li><code>frequency</code> is a 2D array where the first index represents the character and the second index represents the length of consecutive substrings.</li>
</ul>
</li>
<li>Initialize <code>substringLength</code> to 1 and <code>previousCharacter</code> to the first character, and set the frequency of the first character at length 1 to 1: <code>frequency[previousCharacter - 'a'][1] = 1</code>.</li>
<li>For each character in the string:
<ul>
<li>If the current character equals the previous character:
<ul>
<li>Increment <code>substringLength</code>.</li>
<li>Increment the frequency of the current character for the new substring length: <code>frequency[currentCharacter - 'a'][substringLength] += 1</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Reset <code>substringLength</code> to 1 and update the frequency of the current character for substring length 1: <code>frequency[currentCharacter - 'a'][1] += 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Calculate cumulative sums for the frequencies:
<ul>
<li>Outer loop iterates over all 26 characters:
<ul>
<li>Inner loop starts from the longest possible substring length (from the end of the string) and moves backward:
<ul>
<li>Update <code>frequency[i][j]</code> by adding the value from the next substring length: <code>frequency[i][j] += frequency[i][j + 1]</code>.</li>
<li>If <code>frequency[i][j] &gt;= 3</code>, it indicates that we have at least 3 substrings of the current length:
<ul>
<li>Update <code>ans</code> with the length <code>j</code> if it is greater than the current value of <code>ans</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the result, and if no valid substring is found, return <code>-1</code>. Otherwise, return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NyxcGzaS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code> and <span class="math inline">\(c\)</span> be the number of distinct characters (which is 26 in this case).</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + c \cdot n) \approx O(n)\)</span></p>
<p>The algorithm iterates through the string <code>s</code> once, performing constant-time operations for each character to update the <code>frequency</code> array. This results in a time complexity of <span class="math inline">\(O(n)\)</span>. Additionally, the nested loop that calculates the cumulative sum and finds the maximum possible answer iterates over the <code>frequency</code> array, which has dimensions <span class="math inline">\(26 \times (n + 1)\)</span>. This results in a time complexity of <span class="math inline">\(O(c \cdot n)\)</span>. Therefore, the overall time complexity is <span class="math inline">\(O(n + c \cdot n) \approx O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(c \cdot n) \approx O(n)\)</span></p>
<p>The space used by the algorithm is determined by the <code>frequency</code> array, which has a size of <span class="math inline">\(26 \times (n + 1)\)</span>. Thus, the space complexity is <span class="math inline">\(O(c \cdot n) \approx O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-store-the-three-maximum-substring-lengths">Approach 2: Store the Three Maximum Substring Lengths</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we stopped iterating through the string <code>s</code> once the cumulative sum reached at least <code>3</code>. However, we can optimize this by focusing on the fact that we are searching for the longest substring that occurs at least three times. Instead of maintaining a mapping to store the frequency of substring lengths for all characters, we can simplify the process by directly tracking the maximum lengths using integer variables.</p>
<p>Since we are looking for the longest substring that occurs at least three times, we can store the lengths of the three longest substrings in three integer variables. It is guaranteed that at least one of these will occur at least three times in the string <code>s</code>.</p>
<p>For example:</p>
<ul>
<li>
<p>If the longest substring lengths are <code>length1 = 8</code>, <code>length2 = 8</code>, and <code>length3 = 8</code>, then <code>8</code> is the length of the longest substring that occurs at least three times.</p>
</li>
<li>
<p>If the lengths are <code>length1 = 8</code>, <code>length2 = 8</code>, and <code>length3 = 7</code>, the substring of length <code>7</code> is part of the substrings of length <code>8</code>. In this case, the frequency of the substring of length <code>7</code> ensures it occurs at least three times, making <code>7</code> the desired length.</p>
</li>
<li>
<p>If the lengths are <code>length1 = 6</code>, <code>length2 = 8</code>, and <code>length3 = 7</code>, the substring of length <code>7</code> also occurs as part of the substring of length <code>8</code>. However, the cumulative frequency of substrings of length <code>7</code> may not meet the threshold, so the third-largest length, <code>6</code>, is returned as the result.</p>
</li>
</ul>
<p>To implement this, we use a data structure like <code>substringLengths[character][3]</code>, where the array <code>substringLengths[character]</code> stores the three longest substring lengths for each character. While iterating through the string <code>s</code>, if the current character matches the previous one, we increment a <code>substringLength</code> counter. If the updated length belongs among the three longest substrings for that character, we update the <code>substringLengths</code> array accordingly.</p>
<p>Finally, after processing all characters of <code>s</code>, we return the maximum value of the smallest length in the <code>substringLengths</code> array for all characters.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a matrix <code>substringLengths</code> of size <code>26 x 3</code> to track the maximum lengths of substrings.</li>
<li>Initialize <code>substringLength</code> to <code>0</code> to track the length of the current substring of repeated characters.</li>
<li>Initialize <code>previousCharacter</code> to <code>0</code> (or the first character of the string) to compare the consecutive characters.</li>
<li>Iterate over the string from <code>start</code> = <code>0</code> to <code>s.length()</code>:
<ul>
<li>If the current character matches the previous character, increment <code>substringLength</code>.</li>
<li>If it does not match, reset <code>substringLength</code> to <code>1</code> and update the <code>previousCharacter</code>.</li>
<li>Find the minimum length among the three values for the current character, and store it in <code>minLength</code>.</li>
</ul>
</li>
<li>Iterate over the <code>substringLengths</code> array and find the maximum substring length where its length is at least <code>3</code>.</li>
<li>If no valid substring length is found, return <code>-1</code>. Otherwise, return the maximum length.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5aJHgMJW/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>s</code>, <span class="math inline">\(c\)</span> the number of distinct characters (which is 26 in this case), and <span class="math inline">\(k = 3\)</span> the number of tracked substring lengths per character.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the string <code>s</code> once, performing constant-time operations for each character. For each character, it updates the <code>substringLengths</code> array, which involves checking and updating up to <span class="math inline">\(k\)</span> values. Additionally, the final loop to find the maximum value of the minimum frequency iterates over all distinct characters. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(c \cdot k) \approx O(1)\)</span></p>
<p>The space used by the algorithm is determined by the <code>substringLengths</code> array, which has a size of <span class="math inline">\(c \times k\)</span>. The other variables used (e.g., <code>substringLength</code>, <code>previousCharacter</code>, <code>ans</code>) consume constant space. Thus, the space complexity is <span class="math inline">\(O(c \cdot k) \approx O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-lucky-integer-in-an-array/description" target="_blank" rel="noopener noreferrer">Find Lucky Integer in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>arr</code>, a <strong>lucky integer</strong> is an integer that has a frequency in the array equal to its value.</p>

<p>Return <em>the largest <strong>lucky integer</strong> in the array</em>. If there is no <strong>lucky integer</strong> return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,2,3,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The only lucky number in the array is 2 because frequency[2] == 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,2,3,3,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 1, 2 and 3 are all lucky numbers, return the largest of them.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,2,2,3,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no lucky numbers in the array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 500</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 500</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-most-frequent-vowel-and-consonant/description" target="_blank" rel="noopener noreferrer">Find Most Frequent Vowel and Consonant</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of lowercase English letters (<code>&#39;a&#39;</code> to <code>&#39;z&#39;</code>). </p>

<p>Your task is to:</p>

<ul>
	<li>Find the vowel (one of <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, or <code>&#39;u&#39;</code>) with the <strong>maximum</strong> frequency.</li>
	<li>Find the consonant (all other letters excluding vowels) with the <strong>maximum</strong> frequency.</li>
</ul>

<p>Return the sum of the two frequencies.</p>

<p><strong>Note</strong>: If multiple vowels or consonants have the same maximum frequency, you may choose any one of them. If there are no vowels or no consonants in the string, consider their frequency as 0.</p>
The <strong>frequency</strong> of a letter <code>x</code> is the number of times it occurs in the string.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;successes&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The vowels are: <code>&#39;u&#39;</code> (frequency 1), <code>&#39;e&#39;</code> (frequency 2). The maximum frequency is 2.</li>
	<li>The consonants are: <code>&#39;s&#39;</code> (frequency 4), <code>&#39;c&#39;</code> (frequency 2). The maximum frequency is 4.</li>
	<li>The output is <code>2 + 4 = 6</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aeiaeia&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The vowels are: <code>&#39;a&#39;</code> (frequency 3), <code>&#39;e&#39;</code> ( frequency 2), <code>&#39;i&#39;</code> (frequency 2). The maximum frequency is 3.</li>
	<li>There are no consonants in <code>s</code>. Hence, maximum consonant frequency = 0.</li>
	<li>The output is <code>3 + 0 = 3</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-players-with-zero-or-one-losses/description" target="_blank" rel="noopener noreferrer">Find Players With Zero or One Losses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>matches</code> where <code>matches[i] = [winner<sub>i</sub>, loser<sub>i</sub>]</code> indicates that the player <code>winner<sub>i</sub></code> defeated player <code>loser<sub>i</sub></code> in a match.</p>

<p>Return <em>a list </em><code>answer</code><em> of size </em><code>2</code><em> where:</em></p>

<ul>
	<li><code>answer[0]</code> is a list of all players that have <strong>not</strong> lost any matches.</li>
	<li><code>answer[1]</code> is a list of all players that have lost exactly <strong>one</strong> match.</li>
</ul>

<p>The values in the two lists should be returned in <strong>increasing</strong> order.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>You should only consider the players that have played <strong>at least one</strong> match.</li>
	<li>The testcases will be generated such that <strong>no</strong> two matches will have the <strong>same</strong> outcome.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
<strong>Output:</strong> [[1,2,10],[4,5,7,8]]
<strong>Explanation:</strong>
Players 1, 2, and 10 have not lost any matches.
Players 4, 5, 7, and 8 each have lost one match.
Players 3, 6, and 9 each have lost two matches.
Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matches = [[2,3],[1,3],[5,4],[6,4]]
<strong>Output:</strong> [[1,2,5,6],[]]
<strong>Explanation:</strong>
Players 1, 2, 5, and 6 have not lost any matches.
Players 3 and 4 each have lost two matches.
Thus, answer[0] = [1,2,5,6] and answer[1] = [].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= matches.length &lt;= 10<sup>5</sup></code></li>
	<li><code>matches[i].length == 2</code></li>
	<li><code>1 &lt;= winner<sub>i</sub>, loser<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>winner<sub>i</sub> != loser<sub>i</sub></code></li>
	<li>All <code>matches[i]</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-most-common-response/description" target="_blank" rel="noopener noreferrer">Find the Most Common Response</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D string array <code>responses</code> where each <code>responses[i]</code> is an array of strings representing survey responses from the <code>i<sup>th</sup></code> day.</p>

<p>Return the <strong>most common</strong> response across all days after removing <strong>duplicate</strong> responses within each <code>responses[i]</code>. If there is a tie, return the <em><span data-keyword="lexicographically-smaller-string">lexicographically smallest</span></em> response.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">responses = [[&quot;good&quot;,&quot;ok&quot;,&quot;good&quot;,&quot;ok&quot;],[&quot;ok&quot;,&quot;bad&quot;,&quot;good&quot;,&quot;ok&quot;,&quot;ok&quot;],[&quot;good&quot;],[&quot;bad&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;good&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>After removing duplicates within each list, <code>responses = [[&quot;good&quot;, &quot;ok&quot;], [&quot;ok&quot;, &quot;bad&quot;, &quot;good&quot;], [&quot;good&quot;], [&quot;bad&quot;]]</code>.</li>
	<li><code>&quot;good&quot;</code> appears 3 times, <code>&quot;ok&quot;</code> appears 2 times, and <code>&quot;bad&quot;</code> appears 2 times.</li>
	<li>Return <code>&quot;good&quot;</code> because it has the highest frequency.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">responses = [[&quot;good&quot;,&quot;ok&quot;,&quot;good&quot;],[&quot;ok&quot;,&quot;bad&quot;],[&quot;bad&quot;,&quot;notsure&quot;],[&quot;great&quot;,&quot;good&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;bad&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>After removing duplicates within each list we have <code>responses = [[&quot;good&quot;, &quot;ok&quot;], [&quot;ok&quot;, &quot;bad&quot;], [&quot;bad&quot;, &quot;notsure&quot;], [&quot;great&quot;, &quot;good&quot;]]</code>.</li>
	<li><code>&quot;bad&quot;</code>, <code>&quot;good&quot;</code>, and <code>&quot;ok&quot;</code> each occur 2 times.</li>
	<li>The output is <code>&quot;bad&quot;</code> because it is the lexicographically smallest amongst the words with the highest frequency.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= responses.length &lt;= 1000</code></li>
	<li><code>1 &lt;= responses[i].length &lt;= 1000</code></li>
	<li><code>1 &lt;= responses[i][j].length &lt;= 10</code></li>
	<li><code>responses[i][j]</code> consists of only lowercase English letters</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-number-of-winning-players/description" target="_blank" rel="noopener noreferrer">Find the Number of Winning Players</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of players in a game and a 2D array <code>pick</code> where <code>pick[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents that the player <code>x<sub>i</sub></code> picked a ball of color <code>y<sub>i</sub></code>.</p>

<p>Player <code>i</code> <strong>wins</strong> the game if they pick <strong>strictly more</strong> than <code>i</code> balls of the <strong>same</strong> color. In other words,</p>

<ul>
	<li>Player 0 wins if they pick any ball.</li>
	<li>Player 1 wins if they pick at least two balls of the <em>same</em> color.</li>
	<li>...</li>
	<li>Player <code>i</code> wins if they pick at least <code>i + 1</code> balls of the <em>same</em> color.</li>
</ul>

<p>Return the number of players who <strong>win</strong> the game.</p>

<p><strong>Note</strong> that <em>multiple</em> players can win the game.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Player 0 and player 1 win the game, while players 2 and 3 do not win.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, pick = [[1,1],[1,2],[1,3],[1,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>No player wins the game.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, pick = [[1,1],[2,4],[2,4],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>Player 2 wins the game by picking 3 balls with color 4.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10</code></li>
	<li><code>1 &lt;= pick.length &lt;= 100</code></li>
	<li><code>pick[i].length == 2</code></li>
	<li><code>0 &lt;= x<sub>i</sub> &lt;= n - 1 </code></li>
	<li><code>0 &lt;= y<sub>i</sub> &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-valid-pair-of-adjacent-digits-in-string/description" target="_blank" rel="noopener noreferrer">Find Valid Pair of Adjacent Digits in String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting only of digits. A <strong>valid pair</strong> is defined as two <strong>adjacent</strong> digits in <code>s</code> such that:</p>

<ul>
	<li>The first digit is <strong>not equal</strong> to the second.</li>
	<li>Each digit in the pair appears in <code>s</code> <strong>exactly</strong> as many times as its numeric value.</li>
</ul>

<p>Return the first <strong>valid pair</strong> found in the string <code>s</code> when traversing from left to right. If no valid pair exists, return an empty string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;2523533&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;23&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>Digit <code>&#39;2&#39;</code> appears 2 times and digit <code>&#39;3&#39;</code> appears 3 times. Each digit in the pair <code>&quot;23&quot;</code> appears in <code>s</code> exactly as many times as its numeric value. Hence, the output is <code>&quot;23&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;221&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;21&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>Digit <code>&#39;2&#39;</code> appears 2 times and digit <code>&#39;1&#39;</code> appears 1 time. Hence, the output is <code>&quot;21&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;22&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>There are no valid adjacent pairs.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> only consists of digits from <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-words-that-can-be-formed-by-characters/description" target="_blank" rel="noopener noreferrer">Find Words That Can Be Formed by Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>chars</code>.</p>

<p>A string is <strong>good</strong> if it can be formed by characters from <code>chars</code> (each character can only be used once for <strong>each</strong> word in <code>words</code>).</p>

<p>Return <em>the sum of lengths of all good strings in words</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> The strings that can be formed are &quot;cat&quot; and &quot;hat&quot; so the answer is 3 + 3 = 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;
<strong>Output:</strong> 10
<strong>Explanation:</strong> The strings that can be formed are &quot;hello&quot; and &quot;world&quot; so the answer is 5 + 5 = 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>
	<li><code>words[i]</code> and <code>chars</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-count-with-hash-map">Approach 1: Count With Hash Map</h3>
<p><strong>Intuition</strong></p>
<p>If you are not already familiar with hash maps, please check out our relevant <a href="https://leetcode.com/explore/learn/card/hash-table/">LeetCode explore card</a>.</p>
<p>In this problem, we need to determine which elements in <code>words</code> can be built using the letters from <code>chars</code>. A <code>word</code> can be built from <code>chars</code> if and only if the following condition is true:</p>
<p>For each unique character <code>c</code> in <code>word</code>, the frequency of <code>c</code> is not greater in <code>word</code> than it is in <code>chars</code>. That is, there are no characters that appear more in <code>word</code> than in <code>chars</code>.</p>
<p>If any character appears more in <code>word</code> than in <code>chars</code>, there won't be enough of that character in <code>chars</code> to build <code>word</code> with. To solve this problem, we will start by counting the frequency of every character in <code>chars</code> using a hash map <code>counts</code>.</p>
<p>Once we have calculated <code>counts</code>, we can check each <code>word</code> one by one. For a given <code>word</code>, we count the frequency of its characters using a hash map <code>wordCount</code>. Then, we can iterate over each unique character <code>c</code> in <code>wordCount</code>. For each character in <code>c</code>, we can find the frequency in <code>chars</code> by checking <code>counts[c]</code>. We can also find the frequency in <code>word</code> by checking <code>wordCount[c]</code>. We then compare these values.</p>
<p>If <code>counts[c] &lt; wordCount[c]</code> for ANY character, the current word cannot be built. We will use a boolean flag <code>good</code> to indicate if a given <code>word</code> can be built or not. Initially, we set <code>good = true</code>. If we find <code>counts[c] &lt; wordCount[c]</code> for any character, we set <code>good = false</code>. Once we have finished checking all the characters of a <code>word</code>, we check the flag <code>good</code>. If it is still <code>true</code>, we know we can build <code>word</code> and add the length of <code>word</code> to our answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a hash map <code>counts</code> that records the frequency of every character in <code>chars</code>.</li>
<li>Initialize the answer <code>ans = 0</code>.</li>
<li>Iterate over each <code>word</code> in <code>words</code>:
<ul>
<li>Create a hash map <code>wordCount</code> that records the frequency of every character in <code>words</code>.</li>
<li>Set <code>good = true</code>.</li>
<li>Iterate over each key <code>c</code> in <code>wordCount</code>. Let <code>freq = wordCount[c]</code>.
<ul>
<li>If <code>counts[c] &lt; freq</code>, set <code>good = false</code> and break from the loop.</li>
</ul>
</li>
<li>If <code>good = true</code>, add the length of <code>word</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/3NSYWbDs/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>chars</code>, <span class="math inline">\(m\)</span> as the length of <code>words</code> and <span class="math inline">\(k\)</span> as the average length of each word in <code>words</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \cdot k)\)</span></p>
<p>To calculate <code>counts</code>, we iterate over each character of <code>chars</code> once, costing <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we iterate over <span class="math inline">\(O(m)\)</span> elements in <code>words</code>. For each element, we calculate <code>wordCount</code> by iterating over the element, which costs <span class="math inline">\(O(k)\)</span>. We then iterate over <code>wordCount</code>. As the input only contains lowercase English letters, this costs <span class="math inline">\(O(1)\)</span> since <code>wordCount</code> cannot have a length greater than <code>26</code>. Overall, the for loop costs <span class="math inline">\(O(m \cdot k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use extra space for <code>counts</code> and <code>wordCount</code>. However, the input only contains lowercase English letters. Thus, the size of these hash maps never exceed <code>26</code>, so we use <span class="math inline">\(O(1)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-count-with-array">Approach 2: Count With Array</h3>
<p><strong>Intuition</strong></p>
<p>Because the input only contains lowercase English letters, we can use an array to implement <code>counts</code> and <code>wordCount</code> instead of a hash map. Each letter is assigned a unique integer in ASCII encodings and as these values are contiguous, we can subtract the ASCII value of <code>'a'</code> from the ASCII value of the letter to map it to a relative position in the alphabet. For example, <code>'a' - 'a'</code> results in 0, <code>'b' - 'a'</code> results in 1, <code>'c' - 'a'</code> results in 2, and so on. In this way, each letter can be mapped directly to an index in the array.</p>
<p>Let's start by converting each letter to its position in the alphabet according to the rules above,</p>
<ul>
<li>We convert the letter <code>'a'</code> to the integer <code>0</code>.</li>
<li>We convert the letter <code>'b'</code> to the integer <code>1</code>.</li>
<li>We convert the letter <code>'c'</code> to the integer <code>2</code>.</li>
<li>...</li>
<li>We convert the letter <code>'z'</code> to the integer <code>25</code>.</li>
</ul>
<p>Now, we let <code>counts</code> and <code>wordCount</code> be an array of length <code>26</code>. We let <code>counts[x]</code> represent the frequency of <code>x</code> in <code>chars</code>, where <code>x</code> is the letter at position <code>x</code> in the alphabet. <code>wordCount</code> functions similarly.</p>
<p>Aside from this change, the algorithm is the same as in the previous approach.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create an array <code>counts</code> of length <code>26</code>.</li>
<li>Iterate over each <code>c</code> in <code>chars</code>:
<ul>
<li>Increment <code>counts[c - 'a']</code>.</li>
</ul>
</li>
<li>Initialize the answer <code>ans = 0</code>.</li>
<li>Iterate over each <code>word</code> in <code>words</code>:
<ul>
<li>Create an array <code>wordCount</code> of length <code>26</code> and calculate it for <code>word</code> in the same manner as <code>counts</code>.</li>
<li>Set <code>good = true</code>.</li>
<li>Iterate <code>i</code> from <code>0</code> until <code>26</code>:
<ul>
<li>If <code>counts[i] &lt; wordCount[i]</code>, set <code>good = false</code> and break from the loop.</li>
</ul>
</li>
<li>If <code>good = true</code>, add the length of <code>word</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/YDWrAdsk/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>chars</code>, <span class="math inline">\(m\)</span> as the length of <code>words</code>, and <span class="math inline">\(k\)</span> as the average length of each word in <code>words</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \cdot k)\)</span></p>
<p>To calculate <code>counts</code>, we iterate over each character of <code>chars</code> once, costing <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we iterate over <span class="math inline">\(O(m)\)</span> elements in <code>words</code>. For each element, we calculate <code>wordCount</code> by iterating over the element, which costs <span class="math inline">\(O(k)\)</span>. We then perform a loop over <code>26</code> indices, costing <span class="math inline">\(O(1)\)</span>. Overall, the for loop costs <span class="math inline">\(O(m \cdot k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p><code>counts</code> and <code>wordCount</code> both have a fixed length of <code>26</code>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/first-letter-to-appear-twice/description" target="_blank" rel="noopener noreferrer">First Letter to Appear Twice</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> consisting of lowercase English letters, return <em>the first letter to appear <strong>twice</strong></em>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>A letter <code>a</code> appears twice before another letter <code>b</code> if the <strong>second</strong> occurrence of <code>a</code> is before the <strong>second</strong> occurrence of <code>b</code>.</li>
	<li><code>s</code> will contain at least one letter that appears twice.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abccbaacz&quot;
<strong>Output:</strong> &quot;c&quot;
<strong>Explanation:</strong>
The letter &#39;a&#39; appears on the indexes 0, 5 and 6.
The letter &#39;b&#39; appears on the indexes 1 and 4.
The letter &#39;c&#39; appears on the indexes 2, 3 and 7.
The letter &#39;z&#39; appears on the index 8.
The letter &#39;c&#39; is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcdd&quot;
<strong>Output:</strong> &quot;d&quot;
<strong>Explanation:</strong>
The only letter that appears twice is &#39;d&#39; so we return &#39;d&#39;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>s</code> has at least one repeated letter.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/first-unique-character-in-a-string/description" target="_blank" rel="noopener noreferrer">First Unique Character in a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">queue</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, find the <strong>first</strong> non-repeating character in it and return its index. If it <strong>does not</strong> exist, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;leetcode&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The character <code>&#39;l&#39;</code> at index 0 is the first character that does not occur at any other index.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;loveleetcode&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aabb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-linear-time-solution">Approach 1: Linear time solution</h3>
<p>The best possible solution here could be of a linear time because to ensure that the character is unique you have to check the whole string anyway.</p>
<p>The idea is to go through the string and save in a hash map the number of times each character appears in the string. That would take <span class="math inline">\(\mathcal{O}(N)\)</span> time, where <code>N</code> is the number of characters in the string.</p>
<p>Then we go through the string the second time, this time we use the hash map as a reference to check if a character is unique or not. If the character is unique, one could just return its index. The complexity of the second iteration is <span class="math inline">\(\mathcal{O}(N)\)</span> as well.</p>
<p>!?!../Documents/387_LIS.json:1000,621!?!</p>
<p><a href="https://leetcode.com/playground/e6zf5RKZ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since we go through the string of length <code>N</code> two times.</li>
<li>Space complexity: <span class="math inline">\(\mathcal{O}(1)\)</span> because English alphabet contains 26 letters.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/furthest-point-from-origin/description" target="_blank" rel="noopener noreferrer">Furthest Point From Origin</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>moves</code> of length <code>n</code> consisting only of characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;_&#39;</code>. The string represents your movement on a number line starting from the origin <code>0</code>.</p>

<p>In the <code>i<sup>th</sup></code> move, you can choose one of the following directions:</p>

<ul>
	<li>move to the left if <code>moves[i] = &#39;L&#39;</code> or <code>moves[i] = &#39;_&#39;</code></li>
	<li>move to the right if <code>moves[i] = &#39;R&#39;</code> or <code>moves[i] = &#39;_&#39;</code></li>
</ul>

<p>Return <em>the <strong>distance from the origin</strong> of the <strong>furthest</strong> point you can get to after </em><code>n</code><em> moves</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> moves = &quot;L_RL__R&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The furthest point we can reach from the origin 0 is point -3 through the following sequence of moves &quot;LLRLLLR&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> moves = &quot;_R__LL_&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> The furthest point we can reach from the origin 0 is point -5 through the following sequence of moves &quot;LRLLLLL&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> moves = &quot;_______&quot;
<strong>Output:</strong> 7
<strong>Explanation:</strong> The furthest point we can reach from the origin 0 is point 7 through the following sequence of moves &quot;RRRRRRR&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= moves.length == n &lt;= 50</code></li>
	<li><code>moves</code> consists only of characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code> and <code>&#39;_&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/identify-the-largest-outlier-in-an-array/description" target="_blank" rel="noopener noreferrer">Identify the Largest Outlier in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. This array contains <code>n</code> elements, where <strong>exactly</strong> <code>n - 2</code> elements are <strong>special</strong><strong> numbers</strong>. One of the remaining <strong>two</strong> elements is the <em>sum</em> of these <strong>special numbers</strong>, and the other is an <strong>outlier</strong>.</p>

<p>An <strong>outlier</strong> is defined as a number that is <em>neither</em> one of the original special numbers <em>nor</em> the element representing the sum of those numbers.</p>

<p><strong>Note</strong> that special numbers, the sum element, and the outlier must have <strong>distinct</strong> indices, but <em>may </em>share the <strong>same</strong> value.</p>

<p>Return the <strong>largest</strong><strong> </strong>potential<strong> outlier</strong> in <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,5,10]</span></p>

<p><strong>Output:</strong> <span class="example-io">10</span></p>

<p><strong>Explanation:</strong></p>

<p>The special numbers could be 2 and 3, thus making their sum 5 and the outlier 10.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-2,-1,-3,-6,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The special numbers could be -2, -1, and -3, thus making their sum -6 and the outlier 4.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,1,1,1,5,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>The special numbers could be 1, 1, 1, 1, and 1, thus making their sum 5 and the other 5 as the outlier.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
	<li>The input is generated such that at least <strong>one</strong> potential outlier exists in <code>nums</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/increasing-decreasing-string/description" target="_blank" rel="noopener noreferrer">Increasing Decreasing String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>. Reorder the string using the following algorithm:</p>

<ol>
	<li>Remove the <strong>smallest</strong> character from <code>s</code> and <strong>append</strong> it to the result.</li>
	<li>Remove the <strong>smallest</strong> character from <code>s</code> that is greater than the last appended character, and <strong>append</strong> it to the result.</li>
	<li>Repeat step 2 until no more characters can be removed.</li>
	<li>Remove the <strong>largest</strong> character from <code>s</code> and <strong>append</strong> it to the result.</li>
	<li>Remove the <strong>largest</strong> character from <code>s</code> that is smaller than the last appended character, and <strong>append</strong> it to the result.</li>
	<li>Repeat step 5 until no more characters can be removed.</li>
	<li>Repeat steps 1 through 6 until all characters from <code>s</code> have been removed.</li>
</ol>

<p>If the smallest or largest character appears more than once, you may choose any occurrence to append to the result.</p>

<p>Return the resulting string after reordering <code>s</code> using this algorithm.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaaabbbbcccc&quot;
<strong>Output:</strong> &quot;abccbaabccba&quot;
<strong>Explanation:</strong> After steps 1, 2 and 3 of the first iteration, result = &quot;abc&quot;
After steps 4, 5 and 6 of the first iteration, result = &quot;abccba&quot;
First iteration is done. Now s = &quot;aabbcc&quot; and we go back to step 1
After steps 1, 2 and 3 of the second iteration, result = &quot;abccbaabc&quot;
After steps 4, 5 and 6 of the second iteration, result = &quot;abccbaabccba&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;rat&quot;
<strong>Output:</strong> &quot;art&quot;
<strong>Explanation:</strong> The word &quot;rat&quot; becomes &quot;art&quot; after re-ordering it with the mentioned algorithm.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 500</code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intersection-of-multiple-arrays/description" target="_blank" rel="noopener noreferrer">Intersection of Multiple Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given a 2D integer array <code>nums</code> where <code>nums[i]</code> is a non-empty array of <strong>distinct</strong> positive integers, return <em>the list of integers that are present in <strong>each array</strong> of</em> <code>nums</code><em> sorted in <strong>ascending order</strong></em>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [[<u><strong>3</strong></u>,1,2,<u><strong>4</strong></u>,5],[1,2,<u><strong>3</strong></u>,<u><strong>4</strong></u>],[<u><strong>3</strong></u>,<u><strong>4</strong></u>,5,6]]
<strong>Output:</strong> [3,4]
<strong>Explanation:</strong> 
The only integers present in each of nums[0] = [<u><strong>3</strong></u>,1,2,<u><strong>4</strong></u>,5], nums[1] = [1,2,<u><strong>3</strong></u>,<u><strong>4</strong></u>], and nums[2] = [<u><strong>3</strong></u>,<u><strong>4</strong></u>,5,6] are 3 and 4, so we return [3,4].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1,2,3],[4,5,6]]
<strong>Output:</strong> []
<strong>Explanation:</strong> 
There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li>
	<li>All the values of <code>nums[i]</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-distinct-string-in-an-array/description" target="_blank" rel="noopener noreferrer">Kth Distinct String in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>distinct string</strong> is a string that is present only <strong>once</strong> in an array.</p>

<p>Given an array of strings <code>arr</code>, and an integer <code>k</code>, return <em>the </em><code>k<sup>th</sup></code><em> <strong>distinct string</strong> present in </em><code>arr</code>. If there are <strong>fewer</strong> than <code>k</code> distinct strings, return <em>an <strong>empty string </strong></em><code>&quot;&quot;</code>.</p>

<p>Note that the strings are considered in the <strong>order in which they appear</strong> in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;d&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;], k = 2
<strong>Output:</strong> &quot;a&quot;
<strong>Explanation:</strong>
The only distinct strings in arr are &quot;d&quot; and &quot;a&quot;.
&quot;d&quot; appears 1<sup>st</sup>, so it is the 1<sup>st</sup> distinct string.
&quot;a&quot; appears 2<sup>nd</sup>, so it is the 2<sup>nd</sup> distinct string.
Since k == 2, &quot;a&quot; is returned. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;aaa&quot;,&quot;aa&quot;,&quot;a&quot;], k = 1
<strong>Output:</strong> &quot;aaa&quot;
<strong>Explanation:</strong>
All strings in arr are distinct, so the 1<sup>st</sup> string &quot;aaa&quot; is returned.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;a&quot;,&quot;b&quot;,&quot;a&quot;], k = 3
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong>
The only distinct string is &quot;b&quot;. Since there are fewer than 3 distinct strings, we return an empty string &quot;&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= arr.length &lt;= 1000</code></li>
	<li><code>1 &lt;= arr[i].length &lt;= 5</code></li>
	<li><code>arr[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve this problem, we first need to identify which strings in <code>arr</code> are distinct and which occur multiple times.</p>
<p>A brute force approach involves iterating through each string in the array and comparing it with every other string. Strings that do not match any others are considered distinct and are stored in a separate list. After building this list of distinct strings, we can then return the <code>k</code>th element from this list, provided it contains at least <code>k</code> elements.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize
<ul>
<li><code>n</code> as the length of the input array <code>arr</code>.</li>
<li>a list <code>distinctStrings</code> to store distinct strings.</li>
</ul>
</li>
<li>Iterate through each string in <code>arr</code>:
<ul>
<li>For each string, set a flag <code>isDistinct</code> to <code>true</code>.</li>
<li>Compare the current string with every other string in the array:
<ul>
<li>Skip the comparison if comparing the string with itself.</li>
<li>If the string matches another string, set <code>isDistinct</code> to <code>false</code> and break the loop.</li>
</ul>
</li>
<li>If <code>isDistinct</code> remains <code>true</code>, add the current string to <code>distinctStrings</code>.</li>
</ul>
</li>
<li>After collecting distinct strings, check if the size of <code>distinctStrings</code> is less than <code>k</code>:
<ul>
<li>If true, return an empty string, indicating there are not enough distinct strings.</li>
</ul>
</li>
<li>Otherwise, return the <code>k</code>-th element in <code>distinctStrings</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LCYXwrq5/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The outer loop runs <span class="math inline">\(n\)</span> times, and for each iteration of the outer loop, there's an inner loop that also runs <span class="math inline">\(n\)</span> times, where string comparisons are performed. Although string comparisons typically take linear time relative to the string length, in this case, the length of each string is capped at <span class="math inline">\(5\)</span> characters, allowing us to consider these comparisons as running in constant time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The only additional space used is the <code>distinctStrings</code> list, which can store up to <span class="math inline">\(n\)</span> strings in the worst case. Thus, the algorithm takes linear space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-hash-set">Approach 2: Hash Set</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our previous approach involved iterating through the array to check for duplicates, which adds a linear element to the time complexity. Let's explore a more efficient method.</p>
<p>In this improved approach, we'll utilize a hash set to track all encountered strings during iteration. Hash sets are ideal for this task because they offer constant-time add, remove, and lookup operations. For those unfamiliar with hash sets, the LeetCode <a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/">Explore Card</a> on hash tables provides a comprehensive overview.</p>
<p>We'll maintain two sets: <code>distinctStrings</code> and <code>duplicateStrings</code>. As we traverse the input array, we'll check if the current string exists in either set. If it does, we'll categorize it as a duplicate and add it to <code>duplicateStrings</code>. If not, we'll consider it distinct and add it to <code>distinctStrings</code>.</p>
<p>After completing the initial loop, <code>distinctStrings</code> will contain all unique strings. We'll then iterate through <code>arr</code> once more, and each time we encounter a string present in <code>distinctStrings</code>, we'll decrement <code>k</code>. When <code>k</code> reaches zero after a decrement, we can return that string as the <code>k</code>th distinct string in the array.</p>
<p>To illustrate the process, consider the example where <code>arr = [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</code> and <code>k = 2</code>. The following slideshow will demonstrate how the algorithm arrives at the solution:</p>
<p>!?!../Documents/2053/slideshow.json:810,532!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize two sets: <code>distinctStrings</code> to track strings that appear only once, and <code>duplicateStrings</code> to track strings that appear more than once.</li>
<li>Iterate through the array <code>arr</code> to populate <code>distinctStrings</code> and <code>duplicateStrings</code>:
<ul>
<li>If a string is already in <code>duplicateStrings</code>, skip it.</li>
<li>If a string is in <code>distinctStrings</code>, move it to <code>duplicateStrings</code> (indicating it is now a duplicate) and remove it from <code>distinctStrings</code>.</li>
<li>If a string is not in either set, add it to <code>distinctStrings</code>.</li>
</ul>
</li>
<li>Iterate through the array <code>arr</code> again to find the k-th distinct string:
<ul>
<li>For each string, check if it is in <code>duplicateStrings</code>. If not, decrement <code>k</code> (indicating this string is one of the distinct strings).</li>
<li>When <code>k</code> reaches 0, return the current string as the <code>k</code>-th distinct string.</li>
</ul>
</li>
<li>If no <code>k</code>-th distinct string is found (i.e., <code>k</code> does not reach 0), return an empty string.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/68nNZbkz/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm makes two passes through the input array <code>arr</code>. In each pass, all set operations are <span class="math inline">\(O(1)\)</span> on average. Thus, the overall time complexity is <span class="math inline">\(O(2 \cdot n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, one of the sets could store all <span class="math inline">\(n\)</span> strings in <code>arr</code> (for example, when all the strings are distinct). Thus, the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-hash-map">Approach 3: Hash Map</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Maintaining two sets and managing elements between them can be cumbersome. Let's simplify the process.</p>
<p>An alternative method to determine if a string is unique is by examining its frequency of occurrence. A string is considered distinct if its frequency is exactly one.</p>
<p>To implement this approach, we first create a frequency table for all strings in the array. Hash maps are well-suited for this task because they store key-value pairs and provide constant-time operations for adding, removing, and looking up entries. For more details on hash maps and their features, refer to the LeetCode <a href="https://leetcode.com/explore/learn/card/hash-table/184/comparison-with-other-data-structures/">Explore Card</a>.</p>
<p>With the frequency of each string determined, we can easily identify which strings are distinct. We then iterate over <code>arr</code> again and decrement <code>k</code> each time we encounter a unique string. When <code>k</code> reaches zero, we return the current string as our desired answer.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Create a frequency map <code>frequencyMap</code> to count the occurrences of each string in the array <code>arr</code>.</li>
<li>Iterate through <code>arr</code> and for each string, update its frequency in <code>frequencyMap</code>.</li>
<li>Iterate through <code>arr</code> a second time to find the <code>k</code>-th distinct string:
<ul>
<li>For each string, check if its frequency in <code>frequencyMap</code> is 1 (indicating it is distinct).</li>
<li>Decrement <code>k</code> by 1 each time a distinct string is found.</li>
<li>When <code>k</code> reaches 0, return the current string as it is the <code>k</code>-th distinct string.</li>
</ul>
</li>
<li>If no <code>k</code>-th distinct string is found by the end of the array, return an empty string.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/DrVkJ6eF/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates over <code>arr</code> twice. For each element, all map operations take constant time on average. Thus, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space used by the algorithm is primarily for <code>frequencyMap</code>. In the worst case, where all strings are distinct, the map will store <span class="math inline">\(n\)</span> key-value pairs. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-color-value-in-a-directed-graph/description" target="_blank" rel="noopener noreferrer">Largest Color Value in a Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i<sup>th</sup></code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> indicates that there is a <strong>directed edge</strong> from node <code>a<sub>j</sub></code> to node <code>b<sub>j</sub></code>.</p>

<p>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> such that there is a directed edge from <code>x<sub>i</sub></code> to <code>x<sub>i+1</sub></code> for every <code>1 &lt;= i &lt; k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.</p>

<p>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or </em><code>-1</code><em> if the graph contains a cycle</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet1.png" style="width: 400px; height: 182px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored <code>&quot;a&quot; (red in the above image)</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet2.png" style="width: 85px; height: 85px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;a&quot;, edges = [[0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is a cycle from 0 to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == colors.length</code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>colors</code> consists of lowercase English letters.</li>
	<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub>&nbsp;&lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/description" target="_blank" rel="noopener noreferrer">Largest Combination With Bitwise AND Greater Than Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>bitwise AND</strong> of an array <code>nums</code> is the bitwise AND of all integers in <code>nums</code>.</p>

<ul>
	<li>For example, for <code>nums = [1, 5, 3]</code>, the bitwise AND is equal to <code>1 &amp; 5 &amp; 3 = 1</code>.</li>
	<li>Also, for <code>nums = [7]</code>, the bitwise AND is <code>7</code>.</li>
</ul>

<p>You are given an array of positive integers <code>candidates</code>. Compute the <strong>bitwise AND</strong> for all possible <strong>combinations</strong> of elements in the <code>candidates</code> array.</p>

<p>Return <em>the size of the <strong>largest</strong> combination of </em><code>candidates</code><em> with a bitwise AND <strong>greater</strong> than </em><code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> candidates = [16,17,71,62,12,24,14]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The combination [16,17,62,24] has a bitwise AND of 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0.
The size of the combination is 4.
It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.
Note that more than one combination may have the largest size.
For example, the combination [62,12,24,14] has a bitwise AND of 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> candidates = [8,8]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The largest combination [8,8] has a bitwise AND of 8 &amp; 8 = 8 &gt; 0.
The size of the combination is 2, so we return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= candidates.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= candidates[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>When we want to find groups of numbers where their bitwise AND is greater than zero, we first need to understand what conditions allow for a positive result. The crucial factor is that all numbers in the group must share at least one '1' bit in the same position. For instance, if we take the numbers 6 (binary <code>110</code>) and 4 (binary <code>100</code>), their AND operation yields 4 (binary <code>100</code>) because they both have a '1' in the third position.</p>
<p>This insight leads us to a critical conclusion: the size of the largest group we can form will correspond to the count of numbers that share a '1' bit in any particular position.</p>
<p>To illustrate this further, consider the numbers <code>[6, 4, 5, 3]</code>, which in binary are <code>[110, 100, 101 , 011]</code>. For these numbers to yield a bitwise AND greater than zero, they must have at least one '1' bit in the same position. Analyzing the binary representations, we see that three numbers (6, 4, and 5) have a common '1' in the third position. This means we can form groups of size 3 that will result in a non-zero AND. The other groups will be smaller than the size of 3.</p>
<p>In practical terms, for numbers constrained to be less than or equal to <span class="math inline">\(10^7\)</span> (requiring a maximum of 24 bits), we only need to check bit positions 0 to 23 when working with 32-bit integers. For larger numbers, like those up to <span class="math inline">\(10^9\)</span>, we would check up to 30 bits, since <span class="math inline">\(2^{30} = 1,073,741,824\)</span>.</p>
<hr />
<h3 id="approach-1-using-a-bit-count-array">Approach 1: Using a Bit Count Array</h3>
<h4 id="intuition">Intuition</h4>
<p>Since we’re interested in grouping numbers that share 1 bit at the same positions, we can scan through each bit position across all numbers and simply count how many times each position has a 1. For example, if the third bit position has three numbers with a 1, then we know we can form a group of three with a non-zero AND result. By doing this for all bit positions, the largest count we find will represent the maximum group size that meets our criteria.</p>
<p>To implement this, we create an array called <code>bitCount</code>, with each index representing a bit position (from 0 to 23). We initialize all values to zero. As we iterate through each number in <code>candidates</code>, we check if each bit is set using a bitwise AND operation. If it is set, we increment the corresponding index in <code>bitCount</code>. By the end of this process, <code>bitCount[i]</code> will tell us how many numbers have the i-th bit set.</p>
<p>Finally, we look for the maximum value in the <code>bitCount</code> array. This value represents the largest group of candidates that can contribute to a bitwise AND greater than zero. The logic here is straightforward: if more numbers have a specific bit set, we can form a larger combination that retains that bit in the final AND result.</p>
<p>For instance, given the input <code>candidates = [6, 3, 4, 5]</code>, we check each bit position. For the most significant bit (bit 0), the numbers 6 (binary 110), 3 (011), 4 (100), and 5 (101) contribute to a count of 3, since 3 candidates have their most significant bit set. The final maximum count across all bit positions is 3, indicating that the largest combination with a bitwise AND greater than zero consists of 3 numbers.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an array <code>bitCount</code> of size 24 with zeros to store the count of set bits at each bit position from 0 to 23.</p>
</li>
<li>
<p>For each bit position <code>i</code> from 0 to 23:</p>
<ul>
<li>For each number <code>num</code> in <code>candidates</code>:
<ul>
<li>Check if the i-th bit of <code>num</code> is set using the expression <code>(num &amp; (1 &lt;&lt; i)) != 0</code>.</li>
<li>If the bit is set, increment <code>bitCount[i]</code> to track how many numbers have the i-th bit set.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After counting set bits for all positions, find the maximum value in <code>bitCount</code> using <code>max_element</code>.</p>
</li>
<li>
<p>Return the maximum count, which represents the largest size of candidates that have a common bit set at the same position.</p>
</li>
</ul>
<details>
  <summary>Working of <code>(num & (1 << i)) != 0</code> (Click here to check)</summary>
  <p>
    The expression <code>(num & (1 << i)) != 0</code> is a way to check if the bit at the <em>i-th</em> position of <code>num</code> is <code>1</code>.
  </p>
  <p>
    The expression <code>(1 << i)</code> moves the bit <code>1</code> to the left by <code>i</code> places. For example:
    <ul>
      <li><code>(1 << 0)</code> is <code>0001</code> (1 in decimal).</li>
      <li><code>(1 << 1)</code> is <code>0010</code> (2 in decimal).</li>
      <li><code>(1 << 2)</code> is <code>0100</code> (4 in decimal).</li>
    </ul>
    This creates a number where only the i-th bit is <code>1</code>, and all other bits are <code>0</code>.
  </p>
  <p>
    Then the <code>&</code> (bitwise AND) operation compares each bit of <code>num</code> with <code>(1 << i)</code>.
    <ul>
      <li>If the i-th bit of <code>num</code> is <code>1</code>, then <code>(num & (1 << i))</code> will give a non-zero result, because there’s a <code>1</code> in the same position for both <code>num</code> and <code>(1 << i)</code>.</li>
      <li>If the i-th bit of <code>num</code> is <code>0</code>, the result of <code>(num & (1 << i))</code> will be <code>0</code>, because there’s no <code>1</code> in that position in <code>num</code>.</li>
    </ul>
  </p>
  <p>
    Say <code>num</code> is <code>5</code> (binary <code>0101</code>), and we want to check if the 2nd bit (counting from 0) is <code>1</code>:
    <ul>
      <li><code>(1 << 2)</code> gives <code>0100</code>.</li>
      <li><code>num & (1 << 2)</code> does <code>0101 & 0100</code>, which gives <code>0100</code> (not zero), so the 2nd bit in <code>num</code> is indeed <code>1</code>.</li>
    </ul>
  </p>
</details>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LNGeKnEk/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>candidates</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot b + b) = O(n)\)</span></p>
<p>The outer loop iterates over 24 bit positions (from 0 to 23), checking each integer in <code>candidates</code> to see if a specific bit is set. Inside the nested loop, the bitwise operation <code>(num &amp; (1 &lt;&lt; i))</code> is performed, which executes in constant time for each candidate and bit position.</p>
<p>Given that there are <span class="math inline">\(n\)</span> integers in <code>candidates</code> and we check up to 24 bit positions for each, the total time complexity for this part is <span class="math inline">\(O(n \cdot 24)\)</span>.</p>
<p>Additionally, we find the maximum value in the <code>bitCount</code> array, which has a fixed size of 24. This allows the operation to complete in <span class="math inline">\(O(b)\)</span> time, where <span class="math inline">\(b\)</span> represents the fixed size of the array.</p>
<p>Thus, the overall time complexity can be expressed as <span class="math inline">\(O(n \cdot b + b) = O(n)\)</span>, where <span class="math inline">\(b = 24\)</span> represents the fixed bit width.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(b) = O(1)\)</span></p>
<p>We utilize an auxiliary array <code>bitCount</code> of size 24 to store the count of set bits at each bit position. Since 24 is a constant that &quot;doesn't scale with <span class="math inline">\(n\)</span>&quot;, the space complexity is <span class="math inline">\(O(b) = O(1)\)</span>, where <span class="math inline">\(b = 24\)</span> represents the fixed bit width.</p>
<p>Aside from <code>bitCount</code>, we only use a few fixed-size variables, resulting in no additional space complexity beyond <span class="math inline">\(O(b)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-direct-maximum-bit-count">Approach 2: Direct Maximum Bit Count</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can simplify the method by focusing on finding the maximum count of candidates with set bits without using an extra array. Here, we keep track of the highest count directly with a single variable, <code>maxCount</code>.</p>
<p>As we loop through each bit position from 0 to 23, we initialize a <code>count</code> variable to zero for each position. For every candidate, we check if the current bit is set. If it is, we increment <code>count</code>. At the end of checking all candidates for a bit position, we compare <code>count</code> to <code>maxCount</code>. If <code>count</code> is larger, we update <code>maxCount</code>. By the end of our iterations, <code>maxCount</code> will reflect the size of the largest combination with a bitwise AND greater than zero.</p>
<p><img src="../Figures/2275/2275_approach_2.png" alt="Direct Maximum Bit Count" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>maxCount</code> to <code>0</code> to track the maximum number of candidates with the same bit position set.</p>
</li>
<li>
<p>Loop over each bit position from <code>0</code> to <code>23</code> (assuming 24 bits are sufficient for the input constraints):</p>
<ul>
<li>
<p>Set <code>count</code> to <code>0</code> for the current bit position to count how many candidates have this bit set.</p>
</li>
<li>
<p>For each number in <code>candidates</code>:</p>
<ul>
<li>Use bitwise AND to check if the current bit position (i-th bit) is set in the number.</li>
<li>If the bit is set, increment <code>count</code>.</li>
</ul>
</li>
<li>
<p>After counting for the current bit position, update <code>maxCount</code> with the maximum value between <code>maxCount</code> and <code>count</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return the <code>maxCount</code>, which represents the largest size of candidates that have a common bit set at the same position.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/S3MrFPY2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>candidates</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot b) = O(n)\)</span></p>
<p>The outer loop runs 24 times, corresponding to checking each of the 24 bits (from the least significant to the 24th bit). Inside this loop, an inner loop iterates over all <span class="math inline">\(n\)</span> elements in the <code>candidates</code> array. For each element, we perform a constant-time operation (bitwise AND) to determine if a specific bit is set.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n \cdot b)\)</span>, where <span class="math inline">\(b = 24\)</span> represents the fixed bit width being processed. The built-in functions used include <code>max</code> (constant time), <code>&amp;</code>, and bit shifting <code>&lt;&lt;</code>, all of which operate in <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm only uses a fixed amount of extra space: <code>maxCount</code> and <code>count</code> (both integers) and does not require any additional data structures.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-palindromic-number/description" target="_blank" rel="noopener noreferrer">Largest Palindromic Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>num</code> consisting of digits only.</p>

<p>Return <em>the <strong>largest palindromic</strong> integer (in the form of a string) that can be formed using digits taken from </em><code>num</code>. It should not contain <strong>leading zeroes</strong>.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li>You do <strong>not</strong> need to use all the digits of <code>num</code>, but you must use <strong>at least</strong> one digit.</li>
	<li>The digits can be reordered.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;444947137&quot;
<strong>Output:</strong> &quot;7449447&quot;
<strong>Explanation:</strong> 
Use the digits &quot;4449477&quot; from &quot;<u><strong>44494</strong></u><u><strong>7</strong></u>13<u><strong>7</strong></u>&quot; to form the palindromic integer &quot;7449447&quot;.
It can be shown that &quot;7449447&quot; is the largest palindromic integer that can be formed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;00009&quot;
<strong>Output:</strong> &quot;9&quot;
<strong>Explanation:</strong> 
It can be shown that &quot;9&quot; is the largest palindromic integer that can be formed.
Note that the integer returned should not contain leading zeroes.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>
	<li><code>num</code> consists of digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-values-from-labels/description" target="_blank" rel="noopener noreferrer">Largest Values From Labels</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>n</code> item&#39;s value and label as two integer arrays <code>values</code> and <code>labels</code>. You are also given two integers <code>numWanted</code> and <code>useLimit</code>.</p>

<p>Your task is to find a subset of items with the <strong>maximum sum</strong> of their values such that:</p>

<ul>
	<li>The number of items is <strong>at most</strong> <code>numWanted</code>.</li>
	<li>The number of items with the same label is <strong>at most</strong> <code>useLimit</code>.</li>
</ul>

<p>Return the maximum sum.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong></p>

<p>The subset chosen is the first, third, and fifth items with the sum of values 5 + 3 + 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<p>The subset chosen is the first, second, and third items with the sum of values 5 + 4 + 3.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">16</span></p>

<p><strong>Explanation:</strong></p>

<p>The subset chosen is the first and fourth items with the sum of values 9 + 7.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == values.length == labels.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= values[i], labels[i] &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= numWanted, useLimit &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description" target="_blank" rel="noopener noreferrer">Least Number of Unique Integers after K Removals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers&nbsp;<code>arr</code>&nbsp;and an integer <code>k</code>.&nbsp;Find the <em>least number of unique integers</em>&nbsp;after removing <strong>exactly</strong> <code>k</code> elements<b>.</b></p>

<ol>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input: </strong>arr = [5,5,4], k = 1
<strong>Output: </strong>1
<strong>Explanation</strong>: Remove the single 4, only 5 is left.
</pre>
<strong class="example">Example 2:</strong>

<pre>
<strong>Input: </strong>arr = [4,3,1,1,3,3,2], k = 3
<strong>Output: </strong>2
<strong>Explanation</strong>: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length&nbsp;&lt;= 10^5</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 10^9</code></li>
	<li><code>0 &lt;= k&nbsp;&lt;= arr.length</code></li>
</ul></div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Every element will have some frequency of occurrence in the array, i.e., the number of times it occurs in the array. Let us try to rephrase the problem in these terms. We want to end up with the least possible number of unique elements after <code>k</code> removals. In other words, we want to maximize the number of elements we can remove wholly (all occurrences of the element) in at most <code>k</code> removals. Let us figure out what is the most optimal way to do this.</p>
<p>Say we had to remove all occurrences of one element from an array such that it took the least number of removals. In this case, we'd remove the element with the least frequency! If there are multiple elements with the least frequency of occurrence, we could remove any.<br />
Therefore, to maximize the number of unique elements removed, the initial focus should be on elements with the lowest frequencies. By starting with the removal of the least frequent element and progressing to the next least frequent ones iteratively until we have at most 'k' removals, we would end up removing the maximum number of elements we could remove wholly!​</p>
<p>To summarize the idea, we need to greedily remove elements starting with the element with the lowest frequency. This way, we will ensure that we remove the maximum number of elements wholly and end up with the least number of unique elements.</p>
<hr />
<h3 id="approach-1-sorting-the-frequencies">Approach 1: Sorting the Frequencies</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find an efficient way of removing the lowest frequency element in the array, repeatedly till we have <code>k</code> removals. If we created a list of the frequencies of all elements, how could we utilize it? If we sort our list, we could start from the smallest frequency and remove elements till we have <code>k</code> removals. The number of remaining frequencies would represent the number of unique elements left in the array after <code>k</code> removals!</p>
<h4 id="algorithm">Algorithm</h4>
<p>Firstly, we need to build our <code>frequencies</code> array. To do this, we'll need to determine the frequencies of all elements. A hashmap can do this efficiently. Once we have our <code>frequencies</code> array, we can sort it and iterate over it, removing elements, till the sum of the removed elements does not exceed <code>k</code>. We'll track the number of elements removed in a variable <code>elementsRemoved</code>. We'll keep iterating over <code>frequencies</code> till <code>elementsRemoved</code> becomes greater than <code>k</code> or we've fully iterated over <code>frequencies</code>. The number of remaining elements in the <code>frequencies</code> array would be our answer!</p>
<p>Note that <code>frequencies</code> contains the frequencies, but not the values, of the given array <code>arr.</code> This is because the value of the elements does not matter in the final answer; we simply need the number of unique elements.</p>
<p>Let us summarize the algorithm.</p>
<ol>
<li>Initialize a hashmap <code>map</code> which maps <code>element</code> to its <code>frequency</code>.</li>
<li>Iterate over the given <code>arr</code> and increment the frequency of its elements in <code>map</code>.</li>
<li>Create an array <code>frequencies</code> and populate it with the frequencies obtained from <code>map</code>.</li>
<li>Sort <code>frequencies</code>.</li>
<li>Create a variable <code>elementsRemoved</code> which will track the number of elements that are removed.</li>
<li>Iterate over <code>frequencies</code> and add its elements to <code>elementsRemoved</code>.</li>
<li>When <code>elementsRemoved</code> becomes greater than <code>k</code>, we can stop iterating and return the remaining number of integers in <code>frequencies</code> (including the present index).</li>
<li>Return <code>0</code> if we iterated over the entire <code>frequencies</code> array. This means that we removed all elements from the original array <code>arr</code>.</li>
</ol>
<p>!?!../Documents/1481/slideshow1.json:960,540!?!​</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5am8whDM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>​Let <span class="math inline">\(n\)</span> be the length of <code>arr</code> and <span class="math inline">\(m\)</span> be the number of unique elements in it. <span class="math inline">\(k\)</span> represents the number of elements to be removed.<br />
​</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n \log n)\)</span>
<ul>
<li>We traverse <code>arr</code> once and populate <code>map</code>. Since inserting in a hashmap takes <span class="math inline">\(O(1)\)</span> time, the entire operation takes <span class="math inline">\(O(n)\)</span>. Since there are <span class="math inline">\(m\)</span> unique elements in <code>arr</code>, <code>frequencies</code> will be of size <span class="math inline">\(m\)</span>, and sorting it would take <span class="math inline">\(O(m \log m)\)</span>. Finally, traversing <code>frequencies</code> and removing at most <span class="math inline">\(k\)</span> elements will take <span class="math inline">\(O(k)\)</span> time (since we break from the loop once we have removed <span class="math inline">\(k\)</span> elements). This makes the total complexity <span class="math inline">\(O(n + m \log m + k)\)</span>. However, in the worst case, where all elements are unique, <span class="math inline">\(m = n\)</span>. Also, in the case where we're asked to remove all elements, <span class="math inline">\(k = n\)</span>. This makes the complexity <span class="math inline">\(O(n + n \log n + n)\)</span>. The dominating term is <span class="math inline">\(O(n \log n)\)</span>.<br />
​</li>
</ul>
</li>
<li>Space complexity: <span class="math inline">\(O(n)\)</span>
<ul>
<li>We use auxiliary space in creating <code>map</code> and <code>frequencies</code>, both of which will have <span class="math inline">\(m\)</span> elements. As discussed, in the worst case, <span class="math inline">\(m = n\)</span>. This results in a space complexity of <span class="math inline">\(O(n)\)</span>. Note that some extra space is used when we sort <code>frequencies</code> in place. The space complexity of the sorting algorithm depends on the programming language.
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting two arrays.</li>
<li>In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>​</p>
<h3 id="approach-2-min-heap">Approach 2: Min-heap</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A heap is a very powerful data structure that allows us to efficiently find the maximum or minimum value in a dynamic dataset.</p>
<p>If you are not familiar with heaps, we recommend checking out the <a href="https://leetcode.com/explore/learn/card/heap/">Heap Explore Card</a>.</p>
<p>We can use a heap to store all the frequencies and pop out the smallest frequency sequentially till we have removed at most <code>k</code> elements. The difference in this approach is that instead of explicitly sorting a list of frequencies, we're using a min-heap to ensure we always get the smallest frequency every time we remove an element from it. We'll add all the frequencies to a min-heap and remove elements from it till we have <code>k</code> removals. The number of remaining frequencies, which in this case would be the size of the heap, would represent the number of unique elements left in the array after <code>k</code> removals!</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Like the previous approach, we'll create a hashmap to determine all the frequencies, but instead of using a vector to store all frequencies, we'll instead use a min-heap. We'll start popping elements out of the heap and store the sum in <code>elementsRemoved</code>. We'll keep repeating this process till either <code>elementsRemoved</code> becomes greater than <code>k</code> or the heap becomes empty. We'll return the size of the heap as our answer (<em>0</em> in case the heap is empty).</p>
<p>Let us summarize the algorithm.</p>
<ol>
<li>Initialize a hashmap <code>map</code> which maps <code>element</code> to its <code>frequency</code>.</li>
<li>Iterate over the given <code>arr</code> and increment the frequency of its elements in <code>map</code>.</li>
<li>Create a min-heap <code>frequencies</code> and populate it with the frequencies obtained from <code>map</code>.</li>
<li>Create a variable <code>elementsRemoved</code> which will track the number of elements that are removed.</li>
<li>Remove elements from <code>frequencies</code> and increment <code>elementsRemoved</code> while there are still elements in <code>frequencies</code>.</li>
<li>If <code>elementsRemoved</code> becomes greater than <code>k</code>, we can stop iterating and return the number of remaining elements in the heap.</li>
<li>Return <code>0</code> if the heap becomes empty. This means we removed all elements from the original array <code>arr</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/drhrSmFh/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>​Let <span class="math inline">\(n\)</span> be the length of <code>arr</code> and <span class="math inline">\(m\)</span> be the number of unique elements in it. <span class="math inline">\(k\)</span> represents the number of elements to be removed.<br />
​</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n \log n)\)</span>
<ul>
<li>We traverse <code>arr</code> once and populate <code>map</code>. Since inserting in a hashmap takes <span class="math inline">\(O(1)\)</span> time, the entire operation takes <span class="math inline">\(O(n)\)</span>. Since there are <span class="math inline">\(m\)</span> unique elements in <code>arr</code> and inserting and removing elements from a min-heap of size <span class="math inline">\(m\)</span> takes <span class="math inline">\(O( \log m)\)</span> time, inserting <span class="math inline">\(m\)</span> elements will take <span class="math inline">\(O(m \log m)\)</span>. Finally, traversing <code>frequencies</code> and removing at most <span class="math inline">\(k\)</span> elements will take <span class="math inline">\(O(k \log k)\)</span> time (since we break from the loop once we have removed <span class="math inline">\(k\)</span> elements). This makes the total complexity <span class="math inline">\(O(n + m \log m + k \log k)\)</span>. However, in the worst case, where all elements are unique, <span class="math inline">\(m = n\)</span>. Also, in the case where we're asked to remove all elements, <span class="math inline">\(k = n\)</span>. This makes the complexity <span class="math inline">\(O(n + n \log n + n \log n)\)</span>, where the dominating term is <span class="math inline">\(O(n \log n)\)</span>.<br />
​</li>
</ul>
</li>
<li>Space complexity: <span class="math inline">\(O(n)\)</span>
<ul>
<li>We use auxiliary space in creating <code>map</code> and <code>frequencies</code>, both of which will have <span class="math inline">\(m\)</span> elements. As discussed, in the worst case, <span class="math inline">\(m = n\)</span>. This results in a space complexity of <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<p>​</p>
<h3 id="approach-3-counting-sort">Approach 3: Counting Sort</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Note that this is a more challenging approach but can be asked as a follow-up in an interview to improve the time complexity further or fetch brownie points! In the first two approaches, we discussed two ways to store and process frequencies - using an array and sorting it, and using a min-heap (which internally uses heap-sort). There is yet another way to sort the frequencies - <a href="https://leetcode.com/explore/learn/card/sorting/695/non-comparison-based-sorts/4437/">Counting Sort</a>! We can <em>count</em> the frequencies and store this count in an array. In other words, we're storing the frequency of frequencies! We can use this array to process the frequencies in order.</p>
<p>Recall that Counting Sort is dependent on the range of input elements, i.e., it relies on the assumption that the range of input elements is not significantly larger than the number of elements to be sorted. In our case, we can leverage the fact that the maximum possible frequency of any element in an array will be equal to the size of the array itself. This will be when all elements of the array are the same, i.e., there is only one unique element. This value will not exceed <code>10^5</code> as mentioned in the constraints; hence, we can use Counting Sort.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Like the previous approaches, we'll create a hashmap to determine all the frequencies. We'll initialize an array <code>countOfFrequencies</code> with size <code>n + 1</code> where <code>n</code> is the size of the given array <code>arr</code>. Since the largest possible value of a frequency is <code>n</code>, we'll need an array of size <code>n + 1</code> to store the value in its nth index. <code>countOfFrequencies</code> will be initialized with <em>0</em> for all its indices. We'll then traverse the hashmap and increment the count of frequencies we encounter in <code>countOfFrequencies</code>. Once done, <code>countOfFrequencies[i]</code> would represent the number of elements in <code>arr</code> with frequency <code>i</code>. We'll also initialize a variable <code>remainingUniqueElements</code> with the size of our hashmap. This would track the remaining number of unique elements. Now we'll traverse <code>countOfFrequencies</code> in order, process each index, and update <code>k</code> accordingly. For each index <code>i</code>, we can remove a maximum of <code>k / i</code> unique elements. However, this is limited by the actual number of elements with frequency <code>i</code>. Hence, we'll find the <em>min</em> of <code>k / i</code> and <code>countOfFrequences[i]</code>. Let this be <code>numElementsToRemove</code>. This will be the maximum number of unique elements with frequency <code>i</code> that can be removed. <code>k</code> will be decremented by <code>i * numElementsToRemove</code>, and <code>remainingUniqueElements</code> will be decremented by <code>numElementsToRemove</code>. Now if the updated <code>k</code> is less than the current frequency <code>i</code>, it'll show that we can no longer remove any more elements with greater frequencies, and we'll return <code>numElementsToRemove</code>.</p>
<p>Let us summarize the algorithm.</p>
<ol>
<li>Initialize a hashmap <code>map</code> which maps <code>element</code> to its <code>frequency</code>.</li>
<li>Iterate over the given <code>arr</code> and increment the frequency of its elements in <code>map</code>.</li>
<li>Create an array <code>countOfFrequencies</code> of size <code>n + 1</code> where <code>n</code> is the size of <code>arr</code>. Initialize all elements of this array with <code>0</code>.</li>
<li>Traverse over <code>map</code> and increment the frequencies of all frequencies in <code>countOfFrequencies</code>.</li>
<li>Initialize a variable <code>numElementsToRemove</code> with the size of <code>map</code>. This tracks the remaining number of unique elements.</li>
<li>Traverse over <code>countOfFrequencies</code> and for each frequency <code>i</code>, determine the maximum number of elements that can be removed with that frequency. This value will be <code>min(k / i, countOfFrequencies[i])</code>. Initialize a variable <code>numElementsToRemove</code> with this value.</li>
<li>Decrement <code>k</code> by <code>i * numElementsToRemove</code> and decrement <code>remainingUniqueElements</code> by <code>numElementsToRemove</code>.</li>
<li>Check if <code>k &lt; i</code>. If so, return <code>numElementsToRemove</code>.</li>
<li>Return <code>0</code> if we iterated over all the frequencies. This means we removed all elements from the original array <code>arr</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/UJ8mrPep/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>​Let <span class="math inline">\(n\)</span> be the length of <code>arr</code>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span>
<ul>
<li>We traverse <code>arr</code> once and populate <code>map</code>, which is a linear operation. Then we traverse <code>map</code> and populate <code>countOfFrequencies</code>. <code>map</code> can have a maximum size of <span class="math inline">\(n\)</span> so this is also a linear operation. Finally, traversing <code>countOfFrequencies</code> is also a linear operation since the size of <code>countOfFrequencies</code> is <code>n + 1</code>.<br />
​</li>
</ul>
</li>
<li>Space complexity: <span class="math inline">\(O(n)\)</span>
<ul>
<li>We create a hashmap that can have a maximum size of <span class="math inline">\(n\)</span> and an array with size <code>n + 1</code>.</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/letter-tile-possibilities/description" target="_blank" rel="noopener noreferrer">Letter Tile Possibilities</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code>&nbsp;&nbsp;<code>tiles</code>, where each tile has one letter <code>tiles[i]</code> printed on it.</p>

<p>Return <em>the number of possible non-empty sequences of letters</em> you can make using the letters printed on those <code>tiles</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tiles = &quot;AAB&quot;
<strong>Output:</strong> 8
<strong>Explanation: </strong>The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tiles = &quot;AAABBC&quot;
<strong>Output:</strong> 188
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tiles = &quot;V&quot;
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tiles.length &lt;= 7</code></li>
	<li><code>tiles</code> consists of uppercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursion">Approach 1: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's think about how we naturally form different sequences from a set of letters. Imagine we have Scrabble tiles with the letters &quot;A&quot;, &quot;A&quot;, and &quot;B&quot;. How would we manually find all possible sequences? We would likely start with single letters (&quot;A&quot;, &quot;B&quot;), then try two-letter combinations (&quot;AA&quot;, &quot;AB&quot;), and finally three-letter combinations (&quot;AAB&quot;).</p>
<p>A point to note in this manual process is that at each step, we make a choice about whether to use each available letter. For example, when starting with &quot;AAB&quot;, we first decide: &quot;Should I use the first &quot;A&quot;?&quot; If we use it, we then face the same type of decision with our remaining letters. If we don't use it, we still have all our letters available for future choices.</p>
<p>This decision-making pattern, where each choice reduces the problem to a smaller version of itself and follows a repetitive structure, naturally suggests a recursive approach. At each level of the recursion (or decision point), we have two options: either use an available letter and continue exploring, or skip it and move to the next letter.</p>
<p>The diagram below illustrates the structure of a recursion tree for this problem:</p>
<p><img src="../Figures/1079/recursion_tree.png" alt="" /></p>
<p>However, there's a subtle complexity we need to address. Consider the input <code>&quot;AAB&quot;</code> again. If we're not careful, we might count the same sequence multiple times because we have duplicate letters. For instance, we could form <code>&quot;AB&quot;</code> by using either the first or second <code>&quot;A&quot;</code>.</p>
<p>To solve this, we’ll store all the sequences we generate in a hash set. Hash sets allow for quick lookups and keep the characters unique due to the set property, so we can check whether a particular sequence has already been found.</p>
<p>Let's create a recursive function <code>generateSequences</code> which creates all possible letter sequences. We'll also maintain a boolean array <code>used</code> of size equal to that of <code>tiles</code>. Each index in <code>used</code> tells us whether the character at that index in <code>tiles</code> has been used in the current sequence or not.</p>
<p>The first step in the recursive function is to add the current sequence to the hash set. This is because all intermediate sequences are also valid combinations and not just the ones where we use all the tiles. Next, we’ll iterate over each character in <code>tiles</code>. If a character hasn’t been used yet, we’ll add it to the current sequence and recurse. After exploring that path, we’ll backtrack and mark the letter as unused to allow us to try different combinations.</p>
<p>We start the recursion by calling the function with an empty string. When the recursion completes, the hash set will contain all possible letter combinations. Finally, we return the size of the hash set minus one, since the problem asks for non-empty sequences only.</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a hash set called <code>sequences</code> to store the unique sequences.</li>
<li>a variable <code>len</code> to store the length of the input string <code>tiles</code>.</li>
</ul>
</li>
<li>Create a boolean array <code>used</code> of size <code>len</code> to track the used characters</li>
<li>Call the recursive helper function <code>generateSequences</code> with the initial parameters: <code>tiles</code>, an empty string, <code>used</code> array, and the <code>sequences</code> set.</li>
<li>Return the size of the <code>sequences</code> set minus 1 (to exclude the empty string).</li>
</ul>
<p>Helper method <code>generateSequences(tiles, current, used, sequences)</code>:</p>
<ul>
<li>Add the <code>current</code> sequence to the <code>sequences</code> set.</li>
<li>Initialize a loop that runs from position <code>0</code> to the length of <code>tiles</code>. For each position:
<ul>
<li>Check if the character at the current position is not used. If not used:
<ul>
<li>Mark the current position as used in the <code>used</code> array.</li>
<li>Make a recursive call with: <code>tiles</code>, <code>current</code> string + character at the current position, <code>used</code> array, and <code>sequences</code> set.</li>
<li>After the recursive call returns, mark the current position as unused (backtrack).</li>
</ul>
</li>
</ul>
</li>
<li>When the loop ends, return to the previous recursive call.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DGSVqd6c/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>tiles</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n!)\)</span></p>
<p>The time complexity is determined by two main factors. First, for each position, we have at most <span class="math inline">\(n\)</span> choices (in the first level of recursion). At each subsequent level, we have one less choice as characters get used. This creates a pattern similar to <span class="math inline">\(n \cdot (n-1) \cdot (n-2) \cdot ... \cdot 1\)</span>, which is <span class="math inline">\(n!\)</span>. Additionally, at each step, we perform string concatenation which takes <span class="math inline">\(O(n)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot n!)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n!)\)</span></p>
<p>The space complexity has multiple components. First, the recursion stack can go up to depth <span class="math inline">\(n\)</span>, using <span class="math inline">\(O(n)\)</span> space. The set <code>sequences</code> will store all possible unique sequences. For a string of length <span class="math inline">\(n\)</span>, we can have sequences of length <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>, and each sequence can be made from <span class="math inline">\(n\)</span> possible characters (with repetition allowed). This means the hash set can store up to <span class="math inline">\(O(n!)\)</span> sequences, and each sequence can be of length <span class="math inline">\(O(n)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot n!)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-recursion">Approach 2: Optimized Recursion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Imagine we're playing with Scrabble tiles again, but this time we have the string &quot;AAABBC&quot;. We can make an important observation here: what really matters isn't the position of each letter, but rather how many of each letter we have available. Whether we use the first &quot;A&quot; or the second &quot;A&quot; doesn't change the sequences we can create - we just need to know we have three &quot;A&quot;s to work with.</p>
<p>This insight leads us to our first key decision: instead of tracking individual letters, we can track the frequency of each letter. Think of it like having separate piles for each letter - three tiles in the &quot;A&quot; pile, two in the &quot;B&quot; pile, and one in the &quot;C&quot; pile. To implement this, we can maintain an array <code>charCount</code> where each index represents a letter (0 for &quot;A&quot;, 1 for &quot;B&quot;, etc.), and the value represents how many of that letter we have.</p>
<p>Now, let's think about how we build sequences using these frequency counts. At each step, we're asking ourselves: &quot;Which letter should I add to my current sequence?&quot; We can loop over all 26 letters and use any letter that still has a positive count. This is fundamentally different from our previous approach where we were making yes/no decisions about each position in <code>tiles</code>.</p>
<p>This incremental building of the sequence using the remaining letters suggests a recursive approach. We'll pass <code>charCount</code> to the recursive function and start building the sequence by eliminating each available character one by one. Remember that we also need to count all intermediate sequences (where <code>charCount</code> is not empty yet), because these are also valid letter tile possibilities.</p>
<p>Notice that nowhere in our algorithm do we work with the actual sequence itself. Each unique sequence is determined by the number of letters available in <code>charCount</code>, not the sequence. This means we no longer need to maintain a hash set to store visited sequences, saving significant space.</p>
<p>Our main function calls the recursive method with the full <code>charCount</code> array. The result returned by it is our required answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an integer array <code>charCount</code> of size <code>26</code> to store the frequency of each uppercase letter.</li>
<li>Iterate through each character of <code>tiles</code>:
<ul>
<li>Increment the count at the index (character - 'A') in the <code>charCount</code> array.</li>
</ul>
</li>
<li>Call the recursive helper function <code>findSequences</code> with the <code>charCount</code> array.</li>
<li>Return the result from <code>findSequences</code>.</li>
</ul>
<p>Helper method <code>findSequences(charCount)</code>:</p>
<ul>
<li>Initialize a variable <code>totalCount</code> to <code>0</code> to track the number of possible sequences.</li>
<li>Start a loop that runs from position <code>0</code> to <code>25</code> (for 26 letters):
<ul>
<li>Check if the count of the current character is <code>0</code>. If true:
<ul>
<li>Skip to the next iteration.</li>
</ul>
</li>
<li>If not <code>0</code>:
<ul>
<li>Increment <code>totalCount</code> by <code>1</code> (counting the current character as a sequence).</li>
<li>Decrement the count of the current character in the <code>charCount</code> array.</li>
<li>Make a recursive call with the updated <code>charCount</code> array.</li>
<li>Add the result of the recursive call to <code>totalCount</code>.</li>
<li>Increment the count of the current character back (backtrack).</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalCount</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/TujH9fTX/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>tiles</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n!)\)</span></p>
<p>The time complexity comes from the fact that for each position in our sequence, we can choose any of the remaining available characters. At each recursive call, we try all remaining characters, and the number of choices decreases by <span class="math inline">\(1\)</span> each time since we're using frequency counting to handle duplicates. For an input string of length <span class="math inline">\(n\)</span>, at the first level we have <span class="math inline">\(n\)</span> choices, then <span class="math inline">\((n-1)\)</span> choices, and so on, leading to <span class="math inline">\(n \cdot (n-1) \cdot (n-2) ... 1\)</span> possibilities. This recursive pattern of decreasing choices at each level results in a time complexity of <span class="math inline">\(O(n!)\)</span>.</p>
<blockquote>
<p>[!NOTE]<br />
A common misconception is that the time complexity of this problem is <span class="math inline">\(O(2^n)\)</span>, stemming from the idea that each character has a binary decision, either to include or exclude. This may seem valid in problems involving combinations or subsets, but here, the goal is to generate all possible permutations of the tiles. Since we're considering character frequencies, the complexity grows factorially, not exponentially, leading to <span class="math inline">\(O(n!)\)</span>. Each recursive call handles one tile from a decreasing pool of remaining tiles, generating distinct sequences.</p>
<p>Another misconception is that the time complexity is <span class="math inline">\(O(26^n)\)</span>, based on the assumption that there are 26 possible characters at each recursive step. However, the actual complexity depends on the tile frequencies. The recursion operates within the constraints of the available tiles, not an arbitrary 26 choices per call.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity has two parts. First, the fixed-size array <code>charCount</code> takes <span class="math inline">\(O(1)\)</span> space as it always has <span class="math inline">\(26\)</span> elements regardless of input size. Second, the recursion stack can go up to depth <span class="math inline">\(n\)</span> as each recursive call uses one character.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-permutations-and-combinations">Approach 3: Permutations and Combinations</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Consider a sequence &quot;ABC&quot;. Generating it actually has two steps:</p>
<ol>
<li>Choosing the three tiles &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;.</li>
<li>Arranging them in order to form &quot;ABC&quot;.</li>
</ol>
<p>Notice that after step 1, we can create 5 more sequences: &quot;BAC&quot;, &quot;CBA&quot;, &quot;BCA&quot;, &quot;ACB&quot;, and &quot;CAB.&quot; These are all the permutations of &quot;ABC&quot;.</p>
<p>The total number of permutations that can be generated from <span class="math inline">\(n\)</span> unique characters is <span class="math inline">\(n!\)</span>. For the characters &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;, the number of unique characters is 3, so 6 sequences can be generated from them.</p>
<p>However, we need to account for cases where there are multiple occurrences of the same character. For example, consider the tiles &quot;A&quot;, &quot;A&quot;, and &quot;B&quot;. This will generate only 3 unique sequences of length 3: &quot;AAB&quot;, &quot;ABA&quot;, and &quot;BAA&quot;. This is because swapping the first and second &quot;A&quot; doesn’t create a new sequence, so they can’t be counted separately.</p>
<p>To account for this, we modify our formula to the following: if we have 3 characters with frequencies <span class="math inline">\(n_1\)</span>, <span class="math inline">\(n_2\)</span>, and <span class="math inline">\(n_3\)</span>, the number of <span class="math inline">\(3\)</span> length sequences are:</p>
<p><span class="math display">\[\begin{aligned}
    \frac{(n_1 + n_2 + n_3)!}{(n_1)! \cdot (n_2)! \cdot (n_3)!}
\end{aligned}
\]</span></p>
<p>The above formula can be extended to <span class="math inline">\(m\)</span> characters of different frequencies.</p>
<p>So now, our task is to generate all combinations of characters from the given tiles. We can use a recursive method to do this. The function iterates over the tiles string and makes two choices at each step: whether to pick the current character or not. This generates all possible combinations of characters, which we then pass to a helper method called <code>countPermutations</code>.</p>
<p>The <code>countPermutations</code> method counts the frequency of each character in the generated combination using an array called <code>charCount</code> (similar to the previous approach). It then applies the formula above to calculate all possible permutations of the current combination.</p>
<p>The total permutations for each combination are returned by the recursive function. The cumulative sum of all such combinations is our final answer, which we return at the end.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a hash set <code>seen</code> to store unique sequences.</li>
<li>Convert <code>seen</code> to a sorted string <code>sortedTiles</code>.</li>
<li>Call the recursive helper function <code>generateSequences</code> with initial parameters. Subtract 1 from the result and return it.</li>
</ul>
<p>Helper method <code>factorial(n)</code>:</p>
<ul>
<li>Check if <code>n</code> is less than or equal to <code>1</code>:
<ul>
<li>If <code>true</code>, return <code>1</code>.</li>
</ul>
</li>
<li>Initialize a variable <code>result</code> to <code>1</code>.</li>
<li>Loop <code>num</code> from <code>2</code> to <code>n</code>:
<ul>
<li>Multiply the result by <code>num</code>.</li>
</ul>
</li>
<li>Return the final <code>result</code>.</li>
</ul>
<p>Helper method <code>countPermutations(seq)</code>:</p>
<ul>
<li>Initialize an integer array <code>charCount</code> of size <code>26</code> for character frequencies.</li>
<li>Iterate through each character in the input <code>seq</code>:
<ul>
<li>Increment the count at index (character - 'A') in <code>charCount</code>.</li>
</ul>
</li>
<li>Set a variable <code>total</code> as the <code>factorial</code> of the length of <code>seq</code>.</li>
<li>Divide the <code>total</code> by the factorial of each character's frequency in <code>charCount</code>.</li>
<li>Return the final <code>total</code>.</li>
</ul>
<p>Helper method <code>generateSequences(tiles, current, pos, seen)</code>:</p>
<ul>
<li>Check if the current <code>pos</code> has reached the length of <code>tiles</code>. If true and the <code>current</code> sequence is new (added to <code>seen</code> set):
<ul>
<li>Return the number of permutations for the current sequence.</li>
</ul>
</li>
<li>If true but the sequence is already seen:
<ul>
<li>Return <code>0</code>.</li>
</ul>
</li>
<li>Make two recursive calls and sum their results:
<ul>
<li>One excluding the current character (same sequence, next position).</li>
<li>One including the current character (sequence + current character, next position).</li>
</ul>
</li>
<li>Return the sum of both recursive calls.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/oW4cyKrY/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>tiles</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^n \cdot n)\)</span></p>
<p>The time complexity is determined by several components:</p>
<ol>
<li>The initial sorting takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>In the <code>generateSequences</code> function, we create a binary recursion tree where at each position we have two choices (include or exclude), leading to <span class="math inline">\(2^n\)</span> possible sequences. For each unique sequence, we calculate permutations which involves iterating over the sequence (<span class="math inline">\(O(n)\)</span>) and performing factorial calculations (<span class="math inline">\(O(n)\)</span>).</li>
<li>The factorial calculations themselves are <span class="math inline">\(O(n)\)</span> as they iterate from <span class="math inline">\(1\)</span> to at most <span class="math inline">\(n\)</span>.</li>
</ol>
<p>Therefore, the dominant factor is generating and processing all possible sequences, giving us a time complexity of <span class="math inline">\(O(2^n \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2^n \cdot n)\)</span></p>
<p>The space complexity also has multiple components.</p>
<ol>
<li>The recursion stack can go up to depth <span class="math inline">\(n\)</span>, using <span class="math inline">\(O(n)\)</span> space.</li>
<li>The hash set <code>seen</code> stores unique combinations of characters. In the worst case, with all distinct characters, we could have <span class="math inline">\(2^n\)</span> different combinations as each character can either be included or excluded. Each sequence in the set can be up to length <span class="math inline">\(n\)</span>. So, the set uses <span class="math inline">\(O(2^n \cdot n)\)</span> space.</li>
<li>The <code>charCount</code> array in <code>countPermutations</code> is constant space <span class="math inline">\(O(1)\)</span> as it's always size <span class="math inline">\(26\)</span>.</li>
</ol>
<p>Thus, the dominant factor is the space needed for storing unique sequences in the <code>seen</code> set, making the total space complexity <span class="math inline">\(O(2^n \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-harmonious-subsequence/description" target="_blank" rel="noopener noreferrer">Longest Harmonious Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sliding-window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We define a harmonious array as an array where the difference between its maximum value and its minimum value is <b>exactly</b> <code>1</code>.</p>

<p>Given an integer array <code>nums</code>, return the length of its longest harmonious <span data-keyword="subsequence-array">subsequence</span> among all its possible subsequences.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,3,2,2,5,2,3,7]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>The longest harmonious subsequence is <code>[3,2,2,2,3]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The longest harmonious subsequences are <code>[1,2]</code>, <code>[2,3]</code>, and <code>[3,4]</code>, all of which have a length of 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>No harmonic subsequence exists.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/description" target="_blank" rel="noopener noreferrer">Longest Palindrome by Concatenating Two Letter Words</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code>. Each element of <code>words</code> consists of <strong>two</strong> lowercase English letters.</p>

<p>Create the <strong>longest possible palindrome</strong> by selecting some elements from <code>words</code> and concatenating them in <strong>any order</strong>. Each element can be selected <strong>at most once</strong>.</p>

<p>Return <em>the <strong>length</strong> of the longest palindrome that you can create</em>. If it is impossible to create any palindrome, return <code>0</code>.</p>

<p>A <strong>palindrome</strong> is a string that reads the same forward and backward.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;lc&quot;,&quot;cl&quot;,&quot;gg&quot;]
<strong>Output:</strong> 6
<strong>Explanation:</strong> One longest palindrome is &quot;lc&quot; + &quot;gg&quot; + &quot;cl&quot; = &quot;lcggcl&quot;, of length 6.
Note that &quot;clgglc&quot; is another longest palindrome that can be created.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;ab&quot;,&quot;ty&quot;,&quot;yt&quot;,&quot;lc&quot;,&quot;cl&quot;,&quot;ab&quot;]
<strong>Output:</strong> 8
<strong>Explanation:</strong> One longest palindrome is &quot;ty&quot; + &quot;lc&quot; + &quot;cl&quot; + &quot;yt&quot; = &quot;tylcclyt&quot;, of length 8.
Note that &quot;lcyttycl&quot; is another longest palindrome that can be created.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;cc&quot;,&quot;ll&quot;,&quot;xx&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> One longest palindrome is &quot;cc&quot;, of length 2.
Note that &quot;ll&quot; is another longest palindrome that can be created, and so is &quot;xx&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>words[i].length == 2</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-subsequence-repeated-k-times/description" target="_blank" rel="noopener noreferrer">Longest Subsequence Repeated k Times</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of length <code>n</code>, and an integer <code>k</code>. You are tasked to find the <strong>longest subsequence repeated</strong> <code>k</code> times in string <code>s</code>.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>

<p>A subsequence <code>seq</code> is <strong>repeated</strong> <code>k</code> times in the string <code>s</code> if <code>seq * k</code> is a subsequence of <code>s</code>, where <code>seq * k</code> represents a string constructed by concatenating <code>seq</code> <code>k</code> times.</p>

<ul>
	<li>For example, <code>&quot;bba&quot;</code> is repeated <code>2</code> times in the string <code>&quot;bababcba&quot;</code>, because the string <code>&quot;bbabba&quot;</code>, constructed by concatenating <code>&quot;bba&quot;</code> <code>2</code> times, is a subsequence of the string <code>&quot;<strong><u>b</u></strong>a<strong><u>bab</u></strong>c<strong><u>ba</u></strong>&quot;</code>.</li>
</ul>

<p>Return <em>the <strong>longest subsequence repeated</strong> </em><code>k</code><em> times in string </em><code>s</code><em>. If multiple such subsequences are found, return the <strong>lexicographically largest</strong> one. If there is no such subsequence, return an <strong>empty</strong> string</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example 1" src="https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png" style="width: 457px; height: 99px;" />
<pre>
<strong>Input:</strong> s = &quot;letsleetcode&quot;, k = 2
<strong>Output:</strong> &quot;let&quot;
<strong>Explanation:</strong> There are two longest subsequences repeated 2 times: &quot;let&quot; and &quot;ete&quot;.
&quot;let&quot; is the lexicographically largest one.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bb&quot;, k = 2
<strong>Output:</strong> &quot;b&quot;
<strong>Explanation:</strong> The longest subsequence repeated 2 times is &quot;b&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ab&quot;, k = 2
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> There is no subsequence repeated 2 times. Empty string is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == s.length</code></li>
	<li><code>2 &lt;= k &lt;= 2000</code></li>
	<li><code>2 &lt;= n &lt; min(2001, k * 8)</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-brute-force-enumeration">Approach: Brute-force Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem statement, the task is to find the longest subsequence of characters that appears at least <span class="math inline">\(k\)</span> times and is lexicographically largest. Therefore, the characters that make up this subsequence must appear at least <span class="math inline">\(k\)</span> times in <span class="math inline">\(s\)</span>. Characters that appear fewer than <span class="math inline">\(k\)</span> times in <span class="math inline">\(s\)</span> can be filtered out directly.</p>
<p>Let the length of <span class="math inline">\(s\)</span> be <span class="math inline">\(n\)</span>. We only consider characters in <span class="math inline">\(s\)</span> that appear at least <span class="math inline">\(k\)</span> times. The longest valid subsequence can only be composed of these characters, and their count cannot exceed <span class="math inline">\(\left\lfloor \dfrac{n}{k} \right\rfloor\)</span>. Since the problem states that <span class="math inline">\(n < 8k\)</span>, the length of the longest valid subsequence must be at most <span class="math inline">\(7\)</span>, and the number of qualifying characters is also at most <span class="math inline">\(7\)</span>. Therefore, the number of candidate subsequences does not exceed <span class="math inline">\(2^7 = 128\)</span>, making it feasible to use brute-force enumeration to find the correct answer.</p>
<p>We start by counting the frequency of each character to identify those that meet the required threshold. Then, we enumerate all possible permutations formed from any combination of these characters. For each such permutation <span class="math inline">\(\textit{permutation}_i\)</span>, we check whether it appears in <span class="math inline">\(s\)</span> at least <span class="math inline">\(k\)</span> times. Among all valid permutations, we return the one with the maximum length and the greatest lexicographical order.</p>
<p>To generate all permutations, we can use a queue. Each time, we pop the current valid subsequence <span class="math inline">\(\textit{curr}\)</span> from the queue and attempt to append a valid character <span class="math inline">\(c\)</span> to form a new string <span class="math inline">\(\textit{next}\)</span>. If <span class="math inline">\(\textit{next}\)</span> appears in <span class="math inline">\(s\)</span> at least <span class="math inline">\(k\)</span> times, we push it into the queue to continue expanding it. By enumerating characters in reverse lexicographical order (from largest to smallest), we ensure that the largest lexicographical string is generated first. This allows us to return the longest and lexicographically largest valid subsequence efficiently.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DmwxQ3yf/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the given string, and let <span class="math inline">\(k\)</span> be the given number.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot {\lfloor \dfrac{n}{k} \rfloor}!)\)</span>.</p>
<p>According to the analysis, the length of the subsequence does not exceed <span class="math inline">\(m = \lfloor \frac{n}{k} \rfloor\)</span>. At this point, there are <span class="math inline">\(i!\)</span> combinations of strings of length <span class="math inline">\(i\)</span>, so the total number of possible string combinations is</p>
</li>
</ul>
<p><span class="math display">\[
  Therefore, there are at most $2m!$ candidate subsequences. After generating the candidate subsequences, it still takes $O(n)$ time to match and check them, so the total time complexity is $O(n \cdot \lfloor \frac{n}{k} \rfloor!)$.

- Space complexity: $O(\lfloor \dfrac{n}{k} \rfloor!)$.

  There can be at most $\lfloor \dfrac{n}{k} \rfloor!$ candidate subsequences, and at most $\lfloor \dfrac{n}{k} \rfloor!$ elements can exist in the queue. Thus, the space complexity is $O(\lfloor \dfrac{n}{k} \rfloor!)$.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/majority-element/description" target="_blank" rel="noopener noreferrer">Majority Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>

<p>The majority element is the element that appears more than <code>&lfloor;n / 2&rfloor;</code> times. You may assume that the majority element always exists in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [3,2,3]
<strong>Output:</strong> 3
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [2,2,1,1,1,2,2]
<strong>Output:</strong> 2
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow-up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/majority-element-ii/description" target="_blank" rel="noopener noreferrer">Majority Element II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array of size <code>n</code>, find all elements that appear more than <code>&lfloor; n/3 &rfloor;</code> times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,3]
<strong>Output:</strong> [3]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> [1]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2]
<strong>Output:</strong> [1,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-number-of-distinct-characters-equal/description" target="_blank" rel="noopener noreferrer">Make Number of Distinct Characters Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>word1</code> and <code>word2</code>.</p>

<p>A <strong>move</strong> consists of choosing two indices <code>i</code> and <code>j</code> such that <code>0 &lt;= i &lt; word1.length</code> and <code>0 &lt;= j &lt; word2.length</code> and swapping <code>word1[i]</code> with <code>word2[j]</code>.</p>

<p>Return <code>true</code> <em>if it is possible to get the number of distinct characters in</em> <code>word1</code> <em>and</em> <code>word2</code> <em>to be equal with <strong>exactly one</strong> move. </em>Return <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;ac&quot;, word2 = &quot;b&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> Any pair of swaps would yield two distinct characters in the first string, and one in the second string.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abcc&quot;, word2 = &quot;aab&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = &quot;abac&quot; and word2 = &quot;cab&quot;, which both have 3 distinct characters.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abcde&quot;, word2 = &quot;fghij&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Both resulting strings will have 5 distinct characters, regardless of which indices we swap.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>word1</code> and <code>word2</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description" target="_blank" rel="noopener noreferrer">Maximum Count of Positive Integer and Negative Integer</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">counting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>the maximum between the number of positive integers and the number of negative integers.</em></p>

<ul>
	<li>In other words, if the number of positive integers in <code>nums</code> is <code>pos</code> and the number of negative integers is <code>neg</code>, then return the maximum of <code>pos</code> and <code>neg</code>.</li>
</ul>

<p><strong>Note</strong> that <code>0</code> is neither positive nor negative.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,-1,-1,1,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 positive integers and 3 negative integers. The maximum count among them is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-3,-2,-1,0,0,1,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 2 positive integers and 3 negative integers. The maximum count among them is 3.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,20,66,1314]
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 positive integers and 0 negative integers. The maximum count among them is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>-2000 &lt;= nums[i] &lt;= 2000</code></li>
	<li><code>nums</code> is sorted in a <strong>non-decreasing order</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve the problem in <code>O(log(n))</code> time complexity?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of <span class="math inline">\(N\)</span> integers, which may contain positive, negative, or zero values. The array is sorted in non-decreasing order. The task is to count the number of positive and negative integers, and then return the greater of the two counts. Note that zero is considered neither a positive nor a negative integer.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>This is the brute-force approach, where we count the number of positive and negative integers by iterating through each element of the array. During the iteration, we increment <code>positiveCount</code> for each integer greater than zero and <code>negativeCount</code> for each integer less than zero.</p>
<p>Finally, we return the greater of the two variables, <code>positiveCount</code> and <code>negativeCount</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize the variables <code>positiveCount</code> and <code>negativeCount</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over the array <code>nums</code> and for each integer <code>num</code> do the following:</p>
<ul>
<li>Increment the variable <code>positiveCount</code> if <code>num</code> is greater than <code>0</code>.</li>
<li>Increment the variable <code>negativeCount</code> if <code>num</code> is less than <code>0</code>.</li>
</ul>
</li>
<li>
<p>Return the max of the two variables <code>positiveCount</code> and <code>negativeCount</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/YoJSNJpW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of integers in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need to iterate over each integer in the array <code>nums</code> and hence the time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No extra space is required apart from the two variables, <code>positiveCount</code> and <code>negativeCount</code>, and hence the total space complexity is constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search">Approach 2: Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we did not utilize an important property of the problem: the array is sorted in non-decreasing order. One of the typical algorithms that leverages a sorted array is binary search. Let's explore how we can apply binary search to solve this problem.</p>
<p>The array contains negative, positive, and zero integers, and because it is ordered, the zeros will be positioned in the middle, separating the negative and positive integers. To count the number of negative and positive integers, observe that all the integers before the first zero are negative, and all the integers after the last zero are positive. This observation is key: if we can find the indices of the first and last zeros in the array, we can easily determine the counts of positive and negative integers.</p>
<p>If the first zero is located at index <code>x</code>, then there are <code>x</code> negative integers (from index <code>0</code> to <code>x - 1</code>). Similarly, if the last zero is at index <code>y</code>, there are <code>N - y - 1</code> positive integers (from index <code>y + 1</code> to <code>N - 1</code>).</p>
<p>In languages like C++, we have built-in functions such as <code>lower_bound()</code> and <code>upper_bound()</code> that can be used to find these indices directly. To improve readability, we will implement these functions ourselves. The <code>lowerBound()</code> function will return the first index in the array where the value is greater than or equal to zero, and the <code>upperBound()</code> function will return the first index where the value is strictly greater than zero.</p>
<p>The number of positive integers, <code>positiveCount,</code> will be equal to <code>N - upperBound()</code>, since <code>upperBound()</code> returns the first index where the value is greater than zero. Similarly, the number of negative integers, <code>negativeCount</code>, will be equal to <code>lowerBound()</code>, as <code>lowerBound()</code> returns the first index where the value is greater than or equal to zero.</p>
<p>The implementations of <code>lowerBound(nums)</code> and <code>upperBound(nums)</code> are similar. For <code>lowerBound(nums)</code>, we perform a binary search with <code>start = 0</code> and <code>end = nums.size - 1</code>. In each iteration, we calculate the <code>mid</code> index as <code>(start + end) / 2</code>:</p>
<ul>
<li>If <code>nums[mid]</code> is less than <code>0</code>, the first non-negative value must be to the right, so we update <code>start</code> to <code>mid + 1</code> to search the higher range.</li>
<li>If <code>nums[mid]</code> is greater than or equal to <code>0</code>, <code>mid</code> could be the index we are looking for, so we store it as a candidate answer in <code>index</code>. Then, we continue searching to the left by updating <code>end</code> to <code>mid - 1</code> to check whether there is another non-negative value before <code>nums[mid]</code>.</li>
</ul>
<p>This process continues until the search space is exhausted. If you want to learn more details, please read the <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card</a>.</p>
<p>Once we have determined the counts of positive and negative integers using binary search, we can return the greater of the two counts, as we did in the previous approach.</p>
<p><img src="../Figures/2529/2529A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Define <code>lowerBound(nums)</code> function to find the first index where the value is equal to or greater than zero.</p>
<ul>
<li>Initialize <code>start = 0</code>, <code>end = nums.size - 1,</code> and <code>index = nums.size</code>.</li>
<li>Perform a binary search:
<ul>
<li>If the middle element (<code>nums[mid]</code>) is negative, move <code>start </code>to <code>mid + 1</code> to search for non-negative integers in the higher range.</li>
<li>Otherwise, the middle element (<code>nums[mid]</code>) is non-negative:
<ul>
<li>Move <code>end</code> to <code>mid - 1</code> to search for the <strong>first</strong> non-negative element in the lower range.</li>
<li>Update <code>index</code> to <code>mid</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>index</code>, which represents the first index where a non-negative value appears.</li>
</ul>
</li>
<li>
<p>Define <code>upperBound(nums)</code> function to find the first index where the value is strictly greater than zero.</p>
<ul>
<li>Initialize <code>start = 0</code>, <code>end = nums.size - 1</code>, and <code>index = nums.size</code>.</li>
<li>Perform a binary search:
<ul>
<li>If the middle element (<code>nums[mid]</code>) is less than or equal to zero, move <code>start</code> to <code>mid + 1</code> to search for positive values in the higher range.</li>
<li>Otherwise, the middle element (<code>nums[mid]</code>) is greater than zero:
<ul>
<li>Move <code>end</code> to <code>mid - 1</code>, to search for the <strong>first</strong> positive value in the lower range.</li>
<li>Update <code>index</code> to <code>mid</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>index</code>, which represents the first index where a positive value appears.</li>
</ul>
</li>
<li>
<p>Subtract the result of <code>upperBound(nums)</code> from the total array size to get the number of positive integers (<code>positiveCount</code>).</p>
</li>
<li>
<p>Call <code>lowerBound(nums)</code>, which directly gives the count of negative integers (<code>negativeCount</code>).</p>
</li>
<li>
<p>Return the maximum of <code>positiveCount</code> and <code>negativeCount</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/KZiv6zMc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of integers in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log N)\)</span></p>
<p>We perform binary search twice to find the lower and upper bounds for <code>0</code>. At each step of the binary search, we discard half of the array, narrowing down the search range for the index we are looking for. Hence, the total time complexity is  <span class="math inline">\(O(\log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No extra space is required apart from a few variables and hence the total space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-i/description" target="_blank" rel="noopener noreferrer">Maximum Difference Between Even and Odd Frequency I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of lowercase English letters.</p>

<p>Your task is to find the <strong>maximum</strong> difference <code>diff = freq(a<sub>1</sub>) - freq(a<sub>2</sub>)</code> between the frequency of characters <code>a<sub>1</sub></code> and <code>a<sub>2</sub></code> in the string such that:</p>

<ul>
	<li><code>a<sub>1</sub></code> has an <strong>odd frequency</strong> in the string.</li>
	<li><code>a<sub>2</sub></code> has an <strong>even frequency</strong> in the string.</li>
</ul>

<p>Return this <strong>maximum</strong> difference.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aaaaabbc&quot;</span></p>

<p><strong>Output:</strong> 3</p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The character <code>&#39;a&#39;</code> has an <strong>odd frequency</strong> of <code><font face="monospace">5</font></code><font face="monospace">,</font> and <code>&#39;b&#39;</code> has an <strong>even frequency</strong> of <code><font face="monospace">2</font></code>.</li>
	<li>The maximum difference is <code>5 - 2 = 3</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcabcab&quot;</span></p>

<p><strong>Output:</strong> 1</p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The character <code>&#39;a&#39;</code> has an <strong>odd frequency</strong> of <code><font face="monospace">3</font></code><font face="monospace">,</font> and <code>&#39;c&#39;</code> has an <strong>even frequency</strong> of <font face="monospace">2</font>.</li>
	<li>The maximum difference is <code>3 - 2 = 1</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
	<li><code>s</code> contains at least one character with an odd frequency and one with an even frequency.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-count-the-frequency-of-each-character">Approach: Count The Frequency Of Each Character</h3>
<h4 id="intuition">Intuition</h4>
<p>We use a hash map to count the number of occurrences of each character in the string <span class="math inline">\(s\)</span>. In each key-value pair of the hash map, the key represents a character, and the value represents the number of times that character appears.</p>
<p>After the statistics are completed, we traverse the values in the hash map to find the largest odd number <span class="math inline">\(\textit{maxOdd}\)</span> and the smallest even number <span class="math inline">\(\textit{minEven}\)</span>. The final answer is <span class="math inline">\(\textit{maxOdd} - \textit{minEven}\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Zz3eC6Sz/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span>, and <span class="math inline">\(|\Sigma|\)</span> the size of its character set. Since <span class="math inline">\(s\)</span> contains only lowercase letters, <span class="math inline">\(|\Sigma| = 26\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(|\Sigma|)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-manhattan-distance-after-k-changes/description" target="_blank" rel="noopener noreferrer">Maximum Manhattan Distance After K Changes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of the characters <code>&#39;N&#39;</code>, <code>&#39;S&#39;</code>, <code>&#39;E&#39;</code>, and <code>&#39;W&#39;</code>, where <code>s[i]</code> indicates movements in an infinite grid:</p>

<ul>
	<li><code>&#39;N&#39;</code> : Move north by 1 unit.</li>
	<li><code>&#39;S&#39;</code> : Move south by 1 unit.</li>
	<li><code>&#39;E&#39;</code> : Move east by 1 unit.</li>
	<li><code>&#39;W&#39;</code> : Move west by 1 unit.</li>
</ul>

<p>Initially, you are at the origin <code>(0, 0)</code>. You can change <strong>at most</strong> <code>k</code> characters to any of the four directions.</p>

<p>Find the <strong>maximum</strong> <strong>Manhattan distance</strong> from the origin that can be achieved <strong>at any time</strong> while performing the movements <strong>in order</strong>.</p>
The <strong>Manhattan Distance</strong> between two cells <code>(x<sub>i</sub>, y<sub>i</sub>)</code> and <code>(x<sub>j</sub>, y<sub>j</sub>)</code> is <code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;NWSE&quot;, k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>Change <code>s[2]</code> from <code>&#39;S&#39;</code> to <code>&#39;N&#39;</code>. The string <code>s</code> becomes <code>&quot;NWNE&quot;</code>.</p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Movement</th>
			<th style="border: 1px solid black;">Position (x, y)</th>
			<th style="border: 1px solid black;">Manhattan Distance</th>
			<th style="border: 1px solid black;">Maximum</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">s[0] == &#39;N&#39;</td>
			<td style="border: 1px solid black;">(0, 1)</td>
			<td style="border: 1px solid black;">0 + 1 = 1</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">s[1] == &#39;W&#39;</td>
			<td style="border: 1px solid black;">(-1, 1)</td>
			<td style="border: 1px solid black;">1 + 1 = 2</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">s[2] == &#39;N&#39;</td>
			<td style="border: 1px solid black;">(-1, 2)</td>
			<td style="border: 1px solid black;">1 + 2 = 3</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">s[3] == &#39;E&#39;</td>
			<td style="border: 1px solid black;">(0, 2)</td>
			<td style="border: 1px solid black;">0 + 2 = 2</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
	</tbody>
</table>

<p>The maximum Manhattan distance from the origin that can be achieved is 3. Hence, 3 is the output.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;NSWWEW&quot;, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>Change <code>s[1]</code> from <code>&#39;S&#39;</code> to <code>&#39;N&#39;</code>, and <code>s[4]</code> from <code>&#39;E&#39;</code> to <code>&#39;W&#39;</code>. The string <code>s</code> becomes <code>&quot;NNWWWW&quot;</code>.</p>

<p>The maximum Manhattan distance from the origin that can be achieved is 6. Hence, 6 is the output.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= k &lt;= s.length</code></li>
	<li><code>s</code> consists of only <code>&#39;N&#39;</code>, <code>&#39;S&#39;</code>, <code>&#39;E&#39;</code>, and <code>&#39;W&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-step-by-step-solution">Approach 1: Step-by-step Solution</h3>
<h4 id="intuition">Intuition</h4>
<p>For any given string, we can calculate the Manhattan distance using the formula:</p>
<p><span class="math display">\[|\textit{sum}_N - \textit{sum}_S| + |\textit{sum}_E - \textit{sum}_W|
\]</span></p>
<p>Here, <span class="math inline">\(\textit{sum}_N\)</span>, <span class="math inline">\(\textit{sum}_S\)</span>, <span class="math inline">\(\textit{sum}_E\)</span>, and <span class="math inline">\(\textit{sum}_W\)</span> respectively represent the number of occurrences of <span class="math inline">\(\text{'N'}\)</span>, <span class="math inline">\(\text{'S'}\)</span>, <span class="math inline">\(\text{'E'}\)</span>, <span class="math inline">\(\text{'W'}\)</span> in the string.</p>
<p>When we try to modify the letters in the string, there are three possible cases:</p>
<ol>
<li>Modifying the letters that appear less frequently (but are not zero) in either the horizontal or vertical direction increases the Manhattan distance by 2.</li>
<li>Modifying the letters that appear more frequently in either direction decreases the Manhattan distance by 2.</li>
<li>If no modifications are made, the Manhattan distance remains unchanged.</li>
</ol>
<p>It's easy to see that only the first case causes an increase in the Manhattan distance. Therefore, we divide the modification process into two steps:</p>
<ul>
<li>
<p>Step 1: Modify the letters with fewer occurrences in the vertical direction. If the number of such letters exceeds <span class="math inline">\(k\)</span>, then modify only <span class="math inline">\(k\)</span> of them, and set the remaining modification count to <span class="math inline">\(t = 0\)</span>. If the number of such letters is less than or equal to <span class="math inline">\(k\)</span>, then modify all of them and set the remaining modification count to <span class="math inline">\(t\)</span>.</p>
</li>
<li>
<p>Step 2: Modify the letters with fewer occurrences in the horizontal direction. If the number of such letters exceeds <span class="math inline">\(t\)</span>, then modify only <span class="math inline">\(t\)</span> of them; otherwise, modify all of them.</p>
</li>
</ul>
<p>Since the question asks for the maximum Manhattan distance from the origin at any moment during the execution of all movement operations in order, these steps must be carried out during a traversal of the string, and we must track and return the maximum value encountered.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/WeLKBMGN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We need to traverse the string only once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>We need only a few additional variables.</p>
</li>
</ul>
<h3 id="approach-2-overall-solution">Approach 2: Overall Solution</h3>
<h4 id="intuition-1">Intuition</h4>
<p>From the analysis in Approach 1, we can observe that the optimal strategy is to modify the less frequent letters in both directions whenever possible.</p>
<p>Therefore, if we treat the less frequent letters in both the vertical and horizontal directions as a single group, we can reason as follows:</p>
<ul>
<li>If the total number of such letters is greater than <span class="math inline">\(k\)</span>, then modifying any <span class="math inline">\(k\)</span> of them increases the Manhattan distance by <span class="math inline">\(2 \times k\)</span>.</li>
<li>If the total number is less than or equal to <span class="math inline">\(k\)</span>, then all the less frequent letters in both directions will be modified, and no further modifications are necessary. In this case, the Manhattan distance becomes equal to the length of the string.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/K74A22c8/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We only need to traverse the string once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>We only need a few additional variables.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-balloons/description" target="_blank" rel="noopener noreferrer">Maximum Number of Balloons</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>text</code>, you want to use the characters of <code>text</code> to form as many instances of the word <strong>&quot;balloon&quot;</strong> as possible.</p>

<p>You can use each character in <code>text</code> <strong>at most once</strong>. Return the maximum number of instances that can be formed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/05/1536_ex1_upd.JPG" style="width: 132px; height: 35px;" /></strong></p>

<pre>
<strong>Input:</strong> text = &quot;nlaebolko&quot;
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/05/1536_ex2_upd.JPG" style="width: 267px; height: 35px;" /></strong></p>

<pre>
<strong>Input:</strong> text = &quot;loonbalxballpoon&quot;
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;leetcode&quot;
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>
	<li><code>text</code> consists of lower case English letters only.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/rearrange-characters-to-make-target-string/description/" target="_blank"> 2287: Rearrange Characters to Make Target String.</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-balls-in-a-box/description" target="_blank" rel="noopener noreferrer">Maximum Number of Balls in a Box</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are working in a ball factory where you have <code>n</code> balls numbered from <code>lowLimit</code> up to <code>highLimit</code> <strong>inclusive</strong> (i.e., <code>n == highLimit - lowLimit + 1</code>), and an infinite number of boxes numbered from <code>1</code> to <code>infinity</code>.</p>

<p>Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball&#39;s number. For example, the ball number <code>321</code> will be put in the box number <code>3 + 2 + 1 = 6</code> and the ball number <code>10</code> will be put in the box number <code>1 + 0 = 1</code>.</p>

<p>Given two integers <code>lowLimit</code> and <code>highLimit</code>, return<em> the number of balls in the box with the most balls.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> lowLimit = 1, highLimit = 10
<strong>Output:</strong> 2
<strong>Explanation:</strong>
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...
Box 1 has the most number of balls with 2 balls.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> lowLimit = 5, highLimit = 15
<strong>Output:</strong> 2
<strong>Explanation:</strong>
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...
Boxes 5 and 6 have the most number of balls with 2 balls in each.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> lowLimit = 19, highLimit = 28
<strong>Output:</strong> 2
<strong>Explanation:</strong>
Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...
Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...
Box 10 has the most number of balls with 2 balls.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= lowLimit &lt;= highLimit &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-operations-to-move-ones-to-the-end/description" target="_blank" rel="noopener noreferrer">Maximum Number of Operations to Move Ones to the End</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <span data-keyword="binary-string">binary string</span> <code>s</code>.</p>

<p>You can perform the following operation on the string <strong>any</strong> number of times:</p>

<ul>
	<li>Choose <strong>any</strong> index <code>i</code> from the string where <code>i + 1 &lt; s.length</code> such that <code>s[i] == &#39;1&#39;</code> and <code>s[i + 1] == &#39;0&#39;</code>.</li>
	<li>Move the character <code>s[i]</code> to the <strong>right</strong> until it reaches the end of the string or another <code>&#39;1&#39;</code>. For example, for <code>s = &quot;010010&quot;</code>, if we choose <code>i = 1</code>, the resulting string will be <code>s = &quot;0<strong><u>001</u></strong>10&quot;</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> number of operations that you can perform.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;1001101&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>We can perform the following operations:</p>

<ul>
	<li>Choose index <code>i = 0</code>. The resulting string is <code>s = &quot;<u><strong>001</strong></u>1101&quot;</code>.</li>
	<li>Choose index <code>i = 4</code>. The resulting string is <code>s = &quot;0011<u><strong>01</strong></u>1&quot;</code>.</li>
	<li>Choose index <code>i = 3</code>. The resulting string is <code>s = &quot;001<strong><u>01</u></strong>11&quot;</code>.</li>
	<li>Choose index <code>i = 2</code>. The resulting string is <code>s = &quot;00<strong><u>01</u></strong>111&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;00111&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-pairs-in-array/description" target="_blank" rel="noopener noreferrer">Maximum Number of Pairs in Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one operation, you may do the following:</p>

<ul>
	<li>Choose <strong>two</strong> integers in <code>nums</code> that are <strong>equal</strong>.</li>
	<li>Remove both integers from <code>nums</code>, forming a <strong>pair</strong>.</li>
</ul>

<p>The operation is done on <code>nums</code> as many times as possible.</p>

<p>Return <em>a <strong>0-indexed</strong> integer array </em><code>answer</code><em> of size </em><code>2</code><em> where </em><code>answer[0]</code><em> is the number of pairs that are formed and </em><code>answer[1]</code><em> is the number of leftover integers in </em><code>nums</code><em> after doing the operation as many times as possible</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,2,1,3,2,2]
<strong>Output:</strong> [3,1]
<strong>Explanation:</strong>
Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].
Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].
Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].
No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1]
<strong>Output:</strong> [1,0]
<strong>Explanation:</strong> Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].
No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> No pairs can be formed, and there is 1 number leftover in nums.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/description" target="_blank" rel="noopener noreferrer">Maximum Number of Ways to Partition an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>. The number of ways to <strong>partition</strong> <code>nums</code> is the number of <code>pivot</code> indices that satisfy both conditions:</p>

<ul>
	<li><code>1 &lt;= pivot &lt; n</code></li>
	<li><code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>
</ul>

<p>You are also given an integer <code>k</code>. You can choose to change the value of <strong>one</strong> element of <code>nums</code> to <code>k</code>, or to leave the array <strong>unchanged</strong>.</p>

<p>Return <em>the <strong>maximum</strong> possible number of ways to <strong>partition</strong> </em><code>nums</code><em> to satisfy both conditions after changing <strong>at most</strong> one element</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,-1,2], k = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> One optimal approach is to change nums[0] to k. The array becomes [<strong><u>3</u></strong>,-1,2].
There is one way to partition the array:
- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,0], k = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> The optimal approach is to leave the array unchanged.
There are two ways to partition the array:
- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.
- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
<strong>Output:</strong> 4
<strong>Explanation:</strong> One optimal approach is to change nums[2] to k. The array becomes [22,4,<u><strong>-33</strong></u>,-20,-15,15,-16,7,19,-10,0,-13,-14].
There are four ways to partition the array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= k, nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-palindromes-after-operations/description" target="_blank" rel="noopener noreferrer">Maximum Palindromes After Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code> having length <code>n</code> and containing <strong>0-indexed</strong> strings.</p>

<p>You are allowed to perform the following operation <strong>any</strong> number of times (<strong>including</strong> <strong>zero</strong>):</p>

<ul>
	<li>Choose integers <code>i</code>, <code>j</code>, <code>x</code>, and <code>y</code> such that <code>0 &lt;= i, j &lt; n</code>, <code>0 &lt;= x &lt; words[i].length</code>, <code>0 &lt;= y &lt; words[j].length</code>, and <strong>swap</strong> the characters <code>words[i][x]</code> and <code>words[j][y]</code>.</li>
</ul>

<p>Return <em>an integer denoting the <strong>maximum</strong> number of <span data-keyword="palindrome-string">palindromes</span> </em><code>words</code><em> can contain, after performing some operations.</em></p>

<p><strong>Note:</strong> <code>i</code> and <code>j</code> may be equal during an operation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abbb&quot;,&quot;ba&quot;,&quot;aa&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, one way to get the maximum number of palindromes is:
Choose i = 0, j = 1, x = 0, y = 0, so we swap words[0][0] and words[1][0]. words becomes [&quot;bbbb&quot;,&quot;aa&quot;,&quot;aa&quot;].
All strings in words are now palindromes.
Hence, the maximum number of palindromes achievable is 3.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abc&quot;,&quot;ab&quot;]
<strong>Output:</strong> 2
<strong>Explanation: </strong>In this example, one way to get the maximum number of palindromes is: 
Choose i = 0, j = 1, x = 1, y = 0, so we swap words[0][1] and words[1][0]. words becomes [&quot;aac&quot;,&quot;bb&quot;].
Choose i = 0, j = 0, x = 1, y = 2, so we swap words[0][1] and words[0][2]. words becomes [&quot;aca&quot;,&quot;bb&quot;].
Both strings are now palindromes.
Hence, the maximum number of palindromes achievable is 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;cd&quot;,&quot;ef&quot;,&quot;a&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, there is no need to perform any operation.
There is one palindrome in words &quot;a&quot;.
It can be shown that it is not possible to get more than one palindrome after any number of operations.
Hence, the answer is 1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-population-year/description" target="_blank" rel="noopener noreferrer">Maximum Population Year</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>logs</code> where each <code>logs[i] = [birth<sub>i</sub>, death<sub>i</sub>]</code> indicates the birth and death years of the <code>i<sup>th</sup></code> person.</p>

<p>The <strong>population</strong> of some year <code>x</code> is the number of people alive during that year. The <code>i<sup>th</sup></code> person is counted in year <code>x</code>&#39;s population if <code>x</code> is in the <strong>inclusive</strong> range <code>[birth<sub>i</sub>, death<sub>i</sub> - 1]</code>. Note that the person is <strong>not</strong> counted in the year that they die.</p>

<p>Return <em>the <strong>earliest</strong> year with the <strong>maximum population</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> logs = [[1993,1999],[2000,2010]]
<strong>Output:</strong> 1993
<strong>Explanation:</strong> The maximum population is 1, and 1993 is the earliest year with this population.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> logs = [[1950,1961],[1960,1971],[1970,1981]]
<strong>Output:</strong> 1960
<strong>Explanation:</strong> 
The maximum population is 2, and it had happened in years 1960 and 1970.
The earlier year between them is 1960.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= logs.length &lt;= 100</code></li>
	<li><code>1950 &lt;= birth<sub>i</sub> &lt; death<sub>i</sub> &lt;= 2050</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-damage-with-spell-casting/description" target="_blank" rel="noopener noreferrer">Maximum Total Damage With Spell Casting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A magician has various spells.</p>

<p>You are given an array <code>power</code>, where each element represents the damage of a spell. Multiple spells can have the same damage value.</p>

<p>It is a known fact that if a magician decides to cast a spell with a damage of <code>power[i]</code>, they <strong>cannot</strong> cast any spell with a damage of <code>power[i] - 2</code>, <code>power[i] - 1</code>, <code>power[i] + 1</code>, or <code>power[i] + 2</code>.</p>

<p>Each spell can be cast <strong>only once</strong>.</p>

<p>Return the <strong>maximum</strong> possible <em>total damage</em> that a magician can cast.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">power = [1,1,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">power = [7,1,6,6]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= power.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= power[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-array-length-after-pair-removals/description" target="_blank" rel="noopener noreferrer">Minimum Array Length After Pair Removals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>num</code> sorted in non-decreasing order.</p>

<p>You can perform the following operation any number of times:</p>

<ul>
	<li>Choose <strong>two</strong> indices, <code>i</code> and <code>j</code>, where <code>nums[i] &lt; nums[j]</code>.</li>
	<li>Then, remove the elements at indices <code>i</code> and <code>j</code> from <code>nums</code>. The remaining elements retain their original order, and the array is re-indexed.</li>
</ul>

<p>Return the <strong>minimum</strong> length of <code>nums</code> after applying the operation zero or more times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/18/tcase1.gif" style="width: 160px; height: 70px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2,2,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/tcase2.gif" style="width: 240px; height: 70px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1000000000,1000000000]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Since both numbers are equal, they cannot be removed.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4,4,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/tcase3.gif" style="width: 210px; height: 70px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-split-an-array/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Split an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>

<p>Split the array into some number of non-empty subarrays. The <strong>cost</strong> of a split is the sum of the <strong>importance value</strong> of each subarray in the split.</p>

<p>Let <code>trimmed(subarray)</code> be the version of the subarray where all numbers which appear only once are removed.</p>

<ul>
	<li>For example, <code>trimmed([3,1,2,4,3,4]) = [3,4,3,4].</code></li>
</ul>

<p>The <strong>importance value</strong> of a subarray is <code>k + trimmed(subarray).length</code>.</p>

<ul>
	<li>For example, if a subarray is <code>[1,2,3,3,3,4,4]</code>, then <font face="monospace">trimmed(</font><code>[1,2,3,3,3,4,4]) = [3,3,3,4,4].</code>The importance value of this subarray will be <code>k + 5</code>.</li>
</ul>

<p>Return <em>the minimum possible cost of a split of </em><code>nums</code>.</p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,1,3,3], k = 2
<strong>Output:</strong> 8
<strong>Explanation:</strong> We split nums to have two subarrays: [1,2], [1,2,1,3,3].
The importance value of [1,2] is 2 + (0) = 2.
The importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.
The cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,1], k = 2
<strong>Output:</strong> 6
<strong>Explanation:</strong> We split nums to have two subarrays: [1,2], [1,2,1].
The importance value of [1,2] is 2 + (0) = 2.
The importance value of [1,2,1] is 2 + (2) = 4.
The cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,1], k = 5
<strong>Output:</strong> 10
<strong>Explanation:</strong> We split nums to have one subarray: [1,2,1,2,1].
The importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.
The cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-deletions-for-at-most-k-distinct-characters/description" target="_blank" rel="noopener noreferrer">Minimum Deletions for At Most K Distinct Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of lowercase English letters, and an integer <code>k</code>.</p>

<p>Your task is to delete some (possibly none) of the characters in the string so that the number of <strong>distinct</strong> characters in the resulting string is <strong>at most</strong> <code>k</code>.</p>

<p>Return the <strong>minimum</strong> number of deletions required to achieve this.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abc&quot;, k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>s</code> has three distinct characters: <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code> and <code>&#39;c&#39;</code>, each with a frequency of 1.</li>
	<li>Since we can have at most <code>k = 2</code> distinct characters, remove all occurrences of any one character from the string.</li>
	<li>For example, removing all occurrences of <code>&#39;c&#39;</code> results in at most <code>k</code> distinct characters. Thus, the answer is 1.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aabb&quot;, k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>s</code> has two distinct characters (<code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>) with frequencies of 2 and 2, respectively.</li>
	<li>Since we can have at most <code>k = 2</code> distinct characters, no deletions are required. Thus, the answer is 0.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;yyyzz&quot;, k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><code>s</code> has two distinct characters (<code>&#39;y&#39;</code> and <code>&#39;z&#39;</code>) with frequencies of 3 and 2, respectively.</li>
	<li>Since we can have at most <code>k = 1</code> distinct character, remove all occurrences of any one character from the string.</li>
	<li>Removing all <code>&#39;z&#39;</code> results in at most <code>k</code> distinct characters. Thus, the answer is 2.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 16</code></li>
	<li><code>1 &lt;= k &lt;= 16</code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>

<p> </p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-deletions-to-make-string-k-special/description" target="_blank" rel="noopener noreferrer">Minimum Deletions to Make String K-Special</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>word</code> and an integer <code>k</code>.</p>

<p>We consider <code>word</code> to be <strong>k-special</strong> if <code>|freq(word[i]) - freq(word[j])| &lt;= k</code> for all indices <code>i</code> and <code>j</code> in the string.</p>

<p>Here, <code>freq(x)</code> denotes the <span data-keyword="frequency-letter">frequency</span> of the character <code>x</code> in <code>word</code>, and <code>|y|</code> denotes the absolute value of <code>y</code>.</p>

<p>Return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code>word</code> <strong><em>k-special</em></strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">word = &quot;aabcaba&quot;, k = 0</span></p>

<p><strong>Output: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">3</span></p>

<p><strong>Explanation:</strong> We can make <code>word</code> <code>0</code>-special by deleting <code>2</code> occurrences of <code>&quot;a&quot;</code> and <code>1</code> occurrence of <code>&quot;c&quot;</code>. Therefore, <code>word</code> becomes equal to <code>&quot;baba&quot;</code> where <code>freq(&#39;a&#39;) == freq(&#39;b&#39;) == 2</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">word = &quot;dabdcbdcdcd&quot;, k = 2</span></p>

<p><strong>Output: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">2</span></p>

<p><strong>Explanation:</strong> We can make <code>word</code> <code>2</code>-special by deleting <code>1</code> occurrence of <code>&quot;a&quot;</code> and <code>1</code> occurrence of <code>&quot;d&quot;</code>. Therefore, <code>word</code> becomes equal to &quot;bdcbdcdcd&quot; where <code>freq(&#39;b&#39;) == 2</code>, <code>freq(&#39;c&#39;) == 3</code>, and <code>freq(&#39;d&#39;) == 4</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">word = &quot;aaabaaa&quot;, k = 2</span></p>

<p><strong>Output: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">1</span></p>

<p><strong>Explanation:</strong> We can make <code>word</code> <code>2</code>-special by deleting <code>1</code> occurrence of <code>&quot;b&quot;</code>. Therefore, <code>word</code> becomes equal to <code>&quot;aaaaaa&quot;</code> where each letter&#39;s frequency is now uniformly <code>6</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-hash-table--enumeration">Approach: Hash Table + Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>The task requires us to delete certain characters from the given string so that the difference in the frequency of any two types of characters does not exceed <span class="math inline">\(k\)</span>.</p>
<p>To do this, we first use a hash table to count the number of occurrences of each character, where <span class="math inline">\(\textit{cnt}[c]\)</span> represents the number of times the character <span class="math inline">\(c\)</span> appears. Since there are only <span class="math inline">\(26\)</span> character types, we can enumerate one of them as the &quot;character with the lowest frequency after the deletion operation&quot; and set it as <span class="math inline">\(c\)</span>. Then, all characters with frequencies less than <span class="math inline">\(\textit{cnt}[c]\)</span> will be entirely deleted, and all characters with frequencies greater than <span class="math inline">\(\textit{cnt}[c] + k\)</span> will be reduced to exactly <span class="math inline">\(\textit{cnt}[c] + k\)</span> instances.</p>
<p>Among all such enumeration schemes, we select the one that results in the smallest total number of deletions.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HDoKtrdr/shared">code</a></p>
<h4 id="complexity-analysis">Complexity analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(\textit{word}\)</span>, and let <span class="math inline">\(C\)</span> be the size of the character set, which is <span class="math inline">\(26\)</span> in this case.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + C^2)\)</span>.</p>
<p>We enumerate each character and calculate the number of deleted characters.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(C)\)</span>.</p>
<p>The space complexity when using a hash table is <span class="math inline">\(O(C)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-increment-to-make-array-unique/description" target="_blank" rel="noopener noreferrer">Minimum Increment to Make Array Unique</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. In one move, you can pick an index <code>i</code> where <code>0 &lt;= i &lt; nums.length</code> and increment <code>nums[i]</code> by <code>1</code>.</p>

<p>Return <em>the minimum number of moves to make every value in </em><code>nums</code><em> <strong>unique</strong></em>.</p>

<p>The test cases are generated so that the answer fits in a 32-bit integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> After 1 move, the array could be [1, 2, 3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1,2,1,7]
<strong>Output:</strong> 6
<strong>Explanation:</strong> After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
It can be shown that it is impossible for the array to have all unique values with 5 or less moves.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting">Approach 1: Sorting</h3>
<h4 id="intuition">Intuition</h4>
<p>Our first strategy to make every element in the array unique is to identify the duplicates, which we can do more efficiently by sorting the array. If an element is a duplicate of the one before it, we increment it just enough to make it larger. The total number of increments will be the minimum number of moves needed to make each character unique.</p>
<p>The following slideshow demonstrates this process.</p>
<p>!?!../Documents/945/slideshow.json:1242,922!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a variable <code>minIncrements</code> to store the total number of increments needed.</li>
<li>Sort <code>nums</code>.</li>
<li>Iterate through <code>nums</code> starting from the second element to the last. For each element:
<ul>
<li>If the current element is less than or equal to the previous element:
<ul>
<li>Set <code>increment</code> to the difference between the previous and the current element, plus one.</li>
<li>Add <code>increment</code> to <code>minIncrements</code>.</li>
<li>Update the current element to be one more than the previous element.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>minIncrements</code>, which holds the minimum number of increments.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/nBqMWNrX/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>Sorting the array requires <span class="math inline">\(O(n \cdot \log n)\)</span> time and a single traversal over the entire array takes <span class="math inline">\(O(n)\)</span> time. This leads to an overall time complexity of <span class="math inline">\(O(n \cdot \log n) + O(n)\)</span>, which simplifies to a <span class="math inline">\(O(n \cdot \log n)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span></p>
<p>Sorting arrays in place requires some additional space. The space complexity of sorting algorithms varies depending on the programming language being used:</p>
<ul>
<li>Python's sort method employs the Tim Sort algorithm, which is a combination of Merge Sort and Insertion Sort. This algorithm has a space complexity of O(n).</li>
<li>In C++, the sort() function is a hybrid implementation that incorporates Quick Sort, Heap Sort, and Insertion Sort. Its worst-case space complexity is O(log n).</li>
<li>Java's Arrays.sort() method uses a variation of the Quick Sort algorithm. When sorting two arrays, it has a space complexity of O(log n).</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-counting">Approach 2: Counting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Another way to track duplicates is to use an array called <code>frequencyCount</code>. In this array, each index represents a unique value from our given array, <code>nums</code>, and the value at each index represents the count of occurrences of that value in <code>nums</code>.</p>
<p>For example: if <code>3</code> appears in <code>nums</code> twice, <code>frequencyCount[3]</code> would equal <code>2</code>.</p>
<pre><code>nums = [1,3,3,5,5]
frequencyCount = [0, 1, 0, 2, 0, 2]
</code></pre>
<p>We know <code>nums</code> contains all unique values when none of the values in <code>frequencyCount</code> is greater than <code>1</code>.</p>
<p>Once we've created the <code>frequencyCount</code> array from <code>nums</code>, we can iterate through it and simulate the process used in Approach 1 to increment each duplicate value until all values become unique.</p>
<p>So elements with a count of 1 or less will remain unchanged. Upon encountering a duplicate, we'll calculate the surplus of elements with that value, carry that count to the next index, and set the current index value to <code>1</code>.</p>
<p>We'll keep a running count for the number that we carry over to the next index; that equals how many moves it will take to make each value of <code>nums</code> unique.</p>
<p>We want to initialize <code>frequencyCount</code> with the largest possible range that could be needed to solve the problem. How do we determine this range?</p>
<p>The minimum length of <code>frequencyCount</code> would be the largest value in <code>nums</code>, and it must be long enough to hold the new values we get from incrementing any duplicates. Keep in mind that the maximum number of duplicates that we could possibly have is equal to the length of <code>nums</code>.</p>
<p>In problems like this, we can determine the longest possible length needed by considering a worst-case scenario. For instance, take the edge case where <code>nums = [4, 4, 4, 4, 4]</code>.</p>
<p>The <code>frequencyCount</code> array for this would be:</p>
<pre><code>frequencyCount = [0, 0, 0, 0, 5]
</code></pre>
<p>If we make every element unique, the <code>frequencyCount</code> array transforms to:</p>
<pre><code>frequencyCount = [0, 0, 0, 0, 1, 1, 1, 1, 1]
</code></pre>
<p>As you can observe, the size of the <code>frequencyCount</code> array is 9, which equals the length of the original <code>nums</code>(5) array plus the largest value found in <code>nums</code>(4).</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize variables:
<ul>
<li><code>n</code> as the length of <code>nums</code>.</li>
<li><code>max</code> to store the maximum value in <code>nums</code>.</li>
<li><code>minIncrements</code> to store the total number of increments needed.</li>
</ul>
</li>
<li>Find the maximum value in <code>nums</code>.</li>
<li>Create an array <code>frequencyCount</code> to store the frequency of each element.</li>
<li>Loop over <code>nums</code> and populate <code>frequencyCount</code>.</li>
<li>Loop over the <code>frequencyCount</code> array. For each element:
<ul>
<li>If the frequency is less than or equal to one, continue with the next iteration.</li>
<li>Add the duplicates to the frequency of the next element.</li>
<li>Set the frequency of the current element to one.</li>
<li>Update <code>minIncrements</code> to account for the movement of the duplicates.</li>
</ul>
</li>
<li>Return <code>minIncrements</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/XhiwKJTT/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums</code> and <span class="math inline">\(max\)</span> be the maximum element in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n+max)\)</span></p>
<p>The algorithm initially iterates over <code>nums</code> twice, each iteration taking <span class="math inline">\(O(n)\)</span> time. To find the number of increments, it then loops over the <code>frequencyCount</code> array, which has a time complexity of <span class="math inline">\(O(n + \text{max})\)</span>. Thus, the total time complexity is <span class="math inline">\(2 \cdot O(n) + O(n + \text{max})\)</span>, simplifying to <span class="math inline">\(O(n + \text{max})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n+max)\)</span></p>
<p>The only additional space used by the algorithm is the <code>frequencyCount</code> array, which has a size of <span class="math inline">\(n + \text{max}\)</span>. Therefore, the space complexity is <span class="math inline">\(O(n + \text{max})\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-length-of-anagram-concatenation/description" target="_blank" rel="noopener noreferrer">Minimum Length of Anagram Concatenation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>, which is known to be a concatenation of <strong>anagrams</strong> of some string <code>t</code>.</p>

<p>Return the <strong>minimum</strong> possible length of the string <code>t</code>.</p>

<p>An <strong>anagram</strong> is formed by rearranging the letters of a string. For example, &quot;aab&quot;, &quot;aba&quot;, and, &quot;baa&quot; are anagrams of &quot;aab&quot;.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>One possible string <code>t</code> could be <code>&quot;ba&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;cdef&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>One possible string <code>t</code> could be <code>&quot;cdef&quot;</code>, notice that <code>t</code> can be equal to <code>s</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcbcacabbaccba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consist only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-length-of-string-after-operations/description" target="_blank" rel="noopener noreferrer">Minimum Length of String After Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>.</p>

<p>You can perform the following process on <code>s</code> <strong>any</strong> number of times:</p>

<ul>
	<li>Choose an index <code>i</code> in the string such that there is <strong>at least</strong> one character to the left of index <code>i</code> that is equal to <code>s[i]</code>, and <strong>at least</strong> one character to the right that is also equal to <code>s[i]</code>.</li>
	<li>Delete the <strong>closest</strong> occurrence of <code>s[i]</code> located to the <strong>left</strong> of <code>i</code>.</li>
	<li>Delete the <strong>closest</strong> occurrence of <code>s[i]</code> located to the <strong>right</strong> of <code>i</code>.</li>
</ul>

<p>Return the <strong>minimum</strong> length of the final string <code>s</code> that you can achieve.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abaacbcbb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong><br />
We do the following operations:</p>

<ul>
	<li>Choose index 2, then remove the characters at indices 0 and 3. The resulting string is <code>s = &quot;bacbcbb&quot;</code>.</li>
	<li>Choose index 3, then remove the characters at indices 0 and 5. The resulting string is <code>s = &quot;acbcb&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong><br />
We cannot perform any operations, so we return the length of the original string.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code>. The goal is to repeatedly perform the following operation until it is no longer possible:</p>
<ol>
<li>Choose an index <code>i</code> such that:
<ul>
<li>There is at least one character equal to <code>s[i]</code> to its left.</li>
<li>There is at least one character equal to <code>s[i]</code> to its right.</li>
</ul>
</li>
<li>Once such an index is found, the following characters are removed:
<ul>
<li>The closest matching character to the left of index <code>i</code>.</li>
<li>The closest matching character to the right of index <code>i</code>.</li>
</ul>
</li>
</ol>
<p>We need to find the smallest possible length of the string after applying this operation repeatedly.</p>
<hr />
<h3 id="approach-1-using-hash-map">Approach 1: Using Hash Map</h3>
<h4 id="intuition">Intuition</h4>
<p>To approach this problem, we need to consider how often each character appears in the string. The goal is to figure out how many characters need to be removed to minimize the string, based on how many times each character occurs:</p>
<ul>
<li>If a character appears an odd number of times, we can keep exactly one instance of it, and remove the rest.</li>
<li>If a character appears an even number of times, we can keep two instances of it—one on the left side and one on the right side, ensuring a valid operation.</li>
</ul>
<p>For example, let's consider the case where we have 5 <code>'a'</code> characters. Since 5 is odd, we'll end up with exactly one <code>'a'</code>. We can remove the first and third <code>'a'</code> characters because they are closest to the second <code>'a'</code>. After that, we are left with three <code>'a'</code> characters, and we repeat the process of removing pairs. In the end, only one <code>'a'</code> remains. This is because each pair cancels out, leaving the extra character.</p>
<p>Now, let's look at the case with 4 <code>'a'</code> characters. Since 4 is even, we first remove the first and third <code>'a'</code> characters, which are closest to the second <code>'a'</code>. We're left with 2 <code>'a'</code> characters, but for comparisons, we need three characters: one as the reference pivot and two indices, one on the left and one on the right, to remove. So, we stop here in the even case.</p>
<p>The entire intuition can be summarized with the help of the image below.</p>
<p><img src="../Figures/3223/odd_even_cancellation.png" alt="odd_even_cancellation" /></p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Count the frequency of each character in the string:</p>
<ul>
<li>Initialize a frequency map (<code>charFrequencyMap</code>).</li>
<li>For each character in the string <code>s</code>, increment its frequency in the map.</li>
</ul>
</li>
<li>
<p>Calculate the number of characters to delete:</p>
<ul>
<li>Initialize <code>deleteCount</code> to 0.</li>
<li>For each character's frequency in the map:
<ul>
<li>If the frequency is odd, add <code>frequency - 1</code> to <code>deleteCount</code> (remove all but one).</li>
<li>If the frequency is even, add <code>frequency - 2</code> to <code>deleteCount</code> (remove all but two).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the smallest length of the string after deletions:</p>
<ul>
<li>Subtract <code>deleteCount</code> from the original string length.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/RfodwSkT/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code>, and let <code>k</code> be the size of the character set.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates over each character in the string <code>s</code>, which takes <span class="math inline">\(O(n)\)</span> time. This is because inserting or updating elements in an map has an average time complexity of <span class="math inline">\(O(1)\)</span> per operation. The second loop iterates over the <code>charFrequencyMap</code>, which has at most <span class="math inline">\(k\)</span> unique characters. This loop takes <span class="math inline">\(O(k)\)</span> time. Since <span class="math inline">\(k\)</span> is typically much smaller than <span class="math inline">\(n\)</span> (e.g., <span class="math inline">\(k = 26\)</span> for lowercase letters), the overall time complexity is dominated by the first loop, resulting in <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(k)\)</span></p>
<p>The space used by the <code>charFrequencyMap</code> depends on the size of the character set <span class="math inline">\(k\)</span>. In our case, <span class="math inline">\(k\)</span> is fixed (e.g., 26 for lowercase letters), so the space complexity is <span class="math inline">\(O(1)\)</span>. Alternatively, it can also be expressed as <span class="math inline">\(O(k)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-frequency-array">Approach 2: Using Frequency Array</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a hash map to count how often each character appears in the string. Hash maps are flexible and can handle cases where the characters are not limited to a specific set. However, they come with some downsides.</p>
<p>A hash map uses a dynamic data structure, which requires extra memory to store keys and values. This leads to higher space usage compared to an array. Additionally, the process of hashing (calculating a unique code for each character) takes time. While hash map operations like insertion and lookup are generally fast (on average, they take <span class="math inline">\(O(1)\)</span> time), they can sometimes be slower due to <em>hashing collisions</em> (when two keys produce the same hash) and memory allocation.</p>
<p>In this problem, we only need to deal with lowercase English letters (<code>'a'</code> to <code>'z'</code>). Since there are only 26 possible characters, we can use a <em>fixed-size array</em> of size 26 to count character frequencies.</p>
<p>To achieve this, we use a simple hashing operation to map each character to a position in a frequency array. In ASCII, each lowercase letter can be represented as the value of <code>'a'</code> plus its index in the alphabet. By subtracting the ASCII value of <code>'a'</code> from any character, we get a unique integer between 0 and 25, which corresponds to its position in the frequency array.</p>
<p>This approach is more efficient for this specific case because of two reasons.</p>
<ol>
<li>Better Runtime: When we access an element in an array, it’s always a constant time operation. On the other hand, hash maps are <span class="math inline">\(O(1)\)</span> on average, but they can occasionally slow down because of the hashing process or when collisions happen.</li>
<li>Space Efficiency: An array of size 26 uses a fixed, small chunk of memory. Unlike hash maps, arrays don’t need additional structures like hash buckets or key-value pairs, so they’re much more memory-efficient.</li>
</ol>
<p>Apart from using this array, the key idea remains the same as the previous approach:</p>
<ul>
<li>If a character appears an odd number of times, we keep one instance.</li>
<li>If a character appears an even number of times, we keep two instances.</li>
</ul>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a <code>charFrequency</code> array of size <code>26</code> to store the count of occurrences for each character in the string.</p>
</li>
<li>
<p>Initialize <code>totalLength</code> to 0, which will hold the final result.</p>
</li>
<li>
<p>Iterate through each character <code>currentChar</code> in string <code>s</code>:</p>
<ul>
<li>Increment the corresponding index (<code>currentChar</code> - <code>'a'</code>) in <code>charFrequency</code> based on <code>currentChar</code>.</li>
</ul>
</li>
<li>
<p>Calculate the total length of characters that will remain:</p>
<ul>
<li>Iterate through each <code>frequency</code> in <code>charFrequency</code>:
<ul>
<li>If <code>frequency</code> is 0, skip the character (it doesn't appear in the string).</li>
<li>If <code>frequency</code> is even, add 2 to <code>totalLength</code>.</li>
<li>If <code>frequency</code> is odd, add 1 to <code>totalLength</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>totalLength</code>, the smallest length of the string after deletions.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nsp3q2LR/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code>, and let <code>k</code> be the size of the character set.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates over each character in the string <code>s</code>, which takes <span class="math inline">\(O(n)\)</span> time. The second loop iterates over the <code>charFrequency</code> array, which has a size of <span class="math inline">\(k\)</span>. This loop runs in <span class="math inline">\(O(k)\)</span> time. Since <span class="math inline">\(k\)</span> is typically a constant, the second loop is often considered <span class="math inline">\(O(1)\)</span>. However, in the general case, the time complexity is <span class="math inline">\(O(n + k)\)</span>. For most practical purposes, <span class="math inline">\(k\)</span> is small compared to <span class="math inline">\(n\)</span>, so the overall time complexity is dominated by <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(k)\)</span></p>
<p>The space used by the <code>charFrequency</code> depends on the size of the character set <span class="math inline">\(k\)</span>. In our case, <span class="math inline">\(k\)</span> is fixed (e.g., 26 for lowercase letters), so the space complexity is <span class="math inline">\(O(1)\)</span>. Alternatively, it can also be expressed as <span class="math inline">\(O(k)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-bitwise">Approach 3: Using Bitwise</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The ability to remove characters hinges on their occurrences. Specifically, characters that appear an even number of times can be fully removed by pairing them up, while characters with an odd number of occurrences will leave one unpaired character behind.</p>
<p>This means that the specific frequency of each character is irrelevant as long as we know if it contributes an odd or even number of times. Thus, we can collapse the space required to track character occurrences from a full array of 26 integers (one for each letter) to just a few integers.</p>
<p>To achieve this, we use three integers:</p>
<ol>
<li><code>present</code>: This keeps track of which letters are present in the string, using bits to represent each letter. If a letter is present, the corresponding bit is set to <code>1</code>.</li>
<li><code>parity</code>: This tracks the parity (odd or even occurrences) of each character in the string. If a character has an odd number of occurrences, its corresponding bit is set to <code>1</code>.</li>
<li><code>placevalue</code>: This variable is used to isolate the position of each letter in the bit representation.</li>
</ol>
<p>As we iterate through the string, for each character, we update <code>present</code> by setting the corresponding bit to indicate its presence. We also update <code>parity</code> by toggling the bit to track whether the character's occurrences are odd or even.</p>
<p>After processing the string, <code>present</code> shows which characters are in the string, and <code>parity</code> shows whether their occurrences are odd or even. To determine the remaining characters after pairing, we examine both masks. If a character has an odd number of occurrences, it contributes to the final string length, while characters with even occurrences can be fully removed. This continues until all characters have been checked.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>present</code> to <code>0</code>, <code>parity</code> to <code>0</code>, and <code>placevalue</code> for bit manipulation.</p>
</li>
<li>
<p>Iterate through the string <code>s</code>:</p>
<ul>
<li>For each character, calculate the bit position corresponding to the character by shifting <code>1</code> to the left by <code>(s[k] - 'a')</code>.</li>
<li>Set the corresponding bit in the <code>present</code> bitmask using the bitwise OR operation (<code>present |= placevalue</code>).</li>
<li>Toggle the corresponding bit in the <code>parity</code> bitmask using the bitwise XOR operation (<code>parity ^= placevalue</code>).</li>
</ul>
</li>
<li>
<p>Initialize <code>totalLength</code> to <code>0</code>, which will store the result.</p>
</li>
<li>
<p>Process the <code>present</code> bitmask to calculate the minimum length:</p>
<ul>
<li>While there are still set bits in <code>present</code>:
<ul>
<li>Clear the least significant bit in <code>present</code> using <code>placevalue = present &amp; (present - 1)</code>.</li>
<li>Check if the corresponding bit in <code>parity</code> is set:
<ul>
<li>If the bit is set in <code>parity</code>, it indicates an odd occurrence of that character, so add <code>1</code> to <code>totalLength</code>.</li>
<li>Otherwise, add <code>2</code> to <code>totalLength</code>.</li>
</ul>
</li>
<li>Update <code>present</code> to remove the least significant bit (using <code>present = placevalue</code>).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>totalLength</code>, the smallest length of the string after deletions.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/8tDNEWC2/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code>.</p>
<ul>
<li>
<p>Time complexit: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates through the string <code>s</code> once, performing bitwise operations for each character. Since there are <span class="math inline">\(n\)</span> characters, this loop runs in <span class="math inline">\(O(n)\)</span> time.</p>
<p>The second loop processes the <code>present</code> bitmask. The number of iterations in this loop is equal to the number of unique characters in the string, which is at most 26 (since there are 26 lowercase English letters). Therefore, this loop runs in <span class="math inline">\(O(1)\)</span> time.</p>
<p>Thus, the overall time complexity is dominated by the first loop, which is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexi: <span class="math inline">\(O(1)\)</span></p>
<p>The space used by the variables <code>present</code>, <code>parity</code>, <code>placeValue</code>, and <code>count</code> is constant, as they are simple integers. The algorithm does not use any additional data structures that grow with the input size.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-frogs-croaking/description" target="_blank" rel="noopener noreferrer">Minimum Number of Frogs Croaking</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the string <code>croakOfFrogs</code>, which represents a combination of the string <code>&quot;croak&quot;</code> from different frogs, that is, multiple frogs can croak at the same time, so multiple <code>&quot;croak&quot;</code> are mixed.</p>

<p><em>Return the minimum number of </em>different<em> frogs to finish all the croaks in the given string.</em></p>

<p>A valid <code>&quot;croak&quot;</code> means a frog is printing five letters <code>&#39;c&#39;</code>, <code>&#39;r&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;a&#39;</code>, and <code>&#39;k&#39;</code> <strong>sequentially</strong>. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid <code>&quot;croak&quot;</code> return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> croakOfFrogs = &quot;croakcroak&quot;
<strong>Output:</strong> 1 
<strong>Explanation:</strong> One frog yelling &quot;croak<strong>&quot;</strong> twice.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> croakOfFrogs = &quot;crcoakroak&quot;
<strong>Output:</strong> 2 
<strong>Explanation:</strong> The minimum number of frogs is two. 
The first frog could yell &quot;<strong>cr</strong>c<strong>oak</strong>roak&quot;.
The second frog could yell later &quot;cr<strong>c</strong>oak<strong>roak</strong>&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> croakOfFrogs = &quot;croakcrook&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> The given string is an invalid combination of &quot;croak<strong>&quot;</strong> from different frogs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= croakOfFrogs.length &lt;= 10<sup>5</sup></code></li>
	<li><code>croakOfFrogs</code> is either <code>&#39;c&#39;</code>, <code>&#39;r&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;a&#39;</code>, or <code>&#39;k&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Make Array Empty</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> consisting of positive integers.</p>

<p>There are two types of operations that you can apply on the array <strong>any</strong> number of times:</p>

<ul>
	<li>Choose <strong>two</strong> elements with <strong>equal</strong> values and <strong>delete</strong> them from the array.</li>
	<li>Choose <strong>three</strong> elements with <strong>equal</strong> values and <strong>delete</strong> them from the array.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations required to make the array empty, or </em><code>-1</code><em> if it is not possible</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,3,2,2,4,2,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can apply the following operations to make the array empty:
- Apply the first operation on the elements at indices 0 and 3. The resulting array is nums = [3,3,2,4,2,3,4].
- Apply the first operation on the elements at indices 2 and 4. The resulting array is nums = [3,3,4,3,4].
- Apply the second operation on the elements at indices 0, 1, and 3. The resulting array is nums = [4,4].
- Apply the first operation on the elements at indices 0 and 1. The resulting array is nums = [].
It can be shown that we cannot make the array empty in less than 4 operations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,2,2,3,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to empty the array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/description/" target="_blank">2244: Minimum Rounds to Complete All Tasks.</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>This problem revolves around manipulating a given array of positive integers with two distinct operations: the removal of two elements with equal values or three elements with equal values. The objective is to find the minimum number of operations required to empty the array entirely. If achieving an empty array is not possible, the function should return -1. The challenge lies in strategically applying these operations to minimize their overall count. In essence, the problem serves as a computational exercise, testing one's algorithmic proficiency and logical reasoning in optimizing array manipulation operations.</p>
<h3 id="approach-counting">Approach: Counting</h3>
<h4 id="intuition">Intuition</h4>
<p>The given problem introduces us to an array, <code>nums</code>, composed of positive integers, and presents two distinct operations that can be applied repeatedly: the removal of two elements with equal values or the removal of three elements with equal values. The ultimate objective is to ascertain the minimum number of operations required to empty the array entirely. However, if such a scenario proves impossible, the function is expected to return -1.</p>
<p>Since we can only remove elements that are equal each time, we must find the frequency <code>count</code> of each element. To get the count of each element, we could create a counter <code>counter</code> to tally the occurrences of each unique element in the array. This step is crucial for understanding the composition of the array and determining the frequencies of each element. We can use a variable <code>ans</code> initialized to zero, to serve as the accumulator for the total number of operations required to make the array empty.</p>
<p>The first critical insight arises when considering elements with a count of 1 in the array. We must return <code>-1</code> immediately in such cases, as the removal of elements requires pairs or triplets, and a solitary element cannot satisfy this criterion.</p>
<p>To make sure we empty the array in the minimum number of operations, we need to make sure we are removing the maximum possible elements in each operation. That means we need to remove triplets whenever possible. Triplets get priority over pairs. This is shown in the following slides.</p>
<p>!?!../Documents/2870/Minimum_Number_of_Operations_to_Make_Array_Empty.json:3000,1687!?!</p>
<p>The first conclusion that we can draw is that whenever the count of an element is a <strong>multiple of 3</strong>, it will take us <code>count / 3</code> operations to remove the elements of that kind from the array.</p>
<p>Example: 3, 6, 9, 12,...</p>
<pre><code>* count = 3
    3 - 3 = 0
    operations required = 1
* count = 6
    6 - 3 - 3  = 0
    operations required = 2
* count = 9
    9 - 3 - 3 - 3  = 0
    operations required = 3
* count = 12
    12 - 3 - 3 - 3 - 3  = 0
    operations required = 4
</code></pre>
<p>Now, let's consider the scenario when the count of an element is <strong>one</strong> more than a multiple of 3.</p>
<p>Example: 4, 7, 10, 13,...</p>
<p>In such instances, we can eliminate two pairs, thereby making the count divisible by 3. Following this adjustment, we can proceed to remove the remaining numbers in triplets.</p>
<pre><code>* count = 4
    4 - 2 - 2 = 0 -&gt; eliminate two pairs
    operations required = 2
* count = 7
    7 - 2 - 2 = 3 -&gt; eliminate two pairs
    3 - 3 = 0 -&gt; eliminate remaining triplets
    operations required = 3
* count = 10
    10 - 2 - 2 = 6 -&gt; eliminate two pairs
    6 - 3 - 3 = 0 -&gt; eliminate remaining triplets
    operations required = 4
* count = 13
    13 - 2 - 2 = 9 -&gt; eliminate two pairs
    9 - 3 - 3 - 3 = 0 -&gt; eliminate remaining triplets
    operations required = 5
</code></pre>
<p>Now, let's consider the scenario when the count of an element is <strong>two</strong> more than a multiple of 3.</p>
<p>Example: 5, 8, 11, 14,...</p>
<p>In such instances, we can eliminate one pair, thereby making the count divisible by 3. Following this adjustment, we can proceed to remove the remaining numbers in triplets.</p>
<pre><code>* count = 5
    5 - 2 = 3 -&gt; eliminate one pair
    3 - 3 = 0 -&gt; eliminate remaining triplets
    operations required = 2
* count = 8
    8 - 2 = 6 -&gt; eliminate one pair
    6 - 3 - 3 = 0 -&gt; eliminate remaining triplets
    operations required = 3
* count = 11
    11 - 2 = 9 -&gt; eliminate one pair
    9 - 3 - 3 - 3 = 0 -&gt; eliminate remaining triplets
    operations required = 4
* count = 14
    14 - 2 = 12 -&gt; eliminate one pair
    12 - 3 - 3 - 3 - 3 = 0 -&gt; eliminate remaining triplets
    operations required = 5
</code></pre>
<p>Now, that we have the optimal technique to remove elements from the array. Let's look at the pattern that has formed.</p>
<table>
<thead>
<tr>
<th>Count</th>
<th>Operations required to remove elements</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>return -1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>4</td>
</tr>
<tr>
<td>11</td>
<td>4</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>From the information presented in this table, we can deduce that the number of operations needed to remove a total of <code>count</code> elements of a given kind is represented by the expression <code>ceil(count / 3)</code>, where the <code>ceil</code> method rounds up the decimal result of <code>count / 3</code>. Except in the scenario where the count of the element is 1, making it impossible to remove elements of that kind, in which case we should return -1.</p>
<p>Once we have determined the number of operations needed to remove each type of element, we can aggregate these values and return the result as <code>ans</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a hashmap object named <code>counter</code> to count the occurrences of each element in the given array <code>nums</code>. Initialize a variable <code>ans = 0</code> to keep track of the minimum number of operations required.</li>
<li>For each value <code>c</code> in the counter's values:
<ul>
<li>Check if <code>c</code> is equal to 1. If yes, return -1, as it is not possible to perform the required operations on a single element.</li>
<li>Else increment the answer <code>ans</code> by the ceiling division of <code>c</code> by 3.</li>
</ul>
</li>
<li>After iterating through all counts in the Counter, return the final value of <code>ans</code> as the minimum number of operations required to empty the array.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/BtBQFcD5/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of elements in nums.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>. Iterating over <code>nums</code> to count each number will incur a time complexity of <span class="math inline">\(O(N)\)</span>. The subsequent loop iterating over <code>counter</code> will also incur a time complexity of <span class="math inline">\(O(N)\)</span> since there could be at most <span class="math inline">\(N\)</span> unique elements in the hash map.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>. <code>counter</code> will incur a space complexity of <span class="math inline">\(O(N)\)</span> since there could be at most <span class="math inline">\(N\)</span> elements stored in the hash map in the worst-case scenario.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-make-word-k-periodic/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Make Word K-Periodic</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>word</code> of size <code>n</code>, and an integer <code>k</code> such that <code>k</code> divides <code>n</code>.</p>

<p>In one operation, you can pick any two indices <code>i</code> and <code>j</code>, that are divisible by <code>k</code>, then replace the <span data-keyword="substring">substring</span> of length <code>k</code> starting at <code>i</code> with the substring of length <code>k</code> starting at <code>j</code>. That is, replace the substring <code>word[i..i + k - 1]</code> with the substring <code>word[j..j + k - 1]</code>.<!-- notionvc: 49ac84f7-0724-452a-ab43-0c5e53f1db33 --></p>

<p>Return <em>the <strong>minimum</strong> number of operations required to make</em> <code>word</code> <em><strong>k-periodic</strong></em>.</p>

<p>We say that <code>word</code> is <strong>k-periodic</strong> if there is some string <code>s</code> of length <code>k</code> such that <code>word</code> can be obtained by concatenating <code>s</code> an arbitrary number of times. For example, if <code>word == &ldquo;ababab&rdquo;</code>, then <code>word</code> is 2-periodic for <code>s = &quot;ab&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">word = &quot;leetcodeleet&quot;, k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
font-family: Menlo,sans-serif;
font-size: 0.85rem;
">1</span></p>

<p><strong>Explanation:</strong></p>

<p>We can obtain a 4-periodic string by picking i = 4 and j = 0. After this operation, word becomes equal to &quot;leetleetleet&quot;.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">word = &quot;</span>leetcoleet<span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">&quot;, k = 2</span></p>

<p><strong>Output:</strong> 3</p>

<p><strong>Explanation:</strong></p>

<p>We can obtain a 2-periodic string by applying the operations in the table below.</p>

<table border="1" bordercolor="#ccc" cellpadding="5" cellspacing="0" height="146" style="border-collapse:collapse; text-align: center; vertical-align: middle;">
	<tbody>
		<tr>
			<th>i</th>
			<th>j</th>
			<th>word</th>
		</tr>
		<tr>
			<td style="padding: 5px 15px;">0</td>
			<td style="padding: 5px 15px;">2</td>
			<td style="padding: 5px 15px;">etetcoleet</td>
		</tr>
		<tr>
			<td style="padding: 5px 15px;">4</td>
			<td style="padding: 5px 15px;">0</td>
			<td style="padding: 5px 15px;">etetetleet</td>
		</tr>
		<tr>
			<td style="padding: 5px 15px;">6</td>
			<td style="padding: 5px 15px;">0</td>
			<td style="padding: 5px 15px;">etetetetet</td>
		</tr>
	</tbody>
</table>
</div>

<div id="gtx-trans" style="position: absolute; left: 107px; top: 238.5px;">
<div class="gtx-trans-icon">&nbsp;</div>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == word.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= word.length</code></li>
	<li><code>k</code> divides <code>word.length</code>.</li>
	<li><code>word</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-pushes-to-type-word-ii/description" target="_blank" rel="noopener noreferrer">Minimum Number of Pushes to Type Word II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>word</code> containing lowercase English letters.</p>

<p>Telephone keypads have keys mapped with <strong>distinct</strong> collections of lowercase English letters, which can be used to form words by pushing them. For example, the key <code>2</code> is mapped with <code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>, we need to push the key one time to type <code>&quot;a&quot;</code>, two times to type <code>&quot;b&quot;</code>, and three times to type <code>&quot;c&quot;</code> <em>.</em></p>

<p>It is allowed to remap the keys numbered <code>2</code> to <code>9</code> to <strong>distinct</strong> collections of letters. The keys can be remapped to <strong>any</strong> amount of letters, but each letter <strong>must</strong> be mapped to <strong>exactly</strong> one key. You need to find the <strong>minimum</strong> number of times the keys will be pushed to type the string <code>word</code>.</p>

<p>Return <em>the <strong>minimum</strong> number of pushes needed to type </em><code>word</code> <em>after remapping the keys</em>.</p>

<p>An example mapping of letters to keys on a telephone keypad is given below. Note that <code>1</code>, <code>*</code>, <code>#</code>, and <code>0</code> do <strong>not</strong> map to any letters.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png" style="width: 329px; height: 313px;" />
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png" style="width: 329px; height: 313px;" />
<pre>
<strong>Input:</strong> word = &quot;abcde&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> The remapped keypad given in the image provides the minimum cost.
&quot;a&quot; -&gt; one push on key 2
&quot;b&quot; -&gt; one push on key 3
&quot;c&quot; -&gt; one push on key 4
&quot;d&quot; -&gt; one push on key 5
&quot;e&quot; -&gt; one push on key 6
Total cost is 1 + 1 + 1 + 1 + 1 = 5.
It can be shown that no other mapping can provide a lower cost.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/20/edited.png" style="width: 329px; height: 313px;" />
<pre>
<strong>Input:</strong> word = &quot;xyzxyzxyzxyz&quot;
<strong>Output:</strong> 12
<strong>Explanation:</strong> The remapped keypad given in the image provides the minimum cost.
&quot;x&quot; -&gt; one push on key 2
&quot;y&quot; -&gt; one push on key 3
&quot;z&quot; -&gt; one push on key 4
Total cost is 1 * 4 + 1 * 4 + 1 * 4 = 12
It can be shown that no other mapping can provide a lower cost.
Note that the key 9 is not mapped to any letter: it is not necessary to map letters to every key, but to map all the letters.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/27/keypadv2.png" style="width: 329px; height: 313px;" />
<pre>
<strong>Input:</strong> word = &quot;aabbccddeeffgghhiiiiii&quot;
<strong>Output:</strong> 24
<strong>Explanation:</strong> The remapped keypad given in the image provides the minimum cost.
&quot;a&quot; -&gt; one push on key 2
&quot;b&quot; -&gt; one push on key 3
&quot;c&quot; -&gt; one push on key 4
&quot;d&quot; -&gt; one push on key 5
&quot;e&quot; -&gt; one push on key 6
&quot;f&quot; -&gt; one push on key 7
&quot;g&quot; -&gt; one push on key 8
&quot;h&quot; -&gt; two pushes on key 9
&quot;i&quot; -&gt; one push on key 9
Total cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24.
It can be shown that no other mapping can provide a lower cost.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>
	<li><code>word</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The challenge is inspired by traditional telephone keypads where each number key (2-9) corresponds to a group of letters. For instance, pressing the key <code>'2'</code> once corresponds to the letter <code>'a'</code>, pressing it twice corresponds to the letter <code>'b'</code>, and pressing it three times corresponds to the letter <code>'c'</code>.</p>
<p>This problem offers a twist: we can remap the letters to the keys as we see fit. Each letter must be assigned to exactly one key, but a key can have any number of letters (including no letters), and the sets of letters on each key must be distinct. The objective is to remap these letters so that typing the given string <code>word</code> requires the fewest key presses.</p>
<p>Example: For the word &quot;abc&quot;:</p>
<ul>
<li>If mapped traditionally (letters <code>a</code>, <code>b</code>, and <code>c</code> are mapped to key <code>2</code>), typing would require 1 + 2 + 3 = 6 presses.</li>
<li>However, an optimal remapping might assign each letter to a different key, resulting in just 1 press per letter, for a total of 3 presses.</li>
</ul>
<hr />
<h3 id="approach-1-greedy-sorting">Approach 1: Greedy Sorting</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve this problem, we use a greedy algorithm approach combined with sorting. Keeping in mind that we have 8 keys available (2-9), the primary intuition is to remap the keys so the 8 most frequently occurring characters in the given string are assigned as first key presses, the next most common 8 characters as second key presses, and so on.</p>
<p>We begin by counting the occurrences of each letter using a counter, which provides the frequency of each distinct letter. Next, we sort these frequencies in descending order.</p>
<p>Since there are 8 possible key assignments, we'll divide the frequency rank by 8 to group it as a first, second, or third key press. Note that dividing the frequencies by 8 will result in 0, 1, and 2. We must add 1 to this group number to get the actual number of presses required for letters in that group. Multiplying this by the number of times the character appears in the given string yields the total number of presses for that letter.</p>
<p>Finally, we will sum the total presses required to type the word.</p>
<p>This greedy way, combined with sorting by frequency, ensures that each decision (assignment of letters to keys) is optimal for minimizing key presses.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a frequency vector <code>frequency</code> of size 26 to store the count of each letter in the word.
<ul>
<li>Iterate through each character <code>c</code> in <code>word</code> and increment the count in <code>frequency</code> at the index corresponding to <code>c - 'a'</code>.</li>
</ul>
</li>
<li>Sort the <code>frequency</code> vector in descending order to prioritize letters with higher counts.</li>
<li>Initialize a variable <code>totalPushes</code> to store the total number of key presses required.</li>
<li>Iterate through the sorted <code>frequency</code> vector:
<ul>
<li>If the frequency of a letter is zero, break the loop as there are no more letters to process.</li>
<li>Calculate the number of pushes for each letter based on its position in the sorted list: <code>(i / 8 + 1) * frequency[i]</code>.</li>
<li>Accumulate this value in <code>totalPushes</code>.</li>
</ul>
</li>
<li>Return <code>totalPushes</code> as the minimum number of key presses required to type the word.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/btjgtrfB/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Iterating through the word string to count the frequency of each letter takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Sorting the frequency array, which has a fixed size of 26 (for each letter in the alphabet), takes <span class="math inline">\(O(1)\)</span> because the size of the array is constant.</p>
<p>Iterating through the frequency array to compute the total number of presses is <span class="math inline">\(O(1)\)</span> because the array size is constant.</p>
<p>Overall, the dominant term is <span class="math inline">\(O(n)\)</span> due to the frequency counting step.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Frequency array and sorting takes <span class="math inline">\(O(1)\)</span> space, as it always requires space for 26 integers.</p>
<p>Overall, the space complexity is <span class="math inline">\(O(1)\)</span> because the space used does not depend on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-heap">Approach 2: Using Heap</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Following the initial approach that used sorting and a greedy strategy, we now explore a similar yet refined method.</p>
<p>First, we count the frequency of each character in the word using an unordered map (or dictionary), where each key represents a character, and its value indicates how many times it appears in the word.</p>
<p>Next, we use a priority queue (or max-heap) to efficiently manage these frequencies. The priority queue enables quick retrieval of the character with the highest frequency by giving the most frequent characters the highest priority.</p>
<p>As we process characters from the priority queue, we dynamically assign them to keys based on their frequencies. Specifically, at each iteration, we extract the character with the highest frequency and assign it to the key with the least number of characters assigned.</p>
<p>To facilitate this, we maintain a record of the number of letters assigned to each key press count. This helps us determine the next available key press count for assigning characters. For instance, once a key press count of 1 is fully utilized, we proceed to a key press count of 2, and so on.</p>
<p>We assign the character with the highest frequency to the least costly available key press count, updating our record to reflect this assignment and marking the key press count as occupied. This process continues until all characters are assigned.</p>
<p>Finally, we calculate the total number of key presses required by summing the product of each character’s frequency and its assigned key press count. This gives us the optimal total number of key presses needed to type the word.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Create a frequency map <code>frequencyMap</code> to store the count of each letter in the input string <code>word</code>.</p>
<ul>
<li>Iterate through <code>word</code> and for each character, increment its count in <code>frequencyMap</code>.</li>
</ul>
</li>
<li>
<p>Create a priority queue <code>frequencyQueue</code> to store the frequencies of letters in descending order.</p>
<ul>
<li>Iterate through <code>frequencyMap</code> and push each frequency into <code>frequencyQueue</code>.</li>
</ul>
</li>
<li>
<p>Initialize a variable <code>totalPushes</code> to 0 to keep track of the total number of presses.</p>
</li>
<li>
<p>Initialize an index variable <code>index</code> to 0.</p>
</li>
<li>
<p>Calculate the total number of presses by processing the frequencies in the priority queue.</p>
<ul>
<li>While <code>frequencyQueue</code> is not empty:
<ul>
<li>Add the product of <code>(1 + (index / 8))</code> and the top frequency from <code>frequencyQueue</code> to <code>totalPushes</code>.</li>
<li>Remove the top element from <code>frequencyQueue</code>.</li>
<li>Increment <code>index</code> by 1.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>totalPushes</code> as the minimum number of presses needed.</p>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<blockquote>
<p>Note: As shown in Slide 4, when calculating <code>totalPushes</code>, we multiply by 1. This value represents <code>frequencyQueue.top()</code>, which is 1 in the visual example.</p>
</blockquote>
<p>!?!../Documents/3016/approach2.json:920,440!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/6XujJS6T/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Iterating through the word string to count the frequency of each letter takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Inserting each frequency into the priority queue and extracting the maximum frequency both operate with a time complexity of <span class="math inline">\(O(k \log k)\)</span>, where <code>k</code> represents the number of distinct letters. Each of these operations—insertions, and extractions—is logarithmic due to the heap structure of the priority queue. However, since the number of distinct letters is limited to a maximum of 26 (one for each letter in the alphabet), the size of the priority queue remains constant and thus the time complexity effectively becomes <span class="math inline">\(O(1)\)</span> in practice.</p>
<p>Overall, the dominant term is <span class="math inline">\(O(n)\)</span> due to the frequency counting step.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The frequency map and priority queue take <span class="math inline">\(O(26) = O(1)\)</span> space, as it always requires a fixed space for 26 integers.  </p>
<p>Overall, the space complexity is <span class="math inline">\(O(1)\)</span> because the space used does not depend on the input size.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/description" target="_blank" rel="noopener noreferrer">Minimum Number of Steps to Make Two Strings Anagram</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings of the same length <code>s</code> and <code>t</code>. In one step you can choose <strong>any character</strong> of <code>t</code> and replace it with <strong>another character</strong>.</p>

<p>Return <em>the minimum number of steps</em> to make <code>t</code> an anagram of <code>s</code>.</p>

<p>An <strong>Anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bab&quot;, t = &quot;aba&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> Replace the first &#39;a&#39; in t with b, t = &quot;bba&quot; which is anagram of s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, t = &quot;practice&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> Replace &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; and &#39;c&#39; from t with proper characters to make t anagram of s.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;anagram&quot;, t = &quot;mangaar&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> &quot;anagram&quot; and &quot;mangaar&quot; are anagrams. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s.length == t.length</code></li>
	<li><code>s</code> and <code>t</code> consist of lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-hashmap">Approach: HashMap</h3>
<h4 id="intuition">Intuition</h4>
<p>The two strings <code>s</code> and <code>t</code> have the same length, we need to find the minimum characters that need to be replaced in <code>t</code> to make it an anagram of <code>s</code>. One thing to observe here is that we do not need to touch the instances of a character that are present in both strings. For example, if the two strings are <code>s = ba</code> and <code>t = aa</code>, we do not need to change one of the <code>a</code> characters in both two strings.</p>
<p>The character instance which is in <code>t</code> but not in <code>s</code> can be replaced with a character that is present in <code>s</code>. To find the minimum characters required to make <code>t</code> and <code>s</code> anagrams, we can find the count of characters in <code>t</code> which are not present in <code>s</code>.</p>
<p>To find this, we can record the frequency of each character in both strings <code>s</code> and <code>t</code>, and calculate the frequency difference of each character (<code>freq in t - freq in s</code>). One important thing to note is that this difference can be positive or negative, for example, if <code>s = bba</code> and <code>t = baa</code>, the frequency difference of <code>a</code> is 1 (<code>t</code> has 2 occurrences of <code>a</code> while <code>s</code> has 1, 2 - 1 = 1) and the frequency difference of <code>b</code> is -1 (<code>t</code> has 1 occurrence of <code>b</code> while <code>s</code> has 2, 1 - 2 = -1). However, we only need to focus on the positive value which implies that there are more instances of this character in <code>t</code>, why?</p>
<p>This is because the two values (the sum of the positive and negative differences) are equal in absolute value! The positive value comes from the character in <code>t</code> that needs to be replaced, the negative value comes from the character in <code>s</code> that waits for the corresponding replacement in <code>t</code>.</p>
<p>Since <code>t</code> and <code>s</code> are of equal length, and both remain the same after modifying <code>t</code> to make it an anagram of <code>s</code>, the absolute values of the two positive and negative values must be equal. Therefore, we can either sum only the negative differences or only the positive differences, and the result is the same for both.</p>
<p>One way to find the frequencies of characters in both strings is to use two different maps and then find the difference. Instead of storing the frequencies for both strings separately and then calculating the difference, we can simply add the frequencies for string <code>t</code>, and subtract the frequencies for string <code>s</code> on the fly. This way we will only have to keep one map to store the final difference in frequencies. We can then add up all the positive values and return the sum.</p>
<p><img src="../Figures/1347/1347A.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize an array <code>count</code> of size <code>26</code>, all indices point to <code>0</code> initially to denote the frequency of each character.</p>
</li>
<li>
<p>Iterate over the integer from <code>0</code> to the last index in <code>s</code> or <code>t</code>, for each index <code>i</code>:</p>
<ol>
<li>Increment the frequency of character <code>t[i]</code> in the array <code>count</code>.</li>
<li>Decrement the frequency of character <code>s[i]</code> in the array <code>count</code>.</li>
</ol>
</li>
<li>
<p>Initialize the variable <code>ans</code> to <code>0</code></p>
</li>
<li>
<p>Iterate over the integers from <code>0</code> to <code>25</code>, and for each positive frequency difference, add it to the variable <code>ans</code>.</p>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Y2ro4EYf/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the size of the string <code>s</code> and <code>t</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We are iterating over the indices of string <code>s</code> or <code>t</code> to find the frequencies in the array <code>freq</code>. Then we iterate over the integers from <code>0</code> to <code>26</code> to find the final answer. Hence, the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only space required is the array <code>count</code> which has the constant size of <code>26</code>. Therefore, the total space complexity is constant.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/description" target="_blank" rel="noopener noreferrer">Minimum Number of Steps to Make Two Strings Anagram II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code>. In one step, you can append <strong>any character</strong> to either <code>s</code> or <code>t</code>.</p>

<p>Return <em>the minimum number of steps to make </em><code>s</code><em> and </em><code>t</code><em> <strong>anagrams</strong> of each other.</em></p>

<p>An <strong>anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;<strong><u>lee</u></strong>tco<u><strong>de</strong></u>&quot;, t = &quot;co<u><strong>a</strong></u>t<u><strong>s</strong></u>&quot;
<strong>Output:</strong> 7
<strong>Explanation:</strong> 
- In 2 steps, we can append the letters in &quot;as&quot; onto s = &quot;leetcode&quot;, forming s = &quot;leetcode<strong><u>as</u></strong>&quot;.
- In 5 steps, we can append the letters in &quot;leede&quot; onto t = &quot;coats&quot;, forming t = &quot;coats<u><strong>leede</strong></u>&quot;.
&quot;leetcodeas&quot; and &quot;coatsleede&quot; are now anagrams of each other.
We used a total of 2 + 5 = 7 steps.
It can be shown that there is no way to make them anagrams of each other with less than 7 steps.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;night&quot;, t = &quot;thing&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> The given strings are already anagrams of each other. Thus, we do not need any further steps.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-character-frequencies-equal/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make Character Frequencies Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>.</p>

<p>A string <code>t</code> is called <strong>good</strong> if all characters of <code>t</code> occur the same number of times.</p>

<p>You can perform the following operations <strong>any number of times</strong>:</p>

<ul>
	<li>Delete a character from <code>s</code>.</li>
	<li>Insert a character in <code>s</code>.</li>
	<li>Change a character in <code>s</code> to its next letter in the alphabet.</li>
</ul>

<p><strong>Note</strong> that you cannot change <code>&#39;z&#39;</code> to <code>&#39;a&#39;</code> using the third operation.</p>

<p>Return<em> </em>the <strong>minimum</strong> number of operations required to make <code>s</code> <strong>good</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;acab&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>We can make <code>s</code> good by deleting one occurrence of character <code>&#39;a&#39;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;wddw&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>We do not need to perform any operations since <code>s</code> is initially good.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aaabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can make <code>s</code> good by applying these operations:</p>

<ul>
	<li>Change one occurrence of <code>&#39;a&#39;</code> to <code>&#39;b&#39;</code></li>
	<li>Insert one occurrence of <code>&#39;c&#39;</code> into <code>s</code></li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 2&nbsp;* 10<sup>4</sup></code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-the-array-alternating/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make the Array Alternating</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> consisting of <code>n</code> positive integers.</p>

<p>The array <code>nums</code> is called <strong>alternating</strong> if:</p>

<ul>
	<li><code>nums[i - 2] == nums[i]</code>, where <code>2 &lt;= i &lt;= n - 1</code>.</li>
	<li><code>nums[i - 1] != nums[i]</code>, where <code>1 &lt;= i &lt;= n - 1</code>.</li>
</ul>

<p>In one <strong>operation</strong>, you can choose an index <code>i</code> and <strong>change</strong> <code>nums[i]</code> into <strong>any</strong> positive integer.</p>

<p>Return <em>the <strong>minimum number of operations</strong> required to make the array alternating</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,3,2,4,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
One way to make the array alternating is by converting it to [3,1,3,<u><strong>1</strong></u>,<u><strong>3</strong></u>,<u><strong>1</strong></u>].
The number of operations required in this case is 3.
It can be proven that it is not possible to make the array alternating in less than 3 operations. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,2,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
One way to make the array alternating is by converting it to [1,2,<u><strong>1</strong></u>,2,<u><strong>1</strong></u>].
The number of operations required in this case is 2.
Note that the array cannot be converted to [<u><strong>2</strong></u>,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-write-the-letter-y-on-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Write the Letter Y on a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>n x n</code> grid where <code>n</code> is odd, and <code>grid[r][c]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</p>

<p>We say that a cell belongs to the Letter <strong>Y</strong> if it belongs to one of the following:</p>

<ul>
	<li>The diagonal starting at the top-left cell and ending at the center cell of the grid.</li>
	<li>The diagonal starting at the top-right cell and ending at the center cell of the grid.</li>
	<li>The vertical line starting at the center cell and ending at the bottom border of the grid.</li>
</ul>

<p>The Letter <strong>Y</strong> is written on the grid if and only if:</p>

<ul>
	<li>All values at cells belonging to the Y are equal.</li>
	<li>All values at cells not belonging to the Y are equal.</li>
	<li>The values at cells belonging to the Y are different from the values at cells not belonging to the Y.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to</em> <code>0</code><em>,</em> <code>1</code><em>,</em> <em>or</em> <code>2</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/22/y2.png" style="width: 461px; height: 121px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,2],[1,1,0],[0,1,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 1 while those that do not belong to Y are equal to 0.
It can be shown that 3 is the minimum number of operations needed to write Y on the grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/22/y3.png" style="width: 701px; height: 201px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]
<strong>Output:</strong> 12
<strong>Explanation:</strong> We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 0 while those that do not belong to Y are equal to 2. 
It can be shown that 12 is the minimum number of operations needed to write Y on the grid.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 49 </code></li>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 2</code></li>
	<li><code>n</code> is odd.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-rounds-to-complete-all-tasks/description" target="_blank" rel="noopener noreferrer">Minimum Rounds to Complete All Tasks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>tasks</code>, where <code>tasks[i]</code> represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the <strong>same difficulty level</strong>.</p>

<p>Return <em>the <strong>minimum</strong> rounds required to complete all the tasks, or </em><code>-1</code><em> if it is not possible to complete all the tasks.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [2,2,3,3,2,4,4,4,4,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> To complete all the tasks, a possible plan is:
- In the first round, you complete 3 tasks of difficulty level 2. 
- In the second round, you complete 2 tasks of difficulty level 3. 
- In the third round, you complete 3 tasks of difficulty level 4. 
- In the fourth round, you complete 2 tasks of difficulty level 4.  
It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [2,3,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/description/" target="_blank">2870: Minimum Number of Operations to Make Array Empty.</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-substring-partition-of-equal-character-frequency/description" target="_blank" rel="noopener noreferrer">Minimum Substring Partition of Equal Character Frequency</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, you need to partition it into one or more <strong>balanced</strong> <span data-keyword="substring">substrings</span>. For example, if <code>s == &quot;ababcc&quot;</code> then <code>(&quot;abab&quot;, &quot;c&quot;, &quot;c&quot;)</code>, <code>(&quot;ab&quot;, &quot;abc&quot;, &quot;c&quot;)</code>, and <code>(&quot;ababcc&quot;)</code> are all valid partitions, but <code>(&quot;a&quot;, <strong>&quot;bab&quot;</strong>, &quot;cc&quot;)</code>, <code>(<strong>&quot;aba&quot;</strong>, &quot;bc&quot;, &quot;c&quot;)</code>, and <code>(&quot;ab&quot;, <strong>&quot;abcc&quot;</strong>)</code> are not. The unbalanced substrings are bolded.</p>

<p>Return the <strong>minimum</strong> number of substrings that you can partition <code>s</code> into.</p>

<p><strong>Note:</strong> A <strong>balanced</strong> string is a string where each character in the string occurs the same number of times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;fabccddg&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>We can partition the string <code>s</code> into 3 substrings in one of the following ways: <code>(&quot;fab, &quot;ccdd&quot;, &quot;g&quot;)</code>, or <code>(&quot;fabc&quot;, &quot;cd&quot;, &quot;dg&quot;)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abababaccddb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can partition the string <code>s</code> into 2 substrings like so: <code>(&quot;abab&quot;, &quot;abaccddb&quot;)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consists only of English lowercase letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-total-cost-to-make-arrays-unequal/description" target="_blank" rel="noopener noreferrer">Minimum Total Cost to Make Arrays Unequal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, of equal length <code>n</code>.</p>

<p>In one operation, you can swap the values of any two indices of <code>nums1</code>. The <strong>cost</strong> of this operation is the <strong>sum</strong> of the indices.</p>

<p>Find the <strong>minimum</strong> total cost of performing the given operation <strong>any</strong> number of times such that <code>nums1[i] != nums2[i]</code> for all <code>0 &lt;= i &lt;= n - 1</code> after performing all the operations.</p>

<p>Return <em>the <strong>minimum total cost</strong> such that </em><code>nums1</code> and <code>nums2</code><em> satisfy the above condition</em>. In case it is not possible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
<strong>Output:</strong> 10
<strong>Explanation:</strong> 
One of the ways we can perform the operations is:
- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]
- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].
- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].
We can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.
Note that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
<strong>Output:</strong> 10
<strong>Explanation:</strong> 
One of the ways we can perform the operations is:
- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].
- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].
The total cost needed here is 10, which is the minimum possible.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,2], nums2 = [1,2,2]
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
It can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.
Hence, we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums1.length == nums2.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-common-word/description" target="_blank" rel="noopener noreferrer">Most Common Word</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>paragraph</code> and a string array of the banned words <code>banned</code>, return <em>the most frequent word that is not banned</em>. It is <strong>guaranteed</strong> there is <strong>at least one word</strong> that is not banned, and that the answer is <strong>unique</strong>.</p>

<p>The words in <code>paragraph</code> are <strong>case-insensitive</strong> and the answer should be returned in <strong>lowercase</strong>.</p>

<p><strong>Note</strong> that words can not contain punctuation symbols.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;, banned = [&quot;hit&quot;]
<strong>Output:</strong> &quot;ball&quot;
<strong>Explanation:</strong> 
&quot;hit&quot; occurs 3 times, but it is a banned word.
&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), 
and that &quot;hit&quot; isn&#39;t the answer even though it occurs more because it is banned.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> paragraph = &quot;a.&quot;, banned = []
<strong>Output:</strong> &quot;a&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= paragraph.length &lt;= 1000</code></li>
	<li>paragraph consists of English letters, space <code>&#39; &#39;</code>, or one of the symbols: <code>&quot;!?&#39;,;.&quot;</code>.</li>
	<li><code>0 &lt;= banned.length &lt;= 100</code></li>
	<li><code>1 &lt;= banned[i].length &lt;= 10</code></li>
	<li><code>banned[i]</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>This problem is a good exercise to brush up one's skills on string manipulation.</p>
<p>The String data type is almost omnipresent in all programming languages.<br />
However, each language has its own implementation of String type, as well as various APIs for string manipulation.<br />
For instance, String is <em>mutable</em> in C++, while immutable in Python and Java.</p>
<p>The problem is not difficult. But due to the diversity of String type and string manipulation APIs, one could come up many different solutions.</p>
<p>Here we give two general approaches in the following sections.</p>
<ul>
<li>
<p>In one approach, we will construct a pipeline to process strings in several stages, where naturally each string would be traversed for several times.</p>
</li>
<li>
<p>In another approach, we will traverse the input string <em>once and only once</em>, on the character base and do the processing <em><strong>on-the-fly</strong></em>.<br />
<br/><br />
<br/></p>
</li>
</ul>
<hr />
<h3 id="approach-1-string-processing-in-pipeline">Approach 1: String Processing in Pipeline</h3>
<p><strong>Intuition</strong></p>
<p>We can solve the problem by breaking it into a series of <em>sequential tasks</em>.<br />
Each task functions like a stage in a pipeline, which takes the input from the previous stage and then channels its output to the next stage.</p>
<p>More specifically, for this problem, we could break it down into the following stages:</p>
<p><img src="../Figures/819/819_pipeline_.png" alt="string processing pipeline" /></p>
<ol>
<li>
<p>We replace all the punctuations with spaces and at the same time convert each letter to its lowercase. One could also accomplish this in two stages. Here we merge them together in one stage.</p>
</li>
<li>
<p>We split the output in the above step into words, with the separator of spaces.</p>
</li>
<li>
<p>We then iterate through the words to count the appearance of each unique word, excluding the words from the banned list.</p>
</li>
<li>
<p>With the hashmap of <code>{word-&gt;count}</code>, we then walk through all the items to find the word with the highest frequency.</p>
</li>
</ol>
<p><strong>Algorithm</strong></p>
<p>Following the stages we explained before, here are some sample implementations.</p>
<p><a href="https://leetcode.com/playground/jSM7y4ka/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of characters in the input string and <span class="math inline">\(M\)</span> be the number of characters in the banned list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(N + M)\)</span>.</p>
<ul>
<li>
<p>It would take <span class="math inline">\(\mathcal{O}(N)\)</span> time to process each stage of the pipeline as we built.</p>
</li>
<li>
<p>In addition, we built a set out of the list of banned words, which would take <span class="math inline">\(\mathcal{O}(M)\)</span> time.</p>
</li>
<li>
<p>Hence, the overall time complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N + M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(N + M)\)</span>.</p>
<ul>
<li>
<p>We built a hashmap to count the frequency of each unique word, whose space would be of <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
<li>
<p>Similarly, we built a set out of the banned word list, which would consume additional <span class="math inline">\(\mathcal{O}(M)\)</span> space.</p>
</li>
<li>
<p>Therefore, the overall space complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N + M)\)</span>.<br />
<br/><br />
<br/></p>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-character-processing-in-one-pass">Approach 2: Character Processing in One-Pass</h3>
<p><strong>Intuition</strong></p>
<p>With the approach of String manipulation pipeline, it is clear and easy to debug, since we could locate and inspect each stage if anything goes wrong.</p>
<p>However, one might argue that it is probably not the most efficient way to solve the problem, since we scan the input string multiple times.</p>
<p>Indeed, it is possible to process the input string once and only once to accomplish the tasks.</p>
<blockquote>
<p>We could iterate through the string character by character, and do the processing <em><strong>on-the-fly</strong></em>, rather than delaying the processing to the latter stages of the pipeline.</p>
</blockquote>
<p>The idea is that we consume the input string on the character base.<br />
At the moment we reach the end of one word, we can then start to perform the word-based logics such as checking if the word is in the banned list, updating the frequency of the word and also updating the most frequent word we've seen so far <em>etc.</em></p>
<p><strong>Algorithm</strong></p>
<p>We could implement the algorithm in one single loop, over the characters of the input string.</p>
<ul>
<li>At each iteration, the character is either of letter (maybe digit), or punctuation or space in other cases.</li>
</ul>
<p><img src="../Figures/819/819_character_pointers_.png" alt="character pointers" /></p>
<ul>
<li>
<p>Further more, we could divide it into the following two cases:</p>
<ul>
<li>
<p><strong>Case (1):</strong> we are in the middle of a word.</p>
</li>
<li>
<p><strong>Case (2):</strong> we in in-between the words, <em>e.g.</em> punctuations between the words or at the end of the paragraph.</p>
</li>
</ul>
</li>
<li>
<p>We then can organize the logics into the above two cases.</p>
<ul>
<li>
<p>In case (1), we simply append the character into the word buffer.</p>
</li>
<li>
<p>In case (2), we do the rest of the logics, as follows:</p>
<ul>
<li>
<p>check if the word is enlisted in the banned list.</p>
</li>
<li>
<p>if not, update the frequency of the word.</p>
</li>
<li>
<p>update the most common word that we've seen so far.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="https://leetcode.com/playground/Yoz4mHVK/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of characters in the input string and <span class="math inline">\(M\)</span> be the number of characters in the banned list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(N + M)\)</span>.</p>
<ul>
<li>
<p>We traverse each character in the input string once and only once. At each iteration, it takes constant time to perform the operations, except the operation that we build a new string out of the buffer. Excluding the cost of string-building out of the iteration, we can consider the cost of iterations as <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
<li>
<p>If we combine all the string-building operations all together, in total it would take another <span class="math inline">\(\mathcal{O}(N)\)</span> time.</p>
</li>
<li>
<p>In addition, we built a set out of the list of banned words, which would take <span class="math inline">\(\mathcal{O}(M)\)</span> time.</p>
</li>
<li>
<p>Hence, the overall time complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N) + \mathcal{O}(N) + \mathcal{O}(M) = \mathcal{O}(N + M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(N + M)\)</span>.</p>
<ul>
<li>
<p>We built a hashmap to count the frequency of each unique word, whose space would be of <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
<li>
<p>Similarly, we built a set out of the banned word list, which would consume additional <span class="math inline">\(\mathcal{O}(M)\)</span> space.</p>
</li>
<li>
<p>Therefore, the overall space complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N + M)\)</span>.</p>
</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-frequent-even-element/description" target="_blank" rel="noopener noreferrer">Most Frequent Even Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>the most frequent even element</em>.</p>

<p>If there is a tie, return the <strong>smallest</strong> one. If there is no such element, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,2,2,4,4,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.
We return the smallest one, which is 2.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,4,4,9,2,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 4 is the even element appears the most.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [29,47,21,41,13,37,25,7]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no even element.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-frequent-number-following-key-in-an-array/description" target="_blank" rel="noopener noreferrer">Most Frequent Number Following Key In an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.<strong> </strong>You are also given an integer <code>key</code>, which is present in <code>nums</code>.</p>

<p>For every unique integer <code>target</code> in <code>nums</code>, <strong>count</strong> the number of times <code>target</code> immediately follows an occurrence of <code>key</code> in <code>nums</code>. In other words, count the number of indices <code>i</code> such that:</p>

<ul>
	<li><code>0 &lt;= i &lt;= nums.length - 2</code>,</li>
	<li><code>nums[i] == key</code> and,</li>
	<li><code>nums[i + 1] == target</code>.</li>
</ul>

<p>Return <em>the </em><code>target</code><em> with the <strong>maximum</strong> count</em>. The test cases will be generated such that the <code>target</code> with maximum count is unique.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,100,200,1,100], key = 1
<strong>Output:</strong> 100
<strong>Explanation:</strong> For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.
No other integers follow an occurrence of key, so we return 100.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2,2,3], key = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.
For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.
target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li>The test cases will be generated such that the answer is unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-frequent-prime/description" target="_blank" rel="noopener noreferrer">Most Frequent Prime</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> <strong>0-indexed </strong>2D<strong> </strong>matrix <code>mat</code>. From every cell, you can create numbers in the following way:</p>

<ul>
	<li>There could be at most <code>8</code> paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.</li>
	<li>Select a path from them and append digits in this path to the number being formed by traveling in this direction.</li>
	<li>Note that numbers are generated at every step, for example, if the digits along the path are <code>1, 9, 1</code>, then there will be three numbers generated along the way: <code>1, 19, 191</code>.</li>
</ul>

<p>Return <em>the most frequent <span data-keyword="prime-number">prime number</span> <strong>greater</strong> than </em><code>10</code><em> out of all the numbers created by traversing the matrix or </em><code>-1</code><em> if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the <b>largest</b> among them.</em></p>

<p><strong>Note:</strong> It is invalid to change the direction during the move.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2024/02/15/south" style="width: 641px; height: 291px;" /> </strong>

<pre>
<strong>
Input:</strong> mat = [[1,1],[9,9],[1,1]]
<strong>Output:</strong> 19
<strong>Explanation:</strong> 
From cell (0,0) there are 3 possible directions and the numbers greater than 10 which can be created in those directions are:
East: [11], South-East: [19], South: [19,191].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [19,191,19,11].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [99,91,91,91,91].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [91,91,99,91,91].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [11,19,191,19].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [11,19,19,191].
The most frequent prime number among all the created numbers is 19.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[7]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The only number which can be formed is 7. It is a prime number however it is not greater than 10, so return -1.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[9,7,8],[4,6,5],[2,8,6]]
<strong>Output:</strong> 97
<strong>Explanation:</strong> 
Numbers greater than 10 created from the cell (0,0) in all possible directions are: [97,978,96,966,94,942].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [78,75,76,768,74,79].
Numbers greater than 10 created from the cell (0,2) in all possible directions are: [85,856,86,862,87,879].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [46,465,48,42,49,47].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [65,66,68,62,64,69,67,68].
Numbers greater than 10 created from the cell (1,2) in all possible directions are: [56,58,56,564,57,58].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [28,286,24,249,26,268].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [86,82,84,86,867,85].
Numbers greater than 10 created from the cell (2,2) in all possible directions are: [68,682,66,669,65,658].
The most frequent prime number among all the created numbers is 97.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 6</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-numerically-balanced-number/description" target="_blank" rel="noopener noreferrer">Next Greater Numerically Balanced Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An integer <code>x</code> is <strong>numerically balanced</strong> if for every digit <code>d</code> in the number <code>x</code>, there are <strong>exactly</strong> <code>d</code> occurrences of that digit in <code>x</code>.</p>

<p>Given an integer <code>n</code>, return <em>the <strong>smallest numerically balanced</strong> number <strong>strictly greater</strong> than </em><code>n</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 22
<strong>Explanation:</strong> 
22 is numerically balanced since:
- The digit 2 occurs 2 times. 
It is also the smallest numerically balanced number strictly greater than 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1000
<strong>Output:</strong> 1333
<strong>Explanation:</strong> 
1333 is numerically balanced since:
- The digit 1 occurs 1 time.
- The digit 3 occurs 3 times. 
It is also the smallest numerically balanced number strictly greater than 1000.
Note that 1022 cannot be the answer because 0 appeared more than 0 times.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3000
<strong>Output:</strong> 3133
<strong>Explanation:</strong> 
3133 is numerically balanced since:
- The digit 1 occurs 1 time.
- The digit 3 occurs 3 times.
It is also the smallest numerically balanced number strictly greater than 3000.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-beautiful-pairs/description" target="_blank" rel="noopener noreferrer">Number of Beautiful Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed </strong>integer array <code>nums</code>. A pair of indices <code>i</code>, <code>j</code> where <code>0 &lt;=&nbsp;i &lt; j &lt; nums.length</code> is called beautiful if the <strong>first digit</strong> of <code>nums[i]</code> and the <strong>last digit</strong> of <code>nums[j]</code> are <strong>coprime</strong>.</p>

<p>Return <em>the total number of beautiful pairs in </em><code>nums</code>.</p>

<p>Two integers <code>x</code> and <code>y</code> are <strong>coprime</strong> if there is no integer greater than 1 that divides both of them. In other words, <code>x</code> and <code>y</code> are coprime if <code>gcd(x, y) == 1</code>, where <code>gcd(x, y)</code> is the <strong>greatest common divisor</strong> of <code>x</code> and <code>y</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,5,1,4]
<strong>Output:</strong> 5
<strong>Explanation:</strong> There are 5 beautiful pairs in nums:
When i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.
When i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.
When i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.
When i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.
Thus, we return 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [11,21,12]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 beautiful pairs:
When i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.
Thus, we return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 9999</code></li>
	<li><code>nums[i] % 10 != 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-different-subsequences-gcds/description" target="_blank" rel="noopener noreferrer">Number of Different Subsequences GCDs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> that consists of positive integers.</p>

<p>The <strong>GCD</strong> of a sequence of numbers is defined as the greatest integer that divides <strong>all</strong> the numbers in the sequence evenly.</p>

<ul>
	<li>For example, the GCD of the sequence <code>[4,6,16]</code> is <code>2</code>.</li>
</ul>

<p>A <strong>subsequence</strong> of an array is a sequence that can be formed by removing some elements (possibly none) of the array.</p>

<ul>
	<li>For example, <code>[2,5,10]</code> is a subsequence of <code>[1,2,1,<strong><u>2</u></strong>,4,1,<u><strong>5</strong></u>,<u><strong>10</strong></u>]</code>.</li>
</ul>

<p>Return <em>the <strong>number</strong> of <strong>different</strong> GCDs among all <strong>non-empty</strong> subsequences of</em> <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/17/image-1.png" style="width: 149px; height: 309px;" />
<pre>
<strong>Input:</strong> nums = [6,10,3]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The figure shows all the non-empty subsequences and their GCDs.
The different GCDs are 6, 10, 3, 2, and 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,15,40,5,6]
<strong>Output:</strong> 7
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-equivalent-domino-pairs/description" target="_blank" rel="noopener noreferrer">Number of Equivalent Domino Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a list of <code>dominoes</code>, <code>dominoes[i] = [a, b]</code> is <strong>equivalent to</strong> <code>dominoes[j] = [c, d]</code> if and only if either (<code>a == c</code> and <code>b == d</code>), or (<code>a == d</code> and <code>b == c</code>) - that is, one domino can be rotated to be equal to another domino.</p>

<p>Return <em>the number of pairs </em><code>(i, j)</code><em> for which </em><code>0 &lt;= i &lt; j &lt; dominoes.length</code><em>, and </em><code>dominoes[i]</code><em> is <strong>equivalent to</strong> </em><code>dominoes[j]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> dominoes = [[1,2],[2,1],[3,4],[5,6]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= dominoes.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>dominoes[i].length == 2</code></li>
	<li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-tuple-representation--counting">Approach: Tuple Representation + Counting</h3>
<h4 id="intuition">Intuition</h4>
<p>In this problem, we need to count all equivalent dominoes, where dominoes are represented by pairs. The definition of &quot;equivalent&quot; is that, under the condition of allowing the flip of two pairs, their elements correspond and are equal one by one.</p>
<p>So we might as well directly convert each binary pair into the specified format, that is, the first dimension must not be greater than the second dimension. Two pairs are equivalent if they contain the same two numbers, regardless of order.</p>
<p>Noticing that the elements in the pairs are all not greater than <span class="math inline">\(9\)</span>, we can concatenate each binary pair into a two-digit positive integer, i.e., <span class="math inline">\((x, y) \to 10x + y\)</span>. In this way, there is no need to use a hash table to count the number of elements, but we can directly use an array of length <span class="math inline">\(100\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/g5pAEWkh/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of dominoes.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>We only need to traverse the array once.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(1)\)</span></li>
</ul>
<p>We only need constant space to store a few variables.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-good-pairs/description" target="_blank" rel="noopener noreferrer">Number of Good Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code>, return <em>the number of <strong>good pairs</strong></em>.</p>

<p>A pair <code>(i, j)</code> is called <em>good</em> if <code>nums[i] == nums[j]</code> and <code>i</code> &lt; <code>j</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,1,1,3]
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> Each pair in the array are <em>good</em>.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/description" target="_blank" rel="noopener noreferrer">Number of Nodes in the Sub-Tree With the Same Label</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> <code>edges</code>. The <strong>root</strong> of the tree is the node <code>0</code>, and each node of the tree has <strong>a label</strong> which is a lower-case character given in the string <code>labels</code> (i.e. The node with the number <code>i</code> has the label <code>labels[i]</code>).</p>

<p>The <code>edges</code> array is given on the form <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>, which means there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>Return <em>an array of size <code>n</code></em> where <code>ans[i]</code> is the number of nodes in the subtree of the <code>i<sup>th</sup></code> node which have the same label as node <code>i</code>.</p>

<p>A subtree of a tree <code>T</code> is the tree consisting of a node in <code>T</code> and all of its descendant nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/01/q3e1.jpg" style="width: 400px; height: 291px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = &quot;abaedcd&quot;
<strong>Output:</strong> [2,1,1,1,1,1,1]
<strong>Explanation:</strong> Node 0 has label &#39;a&#39; and its sub-tree has node 2 with label &#39;a&#39; as well, thus the answer is 2. Notice that any node is part of its sub-tree.
Node 1 has a label &#39;b&#39;. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/01/q3e2.jpg" style="width: 300px; height: 253px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[1,2],[0,3]], labels = &quot;bbbb&quot;
<strong>Output:</strong> [4,2,1,1]
<strong>Explanation:</strong> The sub-tree of node 2 contains only node 2, so the answer is 1.
The sub-tree of node 3 contains only node 3, so the answer is 1.
The sub-tree of node 1 contains nodes 1 and 2, both have label &#39;b&#39;, thus the answer is 2.
The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label &#39;b&#39;, thus the answer is 4.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/01/q3e3.jpg" style="width: 300px; height: 253px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = &quot;aabab&quot;
<strong>Output:</strong> [3,2,1,1,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>labels.length == n</code></li>
	<li><code>labels</code> is consisting of only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/description" target="_blank" rel="noopener noreferrer">Number of Pairs of Interchangeable Rectangles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>n</code> rectangles represented by a <strong>0-indexed</strong> 2D integer array <code>rectangles</code>, where <code>rectangles[i] = [width<sub>i</sub>, height<sub>i</sub>]</code> denotes the width and height of the <code>i<sup>th</sup></code> rectangle.</p>

<p>Two rectangles <code>i</code> and <code>j</code> (<code>i &lt; j</code>) are considered <strong>interchangeable</strong> if they have the <strong>same</strong> width-to-height ratio. More formally, two rectangles are <strong>interchangeable</strong> if <code>width<sub>i</sub>/height<sub>i</sub> == width<sub>j</sub>/height<sub>j</sub></code> (using decimal division, not integer division).</p>

<p>Return <em>the <strong>number</strong> of pairs of <strong>interchangeable</strong> rectangles in </em><code>rectangles</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> rectangles = [[4,8],[3,6],[10,20],[15,30]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The following are the interchangeable pairs of rectangles by index (0-indexed):
- Rectangle 0 with rectangle 1: 4/8 == 3/6.
- Rectangle 0 with rectangle 2: 4/8 == 10/20.
- Rectangle 0 with rectangle 3: 4/8 == 15/30.
- Rectangle 1 with rectangle 2: 3/6 == 10/20.
- Rectangle 1 with rectangle 3: 3/6 == 15/30.
- Rectangle 2 with rectangle 3: 10/20 == 15/30.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> rectangles = [[4,5],[7,8]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no interchangeable pairs of rectangles.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == rectangles.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>rectangles[i].length == 2</code></li>
	<li><code>1 &lt;= width<sub>i</sub>, height<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/description" target="_blank" rel="noopener noreferrer">Number of Pairs of Strings With Concatenation Equal to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of <strong>digit</strong> strings <code>nums</code> and a <strong>digit</strong> string <code>target</code>, return <em>the number of pairs of indices </em><code>(i, j)</code><em> (where </em><code>i != j</code><em>) such that the <strong>concatenation</strong> of </em><code>nums[i] + nums[j]</code><em> equals </em><code>target</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [&quot;777&quot;,&quot;7&quot;,&quot;77&quot;,&quot;77&quot;], target = &quot;7777&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> Valid pairs are:
- (0, 1): &quot;777&quot; + &quot;7&quot;
- (1, 0): &quot;7&quot; + &quot;777&quot;
- (2, 3): &quot;77&quot; + &quot;77&quot;
- (3, 2): &quot;77&quot; + &quot;77&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [&quot;123&quot;,&quot;4&quot;,&quot;12&quot;,&quot;34&quot;], target = &quot;1234&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Valid pairs are:
- (0, 1): &quot;123&quot; + &quot;4&quot;
- (2, 3): &quot;12&quot; + &quot;34&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], target = &quot;11&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> Valid pairs are:
- (0, 1): &quot;1&quot; + &quot;1&quot;
- (1, 0): &quot;1&quot; + &quot;1&quot;
- (0, 2): &quot;1&quot; + &quot;1&quot;
- (2, 0): &quot;1&quot; + &quot;1&quot;
- (1, 2): &quot;1&quot; + &quot;1&quot;
- (2, 1): &quot;1&quot; + &quot;1&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>
	<li><code>2 &lt;= target.length &lt;= 100</code></li>
	<li><code>nums[i]</code> and <code>target</code> consist of digits.</li>
	<li><code>nums[i]</code> and <code>target</code> do not have leading zeros.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/description" target="_blank" rel="noopener noreferrer">Pairs of Songs With Total Durations Divisible by 60</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a list of songs where the <code>i<sup>th</sup></code> song has a duration of <code>time[i]</code> seconds.</p>

<p>Return <em>the number of pairs of songs for which their total duration in seconds is divisible by</em> <code>60</code>. Formally, we want the number of indices <code>i</code>, <code>j</code> such that <code>i &lt; j</code> with <code>(time[i] + time[j]) % 60 == 0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> time = [30,20,150,100,40]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> time = [60,60,60]
<strong>Output:</strong> 3
<strong>Explanation:</strong> All three pairs have a total duration of 120, which is divisible by 60.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= time.length &lt;= 6 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= time[i] &lt;= 500</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rank-teams-by-votes/description" target="_blank" rel="noopener noreferrer">Rank Teams by Votes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition.</p>

<p>The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.</p>

<p>You are given an array of strings <code>votes</code> which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.</p>

<p>Return <em>a string of all teams <strong>sorted</strong> by the ranking system</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> votes = [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;]
<strong>Output:</strong> &quot;ACB&quot;
<strong>Explanation:</strong> 
Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team.
Team B was ranked second by 2 voters and ranked third by 3 voters.
Team C was ranked second by 3 voters and ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team, and team B is the third.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> votes = [&quot;WXYZ&quot;,&quot;XYZW&quot;]
<strong>Output:</strong> &quot;XWYZ&quot;
<strong>Explanation:</strong>
X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> votes = [&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;]
<strong>Output:</strong> &quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;
<strong>Explanation:</strong> Only one voter, so their votes are used for the ranking.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= votes.length &lt;= 1000</code></li>
	<li><code>1 &lt;= votes[i].length &lt;= 26</code></li>
	<li><code>votes[i].length == votes[j].length</code> for <code>0 &lt;= i, j &lt; votes.length</code>.</li>
	<li><code>votes[i][j]</code> is an English <strong>uppercase</strong> letter.</li>
	<li>All characters of <code>votes[i]</code> are unique.</li>
	<li>All the characters that occur in <code>votes[0]</code> <strong>also occur</strong> in <code>votes[j]</code> where <code>1 &lt;= j &lt; votes.length</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ransom-note/description" target="_blank" rel="noopener noreferrer">Ransom Note</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code><em> if </em><code>ransomNote</code><em> can be constructed by using the letters from </em><code>magazine</code><em> and </em><code>false</code><em> otherwise</em>.</p>

<p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> ransomNote = "a", magazine = "b"
<strong>Output:</strong> false
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> ransomNote = "aa", magazine = "ab"
<strong>Output:</strong> false
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> ransomNote = "aa", magazine = "aab"
<strong>Output:</strong> true
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10<sup>5</sup></code></li>
	<li><code>ransomNote</code> and <code>magazine</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rearrange-characters-to-make-target-string/description" target="_blank" rel="noopener noreferrer">Rearrange Characters to Make Target String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>s</code> and <code>target</code>. You can take some letters from <code>s</code> and rearrange them to form new strings.</p>

<p>Return<em> the <strong>maximum</strong> number of copies of </em><code>target</code><em> that can be formed by taking letters from </em><code>s</code><em> and rearranging them.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ilovecodingonleetcode&quot;, target = &quot;code&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong>
For the first copy of &quot;code&quot;, take the letters at indices 4, 5, 6, and 7.
For the second copy of &quot;code&quot;, take the letters at indices 17, 18, 19, and 20.
The strings that are formed are &quot;ecod&quot; and &quot;code&quot; which can both be rearranged into &quot;code&quot;.
We can make at most two copies of &quot;code&quot;, so we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcba&quot;, target = &quot;abc&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong>
We can make one copy of &quot;abc&quot; by taking the letters at indices 0, 1, and 2.
We can make at most one copy of &quot;abc&quot;, so we return 1.
Note that while there is an extra &#39;a&#39; and &#39;b&#39; at indices 3 and 4, we cannot reuse the letter &#39;c&#39; at index 2, so we cannot make a second copy of &quot;abc&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abbaccaddaeea&quot;, target = &quot;aaaaa&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong>
We can make one copy of &quot;aaaaa&quot; by taking the letters at indices 0, 3, 6, 9, and 12.
We can make at most one copy of &quot;aaaaa&quot;, so we return 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>1 &lt;= target.length &lt;= 10</code></li>
	<li><code>s</code> and <code>target</code> consist of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/maximum-number-of-balloons/description/" target="_blank"> 1189: Maximum Number of Balloons.</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/description" target="_blank" rel="noopener noreferrer">Redistribute Characters to Make All Strings Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> (<strong>0-indexed</strong>).</p>

<p>In one operation, pick two <strong>distinct</strong> indices <code>i</code> and <code>j</code>, where <code>words[i]</code> is a non-empty string, and move <strong>any</strong> character from <code>words[i]</code> to <strong>any</strong> position in <code>words[j]</code>.</p>

<p>Return <code>true</code> <em>if you can make<strong> every</strong> string in </em><code>words</code><em> <strong>equal </strong>using <strong>any</strong> number of operations</em>,<em> and </em><code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abc&quot;,&quot;aabc&quot;,&quot;bc&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> Move the first &#39;a&#39; in <code>words[1] to the front of words[2],
to make </code><code>words[1]</code> = &quot;abc&quot; and words[2] = &quot;abc&quot;.
All the strings are now equal to &quot;abc&quot;, so return <code>true</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;ab&quot;,&quot;a&quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to make all the strings equal using the operation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-count-character-frequencies">Approach 1: Count Character Frequencies</h3>
<p><strong>Intuition</strong></p>
<p>The operation that we are allowed to perform is extremely powerful. We are allowed to move any character to any position in any string. As we are allowed to perform the operation an unlimited number of times, the only thing that matters is the letters we have available to use in <code>words</code>. Given these letters available to us, we can form any combination of words with their letters having any permutation we want.</p>
<p>So, what would it require to make every string equal? There are two requirements for a string to be equal:</p>
<ol>
<li>The strings must have the same letters with the same frequencies. For example, <code>&quot;aabccc&quot;</code> has two <code>&quot;a&quot;</code>, one <code>&quot;b&quot;</code>, and three <code>&quot;c&quot;</code>.</li>
<li>The letters must be in the same positions.</li>
</ol>
<p>We don't need to worry about requirement #2 because as we mentioned above, the operation is extremely powerful and we can create any order we want. So the important thing is that we make every string have the same letters with the same frequencies. If one string has five <code>&quot;h&quot;</code>, then every other string must also have five <code>&quot;h&quot;</code>, for example.</p>
<p>We will start by collecting all the letters available for us to use. We create a hash map <code>counts</code>, where <code>counts[letter]</code> tells us how many times <code>letter</code> appears in the input. We iterate over every <code>word</code> in <code>words</code>, and for each <code>word</code> we iterate over every character <code>c</code> and increment <code>counts[c]</code>.</p>
<p>Once we have calculated <code>counts</code>, we analyze each letter's frequency. Let's say that the length of <code>words</code> is <code>n</code>. If a given letter has a frequency of <code>val</code>, we need to allocate <code>val / n</code> copies to each string. This is only possible if <code>val / n</code> is an integer, i.e. <code>val</code> is divisible by <code>n</code>. We can check if <code>val</code> is divisible by <code>n</code> by taking the modulus. If <code>val % n = 0</code>, then <code>val</code> is divisible by <code>n</code>.</p>
<p>If a letter's frequency is divisible by <code>n</code>, we know we can allocate an equal number of copies of this letter to every string. Again, we don't need to worry about the positions mentioned in requirement #2, since we can create any order we want. If every letter's frequency can be evenly allocated, we are guaranteed to make equal strings and the overall task is possible. If ANY letter's frequency cannot be evenly allocated, the task is impossible.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a hash map <code>counts</code>.</li>
<li>Iterate over each string <code>word</code> in <code>words</code>:
<ul>
<li>Iterate over each character <code>c</code> in <code>word</code>:
<ul>
<li>Increment <code>counts[c]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Set <code>n = words.length</code>.</li>
<li>Iterate over each value <code>val</code> of <code>counts</code>:
<ul>
<li>If <code>val % n != 0</code>, return <code>false</code>.</li>
</ul>
</li>
<li>Return <code>true</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/AeqpT5qg/shared">code</a></p>
<p>Bonus Python 1-liner:</p>
<p><a href="https://leetcode.com/playground/aKkqe7Vc/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>words</code> and <span class="math inline">\(k\)</span> as the average length of the elements in <code>words</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot k)\)</span></p>
<p>To calculate <code>counts</code>, we iterate over every letter in the input. There are <span class="math inline">\(n \cdot k\)</span> letters, so this costs <span class="math inline">\(O(n \cdot k)\)</span> as hash map operations take constant time.</p>
<p>Then, we iterate over the values of <code>counts</code>. Note that the input can only contain lowercase English letters. Thus, there will never be more than <code>26</code> values in <code>counts</code>, so this takes <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only extra space we are using is for <code>counts</code>. However, the input only contains lowercase English letters, so <code>counts</code> never grows larger than a size of <code>26</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-count-with-array">Approach 2: Count With Array</h3>
<p><strong>Intuition</strong></p>
<p>Because the input only contains lowercase English letters, we can use an array to implement <code>counts</code> instead of a hash map. Each letter is assigned a unique integer in ASCII encodings and as these values are contiguous, we can subtract the ASCII value of <code>'a'</code> from the ASCII value of the letter to map it to a relative position in the alphabet. For example, <code>'a' - 'a'</code> results in <code>0</code>, <code>'b' - 'a'</code> results in <code>1</code>, <code>'c' - 'a'</code> results in <code>2</code>, and so on. In this way, each letter can be mapped directly to an index in the array.</p>
<p>In this approach, we will implement the same idea from the previous approach, except we will use an array of length <code>26</code> instead of a hash map for <code>counts</code>. We let <code>counts[i]</code> represent the frequency of the letter at position <code>i</code> in the alphabet. For example,</p>
<ul>
<li><code>'a'</code> is at position <code>0</code> in the alphabet, so <code>counts[0]</code> represents the frequency of <code>'a'</code>.</li>
<li><code>'b'</code> is at position <code>1</code> in the alphabet, so <code>counts[1]</code> represents the frequency of <code>'b'</code>.</li>
<li>...</li>
<li><code>'z'</code> is at position <code>25</code> in the alphabet, so <code>counts[25]</code> represents the frequency of <code>'z'</code>.</li>
</ul>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create an array <code>counts</code> of length <code>26</code>.</li>
<li>Iterate over each string <code>word</code> in <code>words</code>:
<ul>
<li>Iterate over each character <code>c</code> in <code>word</code>:
<ul>
<li>Increment <code>counts[c - 'a']</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Set <code>n = words.length</code>.</li>
<li>Iterate over each value <code>val</code> of <code>counts</code>:
<ul>
<li>If <code>val % n != 0</code>, return <code>false</code>.</li>
</ul>
</li>
<li>Return <code>true</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/acxXCHNv/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>words</code> and <span class="math inline">\(k\)</span> as the average length of the elements in <code>words</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot k)\)</span></p>
<p>To calculate <code>counts</code>, we iterate over every letter in the input. There are <span class="math inline">\(n \cdot k\)</span> letters, so this costs <span class="math inline">\(O(n \cdot k)\)</span>.</p>
<p>Then, we iterate over the values of <code>counts</code>, which has a length of <code>26</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only extra space we use is for <code>counts</code>, which has a length of <code>26</code>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-letter-to-equalize-frequency/description" target="_blank" rel="noopener noreferrer">Remove Letter To Equalize Frequency</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>word</code>, consisting of lowercase English letters. You need to select <strong>one</strong> index and <strong>remove</strong> the letter at that index from <code>word</code> so that the <strong>frequency</strong> of every letter present in <code>word</code> is equal.</p>

<p>Return<em> </em><code>true</code><em> if it is possible to remove one letter so that the frequency of all letters in </em><code>word</code><em> are equal, and </em><code>false</code><em> otherwise</em>.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>The <b>frequency</b> of a letter <code>x</code> is the number of times it occurs in the string.</li>
	<li>You <strong>must</strong> remove exactly one letter and cannot choose to do nothing.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abcc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Select index 3 and delete it: word becomes &quot;abc&quot; and each character has a frequency of 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;aazz&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> We must delete a character, so either the frequency of &quot;a&quot; is 1 and the frequency of &quot;z&quot; is 2, or vice versa. It is impossible to make all present letters have equal frequency.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= word.length &lt;= 100</code></li>
	<li><code>word</code> consists of lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reordered-power-of-2/description" target="_blank" rel="noopener noreferrer">Reordered Power of 2</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. We reorder the digits in any order (including the original order) such that the leading digit is not zero.</p>

<p>Return <code>true</code> <em>if and only if we can do this so that the resulting number is a power of two</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reorganize-string/description" target="_blank" rel="noopener noreferrer">Reorganize String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, rearrange the characters of <code>s</code> so that any two adjacent characters are not the same.</p>

<p>Return <em>any possible rearrangement of</em> <code>s</code> <em>or return</em> <code>&quot;&quot;</code> <em>if not possible</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "aab"
<strong>Output:</strong> "aba"
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "aaab"
<strong>Output:</strong> ""
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 500</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/replace-question-marks-in-string-to-minimize-its-value/description" target="_blank" rel="noopener noreferrer">Replace Question Marks in String to Minimize Its Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>. <code>s[i]</code> is either a lowercase English letter or <code>&#39;?&#39;</code>.</p>

<p>For a string <code>t</code> having length <code>m</code> containing <strong>only</strong> lowercase English letters, we define the function <code>cost(i)</code> for an index <code>i</code>&nbsp;as the number of characters <strong>equal</strong> to <code>t[i]</code>&nbsp;that appeared before it, i.e. in the range <code>[0, i - 1]</code>.</p>

<p>The <strong>value</strong> of <code>t</code> is the <strong>sum</strong> of <code>cost(i)</code> for all indices <code>i</code>.</p>

<p>For example, for the string <code>t = &quot;aab&quot;</code>:</p>

<ul>
	<li><code>cost(0) = 0</code></li>
	<li><code>cost(1) = 1</code></li>
	<li><code>cost(2) = 0</code></li>
	<li>Hence, the value of <code>&quot;aab&quot;</code> is <code>0 + 1 + 0 = 1</code>.</li>
</ul>

<p>Your task is to <strong>replace all</strong> occurrences of <code>&#39;?&#39;</code> in <code>s</code> with any lowercase English letter so that the <strong>value</strong> of <code>s</code> is <strong>minimized</strong>.</p>

<p>Return <em>a string denoting the modified string with replaced occurrences of </em><code>&#39;?&#39;</code><em>. If there are multiple strings resulting in the <strong>minimum value</strong>, return the <span data-keyword="lexicographically-smaller-string">lexicographically smallest</span> one.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> s = &quot;???&quot; </span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> &quot;abc&quot; </span></p>

<p><strong>Explanation: </strong> In this example, we can replace the occurrences of <code>&#39;?&#39;</code> to make <code>s</code> equal to <code>&quot;abc&quot;</code>.</p>

<p>For <code>&quot;abc&quot;</code>, <code>cost(0) = 0</code>, <code>cost(1) = 0</code>, and <code>cost(2) = 0</code>.</p>

<p>The value of <code>&quot;abc&quot;</code> is <code>0</code>.</p>

<p>Some other modifications of <code>s</code> that have a value of <code>0</code> are <code>&quot;cba&quot;</code>, <code>&quot;abz&quot;</code>, and, <code>&quot;hey&quot;</code>.</p>

<p>Among all of them, we choose the lexicographically smallest.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">s = &quot;a?a?&quot;</span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">&quot;abac&quot;</span></p>

<p><strong>Explanation: </strong> In this example, the occurrences of <code>&#39;?&#39;</code> can be replaced to make <code>s</code> equal to <code>&quot;abac&quot;</code>.</p>

<p>For <code>&quot;abac&quot;</code>, <code>cost(0) = 0</code>, <code>cost(1) = 0</code>, <code>cost(2) = 1</code>, and <code>cost(3) = 0</code>.</p>

<p>The value of <code>&quot;abac&quot;</code> is&nbsp;<code>1</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either a lowercase English letter or <code>&#39;?&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/right-triangles/description" target="_blank" rel="noopener noreferrer">Right Triangles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D boolean matrix <code>grid</code>.</p>

<p>A collection of 3 elements of <code>grid</code> is a <strong>right triangle</strong> if one of its elements is in the <strong>same row</strong> with another element and in the <strong>same column</strong> with the third element. The 3 elements may <strong>not</strong> be next to each other.</p>

<p>Return an integer that is the number of <strong>right triangles</strong> that can be made with 3 elements of <code>grid</code> such that <strong>all</strong> of them have a value of 1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div style="display:flex; gap: 12px;">
<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
	</tbody>
</table>

<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
	</tbody>
</table>

<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid blue; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid blue; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid blue; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
	</tbody>
</table>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,0],[0,1,1],[0,1,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>There are two right triangles with elements of the value 1. Notice that the blue ones do <strong>not&nbsp;</strong>form a right triangle because the 3 elements are in the same column.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div style="display:flex; gap: 12px;">
<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid blue; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid blue; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid blue; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
	</tbody>
</table>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>There are no right triangles with elements of the value 1. &nbsp;Notice that the blue ones do <strong>not</strong> form a right triangle.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div style="display:flex; gap: 12px;">
<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
	</tbody>
</table>

<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
		<tr>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid silver; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
		</tr>
	</tbody>
</table>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,1],[1,0,0],[1,0,0]]</span></p>

<p><strong>Output: </strong>2</p>

<p><strong>Explanation:</strong></p>

<p>There are two right triangles with elements of the value 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length &lt;= 1000</code></li>
	<li><code>1 &lt;= grid[i].length &lt;= 1000</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rle-iterator/description" target="_blank" rel="noopener noreferrer">RLE Iterator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">design</span> <span class="topic-badge">iterator</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We can use run-length encoding (i.e., <strong>RLE</strong>) to encode a sequence of integers. In a run-length encoded array of even length <code>encoding</code> (<strong>0-indexed</strong>), for all even <code>i</code>, <code>encoding[i]</code> tells us the number of times that the non-negative integer value <code>encoding[i + 1]</code> is repeated in the sequence.</p>

<ul>
	<li>For example, the sequence <code>arr = [8,8,8,5,5]</code> can be encoded to be <code>encoding = [3,8,2,5]</code>. <code>encoding = [3,8,0,9,2,5]</code> and <code>encoding = [2,8,1,8,2,5]</code> are also valid <strong>RLE</strong> of <code>arr</code>.</li>
</ul>

<p>Given a run-length encoded array, design an iterator that iterates through it.</p>

<p>Implement the <code>RLEIterator</code> class:</p>

<ul>
	<li><code>RLEIterator(int[] encoded)</code> Initializes the object with the encoded array <code>encoded</code>.</li>
	<li><code>int next(int n)</code> Exhausts the next <code>n</code> elements and returns the last element exhausted in this way. If there is no element left to exhaust, return <code>-1</code> instead.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;RLEIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]
[[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]]
<strong>Output</strong>
[null, 8, 8, 5, -1]

<strong>Explanation</strong>
RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5].
rLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5].
rLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5].
rLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5].
rLEIterator.next(2); // exhausts 2 terms, returning -1. This is because the first term exhausted was 5,
but the second term did not exist. Since the last term exhausted does not exist, we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= encoding.length &lt;= 1000</code></li>
	<li><code>encoding.length</code> is even.</li>
	<li><code>0 &lt;= encoding[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>1000</code> calls will be made to <code>next</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sender-with-largest-word-count/description" target="_blank" rel="noopener noreferrer">Sender With Largest Word Count</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a chat log of <code>n</code> messages. You are given two string arrays <code>messages</code> and <code>senders</code> where <code>messages[i]</code> is a <strong>message</strong> sent by <code>senders[i]</code>.</p>

<p>A <strong>message</strong> is list of <strong>words</strong> that are separated by a single space with no leading or trailing spaces. The <strong>word count</strong> of a sender is the total number of <strong>words</strong> sent by the sender. Note that a sender may send more than one message.</p>

<p>Return <em>the sender with the <strong>largest</strong> word count</em>. If there is more than one sender with the largest word count, return <em>the one with the <strong>lexicographically largest</strong> name</em>.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>Uppercase letters come before lowercase letters in lexicographical order.</li>
	<li><code>&quot;Alice&quot;</code> and <code>&quot;alice&quot;</code> are distinct.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> messages = [&quot;Hello userTwooo&quot;,&quot;Hi userThree&quot;,&quot;Wonderful day Alice&quot;,&quot;Nice day userThree&quot;], senders = [&quot;Alice&quot;,&quot;userTwo&quot;,&quot;userThree&quot;,&quot;Alice&quot;]
<strong>Output:</strong> &quot;Alice&quot;
<strong>Explanation:</strong> Alice sends a total of 2 + 3 = 5 words.
userTwo sends a total of 2 words.
userThree sends a total of 3 words.
Since Alice has the largest word count, we return &quot;Alice&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> messages = [&quot;How is leetcode for everyone&quot;,&quot;Leetcode is useful for practice&quot;], senders = [&quot;Bob&quot;,&quot;Charlie&quot;]
<strong>Output:</strong> &quot;Charlie&quot;
<strong>Explanation:</strong> Bob sends a total of 5 words.
Charlie sends a total of 5 words.
Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == messages.length == senders.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= messages[i].length &lt;= 100</code></li>
	<li><code>1 &lt;= senders[i].length &lt;= 10</code></li>
	<li><code>messages[i]</code> consists of uppercase and lowercase English letters and <code>&#39; &#39;</code>.</li>
	<li>All the words in <code>messages[i]</code> are separated by <strong>a single space</strong>.</li>
	<li><code>messages[i]</code> does not have leading or trailing spaces.</li>
	<li><code>senders[i]</code> consists of uppercase and lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-palindromic-rearrangement-ii/description" target="_blank" rel="noopener noreferrer">Smallest Palindromic Rearrangement II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">combinatorics</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="332" data-start="99">You are given a <strong><span data-keyword="palindrome-string">palindromic</span></strong> string <code>s</code> and an integer <code>k</code>.</p>

<p>Return the <strong>k-th</strong> <strong><span data-keyword="lexicographically-smaller-string">lexicographically smallest</span></strong> palindromic <span data-keyword="permutation-string">permutation</span> of <code>s</code>. If there are fewer than <code>k</code> distinct palindromic permutations, return an empty string.</p>

<p><strong>Note:</strong> Different rearrangements that yield the same palindromic string are considered identical and are counted once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abba&quot;, k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;baab&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The two distinct palindromic rearrangements of <code>&quot;abba&quot;</code> are <code>&quot;abba&quot;</code> and <code>&quot;baab&quot;</code>.</li>
	<li>Lexicographically, <code>&quot;abba&quot;</code> comes before <code>&quot;baab&quot;</code>. Since <code>k = 2</code>, the output is <code>&quot;baab&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;aa&quot;, k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>There is only one palindromic rearrangement: <code data-end="1112" data-start="1106">&quot;aa&quot;</code>.</li>
	<li>The output is an empty string since <code>k = 2</code> exceeds the number of possible rearrangements.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;bacab&quot;, k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;abcba&quot;</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The two distinct palindromic rearrangements of <code>&quot;bacab&quot;</code> are <code>&quot;abcba&quot;</code> and <code>&quot;bacab&quot;</code>.</li>
	<li>Lexicographically, <code>&quot;abcba&quot;</code> comes before <code>&quot;bacab&quot;</code>. Since <code>k = 1</code>, the output is <code>&quot;abcba&quot;</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>s</code> is guaranteed to be palindromic.</li>
	<li><code>1 &lt;= k &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-characters-by-frequency/description" target="_blank" rel="noopener noreferrer">Sort Characters By Frequency</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bucket-sort</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, sort it in <strong>decreasing order</strong> based on the <strong>frequency</strong> of the characters. The <strong>frequency</strong> of a character is the number of times it appears in the string.</p>

<p>Return <em>the sorted string</em>. If there are multiple answers, return <em>any of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;tree&quot;
<strong>Output:</strong> &quot;eert&quot;
<strong>Explanation:</strong> &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.
So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cccaaa&quot;
<strong>Output:</strong> &quot;aaaccc&quot;
<strong>Explanation:</strong> Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.
Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;Aabb&quot;
<strong>Output:</strong> &quot;bbAa&quot;
<strong>Explanation:</strong> &quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.
Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists of uppercase and lowercase English letters and digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sorted-gcd-pair-queries/description" target="_blank" rel="noopener noreferrer">Sorted GCD Pair Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and an integer array <code>queries</code>.</p>

<p>Let <code>gcdPairs</code> denote an array obtained by calculating the <span data-keyword="gcd-function">GCD</span> of all possible pairs <code>(nums[i], nums[j])</code>, where <code>0 &lt;= i &lt; j &lt; n</code>, and then sorting these values in <strong>ascending</strong> order.</p>

<p>For each query <code>queries[i]</code>, you need to find the element at index <code>queries[i]</code> in <code>gcdPairs</code>.</p>

<p>Return an integer array <code>answer</code>, where <code>answer[i]</code> is the value at <code>gcdPairs[queries[i]]</code> for each query.</p>

<p>The term <code>gcd(a, b)</code> denotes the <strong>greatest common divisor</strong> of <code>a</code> and <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4], queries = [0,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs = [gcd(nums[0], nums[1]), gcd(nums[0], nums[2]), gcd(nums[1], nums[2])] = [1, 2, 1]</code>.</p>

<p>After sorting in ascending order, <code>gcdPairs = [1, 1, 2]</code>.</p>

<p>So, the answer is <code>[gcdPairs[queries[0]], gcdPairs[queries[1]], gcdPairs[queries[2]]] = [1, 2, 2]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,4,2,1], queries = [5,3,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,2,1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs</code> sorted in ascending order is <code>[1, 1, 1, 2, 2, 4]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,2], queries = [0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs = [2]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= queries[i] &lt; n * (n - 1) / 2</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-integers-by-the-number-of-1-bits/description" target="_blank" rel="noopener noreferrer">Sort Integers by The Number of 1 Bits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">counting</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>arr</code>. Sort the integers in the array&nbsp;in ascending order by the number of <code>1</code>&#39;s&nbsp;in their binary representation and in case of two or more integers have the same number of <code>1</code>&#39;s you have to sort them in ascending order.</p>

<p>Return <em>the array after sorting it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [0,1,2,3,4,5,6,7,8]
<strong>Output:</strong> [0,1,2,4,8,3,5,6,7]
<strong>Explantion:</strong> [0] is the only integer with 0 bits.
[1,2,4,8] all have 1 bit.
[3,5,6] have 2 bits.
[7] has 3 bits.
The sorted array by bits is [0,1,2,4,8,3,5,6,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1024,512,256,128,64,32,16,8,4,2,1]
<strong>Output:</strong> [1,2,4,8,16,32,64,128,256,512,1024]
<strong>Explantion:</strong> All integers have 1 bit in the binary representation, you should just sort them in ascending order.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 500</code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sort-by-custom-comparator-built-in">Approach 1: Sort By Custom Comparator: Built-in</h3>
<p><strong>Intuition</strong></p>
<p>The number of <code>1's</code> in a number's binary representation is also known as the number of <strong>set</strong> bits, or the <a href="https://en.wikipedia.org/wiki/Hamming_weight">hamming weight</a> of the number.</p>
<p>In this problem, we need to sort the numbers according to their hamming weight. We can sort arrays by any criteria using a custom comparator, which is a function that we pass into a language's sort function to specify how elements should be sorted.</p>
<p>There are a number of ways to find the hamming weight of a number, but the easiest way is by using built-in methods.</p>
<blockquote>
<p>Note: we have included this approach for completeness. It is likely that in an interview, you will be expected to use bit manipulation to find the hamming weight, and simply using built-in methods may be considered &quot;cheating&quot;.</p>
</blockquote>
<p>Most major programming languages have a built-in method for finding the hamming weight of a number. We simply define a custom comparator using these methods, then sort the input with it, and return the answer. Remember to handle the tiebreak: when two numbers have equal hamming weight, the one with a lower value should come first.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Use built-in methods to define a custom comparator that uses the hamming weight of a number.</li>
<li>Sort <code>arr</code> with the custom comparator.</li>
<li>Return <code>arr</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/4dYZ9SpT/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>arr</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{n})\)</span></p>
<p>Finding the hamming weight of a number is dependent on the size of a number, but as we are dealing with integers that have a fixed size (31 bits), we can consider it as an <span class="math inline">\(O(1)\)</span> operation. Sorting <code>arr</code> costs <span class="math inline">\(O(n \cdot \log{n})\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log n)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language:</p>
<ul>
<li>In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span></li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-bit-manipulation">Approach 2: Bit Manipulation</h3>
<p><strong>Intuition</strong></p>
<p>This approach is the same as the previous one, except we will now obtain the hamming weight of each number using bit manipulation instead of built-in methods, which is what most interviewers will be expecting.</p>
<details>
    <summary>
        <b> &ensp; If you aren't familiar with bit manipulation and the operations used in bit manipulation, please click to expand. </b>
    </summary>
<br />
<p>Bit manipulation is the act of manipulating bits, like changing bits of an integer.<br />
At the heart of bit manipulation are the bit-wise operators:</p>
<p><strong>NOT (~):</strong> Bitwise NOT is a unary operator that flips the bits of the number i.e., if the current bit is <span class="math inline">\(0\)</span>, it will change it to <span class="math inline">\(1\)</span> and vice versa.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>N = 5 = 101 (in binary)
</span></span><span style="display:flex;"><span>~N = ~(101) = 010 = 2 (in decimal)
</span></span></code></pre><p><strong>AND (&amp;):</strong> In bitwise AND if both bits in the compared position of the bit patterns are <span class="math inline">\(1\)</span>, the bit in the resulting bit pattern is <span class="math inline">\(1\)</span>, otherwise <span class="math inline">\(0\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 5 = 101 (in binary) 
</span></span><span style="display:flex;"><span>B = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A &amp; B = 101 &amp; 001 = 001 = 1 (in decimal)
</span></span></code></pre><p><strong>OR ( | ):</strong> Bitwise OR is also similar to bitwise AND. If both bits in the compared position of the bit patterns are <span class="math inline">\(0\)</span>, the bit in the resulting bit pattern is <span class="math inline">\(0\)</span>, otherwise <span class="math inline">\(1\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 5 = 101 (in binary) 
</span></span><span style="display:flex;"><span>B = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A | B = 101 | 001 = 101 = 5 (in decimal)
</span></span></code></pre><p><strong>XOR (^):</strong> In bitwise XOR if both bits are <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>, the result will be <span class="math inline">\(0\)</span>, otherwise <span class="math inline">\(1\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 5 = 101 (in binary) 
</span></span><span style="display:flex;"><span>B = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A ^ B = 101 ^ 001 = 100 = 4 (in decimal)
</span></span></code></pre><p><strong>Left Shift (&lt;&lt;):</strong> Left shift operator is a binary operator which shifts some number of bits to the left and appends <span class="math inline">\(0\)</span> at the end. One left shift is equivalent to multiplying the bit pattern with <span class="math inline">\(2\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 1 = 001 (in binary) 
</span></span><span style="display:flex;"><span>A &lt;&lt; 1 = 001 &lt;&lt; 1 = 010 = 2 (in decimal)
</span></span><span style="display:flex;"><span>A &lt;&lt; 2 = 001 &lt;&lt; 2 = 100 = 4 (in decimal)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B = 5 = 00101 (in binary)
</span></span><span style="display:flex;"><span>B &lt;&lt; 1 = 00101 &lt;&lt; 1 = 01010 = 10 (in decimal)
</span></span><span style="display:flex;"><span>B &lt;&lt; 2 = 00101 &lt;&lt; 2 = 10100 = 20 (in decimal)
</span></span></code></pre><p><strong>Right Shift (&gt;&gt;):</strong> Right shift operator is a binary operator which shifts some number of bits to the right and appends <span class="math inline">\(0\)</span> at the left side. One right shift is equivalent to dividing the bit pattern with <span class="math inline">\(2\)</span>.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>A = 4 = 100 (in binary) 
</span></span><span style="display:flex;"><span>A &gt;&gt; 1 = 100 &gt;&gt; 1 = 010 = 2 (in decimal)
</span></span><span style="display:flex;"><span>A &gt;&gt; 2 = 100 &gt;&gt; 2 = 001 = 1 (in decimal)
</span></span><span style="display:flex;"><span>A &gt;&gt; 3 = 100 &gt;&gt; 3 = 000 = 0 (in decimal)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>B = 5 = 00101 (in binary)
</span></span><span style="display:flex;"><span>B &gt;&gt; 1 = 00101 &gt;&gt; 1 = 00010 = 2 (in decimal)
</span></span></code></pre></details>
<br /> 
<p>To find the hamming weight of a number, we can use what is called a <strong>mask</strong>. This mask will have a single set bit, initially the least significant one (representing the number <code>1</code>, at position <code>0</code>). We will AND this mask with the number, and if the result is non-zero, it means the bit is set in the number. We can thus increment the hamming weight by 1 and then continue to the next position by left-shifting the mask, which moves the single bit over to the next position (this is the same as multiplying it by two).</p>
<p>There are two ways we can end this process.</p>
<ol>
<li>Iterate 31 times (since this is the maximum size of an integer)</li>
<li>When we find a set bit in the number, flip it to a 0 (with XOR). When the number becomes 0, then we know there are no more set bits and can end.</li>
</ol>
<p>The second option is better since we will terminate as soon as possible, whereas the first option will always iterate 31 times, regardless of the size of the number. We will proceed with the second option. The following animation illustrates this process:</p>
<p>!?!../Documents/1356.json:960,540!?!<br />
<br><br />
<br></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findWeight</code> that takes an integer <code>num</code> and returns its hamming weight.
<ul>
<li>Initialize <code>mask = 1</code> and <code>weight = 0</code></li>
<li>While <code>num &gt; 0</code>:
<ul>
<li>Check if <code>num &amp; mask</code> is non-zero. If so, increment <code>weight</code> and XOR <code>num</code> with <code>mask</code></li>
<li>Left shift <code>mask</code></li>
</ul>
</li>
<li>Return <code>weight</code></li>
</ul>
</li>
<li>Create a custom comparator with <code>findWeight</code>. Sort <code>arr</code> with the custom comparator.</li>
<li>Return <code>arr</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/a8EYPSyq/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>arr</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>Finding the hamming weight of a number is dependent on the size of a number, but as we are dealing with integers that have a fixed size (31 bits), we can consider it as an <span class="math inline">\(O(1)\)</span> operation. Sorting <code>arr</code> costs <span class="math inline">\(O(n \cdot \log{n})\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log n)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language:</p>
<ul>
<li>In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span></li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-brian-kerninghans-algorithm">Approach 3: Brian Kerninghan's Algorithm</h3>
<p><strong>Intuition</strong></p>
<p>There is a better way to find the hamming weight of a number. Brian Kerninghan's algorithm is an elegant and efficient way to find the number of set bits in a number.</p>
<p>For a given <code>num</code>, we run the algorithm until <code>num = 0</code>, that is the algorithm runs until there are no more set bits. At each iteration, we remove the least significant bit in <code>num</code>. Once all the bits are removed, <code>num = 0</code> and the algorithm terminates. The number of iterations is the number of set bits since we remove one bit per iteration.</p>
<p>So how do we remove the least significant bit (LSB)? All we need to do is AND <code>num</code> with <code>num - 1</code>. That is, <code>num &amp;= (num - 1)</code>.</p>
<p>Why does this work? Take a look at the following image.</p>
<p><img src="../Figures/1356/7.png" alt="kerninghan algorithm" /><br />
<br></p>
<p>Logically, every bit to the right of the LSB will be 0. That means when we subtract <code>1</code> from <code>num</code>, the LSB becomes <code>0</code> and every bit to the right of it becomes <code>1</code>.</p>
<blockquote>
<p>In the image, the first 3 positions go from <code>100</code> to <code>011</code>. If the LSB was in position <code>5</code>, it would go from <code>10000</code> to <code>01111</code>.</p>
</blockquote>
<p>In <code>num</code>, every bit to the right of the LSB is <code>0</code>. In <code>num - 1</code>, every bit to the right of the LSB is <code>1</code>. Thus, after an AND operation, every bit to the right of the LSB will remain <code>0</code>, since <code>0 &amp; 1 = 0</code>.</p>
<p>The LSB itself will also become <code>0</code> since it's <code>1</code> in <code>num</code> and <code>0</code> in <code>num - 1</code>.</p>
<p>Finally, everything to the left of the LSB is completely unchanged when subtracting by <code>1</code>. Thus, performing <code>num &amp; (num - 1)</code> will not change any of these bits, and the only net change is that the LSB was set to <code>0</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findWeight</code> that takes an integer <code>num</code> and returns its hamming weight using Brian Kerninghan's algorithm.
<ul>
<li>Initialize <code>weight = 0</code></li>
<li>While <code>num &gt; 0</code>:
<ul>
<li>Increment <code>weight</code></li>
<li>Set <code>num</code> to <code>num &amp; (num - 1)</code></li>
</ul>
</li>
<li>Return <code>weight</code></li>
</ul>
</li>
<li>Create a custom comparator with <code>findWeight</code>. Sort <code>arr</code> with the custom comparator.</li>
<li>Return <code>arr</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/ai2Z3h9R/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>arr</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>Finding the hamming weight of a number is dependent on the size of a number, but as we are dealing with integers that have a fixed size (31 bits), we can consider it as an <span class="math inline">\(O(1)\)</span> operation. Sorting <code>arr</code> costs <span class="math inline">\(O(n \cdot \log{n})\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log n)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language:</p>
<ul>
<li>In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span></li>
</ul>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-a-string-in-balanced-strings/description" target="_blank" rel="noopener noreferrer">Split a String in Balanced Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><strong>Balanced</strong> strings are those that have an equal quantity of <code>&#39;L&#39;</code> and <code>&#39;R&#39;</code> characters.</p>

<p>Given a <strong>balanced</strong> string <code>s</code>, split it into some number of substrings such that:</p>

<ul>
	<li>Each substring is balanced.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of balanced strings you can obtain.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;RLRRLLRLRL&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> s can be split into &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;RLRRRLLRLL&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> s can be split into &quot;RL&quot;, &quot;RRRLLRLL&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;.
Note that s cannot be split into &quot;RL&quot;, &quot;RR&quot;, &quot;RL&quot;, &quot;LR&quot;, &quot;LL&quot;, because the 2<sup>nd</sup> and 5<sup>th</sup> substrings are not balanced.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;LLLLRRRR&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> s can be split into &quot;LLLLRRRR&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s[i]</code> is either <code>&#39;L&#39;</code> or <code>&#39;R&#39;</code>.</li>
	<li><code>s</code> is a <strong>balanced</strong> string.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-the-array/description" target="_blank" rel="noopener noreferrer">Split the Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of <strong>even</strong> length. You have to split the array into two parts <code>nums1</code> and <code>nums2</code> such that:</p>

<ul>
	<li><code>nums1.length == nums2.length == nums.length / 2</code>.</li>
	<li><code>nums1</code> should contain <strong>distinct </strong>elements.</li>
	<li><code>nums2</code> should also contain <strong>distinct</strong> elements.</li>
</ul>

<p>Return <code>true</code><em> if it is possible to split the array, and </em><code>false</code> <em>otherwise</em><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,2,3,4]
<strong>Output:</strong> true
<strong>Explanation:</strong> One of the possible ways to split nums is nums1 = [1,2,3] and nums2 = [1,2,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1]
<strong>Output:</strong> false
<strong>Explanation:</strong> The only possible way to split nums is nums1 = [1,1] and nums2 = [1,1]. Both nums1 and nums2 do not contain distinct elements. Therefore, we return false.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>nums.length % 2 == 0 </code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stone-game-ix/description" target="_blank" rel="noopener noreferrer">Stone Game IX</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array <code>stones</code>, where <code>stones[i]</code> is the <strong>value</strong> of the <code>i<sup>th</sup></code> stone.</p>

<p>Alice and Bob take turns, with <strong>Alice</strong> starting first. On each turn, the player may remove any stone from <code>stones</code>. The player who removes a stone <strong>loses</strong> if the <strong>sum</strong> of the values of <strong>all removed stones</strong> is divisible by <code>3</code>. Bob will win automatically if there are no remaining stones (even if it is Alice&#39;s turn).</p>

<p>Assuming both players play <strong>optimally</strong>, return <code>true</code> <em>if Alice wins and</em> <code>false</code> <em>if Bob wins</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stones = [2,1]
<strong>Output:</strong> true
<strong>Explanation:</strong>&nbsp;The game will be played as follows:
- Turn 1: Alice can remove either stone.
- Turn 2: Bob removes the remaining stone. 
The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stones = [2]
<strong>Output:</strong> false
<strong>Explanation:</strong>&nbsp;Alice will remove the only stone, and the sum of the values on the removed stones is 2. 
Since all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> stones = [5,1,2,4,3]
<strong>Output:</strong> false
<strong>Explanation:</strong> Bob will always win. One possible way for Bob to win is shown below:
- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.
- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.
- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.
- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.
- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.
Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarrays-with-k-different-integers/description" target="_blank" rel="noopener noreferrer">Subarrays with K Different Integers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sliding-window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of <strong>good subarrays</strong> of </em><code>nums</code>.</p>

<p>A <strong>good array</strong> is an array where the number of different integers in that array is exactly <code>k</code>.</p>

<ul>
	<li>For example, <code>[1,2,3,1,2]</code> has <code>3</code> different integers: <code>1</code>, <code>2</code>, and <code>3</code>.</li>
</ul>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,3], k = 2
<strong>Output:</strong> 7
<strong>Explanation:</strong> Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,3,4], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i], k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of integers <code>nums</code> and an integer <code>k</code>. The task is to count the number of contiguous subarrays that contain exactly <code>k</code> distinct integers.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>A &quot;good subarray&quot; is defined as a contiguous subarray that contains exactly <code>k</code> distinct elements.</li>
<li>There can be duplicate elements present in the <code>nums</code> array.</li>
</ol>
<hr />
<h3 id="approach-1-sliding-window">Approach 1: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force method involves finding all the subarrays and then selecting those subarrays that have exactly <code>k</code> distinct integers. However, this approach becomes costly in terms of time complexity, reaching <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For a more efficient approach, let's use the sliding window pattern. This pattern can be applied when the problem entails achieving a goal using subarrays, and individual elements cannot be independently selected.</p>
<p>The concept behind the sliding window pattern is to maintain a window that continuously expands from the right by adding elements until the condition is met. Once the condition is satisfied, we adjust the window by shrinking it from the left until the condition is met again.</p>
<p>For each valid window, we can calculate the total number of subarrays it can form using the formula <code>right - left + 1</code>. This represents the number of subarrays ending at the current element (<code>right</code>) and starting anywhere from the current left boundary (<code>left</code>) to the right pointer (<code>right</code>) (inclusive).</p>
<p>Once the window contains more than <code>k</code> distinct elements, we start shrinking it from the left side. We remove the element at the leftmost position and update the set of distinct elements. This process continues until the window size becomes valid again for the condition.</p>
<p>Another crucial realization is that the subarrays exceeding the <code>k</code> distinct integers are irrelevant to our objective. We focus on subarrays whose distinct integers are either equal to <code>k</code> or less than <code>k</code>.</p>
<p>The calculation <code>right - left + 1</code>, counts the subarrays with at most <code>k</code> distinct integers.</p>
<p>After calculating the total count of subarrays with distinct integers less than or equal to <code>k</code> using <code>slidingWindowAtMost(nums, k)</code>, we need to isolate the subarrays that strictly meet the target <code>k</code>.</p>
<p>This can be achieved by subtracting the total count of subarrays with distinct integers less than <code>k</code> (<code>slidingWindowAtMost(nums, k - 1)</code>) from the total count obtained earlier. By subtracting the latter from the former, we essentially remove the subarrays that don't reach <code>k</code> and are left with only the subarrays that have exactly <code>k</code> distinct integers.</p>
<p>Consider <code>nums = [1, 2, 1, 2, 3]</code> and <code>k = 2</code>.</p>
<p><code>slidingWindowAtMost(nums, 2)</code> will count all subarrays (12) with at most 2 distinct elements (including those with exactly 2 and 1).<br />
<code>slidingWindowAtMost(nums, 1)</code> will count all subarrays (5) with at most 1 distinct element.</p>
<p>The difference, <code>slidingWindowAtMost(nums, 2) - slidingWindowAtMost(nums, 1)</code>, removes subarrays with 1 distinct element, leaving only those with exactly 2, which is our answer (7).</p>
<p>Refer to the visual slideshow demonstrating the sliding window on <code>slidingWindowAtMost(nums, k)</code>.</p>
<p>!?!../Documents/992_re/atmostk.json:1010,570!?!</p>
<p>Now, refer to the visual slideshow demonstrating the sliding window on <code>slidingWindowAtMost(nums, k - 1)</code>.</p>
<p>!?!../Documents/992_re/atmostk_1.json:1010,510!?!</p>
<p>Refer to the below Venn diagram for a better understanding of how subtracting <code>slidingWindowAtMost(nums, k - 1)</code> from <code>slidingWindowAtMost(nums, k)</code> gives exactly <code>k</code> distinct elements.</p>
<p><img src="../Figures/992_re/atmost_venn_diagram.png" alt="img" /></p>
<h4 id="algorithm">Algorithm</h4>
<p>The <code>slidingWindowAtMost</code> function is responsible for counting the subarrays with at most <code>distinctK</code> distinct elements.</p>
<ul>
<li>Initialize an empty <code>freqMap</code> to store the frequency of elements in the current window.</li>
<li>Initialize <code>left</code> and <code>totalCount</code> to 0.</li>
<li>Iterate through the <code>nums</code> array using the <code>right</code> pointer:
<ul>
<li>Increment the frequency of <code>nums[right]</code> in the <code>freqMap</code>.</li>
<li>While the size of <code>freqMap</code> (the number of distinct elements) is greater than <code>distinctK</code>:
<ul>
<li>Decrement the frequency of <code>nums[left]</code> in the <code>freqMap</code>.</li>
<li>If the frequency of <code>nums[left]</code> becomes 0, remove it from the <code>freqMap</code>.</li>
<li>Increment <code>left</code> to shrink the window.</li>
</ul>
</li>
<li>Add <code>right - left + 1</code> to <code>totalCount</code>. This counts the number of subarrays ending at <code>right</code> with at most <code>distinctK</code> distinct elements.</li>
</ul>
</li>
<li>Return <code>totalCount</code>.</li>
</ul>
<p>The <code>subarraysWithKDistinct</code> function calls the <code>slidingWindowAtMost</code> function twice, once with <code>k</code> and once with <code>k - 1</code>, and subtracts the result of the latter from the result of the former to get the exact <code>k</code> distinct elements.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MkLvTfUd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>n</code> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The time complexity is <span class="math inline">\(O(n)\)</span> because the <code>slidingWindowAtMost</code> function iterates through the array once using the sliding window technique, and each element is processed at most twice (once when it enters the window and once when it exits the window). Inside the loop, the operations of updating the frequency map and shrinking the window take <span class="math inline">\(O(1)\)</span> time on average, assuming the underlying hash table implementation has constant-time operations. Therefore, the overall time complexity is linear with respect to the size of the input array.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> due to the use of the <code>freqMap</code> to store the frequency of elements in the current window. In the worst case, when all elements in the array are distinct, the <code>freqMap</code> will store all the elements, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>It's important to note that the space complexity is also affected by the underlying implementation of the hash table used for the <code>freqMap</code>. Some implementations may have additional overhead, leading to a slightly higher space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sliding-window-in-one-pass">Approach 2: Sliding Window in One Pass</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When we create a subarray with an element, we can add <code>k - 1</code> additional distinct elements to the subarray without invalidating it.</p>
<p>If we subtract <code>1</code> from <code>k</code> when we encounter a new element, when <code>k</code> becomes zero, it means we have exactly <code>k</code> distinct elements in the current window. At this point, we need to count the number of valid subarrays we can form with these <code>k</code> distinct elements within the window.</p>
<p>However, if <code>k</code> becomes negative, it indicates that there are more than <code>k</code> distinct elements in the current window. We need to adjust the window from the left side by moving the left pointer and reducing the frequency of <code>nums[left]</code> until the number of distinct elements is valid again (equal to <code>k</code>).</p>
<p>If there are duplicates of <code>nums[left]</code> within the current window, we need to keep shrinking the window from the left side until the frequency of <code>nums[left]</code> is zero. This is crucial because we need to maintain the correct count of distinct elements within the window.</p>
<p>Now if <code>k</code> has become 0 and if the frequency of <code>nums[left]</code> is greater than 1, it means there are duplicates of the current left. For each duplicate, we increment <code>currCount</code>, which represents the number of subarrays that can be formed by including these duplicates along with the distinct elements in the current window.</p>
<p>Once we find the smallest subarray with exactly <code>k</code> distinct elements, we can add <code>currCount + 1</code> to <code>totalCount</code>. The 1 is added to include the current subarray formed by the <code>k</code> distinct elements within the window.</p>
<p>By continuously adjusting the window and counting subarrays when we have exactly <code>k</code> distinct elements, we can find the total count of valid subarrays with at most <code>k</code> distinct elements in just a single pass.</p>
<p>Refer to the visual slideshow demonstrating the sliding window in one pass.</p>
<p>!?!../Documents/992_re/onepass_re.json:1015,700!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize an array <code>distinctCount</code> of size <code>nums.size() + 1</code> to store the count of distinct values encountered.</p>
</li>
<li>
<p>Initialize <code>totalCount</code> to 0, which will store the total count of subarrays with <code>k</code> distinct elements.</p>
</li>
<li>
<p>Initialize <code>left</code> and <code>right</code> pointers to 0, representing the sliding window.</p>
</li>
<li>
<p>Initialize <code>currCount</code> to 0, which will store the count of subarrays with the current distinct elements.</p>
</li>
<li>
<p>Start the sliding window approach by iterating through the <code>nums</code> array using the <code>right</code> pointer:</p>
<ul>
<li>Increment the count of the element at <code>nums[right]</code> in the <code>distinctCount</code> array.</li>
<li>If the count changes from 0 to 1, it means a new distinct element is encountered, so decrement <code>k</code>.</li>
<li>If <code>k</code> becomes negative, it means there are more than <code>k</code> distinct elements in the current window:
<ul>
<li>Move the <code>left</code> pointer until the count of distinct elements becomes valid again by decrementing the count of <code>nums[left]</code> in the <code>distinctCount</code> array and incrementing <code>k</code>.</li>
<li>Reset <code>currCount</code> to 0.</li>
</ul>
</li>
<li>If <code>k</code> becomes 0, it means there are exactly <code>k</code> distinct elements in the current window:
<ul>
<li>While there are duplicate elements (count &gt; 1) in the window, move the <code>left</code> pointer, decrement the count of <code>nums[left]</code> in the <code>distinctCount</code> array, and increment <code>currCount</code>.</li>
<li>Add <code>currCount + 1</code> to <code>totalCount</code>.</li>
</ul>
</li>
<li>Increment <code>right</code> to move the sliding window.</li>
</ul>
</li>
<li>
<p>After the loop, return <code>totalCount</code>, which holds the total count of subarrays with <code>k</code> distinct elements.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nA6bcnFy/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The time complexity is <span class="math inline">\(O(n)\)</span> because the algorithm iterates through the array once using the sliding window technique, and each element is processed at most twice (once when it enters the window and once when it exits the window), resulting in linear time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is also <span class="math inline">\(O(n)\)</span> because the algorithm uses a mapping array to store the count of distinct elements encountered in the current window. In the worst case, this array can grow to the size of the input array; hence, the space complexity is linear with respect to the size of the input.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subdomain-visit-count/description" target="_blank" rel="noopener noreferrer">Subdomain Visit Count</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A website domain <code>&quot;discuss.leetcode.com&quot;</code> consists of various subdomains. At the top level, we have <code>&quot;com&quot;</code>, at the next level, we have <code>&quot;leetcode.com&quot;</code>&nbsp;and at the lowest level, <code>&quot;discuss.leetcode.com&quot;</code>. When we visit a domain like <code>&quot;discuss.leetcode.com&quot;</code>, we will also visit the parent domains <code>&quot;leetcode.com&quot;</code> and <code>&quot;com&quot;</code> implicitly.</p>

<p>A <strong>count-paired domain</strong> is a domain that has one of the two formats <code>&quot;rep d1.d2.d3&quot;</code> or <code>&quot;rep d1.d2&quot;</code> where <code>rep</code> is the number of visits to the domain and <code>d1.d2.d3</code> is the domain itself.</p>

<ul>
	<li>For example, <code>&quot;9001 discuss.leetcode.com&quot;</code> is a <strong>count-paired domain</strong> that indicates that <code>discuss.leetcode.com</code> was visited <code>9001</code> times.</li>
</ul>

<p>Given an array of <strong>count-paired domains</strong> <code>cpdomains</code>, return <em>an array of the <strong>count-paired domains</strong> of each subdomain in the input</em>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cpdomains = [&quot;9001 discuss.leetcode.com&quot;]
<strong>Output:</strong> [&quot;9001 leetcode.com&quot;,&quot;9001 discuss.leetcode.com&quot;,&quot;9001 com&quot;]
<strong>Explanation:</strong> We only have one website domain: &quot;discuss.leetcode.com&quot;.
As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cpdomains = [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]
<strong>Output:</strong> [&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]
<strong>Explanation:</strong> We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times.
For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= cpdomain.length &lt;= 100</code></li>
	<li><code>1 &lt;= cpdomain[i].length &lt;= 100</code></li>
	<li><code>cpdomain[i]</code> follows either the <code>&quot;rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>.d3<sub>i</sub>&quot;</code> format or the <code>&quot;rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>&quot;</code> format.</li>
	<li><code>rep<sub>i</sub></code> is an integer in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>d1<sub>i</sub></code>, <code>d2<sub>i</sub></code>, and <code>d3<sub>i</sub></code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-hash-map">Approach 1: Hash Map</h3>
<p>The algorithm is straightforward: we just do what the problem statement tells us to do.</p>
<p>For an address like <code>a.b.c</code>, we will count <code>a.b.c</code>, <code>b.c</code>, and <code>c</code>.  For an address like <code>x.y</code>, we will count <code>x.y</code> and <code>y</code>.</p>
<p>To count these strings, we will use a hash map.  To split the strings into the required pieces, we will use library <code>split</code> functions.</p>
<p><a href="https://leetcode.com/playground/AA3Vw3MK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of domain strings in the input array <code>cpdomains</code>, and <span class="math inline">\(m\)</span> be the maximum number of fragments in any domain.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The outer loop iterates over each string in <code>cpdomains</code>, which takes <span class="math inline">\(O(n)\)</span> time. For each string, <code>split(&quot;\\s+&quot;)</code> is used to separate the count from the domain name, which takes <span class="math inline">\(O(1)\)</span> time. Then, <code>split(&quot;\\.&quot;)</code> is used to split the domain into fragments. The number of fragments is proportional to <span class="math inline">\(m\)</span> (e.g., &quot;mail.google.com&quot; splits into 3 parts). This splitting takes <span class="math inline">\(O(m)\)</span> time.</p>
<p>The inner loop constructs subdomains by iterating over the fragments in reverse order. For each subdomain, it updates the count in the map, which also takes <span class="math inline">\(O(m)\)</span> time since updating and retrieving from the <code>HashMap</code> is <span class="math inline">\(O(1)\)</span>.</p>
<p>Therefore, the total time for each domain string is <span class="math inline">\(O(m)\)</span>, and for all <span class="math inline">\(n\)</span> domain strings, the overall time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The <code>counts</code> map stores up to <span class="math inline">\(O(n \cdot m)\)</span> subdomains because, for each domain in <code>cpdomains</code>, there can be up to <span class="math inline">\(m\)</span> subdomains.</p>
<p>The <code>ans</code> stores at most <span class="math inline">\(O(n \cdot m)\)</span> results, as each subdomain and its associated count is stored as a string.</p>
<p>The temporary arrays <code>cpinfo</code> and <code>frags</code> each take <span class="math inline">\(O(m)\)</span> space for each iteration, but they are not cumulative since they are overwritten in each iteration.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/substrings-of-size-three-with-distinct-characters/description" target="_blank" rel="noopener noreferrer">Substrings of Size Three with Distinct Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">sliding-window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A string is <strong>good</strong> if there are no repeated characters.</p>

<p>Given a string <code>s</code>​​​​​, return <em>the number of <strong>good substrings</strong> of length <strong>three </strong>in </em><code>s</code>​​​​​​.</p>

<p>Note that if there are multiple occurrences of the same substring, every occurrence should be counted.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;xyzzaz&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> There are 4 substrings of size 3: &quot;xyz&quot;, &quot;yzz&quot;, &quot;zza&quot;, and &quot;zaz&quot;. 
The only good substring of length 3 is &quot;xyz&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aababcabc&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 7 substrings of size 3: &quot;aab&quot;, &quot;aba&quot;, &quot;bab&quot;, &quot;abc&quot;, &quot;bca&quot;, &quot;cab&quot;, and &quot;abc&quot;.
The good substrings are &quot;abc&quot;, &quot;bca&quot;, &quot;cab&quot;, and &quot;abc&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code>​​​​​​ consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-beauty-of-all-substrings/description" target="_blank" rel="noopener noreferrer">Sum of Beauty of All Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>beauty</strong> of a string is the difference in frequencies between the most frequent and least frequent characters.</p>

<ul>
	<li>For example, the beauty of <code>&quot;abaacc&quot;</code> is <code>3 - 1 = 2</code>.</li>
</ul>

<p>Given a string <code>s</code>, return <em>the sum of <strong>beauty</strong> of all of its substrings.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabcb&quot;
<strong>Output:</strong> 5
<strong>Explanation: </strong>The substrings with non-zero beauty are [&quot;aab&quot;,&quot;aabc&quot;,&quot;aabcb&quot;,&quot;abcb&quot;,&quot;bcb&quot;], each with beauty equal to 1.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabcbaa&quot;
<strong>Output:</strong> 17
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;=<sup> </sup>500</code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-digit-differences-of-all-pairs/description" target="_blank" rel="noopener noreferrer">Sum of Digit Differences of All Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> consisting of <strong>positive</strong> integers where all integers have the <strong>same</strong> number of digits.</p>

<p>The <strong>digit difference</strong> between two integers is the <em>count</em> of different digits that are in the <strong>same</strong> position in the two integers.</p>

<p>Return the <strong>sum</strong> of the <strong>digit differences</strong> between <strong>all</strong> pairs of integers in <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [13,23,12]</span></p>

<p><strong>Output:</strong> 4</p>

<p><strong>Explanation:</strong><br />
We have the following:<br />
- The digit difference between <strong>1</strong>3 and <strong>2</strong>3 is 1.<br />
- The digit difference between 1<strong>3</strong> and 1<strong>2</strong> is 1.<br />
- The digit difference between <strong>23</strong> and <strong>12</strong> is 2.<br />
So the total sum of digit differences between all pairs of integers is <code>1 + 1 + 2 = 4</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [10,10,10,10]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong><br />
All the integers in the array are the same. So the total sum of digit differences between all pairs of integers will be 0.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt; 10<sup>9</sup></code></li>
	<li>All integers in <code>nums</code> have the same number of digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-prefix-scores-of-strings/description" target="_blank" rel="noopener noreferrer">Sum of Prefix Scores of Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>words</code> of size <code>n</code> consisting of <strong>non-empty</strong> strings.</p>

<p>We define the <strong>score</strong> of a string <code>term</code> as the <strong>number</strong> of strings <code>words[i]</code> such that <code>term</code> is a <strong>prefix</strong> of <code>words[i]</code>.</p>

<ul>
	<li>For example, if <code>words = [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;cab&quot;]</code>, then the score of <code>&quot;ab&quot;</code> is <code>2</code>, since <code>&quot;ab&quot;</code> is a prefix of both <code>&quot;ab&quot;</code> and <code>&quot;abc&quot;</code>.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the <strong>sum</strong> of scores of every <strong>non-empty</strong> prefix of </em><code>words[i]</code>.</p>

<p><strong>Note</strong> that a string is considered as a prefix of itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abc&quot;,&quot;ab&quot;,&quot;bc&quot;,&quot;b&quot;]
<strong>Output:</strong> [5,4,3,2]
<strong>Explanation:</strong> The answer for each string is the following:
- &quot;abc&quot; has 3 prefixes: &quot;a&quot;, &quot;ab&quot;, and &quot;abc&quot;.
- There are 2 strings with the prefix &quot;a&quot;, 2 strings with the prefix &quot;ab&quot;, and 1 string with the prefix &quot;abc&quot;.
The total is answer[0] = 2 + 2 + 1 = 5.
- &quot;ab&quot; has 2 prefixes: &quot;a&quot; and &quot;ab&quot;.
- There are 2 strings with the prefix &quot;a&quot;, and 2 strings with the prefix &quot;ab&quot;.
The total is answer[1] = 2 + 2 = 4.
- &quot;bc&quot; has 2 prefixes: &quot;b&quot; and &quot;bc&quot;.
- There are 2 strings with the prefix &quot;b&quot;, and 1 string with the prefix &quot;bc&quot;.
The total is answer[2] = 2 + 1 = 3.
- &quot;b&quot; has 1 prefix: &quot;b&quot;.
- There are 2 strings with the prefix &quot;b&quot;.
The total is answer[3] = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abcd&quot;]
<strong>Output:</strong> [4]
<strong>Explanation:</strong>
&quot;abcd&quot; has 4 prefixes: &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, and &quot;abcd&quot;.
Each prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-tries">Approach: Tries</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given an array of strings called <code>words</code>. Our task is to find the score for each string, where the score is defined as the number of times a string appears as a prefix for all strings in <code>words</code>. We need to return an array where each element is the total score of the corresponding string in <code>words</code>.</p>
<p>One way to approach this is by using a hashmap to store the frequency of each prefix. We would count how often each prefix appears and then sum these counts for each string. However, this method can be improved with a trie data structure.</p>
<p>A trie, or prefix tree, helps in searching for prefixes efficiently. If you are not familiar with tries, it would be useful to review an introduction to tries, such as the one in the <a href="https://leetcode.com/problems/implement-trie-prefix-tree/solution">Implement trie prefix tree</a>. For now, we'll assume you have a basic understanding of tries.</p>
<p>A trie is a tree where each node represents a character. The path from the root to a leaf node forms a complete word. This structure is effective for problems involving prefix matching because all descendants of a node share the same prefix. This aligns with our goal of counting matching prefixes.</p>
<p>To implement this, we start by building a trie and inserting each prefix of every string into the trie, character by character. We will keep track of how many times each prefix appears.</p>
<p><img src="../Figures/2416/Slide2.png" alt="fig" /></p>
<p>We need to find the total of all these counts for all prefixes of every string in <code>words</code>. Therefore, we can iterate through the <code>words</code> array, iterate through the prefixes of all strings, appending one character at a time, and calculate the running sum for the count value of these prefixes. Store these running sum values in an array and return it as the answer. Checkout the example below to understand the counting process:</p>
<p><img src="../Figures/2416/Slide1.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<p><code>TrieNode Structure</code></p>
<ul>
<li>Each <code>TrieNode</code> has two properties:
<ul>
<li><code>next</code>: An array of size 26 (for lowercase English letters) to store pointers to child nodes.</li>
<li><code>cnt</code>: An integer value initialized to <code>0</code> to store the count of words that pass through the node.</li>
</ul>
</li>
<li>The constructor initializes all elements in the <code>next</code> array to <code>null</code> and <code>cnt</code> to <code>0</code>.</li>
</ul>
<p><code>Insert(string word)</code></p>
<ul>
<li>Starts from the <code>root</code> node.</li>
<li>For each character <code>c</code> in the word:
<ul>
<li>Calculate the index corresponding to the character (<code>c - 'a'</code>).</li>
<li>If the child node at the calculated index doesn't exist, create a new <code>TrieNode</code> and assign it to that index.</li>
<li>Increment the count (<code>cnt</code>) for the child node.</li>
<li>Move to the child node.</li>
</ul>
</li>
</ul>
<p><code>Count(string s)</code></p>
<ul>
<li>Starts iterating from the <code>root</code> node.</li>
<li>Initialize an integer <code>ans</code> to store the sum of prefix counts.</li>
<li>For each character <code>c</code> in the string <code>s</code>:
<ul>
<li>Calculate the index corresponding to the character (<code>c - 'a'</code>).</li>
<li>Add the <code>cnt</code> value of the child node at the calculated index to <code>ans</code>.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
<p><code>Main function - sumPrefixScores(words)</code></p>
<ul>
<li>For each <code>word</code> in <code>words</code>:
<ul>
<li>Call <code>Insert(word)</code>.</li>
</ul>
</li>
<li>Initialize an array <code>scores</code> of size equal to the number of words, with all elements set to <code>0</code>.</li>
<li>For each <code>word</code> in <code>words</code>:
<ul>
<li>Store <code>Count(word)</code> in <code>scores[i]</code>.</li>
</ul>
</li>
<li>Return the <code>scores</code> array.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/25cczCT5/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>words</code> array, and <span class="math inline">\(M\)</span> be the average length of the strings in <code>words</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot M)\)</span></p>
<p>The insert operation takes <span class="math inline">\(O(length)\)</span> time for a string of size <code>length</code>. The total time taken to perform the insert operations on the strings of the <code>words</code> array is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>Similarly, the count operation takes <span class="math inline">\(O(length)\)</span> time for a string of size <code>length</code>. The total time taken to perform the count operations on the strings of the <code>words</code> array is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot M)\)</span></p>
<p>The insert operation takes <span class="math inline">\(O(length)\)</span> space for a string of size <code>length</code>. The total space taken to perform the insert operations on the strings of the <code>words</code> array is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
<p>The count operation does not use any additional space. Therefore, the total time complexity is given by <span class="math inline">\(O(N \cdot M)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-unique-elements/description" target="_blank" rel="noopener noreferrer">Sum of Unique Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. The unique elements of an array are the elements that appear <strong>exactly once</strong> in the array.</p>

<p>Return <em>the <strong>sum</strong> of all the unique elements of </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The unique elements are [1,3], and the sum is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no unique elements, and the sum is 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> 15
<strong>Explanation:</strong> The unique elements are [1,2,3,4,5], and the sum is 15.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/task-scheduler/description" target="_blank" rel="noopener noreferrer">Task Scheduler</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of CPU <code>tasks</code>, each labeled with a letter from A to Z, and a number <code>n</code>. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there&#39;s a constraint: there has to be a gap of <strong>at least</strong> <code>n</code> intervals between two tasks with the same label.</p>

<p>Return the <strong>minimum</strong> number of CPU intervals required to complete all tasks.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
font-family: Menlo,sans-serif;
font-size: 0.85rem;
">8</span></p>

<p><strong>Explanation:</strong> A possible sequence is: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p>

<p>After completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3<sup>rd</sup> interval, neither A nor B can be done, so you idle. By the 4<sup>th</sup> interval, you can do A again as 2 intervals have passed.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">tasks = [&quot;A&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;,&quot;B&quot;], n = 1</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">6</span></p>

<p><strong>Explanation:</strong> A possible sequence is: A -&gt; B -&gt; C -&gt; D -&gt; A -&gt; B.</p>

<p>With a cooling interval of 1, you can repeat a task after just one other task.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;, &quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 3</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">10</span></p>

<p><strong>Explanation:</strong> A possible sequence is: A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B.</p>

<p>There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tasks.length &lt;= 10<sup>4</sup></code></li>
	<li><code>tasks[i]</code> is an uppercase English letter.</li>
	<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given characters, which are tasks to be scheduled in the CPU. The objective is to find the minimum time required to complete all tasks while including a cooldown period between two identical tasks. The cooldown period is represented by a non-negative integer <code>n</code>. During each unit of time, the CPU can either complete a task or stay idle. The goal is to optimize the schedule to minimize the total time required to process all the tasks.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>Tasks represented by the same character are considered identical.</li>
<li>Repeated tasks should be at least <code>n</code> intervals apart from each other because of the cooling time.</li>
<li>You can put the idle time effectively in between two repetative tasks to schedule them.</li>
</ol>
<p>Checkout the below visual of example 1 from the problem description:</p>
<p><img src="../Figures/621_fix/overiew.png" alt="overview" /></p>
<p>The result is 8 intervals, which is calculated by tasks + idle time (6 + 2). The problem involves finding how much idle time is required to complete the tasks.</p>
<p>All approaches use a greedy strategy, meaning decisions are made step by step, focusing on what seems best in the moment to reach the overall best solution. To show that this type of approach works well, let's use some illustrations. We can prove its effectiveness by showing what happens if we assume the opposite and reach a contradiction.</p>
<p>Using the examples below, we can demonstrate that selecting the task with the lowest frequency increases idle time for the scheduler, thereby failing to maximize efficiency. Conversely, choosing tasks with higher frequencies maximizes efficiency.</p>
<p><img src="../Figures/621_fix/contradiction.png" alt="contradiction" /></p>
<p>The Greedy approach optimizes efficiency by prioritizing tasks based on their frequency, thereby reducing intervals and minimizing idle time for the scheduler. This strategy ultimately leads to the maximization of overall efficiency.</p>
<p><img src="../Figures/621_fix/greedy_works.png" alt="greedy_works" /></p>
<blockquote>
<p>After finishing this problem, take a shot at <a href="https://leetcode.com/problems/task-scheduler-ii/">Task Scheduler II</a> for a deeper understanding of recognizing patterns.</p>
</blockquote>
<hr />
<h3 id="approach-1-using-priority-queue--max-heap">Approach 1: Using Priority Queue / Max Heap</h3>
<h4 id="intuition">Intuition</h4>
<p>To count the occurrences of each task while prioritizing those with the highest frequency, we use a frequency map and a max heap (priority queue).</p>
<p>In each iteration, a cycle of length <code>n + 1</code> is considered, signifying the time needed to execute tasks without violating the cooling period constraint. For instance, if there are 2 tasks (<code>A</code>) and <code>n = 2</code>, the iterations required would be <code>A-Idle-Idle-A</code> (<code>n + 1</code> iterations before picking a new task <code>A</code>).</p>
<p>During each iteration:</p>
<ul>
<li>Tasks with the highest frequency are popped from the max heap. In the case of frequency ties, any tied task can be chosen.</li>
<li>The chosen task's frequency is reduced by 1. If remaining occurrences exist, they are added to a temporary array.</li>
<li>This process continues until the cycle is completed.</li>
</ul>
<p>After completing the cycle:</p>
<ul>
<li>The temporary array is used to rebuild the heap with updated frequencies of tasks encountered during the cycle. This ensures that updated frequencies are preserved when tasks are popped from the heap.</li>
</ul>
<p>Post-cycle processing:</p>
<ul>
<li>A counter (<code>time</code>) is incremented by the actual number of tasks processed in the current cycle (<code>taskCount</code>).</li>
<li>If the heap is not empty, extra idle <code>time</code> (<code>n + 1</code>) is added to account for the cooling period (n cycles + 1 extra idle time).</li>
<li>If the heap is empty, only the remaining tasks in the cycle need consideration (<code>taskCount</code>).</li>
</ul>
<p>This process is repeated until the heap is empty. The <code>time</code> variable is incremented by the actual number of tasks processed in each cycle, with adjustments for idle time when required.</p>
<h5 id="for-a-better-understanding-of-the-intuition-let-us-view-an-example">For a better understanding of the intuition let us view an example:</h5>
<p>Given a task list (e.g., <code>['A', 'A', 'A', 'B', 'B', 'B']</code>) and a cooldown period <code>n</code> (e.g., 2), we aim to minimize the idle time during task execution.</p>
<ol>
<li>Create a frequency map (<code>freq</code>) to track task occurrences: <code>{'A': 3, 'B': 3}</code>.</li>
<li>Initialize a max heap (<code>pq</code>) with frequencies: <code>[3, 3]</code>.</li>
<li>Define the cycle length as <code>n + 1</code> (e.g., <code>2 + 1 = 3</code>) to avoid violating the cooldown idle period.</li>
</ol>
<h5 id="cycle-repetition">Cycle Repetition:</h5>
<p>Repeat cycles until the heap is empty:</p>
<ul>
<li>In the first cycle, choose 'A' and 'B', resulting in <code>[2, 2]</code>.</li>
<li>Rebuild heap: <code>[2, 2]</code>, and increment time: 2 tasks processed + cooldown idle.</li>
<li>In the second cycle, choose 'A' and 'B' again, resulting in <code>[1, 1]</code>.</li>
<li>Rebuild heap: <code>[1, 1]</code>, and increment time: 2 tasks processed + cooldown idle.</li>
<li>Continue cycles until the heap is empty.</li>
</ul>
<p>The accumulated time spent on tasks and idle periods gives the final result: <code>3 + 3 + 2 = 8</code> (A-B-IDLE-A-B-IDLE-A-B).</p>
<p>The following is an illustration demonstrating the above max heap example:</p>
<p><img src="../Figures/621_fix/maxheap.png" alt="maxheap" /></p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize an array <code>freq</code> of size 26 to store the frequency of each task.</li>
<li>Iterate through the <code>tasks</code> array and update the frequency of each task in the <code>freq</code> array.</li>
<li>Create a priority queue <code>pq</code> and insert the frequencies of the tasks into the queue.</li>
<li>Initialize a variable <code>time</code> to keep track of the total time taken.</li>
<li>While the priority queue is not empty, repeat the following steps:
<ul>
<li>Initialize a variable <code>cycle</code> to <code>n + 1</code>, which represents the cooling interval plus one (for the current task).</li>
<li>Initialize an empty array <code>store</code> to store frequencies of tasks that still need to be processed.</li>
<li>Initialize a variable <code>taskCount</code> to keep track of the number of tasks processed in the current cycle.</li>
<li>While <code>cycle</code> is greater than 0 and the priority queue is not empty, repeat the following steps:
<ul>
<li>Decrement <code>cycle</code>.</li>
<li>Pop the top element (<code>task</code> frequency) from the priority queue.</li>
<li>If the popped frequency is greater than 1, decrement it by 1 and store it in the <code>store</code> array.</li>
<li>Increment <code>taskCount</code> as it keeps track of the number of tasks processed in the current cycle.</li>
</ul>
</li>
<li>After processing tasks in the cycle, restore the updated frequencies (stored in the <code>store</code> array) back to the priority queue.</li>
<li>Update the <code>time</code> by adding either <code>taskCount</code> (if the priority queue is empty) or <code>n + 1</code> (cooling interval) to the total time.</li>
</ul>
</li>
<li>Finally, return the total <code>time</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: In Python 3, frequencies are stored as negative values to simulate a max-heap behavior.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/HZxtkVcr/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let the number of tasks be <span class="math inline">\(N\)</span>. Let <span class="math inline">\(k\)</span> be the size of the priority queue. <span class="math inline">\(k\)</span> can, at maximum, be 26 because the priority queue stores the frequency of each distinct task, which is represented by the letters A to Z.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>In the worst case, all tasks must be processed, and each task might be inserted and extracted from the priority queue. The priority queue operations (insertion and extraction) have a time complexity of <span class="math inline">\(O(\log k)\)</span> each. Therefore, the overall time complexity is <span class="math inline">\(O(N \cdot \log k)\)</span>. Since <span class="math inline">\(k\)</span> is at maximum 26, <span class="math inline">\(\log k\)</span> is a constant term. We can simplify the time complexity to <span class="math inline">\(O(N)\)</span>. This is a linear time complexity with a high constant factor.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(26)\)</span> = <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is mainly determined by the frequency array and the priority queue. The frequency array has a constant size of 26, and the priority queue can have a maximum size of 26 when all distinct tasks are present. Therefore, the overall space complexity is <span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(26)\)</span>, which is considered constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-filling-the-slots-and-sorting">Approach 2: Filling the Slots and Sorting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We need to find the minimum time required to complete all tasks given the constraint that at least <code>n</code> units of time must elapse between two identical tasks. To minimize the time, we should first consider scheduling the most frequent tasks so that they are separated by <code>n</code> units of time. Then, we can fill the idle slots with the remaining tasks.</p>
<h5 id="example">Example:</h5>
<p>Consider the task list <code>['A', 'A', 'A', 'B', 'B', 'B']</code> with <code>n = 2</code>.</p>
<ol>
<li>Calculate the frequency array: <code>[3, 3, 0, ..., 0]</code>, as 'A' appears 3 times and 'B' appears 3 times.</li>
<li>Sort the frequency array in ascending order: <code>[0, 0, ..., 3, 3]</code>.</li>
<li>Calculate <code>maxFreq</code> as <code>freq[25] - 1</code>. In this case, <code>maxFreq = 3 - 1 = 2</code>.</li>
<li>Calculate the number of idle slots: <code>idleSlots = maxFreq * n = 2 * 2 = 4</code>.</li>
<li>The loop starts from the second highest frequency (index 24 in the sorted array) and goes down to the lowest frequency. This ensures that the highest frequency task's idle slots are considered only once, as it was accounted for when calculating <code>maxFreq</code> in the earlier step.</li>
<li>In each iteration, subtract the minimum of <code>maxFreq</code> and the current frequency from <code>idleSlots</code>. For the first iteration, subtract <code>min(2, 2) = 2</code> from <code>idleSlots</code>, resulting in <code>idleSlots = 4 - 2 = 2</code>.</li>
<li>If <code>idleSlots &gt; 0</code>, add the remaining idle slots to the total number of tasks. In this example, there are 2 idle slots, so the final result is obtained by adding these idle slots (2) to the total number of tasks (6).</li>
<li>Thus, the minimum time required to complete all tasks, considering the cooldown period, is <code>8</code>.</li>
</ol>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Create a <code>freq</code> array of size 26 to keep track of the count of each task.</li>
<li>Iterate through the <code>tasks</code> array and update the frequency array with the frequency of each task.</li>
<li>Sort the frequency array in non-decreasing order (ascending order = smallest to largest). This is done to process tasks with higher frequencies first.</li>
<li>Calculate the maximum frequency of the most frequent task. Subtract 1 because we want to find the number of intervals, not the number of occurrences.</li>
<li>Calculate the number of <code>idleSlots</code> that will be required by multiplying the maximum frequency by the cooldown period.</li>
<li>Iterate over the frequency array from the second highest frequency to the lowest frequency.
<ul>
<li>Subtract the minimum of the maximum frequency and the current frequency from the <code>idleSlots</code>.</li>
</ul>
</li>
<li>If there are any <code>idleSlots</code> left, add them to the total number of tasks and return this as the answer. Otherwise, return the total number of tasks.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/CzQYBKg3/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let the number of tasks be <span class="math inline">\(N\)</span>. There are up to 26 distinct tasks because the tasks are represented by the letters A to Z.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The time complexity of the algorithm is <span class="math inline">\(O(26 \log 26 + N)\)</span>, where <span class="math inline">\(26 \log 26\)</span> is the time complexity of sorting the frequency array, and <span class="math inline">\(N\)</span> is the length of the input task list, which is the dominating term.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(26) = O(1)\)</span></p>
<p>The frequency array has a size of <span class="math inline">\(26\)</span>.</p>
<p>Note that some extra space is used when we sort arrays in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(N)\)</span> additional space.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log N )\)</span> for sorting array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log N )\)</span>.</li>
</ul>
<p>We sort the frequency array, which has a size of <span class="math inline">\(26\)</span>. The space used for sorting takes <span class="math inline">\(O(26)\)</span> or <span class="math inline">\(O(\log 26)\)</span>, which is constant, so the space complexity of the algorithm is <span class="math inline">\(O(26)\)</span>, which is constant, i.e. <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-greedy-approach">Approach 3: Greedy Approach</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The key is to determine the required number of idle intervals. Let's start by exploring how to arrange tasks. It is apparent that a &quot;greedy arrangement&quot; works well: always arrange tasks with the highest frequency first. The goal is to arrange tasks with the highest frequency first, ensuring that they are separated by at least <code>n</code> units of time.</p>
<h5 id="step-1-task-arrangement">Step 1: Task Arrangement</h5>
<p>For instance, if tasks are <code>[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;]</code> with <code>n = 2</code>, the initial arrangement would be:</p>
<p>A _ _ A _ _ A      (&quot;_&quot; denotes empty slots)</p>
<p>The same approach can be applied to arrange B. The final schedule would look like this:</p>
<p>A B _ A B _ A</p>
<p>After arranging B tasks, we have 2 empty slots, but only one task remains. We can place task C and IDLE time in those slots.</p>
<p>A B C A B _ A</p>
<p>The final schedule could be:</p>
<p>A B C A B IDLE A</p>
<h5 id="step-2-calculate-idle-intervals">Step 2: Calculate Idle Intervals</h5>
<p>Now that we have a method for arranging tasks, the next step is to calculate the total number of idle intervals required. The solution to the problem is the sum of idle intervals and the number of tasks.</p>
<p>Consider the same example of tasks: <code>[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;]</code> with <code>n = 2</code>. After arranging A, we get:<br />
A _ _ A _ _ A</p>
<p>Observe that A separates the empty slots into <code>(count(A) - 1)</code> = 2 parts, each with a length of <code>n</code>. A has the highest frequency, so it requires more idle intervals than any other task.</p>
<p>To calculate parts, empty slots, and available tasks:</p>
<ol>
<li>Find the number of parts separated by A: <code>partCount = count(A) - 1</code>.</li>
<li>Determine the number of empty slots: <code>emptySlots = partCount * n</code>.</li>
<li>Identify the number of tasks to be placed into those slots: <code>availableTasks = tasks.length - count(A)</code>.</li>
</ol>
<p>If <code>emptySlots &gt; availableTasks</code>, indicating insufficient tasks to fill all empty slots, the remaining slots are filled with idle intervals: <code>idles = max(0, emptySlots - availableTasks)</code>.</p>
<h5 id="special-case">Special Case:</h5>
<p>A special case arises when there is more than one task with the highest frequency. For instance, with <code>[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;,&quot;C&quot;,&quot;D&quot;]</code> and <code>n = 3</code>, arranging A results in:<br />
A _ _ _ A _ _ _ A</p>
<p>When arranging B, it becomes evident that each B must follow each A. Considering &quot;A B&quot; as a special task &quot;X,&quot; the arrangement becomes:<br />
X _ _ X _ _ X</p>
<p>In this case, the calculations for parts, empty slots, and available tasks are adjusted:</p>
<ul>
<li><code>partCount = count(A) - 1</code></li>
<li><code>emptySlots = partCount * (n - (count of tasks with the highest frequency - 1))</code></li>
<li><code>availableTasks = tasks.length - count(A) * count of tasks with the highest frequency</code></li>
</ul>
<p>If <code>emptySlots</code> is negative, it means there are already enough tasks to make the &quot;distance&quot; between the same tasks longer than <code>n</code>, and no idle intervals are needed. In this case, <code>idles = max(0, emptySlots - availableTasks)</code> provides the time it takes to complete the tasks.</p>
<p>The final result is then calculated as <code>result = tasks.length + idles</code>.</p>
<p>The visuals below provide an illustration of a general case where all tasks have different frequencies.</p>
<p><img src="../Figures/621_fix/greedy_ex1.png" alt="greedy_ex1" /></p>
<p>The visuals below illustrate a special case where more than one task occurs with the highest frequency.</p>
<p><img src="../Figures/621_fix/greedy_ex2.png" alt="greedy_ex2" /></p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a <code>counter</code> array of size 26 to store the frequency of each task and variables <code>maximum</code> and <code>maxCount</code> to track the maximum frequency and the number of tasks with that frequency.</li>
<li>Traverse through the <code>tasks</code> and update the <code>counter</code> array. If the frequency of a task is equal to the current maximum frequency, increment <code>maxCount</code>. If the frequency is greater than the current maximum frequency, update <code>maximum</code> and set <code>maxCount</code> to 1.</li>
<li>Calculate the number of <code>emptySlots</code> by multiplying <code>partCount</code> <code>(maximum - 1)</code> and <code>partLength</code> <code>(n - (maxCount - 1))</code>.</li>
<li>Calculate the number of <code>availableTasks</code> by subtracting the product of <code>maximum</code> and <code>maxCount</code> from the total number of tasks.</li>
<li>Calculate the number of <code>idles</code> periods needed by taking the maximum of 0 and the difference between the number of <code>emptySlots</code> and the number of <code>availableTasks</code>.</li>
<li>Return the total time required by adding the number of tasks to the number of <code>idles</code> periods.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<blockquote>
<p><strong>Note:</strong> A more concise way of calculating the return value is <code>max(tasks.length, (n + 1) * (max-1) + maxCount)</code>. We have used the below method instead for the sake of readability.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/gExdf5Qa/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of tasks.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>To obtain count(A) and the count of tasks with the highest frequency, we iterate through the inputs, calculating counts for each distinct character. This process has a time complexity of <span class="math inline">\(O(N)\)</span>. All other operations have a time complexity of <span class="math inline">\(O(1)\)</span>, resulting in an overall time complexity of <span class="math inline">\(O(N)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(26)\)</span> = <span class="math inline">\(O(1)\)</span></p>
<p>The array <code>count</code> is size <span class="math inline">\(26\)</span> because the tasks are represented by the letters A to Z. No data structures that vary with input size are used, resulting in an overall space complexity of <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-using-math-formula">Approach 4: Using Math Formula</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Each occurrence of task X takes one CPU cycle. There are <code>(maxCountX - 1)</code> scheduled occurrences, and between each two consecutive occurrences, there are at least <code>N</code> CPU cycles.</p>
<p>Therefore, the total CPU cycles can be calculated as follows:</p>
<p><span class="math inline">\(Total CPU cycles = (maxCountX - 1) \cdot (N + 1)\)</span></p>
<p><strong>Where:</strong></p>
<ul>
<li><code>(maxCountX - 1)</code> represents the number of occurrences of X scheduled, excluding the last one. We exclude the last occurrence of the repeated task in this term because it doesn't need additional cycles between it and the next task; it's the last task from all the repeated tasks of the same character.</li>
<li><code>(N + 1)</code> represents the CPU cycles required for each occurrence of <code>maxCountX</code>. The element <code>maxCountX</code> itself takes one CPU cycle, and there are at least <code>N</code> additional cycles between each two consecutive occurrences.</li>
</ul>
<p>For example, given tasks <code>[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;, &quot;B&quot;, &quot;C&quot;]</code> and <code>n = 3</code>:</p>
<ul>
<li><code>countA = 3</code>, <code>countB = 3</code>, <code>countC = 1</code>.</li>
<li><code>maxCount = max(countA, countB, countC) = 3</code>.</li>
<li>Scheduling <code>maxCount-1</code> occurrences: <code>Total CPU cycles = (maxCount - 1) * (n + 1) = 8</code>.</li>
<li>Scheduling the final round: <code>Ans = Total CPU cycles + 1</code>, as the last task from all the repeated tasks of the same character is left out, and that task doesn't need <code>N + 1</code> cycles to get completed.</li>
</ul>
<p>If there are multiple elements with a frequency equal to <code>maxCount</code>, add 1 cycle each: <code>Ans += numberOfMaxFrequencyElements = 8 + 2 = 10</code>.</p>
<p>The following illustration provides a clearer insight into the underlying approach:</p>
<p><img src="../Figures/621_fix/math_approach.png" alt="math_approach" /></p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize a frequency array <code>freq</code> with all elements set to 0 and a variable <code>maxCount</code> to 0.</li>
<li>Iterate through the <code>tasks</code> array and update the frequency of each task in the <code>freq</code> array. Update <code>maxCount</code> with the maximum frequency encountered.</li>
<li>Calculate the total time needed for execution by multiplying <code>(maxCount - 1)</code> with <code>(n + 1)</code>.</li>
<li>Iterate through the <code>freq</code> array, and if the frequency of a task is equal to <code>maxCount</code>, increment the total time by 1.</li>
<li>Return the maximum of the total time needed and the length of the tasks array.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/asVJpxgp/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of tasks.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The loop iterating over the tasks array has a time complexity of <span class="math inline">\(O(N)\)</span>. The loop iterating over the <code>freq</code> array has a time complexity proportional to the number of unique tasks, which is at most <span class="math inline">\(26\)</span> because the tasks are represented by the letters A to Z. Therefore, the overall time complexity is <span class="math inline">\(O(N + 26)\)</span>, which simplifies to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(26)\)</span> = <span class="math inline">\(O(1)\)</span></p>
<p>The <code>freq</code> array can store at most <span class="math inline">\(26\)</span> unique tasks, resulting in <span class="math inline">\(O(26)\)</span> space complexity. Other variables used in the algorithm have constant space requirements. Therefore, the overall space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-number-of-good-subsets/description" target="_blank" rel="noopener noreferrer">The Number of Good Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. We call a subset of <code>nums</code> <strong>good</strong> if its product can be represented as a product of one or more <strong>distinct prime</strong> numbers.</p>

<ul>
	<li>For example, if <code>nums = [1, 2, 3, 4]</code>:

	<ul>
		<li><code>[2, 3]</code>, <code>[1, 2, 3]</code>, and <code>[1, 3]</code> are <strong>good</strong> subsets with products <code>6 = 2*3</code>, <code>6 = 2*3</code>, and <code>3 = 3</code> respectively.</li>
		<li><code>[1, 4]</code> and <code>[4]</code> are not <strong>good</strong> subsets with products <code>4 = 2*2</code> and <code>4 = 2*2</code> respectively.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the number of different <strong>good</strong> subsets in </em><code>nums</code><em> <strong>modulo</strong> </em><code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>subset</strong> of <code>nums</code> is any array that can be obtained by deleting some (possibly none or all) elements from <code>nums</code>. Two subsets are different if and only if the chosen indices to delete are different.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The good subsets are:
- [1,2]: product is 2, which is the product of distinct prime 2.
- [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [1,3]: product is 3, which is the product of distinct prime 3.
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [3]: product is 3, which is the product of distinct prime 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,3,15]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The good subsets are:
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.
- [3]: product is 3, which is the product of distinct prime 3.
- [15]: product is 15, which is the product of distinct primes 3 and 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 30</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/threshold-majority-queries/description" target="_blank" rel="noopener noreferrer">Threshold Majority Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and an array <code>queries</code>, where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>, threshold<sub>i</sub>]</code>.</p>

<p>Return an array of integers <code data-end="33" data-start="28">ans</code> where <code data-end="48" data-start="40">ans[i]</code> is equal to the element in the subarray <code data-end="102" data-start="89">nums[l<sub>i</sub>...r<sub>i</sub>]</code> that appears <strong>at least</strong> <code data-end="137" data-start="125">threshold<sub>i</sub></code> times, selecting the element with the <strong>highest</strong> frequency (choosing the <strong>smallest</strong> in case of a tie), or -1 if no such element <em>exists</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2,2,1,1], queries = [[0,5,4],[0,3,3],[2,3,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1,2]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="left" style="border: 1px solid black;">Query</th>
			<th align="left" style="border: 1px solid black;">Sub-array</th>
			<th align="left" style="border: 1px solid black;">Threshold</th>
			<th align="left" style="border: 1px solid black;">Frequency table</th>
			<th align="left" style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 5, 4]</td>
			<td align="left" style="border: 1px solid black;">[1, 1, 2, 2, 1, 1]</td>
			<td align="left" style="border: 1px solid black;">4</td>
			<td align="left" style="border: 1px solid black;">1 &rarr; 4, 2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 3, 3]</td>
			<td align="left" style="border: 1px solid black;">[1, 1, 2, 2]</td>
			<td align="left" style="border: 1px solid black;">3</td>
			<td align="left" style="border: 1px solid black;">1 &rarr; 2, 2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">-1</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[2, 3, 2]</td>
			<td align="left" style="border: 1px solid black;">[2, 2]</td>
			<td align="left" style="border: 1px solid black;">2</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,2,3,2,3,2,3], queries = [[0,6,4],[1,5,2],[2,4,1],[3,3,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,3,2]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="left" style="border: 1px solid black;">Query</th>
			<th align="left" style="border: 1px solid black;">Sub-array</th>
			<th align="left" style="border: 1px solid black;">Threshold</th>
			<th align="left" style="border: 1px solid black;">Frequency table</th>
			<th align="left" style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 6, 4]</td>
			<td align="left" style="border: 1px solid black;">[3, 2, 3, 2, 3, 2, 3]</td>
			<td align="left" style="border: 1px solid black;">4</td>
			<td align="left" style="border: 1px solid black;">3 &rarr; 4, 2 &rarr; 3</td>
			<td align="left" style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[1, 5, 2]</td>
			<td align="left" style="border: 1px solid black;">[2, 3, 2, 3, 2]</td>
			<td align="left" style="border: 1px solid black;">2</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 3, 3 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[2, 4, 1]</td>
			<td align="left" style="border: 1px solid black;">[3, 2, 3]</td>
			<td align="left" style="border: 1px solid black;">1</td>
			<td align="left" style="border: 1px solid black;">3 &rarr; 2, 2 &rarr; 1</td>
			<td align="left" style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[3, 3, 1]</td>
			<td align="left" style="border: 1px solid black;">[2]</td>
			<td align="left" style="border: 1px solid black;">1</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 1</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="51" data-start="19"><code data-end="49" data-start="19">1 &lt;= nums.length == n &lt;= 10<sup>4</sup></code></li>
	<li data-end="82" data-start="54"><code data-end="80" data-start="54">1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li data-end="120" data-start="85"><code data-end="118" data-start="85">1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="195" data-start="123"><code data-end="193" data-is-only-node="" data-start="155">queries[i] = [l<sub>i</sub>, r<sub>i</sub>, threshold<sub>i</sub>]</code></li>
	<li data-end="221" data-start="198"><code data-end="219" data-start="198">0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; n</code></li>
	<li data-end="259" data-is-last-node="" data-start="224"><code data-end="259" data-is-last-node="" data-start="224">1 &lt;= threshold<sub>i</sub> &lt;= r<sub>i</sub> - l<sub>i</sub> + 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/top-k-frequent-elements/description" target="_blank" rel="noopener noreferrer">Top K Frequent Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bucket-sort</span> <span class="topic-badge">counting</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">quickselect</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,1,1,2,2,3], k = 2
<strong>Output:</strong> [1,2]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [1], k = 1
<strong>Output:</strong> [1]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>
	<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Your algorithm&#39;s time complexity must be better than <code>O(n log n)</code>, where n is the array&#39;s size.</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-heap">Approach 1: Heap</h3>
<p>Let's start from the simple <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a> approach with <span class="math inline">\(\mathcal{O}(N \log k)\)</span> time complexity. To ensure that <span class="math inline">\(\mathcal{O}(N \log k)\)</span> is always less than <span class="math inline">\(\mathcal{O}(N \log N)\)</span>, the particular case <span class="math inline">\(k = N\)</span> could be considered separately and solved in <span class="math inline">\(\mathcal{O}(1)\)</span> time.</p>
<p><strong>Algorithm</strong></p>
<ul>
<li>
<p>The first step is to build a hash map <code>element -&gt; its frequency</code>. In Java, we use the data structure <code>HashMap</code>. Python provides a dictionary subclass <code>Counter</code> to initialize the hash map we need directly from the input array. This step takes <span class="math inline">\(\mathcal{O}(N)\)</span> time where <code>N</code> is a number of elements in the list.</p>
</li>
<li>
<p>The second step is to build a heap of <em>size k using N elements</em>. To add the first <code>k</code> elements takes a linear time <span class="math inline">\(\mathcal{O}(k)\)</span> in the average case, and <span class="math inline">\(O(\log 1 + \log 2 + ... + \log k) = O(log k!) = \mathcal{O}(k \log k)\)</span> in the worst case. It's equivalent to <a href="https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l16">heapify implementation in Python</a>. After the first <code>k</code> elements we start to push and pop at each step, <code>N - k</code> steps in total. The time complexity of heap push/pop is <span class="math inline">\(\mathcal{O}(\log k)\)</span> and we do it <code>N - k</code> times which means <span class="math inline">\(\mathcal{O}((N - k)\log k)\)</span> time complexity. Adding both parts up, we get <span class="math inline">\(\mathcal{O}(N \log k)\)</span> time complexity for the second step.</p>
</li>
<li>
<p>The third and last step is to convert the heap into an output array. That could be done in <span class="math inline">\(\mathcal{O}(k \log k)\)</span> time.</p>
</li>
</ul>
<p>In Python, library <code>heapq</code> provides a method <code>nlargest</code>, which <a href="https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l203">combines the last two steps under the hood</a> and has the same <span class="math inline">\(\mathcal{O}(N \log k)\)</span> time complexity.</p>
<p><img src="../Figures/347_rewrite/summary.png" alt="diff" /></p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/3WH339tU/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(\mathcal{O}(N + N \log k)\)</span> if <span class="math inline">\(k < N\)</span> and <span class="math inline">\(\mathcal{O}(1)\)</span> in the particular case of <span class="math inline">\(N = k\)</span>. That ensures time complexity to be better than <span class="math inline">\(\mathcal{O}(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(\mathcal{O}(N + k)\)</span> to store the hash map with not more <span class="math inline">\(N\)</span> elements and a heap with <span class="math inline">\(k\)</span> elements.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-quickselect-hoares-selection-algorithm">Approach 2: Quickselect (Hoare's selection algorithm)</h3>
<p>Quickselect is a <a href="https://en.wikipedia.org/wiki/Quickselect">textbook algorithm</a> typically used to solve the problems &quot;find <code>k</code><em>th</em> something&quot;: <code>k</code><em>th</em> smallest, <code>k</code><em>th</em> largest, <code>k</code><em>th</em> most frequent, <code>k</code><em>th</em> less frequent, etc. Like quicksort, quickselect was developed by <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> and is also known as <em>Hoare's selection algorithm</em>.</p>
<p>It has <span class="math inline">\(\mathcal{O}(N)\)</span> <em>average</em> time complexity and is widely used in practice. It is worth noting that its worst-case time complexity is <span class="math inline">\(\mathcal{O}(N^2)\)</span>, although the probability of this worst-case is negligible.</p>
<p>The approach is the same as for quicksort.</p>
<blockquote>
<p>One chooses a pivot and defines its position in a sorted array in a linear time using the so-called <em>partition algorithm</em>.</p>
</blockquote>
<p>As an output, we have an array where the pivot is in its perfect position in the ascending sorted array, sorted by the frequency. All elements on the left of the pivot are less frequent than the pivot, and all elements on the right are more frequent or have the same frequency.</p>
<p>Hence the array is now split into two parts. If by chance our pivot element took <code>N - k</code><em>th</em> final position, then <span class="math inline">\(k\)</span> elements on the right are these top <span class="math inline">\(k\)</span> frequent we're looking for. If not, we can choose one more pivot and place it in its perfect position.</p>
<p><img src="../Figures/347_rewrite/hoare.png" alt="diff" /></p>
<p>If that were a quicksort algorithm, one would have to process both parts of the array. That would result in <span class="math inline">\(\mathcal{O}(N \log N)\)</span> time complexity. In this case, there is no need to deal with both parts since one knows in which part to search for <code>N - k</code><em>th</em> less frequent element, and that reduces the average time complexity to <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
<p><strong>Algorithm</strong></p>
<p>The algorithm is quite straightforward :</p>
<ul>
<li>
<p>Build a hash map <code>element -&gt; its frequency</code> and convert its keys into the array <code>unique</code> of unique elements. Note that elements are unique, but their frequencies are <em>not</em>. That means we need a partition algorithm that works fine with <em>duplicates</em>.</p>
</li>
<li>
<p>Work with <code>unique</code> array.<br />
Use a partition scheme (please check the next section) to place the pivot into its perfect position <code>pivot_index</code> in the sorted array, move less frequent elements to the left of the pivot, and more frequent or of the same frequency - to the right.</p>
</li>
<li>
<p>Compare <code>pivot_index</code> and <code>N - k</code>.</p>
<ul>
<li>
<p>If <code>pivot_index == N - k</code>, the pivot is <code>N - k</code><em>th</em> most frequent element, and all elements on the right are more frequent or of the same frequency. Return these top <span class="math inline">\(k\)</span> frequent elements.</p>
</li>
<li>
<p>Otherwise, choose the side of the array to proceed recursively.</p>
</li>
</ul>
</li>
</ul>
<p><img src="../Figures/347_rewrite/details.png" alt="diff" /></p>
<p><strong>Lomuto's Partition Scheme</strong></p>
<p>There is a zoo of partition algorithms. The most simple one is <a href="https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme">Lomuto's Partition Scheme</a>, and so is what we will use in this article.</p>
<p>Here is how it works:</p>
<ul>
<li>
<p>Move the pivot at the end of the array using swap.</p>
</li>
<li>
<p>Set the pointer at the beginning of the array <code>store_index = left</code>.</p>
</li>
<li>
<p>Iterate over the array and move all less frequent elements to the left <code>swap(store_index, i)</code>. Move <code>store_index</code> one step to the right after each swap.</p>
</li>
<li>
<p>Move the pivot to its final place, and return this index.</p>
</li>
</ul>
<p>!?!../Documents/347_RES.json:1000,556!?!</p>
<p><a href="https://leetcode.com/playground/56S3UHe5/shared">code</a></p>
<p><strong>Implementation</strong></p>
<p>Here is a total algorithm implementation.</p>
<p><a href="https://leetcode.com/playground/eAsoNpLA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> in the average case,</p>
<p><span class="math display">\[
In the worst case of constantly badly chosen pivots, the problem is not divided by half at each step, it becomes just one element less, which leads to $$\mathcal{O}(N^2)$$ time complexity. It happens, for example, if at each step you choose the pivot not randomly, but take the rightmost element. For the random pivot choice, the probability of having such a worst-case is negligibly small. 

\]</span></p>
</li>
<li>
<p>Space complexity: up to <span class="math inline">\(\mathcal{O}(N)\)</span> to store hash map and array of unique elements.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="further-discussion-could-we-do-worst-case-linear-time">Further Discussion: Could We Do Worst-Case Linear Time?</h3>
<p>In theory, we could, the algorithm is called <a href="https://en.wikipedia.org/wiki/Median_of_medians">Median of Medians</a>.</p>
<p>This method is never used in practice because of two drawbacks:</p>
<ul>
<li>
<p>It's <em>outperformer</em>. Yes, it works in a linear time <span class="math inline">\(\alpha N\)</span>, but the constant <span class="math inline">\(\alpha\)</span> is so large that in practice it often works even slower than <span class="math inline">\(N^2\)</span>.</p>
</li>
<li>
<p>It doesn't work with duplicates.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/top-k-frequent-words/description" target="_blank" rel="noopener noreferrer">Top K Frequent Words</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bucket-sort</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p>

<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2
<strong>Output:</strong> [&quot;i&quot;,&quot;love&quot;]
<strong>Explanation:</strong> &quot;i&quot; and &quot;love&quot; are the two most frequent words.
Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4
<strong>Output:</strong> [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;]
<strong>Explanation:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 500</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li><code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/total-characters-in-string-after-transformations-i/description" target="_blank" rel="noopener noreferrer">Total Characters in String After Transformations I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and an integer <code>t</code>, representing the number of <strong>transformations</strong> to perform. In one <strong>transformation</strong>, every character in <code>s</code> is replaced according to the following rules:</p>

<ul>
	<li>If the character is <code>&#39;z&#39;</code>, replace it with the string <code>&quot;ab&quot;</code>.</li>
	<li>Otherwise, replace it with the <strong>next</strong> character in the alphabet. For example, <code>&#39;a&#39;</code> is replaced with <code>&#39;b&#39;</code>, <code>&#39;b&#39;</code> is replaced with <code>&#39;c&#39;</code>, and so on.</li>
</ul>

<p>Return the <strong>length</strong> of the resulting string after <strong>exactly</strong> <code>t</code> transformations.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong><!-- notionvc: eb142f2b-b818-4064-8be5-e5a36b07557a --> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcyy&quot;, t = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">7</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>First Transformation (t = 1)</strong>:

	<ul>
		<li><code>&#39;a&#39;</code> becomes <code>&#39;b&#39;</code></li>
		<li><code>&#39;b&#39;</code> becomes <code>&#39;c&#39;</code></li>
		<li><code>&#39;c&#39;</code> becomes <code>&#39;d&#39;</code></li>
		<li><code>&#39;y&#39;</code> becomes <code>&#39;z&#39;</code></li>
		<li><code>&#39;y&#39;</code> becomes <code>&#39;z&#39;</code></li>
		<li>String after the first transformation: <code>&quot;bcdzz&quot;</code></li>
	</ul>
	</li>
	<li><strong>Second Transformation (t = 2)</strong>:
	<ul>
		<li><code>&#39;b&#39;</code> becomes <code>&#39;c&#39;</code></li>
		<li><code>&#39;c&#39;</code> becomes <code>&#39;d&#39;</code></li>
		<li><code>&#39;d&#39;</code> becomes <code>&#39;e&#39;</code></li>
		<li><code>&#39;z&#39;</code> becomes <code>&quot;ab&quot;</code></li>
		<li><code>&#39;z&#39;</code> becomes <code>&quot;ab&quot;</code></li>
		<li>String after the second transformation: <code>&quot;cdeabab&quot;</code></li>
	</ul>
	</li>
	<li><strong>Final Length of the string</strong>: The string is <code>&quot;cdeabab&quot;</code>, which has 7 characters.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;azbk&quot;, t = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>First Transformation (t = 1)</strong>:

	<ul>
		<li><code>&#39;a&#39;</code> becomes <code>&#39;b&#39;</code></li>
		<li><code>&#39;z&#39;</code> becomes <code>&quot;ab&quot;</code></li>
		<li><code>&#39;b&#39;</code> becomes <code>&#39;c&#39;</code></li>
		<li><code>&#39;k&#39;</code> becomes <code>&#39;l&#39;</code></li>
		<li>String after the first transformation: <code>&quot;babcl&quot;</code></li>
	</ul>
	</li>
	<li><strong>Final Length of the string</strong>: The string is <code>&quot;babcl&quot;</code>, which has 5 characters.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= t &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-recurrence">Approach: Recurrence</h3>
<h4 id="intuition">Intuition</h4>
<p>We define <span class="math inline">\(f(i, c)\)</span> as the number of occurrences of the character <span class="math inline">\(c\)</span> in the string after <span class="math inline">\(i\)</span> transformations. For sake of clarity and ease of notation, we let <span class="math inline">\(c\)</span> = <span class="math inline">\([0, 26)\)</span>, which corresponds to the 26 characters from <span class="math inline">\(a\)</span> to <span class="math inline">\(z\)</span> in sequence.</p>
<p>Initially, each <span class="math inline">\(f(0, c)\)</span> represents the number of occurrences of <span class="math inline">\(c\)</span> in the given string <span class="math inline">\(s\)</span>. As we iterate from <span class="math inline">\(f(i-1, \cdots)\)</span> to <span class="math inline">\(f(i, \cdots)\)</span>:</p>
<ul>
<li>If <span class="math inline">\(c = 0\)</span>, corresponding to <span class="math inline">\(a\)</span>, it can be converted from <span class="math inline">\(z\)</span>, therefore:
<p><span class="math display">\[f(i, 0) = f(i - 1, 25)
\]</span></p>
<ul>
<li>If <span class="math inline">\(c = 1\)</span>, corresponding to <span class="math inline">\(b\)</span>, it can be converted from <span class="math inline">\(z\)</span> or <span class="math inline">\(a\)</span>, therefore:
<p><span class="math display">\[f(i, 1) = f(i - 1, 25) + f(i - 1, 0)
\]</span></p>
<ul>
<li>If <span class="math inline">\(c \geq 2\)</span>, it can come from the last character conversion, therefore:</li>
</ul>
<p><span class="math display">\[f(i, c) = f(i - 1, c - 1)
\]</span></p>
</li>
</ul>
</li>
</ul>
<p>So we obtain the recursive formula, which can be calculated from <span class="math inline">\(f(1, \cdots)\)</span> all the way to <span class="math inline">\(f(t, \cdots)\)</span>. The sum of all <span class="math inline">\(f(t, c)\)</span> is the final answer.</p>
<h4 id="optimize">Optimize</h4>
<p>Notice that in this recurrence formula, the calculation of <span class="math inline">\(f(i, \cdots)\)</span> only depends on the value of <span class="math inline">\(f(i - 1, \cdots)\)</span>, therefore we can use two one-dimensional arrays instead of the entire two-dimensional array <span class="math inline">\(f\)</span> for recursion, as can be seen in the arrays <span class="math inline">\(\textit{cnt}\)</span> and <span class="math inline">\(\textit{nxt}\)</span> in the following code.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/2PiowyMJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span>, and let <span class="math inline">\(|\Sigma|\)</span> be the size of the character set, which is 26 in this question.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + t|\Sigma|)\)</span>.</p>
<p>We first traverse the string to obtain the count of all characters, and then use the recurrence formula to calculate the count of each character over <span class="math inline">\(t\)</span> transformations.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(|\Sigma|)\)</span>.</p>
<p>This is the space required for two one-dimensional arrays in the recursion.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/total-characters-in-string-after-transformations-ii/description" target="_blank" rel="noopener noreferrer">Total Characters in String After Transformations II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of lowercase English letters, an integer <code>t</code> representing the number of <strong>transformations</strong> to perform, and an array <code>nums</code> of size 26. In one <strong>transformation</strong>, every character in <code>s</code> is replaced according to the following rules:</p>

<ul>
	<li>Replace <code>s[i]</code> with the <strong>next</strong> <code>nums[s[i] - &#39;a&#39;]</code> consecutive characters in the alphabet. For example, if <code>s[i] = &#39;a&#39;</code> and <code>nums[0] = 3</code>, the character <code>&#39;a&#39;</code> transforms into the next 3 consecutive characters ahead of it, which results in <code>&quot;bcd&quot;</code>.</li>
	<li>The transformation <strong>wraps</strong> around the alphabet if it exceeds <code>&#39;z&#39;</code>. For example, if <code>s[i] = &#39;y&#39;</code> and <code>nums[24] = 3</code>, the character <code>&#39;y&#39;</code> transforms into the next 3 consecutive characters ahead of it, which results in <code>&quot;zab&quot;</code>.</li>
</ul>

<p>Return the length of the resulting string after <strong>exactly</strong> <code>t</code> transformations.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcyy&quot;, t = 2, nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">7</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>
	<p><strong>First Transformation (t = 1):</strong></p>

	<ul>
		<li><code>&#39;a&#39;</code> becomes <code>&#39;b&#39;</code> as <code>nums[0] == 1</code></li>
		<li><code>&#39;b&#39;</code> becomes <code>&#39;c&#39;</code> as <code>nums[1] == 1</code></li>
		<li><code>&#39;c&#39;</code> becomes <code>&#39;d&#39;</code> as <code>nums[2] == 1</code></li>
		<li><code>&#39;y&#39;</code> becomes <code>&#39;z&#39;</code> as <code>nums[24] == 1</code></li>
		<li><code>&#39;y&#39;</code> becomes <code>&#39;z&#39;</code> as <code>nums[24] == 1</code></li>
		<li>String after the first transformation: <code>&quot;bcdzz&quot;</code></li>
	</ul>
	</li>
	<li>
	<p><strong>Second Transformation (t = 2):</strong></p>

	<ul>
		<li><code>&#39;b&#39;</code> becomes <code>&#39;c&#39;</code> as <code>nums[1] == 1</code></li>
		<li><code>&#39;c&#39;</code> becomes <code>&#39;d&#39;</code> as <code>nums[2] == 1</code></li>
		<li><code>&#39;d&#39;</code> becomes <code>&#39;e&#39;</code> as <code>nums[3] == 1</code></li>
		<li><code>&#39;z&#39;</code> becomes <code>&#39;ab&#39;</code> as <code>nums[25] == 2</code></li>
		<li><code>&#39;z&#39;</code> becomes <code>&#39;ab&#39;</code> as <code>nums[25] == 2</code></li>
		<li>String after the second transformation: <code>&quot;cdeabab&quot;</code></li>
	</ul>
	</li>
	<li>
	<p><strong>Final Length of the string:</strong> The string is <code>&quot;cdeabab&quot;</code>, which has 7 characters.</p>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;azbk&quot;, t = 1, nums = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>
	<p><strong>First Transformation (t = 1):</strong></p>

	<ul>
		<li><code>&#39;a&#39;</code> becomes <code>&#39;bc&#39;</code> as <code>nums[0] == 2</code></li>
		<li><code>&#39;z&#39;</code> becomes <code>&#39;ab&#39;</code> as <code>nums[25] == 2</code></li>
		<li><code>&#39;b&#39;</code> becomes <code>&#39;cd&#39;</code> as <code>nums[1] == 2</code></li>
		<li><code>&#39;k&#39;</code> becomes <code>&#39;lm&#39;</code> as <code>nums[10] == 2</code></li>
		<li>String after the first transformation: <code>&quot;bcabcdlm&quot;</code></li>
	</ul>
	</li>
	<li>
	<p><strong>Final Length of the string:</strong> The string is <code>&quot;bcabcdlm&quot;</code>, which has 8 characters.</p>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= t &lt;= 10<sup>9</sup></code></li>
	<li><code><font face="monospace">nums.length == 26</font></code></li>
	<li><code><font face="monospace">1 &lt;= nums[i] &lt;= 25</font></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-matrix-multiplication--matrix-exponentiation-by-squaring">Approach: Matrix Multiplication + Matrix Exponentiation By Squaring</h3>
<h4 id="intuition">Intuition</h4>
<p>We use <span class="math inline">\(f(i, c)\)</span> to represent the number of occurrences of the character <span class="math inline">\(c\)</span> in the string after <span class="math inline">\(i\)</span> transformations. For convenience, we let the value range of <span class="math inline">\(c\)</span> be <span class="math inline">\([0, 26)\)</span>, corresponding to the 26 characters from <span class="math inline">\(a\)</span> to <span class="math inline">\(z\)</span> in sequence.</p>
<p>Initially, all <span class="math inline">\(f(0, c)\)</span> values are equal to the number of occurrences of <span class="math inline">\(c\)</span> in the given string <span class="math inline">\(s\)</span>. When we iterate from <span class="math inline">\(f(i-1, \cdots)\)</span> to <span class="math inline">\(f(i, \cdots)\)</span>, we use the recurrence:</p>
<p><span class="math display">\[f(i, c) = \sum_{c'=0}^{25} \left[ f(i-1, c') \times T(c, c') \right]
\]</span></p>
<p>Here, the value of <span class="math inline">\(T(c, c')\)</span> is either 0 or 1. If <span class="math inline">\(c'\)</span> is included in the substitution set of <span class="math inline">\(c\)</span> during a single transformation, the value is 1; otherwise, it is 0. The values of <span class="math inline">\(T(c, c')\)</span> can be obtained from the given array <span class="math inline">\(\textit{nums}\)</span>.</p>
<p>The time complexity of directly using the recurrence is high, so optimization is necessary. Notice that <span class="math inline">\(T(c, c')\)</span> is independent of <span class="math inline">\(i\)</span>; it remains fixed in each round of iteration. Therefore, if we express <span class="math inline">\(f(i, c)\)</span> and <span class="math inline">\(f(i-1, c')\)</span> as <span class="math inline">\(n \times 1\)</span> column vectors, and <span class="math inline">\(T(c, c')\)</span> as an <span class="math inline">\(n \times n\)</span> matrix, the recurrence becomes a matrix multiplication:</p>
<p><span class="math display">\[\begin{pmatrix}
f(i, 0) \\
f(i, 1) \\
\vdots \\
f(i, 25)
\end{pmatrix}
=\begin{pmatrix}
T(0, 0) & T(0, 1) & \cdots & T(0, 25) \\
T(1, 0) & T(1, 1) & \cdots & T(1, 25) \\
\vdots & \vdots & \ddots & \vdots \\
T(25, 0) & T(25, 1) & \cdots & T(25, 25)
\end{pmatrix}
\begin{pmatrix}
f(i-1, 0) \\
f(i-1, 1) \\
\vdots \\
f(i-1, 25)
\end{pmatrix}
\]</span></p>
<p>So, after <span class="math inline">\(t\)</span> iterations:</p>
<p><span class="math display">\[\begin{pmatrix}
f(t, 0) \\
f(t, 1) \\
\vdots \\
f(t, 25)
\end{pmatrix}
=\begin{pmatrix}
T(0, 0) & T(0, 1) & \cdots & T(0, 25) \\
T(1, 0) & T(1, 1) & \cdots & T(1, 25) \\
\vdots & \vdots & \ddots & \vdots \\
T(25, 0) & T(25, 1) & \cdots & T(25, 25)
\end{pmatrix}^t
\begin{pmatrix}
f(0, 0) \\
f(0, 1) \\
\vdots \\
f(0, 25)
\end{pmatrix}
\]</span></p>
<p>Thus, we can first compute the <span class="math inline">\(t\)</span>-th power of the matrix corresponding to <span class="math inline">\(T(c, c')\)</span>, and then multiply it by the initial column vector <span class="math inline">\(f(0, \cdots)\)</span> to obtain all values <span class="math inline">\(f(t, \cdots)\)</span>. The sum of these values gives the final answer.</p>
<p>The exponentiation of the transformation matrix can be efficiently performed using <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">matrix exponentiation by squaring</a>, which we will not elaborate on here.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/QRSezZjn/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span>, and let <span class="math inline">\(|\Sigma|\)</span> denote the size of the character set, which is 26 in this case.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + \log t \times |\Sigma|^3)\)</span>.</p>
<p>We first traverse the string to count the occurrences of each character. Then, we apply matrix exponentiation by squaring to compute repeated matrix multiplication.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(|\Sigma|^2)\)</span>.</p>
<p>This is the space required to store the transformation matrix.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/transform-array-by-parity/description" target="_blank" rel="noopener noreferrer">Transform Array by Parity</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. Transform <code>nums</code> by performing the following operations in the <strong>exact</strong> order specified:</p>

<ol>
	<li>Replace each even number with 0.</li>
	<li>Replace each odd numbers with 1.</li>
	<li>Sort the modified array in <strong>non-decreasing</strong> order.</li>
</ol>

<p>Return the resulting array after performing these operations.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,3,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,0,1,1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Replace the even numbers (4 and 2) with 0 and the odd numbers (3 and 1) with 1. Now, <code>nums = [0, 1, 0, 1]</code>.</li>
	<li>After sorting <code>nums</code> in non-descending order, <code>nums = [0, 0, 1, 1]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,5,1,4,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,0,1,1,1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Replace the even numbers (4 and 2) with 0 and the odd numbers (1, 5 and 1) with 1. Now, <code>nums = [1, 1, 1, 0, 0]</code>.</li>
	<li>After sorting <code>nums</code> in non-descending order, <code>nums = [0, 0, 1, 1, 1]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/tuple-with-same-product/description" target="_blank" rel="noopener noreferrer">Tuple with Same Product</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> of <strong>distinct</strong> positive integers, return <em>the number of tuples </em><code>(a, b, c, d)</code><em> such that </em><code>a * b = c * d</code><em> where </em><code>a</code><em>, </em><code>b</code><em>, </em><code>c</code><em>, and </em><code>d</code><em> are elements of </em><code>nums</code><em>, and </em><code>a != b != c != d</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,4,6]
<strong>Output:</strong> 8
<strong>Explanation:</strong> There are 8 valid tuples:
(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,4,5,10]
<strong>Output:</strong> 16
<strong>Explanation:</strong> There are 16 valid tuples:
(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)
(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li>All elements in <code>nums</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>nums</code> containing <code>n</code> <strong>distinct</strong> positive integers. The goal is to find the number of tuples <code>(a, b, c, d)</code> such that:</p>
<ul>
<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are distinct elements of the <code>nums</code> array, and</li>
<li>The condition <code>a * b == c * d</code> is satisfied.</li>
</ul>
<p>Note, that a tuple refers to an ordered list of 4 elements. This means the tuples <code>(2, 3, 1, 6)</code> and <code>(3, 2, 1, 6)</code> are considered distinct and counted separately.</p>
<p>In fact, if we have two pairs of numbers <code>{a, b}</code> and <code>{c, d}</code> that satisfy <code>a * b == c * d</code>, we can generate multiple distinct tuples by varying the order of the elements and the pairs:</p>
<ul>
<li><code>(a, b, c, d)</code></li>
<li><code>(b, a, c, d)</code></li>
<li><code>(a, b, d, c)</code></li>
<li><code>(b, a, d, c)</code></li>
<li><code>(c, d, a, b)</code></li>
<li><code>(c, d, b, a)</code></li>
<li><code>(d, c, a, b)</code></li>
<li><code>(d, c, b, a)</code></li>
</ul>
<p>To understand this, observe that for every two pairs of distinct numbers <code>{a, b}</code> and <code>{c, d}</code>, there are three independent ways to reorder the elements and pairs:</p>
<ol>
<li>Within each pair:</li>
</ol>
<ul>
<li>The order of elements in <code>{a, b}</code> can be <code>(a, b)</code> or <code>(b, a)</code> (2 options).</li>
<li>Similarly, the order in <code>{c, d}</code> can be <code>(c, d)</code> or <code>(d, c)</code> (2 options).</li>
</ul>
<ol start="2">
<li>Between the pairs:</li>
</ol>
<ul>
<li>The order of the two pairs can be <code>({a, b}, {c, d})</code> or <code>({c, d}, {a, b})</code> (2 options).</li>
</ul>
<p>Since these choices are independent, the total number of distinct tuples is the product of these options: <span class="math inline">\(2 \times 2 \times 2 = 8\)</span>.</p>
<hr />
<h3 id="approach-1-optimized-brute-force">Approach 1: Optimized Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>A straightforward way to solve the problem is to test all possible combinations of values for <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> and count how many satisfy the condition. This approach can be implemented using 4 nested <code>for</code> loops, with each loop assigning a value to one of <code>a</code>, <code>b</code>, <code>c</code>, or <code>d</code>. However, this method has a time complexity of <span class="math inline">\(O(n^4)\)</span>, which is inefficient for the given constraints.</p>
<p>To optimize this approach, we can make the following observations:</p>
<ol>
<li>If <code>a</code> and <code>b</code> are both greater (or both smaller) than <code>c</code> and <code>d</code>, then the condition <code>a * b == c * d</code> cannot be true because the first product will be strictly greater than (or strictly smaller than) the second. To address this, we will sort the array to ensure that the selected values for <code>c</code> and <code>d</code> always lie between the values of <code>a</code> and <code>b</code>.</li>
<li>If <code>a * b</code> is not a multiple of <code>c</code> for some fixed values of <code>a</code>, <code>b</code>, and <code>c</code>, the condition cannot be satisfied for any integer value of <code>d</code>. For cases where the condition can be satisfied, the value of <code>d</code> is already determined as <code>d = a * b / c</code>. Instead of searching the entire array to find a matching value for <code>d</code>, we can store all possible values in a hash map and efficiently check if the required value exists. As we process each potential value of <code>c</code> that could form a tuple (i.e., values that divide the product <code>a * b</code>), we add them to a hash map, <code>possibleDValues</code>, ensuring they are readily available for efficient lookups when needed.</li>
</ol>
<p>For example, consider the array <code>[1, 2, 3, 4, 8]</code>. Let <code>a = 1</code> and <code>b = 8</code>. Their product is <code>8</code>. If we choose <code>c = 4</code>, then <code>d</code> must be <code>8 / 4 = 2</code> to satisfy the condition. Number <code>2</code> exists in the array so the tuple <code>(1, 8, 4, 2)</code> is a valid one. However, for <code>c = 3</code>, <code>c</code> is not a divisor of <code>a * b</code>, so the condition cannot be satisfied for any value of <code>d</code> and therefore this combination won't lead to any valid tuple.</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card 🔗</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>numsLength</code> to the length of the <code>nums</code> array.</li>
<li>Sort the array in increasing order.</li>
<li>Initialize <code>totalNumberOfTuples</code> to <code>0</code>.</li>
<li>Iterate over <code>nums</code> to try out all possible values of <code>a</code> with <code>aIndex</code> from <code>0</code> to <code>numsLength - 1</code>.
<ul>
<li>Iterate over the rest values of <code>nums</code> to try all possible values for <code>b</code> with <code>bIndex</code> from <code>numsLength - 1</code> to <code>aIndex + 1</code>.
<ul>
<li>Define <code>product</code> as <code>nums[aIndex] * nums[bIndex]</code>.</li>
<li>Initialize a hash map <code>possibleDValues</code>.
<ul>
<li>Iterate over <code>nums</code> with <code>cIndex</code> from <code>aIndex + 1</code> to <code>bIndex - 1</code>:
<ul>
<li>If the condition can be satisfied for some integer value of <code>d</code>, i.e. if <code>product % nums[cIndex] == 0</code>:
<ul>
<li>Define the desired value of <code>d</code> as <code>dValue =  product / nums[cIndex]</code>.</li>
<li>If <code>dValue</code> is in <code>possibleDValues</code> then add <code>8</code> (all possible tuples) to <code>totalNumberOfTuples</code>.</li>
<li>Add <code>nums[cindex]</code> to the <code>possibleDValues</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalNumberOfTuples</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>This solution results in a TLE (Time Limit Exceeded) error for the <code>Python3</code> implementation.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/GMSAz8vi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3)\)</span></p>
<p>First, we sort the array in <span class="math inline">\(O(n \log n)\)</span> time. Next, we use 3 nested loops to fix the values of <code>a</code>, <code>b</code>, and <code>c</code>, and for each combination, we check whether the required value of <code>d</code> exists in the array. Using a hash set allows us to perform both insertion and lookup operations in constant time on average. Thus, the operations within the innermost loop take constant time. As a result, the overall time complexity of the algorithm is <span class="math inline">\(O(n^3)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create a hash set to store the possible values variable <code>d</code> can take. This hash set can grow up to <span class="math inline">\(O(n)\)</span> in size, so the algorithm requires <span class="math inline">\(O(n)\)</span> extra space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-count-product-frequency">Approach 2: Count Product Frequency</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, instead of directly finding the number of <em>tuples</em> in <code>nums</code> that meet the condition, we first create an array of all possible products of two numbers from <code>nums</code>. Then, we count how many times each product appears and from that, we calculate the number of <em>pairs</em> of products that are equal.</p>
<p>This simplified version of the problem is equivalent to the original because the distinctness of the numbers in <code>nums</code> ensures that if two products are the same, they must come from two different pairs of numbers. From each of these pairs, we can create <code>8</code> valid tuples, as explained in the overview.</p>
<p>Let's take a look at an example, where <code>nums = [2, 3, 4, 6]</code>.<br />
First, we will calculate the pairwise products of the elements in <code>nums</code>, and store them in a new array: <code>pairProducts = [6, 8, 12, 12, 18, 24]</code>.<br />
We notice that only one pair of equal products exists: <code>(12, 12)</code>. Based on the observation above, each of these <code>12</code>'s is formed by two distinct numbers in <code>nums</code> (<code>2</code> and <code>6</code>, <code>3</code> and <code>4</code>), which can create <code>8</code> tuples. Therefore, the answer here is <code>8</code>.</p>
<p>To count the number of times each product value occurs, we will sort the <code>pairProducts</code> array and process it from left to right. If the current value is equal to the last one seen, then we'll increment a counter. Otherwise, we will calculate the number of tuples for the previous product value and then update it to the current one.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize
<ul>
<li><code>numsLength</code> to the length of the <code>nums</code> array.</li>
<li>an array, <code>pairProducts</code>, to store the pairwise products of the elements.</li>
<li><code>totalNumberOfTuples</code> to <code>0</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>firstIndex</code> from <code>0</code> to <code>numsLength - 1</code>:
<ul>
<li>Iterate over <code>nums</code> with <code>secondindex</code> from <code>firstIndex + 1</code> to <code>numsLength - 1</code>:
<ul>
<li>Add the product <code>nums[firstIndex] * nums[secondindex]</code> to the <code>pairProducts</code> list.</li>
</ul>
</li>
</ul>
</li>
<li>Sort <code>pairProducts</code> in increasing order.</li>
<li>Initialize <code>lastProductSeen</code> to <code>-1</code> and <code>sameProductCount</code> to <code>0</code>.</li>
<li>Iterate over <code>pairProducts</code> with <code>productIndex</code> from <code>0</code> to <code>pairProducts.size - 1</code>:
<ul>
<li>If the current product is equal to the last seen:
<ul>
<li>Increment <code>sameProductCount</code> by <code>1</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Calculate the number of pairs of products with value <code>lastProductSeen</code>: <code>pairsOfEqualProduct = (sameProductCount - 1) * sameProductCount / 2</code>.</li>
<li>Add all possible tuples for that product value to the total: increment <code>totalNumberOfTuples</code> by <code>8 * pairsOfEqualProduct</code>.</li>
<li>Set <code>lastProductSeen</code> to the <code>pairProducts[productIndex]</code> and <code>sameProductCount</code> to <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Handle the last group of products:
<ul>
<li>Calculate the number of pairs of products with value <code>lastProductSeen</code>: <code>pairsOfEqualProduct = (sameProductCount - 1) * sameProductCount / 2</code>.</li>
<li>Add all possible tuples for that product value to the total: increment <code>totalNumberOfTuples</code> by <code>8 * pairsOfEqualProduct</code>.</li>
</ul>
</li>
<li>Return <code>totalNumberOfTuples</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/EYewLEL4/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \log{n})\)</span></p>
<p>We iterate over the array with a nested loop to calculate all pairwise products, which takes <span class="math inline">\(O(n^2)\)</span>. Sorting the <code>pairProducts</code> array requires <span class="math inline">\(O(n^2 \log{n^2}) = O(2n^2 \log{n}) = O(n^2 \log{n})\)</span> time, as the length of the array is <span class="math inline">\(O(n^2)\)</span>. Then, we perform a final pass over the <code>pairProducts</code> array to count the frequency of each product and update the total number of tuples. Each iteration only involves constant-time operations, and therefore this step costs <span class="math inline">\(O(n^2)\)</span> time. Overall, the time complexity of the algorithm is <span class="math inline">\(O(n^2 + n^2 \log{n} + n^2) = O(n^2 \log{n})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The <code>pairProducts</code> array contains the products of all pairs of elements in <code>nums</code>. Since there exist <span class="math inline">\(\frac{n \times (n - 1)}{2} = O(n^2)\)</span> pairs of <span class="math inline">\(n\)</span> elements, the <code>pairProducts</code> array requires <span class="math inline">\(O(n^2)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-product-frequency-hash-map">Approach 3: Product Frequency Hash Map</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, we identified a bottleneck caused by sorting the <code>pairProducts</code> array to calculate the frequency of each element. To address this, instead of storing each pair product in a new array, we will directly update the frequency of each product using a hash map. Then, following the same approach as before, we will count the number of pairs of products with the same value and calculate how many tuples can be formed from them.</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card 🔗</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize
<ul>
<li><code>numsLength</code> to the length of the <code>nums</code> array.</li>
<li>a hash map, <code>pairProductsFrequency</code>.</li>
<li><code>totalNumberOfTuples</code> to <code>0</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>firstIndex</code> from <code>0</code> to <code>numsLength - 1</code>:
<ul>
<li>Iterate over <code>nums</code> with <code>secondindex</code> from <code>firstIndex + 1</code> to <code>numsLength - 1</code>:
<ul>
<li>Increment the frequency of the product: <code>nums[firstIndex] * nums[secondindex]</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>For each element <code>[productValue, productFrequency]</code> of <code>pairProductsFrequency</code>:
<ul>
<li>Calculate the number of pairs of products with value <code>productValue</code>: <code>pairsOfEqualProduct = (productFrequency - 1) * productFrequency / 2</code>.</li>
<li>Add all possible tuples for that product value to the total: increment <code>totalNumberOfTuples</code> by <code>8 * pairsOfEqualProduct</code>.</li>
</ul>
</li>
<li>Return <code>totalNumberOfTuples</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/BtU79MJh/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We begin by calculating all pairwise products in <span class="math inline">\(O(n^2)\)</span> time. Next, for each of these product values, we find the number of pairs of products of this value and then the number of tuples that can be formed. These calculations require constant time and therefore this part of the algorithm also takes <span class="math inline">\(O(n^2)\)</span> in the worst-case (when all product values are distinct). Therefore, the total time complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The <code>pairProductsFrequency</code> can grow up to <span class="math inline">\(\frac{n \times (n - 1)}{2} = O(n^2)\)</span> in size (when all pair products are different) and thus the algorithm requires <span class="math inline">\(O(n^2)\)</span> extra space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/uncommon-words-from-two-sentences/description" target="_blank" rel="noopener noreferrer">Uncommon Words from Two Sentences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>sentence</strong> is a string of single-space separated words where each word consists only of lowercase letters.</p>

<p>A word is <strong>uncommon</strong> if it appears exactly once in one of the sentences, and <strong>does not appear</strong> in the other sentence.</p>

<p>Given two <strong>sentences</strong> <code>s1</code> and <code>s2</code>, return <em>a list of all the <strong>uncommon words</strong></em>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s1 = &quot;this apple is sweet&quot;, s2 = &quot;this apple is sour&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[&quot;sweet&quot;,&quot;sour&quot;]</span></p>

<p><strong>Explanation:</strong></p>

<p>The word <code>&quot;sweet&quot;</code> appears only in <code>s1</code>, while the word <code>&quot;sour&quot;</code> appears only in <code>s2</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s1 = &quot;apple apple&quot;, s2 = &quot;banana&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[&quot;banana&quot;]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s1.length, s2.length &lt;= 200</code></li>
	<li><code>s1</code> and <code>s2</code> consist of lowercase English letters and spaces.</li>
	<li><code>s1</code> and <code>s2</code> do not have leading or trailing spaces.</li>
	<li>All the words in <code>s1</code> and <code>s2</code> are separated by a single space.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-counting">Approach 1: Counting</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Every uncommon word occurs exactly once in total.  We can count the number of occurrences of every word, then return ones that occur exactly once.</p>
<p><a href="https://leetcode.com/playground/K9coviyW/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(M + N)\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>A</code> and <code>B</code> respectively.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(M + N)\)</span>, the space used by <code>count</code>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/description" target="_blank" rel="noopener noreferrer">X of a Kind in a Deck of Cards</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>deck</code> where <code>deck[i]</code> represents the number written on the <code>i<sup>th</sup></code> card.</p>

<p>Partition the cards into <strong>one or more groups</strong> such that:</p>

<ul>
	<li>Each group has <strong>exactly</strong> <code>x</code> cards where <code>x &gt; 1</code>, and</li>
	<li>All the cards in one group have the same integer written on them.</li>
</ul>

<p>Return <code>true</code><em> if such partition is possible, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> deck = [1,2,3,4,4,3,2,1]
<strong>Output:</strong> true
<strong>Explanation</strong>: Possible partition [1,1],[2,2],[3,3],[4,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> deck = [1,1,1,2,2,2,3,3]
<strong>Output:</strong> false
<strong>Explanation</strong>: No possible partition.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= deck.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= deck[i] &lt; 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p><strong>Intuition</strong></p>
<p>We can try every possible <code>X</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Since we divide the deck of <code>N</code> cards into say, <code>K</code> piles of <code>X</code> cards each, we must have <code>N % X == 0</code>.</p>
<p>Then, say the deck has <code>C_i</code> copies of cards with number <code>i</code>.  Each group with number <code>i</code> has <code>X</code> copies, so we must have <code>C_i % X == 0</code>.  These are necessary and sufficient conditions.</p>
<p><a href="https://leetcode.com/playground/mTHbaonm/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2 \log \log N)\)</span>, where <span class="math inline">\(N\)</span> is the number of cards.  It is outside the scope of this article to prove that the number of divisors of <span class="math inline">\(N\)</span> is bounded by <span class="math inline">\(O(N \log \log N)\)</span>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-greatest-common-divisor">Approach 2: Greatest Common Divisor</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Again, say there are <code>C_i</code> cards of number <code>i</code>.  These must be broken down into piles of <code>X</code> cards each, ie. <code>C_i % X == 0</code> for all <code>i</code>.</p>
<p>Thus, <code>X</code> must divide the greatest common divisor of <code>C_i</code>.  If this greatest common divisor <code>g</code> is greater than <code>1</code>, then <code>X = g</code> will satisfy.  Otherwise, it won't.</p>
<p><a href="https://leetcode.com/playground/XR8H7QdB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N \log^2 N)\)</span>, where <span class="math inline">\(N\)</span> is the number of votes.  If there are <span class="math inline">\(C_i\)</span> cards with number <span class="math inline">\(i\)</span>, then each <code>gcd</code> operation is naively <span class="math inline">\(O(\log^2 C_i)\)</span>.  Better bounds exist, but are outside the scope of this article to develop.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>