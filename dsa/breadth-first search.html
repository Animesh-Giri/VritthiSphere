<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>breadth-first search - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>breadth-first search</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">243</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">01 Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Accounts Merge</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Add One Row to Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">All Ancestors of a Node in a Directed Acyclic Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">All Nodes Distance K in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">All Paths From Source to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Amount of Time for Binary Tree to Be Infected</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">As Far from Land as Possible</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Average of Levels in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">BFS of graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-10" class="toc-link">Binary Tree Level Order Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Binary Tree Level Order Traversal II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Binary Tree Right Side View</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Binary Tree Zigzag Level Order Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Bipartite Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-15" class="toc-link">Brace Expansion II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Bulb Switcher II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Burning Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-18" class="toc-link">Bus Routes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Cheapest Flights Within K Stops</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-20" class="toc-link">Cheapest Flights Within K Stops</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Check Completeness of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Check if the Rectangle Corner Is Reachable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Check if There is a Valid Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Check if two Nodes are Cousins</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-25" class="toc-link">Check Knight Tour Configuration</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">City With the Smallest Number of Neighbors at a Threshold Distance</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-27" class="toc-link">Clone an Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-28" class="toc-link">Clone Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Coin Change</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Coloring A Border</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Complete Binary Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-32" class="toc-link">Complete Binary Tree Inserter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Connected Components in an Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-34" class="toc-link">Connecting the special nodes</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-35" class="toc-link">Contain Virus</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Count Good Nodes in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Count Islands With Total Value Divisible by K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Count Servers that Communicate</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Count Sub Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Count the Number of Complete Components</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Count the Number of Houses at a Certain Distance I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Count Unreachable Pairs of Nodes in an Undirected Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Couples Holding Hands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Course Schedule</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-45" class="toc-link">Course Schedule</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Course Schedule II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Course Schedule IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Cousins in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Cousins in Binary Tree II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Covid Spread</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-51" class="toc-link">Cut Off Trees for Golf Event</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Deepest Leaves Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Detect Cycles in 2D Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Detonate the Maximum Bombs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Disconnect Path in a Binary Matrix by at Most One Flip</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Distance of nearest cell having 1</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-57" class="toc-link">Divide Nodes Into the Maximum Number of Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Employee Importance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Escape a Large Maze</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Escape the Spreading Fire</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Evaluate Division</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Even Odd Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Eventual Safe States</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-64" class="toc-link">Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Find All Groups of Farmland</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Find All People With Secret</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Find a Safe Walk Through a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Find Bottom Left Tree Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Find Edges in Shortest Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Find Elements in a Contaminated Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Find Eventual Safe States</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Find if Path Exists in Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Find Largest Value in Each Tree Row</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Find Minimum Diameter After Merging Two Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Find number of closed islands</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-76" class="toc-link">Find the longest string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-77" class="toc-link">Find the Safest Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Find whether path exist</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-79" class="toc-link">Firing employees</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-80" class="toc-link">Flood Fill</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-81" class="toc-link">Flower Planting With No Adjacent</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Freedom Trail</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Frog Position After T Seconds</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-84" class="toc-link">Geek&#39;s Village and Wells</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-85" class="toc-link">Get Watched Videos by Your Friends</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">Grid Teleportation Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Height of Binary Tree After Subtree Removal Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Invert Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Is Graph Bipartite?</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Island Perimeter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-91" class="toc-link">Jump Game III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">Jump Game IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Keys and Rooms</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-94" class="toc-link">K Highest Ranked Items Within a Price Range</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Kill Captain America</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-96" class="toc-link">Knight in Geekland</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-97" class="toc-link">Knight Walk</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-98" class="toc-link">K-Similar Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Kth Ancestor of a Tree Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-100" class="toc-link">Kth Largest Sum in a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Last Day Where You Can Still Cross</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Level of Nodes</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-103" class="toc-link">Lexicographically Smallest String After Applying Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Lexicographical Smallest String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-105" class="toc-link">Longest Cycle in a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Longest Increasing Path in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-107" class="toc-link">Lowest Common Ancestor of Deepest Leaves</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Making A Large Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Making A Large Island</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-110" class="toc-link">Map of Highest Peak</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Max Area of Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Maximize Amount After Two Days of Conversions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Maximize the Number of Target Nodes After Connecting Trees I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Maximize the Number of Target Nodes After Connecting Trees II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Maximum Candies You Can Get from Boxes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Maximum Connected group</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-117" class="toc-link">Maximum Depth of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-118" class="toc-link">Maximum Depth of N-ary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Maximum Level Sum of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">Maximum Number of Fish in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Maximum Number of Moves to Kill All Pawns</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-122" class="toc-link">Maximum Number of Points From Grid Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Maximum Width of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Merge Two Binary Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Minesweeper</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Minimize Malware Spread</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-127" class="toc-link">Minimize Malware Spread II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Minimize the Maximum Edge Weight of Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-129" class="toc-link">Minimum Absolute Difference in BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Minimum Cost to Make at Least One Valid Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Minimum Depth of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Minimum Distance Between BST Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Minimum Edge Reversals So Every Node Is Reachable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Minimum Fuel Cost to Report to the Capital</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Minimum Genetic Mutation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Minimum Height Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">Minimum Jumps to Reach End via Prime Teleportation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-138" class="toc-link">Minimum Jumps to Reach Home</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-139" class="toc-link">Minimum Moves to Clean the Classroom</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-140" class="toc-link">Minimum Moves to Move a Box to Their Target Location</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-141" class="toc-link">Minimum Moves to Reach Target with Rotations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-142" class="toc-link">Minimum Moves to Spread Stones Over Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-143" class="toc-link">Minimum Multiplications to reach End</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-144" class="toc-link">Minimum Number of Days to Disconnect Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-145" class="toc-link">Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-146" class="toc-link">Minimum Number of Operations to Make X and Y Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-147" class="toc-link">Minimum Number of Operations to Sort a Binary Tree by Level</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Minimum Number of Visited Cells in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-149" class="toc-link">Minimum Obstacle Removal to Reach Corner</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-150" class="toc-link">Minimum Operations to Convert Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-151" class="toc-link">Minimum Reverse Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-152" class="toc-link">Minimum Score of a Path Between Two Cities</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-153" class="toc-link">Minimum Time to Collect All Apples in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-154" class="toc-link">Minimum Time to Visit a Cell In a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-155" class="toc-link">Most Profitable Path in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-156" class="toc-link">N-ary Tree Level Order Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-157" class="toc-link">Nearest Exit from Entrance in Maze</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-158" class="toc-link">Network Delay Time</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-159" class="toc-link">Number of Closed Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-160" class="toc-link">Number of Distinct Islands</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-161" class="toc-link">Number of Enclaves</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-162" class="toc-link">Number Of Enclaves</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-163" class="toc-link">Number of Increasing Paths in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-164" class="toc-link">Number of Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-165" class="toc-link">Number of Nodes in the Sub-Tree With the Same Label</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-166" class="toc-link">Number of Operations to Make Network Connected</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-167" class="toc-link">Number of Provinces</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-168" class="toc-link">Numbers With Same Consecutive Differences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-169" class="toc-link">Open the Lock</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-170" class="toc-link">Operations on Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-171" class="toc-link">Pacific Atlantic Water Flow</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-172" class="toc-link">Pacific Atlantic Water Flow</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-173" class="toc-link">Path Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-174" class="toc-link">Path With Minimum Effort</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-175" class="toc-link">Path With Minimum Effort</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-176" class="toc-link">Perfect Squares</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-177" class="toc-link">Populating Next Right Pointers in Each Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-178" class="toc-link">Populating Next Right Pointers in Each Node II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-179" class="toc-link">Possible Bipartition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-180" class="toc-link">Power Grid Maintenance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-181" class="toc-link">Print Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-182" class="toc-link">Printing patterns</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-183" class="toc-link">Properties Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-184" class="toc-link">Pseudo-Palindromic Paths in a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-185" class="toc-link">Pyramid Transition Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-186" class="toc-link">Reachable Nodes With Restrictions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-187" class="toc-link">Redundant Connection</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-188" class="toc-link">Redundant Connection II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-189" class="toc-link">Regions Cut By Slashes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-190" class="toc-link">Remove Invalid Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-191" class="toc-link">Remove Methods From Project</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-192" class="toc-link">Reorder Routes to Make All Paths Lead to the City Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-193" class="toc-link">Reverse Odd Levels of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-194" class="toc-link">Rotting Oranges</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-195" class="toc-link">Same Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-196" class="toc-link">Second Minimum Time to Reach Destination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-197" class="toc-link">Serialize and Deserialize Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-198" class="toc-link">Serialize and Deserialize BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-199" class="toc-link">Shift String</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-200" class="toc-link">Shortest Bridge</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-201" class="toc-link">Shortest Cycle in a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-202" class="toc-link">Shortest Distance After Road Addition Queries I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-203" class="toc-link">Shortest Distance in a Binary Maze</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-204" class="toc-link">Shortest Path by Removing K walls</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-205" class="toc-link">Shortest Path in a Grid with Obstacles Elimination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-206" class="toc-link">Shortest Path in Binary Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-207" class="toc-link">Shortest Path in Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-208" class="toc-link">Shortest Path to Get All Keys</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-209" class="toc-link">Shortest Path Visiting All Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-210" class="toc-link">Shortest Path with Alternating Colors</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-211" class="toc-link">Shortest Source to Destination Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-212" class="toc-link">Similar String Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-213" class="toc-link">Sliding Puzzle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-214" class="toc-link">Smallest String With Swaps</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-215" class="toc-link">Smallest Subtree with all the Deepest Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-216" class="toc-link">Snake and Ladder Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-217" class="toc-link">Snakes and Ladders</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-218" class="toc-link">Sort Items by Groups Respecting Dependencies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-219" class="toc-link">Spidey Sense</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-220" class="toc-link">Steps by Knight</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-221" class="toc-link">Sum of Left Leaves</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-222" class="toc-link">Sum of Nodes with Even-Valued Grandparent</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-223" class="toc-link">Surrounded Regions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-224" class="toc-link">Swim in Rising Water</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-225" class="toc-link">Symmetric Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-226" class="toc-link">The Time When the Network Becomes Idle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-227" class="toc-link">Time Needed to Inform All Employees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-228" class="toc-link">Trapping Rain Water II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-229" class="toc-link">Travel diaries</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-230" class="toc-link">Tree Trips</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-231" class="toc-link">Two Sum IV - Input is a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-232" class="toc-link">Unit Area of largest region of 1&#39;s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-233" class="toc-link">Unit Conversion I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-234" class="toc-link">Univalued Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-235" class="toc-link">Validate Binary Tree Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-236" class="toc-link">Vertical Order Traversal of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-237" class="toc-link">Water and Jug Problem</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-238" class="toc-link">Word Ladder</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-239" class="toc-link">Word Ladder I</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-240" class="toc-link">Word Ladder II</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-241" class="toc-link">Word Ladder II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-242" class="toc-link">Zuma Game</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/01-matrix/description" target="_blank" rel="noopener noreferrer">01 Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> binary matrix <code>mat</code>, return <em>the distance of the nearest </em><code>0</code><em> for each cell</em>.</p>

<p>The distance between two cells sharing a common edge is <code>1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> mat = [[0,0,0],[0,1,0],[0,0,0]]
<strong>Output:</strong> [[0,0,0],[0,1,0],[0,0,0]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> mat = [[0,0,0],[0,1,0],[1,1,1]]
<strong>Output:</strong> [[0,0,0],[0,1,0],[1,2,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one <code>0</code> in <code>mat</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1765: <a href="https://leetcode.com/problems/map-of-highest-peak/description/" target="_blank">https://leetcode.com/problems/map-of-highest-peak/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/accounts-merge/description" target="_blank" rel="noopener noreferrer">Accounts Merge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.</p>

<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>

<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> accounts = [[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john_newyork@mail.com&quot;],[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john00@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]
<strong>Output:</strong> [[&quot;John&quot;,&quot;john00@mail.com&quot;,&quot;john_newyork@mail.com&quot;,&quot;johnsmith@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]
<strong>Explanation:</strong>
The first and second John&#39;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;.
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [[&#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], 
[&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]] would still be accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> accounts = [[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe3@m.co&quot;,&quot;Gabe1@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;,&quot;Kevin0@m.co&quot;],[&quot;Ethan&quot;,&quot;Ethan5@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan0@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo3@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo0@m.co&quot;],[&quot;Fern&quot;,&quot;Fern5@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern0@m.co&quot;]]
<strong>Output:</strong> [[&quot;Ethan&quot;,&quot;Ethan0@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan5@m.co&quot;],[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe1@m.co&quot;,&quot;Gabe3@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo0@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo3@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin0@m.co&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;],[&quot;Fern&quot;,&quot;Fern0@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern5@m.co&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>
	<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>
	<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>
	<li><code>accounts[i][0]</code> consists of English letters.</li>
	<li><code>accounts[i][j] (for j &gt; 0)</code> is a valid email.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a list of accounts where each account consists of a list containing the name of the person the account belongs to and some emails that belong to the person. One person is allowed to have multiple accounts, but each email can only belong to one person. Therefore, we can say two accounts must belong to the same person if the accounts have an email in common. Note that we cannot just use the user's name to determine which email addresses belong to the same user since different users may have the same name.</p>
<p>Our goal is, for each person, we want to identify all of the emails that belong to that person. Therefore, every time we find two accounts with an email in common, we will merge the two accounts into one.</p>
<p>Whenever we must work with a set of elements (emails) that are connected (belong to the same user), we should always consider visualizing our input as a graph. In this problem, converting the input into a graph will facilitate the process of &quot;merging&quot; two accounts.</p>
<p>Emails can be represented as nodes, and an edge between nodes will signify that they belong to the same person. Since all of the emails in an account belong to the same person, we can connect all of the emails with edges. Thus, each account can be represented by a connected component. What if two accounts have an email in common? Then we can add an edge between the two connected components, effectively merging them into one connected component.<br />
</br></p>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<p>Here, we will represent emails as nodes, and an edge will signify that two emails are connected and hence belong to the same person. This means that any two emails that are connected by a path of edges must also belong to the same person. Initially, we are given <span class="math inline">\(N\)</span> accounts, where each account's emails make up a connected component.</p>
<p>Our first step should be to ensure that for each account, all of its nodes are connected. Suppose an account has <span class="math inline">\(K\)</span> emails, and we want to connect these emails. Since all emails in an account are connected, we can add an edge between every pair of emails. This will create a complete subgraph and require adding <span class="math inline">\(K \choose 2\)</span> edges. However, do we really need that many edges to keep track of which emails belong to the same account? No, as long as two emails are connected by a path of edges, we know they belong to the same account. So instead of creating a complete subgraph for each account, we can create an acyclic graph using only <span class="math inline">\(K - 1\)</span> edges. Recall that <span class="math inline">\(K - 1\)</span> is the minimum number of edges required to connect <span class="math inline">\(K\)</span> nodes. In this approach, we will connect emails in an account in a <a href="https://en.wikipedia.org/wiki/Star_(graph_theory)">star</a> manner with the first email as the internal node of the star and all other emails as the leaves (as shown below).</p>
<p><img src="../Figures/721/721A.png" alt="fig" /></p>
<p>The beauty of connecting the emails in each account in this manner is that after connecting an email to a second account, that email will have one edge going to an email in the first account and one edge going to an email in the second account.  Thereby automatically merging the two accounts. The below slideshow depicts the merging process for four accounts that belong to two different people.</p>
<p>!?!../Documents/721_Accounts_Merge_A.json:960,720!?! <br></p>
<p>After iterating over each account and connecting the emails as described above, we will have a one or more connected components. Each connected component will represent one person, and the nodes in the connected component are the person's emails. Now our task is to explore each connected component to find all the emails that belong to each person. Since a depth-first search is guaranteed to explore every node in a connected component, we will perform a DFS on each connected component (person) to find all of the connected emails.</p>
<p>To do so, we will iterate over all of the nodes and consider starting a DFS. If the node has already been visited, in an earlier DFS, we will not start a DFS.  Otherwise, perform a DFS traversal over the connected component and store all the visited emails together, as they all belong to one person. Each time we visit an email during a DFS, we will mark it as visited to ensure that we do not search the same connected component more than once. To read more about how DFS can be leveraged to find components you can refer to the first approach <a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/solution/">here</a>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create an adjacency list: For each account add an edge between the first email (<code>accountFirstEmail</code>) and each of the other emails in the account.</li>
<li>Traverse over the accounts; for each account, check if the first email in the account (<code>accountFirstEmail</code>) was already visited.  If so, then do not start a new DFS. Otherwise, perform DFS with this email as the source node.</li>
<li>During each DFS, store the traversed emails in an array <code>mergedAccount</code>, also mark all these emails as visited.</li>
<li>After the DFS traversal is over, sort the emails and add the account name (<code>accountName</code>) at the start of the vector <code>mergedAccount</code>.</li>
<li>Store the vector <code>mergedAccount</code> in the answer list <code>mergedAccounts</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/EAjKzRH9/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here <span class="math inline">\(N\)</span> is the number of accounts and <span class="math inline">\(K\)</span> is the maximum length of an account.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(NK \log{NK})\)</span></p>
<p>In the worst case, all the emails will end up belonging to a single person. The total number of emails will be <span class="math inline">\(N*K\)</span>, and we need to sort these emails. DFS traversal will take <span class="math inline">\(NK\)</span> operations as no email will be traversed more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(NK)\)</span></p>
<p>Building the adjacency list will take <span class="math inline">\(O(NK)\)</span> space. In the end, <code>visited</code> will contain all of the emails hence it will use <span class="math inline">\(O(NK)\)</span> space. Also, the call stack for DFS will use <span class="math inline">\(O(NK)\)</span> space in the worst case.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, Collections.sort() dumps the specified list into an array this will take <span class="math inline">\(O(NK)\)</span> space then Arrays.sort() for primitives is implemented as a variant of quicksort algorithm whose space complexity is <span class="math inline">\(O(\log NK)\)</span>. In C++ <code>sort()</code> function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort with the worst-case space complexity of <span class="math inline">\(O(\log NK)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-disjoint-set-union-dsu">Approach 2: Disjoint Set Union (DSU)</h3>
<p><strong>Intuition</strong></p>
<p>As in the previous approach, the first step is to find which accounts have an email in common and merge them to form a larger connected component. Any problem that involves merging connected components (accounts) is a natural fit for the Disjoint Set Union (DSU) data structure. If you would like to learn more about the DSU data structure (also known as Union-Find), a tutorial is provided in the <a href="https://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/">Graph Explore Card</a>. Since most implementations of DSU use an array to record the root (representative) of each component, we will use integers to represent each component for ease of operability. Therefore, we will give each account a unique ID, and we will map all the emails in the account to the account's ID. We will use a map, <code>emailGroup</code>, to store this information.</p>
<p>We chose the account index to be the identifier for all the emails of an account. We will assign the account index as the group when we get the email for the first time and when we get an email that we have already traversed, we will merge the current account and the group that we have previously stored in <code>emailGroup</code> using union operation.</p>
<p>After traversing over all the accounts, we will find the representative of all the emails which will inform us about their group. Emails with the same representative belong to the same person/group and hence will be stored together. Also, we can retrieve the account name for our final answer using <code>accountList</code> as we have <code>group</code> which is the index in the original accounts list.</p>
<p>!?!../Documents/721_Accounts_Merge_B.json:960,720!?! <br></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Traverse over each account, and for each account, traverse over all of its emails.  If we see an email for the first time, then set the group of the email as the index of the current account in <code>emailGroup</code> .</li>
<li>Otherwise, if the email has already been seen in another account, then we will union the current group (<code>i</code>) and the group the current email belongs to (<code>emailGroup[email]</code>).</li>
<li>After traversing over every account and merging the accounts that share a common email, we will now traverse over every email once more. Each email will be added to a map (<code>components</code>) where the key is the email's representative, and the value is a list of emails with that representative.</li>
<li>Traverse over <code>components</code>, here the keys are the group indices and the value is the list of emails belonging to this group (person). Since the emails must be &quot;in sorted order&quot; we will sort the list of emails for each group. Lastly, we can get the account name using the <code>accountList[group][0]</code>. In accordance with the instructions, we will insert this name at the beginning of the email list.</li>
<li>Store the list created in step 4 in our final result (<code>mergedAccount</code>).</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/cCnGvzFV/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here <span class="math inline">\(N\)</span> is the number of accounts and <span class="math inline">\(K\)</span> is the maximum length of an account.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(NK \log {NK})\)</span></p>
<p>While merging we consider the size of each connected component and we always choose the representative of the larger component to be the new representative of the smaller component, also we have included the path compression so the time complexity for find/union operation is <span class="math inline">\(\alpha({N})\)</span> (Here, <span class="math inline">\(\alpha({N})\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(N\)</span> (approximately <span class="math inline">\( N < 10^{600}\)</span>).</p>
<p>We find the representative of all the emails, hence it will take <span class="math inline">\(O(NK\alpha({N}))\)</span> time. We are also sorting the components and the worst case will be when all emails end up belonging to the same component this will cost <span class="math inline">\(O(NK(\log {NK}))\)</span>.</p>
<p>Hence the total time complexity is <span class="math inline">\(O(NK \cdot \log {NK} + NK \cdot \alpha({N}))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(NK)\)</span></p>
<p>List <code>representative</code>, <code>size</code> store information corresponding to each group so will take <span class="math inline">\(O(N)\)</span> space. All emails get stored in <code>emailGroup</code> and <code>component</code> hence space used is <span class="math inline">\(O(NK)\)</span>.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, Collections.sort() dumps the specified list into an array this will take <span class="math inline">\(O(NK)\)</span> space then Arrays.sort() for primitives is implemented as a variant of quicksort algorithm whose space complexity is <span class="math inline">\(O(\log NK)\)</span>. In C++ <code>sort()</code> function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort with the worst-case space complexity of <span class="math inline">\(O(\log NK)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/add-one-row-to-tree/description" target="_blank" rel="noopener noreferrer">Add One Row to Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and two integers <code>val</code> and <code>depth</code>, add a row of nodes with value <code>val</code> at the given depth <code>depth</code>.</p>

<p>Note that the <code>root</code> node is at depth <code>1</code>.</p>

<p>The adding rule is:</p>

<ul>
	<li>Given the integer <code>depth</code>, for each not null tree node <code>cur</code> at the depth <code>depth - 1</code>, create two tree nodes with value <code>val</code> as <code>cur</code>&#39;s left subtree root and right subtree root.</li>
	<li><code>cur</code>&#39;s original left subtree should be the left subtree of the new left subtree root.</li>
	<li><code>cur</code>&#39;s original right subtree should be the right subtree of the new right subtree root.</li>
	<li>If <code>depth == 1</code> that means there is no depth <code>depth - 1</code> at all, then create a tree node with value <code>val</code> as the new root of the whole original tree, and the original tree is the new root&#39;s left subtree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg" style="width: 500px; height: 231px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2
<strong>Output:</strong> [4,1,1,2,null,null,6,3,1,5]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg" style="width: 500px; height: 277px;" />
<pre>
<strong>Input:</strong> root = [4,2,null,3,1], val = 1, depth = 3
<strong>Output:</strong> [4,2,null,1,1,3,null,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li>The depth of the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li><code>-10<sup>5</sup> &lt;= val &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description" target="_blank" rel="noopener noreferrer">All Ancestors of a Node in a Directed Acyclic Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing the number of nodes of a <strong>Directed Acyclic Graph</strong> (DAG). The nodes are numbered from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>).</p>

<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> denotes that there is a <strong>unidirectional</strong> edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> in the graph.</p>

<p>Return <em>a list</em> <code>answer</code><em>, where </em><code>answer[i]</code><em> is the <strong>list of ancestors</strong> of the</em> <code>i<sup>th</sup></code> <em>node, sorted in <strong>ascending order</strong></em>.</p>

<p>A node <code>u</code> is an <strong>ancestor</strong> of another node <code>v</code> if <code>u</code> can reach <code>v</code> via a set of edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/12/e1.png" style="width: 322px; height: 265px;" />
<pre>
<strong>Input:</strong> n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
<strong>Output:</strong> [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
<strong>Explanation:</strong>
The above diagram represents the input graph.
- Nodes 0, 1, and 2 do not have any ancestors.
- Node 3 has two ancestors 0 and 1.
- Node 4 has two ancestors 0 and 2.
- Node 5 has three ancestors 0, 1, and 3.
- Node 6 has five ancestors 0, 1, 2, 3, and 4.
- Node 7 has four ancestors 0, 1, 2, and 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/12/e2.png" style="width: 343px; height: 299px;" />
<pre>
<strong>Input:</strong> n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
<strong>Output:</strong> [[],[0],[0,1],[0,1,2],[0,1,2,3]]
<strong>Explanation:</strong>
The above diagram represents the input graph.
- Node 0 does not have any ancestor.
- Node 1 has one ancestor 0.
- Node 2 has two ancestors 0 and 1.
- Node 3 has three ancestors 0, 1, and 2.
- Node 4 has four ancestors 0, 1, 2, and 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= edges.length &lt;= min(2000, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>The graph is <strong>directed</strong> and <strong>acyclic</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed acyclic graph of <code>n</code> nodes, and our task is to return a list where each sub-list contains the ancestors of the node at that index, sorted in ascending order.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph (DAG)</a> is a graph where each edge has a defined direction from one vertex to another and following these edges will never create a closed loop.</p>
<p>A prerequisite for solving this problem is knowledge of graph traversals, namely depth-first search and breadth-first search. If you are not familiar with popular graph traversal techniques, we strongly encourage you to check out this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/">Explore Card</a>.</p>
<hr />
<h3 id="approach-1-depth-first-search-reversed-graph">Approach 1: Depth First Search (Reversed Graph)</h3>
<h4 id="intuition">Intuition</h4>
<p>A node <code>u</code> is an ancestor of node <code>v</code> if we can reach <code>v</code> by following a series of directed edges from <code>u</code>. Thus, all nodes from which we can reach <code>v</code> are its ancestors. But how can we efficiently find all ancestors for each node?</p>
<p>The brute force strategy to determine if node <code>u</code> is an ancestor of node <code>v</code> involves performing a graph traversal from <code>u</code> to check if <code>v</code> can be reached. However, this approach has a time complexity of <span class="math inline">\(O(n^3)\)</span>, which is too slow for our constraints. We need a more optimized technique.</p>
<p>The key insight lies in reversing the traversal direction. By starting from each node and tracing back to all its ancestors directly, we can simplify our task. This is achieved by reversing the edges of the graph, flipping parent-child connections to child-parent. Consequently, nodes reachable from a given node in the reversed graph were its ancestors in the original graph. Have a look at the slides below:</p>
<p>!?!../Documents/2192/reversed_slideshow.json:1162,1142!?!</p>
<p>To find the descendants of a node <code>v</code>, we start a depth-first traversal from <code>v</code> in the reversed graph, using a <code>visited</code> set to track nodes. After the traversal, we collect all nodes in <code>visited</code> (except <code>v</code>) in a list, representing the ancestors of <code>v</code> in the original graph. Performing this traversal for each node provides the required ancestors for all nodes.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Main method <code>getAncestors</code>:</p>
<ul>
<li>Initialize <code>adjacencyList</code> to store the graph representation.</li>
<li>Add the edges to the <code>adjacencyList</code> but reverse their direction.</li>
<li>Initialize a list of lists <code>ancestorsList</code> to store the ancestors of each node.</li>
<li>Iterate through each node:
<ul>
<li>Initialize:
<ul>
<li>An empty list <code>ancestors</code> to store ancestors of the current node.</li>
<li>A set <code>visited</code> to store the nodes already visited in the traversal.</li>
</ul>
</li>
<li>Call the <code>findChildren</code> method to perform DFS and find all descendants of the current node.</li>
<li>Add all nodes present in the <code>visited</code> set to <code>ancestors</code>.</li>
<li>Add <code>ancestors</code> to <code>ancestorsList</code>.</li>
</ul>
</li>
<li>Return <code>ancestorsList</code> containing the ancestors for each node.</li>
</ul>
</li>
<li>
<p>Helper method <code>findChildren</code>:</p>
<ul>
<li>Define the <code>findChildren</code> method with parameters: <code>currentNode</code>, <code>adjacencyList</code> and the <code>visited</code> set for the current traversal.</li>
<li>Add <code>currentNode</code> to the <code>visited</code> set.</li>
<li>Iterate through the neighbors of <code>currentNode</code>. If <code>neighbor</code> has not been visited yet:
<ul>
<li>Recursively call <code>findChildren</code> on <code>neighbor</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TMApG9fd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + n \cdot m)\)</span></p>
<p>Initializing and populating the adjacency list requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The algorithm calls the the DFS method a total of <span class="math inline">\(n\)</span> times. The depth-first search has a worst-case time complexity of <span class="math inline">\(O(n + m)\)</span>. Thus, finding the ancestors take a total of <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
<p>Forming the list of ancestors requires <span class="math inline">\(O(n)\)</span> time, which also occurs <span class="math inline">\(n\)</span> times. This equates to a <span class="math inline">\(O(n^2)\)</span> complexity.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(n + m)\)</span> + <span class="math inline">\(O(n^2 + n \cdot m)\)</span> + <span class="math inline">\(O(n^2)\)</span>, which simplifies to <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list takes <span class="math inline">\(O(n + m)\)</span> space, while the <code>ancestors</code> list and the <code>visited</code> set each require <span class="math inline">\(O(n)\)</span> space. The recursion call stack can go as deep as <span class="math inline">\(O(n)\)</span> in the worst case. Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + m) + 3 \cdot O(n)\)</span>, which simplifies to <span class="math inline">\(O(n + m)\)</span>.</p>
<blockquote>
<p>Note: We are not considering the space required by <code>ancestorsList</code> in our analysis, since it is part of the output space. If we do consider it, <code>ancestorsList</code> would have a worst-case space complexity of <span class="math inline">\(O(n^2)\)</span>, making the space complexity of the algorithm <span class="math inline">\(O(n^2 + m)\)</span>.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-optimized">Approach 2: Depth First Search (Optimized)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can solve this problem without reversing the edges. Observe that a vertex <code>v</code> will be an ancestor for all nodes reachable from it. Therefore, we can initiate a depth-first traversal from each vertex and designate that vertex as an ancestor to all nodes it can reach.</p>
<p>Our depth-first search would be very similar to Approach 1; but with a key difference: we add the given node as an <code>ancestor</code> to all children of the node we're currently exploring. We then recursively call our depth-first search function on each child until all descendants of <code>ancestor</code> are marked with its presence.</p>
<p>Have a look at this slideshow to better understand this process:</p>
<p>!?!../Documents/2192/ancestors_slideshow.json:1742,1310!?!</p>
<p>Another optimization we can implement is eliminating the <code>visited</code> set. In each traversal, we add <code>ancestor</code> to the list of ancestors for each node. To determine if a node has been visited, we check if its last ancestor matches the current ancestor. If it does, the node has been visited and can be safely skipped from further exploration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Main method <strong>getAncestors</strong>:</p>
<ul>
<li>Initialize:
<ul>
<li>A list of lists <code>adjacencyList</code> to store the adjacency list of the graph.</li>
<li>A list of lists <code>ancestors</code> to store the ancestors of each node.</li>
</ul>
</li>
<li>Populate <code>adjacencyList</code> with edges from the input.</li>
<li>For each node, use depth-first search (DFS) to find all its ancestors.</li>
<li>Return <code>ancestors</code> containing the ancestors of each node.</li>
</ul>
</li>
<li>
<p>Helper method <strong>findAncestorsDFS</strong>:</p>
<ul>
<li>Define a method <code>findAncestorsDFS</code> that takes four parameters: the <code>ancestor</code> node, <code>adjacencyList</code>, the current node being visited, and <code>ancestors</code>.</li>
<li>Loop through each child node <code>childNode</code> of the current node in the adjacency list:
<ul>
<li>Check if <code>ancestor</code> is already added to the child node's ancestor list. If not:
<ul>
<li>Add <code>ancestor</code> to the child node's ancestor list.</li>
<li>Recursively call <code>findAncestorsDFS</code> for <code>childNode</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ejRveq7U/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + n \cdot m)\)</span></p>
<p>Initializing and populating the adjacency list requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The depth-first search (DFS) has a time complexity of <span class="math inline">\(O(n + m)\)</span> and is executed <span class="math inline">\(n\)</span> times. Therefore, the total time complexity of this section is <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
<p>The overall time complexity of the algorithm combines <span class="math inline">\(O(n + m)\)</span> for initialization and <span class="math inline">\(O(n^2 + n \cdot m)\)</span> for the DFS, resulting in <span class="math inline">\(O(n^2 + n \cdot m)\)</span> complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list representation of the graph takes <span class="math inline">\(O(n + m)\)</span> space. The call stack for the DFS could go as deep as the height of the graph, which in the worst case is <span class="math inline">\(O(n)\)</span>. Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + m) + O(n)\)</span>, simplifying to <span class="math inline">\(O(n + m)\)</span>.</p>
<blockquote>
<p>Note: We have not considered the space required by <code>ancestors</code> in our analysis, since it is part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort-bfs">Approach 3: Topological Sort (BFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The problem revolves around the nature of the graph as a Directed Acyclic Graph (DAG). In a DAG, cycles are absent, and each path progresses clearly from a starting point to an endpoint. This characteristic implies that by processing nodes in a specific order, we can systematically determine each node's ancestors.</p>
<p>The key to identifying this optimal processing order lies in topological sorting. In a DAG, topological sorting arranges nodes such that for every directed edge from node <code>u</code> to node <code>v</code>, <code>u</code> precedes <code>v</code> in the ordering. This arrangement is crucial because it ensures that when we process a node <code>v</code>, we have already considered all its potential ancestors. To achieve this ordering, we will use Kahn's algorithm.</p>
<p>Kahn's algorithm is a method for topologically sorting a directed acyclic graph. It starts by identifying all nodes without incoming edges and placing them in a queue. At each step, it removes a node from this queue, adds it to the sorted list, and eliminates its outgoing edges from the graph. This process may create new nodes without incoming edges, which are then added to the queue. The algorithm continues until the queue is empty. The resulting list provides a valid topological ordering of the graph. For a more detailed explanation of Kahn's algorithm and its implementation, refer to this <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">Explore Card</a>.</p>
<p>After establishing the topological order, we process each node sequentially. For each <code>node</code>, we iterate through its <code>neighbors</code>, designating both the node itself and its ancestors as ancestors of the <code>neighbor</code>. To efficiently track each node's ancestors, we use a list of sets. Sets, unlike lists, maintain unique elements, ensuring each ancestor appears only once in a node's ancestor set.</p>
<p>In the final step, we'll convert these sets of ancestors into lists, as required by the problem statement.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a list of lists <code>adjacencyList</code> to store the edges of the graph.</li>
<li>Initialize an array <code>indegree</code> to store the in-degree of each node.</li>
<li>Fill <code>adjacencyList</code> and the <code>indegree</code> array based on the given edges.</li>
<li>Initialize a queue <code>nodesWithZeroIndegree</code> and add all such nodes to the queue.</li>
<li>Initialize a list <code>topologicalOrder</code> to store the topological order of nodes and process nodes in the queue. For each node:
<ul>
<li>Reduce the in-degree of its neighbors.</li>
<li>Add neighbors with zero in-degree to the queue.</li>
</ul>
</li>
<li>Initialize a list <code>ancestorsList</code> to store the result and a list of sets <code>ancestorsSetList</code> to store the ancestors of each node.</li>
<li>For each <code>node</code> in the topological order:
<ul>
<li>Loop over all neighbors <code>neighbor</code> of <code>node</code>. For each <code>neighbor</code>:
<ul>
<li>Add <code>node</code> as the immediate parent of <code>neighbor</code> to the set <code>ancestorsSetList[neighbor]</code>.</li>
<li>Add all other ancestors of <code>node</code> to the set <code>ancestorsSetList[neighbor]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add the contents of each set to it's corresponding list in <code>ancestorsList</code> in ascending order.</li>
<li>Return <code>ancestorsList</code>, which contains the ancestors of each node in the graph.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/BGfz4pY8/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + m)\)</span></p>
<p>Creating and filling the adjacency list and in-degree array requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>Topological sort on the graph also needs <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>In the worst-case scenario, if the graph forms a chain, the time complexity could be <span class="math inline">\(O(n^2)\)</span>. This is because each node in the chain would have a growing number of ancestors. So, the sizes of the ancestor lists would be <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, ..., <span class="math inline">\(n-2\)</span>, <span class="math inline">\(n-1\)</span>. Forming these lists would take another <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n^2 + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2 + m)\)</span></p>
<p>We use an adjacency list which takes <span class="math inline">\(O(n + m)\)</span> space.</p>
<p>We store an array of size <span class="math inline">\(n\)</span> to keep track of the indegree of each node, taking <span class="math inline">\(O(n)\)</span> space.</p>
<p>All nodes are added to the queue once, requiring <span class="math inline">\(O(n)\)</span> space.</p>
<p>The topological order list requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Maintaining a list of sets to store the ancestors requires <span class="math inline">\(O(n^2)\)</span> space in the worst case.</p>
<p>Considering all individual components, the total space complexity comes out to be <span class="math inline">\(O(n^2 + m)\)</span>.</p>
<blockquote>
<p>Note: As stated in the previous approaches, the space taken by <code>ancestorsList</code> is not taken into consideration since it is part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description" target="_blank" rel="noopener noreferrer">All Nodes Distance K in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, the value of a target node <code>target</code>, and an integer <code>k</code>, return <em>an array of the values of all nodes that have a distance </em><code>k</code><em> from the target node.</em></p>

<p>You can return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" style="width: 500px; height: 429px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
<strong>Output:</strong> [7,4,1]
Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1], target = 1, k = 3
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 500]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 500</code></li>
	<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>target</code> is the value of one of the nodes in the tree.</li>
	<li><code>0 &lt;= k &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-paths-from-source-to-target/description" target="_blank" rel="noopener noreferrer">All Paths From Source to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a directed acyclic graph (<strong>DAG</strong>) of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, find all possible paths from node <code>0</code> to node <code>n - 1</code> and return them in <strong>any order</strong>.</p>

<p>The graph is given as follows: <code>graph[i]</code> is a list of all nodes you can visit from node <code>i</code> (i.e., there is a directed edge from node <code>i</code> to node <code>graph[i][j]</code>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> graph = [[1,2],[3],[3],[]]
<strong>Output:</strong> [[0,1,3],[0,2,3]]
<strong>Explanation:</strong> There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" style="width: 423px; height: 301px;" />
<pre>
<strong>Input:</strong> graph = [[4,3,1],[3,2,4],[3],[4],[]]
<strong>Output:</strong> [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>2 &lt;= n &lt;= 15</code></li>
	<li><code>0 &lt;= graph[i][j] &lt; n</code></li>
	<li><code>graph[i][j] != i</code> (i.e., there will be no self-loops).</li>
	<li>All the elements of <code>graph[i]</code> are <strong>unique</strong>.</li>
	<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description" target="_blank" rel="noopener noreferrer">Amount of Time for Binary Tree to Be Infected</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree with <strong>unique</strong> values, and an integer <code>start</code>. At minute <code>0</code>, an <strong>infection</strong> starts from the node with value <code>start</code>.</p>

<p>Each minute, a node becomes infected if:</p>

<ul>
	<li>The node is currently uninfected.</li>
	<li>The node is adjacent to an infected node.</li>
</ul>

<p>Return <em>the number of minutes needed for the entire tree to be infected.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png" style="width: 400px; height: 306px;" />
<pre>
<strong>Input:</strong> root = [1,5,3,null,4,10,6,9,2], start = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> The following nodes are infected during:
- Minute 0: Node 3
- Minute 1: Nodes 1, 10 and 6
- Minute 2: Node 5
- Minute 3: Node 4
- Minute 4: Nodes 9 and 2
It takes 4 minutes for the whole tree to be infected so we return 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png" style="width: 75px; height: 66px;" />
<pre>
<strong>Input:</strong> root = [1], start = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> At minute 0, the only node in the tree is infected so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>Each node has a <strong>unique</strong> value.</li>
	<li>A node with a value of <code>start</code> exists in the tree.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to find the number of minutes needed for the entire tree to become infected. A node one level away from the start node takes 1 minute to become infected. All nodes on that level take the same amount of time to become infected. A node two levels away from the start node takes two minutes to become infected. We can reason that the distance of any given node from the start node will be the number of minutes it takes to infect the whole tree. Therefore, our solution will be the maximum distance from the start node.</p>
<hr />
<h3 id="approach-1-convert-to-graph-and-breadth-first-search">Approach 1: Convert to Graph and Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Before we can approach finding the maximum distance from the start node, we must note that the start node is not necessarily the root node. This means the infection may spread from child to root, which would include traversal from child to parent. The ordinary definition of a binary tree does not support this kind of traversal, so we need to convert the binary tree to a structure that represents the original but allows traversal from child to parent. In this scenario, a child is a neighbor of a parent and vice-versa. An undirected graph will work for this.</p>
<h5 id="1-convert-the-binary-tree-to-an-undirected-graph">1. Convert the binary tree to an undirected graph</h5>
<p>A tree is a special kind of graph with a root and subtrees. We want to search the graph from any node, not just the root, and be able to traverse to all neighbors, including parents and children. An undirected graph is a set of vertices with edges that connect them. We will use a map to represent our graph, made up of integer vertices, and an adjacency list to record the edges.</p>
<p>We can define a function that converts our binary tree to an undirected graph by traversing the tree and creating a graph. The parameters are the current node and its parent. We traverse the tree with a preorder traversal, visiting first the root, then the left and right child, so we can log the parent of each node and make a connection to it. When we encounter a new right or left child, we add them to the adjacency list.</p>
<p>The algorithm for this recursive <code>convert</code> function is defined as follows:</p>
<ol>
<li>If <code>current == null</code>, return.</li>
<li>If the root has a new value, we add it to the map and create a new adjacency list to store the adjacent vertices</li>
<li>Retrieve the adjacency list of the current vertex.</li>
<li>If <code>current</code> is not the root, add its parent to the adjacency list.</li>
<li>If <code>current</code> a left child, add the child to its adjacency list.</li>
<li>If <code>current</code> has a right child, add the child to its adjacency list.</li>
<li>Recursively call convert on <code>current.left</code> with current as the parent.</li>
<li>Recursively call convert on <code>current.right</code> with current as the parent.</li>
</ol>
<p><a href="https://leetcode.com/playground/R2LABaZY/shared">code</a></p>
<h5 id="2-conduct-a-breath-first-search-bfs-to-find-the-maximum-distance-between-the-start-and-other-vertices">2. Conduct a Breath First Search (BFS) to find the maximum distance between the start and other vertices.</h5>
<p>We can find the maximum distance between the vertex with the value <code>start</code> and the rest of the vertices in our graph by using a BFS starting with the <code>start</code>.</p>
<h6 id="standard-breadth-first-search">Standard Breadth-First Search</h6>
<ol>
<li>Add the first node to the queue</li>
<li>While the queue is not empty:
<ul>
<li>Remove the front node of the queue and mark it as visited.</li>
<li>Check whether all adjacent nodes have been visited. If they have not, add them to the queue</li>
</ul>
</li>
</ol>
<p>If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
<p>To determine the amount of time it takes to infect all of the vertices, we specifically need to determine the maximum distance from the start vertex. We use the variable <code>minute</code> to store the distance from the start vertex. We will make a few tweaks to BFS to update <code>minute</code> accurately.</p>
<p>For our implementation of BFS, we will use a queue to store the vertices that we need to visit. We will create a set to store the nodes we have already visited so we don't visit them multiple times. We add <code>start</code> to the queue and the visited set and then iterate through the vertices in the queue until it is empty.  We set the variable <code>levelSize</code> to the size of the queue so we can keep track of how many vertices are in the current level. We <code>poll()</code> a vertex <code>current</code> from the queue. We iterate through each of the values in its adjacency list checking whether each one has been visited. If they have not been visited, we add them to the queue and the visited set. After adding all of the adjacent vertices, we decrement <code>levelSize</code>. When there are no more vertices in the current level, we will move to the next level, so we increment the variable <code>minute</code>. When the queue is empty, we return <code>minute - 1</code>, because we have incremented <code>minute</code> for each level, but the time taken by the first node to infect neighbors is zero.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Declare a hash map <code>map</code> to store vertices and their adjacency list for edges.</li>
<li>Implement a function <code>convert</code> that creates an undirected graph of the tree and stores it in <code>map</code> as explained above.</li>
<li>Call <code>convert(root, 0, map)</code> as the root has no parent.</li>
<li>Set <code>minute</code>, the distance from the start vertex to 0.</li>
<li>Initialize a <code>queue</code> and add <code>start</code>.</li>
<li>Initialize a set <code>visited</code> to store the visited vertexes and add <code>start</code>.</li>
<li>While <code>queue</code> is not empty:
<ul>
<li>Set <code>levelSize</code>, the number of vertices in this level, to the size of <code>queue</code>.</li>
<li>While  <code>levelSize</code> is greater than 0:
<ul>
<li>Remove a vertex <code>current</code> from the <code>queue </code>.</li>
<li>For each edge in the adjacency list:
<ul>
<li>Check whether the edge has been visited. If not, add it to <code>queue</code> and <code>visited</code>.</li>
</ul>
</li>
<li>Decrement <code>levelSize</code>.</li>
</ul>
</li>
<li>Increment <code>minute</code> as the distance from <code>startNode</code> has increased.</li>
</ul>
</li>
<li>After the BFS, return <code>minute - 1</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/gWBgxCJ9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Converting the tree to a graph using a preorder traversal costs <span class="math inline">\(O(n)\)</span>. We then perform BFS, which also costs <span class="math inline">\(O(n)\)</span> because we don't visit a node more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>When converting the tree to a graph, we require <span class="math inline">\(O(n)\)</span> extra space for the map. We also require <span class="math inline">\(O(n)\)</span> space for the queue and <span class="math inline">\(O(n)\)</span> space for the visited set during the BFS.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-one-pass-depth-first-search">Approach 2: One-Pass Depth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The above solution passed over each node twice, once to create an undirected graph, and again to complete the breath first search. Is there a way to find the maximum distance from the start node with only one pass?</p>
<p>If the node with the value start happened to be the root, the maximum distance from the start node would be equivalent to the maximum height of the tree. We can also reason that there are certain test cases where the maximum height of the start node's sub-tree would be the maximum distance from the start node. An example case where this is true is <code>[1, 2, null, 3, null, 4, null]</code> where the start node is 2. In this case, all nodes have only one child.</p>
<p>Is there a way to calculate the maximum distance from the start node using subtree depths, even when the start node is not the root? This would help us solve the problem in just one pass.</p>
<p>The first question we need to solve is &quot;Can we determine the max distance of the start node using the depths of sub-trees?&quot; We use the image below to demonstrate a method for determining the max distance using sub-tree depths.</p>
<p><img src="../Documents/2385/2385.drawio.svg" alt="Tree with Highlighted Nodes" /></p>
<p>In the image above the start node is the red node, 5.<br />
subDepth = 2 // red subtree's depth (Nodes below the start node)<br />
depth = 1 // red node's depth (the start node)<br />
otherDepth = 2 // green subtree depth (nodes above the start node)<br />
distance = depth + other_depth = 3 // distance of any node above the start node from the start node<br />
maxDistance = max(distance, sub_depth) = 3</p>
<p>Knowing that we can calculate the maximum distance from the start node using subtree height, we can attempt a one-pass method of solving this problem. We can base our algorithm on a calculation of max depth using a depth-first search.</p>
<p>Here is the basic recursive algorithm for finding the maximum depth, which we will adjust to our needs.</p>
<ol>
<li>If <code>root = null</code> return 0.</li>
<li>Make a recursive call with root.right and save as <code>rightDepth</code>.</li>
<li>Make a recursive call with root.left and save as <code>leftDepth</code>.</li>
<li>Return max(rightDepth, leftDepth) + 1.</li>
</ol>
<p>One challenge to this task is identifying whether we have encountered the start node during the traversal. We can return a negative depth when we encounter the start node. This will flag that we have found the start node, and as we traverse the tree, whenever we encounter a negative depth, we know the subtree contains the start node.</p>
<p>Additionally, as we traverse the tree, we might find the start node before we have calculated the max depth of each part of the tree. Therefore, we need to be able to save the max distance and continue calculating it while traversing the rest of the tree.</p>
<p>There are four main cases:</p>
<ol>
<li>If <code>root</code> is null, return 0.</li>
<li><code>root.val = start</code>. If so, we return <code>depth = -1</code> to signify this is the start node. In this way, in subsequent recursive calls, the parent node of the start node will know whether its child nodes contain the start node. Here we are also able to calculate the <code>maxDistance</code> of any node in the start node's subtree by finding the max of the left and right depth.</li>
<li>The left and right depth are both non-negative. If they are, we know the start node is not in this subtree, and we can set <code>depth = max(leftDepth, rightDepth)</code> just like with the basic max depth.</li>
<li>The final case is when the <code>root</code> is not the start node, but its subtree contains the start node. In this case, we will set <code>depth = min(leftDepth, rightDepth) - 1</code>, which will give us a negative number, the absolute value of which represents the distance of the start node to the root node. To calculate the distance from the start node to the furthest node in the other subtree, we will add the absolute value of the negative depth of the subtree that contains the start node, and the positive depth of the other subtree, for convenience, we can directly take the absolute value of two values. Then, we update <code>maxDistance</code> with <code>distance</code> if it is larger.</li>
</ol>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Declare a variable <code>maxDistance</code> to store maximum distance from the start node.</li>
<li>Define a function <code>traverse</code> that performs a depth-first search of the tree that returns depth and calculates and saves <code>maxDistance</code>.
<ul>
<li>For each call to <code>traverse</code>, we have a new root and declare a variable <code>depth = 0</code>.</li>
<li>If <code>root == null</code> set <code>depth = 0</code> and return.</li>
<li>Recursively call <code>traverse</code> with <code>root.right</code> and save in the variable <code>rightDepth</code>.</li>
<li>Recursively call <code>traverse</code> with <code>root.left</code> and save in the variable <code>leftDepth</code>.</li>
<li>If <code>root = start</code> the root is the start node:
<ul>
<li>Set <code>maxDistance = max(leftDepth, rightDepth)</code>  to calcualte the start node's max depth.</li>
<li>Set <code>depth = -1</code> to signify this is the start node.</li>
</ul>
</li>
<li>If the <code>leftDepth</code> and <code>rightDepth</code> are both greater than or equal to <code>0</code>, the start node is not in this subtree:
<ul>
<li>Set <code>depth = max(leftDepth, rightDepth) + 1</code> to calculate the current root's max depth.</li>
</ul>
</li>
<li>Else, the current root's subtree contains the start node:
<ul>
<li>Define a variable <code>distance</code> as the sum of <code>abs(leftDepth)</code> and <code>abs(rightDepth)</code>, which is the distance of the furthest node in the other subtree.</li>
<li>Set <code>maxDistance = max(maxDistance,  distance)</code> to update <code>maxDistance</code> if <code>distance</code> is larger.</li>
<li>Set <code>depth = min(leftDepth, rightDepth) - 1</code> to calculate a negative number that signifies the subtree contains the start node and represents the distance of the start node from the root.</li>
</ul>
</li>
<li>return <code>depth</code>.</li>
</ul>
</li>
<li>Call <code>traverse(root, start)</code>.</li>
<li>Return <code>maxDistance</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gWL2KH7K/shared">code</a></p>
<h4 id="complexity">Complexity</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Traversing the tree with a DFS costs <span class="math inline">\(O(n)\)</span> as we visit each node exactly once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of DFS is determined by the maximum depth of the call stack, which corresponds to the height of the tree (or the graph in our case). In the worst case, if the tree is completely unbalanced (e.g., a linked list), the call stack can grow as deep as the number of nodes, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/as-far-from-land-as-possible/description" target="_blank" rel="noopener noreferrer">As Far from Land as Possible</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> <code>grid</code>&nbsp;containing only values <code>0</code> and <code>1</code>, where&nbsp;<code>0</code> represents water&nbsp;and <code>1</code> represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance.&nbsp;If no land or water exists in the grid, return <code>-1</code>.</p>

<p>The distance used in this problem is the Manhattan distance:&nbsp;the distance between two cells <code>(x0, y0)</code> and <code>(x1, y1)</code> is <code>|x0 - x1| + |y0 - y1|</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/03/1336_ex1.JPG" style="width: 185px; height: 87px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,1],[0,0,0],[1,0,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The cell (1, 1) is as far as possible from all the land with distance 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/03/1336_ex2.JPG" style="width: 184px; height: 87px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The cell (2, 2) is as far as possible from all the land with distance 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>
	<li><code>grid[i][j]</code>&nbsp;is <code>0</code> or <code>1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/average-of-levels-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Average of Levels in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given the <code>root</code> of a binary tree, return <em>the average value of the nodes on each level in the form of an array</em>. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" style="width: 292px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,15,7]
<strong>Output:</strong> [3.00000,14.50000,11.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bfs-traversal-of-graph/1" target="_blank" rel="noopener noreferrer">BFS of graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a&nbsp;<strong>connected undirected graph</strong> containing<strong> V </strong>vertices, <span style="font-size: 14pt;">represented by a 2-d&nbsp;</span>adjacency list&nbsp;<strong><code>adj[][]</code></strong>, where each&nbsp;<code>adj[i]</code>&nbsp;represents the list of vertices connected to vertex&nbsp;<code>i</code>. Perform a&nbsp;<strong>Breadth First Search (BFS)&nbsp;</strong>traversal&nbsp;starting from vertex&nbsp;<code>0</code>, visiting vertices from left to right according to the given adjacency list, and return a list containing the BFS traversal of the graph.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;Do traverse in the&nbsp;<strong>same order</strong>&nbsp;as they are in the given&nbsp;<strong>adjacency list</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>adj[][] = [[2, 3, 1], [0], [0, 4], [0], [2]]</span><br /><span style="font-size: 14pt;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700217/Web/Other/blobid0_1728648582.jpg" width="301" height="189" /><br /><strong>Output:</strong> [0, 2, 3, 1, 4]<br /><strong>Explanation:</strong> Starting from 0, the BFS traversal will follow these steps: <br />Visit 0 &rarr; Output: 0 <br />Visit 2 (first neighbor of 0) &rarr; Output: 0, 2 <br />Visit 3 (next neighbor of 0) &rarr; Output: 0, 2, 3 <br />Visit 1 (next neighbor of 0) &rarr; Output: 0, 2, 3, <br />Visit 4 (neighbor of 2) &rarr; Final Output: 0, 2, 3, 1, 4</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Input: </strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">adj[][] = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]]<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700217/Web/Other/blobid1_1728648604.jpg" width="301" height="189" /><br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Output:</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> [0, 1, 2, 3, 4]<br /><strong>Explanation: </strong></span><span style="font-family: -apple-system, system-ui, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif;">Starting from 0, the BFS traversal proceeds as follows: <br />Visit 0 &rarr; Output: 0 <br />Visit 1 (the first neighbor of 0) &rarr; Output: 0, 1 <br />Visit 2 (the next neighbor of 0) &rarr; Output: 0, 1, 2 <br />Visit 3 (the first neighbor of 2 that hasn't been visited yet) &rarr; Output: 0, 1, 2, 3 <br />Visit 4 (the next neighbor of 2) &rarr; Final Output: 0, 1, 2, 3, 4</span></span></pre>
<p><span style="font-size: 14pt;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Constraints:<br /></strong>1 &le; V = adj.size() &le; 10<sup>4<br /></sup>1 &le; adj[i][j] &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-level-order-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Level Order Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[9,20],[15,7]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-level-order-traversal-ii/description" target="_blank" rel="noopener noreferrer">Binary Tree Level Order Traversal II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the bottom-up level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level from leaf to root).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[15,7],[9,20],[3]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-right-side-view/description" target="_blank" rel="noopener noreferrer">Binary Tree Right Side View</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,null,5,null,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" style="width: 400px; height: 207px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,null,null,null,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,4,5]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" style="width: 400px; height: 214px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Zigzag Level Order Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[20,9],[15,7]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/bipartite-graph/1" target="_blank" rel="noopener noreferrer">Bipartite Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Graph with <strong>V</strong>&nbsp;vertices (Numbered from&nbsp;<strong>0</strong>&nbsp;to&nbsp;<strong>V-1</strong>) and&nbsp;<strong>E</strong> edges.&nbsp;Check whether the graph is <strong>bipartite</strong> or not.</span></p>
<p dir="ltr" style="box-sizing: border-box; margin: 0px 0px 10px; padding: 0px; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">A</span><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">&nbsp;<a href="https://www.geeksforgeeks.org/what-is-bipartite-graph/" target="_blank" rel="noopener">bipartite graph</a>&nbsp;</strong><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">can be colored with two colors such that <strong>no two</strong> <strong>adjacent</strong> <strong>vertices</strong> share the <strong>same color</strong>. This means we can divide the graph&rsquo;s vertices into two distinct sets where:</span></p>
<ul>
<li dir="ltr" style="box-sizing: border-box; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">All edges connect vertices from one set to vertices in the other set.</span></li>
<li dir="ltr" style="box-sizing: border-box; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">No edges exist between vertices within the same set.</li>
</ul>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V = 3<strong>, </strong>edges[][] = [[0, 1], [1,2]]
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240926114602/Bipartite-Graph.webp" alt="Bipartite-Graph" width="254" height="226" />
<strong>Output: </strong>true
<strong>Explanation: </strong>The given graph can be colored in two colors so, it is a bipartite graph.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, edges[][] = [[0, 3], [1, 2], [3, 2], [0, 2]]<br /></span><br /><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700410/Web/Other/blobid0_1735020917.webp" width="319" height="212" /><br /><br /><span style="font-size: 18px;"><strong>Output: </strong>false <br /><strong>Explanation: </strong>The given graph cannot be colored in two colors such that color of adjacent vertices differs. </span></pre>
<p><span style="font-size: 18px;"><strong style="font-size: 18px;">Constraints:<br /></strong><span style="font-size: 18px;">1&nbsp;</span><span style="color: #1e2229; font-family: 'andale mono', monospace; font-size: 18.6667px; background-color: #ffffff;">&le; V&nbsp;</span><span style="color: #1e2229; font-family: 'andale mono', monospace; font-size: 18.6667px; background-color: #ffffff;">&le; 2 </span><span style="color: #1e2229; font-family: 'andale mono', monospace; font-size: 18.6667px; background-color: #ffffff;">* 10</span><span style="color: #1e2229; white-space: normal; background-color: #ffffff;"><sup>5</sup></span><br /><span style="font-family: 'andale mono', monospace; font-size: 14pt;"><span style="color: #1e2229; white-space: normal; background-color: #ffffff;">1 &le; edges.size() &le; 10</span><span style="box-sizing: border-box; line-height: 1.7em; position: relative; vertical-align: baseline; top: -0.5em; color: #1e2229; background-color: #ffffff; white-space: normal;">5<br style="box-sizing: border-box; line-height: 1.7em; color: var(--text-color) !important; background-color: var(--background) !important;" /></span><span style="color: #1e2229; white-space: normal; background-color: #ffffff;">1 &le; edges[i][j] &le; 10</span><span style="box-sizing: border-box; line-height: 1.7em; position: relative; vertical-align: baseline; top: -0.5em; color: #1e2229; background-color: #ffffff; white-space: normal;">5</span></span><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/brace-expansion-ii/description" target="_blank" rel="noopener noreferrer">Brace Expansion II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Under the grammar given below, strings can represent a set of lowercase words. Let&nbsp;<code>R(expr)</code>&nbsp;denote the set of words the expression represents.</p>

<p>The grammar can best be understood through simple examples:</p>

<ul>
	<li>Single letters represent a singleton set containing that word.
	<ul>
		<li><code>R(&quot;a&quot;) = {&quot;a&quot;}</code></li>
		<li><code>R(&quot;w&quot;) = {&quot;w&quot;}</code></li>
	</ul>
	</li>
	<li>When we take a comma-delimited list of two or more expressions, we take the union of possibilities.
	<ul>
		<li><code>R(&quot;{a,b,c}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code></li>
		<li><code>R(&quot;{{a,b},{b,c}}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code> (notice the final set only contains each word at most once)</li>
	</ul>
	</li>
	<li>When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.
	<ul>
		<li><code>R(&quot;{a,b}{c,d}&quot;) = {&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;}</code></li>
		<li><code>R(&quot;a{b,c}{d,e}f{g,h}&quot;) = {&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;}</code></li>
	</ul>
	</li>
</ul>

<p>Formally, the three rules for our grammar:</p>

<ul>
	<li>For every lowercase letter <code>x</code>, we have <code>R(x) = {x}</code>.</li>
	<li>For expressions <code>e<sub>1</sub>, e<sub>2</sub>, ... , e<sub>k</sub></code> with <code>k &gt;= 2</code>, we have <code>R({e<sub>1</sub>, e<sub>2</sub>, ...}) = R(e<sub>1</sub>) &cup; R(e<sub>2</sub>) &cup; ...</code></li>
	<li>For expressions <code>e<sub>1</sub></code> and <code>e<sub>2</sub></code>, we have <code>R(e<sub>1</sub> + e<sub>2</sub>) = {a + b for (a, b) in R(e<sub>1</sub>) &times; R(e<sub>2</sub>)}</code>, where <code>+</code> denotes concatenation, and <code>&times;</code> denotes the cartesian product.</li>
</ul>

<p>Given an expression representing a set of words under the given grammar, return <em>the sorted list of words that the expression represents</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;{a,b}{c,{d,e}}&quot;
<strong>Output:</strong> [&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;{{a,z},a{b,c},{ab,z}}&quot;
<strong>Output:</strong> [&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;]
<strong>Explanation:</strong> Each distinct word is written only once in the final answer.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 60</code></li>
	<li><code>expression[i]</code> consists of <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;,&#39;</code>or lowercase English letters.</li>
	<li>The given&nbsp;<code>expression</code>&nbsp;represents a set of words based on the grammar given in the description.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/bulb-switcher-ii/description" target="_blank" rel="noopener noreferrer">Bulb Switcher II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a room with <code>n</code> bulbs labeled from <code>1</code> to <code>n</code> that all are turned on initially, and <strong>four buttons</strong> on the wall. Each of the four buttons has a different functionality where:</p>

<ul>
	<li><strong>Button 1:</strong> Flips the status of all the bulbs.</li>
	<li><strong>Button 2:</strong> Flips the status of all the bulbs with even labels (i.e., <code>2, 4, ...</code>).</li>
	<li><strong>Button 3:</strong> Flips the status of all the bulbs with odd labels (i.e., <code>1, 3, ...</code>).</li>
	<li><strong>Button 4:</strong> Flips the status of all the bulbs with a label <code>j = 3k + 1</code> where <code>k = 0, 1, 2, ...</code> (i.e., <code>1, 4, 7, 10, ...</code>).</li>
</ul>

<p>You must make <strong>exactly</strong> <code>presses</code> button presses in total. For each press, you may pick <strong>any</strong> of the four buttons to press.</p>

<p>Given the two integers <code>n</code> and <code>presses</code>, return <em>the number of <strong>different possible statuses</strong> after performing all </em><code>presses</code><em> button presses</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1, presses = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> Status can be:
- [off] by pressing button 1
- [on] by pressing button 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, presses = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> Status can be:
- [off, off] by pressing button 1
- [on, off] by pressing button 2
- [off, on] by pressing button 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3, presses = 1
<strong>Output:</strong> 4
<strong>Explanation:</strong> Status can be:
- [off, off, off] by pressing button 1
- [off, on, off] by pressing button 2
- [on, off, on] by pressing button 3
- [off, on, on] by pressing button 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= presses &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-reduce-search-space-accepted">Approach 1: Reduce Search Space [Accepted]</h3>
<h3 id="intuition">Intuition</h3>
<p>As the search space is very large (<span class="math inline">\(2^N\)</span> states of lights, naively <span class="math inline">\(4^M\)</span> operation sequences), let us try to reduce it.</p>
<p>The first 6 lights uniquely determine the rest of the lights. This is because every operation that modifies the <span class="math inline">\(x\)</span>-th light also modifies the <span class="math inline">\((x+6)\)</span>-th light.</p>
<p>Also, operations commute: doing operation A followed by B is the same as doing operation B followed by A. So we can assume we do all the operations in order.</p>
<p>Finally, doing the same operation twice in a row is the same as doing nothing. So we only need to consider whether each operation was done 0 or 1 times.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Say we do the <span class="math inline">\(i\)</span>-th operation <span class="math inline">\(f_i\)</span> times. Let's first figure out what sets of residues are possible: that is, what sets <span class="math inline">\(c_i = f_i\)</span> (<span class="math inline">\(\mod 2\)</span> ) are possible.</p>
<p>Because <span class="math inline">\(c_i \equiv f_i\)</span> and <span class="math inline">\(c_i \leq f_i\)</span>, if <span class="math inline">\(\sum f_i \not\equiv \sum c_i\)</span>, or if <span class="math inline">\(\sum f_i < \sum c_i\)</span>, it isn't possible. Otherwise, it is possible by a simple construction: do the operations specified by <span class="math inline">\(c_i\)</span>, then do operation number 1 with the even number of operations you have left.</p>
<p>For each possible set of residues, let's simulate and remember what the first 6 lights will look like, storing it in a <em>Set</em> structure <code>seen</code>. At the end, we'll return the size of this set.</p>
<p>In Java, we make use of bit manipulations to manage the state of lights, whereas in Python we simulate it directly.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4uKAdpEY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(1)\)</span>. Our checks are bounded by a constant.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>, the size of the data structures used.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-mathematical-accepted">Approach 2: Mathematical [Accepted]</h3>
<h4 id="intuition-and-algorithm">Intuition and Algorithm</h4>
<p>As before, the first 6 lights uniquely determine the rest of the lights. This is because every operation that modifies the <span class="math inline">\(x\)</span>-th light also modifies the <span class="math inline">\((x+6)\)</span>-th light, so the <span class="math inline">\(x\)</span>-th light is always equal to the <span class="math inline">\((x+6)\)</span>-th light.</p>
<p>Actually, the first 3 lights uniquely determine the rest of the sequence, as shown by the table below for performing the operations a, b, c, d:</p>
<ul>
<li>Light 1 = 1 + a + c + d</li>
<li>Light 2 = 1 + a + b</li>
<li>Light 3 = 1 + a + c</li>
<li>Light 4 = 1 + a + b + d</li>
<li>Light 5 = 1 + a + c</li>
<li>Light 6 = 1 + a + b</li>
</ul>
<p>So that (modulo 2):</p>
<ul>
<li>Light 4 = (Light 1) + (Light 2) - (Light 3)</li>
<li>Light 5 = Light 3</li>
<li>Light 6 = Light 2</li>
</ul>
<p>The above justify taking <span class="math inline">\(n = min(n, 3)\)</span> without loss of generality. The rest is now casework.</p>
<p>Let's denote the state of lights by the tuple <span class="math inline">\((a, b, c)\)</span>. The transitions are to XOR by <span class="math inline">\((1, 1, 1), (0, 1, 0), (1, 0, 1),\)</span> or <span class="math inline">\((1, 0, 0)\)</span>.</p>
<p>When <span class="math inline">\(m = 0\)</span>, all the lights are on, and there is only one state <span class="math inline">\((1, 1, 1)\)</span>. The answer in this case is always 1.</p>
<p>When <span class="math inline">\(m = 1\)</span>, we could get states <span class="math inline">\((0, 0, 0)\)</span>, <span class="math inline">\((1, 0, 1)\)</span>, <span class="math inline">\((0, 1, 0)\)</span>, or <span class="math inline">\((0, 1, 1)\)</span>. The answer in this case is either <span class="math inline">\(2, 3, 4\)</span> for <span class="math inline">\(n = 1, 2, 3\)</span> respectively.</p>
<p>When <span class="math inline">\(m = 2\)</span>, we can manually check that we can get 7 states: all of them except for <span class="math inline">\((0, 1, 1)\)</span>. The answer in this case is either <span class="math inline">\(2, 4, 7\)</span> for <span class="math inline">\(n = 1, 2, 3\)</span> respectively.</p>
<p>When <span class="math inline">\(m = 3\)</span>, we can get all 8 states. The answer in this case is either <span class="math inline">\(2, 4, 8\)</span> for <span class="math inline">\(n = 1, 2, 3\)</span> respectively.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/AcZyWhXU/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>Time and Space Complexity: <span class="math inline">\(O(1)\)</span>. The entire program uses constants.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/burning-tree/1" target="_blank" rel="noopener noreferrer">Burning Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary tree and a <strong>target</strong> node, determine the minimum time required to burn the entire tree if the <strong>target </strong>node is set on fire. In one second, the fire spreads from a node to its left child, right child, and parent.<br /><strong>Note:</strong> The tree contains unique values.</span></p>
<p><strong><span style="font-size: 18px;">Examples :&nbsp;</span></strong></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">root[] = [1, 2, 3, 4, 5, 6, 7], target = 2</span><strong style="font-size: 18px;"><br /></strong><strong style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/702131/Web/Other/blobid0_1747048733.webp" width="397" height="253" /> &nbsp;</strong></span>
<span style="font-size: 18px;"><strong>Output:</strong> 3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong> Initially 2 is set to fire at 0 sec <br />At 1 sec: Nodes 4, 5, 1 catches fire.<br />At 2 sec: Node 3 catches fire.<br />At 3 sec: Nodes 6, 7 catches fire.<br />It takes 3s to burn the complete tree.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> <span class="hljs-variable">root</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">5</span><span class="hljs-operator">,</span> <span class="hljs-built_in">N</span><span class="hljs-operator">,</span> <span class="hljs-number">7</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">,</span> <span class="hljs-built_in">N</span><span class="hljs-operator">,</span> <span class="hljs-number">10</span><span class="hljs-punctuation">]</span><span class="hljs-operator">, </span>target = 10<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/702131/Web/Other/blobid1_1747048769.webp" width="340" height="306" /><br /><span style="font-size: 18px;"><strong style="font-size: 18px;">Output:</strong><span style="font-size: 18px;"> 5<br /></span><strong style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><strong style="font-size: 18px;">: </strong><span style="font-size: 18px;">Initially 10 is set to fire at 0 sec </span><strong style="font-size: 18px;"><br /></strong><span style="font-size: 18px;">At 1 sec: Node 5 catches fire.
At 2 sec: Node 2 catches fire.
At 3 sec: Nodes 1 and 4 catches fire.
At 4 sec: Node 3 and 8 catches fire.
At 5 sec: Node 7 catches fire.
It takes 5s to burn the complete tree.</span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le;&nbsp;</span><span style="font-size: 18px;">number of nodes</span><span style="font-size: 18px;">&nbsp;&le; 10</span><sup>5<br /></sup><span style="font-size: 18px;">1 &le; node-&gt;data</span><span style="font-size: 18px;">&nbsp;&le; 10</span><sup>5</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/bus-routes/description" target="_blank" rel="noopener noreferrer">Bus Routes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>routes</code> representing bus routes where <code>routes[i]</code> is a bus route that the <code>i<sup>th</sup></code> bus repeats forever.</p>

<ul>
	<li>For example, if <code>routes[0] = [1, 5, 7]</code>, this means that the <code>0<sup>th</sup></code> bus travels in the sequence <code>1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; ...</code> forever.</li>
</ul>

<p>You will start at the bus stop <code>source</code> (You are not on any bus initially), and you want to go to the bus stop <code>target</code>. You can travel between bus stops by buses only.</p>

<p>Return <em>the least number of buses you must take to travel from </em><code>source</code><em> to </em><code>target</code>. Return <code>-1</code> if it is not possible.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> routes = [[1,2,7],[3,6,7]], source = 1, target = 6
<strong>Output:</strong> 2
<strong>Explanation:</strong> The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= routes.length &lt;= 500</code>.</li>
	<li><code>1 &lt;= routes[i].length &lt;= 10<sup>5</sup></code></li>
	<li>All the values of <code>routes[i]</code> are <strong>unique</strong>.</li>
	<li><code>sum(routes[i].length) &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= routes[i][j] &lt; 10<sup>6</sup></code></li>
	<li><code>0 &lt;= source, target &lt; 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-breadth-first-search-bfs-with-bus-stops-as-nodes">Approach 1: Breadth-First Search (BFS) with Bus Stops as Nodes</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are not familiar with Breadth-First Search (BFS) algorithms, please refer to our explore cards: <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth-First Search Explore Card</a>. We will focus on the usage in this article and not the implementation details.</p>
</blockquote>
<p>This approach will build up the graph using the bus stops as the nodes. To connect the edges in this graph, we need to find the stop we can go from a particular stop. There can be multiple routes that have this stop, we can go to any bus stop that is present in all these routes. One way is to store all these bus stops in the routes that have this stop, but this would take up too much memory. Instead, we can only store the indices of the routes that have the stop. The next reachable stop from this stop will be all the bus stops on all these routes.</p>
<p>So, we have prepared a graph where the nodes are bus stops and we can find the next stop we can travel to from each stop. We need to find the shortest distance between two given nodes &quot;source&quot; and &quot;target&quot;. Since the edges are unweighted, BFS is more appropriate than Dijkstra's algorithm.</p>
<p>In the problem statement, it's given that we are not on any bus initially. Hence, to start from the bus stop <code>source</code> we can board any of the bus that has the <code>source</code> as one of the stops in its route. So the breadth-first search here needs to be a multi-source BFS starting with all the buses that have the <code>source</code> in stops. During the BFS, we will pop the first bus from the queue and iterate over the stops that this route involves. For each stop, we will check if this stop is equal to <code>target</code>, and then we can return the current count of buses <code>busCount</code>. If the stop is not equal to <code>target</code> then we will iterate over all the routes that have this stop and add them to the queue if the route is not visited before. Note that we are keeping track of visited routes instead of bus stops because when we visit a route we are essentially visiting all the stops in that route and hence keeping track of visited stops individually is not that efficient.</p>
<p>If we have completed the BFS and still haven't reached the <code>target</code>, it implies there is no way to reach that stop and hence we can return <code>-1</code>.</p>
<p><img src="../Figures/815/815A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Return <code>0</code> if the <code>source</code> and <code>target</code> are the same.</p>
</li>
<li>
<p>Initialize an empty map from an integer to a list of integers <code>adjList</code> to store the edges. The key is the bus stop and the value is the list of integers denoting the indices of routes that have this stop.</p>
</li>
<li>
<p>Initialize an empty queue <code>q</code> and an unordered set <code>vis</code> to keep track of visited routes.</p>
</li>
<li>
<p>Insert the initial routes into the queue <code>q</code> and mark them visited in <code>vis</code>.</p>
</li>
<li>
<p>Iterate over the queue while it's not empty and do the following:</p>
<ol>
<li>Pop the route from the queue.</li>
<li>Iterate over the stops in the route.</li>
<li>If the stop is equal to <code>target</code>, return <code>busCount</code>.</li>
<li>Otherwise, iterate over the routes for this stop in the map <code>adjList</code>.</li>
<li>Add the unvisited routes to the queue and mark them visited.</li>
</ol>
</li>
<li>
<p>Return <code>-1</code> after completing the BFS.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/NbR4YD7h/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(M\)</span> is the size of <code>routes</code>, and <span class="math inline">\(K\)</span> is the maximum size of <code>routes[i]</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M^2 * K)\)</span></p>
<p>To store the routes for each stop we iterate over each route and for each route, we iterate over each stop, hence this step will take <span class="math inline">\(O(M* K)\)</span> time. In the BFS, we iterate over each route in the queue. For each route we popped, we will iterate over its stop, and for each stop, we will iterate over the connected routes in the map <code>adjList</code>, hence the time required will be <span class="math inline">\(O(M * K * M)\)</span> or <span class="math inline">\(O(M^2 * K)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot K)\)</span></p>
<p>The map <code>adjList</code> will store the routes for each stop. There can be <span class="math inline">\(M \cdot K\)</span> number of stops in <code>routes</code> in the worst case (each of the <span class="math inline">\(M\)</span> routes can have <span class="math inline">\(K\)</span> stops), possibly with duplicates. When represented using <code>adjList</code>, each of the mentioned stops appears exactly once. Therefore, <code>adjList</code> contains an equal number of stop-route element pairs.<br />
<br/></p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs-with-routes-as-nodes">Approach 2: Breadth-First Search (BFS) with Routes as Nodes</h3>
<p><strong>Intuition</strong></p>
<p>Instead of considering the individual stops as the nodes in the graph, what if we consider the bus routes as the nodes? If we consider the bus routes as the nodes, all stops that are there in the bus route will be considered in that node itself and hence the buses required to travel across them should be <code>0</code>. Two bus routes will be considered connected if they have a common stop, this is because it would need two travels from a stop on one bus route to another stop on the other route.</p>
<p>Now, we have the graph ready with routes as the nodes and edges between them if there is a common stop between them. We need to find a way to get the shortest distance between <code>source</code> and <code>target</code>. We can use a similar BFS strategy to get the shortest distance. Similar to the previous approach, it would be a multi-source BFS, the initial points of our search would be the routes that have the <code>source</code> as one of the stops.</p>
<p>During the BFS we will pop the route from the queue, we will first check if this route has the stop <code>target</code>. If it does, we can return the <code>busCount</code>. Otherwise, we will iterate over the next route that we can travel to. For each adjacent route, we will add it to the queue if it's not visited yet. If we have completed the BFS and still haven't reached the <code>target</code>, it implies there is no way to reach that stop and hence we can return <code>-1</code>.</p>
<p><img src="../Figures/815/815B.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Define these methods:</p>
<ol>
<li><code>createGraph</code>: Iterate over each pair of routes and add an edge between them in <code>adjList</code> if there is a common stop in them.</li>
<li><code>haveCommonNode</code>: Accept two routes and return <code>true</code> if there is a common stop, otherwise false.</li>
<li><code>addStartingNodes</code>: Add all the routes in the queue <code>q</code> that have the <code>source</code> as one of the stops in it.</li>
<li><code>isStopExist</code>: Returns true if a stop is present in the route, false otherwise.</li>
</ol>
</li>
<li>
<p>Return <code>0</code>, if the <code>source</code> and <code>target</code> is the same.</p>
</li>
<li>
<p>Iterate over the routes and sort each <code>route[i]</code>, this will help in finding if these routes have a common stop or not.</p>
</li>
<li>
<p>Add the edges in the graph using the <code>createGraph</code> method.</p>
</li>
<li>
<p>Add the starting nodes in the queue using the <code>addStartingNodes</code> method.</p>
</li>
<li>
<p>Iterate over the routes in the queue and for each route do the following:</p>
<ol>
<li>Pop the route from the queue.</li>
<li>If the <code>target</code> is present in the route, return <code>busCount</code>.</li>
<li>Otherwise, iterate over the adjacent routes for this route <code>adjList</code>.</li>
<li>Add the unvisited routes to the queue and mark them visited.</li>
</ol>
</li>
<li>
<p>Return <code>-1</code> after completing the BFS.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/ZF9TFkKs/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(M\)</span> is the size of <code>routes</code>, and <span class="math inline">\(K\)</span> is the maximum size of <code>routes[i]</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M^2 * K + M * k * \log K)\)</span></p>
<p>The <code>createGraph</code> method will iterate over every pair of <span class="math inline">\(M\)</span> routes and for each iterate over the <span class="math inline">\(K\)</span> stops to check if there is a common stop, this step will take <span class="math inline">\(O(M^2 * K)\)</span>. The <code>addStartingNodes</code> method will iterate over all the <span class="math inline">\(M\)</span> routes and check if the route has <code>source</code> in it, this step will take <span class="math inline">\(O(M * K)\)</span>. In BFS, we iterate over each of the <span class="math inline">\(M\)</span> routes, and for each route, we iterate over the adjacent route which could be <span class="math inline">\(M\)</span> again, so the time it takes is <span class="math inline">\(O(M^2)\)</span>.</p>
<p>Sorting each <span class="math inline">\(\text{routes}[i]\)</span> takes <span class="math inline">\(K * \log K\)</span> time.</p>
<p>Thus, the time complexity is equal to <span class="math inline">\(O(M^2 * K + M * K * \log K)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M^2 + \log K)\)</span></p>
<p>The map <code>adjList</code> will store the routes for each route, thus the space it takes is <span class="math inline">\(O(M^2)\)</span>. The queue <code>q</code> and the set <code>visited</code> store the routes and hence can take <span class="math inline">\(O(M)\)</span> space.</p>
<p>Some extra space is used when we sort <span class="math inline">\(\text{routes}[i]\)</span> in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O(\log K)\)</span>.</li>
<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log K)\)</span>.</li>
</ul>
<p>Thus, the total space complexity is equal to <span class="math inline">\(O(M^2 + \log K)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/cheapest-flights-within-k-stops/1" target="_blank" rel="noopener noreferrer">Cheapest Flights Within K Stops</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">queue</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are&nbsp;<code>n</code>&nbsp;cities and m edges connected by some number of flights. You are given an array&nbsp;<code>flights</code>&nbsp;where&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code>&nbsp;indicates that there is a flight from the city&nbsp;<code>from<sub>i</sub></code>&nbsp;to city&nbsp;<code>to<sub>i</sub></code>&nbsp;with cost&nbsp;<code>price<sub>i</sub></code>.</span></p>
<p><span style="font-size: 18px;">You are also given three integers&nbsp;<code>src</code>,&nbsp;<code>dst</code>, and&nbsp;<code>k</code>, return&nbsp;<em><strong>the cheapest price</strong>&nbsp;from&nbsp;</em><code>src</code><em>&nbsp;to&nbsp;</em><code>dst</code><em>&nbsp;with at most&nbsp;</em><code>k</code><em>&nbsp;stops.&nbsp;</em>If there is no such route, return<em>&nbsp;</em><code>-1</code>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note</strong>: The price from city A to B may be different From the price from city B to A. </span></p>
<pre><span style="font-size: 18px;"><strong>Example 1:</strong>
<strong>Input:</strong>
n = 4
flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]
src = 0
dst = 3
k = 1
<strong>Output:</strong>
700
Explanation:
</span><span style="font-size: 18px;">The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br /><code>1 &lt;= n &lt;= 100<br />
0 &lt;= flights.length &lt;= (n * (n - 1) / 2)<br />
flights[i].length == 3<br />
0 &lt;= from<sub>i</sub>, to<sub>i</sub>&nbsp;&lt; n<br />
from<sub>i</sub>&nbsp;!= to<sub>i</sub><br />
1 &lt;= price<sub>i</sub>&nbsp;&lt;= 10<sup>4</sup></code><br />There will not be any multiple flights between the two cities.<br /><code>0 &lt;= src, dst, k &lt; n<br />
src != dst</code></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cheapest-flights-within-k-stops/description" target="_blank" rel="noopener noreferrer">Cheapest Flights Within K Stops</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities connected by some number of flights. You are given an array <code>flights</code> where <code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> indicates that there is a flight from city <code>from<sub>i</sub></code> to city <code>to<sub>i</sub></code> with cost <code>price<sub>i</sub></code>.</p>

<p>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return <em><strong>the cheapest price</strong> from </em><code>src</code><em> to </em><code>dst</code><em> with at most </em><code>k</code><em> stops. </em>If there is no such route, return<em> </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-3drawio.png" style="width: 332px; height: 392px;" />
<pre>
<strong>Input:</strong> n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1
<strong>Output:</strong> 700
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-1drawio.png" style="width: 332px; height: 242px;" />
<pre>
<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
<strong>Output:</strong> 200
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-2drawio.png" style="width: 332px; height: 242px;" />
<pre>
<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
<strong>Output:</strong> 500
<strong>Explanation:</strong>
The graph is shown above.
The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>
	<li><code>flights[i].length == 3</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>There will not be any multiple flights between two cities.</li>
	<li><code>0 &lt;= src, dst, k &lt; n</code></li>
	<li><code>src != dst</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-completeness-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Check Completeness of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, determine if it is a <em>complete binary tree</em>.</p>

<p>In a <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">complete binary tree</a></strong>, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png" style="width: 180px; height: 145px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> true
<strong>Explanation:</strong> Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png" style="width: 200px; height: 145px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,null,7]
<strong>Output:</strong> false
<strong>Explanation:</strong> The node with value 7 isn&#39;t as far left as possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-the-rectangle-corner-is-reachable/description" target="_blank" rel="noopener noreferrer">Check if the Rectangle Corner Is Reachable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">geometry</span> <span class="topic-badge">math</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integers <code>xCorner</code> and <code>yCorner</code>, and a 2D array <code>circles</code>, where <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> denotes a circle with center at <code>(x<sub>i</sub>, y<sub>i</sub>)</code> and radius <code>r<sub>i</sub></code>.</p>

<p>There is a rectangle in the coordinate plane with its bottom left corner at the origin and top right corner at the coordinate <code>(xCorner, yCorner)</code>. You need to check whether there is a path from the bottom left corner to the top right corner such that the <strong>entire path</strong> lies inside the rectangle, <strong>does not</strong> touch or lie inside <strong>any</strong> circle, and touches the rectangle <strong>only</strong> at the two corners.</p>

<p>Return <code>true</code> if such a path exists, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 3, yCorner = 4, circles = [[2,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/18/example2circle1.png" style="width: 346px; height: 264px;" /></p>

<p>The black curve shows a possible path between <code>(0, 0)</code> and <code>(3, 4)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 3, yCorner = 3, circles = [[1,1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/18/example1circle.png" style="width: 346px; height: 264px;" /></p>

<p>No path exists from <code>(0, 0)</code> to <code>(3, 3)</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 3, yCorner = 3, circles = [[2,1,1],[1,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/18/example0circle.png" style="width: 346px; height: 264px;" /></p>

<p>No path exists from <code>(0, 0)</code> to <code>(3, 3)</code>.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 4, yCorner = 4, circles = [[5,5,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/rectangles.png" style="width: 346px; height: 264px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= xCorner, yCorner &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= circles.length &lt;= 1000</code></li>
	<li><code>circles[i].length == 3</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Check if There is a Valid Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> <code>grid</code>. Each cell of <code>grid</code> represents a street. The street of <code>grid[i][j]</code> can be:</p>

<ul>
	<li><code>1</code> which means a street connecting the left cell and the right cell.</li>
	<li><code>2</code> which means a street connecting the upper cell and the lower cell.</li>
	<li><code>3</code> which means a street connecting the left cell and the lower cell.</li>
	<li><code>4</code> which means a street connecting the right cell and the lower cell.</li>
	<li><code>5</code> which means a street connecting the left cell and the upper cell.</li>
	<li><code>6</code> which means a street connecting the right cell and the upper cell.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/main.png" style="width: 450px; height: 708px;" />
<p>You will initially start at the street of the upper-left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code>. <strong>The path should only follow the streets</strong>.</p>

<p><strong>Notice</strong> that you are <strong>not allowed</strong> to change any street.</p>

<p>Return <code>true</code><em> if there is a valid path in the grid or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/e1.png" style="width: 455px; height: 311px;" />
<pre>
<strong>Input:</strong> grid = [[2,4,3],[6,5,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/e2.png" style="width: 455px; height: 293px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,1],[1,2,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong> You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/check-if-two-nodes-are-cousins/1" target="_blank" rel="noopener noreferrer">Check if two Nodes are Cousins</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary tree (having <strong>distinct</strong> node values)<strong>root</strong> and two node values. Check whether <span style="box-sizing: border-box; margin: 0px; padding: 0px;">or not the two nodes with values <strong>a </strong>and <strong>b</strong> are&nbsp;<strong>cousins</strong></span>.<br /></span><span style="font-size: 18px;"><strong>Note:</strong> Two nodes of a binary tree are&nbsp;<strong>cousins</strong> if they have the same depth with different parents</span><span style="font-size: 18px;">.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:
&nbsp;     </strong>1
&nbsp;   /   \
<strong>   </strong>2     3
a = 2, b = 3<strong>
Output: </strong>false<br /><strong>Explanation</strong>: Here, nodes 2 and 3 are at the same level but have same parent nodes.</span></pre>
<pre><span style="font-size: 18px;"><span style="font-size: 14pt;"><strong>Input:
</strong>&nbsp; &nbsp; &nbsp; &nbsp;1
&nbsp; &nbsp; &nbsp;/&nbsp;  \&nbsp;
&nbsp;  &nbsp;2&nbsp; &nbsp;  3
&nbsp;  /&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;\
<strong>  </strong>5&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;4<strong>&nbsp;
</strong>a = 5, b = 4<strong>
Output: </strong>True<strong>
Explanation: </strong></span><span style="font-size: 18px;"><span style="font-size: 14pt;">Here, nodes 5 and 4 are at the same level and have different parent nodes. Hence, they both are cousins. </span><br /></span></span></pre>
<pre><span style="font-size: 18px;"><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:
</strong><span style="font-size: 18px;">&nbsp; &nbsp; &nbsp;     10
        /    \
      5       15
     / \     /  \
    3   7   12   20</span>
<span style="font-size: 18px;">a = 7, b = 12</span><strong style="font-size: 18px;">
Output: </strong><span style="font-size: 18px;">True</span><strong style="font-size: 18px;">
Explanation: </strong><span style="font-size: 18px;">Here, nodes 7 and 12 are at the same level and have different parent nodes. Hence, they both are cousins. </span></span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= number of nodes &lt;= 10<sup>5<br /></sup></span><span style="font-size: 18px;">1 &lt;= node-&gt;data &lt;= 10<sup>5<br /></sup>1 &lt;= a, b &lt;= 10<sup>5</sup><sup><br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-knight-tour-configuration/description" target="_blank" rel="noopener noreferrer">Check Knight Tour Configuration</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a knight on an <code>n x n</code> chessboard. In a valid configuration, the knight starts <strong>at the top-left cell</strong> of the board and visits every cell on the board <strong>exactly once</strong>.</p>

<p>You are given an <code>n x n</code> integer matrix <code>grid</code> consisting of distinct integers from the range <code>[0, n * n - 1]</code> where <code>grid[row][col]</code> indicates that the cell <code>(row, col)</code> is the <code>grid[row][col]<sup>th</sup></code> cell that the knight visited. The moves are <strong>0-indexed</strong>.</p>

<p>Return <code>true</code> <em>if</em> <code>grid</code> <em>represents a valid configuration of the knight&#39;s movements or</em> <code>false</code> <em>otherwise</em>.</p>

<p><strong>Note</strong> that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/10/12/knight.png" style="width: 300px; height: 300px;" />
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png" style="width: 251px; height: 251px;" />
<pre>
<strong>Input:</strong> grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram represents the grid. It can be shown that it is a valid configuration.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png" style="width: 151px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[0,3,6],[5,8,1],[2,7,4]]
<strong>Output:</strong> false
<strong>Explanation:</strong> The above diagram represents the grid. The 8<sup>th</sup> move of the knight is not valid considering its position after the 7<sup>th</sup> move.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>3 &lt;= n &lt;= 7</code></li>
	<li><code>0 &lt;= grid[row][col] &lt; n * n</code></li>
	<li>All integers in <code>grid</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/1" target="_blank" rel="noopener noreferrer">City With the Smallest Number of Neighbors at a Threshold Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are <strong>n</strong> cities labeled from 0 to n-1 with <strong>m </strong>edges connecting them. Given the array <strong>edges</strong>&nbsp;where <strong>edges[i] = [from<sub>i&nbsp;</sub>, to<sub>i ,</sub>weight<sub>i</sub>]<sub>&nbsp;</sub></strong>&nbsp;represents a <strong>bidirectional </strong>and <strong>weighted edge </strong>between cities <strong>from<sub>i</sub>&nbsp;</strong>and <strong>to<sub>i</sub></strong>, and given the integer <strong>distanceThreshold</strong>. You need to find out a city with the <strong>smallest number </strong>of cities that are reachable through some path and whose distance is&nbsp;<strong>at most</strong>&nbsp;<strong>Threshold Distance.</strong>&nbsp;If there are multiple such cities, our answer will&nbsp;be the city with the <strong>greatest label</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> The distance of a path connecting cities <em><strong>i</strong></em>&nbsp;and&nbsp;<em><strong>j</strong></em> is equal to the sum of the edge's weights along that path.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">n = 4, m = 4</span>
<span style="font-size: 18px;">edges = [[0, 1, 3],<br />         [1, 2, 1], <br />         [1, 3, 4],  <br />         [2, 3, 1]]</span>
<span style="font-size: 18px;">distanceThreshold = 4</span>
<strong><span style="font-size: 18px;">Output:<br /></span></strong><span style="font-size: 18px;">3</span>
<strong><span style="font-size: 18px;">Explaination:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid1_1745300064.jpg" width="278" height="278" /><br /></span></strong><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -&gt; [City 1, City 2]&nbsp;
City 1 -&gt; [City 0, City 2, City 3]&nbsp;
City 2 -&gt; [City 0, City 1, City 3]&nbsp;
City 3 -&gt; [City 1, City 2]&nbsp;
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input:&nbsp;</span></strong><span style="font-size: 18px;"><span style="font-size: 18px;"><br />n = 5, m = 6<br />edges = [[0, 1, 2],
         [0, 4, 8],<br />         [1, 2, 3], <br />         [1, 4, 2], <br />         [2, 3, 1],<br />         [3, 4, 1]]<br />distanceThreshold = 2.<br /></span></span><span style="font-size: 18px;"><strong style="font-size: 18px;">Output:<br /></strong><span style="font-size: 18px;">0<br /></span><strong style="font-size: 18px;">Explaination:<br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid2_1745300084.jpg" width="320" height="320" /><br /><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -&gt; [City 1] 
City 1 -&gt; [City 0, City 4] 
City 2 -&gt; [City 3, City 4] 
City 3 -&gt; [City 2, City 4]
City 4 -&gt; [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.<br /></span></span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong><br /><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>findCity( )&nbsp;</strong>which takes a number of nodes <strong>n, </strong>total number of edges <strong>m</strong>&nbsp;and vector of <strong>edges</strong> and <strong>distanceThreshold</strong>. and return the city with the smallest number of cities that are reachable through some path and whose distance is <strong>at most</strong> Threshold Distance. If there are multiple such cities, return the city with the greatest label.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup> + length(edges)*nlog(n) )</span><br /><span style="font-size: 18px;"><strong>Expected Auxiliary Space:&nbsp;&nbsp;</strong>O(n<sup>3</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&nbsp; &le;&nbsp; n &le;&nbsp; 100<br />1 &lt;= m &lt;= n*(n-1)/2<br />length(edges[i]) == 3<br />0 &lt;= from<sub>i&nbsp;</sub>&lt; to<sub>i</sub>&nbsp;&lt; n<br />1 &lt;= weight<sub>i </sub>distanceThreshold &lt;= 10<sup>4</sup><br />All pairs (from<sub>i</sub>, to<sub>i</sub>) are distinct</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/clone-graph/1" target="_blank" rel="noopener noreferrer">Clone an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>connected undirected graph </strong>represented by adjacency list, <strong>adjList[][] </strong>with <strong>n </strong>nodes,&nbsp;having a <strong>distinct label </strong>from <strong>0 to n-1</strong>, where </span><span style="font-size: 14pt;">each <strong>adj[i]</strong> represents the list of vertices connected to vertex i.</span></p>
<p><span style="font-size: 14pt;">Create a <strong>clone </strong>of the graph, where each node in the graph contains an integer <strong>val</strong> and an array (<strong>neighbors</strong>) of nodes,<strong>&nbsp;</strong>containing nodes that are adjacent to the current node.</span></p>
<pre><span style="font-size: 18.6667px;">class Node {
    val: integer
    neighbors: List[Node]
}</span></pre>
<p><span style="font-size: 14pt;">Your task is to complete the function <strong>cloneGraph( )&nbsp;</strong>which takes a starting node of the graph as input and returns the <strong>copy of the given node</strong> as a reference to the cloned graph.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:&nbsp;</strong>If you return a <strong>correct copy </strong>of the given graph, then the driver code will print <strong>true</strong>; and if an incorrect copy is generated or when you return the original node, the driver code will print <strong>false</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 4, adjList[][] = [[1, 2], [0, 2], [0, 1, 3], [2]]
<strong>Output: </strong>true
<strong>Explanation: <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893038/Web/Other/blobid0_1744464094.jpg" width="211" height="190" /><br /></strong>As the cloned graph is identical to the original one the driver code will print true.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 3, adjList[][] = [[1, 2], [0], [0]]
<strong>Output: </strong>true
<strong>Explanation: <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893038/Web/Other/blobid1_1744465861.jpg" width="233" height="206" /><br /></strong>As the cloned graph is identical to the original one the driver code will print true.<br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>4<br /></sup></span><span style="font-size: 14pt;">0&nbsp;</span><span style="font-size: 18.6667px;">&le; no. of edges&nbsp;</span><span style="font-size: 18.6667px;">&le; 10<sup>5</sup><br /></span><span style="font-size: 14pt;">0 &le; adjList[i][j] &lt; n</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/clone-graph/description" target="_blank" rel="noopener noreferrer">Clone Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph" target="_blank">connected</a></strong> undirected graph.</p>

<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank"><strong>deep copy</strong></a> (clone) of the graph.</p>

<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>

<pre>
class Node {
    public int val;
    public List&lt;Node&gt; neighbors;
}
</pre>

<p>&nbsp;</p>

<p><strong>Test case format:</strong></p>

<p>For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>

<p><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>

<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" style="width: 454px; height: 500px;" />
<pre>
<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]
<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]
<strong>Explanation:</strong> There are 4 nodes in the graph.
1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/07/graph.png" style="width: 163px; height: 148px;" />
<pre>
<strong>Input:</strong> adjList = [[]]
<strong>Output:</strong> [[]]
<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> adjList = []
<strong>Output:</strong> []
<strong>Explanation:</strong> This an empty graph, it does not have any nodes.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li><code>Node.val</code> is unique for each node.</li>
	<li>There are no repeated edges and no self-loops in the graph.</li>
	<li>The Graph is connected and all nodes can be visited starting from the given node.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/coin-change/description" target="_blank" rel="noopener noreferrer">Coin Change</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>

<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>

<p>You may assume that you have an infinite number of each kind of coin.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> coins = [1,2,5], amount = 11
<strong>Output:</strong> 3
<strong>Explanation:</strong> 11 = 5 + 5 + 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> coins = [2], amount = 3
<strong>Output:</strong> -1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> coins = [1], amount = 0
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= coins.length &lt;= 12</code></li>
	<li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/coloring-a-border/description" target="_blank" rel="noopener noreferrer">Coloring A Border</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, and three integers <code>row</code>, <code>col</code>, and <code>color</code>. Each value in the grid represents the color of the grid square at that location.</p>

<p>Two squares are called <strong>adjacent</strong> if they are next to each other in any of the 4 directions.</p>

<p>Two squares belong to the same <strong>connected component</strong> if they have the same color and they are adjacent.</p>

<p>The <strong>border of a connected component</strong> is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).</p>

<p>You should color the <strong>border</strong> of the <strong>connected component</strong> that contains the square <code>grid[row][col]</code> with <code>color</code>.</p>

<p>Return <em>the final grid</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
<strong>Output:</strong> [[3,3],[3,2]]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
<strong>Output:</strong> [[1,3,3],[2,3,3]]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
<strong>Output:</strong> [[2,2,2],[2,1,2],[2,2,2]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j], color &lt;= 1000</code></li>
	<li><code>0 &lt;= row &lt; m</code></li>
	<li><code>0 &lt;= col &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/complete-binary-tree/1" target="_blank" rel="noopener noreferrer">Complete Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">queue</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a Binary Tree, check whether the given Binary Tree is Complete Binary Tree or not. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes should be as much close to left as possible</span><span style="font-size: 18px;">.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">root = [1, 2, 3]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700557/Web/Other/blobid0_1733207350.png" alt="" width="222" height="182" />
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">true<br /></span><strong style="font-size: 18px;">Explanation: </strong><span style="font-size: 18px;">The given tree is complete binary tree.</span></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>root = [1, 2, 3, 4, N, 5, 6]<br /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARoAAADhCAYAAAAXkXrUAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAEm5SURBVHhe7d0H/GVFdQfwq6YnYoyxS0giKAKCRkBEBAEpkSoKKIgCigsqESMYWWwQFNFYIIICSqhGlqCCiiJNBSQYRAKs9GJUhGCCaabH7Hd2zzJ7eff9733vX16Z3+czn9duezNnfnPOmTNnHvEv//IvP68KCgoK5hCPXPFaUFBQMGcoRFNQUDDnKERTUFAw5yhEU1BQMOcoRFNQUDDnKERTUFAw5yhEU1BQMOcoRFNQUDDnKERTUFAw5yhEU1BQMOcoRFNQUDDnKERTUFAw5yhEU9CIRzziEakUFAyLQjQFfVGIpmA2UNJEFKyCXlrMf//3f1ePetSjVnyqqv/93/+tfvjDH1Z33313dfXVV1dLly6tvvvd71b//M//XC2Tp+r//u//qt/4jd+o1lhjjeopT3lKteGGG1YbbbRRtfbaa1ePe9zjql/7tV+rfv7zn6fyyEc+Mr0WTDYK0RSsgl5E81//9V+JaH7yk59UF1xwQXXFFVdU1113XfXAAw9UT3va06qnPvWpiVR+5Vd+JRVEg5z+8R//MZV77rknFcduuumm1frrr1+96EUvqtZdd91EMk1aU9P3bVDIa7RQiKZgFdSJxvsHH3ywOu6446rzzz8/aTJrrbVWtccee1QbbLBB9fjHP7765V/+5eoXf/EXq1/4hV9IhKQgm3//939P2s/Pfvaz9P7yyy+vzj333Oq+++6rfv3Xf716zWteUx1yyCHVr/7qr66420OoP0dXuH/B6KAQzRSCuRLIOySi+I//+I9EGjr5P/3TP1VXXnlltXjx4urHP/5x0kD22muvauutt04mEPIItCEFxyCda665pjrppJOq2267rXrMYx5TnXLKKdWzn/3s6rd+67fS8/znf/5neoZhtJJCNKOFQjRTiCai+Z//+Z8V76pELCeccEJ12mmnJf/Ky172smq77bZL/pVAfjzMRDaIjIbDrPq3f/u3RDif/exnq29/+9vVnnvuWR1++OGJbGhEjh1GowmSKibUaKAQzRQi78B5R/R9+FZe/epXV7feemt1wAEHVK985Surxz72sSvP47OhcdS1Br/3Iwfk4fqIzvmu89Of/rRasmRJdfLJJ1e/8zu/U33+859PWk6YYF2R/x/vC9GMBgrRTDkQA82EpvFLv/RL1Y033ljts88+6fNBBx1U7b777okgIDptvCKamcglB5LJj4/3TCUE8/GPfzz5bs4444zkBwrNBil5njYoRDOaKHE0BSthZuitb31rIpAjjzyy2m233Vb80httCaYX8nORC9Psfe97X3Isv+Md76i+//3vr/i1YBJQNJophw4fGs22226bTJnjjz++Wm+99VJMjI6vQD8HaxvSYSo5Lgp4pUlxEntPo0I0j370o6tLLrmkaDQTgqLRTDl0bjNNixYtqm6++ebqTW96U5oB0rE5fpkviEiJjotw6iV+61cQBuJwTfflq/HKpIrfnvvc51b77bdfmkbff//908xXW5IpGF0UoplC6NxREIDYlksvvbQ68MADqx122CF1/F4IwphLIJxddtklOaAvvPDC6gtf+MKc37Ng7lFMpylEPr19//33J4evoLnTTz99peO3qxaRX3MYIDn3FqNz2GGHVX//939fnXPOOSnyuA1yUpoPYixoh6LRTCH4RMI00ol/9KMfJScwhJk01whzKwcNy7MhPfE0hx56aPWDH/wgLXtg3ikF44lCNFOI6LC33357il8RiGfBY25SjQJoMdtvv32a9qZ5AYdy0VTGD4VophDMHB2VNsPZaoFjzCyNEkx7I5p//dd/rT75yU+u+LZgHFF8NFMIJGMl9kte8pJqtdVWq84666yU1qErmF58KZYTIAXT4TQPfpYnPOEJaT3UMJqHc2lXO+64Y7rmZZddtnKFeB2hheX3836Y+xfMHopGM4XQ+f72b/82aTMC5ZANn0lX0DQQjcWR1iwdddRR1d577129/OUvTxqIiN/ZwK677pqcwnLfIJRCIOOHQjRTCJ30+uuvT0Tzghe8YGU8S17aADmdeuqpaanCe9/73uq8885LKSCQj8C/YYkmnmOnnXZKzmvBfGbFCsmMHwrRTCFoIrQQDuBnPOMZaZapLbnk0OEjqx6tSAyM6/jeqxkkr8OWJz3pSSlp1i233DJrWlLB/KIQzRTCzI1pYxHAw8A09M4771wdc8wxyWzaaqutErkgmtnWOjbeeOP0zIitYPxQiGYKQSsQ4j8s0dA2XINp89KXvrRaZ511VhKM32YTv/d7v5fSV5RYmvFEIZopBH8H/8wTn/jEFd90ByJhcvHT8PG4pve0JQitJsyfeukKizyRYyGa8UQhmikEjYYJwvcxLhDnEws7C8YPhWimEDQPhfN2XMD3I5bGcxeMHwrRTCF0VqkaxqnTDpLWs2B0UIhmCsGnQkMQ0TsbmA9zxh5SopdjdTkUM2p8UIhmChGro8cpXaYlE5Y5hLkXzuaC8UAhmikBLSYKxypH8N/93d+t+HU5ovO26cD1Y+szSvnvbUsO12EuRRIu2+6uvvrqiSTzY/N7FowuCtFMISyGlILh2muvXfHNcKiTxGwhprKRjb29RQfLJVyIZfxQiGYKgWh+93d/t/rOd76z4pvZQS/NZBiEmSRQzyJQROPZC8YPhWimBDGlHTNOkoDryLLXefV9mCFtNYa77rqrOvHEE1Niqo997GPVt771rfS9NA7XXXdd9YlPfKL68z//85T3xnqoICIlv1d+z/w9xy9Tj+blGT1zmFIF44WSj2YKoQMjCeuUnvrUp6YV2MhHpw600Uz+5m/+Jm02F1PlSEBQXXxGDr6jiXzmM59JPpZAkEkd+feuYSW4NKMWgSJFSxHyZ8ufGfLfgtQKFh5Fo5lS6PzPf/7z0xYrSr3DtkHkFhZpjBDis+UIOrjlCK6L2JqIpR8QjWe74447UpIuREUzCq1nkGsWLAyKRjMlqI/sOr9ZJ6ui7bNNawifyFwjJ4g6WeTPKZ0FbUte469//evVs571rERiOSn2O9/7+v8uWBgUjWYKwbQBm+rbauVLX/pS0hpGDXZn+PKXv5zMsyCZ0JoKxguFaKYQTBLQcV//+tcnrcBGbaOGT33qU4kU7VgZJEMTC02laCvjg0I0UwJkEgV0XJBP5rWvfW115plnVl/96ldT551rrSEniJw0onAg/9Vf/VUiv1e84hXVM5/5zPQ90qkfWzAeKEQz5eDvYJo85znPqT7wgQ9U3/72t3vuMjBf4CcyNW7KfNNNN6323HPPlRpYoBDN+KEQzZSD9vLkJz+5+uhHP5pmj8S93HPPPSt+nX/Y7UBsjqjgI488MkUw1x2+BeOHQjRTDp2YZiAN51/8xV+k+JrFixenbHZ+q0970y6i5Mi/z0sbRBCerH+2wRUzc9ppp6UAvTDxCsYbhWgKVmKjjTaqPvShD1V33nln9Sd/8ifVNddcMy/mCTKz/cshhxySlhow4TxLweSgEE3BSlgZvfnmm6ctWHT4I444ovrGN76x4te5g3u8+c1vrq688so0q8SU81owOShEM+WIdU5mdJguguM4hHfbbbe0gPGAAw6ojj766BTcJ9LXsbQcRJCbSLSSXiVmupQ4VpoKEb58Qe9617vSBnTSVtjd0vcnnXRSymnsOGaV6xSMNx61zB5/74r3BVMIHTlIwGzP+973vrQF7Qc/+MEU9m//7NNPPz1F5v7DP/xD2jlB0iy+E+cF8vc58u8RBofzrbfeWp1//vnVn/3Zn6X3++67b9rp0q6Z1l7xFdm7m48GgtR6oZDQeKAsQZhy0GRoKg8++GC1yy67pE59xhlnpMWLfkMo/CdI4aKLLqoe//jHVxtssEGadkYMgaYOnxPNVVddlRZGWuVNe2Km0WjsmBmaFU3msMMOqy699NLqkksuSeksaFBNRFM3sXKfkvfz4WMqmBmFaKYE/UZ+5sof/dEfVd/85jerD3/4w0mjyTs2sjANjihOOeWU6oYbbqjuvffe1Mk5bRWmD1JgbrmXayr2y5a0is8HHvOYxyQfEM3Jq9zFsRcUONc51l/RnpYsWZI0qJiZqqMQzXigEM2UoIlorLo+66yzUszKokWL0mwT30g+rYx0dFjOYsfffffdyY+DPLzna7EAUoKq8OMI+lOsuLZSXBGAZyM42pLfkFcsKwhE0vS//Mu/rN7+9rdXBx98cPWOd7yj8fkL0YwHCtFMCZo66ve+971qjz32SATAN0Ij0flzkyeIxnfeIyFkxN/ys5/9bGWKCEF2oQkxu5AAcrJ7gcTizmMiOdbzuJ7vHBtwjt99j/Q+//nPJ9Jpmu4uRDMeKEQzJciJRidWaCFveMMbEtno0GuuueaKI1ZFTjp5x236Pkd+TKBOBo7Jj4vPtliRnIvZ9LnPfS5FCSOlOL/+CvX3+eeChUOz4V4w0aB5CM7jdzHjw7+yEOhFRAE+mj/+4z+u7r///ur4449PmlNoTIFCJOOBQjRTCJ3bymjpNc00bb/99g8zQUYBTCjxPHLmnHfeedXll18+b8m5CmYXxXSaEhj5wx9i4zh5aPhXpGPgqK0HxvXTNGYTnqvNvTiSkYypd9qXZ0VEuX/HdXINx/ui8YwGikYzJWBy0FrMDP3pn/5pCr6zSwGSgYXSFNoS2kc+8pG0slv6CAQDhUTGB4VopgRIRvn0pz+dElxxAq+//vor41NGvdP+wR/8QbXXXntVZ599dnIMg/8TWkshndFGMZ2mBOJW5AZ+3eteV73whS9MhLPaaqutEiyns+YaxnyZT23AVBI1zGfD9DNLJrVFjiAeKAQ0WigazZRA6gdJrfg3hP2LbeGzGSeIxbEGixnIhLKMoRDKeKAQzQSiV8ezMtqGb6a05QnmCG4K6x9FmNr2n5hQ7373u9PuCDS0HPG/6/+9YOFRiGaC0KuT0VrMLHH8yl63ySabJGeqyF4zNsyjvARGyWwCEcZMI9hxxx2rrbfeOu1FZV1U/Of8vxeyGS0UoplABOHwa1iT9M53vrPacsstq5e//OUrZ2zqBDNqxNIPTCjT8xJkCTY0G1WfNYs6KBgNFKKZYPzkJz9JEbVIRHpMU9l55xsnogniUCy8pJkhUOlGrYX66U9/uuLIglFEIZoJArKIADavJ5xwQkqPKWPd05/+9GR6GPlpOr2IxW+OUZqOWSjkRBPLEGhoiv9nJiq0tTyIr2A0UIhmwmBFtRH/i1/8YprCtmcTB2ob6MT56yghJ5rQwBR+J1n5pJQQhIhs8t8LRgOFaCYMSEaiKfll1l133erAAw9Mjt+2GEWS6Qf7h/uPnMJm1BCNVemFbEYLhWgmAEwJBMHc4asQL3PfffclH4aOGLM1jnFsHF9H/l3TMQuFJuIw7b3NNttUW221VfXZz342TXnnjuF+ZOP/DVoKuqEQzQQgtrDlm+AY/cpXvpJSZcrpa3q7KV6mVweKMsrIScd//+3f/u3q/e9/f7XWWmslc/FHP/rRiiMLRgWFaCYAiEGns1MBguEglfrB94jmN3/zN1cc+RByUulVxgXI1X+UNF0CdWlFOcGDiApGA4VoxhTMpCjWAMndK/XlU57ylOo1r3lNcpAiDGaEHLzjRB5dECae/2l7Fmu57N0tcpgmh4SCPOslyGiQUtANhWgmAMjmuOOOS5u8SQHxnOc8Z5XFktMCpPLKV74yLRqV0PyOO+5I3yOVgoVFIZoJgKlsjlA7Sm677bYrY2GmDWbcbDxn4aWpbjlsLLwsWHgUohlzLF26NOXVffGLX5x8M3wWodojG5/z7yYZNBr/2Y4O4mvshnnxxRen/64OimazcChEM6bQcaR+0KFssPa2t70t5ZcpWI799tuveulLX5riiW677bZEQvm0d8H8ohDNmEKaB8nFLZp8z3vekxyhooILluPRj3509cY3vjEF71l4yWFeNJqFQ8mwN4swYhJmsx2csT4vq9+kuttcTdSqALOAY0Xt6hRmT8SD+E7xua7uh/njunYF0JHe/OY3p9mmAMdwwPH5+XHtaYD4Gu1w6qmnVocffnhyDtv2V51qG/6cWBsFjvWd3xV1p61oQvw82s97xXmKunYf59l4TyoLbeP8aD/t69imWKZpQSGaWQQhI5AE9Oqrr65uuumm5EMRpWtGSGJwI2zgcY97XNqL2pS0OJD11lu32mijjavnP//5SXDr0bkEluBaYiDnr3M+9alPpf2PAoVolsN/V2h+CMbi0jPPPLPacMMNVxyxfGo8oN6ibry//fbbq+uvv7669tprq7vuuivtLSWEQPuG5qgtHvvYx6aBwja/inVl2k8mQ0QTpEQ2phmFaGYRhNA+1qJzb7311iTotBRmjSlnsS1yqAQQkChWe1gTamSEeAis3Lg2updyM+B6hPy1r31t9dd//ddpC1vbkBhRA4VolsP/DPJAEGKLaCMIB0GoR/UTCC2E38vSDbt3SrPhGtaMSUux9tprJz8YYnGu+CSrxn/84x8nQlIcr80RmgWtnPT1dphGFKIZAAQ21GtqONXaDIeoXAL1pCc9KRHF5ptvntYaxRIBv0WpwzFGzq997WuJqJAQrcZojHC8d78Pf/jDKccMJ6fgNOflMTOOiVJH070nHTRM7cNxvmjRomRqIgzajrakbSAYs3eIyICw8cYbVzvssEO12WabrbjKqsgJPYfobInTaZ00WGuwFi9eXD3jGc9IbaVdck2qCW2OGScUohkS5557btrUjEZi9BLHImAMMQRCbY5O3quzI67Agw8+mEbHCy+8MO3O+LznPa/ad999U4yIlcrucdRRR628Ry6UhWgeDh1cnco1jAQEN9qhE0HTRphUCh9LpAm1bspUeVN9NRGNeqfZ0nQuvfTS1IZiesyCGTCYyW1inArRFCRBocXo7ASXuSMi16hlXRFioVZHnluCB/06upE1RrsgCt/ZG5sWY3R0XaPtkiVLkn+HsLP/C9H0h3ZgKunwO+20UyIeM3Y//OEPqyOOOCIlbWeOiiqmgaq70BS7Eo32iLZj0tJSBVMajJhgggmZYTOhEM2UggARLpqHHLWIxUZmtBiqON9LLpRNgtjU2ZuO9/0PfvCDFOUqAnjnnXdOwsoR7DckljsaC9EsR16feV1w0r/sZS9LMTbf+MY3Uv5hZMPEqSPqq0t7NREEk4q5i/D48TiN3RshQb97TQIetcx+fO+K9wUzgMDSVNjyTBozPwcffHCy93X2XEh6dfRAEEG99ALBFJBnFKQ5WSxoDQ8nMKemadNcFZ/petOC/P/n73VuWoadIUQQ2+MKyUSH74W8TvPSC01EscYaa1QbbLBBdfPNNyczTf5mTv82ZtQkoGg0LWEEW1ZXiVhsKSsuY++9907qtQ5f1yyaRrxBoBMQYKQisdOxxx5bbbHFFilXLhW/mE4PR5NGQ7M44IADqmc961kp0HHNNddM9duLaAapqyaNRtsx4Tj5OfiZbaeddloaMCDaZlLbp2g0fcBMIiCEFpFwJurob3nLW6r9998/fU8wCJf3uUD36uhNCGLISw7XVtj8pli9svnNmoRmQ/OJmbBe15g25B036uY73/lOGhyQi9w1zF0Eo/161Ve/eozf2pYYhIQr2PpGRLfwhJe85CXJr6ct84Fq0jB7w+4EArkQVP4Zs0tIZs8990wjoinTcPLOFyJeZo899qhe9apXJVv/oosuSt8R0mmPPm0CTcL0NV8M39YhhxySYl0WCoL8DFYGiNBu8nipSUQhmj6IEcaMD1veSGiaMkYpWsZ8ItR709xMOLEewuut42Hr51PqBQ9BvZllEoKg/WwJ3MtUakKumUQZBjQo/iG+vhtuuCEtJ2GWTzIK0fQBgUIm8tEiHbsjml4mpLSLfo48whTFyOU1YmW8D1OrSWjjt7y4r2tQszmImQHeIx1LG+Zbwxpl0ETVsVfOX070XXfdNaXS0HaDmJmup+2CpHxu68wNWfA8ziETAgJpp6ecckqKCvdMimMmDYVo+kCDC/UnpKZDzfzka5WgjbDGQsrw9xC0tsLdBE5oa2rY+FdccUUK8Jt09bsLgtTV9Sc/+cnUBpYhDAMEgyC0oQJBHnkJUsl/a4IgPoMYx35EeDtv0lCIpg9oCF/4wheSgNFmBkWYYKJTv/Wtb1Xf/OY3k89gGHg2ZPWmN70pvReBOunqdxdoM/VDUzjnnHNSJLCFjsPA9Wxnw9wR3nDLLbekz6GJREFuUYKUlF6Di+Uq2223XQrCNPUNfIKThkI0NeQjEyG97LLLqr322iutkCYsppPzY3LkQqUQOq9U98MOOyzFa7iW5QTC3KnOAsjAKBbHt4F4EMeuvvrqafGeYD4LOX0XAt1LsKcF6hLZiKpWJy960YuSUzhHUzvWoeMLmnQtyz+YYNrQexolhy6SEGNVhzbI26NezDhFtLKZMPeiNU0aCtH0gZFL2LoNypqQC00Owmta1WwVcrFUwbKF6ABepSLgZLbgz/FU50Fmjph1ntPzFiyHejRQWKRq5by4Gf6srtCuZvZotLZxEQcDYRapd79rR5MGg8DShHXWWSdNv1sjVZelSUAhmj6wipqQUm+b0EQ0HI6I5OMf/3jKZeIaliq4pmlp/hWdgbYjLcEDDzyQzhlEyCzUk4rCmpoc+Ujtff550mEGjt8KEVgoSUsYRFOgDWknbUiLtGJe+wl1kLlPVDj/D5IQgNcVztUuBgumtfgaA9GkoRBNDTFSmTLmT4mFkl1BWJxrRshoinBkw0MwUg8QVlOcjnMvEauDCpjnE95Oo9EhPL/OEeQSZZrg/8vzoyNbH+b/q99o3xz9yJ2WybSx6NJWwwYFbajtLEERU+V819aGXcGc8zyeka9t6U03DSwHo4xCNDVoeGbNNddck5y4YmcGAeFxHU5IWfAidiMXIj4ax4DkTL00ozbQGZCaa4sVcU0jsWeIMm1gJgmEW3/99Vd8MxjC58UPYwFttKu6RloSXEX9DuLEjXM4jl3rnmWm0yAm3qijEE0NGh7BmFHQ+IiGsHWF6xBI6jpHcj4tGoQiBN4x7hOE4Lh43xauGdei1bie99MMYQiyF1olPQyirZRoE9qSOkc0TJ2YVRRj1RWuBa4h75AtfQvRTAEQhCJDGpuc/4NAdYWOTjCdG0IaxfUJmClS2ojPNBLC63N+bJR+MGPhOa3uNvMErjXNMNUvqZW1YeoiL9ojR7/6jd+CbPhREAETlYPfmjPH8NUINeiKGBQ8l1w4rjuJgZeFaGoITYBAeR8axmzBTFQQmRkRwmskNPUdo1vX+1HjkSLce++9qSMgrOgcyrQBwYtx6efI7wpakvQSlg6Y3rZeyT3MGlkJLivfMBDnY+aKjEwaCtHUEGaMBveez2YQjaYJro1oLGsQd+Ee7H8jYiya7AoEJSrYtQi+0TFmsKaVaJCvush3iBgEeR0yb2iMUnSG5kg2+N+k7ZD1ELRx28EijlUMFgaI2ZS3UUEhmho0NCGleuuwGj+0hUERQud6SMbsxY033piIQdCXWQ3v3dexXYnBubQv5xFSJOO7aUfUizrJS7RHoG19I3R+FAGS4l4icZVEVmKlzHJpw0AQSP1+TQhtehLbrhBNDcgAaAiEkr3sdRi4pmsQJMFdbHuEw4ErLqMesToI4jl1GqZT3c73fVcCG3fosHUzZJg6IBPSc8gVLRKbf8b0NmKX9fDtb3970qK6kEtORmSCrExiOxWiqUFDa3RajAafDaIJTcV6JLmGBZFJ7SjkXPzLIEQTxKEQUPEint2eQ15Dw8nLNMH/VQe9iKZLXcTxSgwYQejaENGIqXEv5pQ21taDQNSx9hsksHDUUYimBsKkcOxZMmAWYBBVNoSRus0ck/5TsBeTTOIjPhqBXwQ0tI9cK5mp5EA0gv6U3//930+/u1YcN6jgjzN0Vk525oz/HyWQ12G/+tF26hdhqVPHujZ/jbaj5TCjAgaRILhe960j2lOR9J5sFNNpChAzP0YpgmWU6ScoTSBszvPKeYhYXEvSKhuKie/IhYxgEt5BhMw5YkZ0CksRXG9Qx/KkgJYoZ49AyGGg/cTKWOdENtSteg5fXiw/QEaAKLS7waor+O0kLS8azRSAMBEUMwmEBznkDr62IIi0E6o0m16UKiKREsD3p59++irFGihBgiGwMyEnKUTj+k1E4/O0wSyeuBR7NuWIOmsLGuinP/3p6hOf+ETKZ8M3Q0bIhBAFfhkrt7Up0FK1xyDZDoNoxEVNGsouCDUQEp2dMIlrsKmYHQ8CoanMBIIoIRVBtIdzHXVhRwxy2rpfaDX5MfXj82dAMDQmZEV1DzgnP877Ns8+CfDf7RZhm2Jr1miSdS2jXqe9cNNNNyUN1CCgTclGyIhXBEMmlIMOOiitZzOg+F5xj/w+9XtqD9cyUEgdwrwWpzOIRjTKKBpNDaHRECJTz0bEQZb/EyimFxKIDp538vw7xfHuPYiACSTjiJQnpWA51KNAOsnIL7jgglS/ef23xTOf+cy0eZ9FlRKah2/G9RCPa3IKIwcziEEybbXguJYocZHdsgX4PGkoGk0NOjuSITB8K694xSvSjpRC2aGtRkPYEICESaEKx3m9zne8ZQRs/DCfcoGrC19+DQtAdQQmmIWaAefkx3nf696TCqk3JKZixiAbyIm8TYfW3s4x2Mhvoz1FX8eAZNaQ01lgILlxbJCM60cJ1O9pIOKfY5aJRidztK9Ja6dCNDXkDWwWwOrrpz/96WkqGhl0tZ/7CdkwwuRZwDVtH8IZLO0oogrk14/jpwU6O3PUXlwnn3xyStMhy16/9qhD/UUZFO7R754IS3qJt771rSlfkVfHtNWIxgXFdOoDIyFzRI5fq6IJhRFoVIA8zHjYQ5qZN2wE8yQhyOHAAw9Ms08SVWm/QRBkkZfZglkrvjwmnh0aPGNotJOEQjR9QHuxITzb+WMf+1gyp0ZlRsCIJ87nxBNPTIToOYcZeScNzBgQfc1JywcyyFR3L5JRZgt8a2KsEKLJB1pYIZopg3gGvhlh56YeL7nkks5CkHf+2SQCHYkmYzsYjkh5c8SOuEeUvEPwHcxmBxkHIGNanzSZ/F8f/ehH0/IMdRP10Y84+v3m/DYlzo9rKdE+BgrPJMjSQBHaTJDkJKEQTR9odILKB2JXSDlhOQNHAbfddlvK3CewkMOacHJcFjwcZoUWLVpUXXXVVWmzNm26UHWFYJhLZiTF5ohctokc02mSUYimD6ixzBLrT6xRMvOQx9QsJMTcSDMhfkZ6Ah1nlPxHowRaBF8bzcbG+pzmOntb5NrIoCUHzZMpJ5m8XMH2c5/EaOAchWhqyIWDRkMgjYDiG2RQEwVqdsC6otB4jFL9EKpyveTo9Z1nQCBU6nhvytx+21YLs+s32mij9JvniHOiFCwHE4af7dRTT01xMXauVH9WWjOv8linHLNZh+SIvDDdTCzw+TGZbNPi2QZ1VI8LCtF0wH777VcdeuihKdVDbu/3EtLZAhUbCKI4C5uYub/dFTzPXN13UsHclHXvjW98Y4r2RSbzYUaZRGDeijTmUxP8Z9rdMgnwDJM8SDxq8eLF713xvqAPzDgxpSyGtL2JUdFiO5+NSNBGQJqO6SVgPhuNkYmlBWIsOICtnRKgx6wjwKHNQJtnmDbkdaKDixi2n7p1aMwY2+GoZ8iP7VeXfutStKHNBLWddiM/SAbBuDfNynGTihKwNwNyYYnPzCa2PqGxCO7oo49OwkpodXqC0zRzMJMw+Z2K7RquRQCXLl2a7iEiFdnQZNyrF+rXzzUe76dFAwrigJyIc/zhH/5hcqrL/2uNmQFE/SmidZGAAaYL1K82MygBjZQv7bzzzktBg0y3s88+Ow1OBon8OZ03qShEMwNC8KIDe2UyLau3lL7RWigzBiKId99995TekYA2CXdcpxfyezCVLLSTxe3iiy9ODl/7dwvMQ2JtiawQTTPRCHYUJMckfeELX1jtvffeqX7zOsyv0wb5uQYkbSejovAIZMbkjSUG9QDL/DknrZ0K0cwAghMlPhMCBGClre1WwYglCRKyMYvQtMdPLog58u9NofMlWPdCi+H0VajaRth+anb9+1xgvZ80AW5CXg9N/5lz3xqoY445Js3iqVeaqRXYnOxmgprquQmIiXOZWS03NKezQcL2udZd+V0bxnGh+UD+nE3kOK4oRNMSIRCEkfAY/WgV7Hy/WaZw3HHHJTPHDMM222xT7bbbbolwEJBSn8J0LdoRoTKbJHLVdZYsWZKm1BGLGS7pA+oC3zTSFqLpD23FLFLHIobFSBkwfMfRbjsVa9xE6Wpj8VPMVH6ViAynsWq7KNoQaUgHgmD4f8gBTZe2JCSCyavuHZdro7lpVm+fSWqvQjQtoWNrdNGcBNTsAa3GCIhACA9zClHEdhxXX311ElCbw8UGbwgkgFzE5tBgJNhCUEwvi/+23HLLNKpK4MRnQ6BzAS1E0x/5/8zrBKkLktt///2TCWPmR507Xqfns/nKV76SpqDlsdEuSMcx2sKiVe2t/vlfFCauYmGrJQ+Spm266aZpC11T6uecc05KnuVz+N8ChWgKVgGBILBGP+kYOGcFW4VDj0AggggjR0hmivgBFMJt50SCGzADQoCRlcxsUg4QZE5Jo6jRF/m4rmsWommP/H/mdaI+aRdWTHPKykiIQMTUIBDnIaPIF33XXXel9uOL8/n73/9+cu6qf4OGot1EaL/gBS9IpGT63KBCe9Helhd4BveTCcCgEShEU7AKCJ+RzmZvbG3Z25ACASIMSCAEKBfs/H0/wYnj4pim4wKFaNpDnQRJM43e9ra3JZNJLE3Ul9d6G0C9PgNt6tFggdisHLdbgqUizOsYOFw7Jxqf47rxDG3uMw7oLa0FD4PN1zn3aCC2P428LwSB4DQ573KB6Sc0M/3eFvm9ZuN6kwAd2CBAqxSJu9lmmyWH/VyD34eGa8IA0RiolJiVrLfPJLdXIZqWkPjqe9/7Xoqd4aQlvAQpSKZ06tEFPwr/maUb3tNkmKdzDdoKc4yfTjSw4E45pDmIfRda1jSgEM0yxOhfJwtCglCQjOlrSarZ4Y7zfQTogc8K5NfLS/zmnHoJ5Mf2Q69rKHXk92tz3UkEP5pIXCk1mE38YXl7BfK67/V7jvi9X+GjcT3mE2ITQ6MdmG38d73aI55h0tqrEE0fUHvNIInopP5y/iKftgihyUsT2hzTBvl1hr3WpECw3FlnnZVWb5uy1q7IZz7BXNpkk02qN7zhDSnRlYELGeWY5PYqzuBlyBs4b3wzEZJGE9Qrr7wyTVGz9fuRTX6t0tlHA5z3ZopMZVuFr03CGRuod/rZBrlR3Gefffap7rzzzur888+vVl999RVHrCo7vbTTccbUajRBAorGj0IYfMf/Yk+g6667Ls1U8MuwqbtoNAULB/4RpotV9qaoOWOFEWhfndisXd7ucw3380xkiENaDBUTKgI2688RzzcpKKZTDWJXNDBysUaFgAq4KxgvIBQBk3wz22+/fVqXlk8lzzeCSBSxNJY5CAg86aST0qC2kM82H5ha0ylXU/ORg4NXKgaRo7Ln2/1RBGkvTSY/L5BfNzSmgvmHKF1rmZi9Au7M8jCXvC40DGbMcuRnOQuTjv8G2Uyq/EytRpOPMBqTqkoQrXPR8Gx6OYKtVUIy0ehNpWDhoQNrRyaTfLxmmc4888wUpasTG0RGAeRFNPLxxx+f5O+EE05I0++0sJjyLrNOE4ggEpBnxm4H4mWkWoRo9LwUjB60ixklQXGf+cxnkiOf83cUkA9sIU/kSy7qa6+9Npl4vq8vNZkUFKJZBg0MEkbbZ1nUqNwhpiSBDV0wHrC48YMf/GBaRyYwL9p2oZETDY0r3vMfWeUvh7DcNbFWbtIwtURDxY5CGNn0ojf5Y8Q6+J4qC2WmaXRhMIiOye/BuWqPbDOGNAa5YHJNtKnMNchYFGacV/IlfQjNy0JM2o1nn0QUjWYZrNT9wAc+kOxko6H1TF0DuuZLYAtWhSUF6h3ZCK60lcpb3vKWarvttksRuaaRc21i1OD5zWpaP2dluIRnvps0FKJZBvvryBkiC5pcMFIshtlUMNqIaWF5fawjWmeddapXv/rVyc+hDUfd3xFrnkSdI0i+JcmzJg0TP71ttMtHshjZCCgNxope04xyxlpqQJXtiny0LJrN/IMJwvwwjW3GcPPNN1/xy3Lk7ZHLwiiAiR4w48lsZ8ZzaMsQ4L+ZTQswuQL5ufn3o4iJ12iaBIuDV2Y7i+zY8ZIhReqHQVAIZmHAeWoK+7LLLkuJxqXerPvUYiAYNZKp44lPfGLKDS0lqBSuTPrQ2ALj8l/qmFrTif1uKvv666+vjjzyyGr99dcf2NsfJFPIZv7BeSrXLy3GoMHsHfXRvQmWI/At2bNL3mGR6Waocowr0UxFZHA0DFXTK3X0c5/7XFq2/7rXvS7FzATGVUinCUb5SKdpiQiTSXsK7Q+MS0fMzZ8cVpqbRaOtmT1DOFJNGCB7oZhOC4xc4IJk+GXMMkkgzWQqGC9oQ45e0b9f+9rXkhM1J5lJgOl5Gg45NXPGYWyfqHHFVBBNkE2eaS22mB2FtS8F3UALkCxcCL+dH1/1qldN3JSwbHyR/vPEE09MxMr3FPIcMj0umHii0UAchuDVCGFVr7gF2fLquwUWjCaYDgiGD4yzVOfznbAETvxRWcc0W6DB8NXIBnjKKackZzdNLvcFMpeijDomnmhipEMyluVzsJlCtMTAqEA9zZGPGHkpWFjETJIOaI8ky0XkmrHolRN/0pzw5FXQKO2bT8paqGI6jTDygC5ThhJYSR8QsQl1Ae1FMkrBwiLaKXYEtVeSTfppNYgmtNZJAS2FlmY21O4bMjyKERpXTDzRULc50yywo3LblynfF7usYxoPGDBMZZshtNXs61//+rR5WxBQPd5knGFgY/IjUFrNhhtumPaEkk5C1PA4anATTzScv6YImU1mJ2xLOohNWzSbhYXpbFsQ21+LZiot56RpMYE6iSBUgXwI1j7edjztRzQhq/WSo9fvUQK9futX+mHiiUbOXyt6Jaim1ZhlMlp0HRFmqsiCucU111yTtiKWwoPZZKSfpjax8PKII45Ie4vZ0aEeyJcj7/x5ydHrdyVHr9/7lX4YOGAv76hNNxlGvWu6ZlOAU11LIYhyk1CxLTXgBLYvcqBJq6lf338Y5n8UDA5+NEtFBK5x3msbnUyK1Zkwk+CPKvzH/Nm9zyPWDz300GrJkiWpHiwA9lu+v9ggiPu1kfN6vTadU3+eidRozEzwy7DnRY0aCWyV0gZBLFEKFg5MIx3JrgF33313Mh/kbZlk9JI7nTsKH6PYIctmLL4EGvp8ICeZeJ9/1w9jTTRNhGAUlFTcTgb77bdfWoLfNl4mv2avaxfMHwixpQU2W9OG1gFNY7ZD9RDFgHnYYYcl4j366KPT74OEaPT6XcnR67f6+3iN902YlbVOYW7UO6eZACqUkUmwkdHJzA/70nTdVVddVd16662p0mggmJk2YtTi+BId+bznPS953anLUjj43XVdI/9z8V6lM5kQjOdyjxw5ceTPWtAO6lmbqjftqV0feOCBNCMkEHLp0qUpB66YD454x/KLMVvN9m200UapWL9jtTLzyMxf+BzIgO98NmJL/2B9D3npgpkEf1ThuetyncsomVbvlihIkiWWaJdddkl1qC3UFVNTOIcFwxK0W3KjT9x3330rrlJVT3va06onP/nJ1QYbbJCm0OVWtpbK966lz7qX9tAWudakDwbyZ6s/q/fxeU6JxgP5zZ8X/yC6kVOPMCINwoZUkIg/h0BUFgFVZBwzy+APEE6EY7HZWmutlf54vUGcS8DFydx2221ptmm99dZbccRyxLNB/qwF7aCetSu/l2x2TFOFIBNSZY011kg+MgXREFSCr220p0LIN9tsszSYbLHFFtXaa6+dZpbIgesTdImshOBz5ssX1AW5bIwTPHddrnMZFYCqTxlQ5VFSp4L59CVT3wIZr7jiiur2229Pdak97Iapj+Vavf7l3HvvvTe1h/f6mDQbylZbbbVKHhx9KzByROPhEIvEy4RR5Wy55ZZJBUYAtsHwZwgk4ohzCaaCoBTExPllBkmFqgRTnPX8Mc5597vfnY61Mb/8JPXQ9Hg2yJ+1oB0IpARhBPrmm29OWork2oRUQnBtGTN7CqFENjqI9le0qb2zmLZGX+3INFq0aFHSZAksh6e1aDZak/6ha5xM3lnHCZ47f/b6//AZSZBrGsvuu++eSJrsG5jV7bbbbptmWc1UaQvHagttE6AVOYcl4RwDh+UcSApByVSI6KXfyEkG5pVo6jcIIA7CZAQTYCTniz9KkPZbZs5gV3+wjnio/LoBf9SfZ2aJClUZ1DxbihJyiavc0+hHKEWMyv2LyOoNlV+/6X4Fy2ftCGBomXwj6n3x4sXJpFl33XWTWSOLP+2UwHaB9kQy4pukr7zhhhuSAJ999tmpTfbdd9+Uu5mPxrHTAvKay2xdfvUd9aGOaCLk3Qp2hG8Al8aURtkL9WsF8u8tNra26sILL0wZ/8zaHnTQQdWaa665st/mxJOfGwoHGFxyzDrR+F6SaLajEY9WoTB3+sF5USC/Zmg7vsPm7M4LLrig+vrXv15tvfXWyV7VKZhMVG4qvdFVheR/HuL6kN+vYFXk9YJYELzcykydXXfdNY2aiEGbRNt0gcHHOQhMueiii6pzzz23uummm5JWQ+A5gZ/73Oemduyq0Ywr1Elel/V6VedI/fzzz1+544PBdocddkh9LNc26mhqo/x7BKG+mV7IRlgI5cD6QESmHXKTKj93XomGsDBr/GEajak4QkVVi5GpV+f2XRTIr+lavg9tyXv2PKKxCtv6JZVhVGQ2sTGxr+NCQON6cX3wPv9c8BDUOdKmmQqQi+llofDsffWmPbUD2z8f5drA4BGTBDQi13nwwQeTRsO35po28jPLQoDJzzSAnOayn78H9YBgaOz8XDRMvktyrk71j5wIctSv1QvqHZG5Bo0T8b///e9P7f/Od74zWSXzSjQ53MyoZOm+h+LkE/uAAAL1G3dB/gfyP0ZI2anURzYmFU9lqCwdwbFNlTvM80wqCKr6IsxI4M4770yqOP8KkuEPiBEzr1fvuxJ2fnx+LXL0xS9+MfnYEJqV2tT2aTGf1EWU+Kwt9AFaO1fEsccem3xiNHluA7Jc7+T5NaD+uam98u+RV2icour1Nf1anhyoXyMUgoD38flRyxjxvendEKA9cOzZrsRaIgFy7Ov6TbsgKqZeQfX3pkhN0THT+HBES6p8Fa/jNKHr80wDor7UHftfcJhRzcZmfDH1+qy3zWzAIMG5aS2TmUo+HG06TOL4cULUadSrV7LKZSCjIE3GdDZNXp0gobpZ6fj8GlD/nKOpL8QMF5I3AUMWaFMIb5NNNkmaTT5g52RXx6xoNGaWjHzm4o855pi0CEwFMJkCXTWIpofOKwuDGn1d23S2QCaVIHbGvTk0w4GVwzW6qvqTjFzQCK2palnrZOHXnpIvEXQCl7djaDfQhbjrHSCH9ox2veOOO5LDH/kwk6cB6iNKfCar3BAC9HbaaaekwYd8I38zS0zPQFeNpqnttIF+qDiGSfWhD30o+YdE3ZsMyAeffhrNUETjJgLwOOz4SAQQccLONvIKyuF7lRp/xpSpbW11jFNPPTU5Fal9ENdoqohpRP2/qyP1ZZW76Wu+Nj4Zg8ZMmK2BJL8OQeeQZI7zu5122mnpPAKdy4T3+Wfo+jyjBqSu3v0PJosk+kxJM3SBpjrMUa+nuvxDve4C+bF5fSKYmA43DW5wMsAjvvr14/PAppNKIJRGHGo2Vc5N5wJNFZFXHDXOFJ9n4ik3tS1WJ0bdpmsUPAR1aaZHABiNZu+9907116bT5gLWBnl79DtX0nGyZppb+5pcINhxfv010PV5Rg3+j3qnSZrq939sKyOsI1D/z72QH9N0fJvrgOMUoQ0GdRHgQknISJ3865iZEhtAnaVCifbFtvLvGoEWCoTRn+UQ5ow+44wzUhxAHVFZBQ+BECuiRM348I+YzoxRda4R91dyGLE9A0ckLVWgoGnvHJPanqGtmIWTGkL+YEQ7n8jrNepZoVBwCItE/shHPpJkZKa+PzDRiEI0lczxSr3WyZum1drCwxI2ahj4U3Xha0JUCvXNDInkQFQ7Gk5cI44pWA71oc28MoPN9vB1Sa5kIDGitq0zx8XIppP0KjH16ti89DpWAc/gPf+bqXaTDs7xfS5vca2Ac/LP44hbbrklkavlFxHDktdP/Od+xTnqSR/Qv7SzEm2r9EN+rYDr0GRMwuhjiNDz9EMnoslvduONN6Y5dgKAbOKPDAMV4B7hRHbN/J5tQb0WJGhq9P7770/fha+mYFUEuXMAy01rdsEyj64gaK7TrxgEzGTkQt6v5J3KM5l9Mr0rgBChudakgrzqxLQFgairrbZa+s9dgdwVDmUOYw52rg6+VXWsz3WFtkRelodYkvKlL30pEVo/dHIGezA3AXYjNdb2JVQ6szu838N0aJ51jq8YrTidmEE+94Ln8ZtnyhnVuSJNJQniZxBvoENRw+P5vUaZZhBA7UYFNqNg+lS0dVcQNEsUmKz5DEgOdW2RH42JDy3Q1A75d9rXzJP1N5JgeVYdSJvmyM9puu44gLOV/Fv1Lsoe/Je8L5D/mYBIRA/LTsivwufjO6QlZMH6stzvkyO/fl6PyM9nbYIEDVJ8eyaE8uO8j8+dicbFMeKzn/3sZDtjNQ+dP5T3bSoBPDQhFQNDPVQJHs4UudkGMQNNU9Hu0Yto4v577LFH8tMQUJXpOeOPRyXE52mFepLmwSI8dcRHo55ys6QN1D8nvJkqg452qft4fEduCH0Id8hJvObIv3NNRbi977/61a8msspH5Lx9YZzb1zIafhB5lczq9kKvOgtE/VvMLL7NKzhHnWgv/c7MLBeI4Fptnlsl+fXzeszJTgoKgZye14LpQH4MDGQ6uShVTuiz0bDfH24D7E1AQ2iGvZ4/qSKZAex6gV+5QBY8BHVFWMTM7Ljjjqk9mThd4TphyhDKJzzhCcnc4TiMwskskBNhBAk4L17rJY5RtJ/nss6K/81Olb4fVlZGFcwR68qaFkjOBIMzMwnJWJqDVARCSi1hGYGAO98h/CAX7dIVtBj5bGiy/TAQ0ZhtYi4hmmH9MmDqkkOJbwazNmkwbWFko1bHvj+caoSy4OFQL8xVRIOYdfBB6t91womP5CURN1JaCRyFf0UaD7FWZMlxCCR/31QcE0RD5siLZ4VJIhv/RZGJgK+xbhq2QfjBmMM0GdeTx0kbMFsVvyEhpnIsFYr6hHqdxnPVvzdpYMbZQudAr77WiWiAA9g0KBXY6EdAwAN4r9Qfpo6w8Rxn6QCVGyFYvoC8hgVBxNb8ASoRs88GIU4iOPPuuuuulLtEXWm/XODawnl8M9pWuwqPNxgxbwSaWQBouYiJAwMBkAH3CnnxOS9+Q3pBfPx/rmGUz4nGveOarjWT/I0y1J9Ie//BGi8uBP+zV8nrKgdCJvPR+bWtaGLaB2JQV0wmZigtx2d1qM90rT/3svCV5eC5DQq90IlodFbpAL1GcN4gDRtkxPNt7QRnEhVOrEBcS+V1vW4vWHzGNNOhCh4OnVf9GDiGAcEP08kAhFB8JtiEcTbaMq4RbcqxCXmHizKO8P90dqYsf4mBcpAB0jVoMlbDAzMpkrrre9H/BoVzo7gWQtTONOOm5+1ENEYWRIN160SjtIWH80BiIswOOdd0tPzAQDADwwoNnwC2DbW+YFXQJGeDaCBUduq+9jU9e/zxxycTiuY6DHL5mtQ2pQ3QLvhU1CGiGcSMtSaJlqotaETqC/kArZPzv2u/yvt5XrSzNB/cHkE0+ncdnYgGAWBJjUwVdsEYxQK9HqZe/GlxONaueDDrWMxeuZaKzU2rGKGi5MivGYjjQr3kqKIx8dk0XWeaoS60Z6TQrNdnW2jTqGP+Hqq6lB0CzvgC5LSRO4UjF8hOlCbU28lzOZ5TGTmSl2jPaO84J38/LvC85F8wLK2Qlu9zXld5aWov/UfoiVfkxXy9+OKL06yuIDsBgPxxfDZWZOuDEHXWq97i+/pvrm8KngamTcDgVUcnovEg0bhmnfyRsI27AFkZ5TArNhRZ7Hp1DCLwgWiAGF17VV7BctOJWWngGAba1KimznUCAm3KnKZEGGkfNBzOYCbzMIhp2GjTvG29H9e2juemkXhvYB+kf+X9BlFZiGlNIr+NuvM7y4S2KZ93ID+vbR1q62h3Aw3giTo6m06hwSAGjR0qWRcIczd9RwDFuvCIx8PlfzD/413gvCgqFiH2+vMFy4VCuw7SjjmMwNa8iRQ3o0GTkceGDw65GFW1h21TTCgMA4NHtGnIi9f8/TgiZDQCHhGNjjwMXEtSfzEuS5YsSf1OfBoC03+lZ5VzWJ2FZjMT8v6lD8fMGIKEXn2t87/wgB4Ke5lNcLM2UGkh1AcffHD6U7QZjirJjeSQ8UqVc4zfCaRoU6qk+8a9e5VAVEDAb7lAFqwKdR31OgwIHK1IEKeBwwyHaWxOYbEb/G86DbVautdh0Fbmxg3qUHv4fzqvdhnkv7pGkJXzhXnIZaMNxDbxh8pg6DjtIYCSAqF9usoBwqcRx3Mr+nUdnU0nFeBiiEZpy4KxNIE3XLSuB6NuWwBppfD++++fXq0GB6q21KCWECAb93ROV1DTY0qv4OEg3LSZEMzZhnZT98wo7edeMRsyKLQpYc61MPcZd4R8G8DJf5hQXUGLj1kmmqYlJSwQbQ2uKdWDfsHsQRTRt7sCOYVvlZ+vqZ91IhoP6ME0MC3DTeLhZ0KoU5xUrkMwfOc11OA4BkJAwR9BaoMQTfiBVH7Bw6E9Cbb21C5RZgvaTlvGAGVgGpZook2HNfdGDTFocwIbmBFN24E8h7oWb6S+ERZiprlEf9Nv9SUk5D7R9/TDrnA9bew5abD4oBfldyIaF6F6CcbiZ3HxcADNBA+kiCK0JCC2xA2zidbCVtxmm22SAJmWs2CTBsT2V3khrFFUWLwP5J1FERUsoKiXOlfw0Ohn4V1gEKIhyNbAmcEiF65BXhTmsB0NCLcitL4rIuTB4CNpeuyG6TM5gFwOxhHhXpASVx1apa4fhIzXSy7nOZCHYEkai+tYruG63mtv75GPtgLEZsDRhq7bBepehgTtKtg2tfGy69fRWaPBlB4qHHpNqlIv+BOcgmz5ekEG7Hp/GlSG+1DHEI/P2DmvXN/F+xz5MRxhpt9cq+DhMKqpH9nS8nrrCstIZOXj/BVwFqMxYZbi1WCCdHQci/C6wqgJrikC1VqqXNXv2kFGEeRZf7KI0v8VgU/mu4KsG7CFdug7MYgLcKS10Ai1CULSJhzFXgdJAO/5zGZROEQgk50g/hydiAaMfpg3iKar+kogYqSrF5Ub5AFeCVb4d4KNo/g93jeBRmT0K0TTG+pF/ainYRC5f6z+tpWtVfeckEIX5G9GPNrJ50Hy3cSAhrgsPxCEFh2DTE0C0YD/SaNRVzZxG4T0XQOh241En+GDYR3wg4pX45yXMgJoIT7rf9HPugBx0TC1bywf8r6OzqYTDUOOGKq2SMBB7LocVC1CggWRlnv4Dnw2ann1u0r3u/dRfFYCcS0wu6Ej8bbnxxQ8BAJtvYt6knqBYHYdPADByNBPXRe4xYwSnUr9J3ickRzC8pcMMnLqBNrV6GygC/NikhADq5k6yywM5oNoNM6Jdj355JOTxcA3qr/a4dVmcOqS5mSXC1aEe0e/64LQaAQBalf3JUN1dEpO7uE8EH+HOXmjiofNR5OuI0t+PAHHxlR5OWJd28O7r+Pi2HgfhFKHZ2Rv2saVlmRnBI2nEgpWBQLWnhIX0Uh67d/UBkwwA5CoXWawBZoGJeq0xbL77LNPGk21cd6WbaGtqf7aVGcUgMZ80taB/P04IuTZ/1AE2tl6uM3OInl9OjfqWBvITIhM+G20C5OKxmnfrlhIG+flaNNGJhEks3ct141r1M/tlPgK4xFCo4sQZv4awT/+TKDNw+WoH+8eBCnIxf3yCmiqjPw6tCyjqr2mMK2Ntwh4vQO5Vv160wb1rM7VFT8NHwttoevo5niDBFtdWyD1IHbakt/ITTg82yBvU+3E9yMEgvklLoScILjAuA8k8X/9D5G7pqV33nnnlFWwF3LZzesqbzsWgTZxTYNvQJs4R7tAr36QX7MJ+j8tEylaXBltUD+3s+kEHl4EKKdczFZ4UBdvKk1wXhQPSfCpXl6DbPIS3yueJ77Pr4Vo5POgsgsOhFDn4j6K99MOdYiEqdA0BrmG6r6yQNRzL8SAQICRCQKgKSnxmzYIQYw26FdyIBUCrW0lbnItcth0/Lgi6pwmT7u0VIemmdddIGS/XvI+or60r/bgt6HZeEUw0S6IqUsduq5riodjitFkaZf9zu9ENDlc3HoWuVuNVNgyZgYWGuI0+Bt43q0yV6kqs95xCpZ3ePXCQStNh85stmOu0auD1EsOPh8LA81sMc+057D+wVGF/05maW4IRh8TUDlX8ttU501Q7xbOWmZiABBpbIDph4GJBoNZkWv6mPagQma62XyBE5gTkm8mooKRoIYqZLMqInZCkRWPEJ3RkJZxNusuF+42xUp/95dHN0jGqDpJyOuX1mASw0yOGSJ7KLX9v3m9tUF+fF6aQGa++93vpueS/tVz5iZsLwxMNBp7hx12SA4gO+hFusymMleISjEyqwDpJ6xK5XykzXhOoM7nKmXBclCfjUo6Luc7rcZ0dATYhUo91+3YBLMaVn3LXSTNAeel9jaw9esM4w6DI9PQtLQBXJtwU2gTgyYrIm+TuW4fMuL62sN0uXAGpvbhhx+eSGYma2bgHqeRha5boesm1iV5gIWCShCtbIsVqrXFfRqqoD0Qiq1MRG9bcR0RpTDXgtwLhNvAwZlv1OSbMWBMA6LembQc36am5Vw2SC6E5RB9CQHSeCUyi62WYCZta+C9t+PGPM0cVyqBIFqNPQxilHIt7/uNWvlvmJZDk8lkNepaa62V2L/p/PnuNOMA9cXUNFMnfQAtlS8uX77Rrz26INq2X+HMf9e73pVmYDhF7cNNA4tOOMmgsejU/q/OTL5tvaJekK7fIOQYAfmtCX53bLzmiPqulxxI33f6loRZ0rsYzH0X18yvWz9/YKLJHxrrEgobwBFWa1moU3FjJo0Ka4N4QOd6X3/gHBrD/USLvuc970nrpqh0gp3i3k3nx+8FD0F7KjRVBGPfZ74BsRwGFuZV23acCU3t4nudiEPajKFgMCRj4gGmgWQgJxJanLiypUuXpjZB/ILxaBHqY6Z+AtFX4zXOUfr1Bb+HaW2bJQ5gGTGlmXB/8uD8+jXrGJho8ou5oWXnPNHUKn+ef4QdDVFpbRDXzR+8Cf6k6FNz+RxT4g34jXI1run8fpVbsDxVgZy1pi8vv/zy9N4EwEwqcls0tYtBicnGdNO2xx57bCK6aQY5V+9MWqlQrSszC8VFwIxCHjOhF9H0Qv69tjCQuxdnPG1G/ByfbEyRt8WsEI2KIJg85DQbI9DVV1+dVLyI7G3bseO6bYiGnSg3ralPZhMHsD+fV3zT+YVoZgZThRlFSzTtbdGr72YDTe1iV1HaKTlijiOZLvIzqRB0F0sTaPCWfHAO62O0zVzmeyHqMF6b6j//3nXF8BjIOeRtz8Ina9BhytF02pJNZ6LxIL06Mi2GuSR2xatZCzMFFmEKSce81C/nOtYDOrcuQHG9qAwlVDcaEnaVdkAkot0t+RRsTi+C0jWRXpzXqwTy9wUPh3ZSl9qP2k5jFDZAyCNFA2gn9V5vx5ngeHLgOoRWKDvT+6ijjkp+P36ASCfR9dqTgJD/eB+apDVj2sPaJWElYoti/6ewILSbc/Sb6KtBMPGay3/0xzhPX9POIrGZr3x1EtTFnulcFo5tSzLQaQkCzNRhqVse1AhoDYToYSqftRVbbLFFYslwJAPVLJBXgD/vvYqJyuEUvPTSS6svf/nLyV61a6H1M/k0dhe4plIwMyzpoDpbokCzsTKbtsE/pw4JXhdoUwRDG9WmTDRaTGzZ6h7T3Db+e72fKbmcG8yt/bL4kkljkNfXaD7qVh3HNbSPc+M1v3ZOHAZxKT0QmHbhj9EeopT9ruibXTHrRAPIBkTosu/Z2WxLarcFXtJz8qSHhhPIKzcnGomysLed95CNkc6iuk033TSZbKbXu7BrwP2mWZjbgiDSPKjvCN42qvbjQgactAL9mFhdwLS23IEDXyi7ld18bPwORu+uxDVpaCKakHX1o5/R8Gn3+phztIl8P3yVfGq0GuhHNM6jUTJbuT20h+OYsPI/05ZYDjSm6NtdMSdEE0AWhMaUs8Q7bH2zCNjWql7CSe2jnisqwB9RRBxT2WTiw7KICalQ4diKKkKF50Thff4ZciKDXscUtAfCoXkgCCkIbHZmEFHP/Af8dExlK/CZ0NpJfJXgLtGkCpWcVmvdDTk48sgjUzgCWYmOAf1kq2BVGLSZm4hC9jymFROXRmIw0H/yxc98L2b2xOcYPKSO0CbagyJgWUGYx9Hnh2mPOSUaQhYgaEZE06X+mORFnFmyfSESM1YIINQzlYSRpaIghFRCUchhdsV9c9LoRSK9nq8QzeDIidtAQkC1KQJhBinse9qsAUNdazM+Om3Jkahoz/XWWy+ZXtobwSjhi4B+slWwKrSFop9JYibQUQlCQfY0lQCSN3CLtKYFmS5XWBy0F+0WpK8dogyKeSEaD0zoCJHjVUiMcrQYxXdYGQgzNjUixqyVz1R457ueays5aXhfSGRuoQ3D/qdKawtEYrDwvcFEe3qvTSHaigouBkS7+i00GMf73SvSCfSTrYJVEXWt/vQTdcvM0h40UN/FMeA4da5f0XRiAHGe35yrPUA7RBkUc0o0vRBkkBPCMNfMr1O/bsFooN6+gWivpjbrIgfTDnVY70P553pdz3fdrurAmEdERcz3Hy4oKJh/LAjR5CRTyKagYPIx70TTRCqFdAoKBke93zCR+GSi5CbTQvSxBdNoCgogBH+mUjDeGAkfTRGk6cRMbV/kY3KwYERTML0o5DF9GHp6e5SQT98VjA5mkpmmNsvPiWNK+44nikZTsOAIIqqXHPXPBeOFzhpNjl4CMd8oWsx4oZfM5BGrOUSrlvadDAxNNKOAIojjg14y09R+cWxp3/HHUERTUFBQMDOq6v8BcWxo8LWsJZUAAAAASUVORK5CYII=" alt="" />
<strong>Output: </strong>false<br /><strong>Explanation: </strong>The given tree is not complete binary tree because in last level all nodes are not at left.
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=number of node&lt;=10<sup>5</sup></span><br /><span style="font-size: 18px;">0 &lt;= node -&gt; data &lt;= 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/complete-binary-tree-inserter/description" target="_blank" rel="noopener noreferrer">Complete Binary Tree Inserter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>complete binary tree</strong> is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>

<p>Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.</p>

<p>Implement the <code>CBTInserter</code> class:</p>

<ul>
	<li><code>CBTInserter(TreeNode root)</code> Initializes the data structure with the <code>root</code> of the complete binary tree.</li>
	<li><code>int insert(int v)</code> Inserts a <code>TreeNode</code> into the tree with value <code>Node.val == val</code> so that the tree remains complete, and returns the value of the parent of the inserted <code>TreeNode</code>.</li>
	<li><code>TreeNode get_root()</code> Returns the root node of the tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg" style="width: 500px; height: 143px;" />
<pre>
<strong>Input</strong>
[&quot;CBTInserter&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;get_root&quot;]
[[[1, 2]], [3], [4], []]
<strong>Output</strong>
[null, 1, 2, [1, 2, 3, 4]]

<strong>Explanation</strong>
CBTInserter cBTInserter = new CBTInserter([1, 2]);
cBTInserter.insert(3);  // return 1
cBTInserter.insert(4);  // return 2
cBTInserter.get_root(); // return [1, 2, 3, 4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 5000</code></li>
	<li><code>root</code> is a complete binary tree.</li>
	<li><code>0 &lt;= val &lt;= 5000</code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>insert</code> and <code>get_root</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-deque">Approach 1: Deque</h3>
<p><strong>Intuition</strong></p>
<p>Consider all the nodes numbered first by level and then left to right.  Call this the &quot;number order&quot; of the nodes.</p>
<p>At each insertion step, we want to insert into the node with the lowest number (that still has 0 or 1 children).</p>
<p>By maintaining a <code>deque</code> (double ended queue) of these nodes in number order, we can solve the problem.  After inserting a node, that node now has the highest number and no children, so it goes at the end of the deque.  To get the node with the lowest number, we pop from the beginning of the deque.</p>
<p><strong>Algorithm</strong></p>
<p>First, perform a breadth-first search to populate the <code>deque</code> with nodes that have 0 or 1 children, in number order.</p>
<p>Now when inserting a node, the parent is the first element of <code>deque</code>, and we add this new node to our <code>deque</code>.</p>
<p><a href="https://leetcode.com/playground/KLGeXjUA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  The preprocessing is <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the tree.  Each insertion operation thereafter is <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N_{\text{cur}})\)</span> space complexity, when the size of the tree during the current insertion operation is <span class="math inline">\(N_{\text{cur}}\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/connected-components-in-an-undirected-graph/1" target="_blank" rel="noopener noreferrer">Connected Components in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected graph with&nbsp;<strong>V&nbsp;</strong>vertices numbered from 0 to V-1 and&nbsp;<strong>E</strong> edges, represented as a 2D array <strong>edges[][]</strong>, where each entry&nbsp;<strong>edges[i] = [u, v]</strong>&nbsp;denotes an edge between vertices&nbsp;<strong>u</strong>&nbsp;and&nbsp;<strong>v</strong>.</span></p>
<p><span style="font-size: 18px;">Your task is to return a list of all connected components. Each connected component should be represented as a list of its vertices, with all components returned in a collection where each component is listed separately.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> You can return the components in any order, driver code will print the components in <strong>sorted </strong>order.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V = 5, edges[][] = [[0, 1], [2, 1], [3, 4]]
<strong>Output: </strong>[[0, 1, 2], [3, 4]]</span><strong><span style="font-size: 18px;">
Explanation:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893290/Web/Other/blobid1_1744798106.jpg" width="269" height="238" /><br /></span></strong></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 7,<strong> </strong></span><span style="font-size: 18px;">edges[][] <strong>= </strong>[[0, 1], [6, 0], [2, 4], [2, 3], [3, 4]]
<strong>Output: </strong>[[0, 1, 6], [2, 3, 4], [5]]<br /><strong>Explanation:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893290/Web/Other/blobid0_1744797809.jpg" width="360" height="228" /></strong></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1 &le; V &le; 10<sup>5</sup><br />1 &le; edges.size() &le; 10<sup>5</sup><br /></span><span style="font-size: 18px;">0 &lt;= edges[i][0], edges[i][1] &lt; V</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/jenny-and-water-7-d0337cc3-ec2c1136/" target="_blank" rel="noopener noreferrer">Connecting the special nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">hard</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a graph of <span class="mathjax-latex">\(N\)</span> nodes. The graph consists of connected components. Some of the connected components contain a special node and each component contains at most one special node. You are required to maximize the number of edges in the given graph such that it follows these constraints: </p>

<ul>
	<li>No self-loop or multiple edges should be present </li>
	<li>No connected components with more than one special node should be present</li>
	<li>Each node in the graph should belong to a component with exactly one special node</li>
</ul>

<p>If you add an edge between two nodes that belong to the same component in the graph, then the total cost involved is <span class="mathjax-latex">\(0\)</span>. Whereas, if you connect two nodes that belong to different components, then the cost is equal to the product of the sizes of both the components. </p>

<p>Your task is to maximize the number of new edges in the graph and calculate the minimum cost that will be involved in performing the required task.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>First line: Three integers <span class="mathjax-latex">\(N,\ M,\ and\ K\)</span> representing the number of nodes, number of edges, and number of special nodes in the graph respectively</li>
	<li>Next <span class="mathjax-latex">\(M\)</span> lines: Two integers <span class="mathjax-latex">\(u\ and\ v\)</span> representing an undirected edge from the node <span class="mathjax-latex">\(u\)</span> to node <span class="mathjax-latex">\(v\)</span> </li>
	<li>Next line: An empty line</li>
	<li>Next line: <span class="mathjax-latex">\(K\)</span> space-separated integers each representing the special nodes in a connected component</li>
</ul>

<p><strong>Output format</strong></p>

<p>Print the maximum number of new edges that can be added to the graph and the minimum cost of doing so.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 ≤ N ≤ 10^{5}\)</span></p>

<p><span class="mathjax-latex">\(1 ≤ M ≤ 2 \times 10^{5}\)</span></p>

<ul>
	<li><span class="mathjax-latex">\(K \leq\)</span> the total number of connected components present in the graph.</li>
	<li>It is guaranteed that for any connected component at most one special node exists.</li>
	<li>The given graph does not contain any self-loops or multiple edges.</li>
</ul></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The given graph consist of 5 connected components.<span class="mathjax-latex">\( (1, 2, 3), (4, 5, 6, 7), (8), (9, 10), (11, 12)\)</span>.<br>
1 is the special node in <span class="mathjax-latex">\((1, 2, 3)\)</span> and 4 is the special node in <span class="mathjax-latex">\((4, 5, 6, 7)\)</span>.<br>
There is no special node in <span class="mathjax-latex">\((8), (9, 10), (11, 12)\)</span>.<br>
<br>
For <span class="mathjax-latex">\((1, 2, 3)\)</span>:-<br>
We can add 1 edge from 2 to 3,  cost = 0 (same component).<br>
For <span class="mathjax-latex">\((4, 5, 6, 7)\)</span>:-<br>
We will add 3 edges from 6 to 5, 6 to 7 and 4 to 7. Now we can't add more edges to this component, cost = 0 (same component).<br>
For the remaining nodes (without special nodes):-<br>
We will first connect $$8$$ and <span class="mathjax-latex">\((11, 12)\)</span> with cost 2 and 2 edges.<br>
Then <span class="mathjax-latex">\((8, 11, 12)\)</span> and <span class="mathjax-latex">\((9, 10)\)</span> with cost 6 and 6 edges. (product of their sizes).<br>
Now we have all the non special nodes completely connected.<br>
We can now connect all the 5 non special nodes to the component <span class="mathjax-latex">\((4, 5, 6, 7)\)</span> with cost 20 and 20 edges.<br>
Hence total cost is 28 and maximum number of edges that can be added are 32.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/contain-virus/description" target="_blank" rel="noopener noreferrer">Contain Virus</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.</p>

<p>The world is modeled as an <code>m x n</code> binary grid <code>isInfected</code>, where <code>isInfected[i][j] == 0</code> represents uninfected cells, and <code>isInfected[i][j] == 1</code> represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two <strong>4-directionally</strong> adjacent cells, on the shared boundary.</p>

<p>Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There <strong>will never be a tie</strong>.</p>

<p>Return <em>the number of walls used to quarantine all the infected regions</em>. If the world will become fully infected, return the number of walls used.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg" style="width: 500px; height: 255px;" />
<pre>
<strong>Input:</strong> isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
<strong>Output:</strong> 10
<strong>Explanation:</strong> There are 2 contaminated regions.
On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg" style="width: 500px; height: 257px;" />
On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg" style="width: 500px; height: 261px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg" style="width: 653px; height: 253px;" />
<pre>
<strong>Input:</strong> isInfected = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Even though there is only one cell saved, there are 4 walls built.
Notice that walls are only built on the shared boundary of two different cells.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> The region on the left only builds two new walls.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m ==&nbsp;isInfected.length</code></li>
	<li><code>n ==&nbsp;isInfected[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>isInfected[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is always a contiguous viral region throughout the described process that will <strong>infect strictly more uncontaminated squares</strong> in the next round.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-good-nodes-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Count Good Nodes in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named&nbsp;<strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.</p>

<p>Return the number of <strong>good</strong> nodes in the binary tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" style="width: 263px; height: 156px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [3,1,4,3,null,1,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.
Root Node (3) is always a good node.
Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.
Node 5 -&gt; (3,4,5) is the maximum value in the path
Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png" style="width: 157px; height: 161px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [3,3,null,4,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because &quot;3&quot; is higher than it.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the binary tree is in the range&nbsp;<code>[1, 10^5]</code>.</li>
	<li>Each node&#39;s value is between <code>[-10^4, 10^4]</code>.</li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-islands-with-total-value-divisible-by-k/description" target="_blank" rel="noopener noreferrer">Count Islands With Total Value Divisible by K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> and a positive integer <code>k</code>. An <strong>island</strong> is a group of <strong>positive</strong> integers (representing land) that are <strong>4-directionally</strong> connected (horizontally or vertically).</p>

<p>The <strong>total value</strong> of an island is the sum of the values of all cells in the island.</p>

<p>Return the number of islands with a total value <strong>divisible by</strong> <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/06/example1griddrawio-1.png" style="width: 200px; height: 200px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,2,1,0,0],[0,5,0,0,5],[0,0,1,0,0],[0,1,4,7,0],[0,2,0,0,8]], k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The grid contains four islands. The islands highlighted in blue have a total value that is divisible by 5, while the islands highlighted in red do not.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/06/example2griddrawio.png" style="width: 200px; height: 150px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,0,3,0], [0,3,0,3], [3,0,3,0]], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The grid contains six islands, each with a total value that is divisible by 3.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-servers-that-communicate/description" target="_blank" rel="noopener noreferrer">Count Servers that Communicate</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">counting</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a map of a server center, represented as a <code>m * n</code> integer matrix&nbsp;<code>grid</code>, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.<br />
<br />
Return the number of servers&nbsp;that communicate with any other server.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-6.jpg" style="width: 202px; height: 203px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,1]]
<strong>Output:</strong> 0
<b>Explanation:</b>&nbsp;No servers can communicate with others.</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/11/13/untitled-diagram-4.jpg" style="width: 203px; height: 203px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[1,1]]
<strong>Output:</strong> 3
<b>Explanation:</b>&nbsp;All three servers can communicate with at least one other server.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-1-3.jpg" style="width: 443px; height: 443px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
<strong>Output:</strong> 4
<b>Explanation:</b>&nbsp;The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 250</code></li>
	<li><code>1 &lt;= n &lt;= 250</code></li>
	<li><code>grid[i][j] == 0 or 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a grid representing a server center in the form of a matrix of size <code>m x n</code>. Each cell of the matrix contains either a <code>1</code>, indicating the presence of a server, or a <code>0</code>, indicating an empty space.</p>
<p>We need to return the number of servers that can communicate with at least one other server. This excludes servers that are isolated, i.e., those that do not share a row or column with any other server.</p>
<p>The first thing to note is that a server can communicate with another server if they are located either in the same row or the same column. Thus, the key observation here is that we only need to check rows and columns to determine if a server is communicable. If there’s at least one other server in the same row or column, then this server is communicable.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute-Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We know that each cell either contains a server (represented by <code>1</code>) or is empty (represented by <code>0</code>). So, we start by going through each cell to see if there is a server at that position. If the current cell contains a server, we then check if this server can communicate with any other server. If it can, we count it as communicable.</p>
<p>Once we find a server, we check if there is any other server in the same row that can communicate with it. We do this by iterating through all the other cells in the same row. If we find another server in the same row, we can immediately mark it as communicable.</p>
<p>If we do not find any other server in the row, we proceed to check the column. We iterate through all the other rows in the same column to see if there is another server. If a server is found in the same column, we know this server can communicate and is communicable.</p>
<p>As soon as we determine that a server can communicate (either in the same row or column), we increment the total communicable servers count. Once we finish checking the entire grid, we return the count of communicable servers.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>numRows</code> and <code>numCols</code> to represent the number of rows and columns in the grid.</p>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will keep track of the count of communicable servers.</p>
</li>
<li>
<p>Traverse through the grid:</p>
<ul>
<li>For each server at position <code>(row, col)</code> where <code>grid[row][col] == 1</code>:
<ul>
<li>Set <code>canCommunicate</code> to <code>false</code>.</li>
<li>Check for communication in the same row:
<ul>
<li>Iterate through each column <code>otherCol</code> in the same row:
<ul>
<li>If <code>otherCol</code> is not equal to <code>col</code> and <code>grid[row][otherCol] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
<li>If no communication was found in the same row, check for communication in the same column:
<ul>
<li>Iterate through each row <code>otherRow</code> in the same column:
<ul>
<li>If <code>otherRow</code> is not equal to <code>row</code> and <code>grid[otherRow][col] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DouY2Fzd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span></p>
<p>The algorithm traverses through each cell in the grid using nested loops, where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). For each cell containing a server (<code>grid[row][col] == 1</code>), it performs two additional checks:</p>
<ol>
<li>It checks the entire row to see if there is another server in the same row. This involves iterating over <span class="math inline">\(n\)</span> columns.</li>
<li>If no server is found in the same row, it checks the entire column to see if there is another server in the same column. This involves iterating over <span class="math inline">\(m\)</span> rows.</li>
</ol>
<p>Since these checks are performed for each server, the worst-case time complexity is <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only maintains a few variables (<code>numRows</code>, <code>numCols</code>, <code>communicableServersCount</code>, <code>canCommunicate</code>, etc.). No additional data structures are used that scale with the input size. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-track-using-two-arrays">Approach 2: Track Using Two Arrays</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To optimize the checking process, the first step is to count how many servers exist in each row and each column before we start checking individual servers.</p>
<p>We don’t need to check the entire row and column every time for every server. Instead, we can track the number of servers in each row and column using two arrays: <code>rowCounts</code> and <code>colCounts</code>. We loop over the grid once, and for each server (<code>grid[row][col] == 1</code>), we increment the count for the corresponding row and column. This precomputes how many servers are present in each row and column.</p>
<p>The advantage of this approach is that we know in advance how many servers are in a given row or column, so when we encounter a server, we can quickly determine if it’s communicable by checking these precomputed values.</p>
<p>Once we have the counts of servers in each row and column, the next task is to identify which servers are communicable. For a server at position <code>(row, col)</code>, we need to check:</p>
<ul>
<li>If the row has more than one server (i.e., <code>rowCounts[row] &gt; 1</code>), which means there are other servers in the same row.</li>
<li>If the column has more than one server (i.e., <code>colCounts[col] &gt; 1</code>), which means there are other servers in the same column.</li>
</ul>
<p>If either condition is true, the server can communicate, and we increment the count of communicable servers.</p>
<p>Once we’ve checked all servers and counted the communicable ones, we simply return the count.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize two arrays, <code>rowCounts</code> and <code>colCounts</code>, of appropriate sizes to keep track of the server counts in each row and column.</p>
</li>
<li>
<p>Count servers in each row and column:</p>
<ul>
<li>Iterate through each row (<code>row</code>), and for each row, iterate through each column (<code>col</code>):
<ul>
<li>If there’s a server at <code>grid[row][col]</code>, increment the corresponding values in <code>rowCounts[row]</code> and <code>colCounts[col]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will store the count of servers that can communicate.</p>
</li>
<li>
<p>Count servers that can communicate (i.e., those in the same row or column as another server):</p>
<ul>
<li>Iterate again through each row and column:
<ul>
<li>If there’s a server at <code>grid[row][col]</code>, check if it can communicate with another server (i.e., if <code>rowCounts[row] &gt; 1</code> or <code>colCounts[col] &gt; 1</code>).</li>
<li>If so, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7NwwDvo6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The first nested loop iterates over each row in the grid to count the number of servers in each row and column. The outer loop runs <span class="math inline">\(m\)</span> times (for each row), and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second nested loop also iterates over each row in the grid to determine if a server can communicate with others in its row or column. This again involves an outer loop running <span class="math inline">\(m\)</span> times and an inner loop running <span class="math inline">\(n\)</span> times, resulting in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Since both loops are independent and each has a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional arrays:<br />
- <code>rowCounts</code> of size <span class="math inline">\(n\)</span> (number of columns) to store the count of servers in each column.<br />
- <code>colCounts</code> of size <span class="math inline">\(m\)</span> (number of rows) to store the count of servers in each row.</p>
<p>The space required for these arrays is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-server-grouping">Approach 3: Server Grouping</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In Approach 2, we were repeatedly scanning the entire row and column for each server to check if there were any other servers for communication. While this method works, it is somewhat redundant since we perform the same checks multiple times. The goal now is to micro-optimize the process.</p>
<p>Instead of directly checking the count of servers in every row and column each time we find a server, we aim to track the necessary information during our first pass so that in the second pass, we can make decisions more quickly. This will reduce some runtime redundancy.</p>
<p>We begin by initializing a <code>colCount</code> array, where each entry tracks the number of servers in that row. By maintaining this count, we can easily find if a server can communicate based on the number of servers in the same row.</p>
<p>In addition to counting the servers in each row and column, we use another array, <code>lastServerInRow</code>, to track the position of the last server in each column. This is crucial because if a column has multiple servers, we don’t need to check the entire column again. Instead, we can focus on whether the last server in a column is part of a communicable set (i.e., a row or column with multiple servers). For example, if <code>lastServerInRow[0]</code> is 3, it means the last server in column 0 is at row 3. If this server can communicate, it indicates that there are other servers in that column, and we can mark it as communicable without needing to scan all rows again.</p>
<p>Now we process each server in the grid by iterating over the rows and columns. For each server we encounter, we:</p>
<ul>
<li>Increment the count for that row in the <code>colCount</code> array.</li>
<li>Track the position of the last server in the <code>lastServerInRow</code> array.</li>
</ul>
<p>Thus, we gather all the necessary information about how many servers are in each row and column and the position of the last server.</p>
<p>After collecting this information, we use the <code>colCount</code> and <code>lastServerInRow</code> arrays to identify communicable servers. For each server in the grid, we check if the count of servers in the same row is greater than 1. If it is, we know that this server can communicate with another server in the same row. Similarly, we check if the server’s column has more than one server using the <code>lastServerInRow</code> array. If the server is part of a communicable set (i.e., there are other servers in the same row or column), we increase the count of communicable servers.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1267/server_grouping.json:760,532!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>communicableServersCount</code> to 0 to keep track of servers that can communicate.</li>
<li>Initialize <code>colCount</code> to store the count of servers in each row, and <code>lastServerInRow</code> to track the last server in each column.</li>
</ul>
<h5 id="first-pass-count-servers-in-each-row-and-column">First Pass: Count servers in each row and column</h5>
<ol>
<li>Iterate through each row (<code>row</code>):
<ul>
<li>For each row, initialize <code>serverCountInRow</code> to 0 to track the number of servers in that row.</li>
<li>Iterate through each column (<code>col</code>):
<ul>
<li>If a server is found at <code>grid[row][col]</code>, increment <code>serverCountInRow</code>, update <code>colCount[col]</code>, and set <code>lastServerInRow[col]</code> to <code>row</code>.</li>
</ul>
</li>
<li>If the row has more than one server, increment <code>communicableServersCount</code> by the number of servers in the row and set <code>lastServerInRow[col]</code> to -1 (indicating no servers to communicate in that column).</li>
</ul>
</li>
</ol>
<h5 id="second-pass-check-if-servers-can-communicate">Second Pass: Check if servers can communicate</h5>
<ol start="2">
<li>Iterate again through each column (<code>col</code>):
<ul>
<li>If there is a server at <code>lastServerInRow[col]</code> and the count of servers in the corresponding row (<code>colCount[lastServerInRow[col]]</code>) is greater than one, increment <code>communicableServersCount</code> by 1.</li>
</ul>
</li>
</ol>
<ul>
<li>Finally, return <code>communicableServersCount</code>, the total count of servers that can communicate.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/8eyTWJqP/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm performs two passes over the grid. In the first pass, it iterates over each cell in the grid to count the number of servers in each row and column. This involves nested loops where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second pass iterates over the rows to check if servers can communicate based on the counts computed in the first pass. This pass runs in <span class="math inline">\(O(m)\)</span> time. Since <span class="math inline">\(O(m \cdot n)\)</span> dominates <span class="math inline">\(O(m)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional data structures: <code>colCount</code> and <code>lastServerInRow</code>. The <code>colCount</code> array has a size of <span class="math inline">\(n\)</span> (number of columns), and the <code>lastServerInRow</code> array has a size of <span class="math inline">\(m\)</span> (number of rows). Therefore, the space complexity is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-space-optimized">Approach 4: Space Optimized</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of keeping an array to track the position of the last server in each column, we just count the number of servers directly in each row and perform a simple check when a single server is found, leveraging the grid's structure itself.</p>
<p>We start by iterating over each row in the grid. For each row, we count how many servers are present. As we count, we also keep track of the column index of the first server encountered. This is important because if there’s only one server in the row, we need to check if there’s any other server in the same column.</p>
<p>Once the row is processed, we check if there are multiple servers in that row. If there are, we conclude that all servers in that row can communicate with each other, so we add the count of servers in that row to the total communicable servers count.</p>
<p>If there’s exactly one server in the row, we then check all the other rows to see if there’s any server in the same column as that single server. If such a server exists, then the lone server in that row is communicable, and we add it to the total count.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>rows</code> and <code>cols</code> to the dimensions of the grid, and <code>communicableServersCount</code> to <code>0</code>, which will store the total count of communicable servers.</p>
</li>
<li>
<p>Iterate through each row (<code>rowIndex</code>):</p>
<ul>
<li>
<p>Initialize <code>rowCounts</code> to count the number of servers in the current row, and <code>serverColumnIndex</code> to store the column index of the first server in the row.</p>
</li>
<li>
<p>Count the servers in the current row:</p>
<ul>
<li>Iterate through each column (<code>colIndex</code>):
<ul>
<li>If there's a server (<code>grid[rowIndex][colIndex]</code>), update <code>serverColumnIndex</code> if it is the first server found, and increment <code>rowCounts</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check if the row has more than one server (<code>rowCounts != 1</code>), meaning servers in the row can communicate. If not, check for a server in the same column (<code>serverColumnIndex</code>) in other rows.</p>
</li>
<li>
<p>If the server can communicate (either because there are multiple servers in the row or another server exists in the same column in another row), add <code>rowCounts</code> to <code>communicableServersCount</code>.</p>
</li>
</ul>
</li>
<li>
<p>After iterating through all rows, return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/89oda5wC/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The algorithm iterates over each cell in the grid once to count the number of servers in each row and determine if they can communicate. For each row, it takes <span class="math inline">\(O(n)\)</span> time to count the servers and <span class="math inline">\(O(m)\)</span> time to check if a server in a row can communicate with another server in the same column. Since there are <span class="math inline">\(m\)</span> rows, the total time complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>The nested loops and the checks for communication contribute to this time complexity. The outer loop runs <span class="math inline">\(m\)</span> times, and the inner loops run <span class="math inline">\(n\)</span> times and <span class="math inline">\(m\)</span> times respectively, leading to the overall time complexity of <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm does not allocate any additional memory that depends on the size of the input grid. All operations are performed in-place using a fixed number of variables.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-sub-islands/description" target="_blank" rel="noopener noreferrer">Count Sub Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <code>m x n</code> binary matrices <code>grid1</code> and <code>grid2</code> containing only <code>0</code>&#39;s (representing water) and <code>1</code>&#39;s (representing land). An <strong>island</strong> is a group of <code>1</code>&#39;s connected <strong>4-directionally</strong> (horizontal or vertical). Any cells outside of the grid are considered water cells.</p>

<p>An island in <code>grid2</code> is considered a <strong>sub-island </strong>if there is an island in <code>grid1</code> that contains <strong>all</strong> the cells that make up <strong>this</strong> island in <code>grid2</code>.</p>

<p>Return the <em><strong>number</strong> of islands in </em><code>grid2</code> <em>that are considered <strong>sub-islands</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/10/test1.png" style="width: 493px; height: 205px;" />
<pre>
<strong>Input:</strong> grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png" style="width: 491px; height: 201px;" />
<pre>
<strong>Input:</strong> grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
<strong>Output:</strong> 2 
<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid1.length == grid2.length</code></li>
	<li><code>n == grid1[i].length == grid2[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid1[i][j]</code> and <code>grid2[i][j]</code> are either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two binary matrices, <code>grid1</code> and <code>grid2</code>, both of size <code>m x n</code>, where 1 represents land and 0 represents water. An island is a group of connected 1s, connected horizontally or vertically. The task is to find how many islands in <code>grid2</code> are also sub-islands of <code>grid1</code>. An island in <code>grid2</code> is considered a sub-island if every land cell of the island is part of an island in <code>grid1</code>.</p>
<p><img src="../Figures/1905/Slide-1a.png" alt="slide1a" /></p>
<br />
<p>If we overlap this image with <code>grid1</code>, we can see all the land cells of the island of <code>grid2</code> lie on one island in grid1.</p>
<p><img src="../Figures/1905/Slide-1b.png" alt="slide1b" /></p>
<br />
<p>Let's consider another island of the <code>grid2</code>, now, is this a sub-island?</p>
<p><img src="../Figures/1905/Slide-1c.png" alt="slide1c" /></p>
<br />
<p>If we overlap this image with <code>grid1</code>, we can see two land cells are lying on the water cell, thus this island can't be considered a sub-island.</p>
<p><img src="../Figures/1905/Slide-1d.png" alt="slide1d" /></p>
<br />
<p>The above images hint that; to check whether an island of <code>grid2</code> is a sub-island in <code>grid1</code>, we can start traversing on each land cell of the current island of <code>grid2</code> and for each land cell there should be a land cell in <code>grid1</code> at the same position (at same <code>(x, y)</code> index in grids).</p>
<p>Each grid cell is connected to its adjacent neighbors 4-directionally (horizontal or vertical), this grid problem can be visualized as a graph traversal problem, where each cell is a node and the 4-directions are edges connecting those nodes.</p>
<p><img src="../Figures/1905/Slide-1e.png" alt="slide1e" /></p>
<br />
<p>We will iterate on each cell of the <code>grid2</code>, if the current cell is a land cell we traverse the whole island of <code>grid2</code> containing the current land cell. While traversing over the entire island we keep track if, for each land cell of the island of <code>grid2</code>, the <code>grid1</code> also has a land cell at the respective position using a boolean variable. After iteration on the current island is completed this boolean variable will denote if the island is a sub-island or not.</p>
<br />
<p>The following slideshow will give you an idea about this approach:</p>
<p>!?!../Documents/1905/slideshow1.json:1900,1600!?!</p>
<p>There are different techniques to traverse a graph, in this article we will cover some of them in brief, we assume you already have a good knowledge about them,<br />
if you are new to the graph traversal algorithms we recommend you read the following Leetcode articles before proceeding:</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/3883/">Breadth-First Search</a></li>
<li><a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/3882/">Depth-First Search</a></li>
<li><a href="https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide">Union Find</a></li>
</ul>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth-First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Breadth-first search is used to traverse graphs level by level, and in this problem, each cell in the grid represents a node, with 4-directional connections as edges. In this context, each cell in the grid represents a node, and the horizontal and vertical connections between cells are the edges. The goal is to check if an island in <code>grid2</code> is a sub-island of <code>grid1</code>. We start BFS from each unvisited land cell in <code>grid2</code> and verify if all corresponding cells in <code>grid1</code> are also land cells. If we encounter a land cell in <code>grid2</code> where the corresponding cell in <code>grid1</code> is water, the island in <code>grid2</code> is not a sub-island.</p>
<p>We iterate through each cell in <code>grid2</code>, initiating BFS from each unvisited land cell to explore the island. During the traversal, we use a boolean flag <code>isSubIsland</code> to track if all corresponding cells in <code>grid1</code> are land. If the flag remains <code>true</code> after the traversal, we increment our sub-island count.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an array of <code>directions</code> storing the up, down, left, and right direction movements which is the change in the <code>(x, y)</code> position value of the cell while moving.</li>
<li>Create a helper method <code>isCellLand(x, y, grid)</code> which returns a boolean value indicating whether the cell at position <code>(x, y)</code> in <code>grid</code> is a land cell or not.</li>
<li>Create a helper method <code>isSubIsland(x, y, grid1, grid2, visited)</code> which returns a boolean value indicating whether the island of <code>grid2</code> containing cell at position <code>(x, y)</code> is a sub-island in <code>grid1</code> or not. This method will utilize the BFS algorithm to traverse all cells of the island of the <code>grid2</code>:
<ul>
<li>Initialize a variable <code>isSubIsland</code> to <code>true</code>, indicating whether the island of <code>grid2</code> is a sub-island or not.</li>
<li>Initialize a queue, push the starting cell <code>(x, y)</code> in queue and mark it as visited.</li>
<li>While the queue is not empty:
<ul>
<li>Pop the current cell from the queue.</li>
<li>If the cell in <code>grid1</code> at the same position as the current cell of <code>grid2</code> is not a land cell then this island can't be a sub-island so we will mark the <code>isSubIsland</code> flag as <code>false</code>.</li>
<li>Next, we move in all 4 directions one by one using the <code>directions</code> array. If the cell at the next position <code>(nextX, nextY)</code> lies inside the <code>grid2</code>, was not visited earlier, and is also a land cell, then we will traverse on this cell, hence, push it in the queue and mark it as visited.</li>
</ul>
</li>
<li>When we traverse all cells of the current island we return <code>isSubIsland</code>.</li>
</ul>
</li>
<li>Initialize a boolean <code>visited</code> matrix of the same size as the <code>grid2</code> matrix to mark visited land cells.</li>
<li>Initialize a variable <code>subIslandsCount</code> to <code>0</code>, to count the total number of islands in <code>grid2</code> which are also sub-islands.</li>
<li>Iterate on all cells of the <code>grid2</code> using nested for loop, if the current cell is never visited, is a land cell in <code>grid2</code>, and is a sub-island then increment the <code>subIslandsCount</code> by <code>1</code>.</li>
<li>At the end return, <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/mVB8kFHK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each grid cell and perform BFS to traverse all land cells of all the islands. Each land cell is only traversed once. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional grid <code>visited</code> of size <span class="math inline">\(m * n\)</span> and push the land cells in the queue.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Depth-first search (DFS) explores as far as possible along each branch before backtracking, making it effective for checking if an island in <code>grid2</code> is a sub-island of <code>grid1</code>.</p>
<p>We start by iterating through each cell in <code>grid2</code>. Upon encountering an unvisited land cell, we initiate a DFS to mark all connected land cells as visited. During the traversal, we compare each cell in <code>grid2</code> with the corresponding cell in <code>grid1</code>. If any land cell in <code>grid2</code> maps to a water cell in <code>grid1</code>, the island is disqualified. If the island passes the check, it is counted as a sub-island.</p>
<p>DFS is ideal for this task because it efficiently handles deep, recursive exploration, avoiding the need for additional data structures like a queue.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an array <code>directions</code> for the four movement directions: up, down, left, and right, representing changes in <code>(x, y)</code> coordinates.</li>
<li>Define a helper method <code>isCellLand(x, y, grid)</code> to check if the cell at <code>(x, y)</code> in <code>grid</code> is a land cell.</li>
<li>Define a helper method <code>isSubIsland(x, y, grid1, grid2, visited)</code> to determine if the island in <code>grid2</code> containing cell <code>(x, y)</code> is a sub-island of <code>grid1</code>. This method uses DFS to:
<ul>
<li>Initialize <code>isSubIsland</code> as <code>true</code>.</li>
<li>Check if the corresponding cell in <code>grid1</code> is land; if not, set <code>isSubIsland</code> to <code>false</code>.</li>
<li>Move in all four directions. For each valid, unvisited land cell in <code>grid2</code>, recursively check if it’s part of a sub-island and update <code>isSubIsland</code> accordingly.</li>
<li>Return <code>isSubIsland</code> after traversing the island.</li>
</ul>
</li>
<li>Initialize a boolean <code>visited</code> matrix of the same size as <code>grid2</code> to keep track of visited cells.</li>
<li>Initialize <code>subIslandsCount</code> to <code>0</code> to count sub-islands.</li>
<li>Iterate through all cells of <code>grid2</code>. For each unvisited land cell, use <code>isSubIsland</code> to check if it's a sub-island of <code>grid1</code>. Increment <code>subIslandsCount</code> if it is.</li>
<li>Return <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VSRKGot2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each grid cell and perform DFS to traverse all land cells of all the islands. Each land cell is only traversed once. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional grid <code>visited</code> of size <span class="math inline">\(m * n\)</span> and push the land cells in the recursive stack.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union-Find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Union-Find, or Disjoint Set Union (DSU), is a data structure that efficiently manages disjoint subsets, supporting quick union and find operations. It’s well-suited for problems where you need to determine if elements are in the same subset or to merge subsets. The key idea is to treat each island as a separate set and unite these sets based on connectivity.</p>
<p>In the context of this problem, we start by representing each land cell in both grids as a node in a graph. The main challenge is to determine whether an island in <code>grid2</code> is a sub-island of <code>grid1</code>, which means all cells of an island in <code>grid2</code> must also belong to the corresponding island in <code>grid1</code>. To implement this, we can follow these steps:</p>
<p>First, we initialize a Union-Find data structure where each cell initially belongs to its own set. As we iterate through the grid, we union adjacent land cells (cells with value <code>1</code>) in <code>grid2</code>. This results in a partitioning of the grid into distinct islands, where each island is represented by its parent node in the Union-Find structure.</p>
<p>After unionizing all possible cells within each grid, the next step is to compare the islands in <code>grid2</code> with the corresponding islands in <code>grid1</code>. As we discussed in the overview section, for each land cell in <code>grid2</code> there should be a corresponding land cell at the same position in <code>grid1</code> as well. If any land cell in an island of <code>grid2</code> does not have a corresponding land cell in <code>grid1</code>, the entire island containing that land cell is disqualified as a sub-island and we mark the parent cell of that island of <code>grid2</code> as not a sub-island.</p>
<p>Union-Find allows us to efficiently manage and compare these islands by providing quick union operations to group cells and find operations to identify the root of any given cell. Additionally, the process is optimized by two key techniques: path compression and union by rank. Path compression ensures that during the find operation, each node on the path to the root directly connects to the root, making future find operations faster. Union by rank helps to keep the tree representing each set shallow by always attaching the smaller tree under the root of the larger tree during union operations.</p>
<p>By the end of the process, the number of valid sub-islands can be determined by counting how many islands in <code>grid2</code> satisfy the condition of being entirely contained within the corresponding islands in <code>grid1</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create an array of <code>directions</code> storing the up, down, left, and right direction movements which is the change in the <code>(x, y)</code> position value of the cell while moving.</li>
<li>Create a helper method <code>isCellLand(x, y, grid)</code> which returns a boolean value indicating whether the cell at position <code>(x, y)</code> in <code>grid</code> is a land cell or not.</li>
<li>Create a class <code>UnionFind</code> which initialized two arrays <code>rank</code> and <code>parent</code> with size <code>n</code>. Initially rank of all elements is <code>0</code> and the parent is the element itself.
<ul>
<li>Create a method <code>int find(int u)</code>, which returns the <code>parent</code> of element <code>u</code> using the path compression technique.</li>
<li>Create a method <code>void unionSets(int u, int v)</code>, which joins two components of elements <code>u</code> and <code>v</code> into one based on their parent's ranks.</li>
</ul>
</li>
<li>Create a helper method <code>convertToIndex(int x, int y, int totalCols)</code> which converts and returns the 2-dimensional position to a 1-dimensional index.</li>
<li>Initialize a <code>UnionFind</code> object <code>uf</code> with size the same as <code>grid2</code>.</li>
<li>Iterate on all land cells of the <code>grid2</code> using nested for loop, and join the adjacent cells to the current land cell if they are also a land cell.</li>
<li>Initialize a boolean array <code>isSubIsland</code> with the size same as <code>grid2</code> initially storing <code>true</code>.</li>
<li>Iterate on all land cells of the <code>grid2</code> and if the respective cell in the <code>grid1</code> isn't a land cell then mark the <code>parent</code> node of the current land cell's island as <code>false</code> in the <code>isSubIsland</code> array.</li>
<li>Iterate on all land cells of the <code>grid2</code> and if <code>isSubIsland</code> for the parent cell is <code>true</code> count the sub-island, i.e. increment <code>subIslandsCount</code> by <code>1</code> and mark it as <code>false</code> to prevent counting it multiple times.</li>
<li>At the end return, <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/jhroFs5M/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each land cell of the grid and perform union operations with its adjacent cells. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional object <code>uf</code> and a boolean array <code>isSubIsland</code> of size <span class="math inline">\(m * n\)</span>.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-complete-components/description" target="_blank" rel="noopener noreferrer">Count the Number of Complete Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> vertices, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>Return <em>the number of <strong>complete connected components</strong> of the graph</em>.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>A connected component is said to be <b>complete</b> if there exists an edge between every pair of its vertices.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png" style="width: 671px; height: 270px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> From the picture above, one can see that all of the components of this graph are complete.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png" style="width: 671px; height: 270px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Before diving into the solution, let’s clarify what a <strong>complete connected component</strong> is. A complete connected component is a set of nodes and edges in a graph (also known as a subgraph) that satisfies the following conditions:</p>
<ul>
<li>It is <strong>connected</strong>, meaning every pair of vertices in the subgraph is reachable through some path, and no vertex connects to another component.</li>
<li>It is <strong>complete</strong>, meaning every vertex in the component has a direct edge to every other vertex. Notice that every complete subgraph is also a connected subgraph, but the reverse is not always true.</li>
</ul>
<p>In simpler terms, we are looking for connected subgraphs that form perfect <a href="https://en.wikipedia.org/wiki/Clique_(graph_theory)">cliques</a> - where each vertex is directly connected to all others within the component.</p>
<p><img src="../Figures/2685/subgraphs.png" alt="types of subgraph" /></p>
<blockquote>
<p>A strong grasp of fundamental graph algorithms like Depth-First Search, Breadth-First Search, and Disjoint Set Union is essential for understanding the solutions ahead. If you need a refresher or want to explore these concepts further, check out the <a href="https://leetcode.com/explore/learn/card/graph/">Graph Explore Card</a>. This resource provides an in-depth look at key graph algorithms, their applications, and a variety of problems to reinforce the underlying patterns.</p>
</blockquote>
<hr />
<h3 id="approach-1-adjacency-list">Approach 1: Adjacency List</h3>
<h4 id="intuition">Intuition</h4>
<p>The most common way to represent a graph is through an adjacency list, where each node points to a list of all the nodes it is directly connected to.</p>
<p>For example, consider a graph where vertices <code>0</code>, <code>1</code>, and <code>2</code> form a complete component. Their adjacency lists would look like this:</p>
<ul>
<li>Vertex <code>0</code>’s neighbors: <code>[1, 2]</code></li>
<li>Vertex <code>1</code>’s neighbors: <code>[0, 2]</code></li>
<li>Vertex <code>2</code>’s neighbors: <code>[0, 1]</code></li>
</ul>
<p>Now, let’s take a moment to include each vertex as its own neighbor. This does not violate any constraints since every node is naturally reachable from itself. After this adjustment, the adjacency lists would look like:</p>
<ul>
<li>Vertex <code>0</code>’s neighbors: <code>[0, 1, 2]</code></li>
<li>Vertex <code>1</code>’s neighbors: <code>[0, 1, 2]</code></li>
<li>Vertex <code>2</code>’s neighbors: <code>[0, 1, 2]</code></li>
</ul>
<p>This leads to a key insight: in a complete connected component, every vertex must have the exact same set of neighbors (including itself). This forms a unique &quot;adjacency pattern&quot; that is shared by all vertices in the same component.</p>
<p>Let us create the adjacency list for the graph and include each vertex as a neighbor in its own list. Now, we need to identify all vertices that share the same neighbor pattern.</p>
<p>To do this, we can use a hash map where the key represents a unique neighbor pattern, and the value keeps track of how many times this pattern appears in the graph. However, there may be cases where two neighbor patterns are the same but appear differently in the adjacency list (for example, <code>0: [0, 1, 2]</code> and <code>2: [2, 1, 0]</code>). To ensure they are grouped together, we first sort each neighbor list before adding it to the map.</p>
<p>Next, we go through each entry in the map to count how many unique patterns were collected. But one final check is needed: the size of the adjacency list must match the number of vertices that share this pattern. In other words, the size of the list should be equal to its frequency of occurrence in the map.</p>
<p>Why? Because in a complete component with <code>k</code> vertices, each vertex must have exactly <code>k</code> neighbors (including itself). And exactly <code>k</code> vertices must share this pattern - one for each member of the component.</p>
<p>Finally, we count the number of entries in the map that pass this validation and return this count as our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>an array of adjacency lists called <code>graph</code> with size <code>n</code>.</li>
<li>a hash map <code>componentFreq</code> to track frequencies of unique adjacency lists.</li>
</ul>
</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Initialize the adjacency list for the current vertex and add the vertex itself (self-loop).</li>
</ul>
</li>
<li>Build the graph by looping through each <code>edge = [u, v]</code> in the <code>edges</code> array:
<ul>
<li>Push <code>v</code> into <code>u</code>'s adjacency list (<code>graph[u]</code>).</li>
<li>Push <code>u</code> into <code>v</code>'s adjacency list (<code>graph[v]</code>).</li>
</ul>
</li>
<li>For each vertex from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Get and sort its list of neighbors.</li>
<li>Increment the frequency count for this specific adjacency pattern in the <code>componentFreq</code> map.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Iterate through each entry in the <code>componentFreq</code> map:
<ul>
<li>If the size of the adjacency list equals its frequency count, increment <code>completeCount</code>.</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/g4GoucsF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \log n)\)</span></p>
<p>The solution's time complexity stems from several operations. Initializing the adjacency lists requires <span class="math inline">\(O(n)\)</span> time as we create a list for each vertex. When building the adjacency lists from the edges, we spend <span class="math inline">\(O(m)\)</span> time adding each edge to the lists of both vertices it connects.</p>
<p>The most expensive operation comes when we sort each vertex's adjacency list, which costs <span class="math inline">\(O(d_i \log d_i)\)</span> for a vertex with degree <span class="math inline">\(d_i\)</span>. Across all vertices, this sorting accounts for <span class="math inline">\(O(\sum_{i=0}^{n-1} d_i \log d_i)\)</span> time. Since <span class="math inline">\(\sum d_i = 2m\)</span> and the maximum degree is bounded by <span class="math inline">\(n\)</span>, this simplifies to <span class="math inline">\(O(m \log n)\)</span> in the worst case. The final operations of processing vertices and counting complete components take <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is dominated by the sorting step, giving us <span class="math inline">\(O(n + m \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m + S)\)</span></p>
<p>For space complexity, we use memory for the adjacency list array itself, which requires <span class="math inline">\(O(n)\)</span> space. The contents of all adjacency lists collectively require space proportional to the number of edges, contributing <span class="math inline">\(O(m)\)</span> to our space usage.</p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span> .</li>
</ul>
<p>While the hash map stores references to these same adjacency lists, it doesn't significantly increase the asymptotic space complexity. Each unique component pattern may be stored once in the hash map, but the total size of all stored patterns remains bounded by the total size of all adjacency lists, which is <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m + S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-dfs">Approach 2: Depth-First Search (DFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's now return to traditional graph traversal techniques to solve this problem. Depth-first search (DFS) is particularly well-suited for this task. Starting from an unvisited vertex, DFS explores as far as possible along a branch before backtracking, ensuring that every vertex reachable from the starting point is visited.</p>
<p>But how do we determine if a component is complete? One approach is to check every pair of vertices in the component to see if they share an edge, but this would be inefficient.</p>
<p>Instead, we can take advantage of a key property of complete graphs: in a complete graph with <span class="math inline">\(n\)</span> vertices, there must be exactly <span class="math inline">\(\frac{n \cdot (n-1)}{2}\)</span> unique edges - equal to the number of pairs of nodes in the graph. Since our graph is undirected but our adjacency list counts each edge twice (once from each endpoint), the total edge count from the adjacency lists should be <span class="math inline">\(n \cdot (n-1)\)</span>.</p>
<p>During our DFS traversal, we will track two crucial pieces of information for each component:</p>
<ol>
<li>The number of vertices in the component.</li>
<li>The total number of edges connected to vertices in the component.</li>
</ol>
<p>For each new vertex we visit, we increment the vertex count and add all its edges to the total edge count. Once the traversal is complete, we check if the gathered values match the expected count. We keep track of all components that meet this condition, and after visiting all vertices, we return this count as our final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an array of adjacency lists called <code>graph</code> with size <code>n</code> to represent the undirected graph.</li>
<li>Build the graph by looping through each edge in the <code>edges</code> array:
<ul>
<li>Add each vertex to the other's adjacency list.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Create a hash set <code>visited</code> to keep track of visited vertices.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Skip if the <code>vertex</code> has already been visited.</li>
<li>Initialize an array <code>componentInfo</code> with two elements to track: <code>[0]</code>: number of vertices and <code>[1]</code>: total edges.</li>
<li>Call the <code>dfs</code> function starting from the current <code>vertex</code>.</li>
<li>Check if the component is complete by comparing the number of edges to <code>vertices * (vertices - 1)</code>.</li>
<li>Increment <code>completeCount</code> if the condition is met.</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<p>Helper method <code>dfs(curr, graph, visited, componentInfo)</code>:</p>
<ul>
<li>Mark the current vertex as visited.</li>
<li>Increment the vertex count in <code>componentInfo[0]</code>.</li>
<li>Add the number of edges from the current vertex to <code>componentInfo[1]</code>.</li>
<li>Recursively explore all unvisited neighbors of the current vertex.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/keZDcvFS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The algorithm begins with graph initialization, where populating the adjacency list by processing <span class="math inline">\(m\)</span> edges requires <span class="math inline">\(O(m)\)</span>, since each edge is added to two lists.</p>
<p>The core of the solution is a DFS traversal, which visits each vertex once and explores all edges connected to it. Since each edge is considered at most twice (once from each endpoint), DFS runs in <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Summing these components, the overall time complexity remains <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list representation requires <span class="math inline">\(O(n)\)</span> for the array and <span class="math inline">\(O(m)\)</span> for the edge storage. The <code>visited</code> set stores at most <span class="math inline">\(O(n)\)</span> vertices, while the recursive DFS calls can create a call stack of size <span class="math inline">\(O(n)\)</span> in the worst case. The <code>componentInfo</code> array uses constant space.</p>
<p>Combining these, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>, dominated by the graph representation and recursion stack.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-breadth-first-search-bfs">Approach 3: Breadth-First Search (BFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The other quintessential graph traversal algorithm is the Breadth-First Search (BFS), which can also be used to solve this problem.</p>
<p>BFS explores each component using a queue. We maintain a <code>visited</code> array to track which vertices have been visited. When we encounter an unvisited vertex, we add it to the queue and begin exploring its connected component.</p>
<p>Along with the queue, we maintain a list called <code>component</code> to store all vertices belonging to the current component. Once the exploration is complete, we need to verify whether the component is fully connected. For a component with <code>k</code> vertices to be complete, every vertex must have exactly <code>k - 1</code> edges connecting it to the other vertices within the component.</p>
<p>After finishing the BFS traversal for a component, we iterate through the gathered vertices in <code>component</code>. If the size of the component is <code>k</code> and each vertex has exactly <code>k - 1</code> edges, we confirm that it is a complete component and increment our count.</p>
<p>Once all vertices in the graph have been explored, we return this count as our final answer.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize an array of adjacency lists called <code>graph</code> with size <code>n</code> to represent the undirected graph.</li>
<li>Build the graph by looping through each edge in the <code>edges</code> array:
<ul>
<li>Add each vertex to the other's adjacency list.</li>
</ul>
</li>
<li>Create a boolean array <code>visited</code> of size <code>n</code> to track visited vertices.</li>
<li>Initialize a counter variable <code>completeComponents</code> to zero.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Skip if the <code>vertex</code> has already been visited.</li>
<li>Create a list called <code>component</code> to store vertices in the current component.</li>
<li>Initialize a <code>queue</code> and add the current vertex to it.</li>
<li>Mark the current <code>vertex</code> as visited.</li>
<li>Perform BFS:
<ul>
<li>Poll the next vertex from the queue.</li>
<li>Add it to the component list.</li>
<li>Process all unvisited neighbors by adding them to the queue and marking them as visited.</li>
</ul>
</li>
<li>After BFS completes, check if the component is complete:
<ul>
<li>Initialize <code>isComplete</code> as <code>true</code>.</li>
<li>For each <code>node</code> in the component:
<ul>
<li>Check if the number of its neighbors equals <code>component.size - 1</code>.</li>
<li>If not, set <code>isComplete</code> to <code>false</code> and break.</li>
</ul>
</li>
</ul>
</li>
<li>If the component is complete, increment <code>completeComponents</code>.</li>
</ul>
</li>
<li>Return the final value of <code>completeComponents</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RgcCySnK/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The solution first builds an adjacency list representation, which takes <span class="math inline">\(O(n)\)</span> time for initialization and <span class="math inline">\(O(m)\)</span> time to add all edges. Then, for each unvisited vertex, we perform a BFS traversal that visits each vertex and edge exactly once across all components, taking <span class="math inline">\(O(n + m)\)</span> time in total.</p>
<p>For each component found, we check if it's complete by examining the degree of each vertex in the component, which cumulatively takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list requires <span class="math inline">\(O(n + m)\)</span> space: <span class="math inline">\(O(n)\)</span> for the array of lists and <span class="math inline">\(O(m)\)</span> for storing all edges. The visited array requires <span class="math inline">\(O(n)\)</span> space. The queue used in BFS and the list to store component vertices can each contain at most <span class="math inline">\(O(n)\)</span> vertices.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-disjoint-set-union-union-find">Approach 4: Disjoint Set Union (Union-Find)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>A complete connected component has a distinct property: it is a disjoint unit of the graph, meaning it does not share any connections with other parts of the graph. Our task is to identify these disjoint units and check whether their vertices and edges meet the criteria for completeness and connectivity.</p>
<p>One of the most effective ways to find separate groups in a graph is by using the Union-Find algorithm (also known as Disjoint Set Union). This method helps group vertices that belong together. Each group has a representative vertex, known as the leader, which serves as the group's identifier. To determine whether two vertices belong to the same group, we simply check if they share the same leader.</p>
<p>In our Union-Find implementation, we also track the size of each component. Maintaining size is not only useful for optimizing the merging of components - since attaching a smaller component to a larger one is more efficient - but also plays a crucial role in this problem: it tells us exactly how many vertices exist in each component. To verify whether a component is a valid complete connected component, we check if its edge count matches <span class="math inline">\(\frac{k \cdot (k - 1)}{2}\)</span>, where <span class="math inline">\(k\)</span> is the number of vertices in the component.</p>
<p>Now, let’s implement our solution. First, we initialize a Union-Find structure and perform the &quot;union&quot; operation for each edge in our input. Since an edge signifies that two vertices belong to the same component, applying &quot;union&quot; to all edges ensures that all vertices are grouped correctly.</p>
<p>Next, we count the number of edges in each component. To do this, we use a hash map that associates each component with its edge count. Since Union-Find assigns each component a unique representative (the root of its tree), we use these representatives as keys in the map.</p>
<p>Finally, we iterate through each group leader and check if the group forms a complete component. A group is complete if its edge count equals <span class="math inline">\(\frac{k \cdot (k - 1)}{2}\)</span>. If it does, we increment our final count. Once all components have been processed, we return the total number of complete components as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Create a <code>UnionFind</code> data structure <code>dsu</code> to track connected components in the graph.</li>
<li>Initialize a hash map <code>edgeCount</code> to track the number of edges in each component.</li>
<li>Loop through each edge in the <code>edges</code> array:
<ul>
<li>Join the two vertices using the <code>union</code> operation.</li>
</ul>
</li>
<li>Loop through the <code>edges</code> again:
<ul>
<li>Find the root of the component containing the first vertex of each edge.</li>
<li>Increment the edge count for that component in the <code>edgeCount</code> map.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If the <code>vertex</code> is a root (representative) of its component:
<ul>
<li>Calculate the expected number of edges for a complete component with that many vertices: <code>(size[vertex] * (size[vertex] - 1)) / 2</code>.</li>
</ul>
</li>
<li>Compare the actual edge count with the expected edge count.
<ul>
<li>If they match, increment <code>completeCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<p>Helper class <code>UnionFind</code>:</p>
<ul>
<li>
<p>Initialize a <code>UnionFind</code> class with two instance variables:</p>
<ul>
<li>An array <code>parent</code> to track the parent of each node.</li>
<li>An array <code>size</code> to track the size of each component.</li>
</ul>
</li>
<li>
<p>In the constructor <code>dsu(n)</code>:</p>
<ul>
<li>Initialize both arrays with size <code>n</code>.</li>
<li>Fill the <code>parent</code> array with <code>-1</code> to indicate each node is its own parent initially.</li>
<li>Fill the <code>size</code> array with <code>1</code> as each node starts in its own single-node component.</li>
</ul>
</li>
<li>
<p>In the <code>find(node)</code> method:</p>
<ul>
<li>Check if the node's parent is <code>-1</code> (indicating it's a root).</li>
<li>If it is a root, return the <code>node</code> itself.</li>
<li>Otherwise, recursively find the root and update the <code>node</code>'s parent (path compression).</li>
</ul>
</li>
<li>
<p>In the <code>union(node1, node2)</code> method:</p>
<ul>
<li>Find the roots of nodes <code>node1</code> and <code>node2</code> using the <code>find</code> method.</li>
<li>If both nodes already belong to the same component (same root), return early.</li>
<li>Apply union-by-size strategy:
<ul>
<li>If the component containing <code>node1</code> is larger:
<ul>
<li>Make <code>root1</code> the parent of <code>root2</code>.</li>
<li>Add the size of <code>root2</code>'s component to <code>root1</code>'s component size.</li>
</ul>
</li>
<li>Otherwise, make <code>root2</code> the parent of <code>root1</code> and alter size accordingly.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/RYozofJc/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m\alpha(n))\)</span></p>
<p>The solution uses a Union-Find data structure with path compression and union by size. Building the Union-Find structure takes <span class="math inline">\(O(n)\)</span> time for initialization. Processing all edges through union operations takes <span class="math inline">\(O(m\alpha(n))\)</span> time, where <span class="math inline">\(\alpha(n)\)</span> is the inverse Ackermann function, which grows extremely slowly and is practically constant.</p>
<p>Counting edges in each component requires iterating through all edges again, taking <span class="math inline">\(O(m)\)</span> time. Finally, checking if each component is complete involves iterating through all vertices once, taking <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n + m\alpha(n))\)</span>, which is essentially linear in practice.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The Union-Find data structure uses two arrays of size <span class="math inline">\(n\)</span> for parent pointers and component sizes, requiring <span class="math inline">\(O(n)\)</span> space. The edge count map stores at most <span class="math inline">\(n\)</span> entries (one for each potential component root), requiring <span class="math inline">\(O(n)\)</span> space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-i/description" target="_blank" rel="noopener noreferrer">Count the Number of Houses at a Certain Distance I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three <strong>positive</strong> integers <code>n</code>, <code>x</code>, and <code>y</code>.</p>

<p>In a city, there exist houses numbered <code>1</code> to <code>n</code> connected by <code>n</code> streets. There is a street connecting the house numbered <code>i</code> with the house numbered <code>i + 1</code> for all <code>1 &lt;= i &lt;= n - 1</code> . An additional street connects the house numbered <code>x</code> with the house numbered <code>y</code>.</p>

<p>For each <code>k</code>, such that <code>1 &lt;= k &lt;= n</code>, you need to find the number of <strong>pairs of houses</strong> <code>(house<sub>1</sub>, house<sub>2</sub>)</code> such that the <strong>minimum</strong> number of streets that need to be traveled to reach <code>house<sub>2</sub></code> from <code>house<sub>1</sub></code> is <code>k</code>.</p>

<p>Return <em>a <strong>1-indexed</strong> array </em><code>result</code><em> of length </em><code>n</code><em> where </em><code>result[k]</code><em> represents the <strong>total</strong> number of pairs of houses such that the <strong>minimum</strong> streets required to reach one house from the other is </em><code>k</code>.</p>

<p><strong>Note</strong> that <code>x</code> and <code>y</code> can be <strong>equal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example2.png" style="width: 474px; height: 197px;" />
<pre>
<strong>Input:</strong> n = 3, x = 1, y = 3
<strong>Output:</strong> [6,0,0]
<strong>Explanation:</strong> Let&#39;s look at each pair of houses:
- For the pair (1, 2), we can go from house 1 to house 2 directly.
- For the pair (2, 1), we can go from house 2 to house 1 directly.
- For the pair (1, 3), we can go from house 1 to house 3 directly.
- For the pair (3, 1), we can go from house 3 to house 1 directly.
- For the pair (2, 3), we can go from house 2 to house 3 directly.
- For the pair (3, 2), we can go from house 3 to house 2 directly.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example3.png" style="width: 668px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 5, x = 2, y = 4
<strong>Output:</strong> [10,8,2,0,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).
- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).
- For k == 3, the pairs are (1, 5), and (5, 1).
- For k == 4 and k == 5, there are no pairs.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example5.png" style="width: 544px; height: 130px;" />
<pre>
<strong>Input:</strong> n = 4, x = 1, y = 1
<strong>Output:</strong> [6,4,2,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).
- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).
- For k == 3, the pairs are (1, 4), and (4, 1).
- For k == 4, there are no pairs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= x, y &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description" target="_blank" rel="noopener noreferrer">Count Unreachable Pairs of Nodes in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> nodes, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>Return <em>the <strong>number of pairs</strong> of different nodes that are <strong>unreachable</strong> from each other</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/05/tc-3.png" style="width: 267px; height: 169px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[0,2],[1,2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/05/tc-2.png" style="width: 295px; height: 269px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
<strong>Output:</strong> 14
<strong>Explanation:</strong> There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/couples-holding-hands/description" target="_blank" rel="noopener noreferrer">Couples Holding Hands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> couples sitting in <code>2n</code> seats arranged in a row and want to hold hands.</p>

<p>The people and seats are represented by an integer array <code>row</code> where <code>row[i]</code> is the ID of the person sitting in the <code>i<sup>th</sup></code> seat. The couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2n - 2, 2n - 1)</code>.</p>

<p>Return <em>the minimum number of swaps so that every couple is sitting side by side</em>. A swap consists of choosing any two people, then they stand up and switch seats.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> row = [0,2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We only need to swap the second (row[1]) and third (row[2]) person.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> row = [3,2,0,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All couples are already seated side by side.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2n == row.length</code></li>
	<li><code>2 &lt;= n &lt;= 30</code></li>
	<li><code>n</code> is even.</li>
	<li><code>0 &lt;= row[i] &lt; 2n</code></li>
	<li>All the elements of <code>row</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/course-schedule/1" target="_blank" rel="noopener noreferrer">Course Schedule</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are a total of <strong>n</strong> tasks you have to pick, labelled from <strong>0 to n-1</strong>. Some tasks may have <strong>prerequisites[][] </strong>tasks, for example to pick task <strong>0</strong> you have to first finish tasks <strong>1</strong>, which is expressed as a pair: <strong>[0, 1]</strong><br />Given the total number of <strong>n</strong> tasks and a list of prerequisite pairs of size <strong>m</strong>. Find a ordering of tasks you should pick to finish all tasks.</span><br /><span style="font-size: 18px;"><strong>Note: </strong>There may be multiple correct orders, you just need to return any one of them. If it is impossible to finish all tasks, return an empty array. </span><span style="font-size: 18px;">Returning any correct order will give the output as <strong>true</strong></span><span style="font-size: 18px;">, whereas any invalid order will give the output <strong>false</strong></span><span style="font-size: 18px;">.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, prerequisites[][] = [[1, 0]]
<strong>Output: </strong>true<strong>
Explanation: </strong></span><span style="font-size: 18px;">Only possible order is [0, 1].</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, prerequisites[][] = [[1, 0], [2, 0], [3, 1], [3, 2]]
<strong>Output: </strong>true<strong>
Explanation: </strong>There are a total of 4 tasks to pick. To pick task 3 you should have finished both tasks 1 and 2. Both tasks 1 and 2 should be pick after you finished task 0. So one correct task order is [0, 1, 2, 3]. Another correct ordering is [0, 2, 1, 3]. Returning any of these order will result in an output of true.</span>
</pre>
<div><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>5</sup></span>
<div><span style="font-size: 18px;">0 &le; prerequisites[i][0], prerequisites[i][1] &lt; n<br />All prerequisite pairs are unique</span></div>
<div><span style="font-size: 18px;">prerequisites[i][0] &ne; prerequisites[i][1]</span></div>
</div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule/description" target="_blank" rel="noopener noreferrer">Course Schedule</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>
	<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule-ii/description" target="_blank" rel="noopener noreferrer">Course Schedule II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
<strong>Output:</strong> [0,2,1,3]
<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 1, prerequisites = []
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule-iv/description" target="_blank" rel="noopener noreferrer">Course Schedule IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>a<sub>i</sub></code> first if you want to take course <code>b<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code> indicates that you have to take course <code>0</code> before you can take course <code>1</code>.</li>
</ul>

<p>Prerequisites can also be <strong>indirect</strong>. If course <code>a</code> is a prerequisite of course <code>b</code>, and course <code>b</code> is a prerequisite of course <code>c</code>, then course <code>a</code> is a prerequisite of course <code>c</code>.</p>

<p>You are also given an array <code>queries</code> where <code>queries[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>. For the <code>j<sup>th</sup></code> query, you should answer whether course <code>u<sub>j</sub></code> is a prerequisite of course <code>v<sub>j</sub></code> or not.</p>

<p>Return <i>a boolean array </i><code>answer</code><i>, where </i><code>answer[j]</code><i> is the answer to the </i><code>j<sup>th</sup></code><i> query.</i></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg" style="width: 222px; height: 62px;" />
<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
<strong>Output:</strong> [false,true]
<strong>Explanation:</strong> The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
<strong>Output:</strong> [false,false]
<strong>Explanation:</strong> There are no prerequisites, and each course is independent.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
<strong>Output:</strong> [true,true]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= numCourses &lt;= 100</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2)</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= numCourses - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>unique</strong>.</li>
	<li>The prerequisites graph has no cycles.</li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= numCourses - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed graph representing course dependencies. The graph consists of <code>numCourses</code> nodes (denoted as <code>N</code> for simplicity) and <code>E</code> directed edges, where each edge is represented as a pair <code>(u, v)</code>. An edge <code>(u, v)</code> indicates that course <code>u</code> is a prerequisite for course <code>v</code>.</p>
<p>Additionally, we are given <code>Q</code> queries. Each query is a pair <code>(u, v)</code>, and the goal is to determine if course <code>u</code> is a prerequisite for course <code>v</code>.  The answer to each query should be <code>true</code> if <code>u</code> is a prerequisite of <code>v</code>, and <code>false</code> otherwise.</p>
<hr />
<h3 id="approach-1-tree-traversal---on-demand">Approach 1: Tree Traversal - On Demand</h3>
<h4 id="intuition">Intuition</h4>
<p>We can simplify the problem by recognizing that the answer to the query <code>(u, v)</code> is <code>true</code> if there exists a path from node <code>u</code> to node <code>v</code>. This is because the edges are directed to represent dependencies, so if we can reach node <code>v</code> from node <code>u</code>, it indicates that node <code>u</code> is a prerequisite for node <code>v</code>.</p>
<p>This relationship is an example of <em>transitive closure</em>. For instance, consider a path with three nodes: <code>u -&gt; v -&gt; w</code>.  In this case:</p>
<ul>
<li>Node <code>u</code> is a prerequisite for node <code>v</code></li>
<li>Node <code>v</code> is a prerequisite for node <code>w</code>. By transitivity, we can conclude that node <code>u</code> is also a prerequisite for node <code>w</code>.</li>
</ul>
<p>Therefore, the problem reduces to determining whether there exists a path between two nodes. To solve this, we can use <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth-First Search (DFS)</a> to explore the graph. Alternatively, other traversal methods like <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth-First Search (BFS)</a> can also be used. In this approach, we begin at node <code>u</code> and explore its adjacent nodes recursively until we reach node <code>v</code>. If we find node <code>v</code> during the traversal, we return <code>true</code>. If we exhaust all possible paths without reaching node <code>v</code>, we return <code>false</code>.</p>
<p>To efficiently track visited nodes and prevent revisiting them, we maintain a <code>visited</code> array. This array is reset for each query to ensure that each DFS traversal starts with a clean slate, avoiding interference from previous queries.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Define a function <code>isPrerequisite</code> that takes the adjacency list of the graph, a <code>visited</code> array, and two nodes <code>src</code> and <code>target</code>, and returns whether a path exists from <code>src</code> to <code>target</code>:</p>
<ul>
<li>Mark the current node <code>src</code> as visited.</li>
<li>If <code>src</code> is the same as <code>target</code>, return <code>true</code> (we found the path).</li>
<li>For each neighboring node <code>adj</code> of <code>src</code>:
<ul>
<li>If <code>adj</code> has not been visited yet, recursively call the DFS to check if a path exists from <code>adj</code> to <code>target</code>.</li>
</ul>
</li>
<li>Return the <code>true</code> if the result of at least one recursive call is <code>true</code> and <code>false</code> otherwise.</li>
</ul>
</li>
<li>
<p>Create the adjacency list <code>adjList</code> using the prerequisite pairs <code>[u, v]</code>.</p>
</li>
<li>
<p>For each query <code>[u, v]</code>, check if there is a path from <code>u</code> to <code>v</code> using DFS:</p>
<ul>
<li>Initialize a visited array with all entries as <code>false</code></li>
<li>Call the i<code>sPrerequisite</code> function to check if there exists a path from <code>u</code> to <code>v</code>.</li>
<li>Store the result for each query in a result list <code>answer</code>.</li>
</ul>
</li>
<li>
<p>Return <code>answer</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/33jKrZ6q/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(Q \cdot N ^2)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> time as we need to iterate over the list <code>prerequisites</code>. Then we iterate over queries and for each we perform DFS that can take <span class="math inline">\(O(V + E)\)</span> which is equivalent to <span class="math inline">\(O(N^2)\)</span>. Hence, the total time complexity equals <span class="math inline">\(O(Q \cdot N ^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The adjacency list requires <span class="math inline">\(O(N^2)\)</span> as it stores every edge in the list <code>prerequisites</code>. For the DFS traversal, we need a visited array of size <span class="math inline">\(O(N)\)</span> and the recursive stack for DFS calls requires <span class="math inline">\(O(N)\)</span> space in the worsts case. Therefore, the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-tree-traversal---preprocessed">Approach 2: Tree Traversal - Preprocessed</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This approach is similar to the previous one, where we traverse the graph to determine if there is a path from node <code>u</code> to node <code>v</code>. However, the key difference here is that instead of performing DFS/BFS for each query, we precompute the reachability for all nodes. Specifically, for each node <code>i</code> in the range from <code>0</code> to <code>N - 1</code>, we perform BFS (can do DFS as well) to identify all nodes that can be reached from <code>i</code> and store this information in a 2D array <code>isPrerequisite</code>.</p>
<p>A value of <code>isPrerequisite[u][v] = true</code> indicates that node <code>u</code> is a prerequisite for node <code>v</code>. During the BFS, starting from node <code>i</code>, we mark all nodes <code>adj</code> in the path as <code>isPrerequisite[i][adj] = true</code>, signifying that <code>i</code> is a prerequisite for <code>adj</code>. In the BFS process, instead of using a separate visited array, we will just use an <code>isPrerequisite</code> array. This is because if <code>isPrerequisite[i][adj]</code> is <code>true</code>, then we can deduce that <code>adj</code> is already visited and skip it.</p>
<p>This method is particularly useful when the number of queries is much larger than the number of nodes. In contrast to the previous approach, where we performed DFS/BFS for each query, this method allows for constant-time query answers since the reachability information has already been preprocessed and stored.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Construct an adjacency list <code>adjList</code> from the prerequisites list where each course points to the courses that depend on it.</p>
</li>
<li>
<p>Preprocessing (BFS from each node):</p>
<ul>
<li>For each node<code> i</code> (from <code>0</code> to <code>N - 1</code>):
<ul>
<li>
<p>Start a BFS from <code>i</code> to explore all reachable nodes.</p>
</li>
<li>
<p>Repeat the following while the queue is not empty:</p>
<ul>
<li>Pop the front in the queue as <code>node</code>.</li>
<li>Iterate over the adjacent <code>node</code> and if the node <code>i</code> is not already marked as its prerequisite, mark it and add <code>node</code> to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For each query <code>[u, v]</code> return <code>isPrerequisite[u][v]</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ycdpa23U/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> requires <span class="math inline">\(O(N^2)\)</span> time, as we need to iterate over the <code>prerequisites</code> list. Next, we perform BFS starting from each of the <span class="math inline">\(N\)</span> nodes. Each BFS traversal takes <span class="math inline">\(O(N^2)\)</span> in the worst case, as the time complexity of BFS is <span class="math inline">\(O(V + E)\)</span>. Therefore, the total preprocessing is <span class="math inline">\(O(N \cdot N^2) = O(N^3)\)</span>.</p>
<p>To answer each query, we can retrieve results in constant time from a precomputed map, so answering all <span class="math inline">\(Q\)</span> queries takes <span class="math inline">\(O(Q)\)</span> time. Thus, the total time complexity will be <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The adjacency list takes <span class="math inline">\(O(N^2)\)</span> space as it will store every edge in the list <code>prerequisites</code>. For BFS, we need a 2D array <code>isPrerequisite</code> with size <span class="math inline">\(O(N^2)\)</span> to store the answer for every pair of nodes. The queue required for the BFS will take <span class="math inline">\(O(N)\)</span> size for each node, hence the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort---kahns-algorithm">Approach 3: Topological Sort - Kahn's Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We need to find a way to process nodes in the correct order, ensuring that each node is processed only after its dependencies are handled. This is where <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/">topological sorting</a> comes into play. Kahn’s algorithm is a great fit for this task because it respects the dependencies of each node, ensuring nodes are only visited once their prerequisites are completed.</p>
<blockquote>
<p>Topological sorting is an algorithm used in directed graphs to arrange nodes such that for every directed edge from node <code>u</code> to node <code>v</code>, node <code>u</code> comes before <code>v</code>. This is a natural approach when dealing with dependencies, like in project scheduling, task ordering, or handling prerequisites.</p>
</blockquote>
<p>Now, to adapt Kahn's algorithm to our needs, we need to keep track of a node’s prerequisites. Instead of just processing nodes in topological order, we'll modify the algorithm to maintain a list of dependencies for each node. As we move from node <code>u</code> to node <code>v</code>, we’ll add all of <code>u</code>'s prerequisites to <code>v</code>'s prerequisites. This is important because it computes the transitive closure, meaning we’re not just tracking immediate dependencies, but also indirect ones.</p>
<p>By the end of this process, each node will have a complete list of all nodes that must be visited before it. With this setup, when we need to answer a query <code>(u, v)</code>, all we have to do is check if <code>u</code> is in the list of prerequisites for <code>v</code>.</p>
<p>The general structure of Kahn’s algorithm stays the same. We start by calculating the indegree of each node, which tells us how many nodes depend on it. Nodes with an indegree of zero are independent and can be processed first, so we enqueue them. Then, using a queue, we dequeue nodes, process their neighbors, update the prerequisite lists, and enqueue any neighbors whose indegree drops to zero. This continues until we’ve processed all nodes, ensuring the correct order of traversal.</p>
<p>!?!../Documents/1462/1462_Course_Schedule_IV.json:960,720!?! <br></p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Create an adjacency list (<code>adjList</code>) to store the directed graph representing course dependencies.</p>
</li>
<li>
<p>Initialize an array (<code>indegree</code>) to track the number of prerequisites (in-degree) for each course.</p>
</li>
<li>
<p>Iterate over the prerequisites array to populate the adjacency list and update the indegree for each course.</p>
</li>
<li>
<p>Initialize a queue (<code>q</code>) to process courses with zero in-degree (no prerequisites).</p>
</li>
<li>
<p>While the queue is not empty:</p>
<ul>
<li>Dequeue a course (<code>node</code>).</li>
<li>For each adjacent course (<code>adj</code>) in the adjacency list of nodes, add the prerequisites of <code>node</code> to the list <code>nodePrerequisites[adj]</code>.</li>
<li>Decrement the in-degree of the node <code>adj</code>, and if the in-degree becomes zero, enqueue it for further processing.</li>
</ul>
</li>
<li>
<p>For each query <code>(u, v)</code>, check if course <code>u</code> is in the prerequisite list of course <code>v</code> by checking <code>nodePrerequisites[v]</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/76eFh22K/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> time as we need to iterate over the list <code>prerequisites</code>. The array <code>indegree</code>  will be of size <span class="math inline">\(O(N)\)</span>. In Kahn's algorithm, we iterate over each node and edge of the vertex which is <span class="math inline">\(O(N^2)\)</span> and for each edge traversed we will also add the prerequisites to the next node which is another <span class="math inline">\(O(N)\)</span>. To answer each query we need constant time to retrieve from the map and hence it's <span class="math inline">\(O(Q)\)</span> to answer all queries. Hence, the total time complexity equals <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>List <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> as it will store every edge in the list <code>prerequisites</code>. Array <code>indegree</code> will take <span class="math inline">\(O(N)\)</span> space and the queue for Kahn's algorithm will also be <span class="math inline">\(O(N)\)</span> size. Map <code>nodePrerequisites</code> will be from the node to its prerequisites and thus the total number of entries can be equal to <span class="math inline">\(O(N^2)\)</span>. Hence the total space complexity equals <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-floyd-warshall-algorithm">Approach 4: Floyd Warshall Algorithm</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In the first approach, we discussed the concept of transitive closure, which simplified the problem. The key insight was that the transitive closure allows us to determine if a path exists between two nodes, even indirectly. This concept is central to solving the All-Pairs Shortest Path (APSP) problem, for which the Floyd-Warshall algorithm is commonly used. This algorithm works by systematically considering every possible intermediate node and checking if a path between two nodes can be improved by going through that intermediate node. It then updates the shortest distance between the nodes.</p>
<p>For our problem, however, we don't need to calculate the shortest path, just whether a path exists. This leads us to a simple modification of the Floyd-Warshall algorithm: instead of keeping track of distances, we’ll use boolean values to represent whether a path exists between two nodes.</p>
<p>The main idea is to check if there’s a path from <code>src</code> to <code>target</code> by looking at all possible intermediate nodes. For each intermediate node, we check if there’s a path from <code>src</code> to that node and a path from that node to <code>target</code>. If both conditions hold, then we can confirm that a path exists between <code>src</code> and <code>target</code>. We then set <code>isPrerequisite[src][target]</code> to <code>true</code>.</p>
<p>At the end of this process, we’ll have a 2D array, <code>isPrerequisite</code>, where each entry <code>isPrerequisite[u][v]</code> tells us whether <code>u</code> is a prerequisite for <code>v</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Initialize a 2D boolean array <code>isPrerequisite</code> of size <code>numCourses x numCourses</code> to track direct prerequisite relationships between courses.</p>
</li>
<li>
<p>Populate the <code>isPrerequisite</code> matrix based on the <code>prerequisites</code>:</p>
</li>
</ol>
<ul>
<li>For each pair in <code>prerequisites</code>, mark <code>isPrerequisite[edge[0]][edge[1]]</code> as <code>true</code> to indicate that <code>edge[0]</code> is a prerequisite for <code>edge[1]</code>.</li>
</ul>
<ol start="3">
<li>Compute transitive closure of the prerequisite relationships using the Floyd-Warshall algorithm:</li>
</ol>
<ul>
<li>For each possible intermediate course <code>intermediate</code>:
<ul>
<li>For each source course <code>src</code>:
<ul>
<li>For each target course <code>target</code>:
<ul>
<li>Update <code>isPrerequisite[src][target]</code> to include indirect relationships:
<ul>
<li>If <code>src</code> can reach <code>intermediate</code> and <code>intermediate</code> can reach <code>target</code>, then <code>src</code> can reach <code>target</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<p>Initialize an empty list <code>answer</code> to store the results of the queries.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
</li>
</ol>
<ul>
<li>Add the value of <code>isPrerequisite[query[0]][query[1]]</code> to the <code>answer</code> list, indicating whether <code>query[0]</code> is a prerequisite for <code>query[1]</code>.</li>
</ul>
<ol start="6">
<li>Return the <code>answer</code> list containing the results for all queries.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/LU6eyzQL/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>We iterate over each node in three nested loops, so this step takes <span class="math inline">\(O(N^3)\)</span>. To answer each query we need constant time to retrieve from the map and hence it's <span class="math inline">\(O(Q)\)</span> to answer all queries. Hence, the total time complexity equals <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>We need a 2D array <code>isPrerequisite</code> with size <span class="math inline">\(O(N^2)\)</span> to store the answer for every pair of nodes, hence the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cousins-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Cousins in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree with unique values and the values of two different nodes of the tree <code>x</code> and <code>y</code>, return <code>true</code> <em>if the nodes corresponding to the values </em><code>x</code><em> and </em><code>y</code><em> in the tree are <strong>cousins</strong>, or </em><code>false</code><em> otherwise.</em></p>

<p>Two nodes of a binary tree are <strong>cousins</strong> if they have the same depth with different parents.</p>

<p>Note that in a binary tree, the root node is at the depth <code>0</code>, and children of each depth <code>k</code> node are at the depth <code>k + 1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png" style="width: 304px; height: 270px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4], x = 4, y = 3
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png" style="width: 334px; height: 266px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4,null,5], x = 5, y = 4
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png" style="width: 267px; height: 258px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4], x = 2, y = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li>Each node has a <strong>unique</strong> value.</li>
	<li><code>x != y</code></li>
	<li><code>x</code> and <code>y</code> are exist in the tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cousins-in-binary-tree-ii/description" target="_blank" rel="noopener noreferrer">Cousins in Binary Tree II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, replace the value of each node in the tree with the <strong>sum of all its cousins&#39; values</strong>.</p>

<p>Two nodes of a binary tree are <strong>cousins</strong> if they have the same depth with different parents.</p>

<p>Return <em>the </em><code>root</code><em> of the modified tree</em>.</p>

<p><strong>Note</strong> that the depth of a node is the number of edges in the path from the root node to it.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/11/example11.png" style="width: 571px; height: 151px;" />
<pre>
<strong>Input:</strong> root = [5,4,9,1,10,null,7]
<strong>Output:</strong> [0,0,0,7,7,null,11]
<strong>Explanation:</strong> The diagram above shows the initial binary tree and the binary tree after changing the value of each node.
- Node with value 5 does not have any cousins so its sum is 0.
- Node with value 4 does not have any cousins so its sum is 0.
- Node with value 9 does not have any cousins so its sum is 0.
- Node with value 1 has a cousin with value 7 so its sum is 7.
- Node with value 10 has a cousin with value 7 so its sum is 7.
- Node with value 7 has cousins with values 1 and 10 so its sum is 11.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/11/diagram33.png" style="width: 481px; height: 91px;" />
<pre>
<strong>Input:</strong> root = [3,1,2]
<strong>Output:</strong> [0,0,0]
<strong>Explanation:</strong> The diagram above shows the initial binary tree and the binary tree after changing the value of each node.
- Node with value 3 does not have any cousins so its sum is 0.
- Node with value 1 does not have any cousins so its sum is 0.
- Node with value 2 does not have any cousins so its sum is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-two-pass-bfs">Approach 1: Two Pass BFS</h3>
<h4 id="intuition">Intuition</h4>
<p>Cousins are nodes that share the same depth but have different parents. This means that to find the sum of a node’s cousins, we first need to know the total sum of all nodes at the same depth. If we subtract the sum of a node and its siblings from this total, we’re left with the sum of its cousins.</p>
<p><img src="../Figures/2641/2641_cousins_II.png" alt="2641_cousins_II" /></p>
<p>With this thought in mind, we break down the solution into two parts. First, we perform a BFS traversal to calculate the sum of all nodes at each level. In BFS, we explore each level independently, which lets us sum the node values for each level as we go. We store these sums in an array, <code>levelSums</code>, so each level’s total is recorded and ready for the next part.</p>
<p>In the second part, we go through the tree again with another BFS traversal. Now, as we visit each node, we use the <code>levelSums</code> array recorded earlier. For each node, we subtract the value of itself and its sibling from the corresponding <code>levelSums</code> entry. The remaining sum is the cousin sum, which we then assign to the current node.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>If the <code>root</code> is null, return <code>root</code>.</p>
</li>
<li>
<p>Initialize a queue <code>nodeQueue</code> and push <code>root</code> into it.</p>
</li>
<li>
<p>Create an array <code>levelSums</code> to store the sum of node values at each level.</p>
</li>
<li>
<p>First BFS traversal to calculate the sum of nodes at each level:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Initialize <code>levelSum</code> to <code>0</code> for the current level.</li>
<li>Get the number of nodes at the current level (<code>levelSize</code>).</li>
<li>For each node at this level:
<ul>
<li>Pop the front node from the queue and add its value to <code>levelSum</code>.</li>
<li>If the node has a left child, push it to the queue.</li>
<li>If the node has a right child, push it to the queue.</li>
</ul>
</li>
<li>After processing all nodes at the level, append <code>levelSum</code> to <code>levelSums</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Second BFS traversal to update each node's value to the sum of its cousins:</p>
<ul>
<li>
<p>Push <code>root</code> back into the queue.</p>
</li>
<li>
<p>Set <code>root.val</code> to <code>0</code> since it has no cousins.</p>
</li>
<li>
<p>Initialize <code>levelIndex</code> to <code>1</code>.</p>
</li>
<li>
<p>While the queue is not empty:</p>
<ul>
<li>Get the number of nodes at the current level (<code>levelSize</code>).</li>
<li>For each node at this level:
<ul>
<li>Pop the front node from the queue.</li>
<li>Calculate <code>siblingSum</code> by adding the values of the left and right children (if they exist).</li>
<li>If the left child exists, update its value to <code>levelSums[levelIndex] - siblingSum</code> and push it to the queue.</li>
<li>If the right child exists, update its value similarly and push it to the queue.</li>
</ul>
</li>
<li>Increment <code>levelIndex</code> after processing the current level.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the modified <code>root</code> of the tree.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/m8rZC574/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the first BFS, we traverse each node in the tree once to calculate the sum of values at each level. This requires visiting each of the <span class="math inline">\(n\)</span> nodes, leading to a time complexity of <span class="math inline">\(O(n)\)</span>. Similarly, the second BFS traverses each node to update its value based on the sums of its cousins, which also takes <span class="math inline">\(O(n)\)</span> time. Thus, the overall time complexity is <span class="math inline">\(O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity primarily comes from the queue used in the BFS and the array that stores the level sums. The maximum size of the queue will be the maximum width of the tree, which in the worst case (for a complete binary tree) can be <span class="math inline">\(O(n)\)</span>. Additionally, the <code>levelSums</code> array will store one integer for each level of the tree. In a balanced binary tree, the height is <span class="math inline">\(O(\log n)\)</span>, leading to <span class="math inline">\(O(\log n)\)</span> levels. However, in the worst case, we can have <span class="math inline">\(O(n)\)</span> elements in <code>levelSums</code> when considering unbalanced trees (e.g., all nodes have only one child). Thus, the overall space complexity can be represented as <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pass-dfs">Approach 2: Two Pass DFS</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can apply the same approach in DFS as we did in BFS. We begin with a DFS traversal to calculate the sum of the values of all nodes at each depth level. We define an array called <code>levelSums</code>, where each index corresponds to a specific level in the tree. As we traverse, we add each node's value to the appropriate index in <code>levelSums</code>.</p>
<p>Next, we proceed with the second DFS traversal to update each node's values. In this traversal, we calculate each node's left and right children’s values, defaulting to zero if they are absent. If the node is at the root level or the first level, we set its value to zero since these nodes do not have cousins.</p>
<p>For deeper nodes, we compute their new value as the sum from <code>levelSums</code> at their level, subtracting their current value and the sum of their siblings.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Declare an array <code>levelSums</code> to store the sum of values at each level of the tree.</p>
</li>
<li>
<p>Define the <code>replaceValueInTree</code> function:</p>
<ul>
<li>Call <code>calculateLevelSum(root, 0)</code> to perform a depth-first search (DFS) and calculate the sum of values at each level.</li>
<li>Call <code>replaceValueInTreeInternal(root, 0, 0)</code> to replace each node's value with the sum of its cousins.</li>
<li>Return the modified tree root.</li>
</ul>
</li>
<li>
<p>Define the <code>calculateLevelSum</code> function:</p>
<ul>
<li>If <code>node</code> is <code>null</code>, return (base case).</li>
<li>Add the value of <code>node</code> to <code>levelSums[level]</code> (accumulate the sum at the current level).</li>
<li>Recursively call <code>calculateLevelSum</code> for the left child, increasing the level by 1.</li>
<li>Recursively call <code>calculateLevelSum</code> for the right child, increasing the level by 1.</li>
</ul>
</li>
<li>
<p>Define the <code>replaceValueInTreeInternal</code> function:</p>
<ul>
<li>
<p>If <code>node</code> is <code>null</code>, return (base case).</p>
</li>
<li>
<p>Determine the values of the left and right children:</p>
<ul>
<li>If <code>node.left</code> is <code>null</code>, set <code>leftChildVal</code> to 0; otherwise, set it to <code>node.left.val</code>.</li>
<li>If <code>node.right</code> is <code>null</code>, set <code>rightChildVal</code> to 0; otherwise, set it to <code>node.right.val</code>.</li>
</ul>
</li>
<li>
<p>For the root and its children (level 0 and level 1):</p>
<ul>
<li>Set <code>node.val</code> to 0.</li>
</ul>
</li>
<li>
<p>For other levels:</p>
<ul>
<li>Set <code>node.val</code> to <code>levelSums[level] - node.val - siblingSum</code> (sum of cousins).</li>
</ul>
</li>
<li>
<p>Recursively call <code>replaceValueInTreeInternal</code> for the left child, passing the right child's value as the sibling sum and increasing the level by 1.</p>
</li>
<li>
<p>Recursively call <code>replaceValueInTreeInternal</code> for the right child, passing the left child's value as the sibling sum and increasing the level by 1.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/g5KmjUxf/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the first DFS traversal, we visit each node exactly once to compute the sum of values at each level. Thus, this part has a time complexity of <span class="math inline">\(O(n)\)</span>. In the second DFS, we again traverse each node exactly once to update the values based on the previously computed sums. Therefore, this part also has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The maximum depth of the recursion stack will be equal to the height of the tree, which is <span class="math inline">\(O(h)\)</span>. In a balanced binary tree, <span class="math inline">\(h\)</span> is <span class="math inline">\(O(\log n)\)</span>, while in the worst case (for a skewed tree), <span class="math inline">\(h\)</span> can be <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>levelSums</code> array is determined by the maximum number of levels in the tree, which can be at most <span class="math inline">\(n\)</span>. Thus, the overall space complexity can be represented as <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-single-bfs-with-running-sum">Approach 3: Single BFS with Running Sum</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can aim to reduce our two-step process into a single traversal. So the question is: can we calculate the level sums and update the nodes’ values simultaneously? With some adjustments, it’s possible. Instead of storing each level’s sum first and revisiting it later, we calculate the cousin sum as we traverse each level and apply it immediately.</p>
<p>We begin by initializing a variable called <code>currentLevelSum</code>. This variable holds the total value of all nodes at the current level. We set <code>currentLevelSum</code> to the root value value since it is the only node at level zero.</p>
<p>We traverse the tree level-by-level to visit each node and apply a formula to determine its new value. The formula is:</p>
<p><span class="math inline">\(\text{currentNode.val} = \text{currentLevelSum} - \text{siblingSum}\)</span></p>
<p>The formula subtracts the sum of each node's siblings from <code>currentLevelSum</code> to give us the sum of all other nodes at that level, which is effectively the sum of its cousins.</p>
<p>While processing each node, we also need to prepare for the next level. For each child of the current node, we calculate their contribution to the sibling sum of their level. This ensures that when we update the children's values in the next iteration, we have the correct sibling sum to use. We then add these children to a queue to process them in the next level and continue till we process the entire tree.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>If <code>root</code> is null, return <code>root</code> (base case).</p>
</li>
<li>
<p>Initialize a queue <code>nodeQueue</code> and add the <code>root</code> node to it.</p>
</li>
<li>
<p>Set <code>currentLevelSum</code> to the value of <code>root</code>.</p>
</li>
<li>
<p>While the queue is not empty:</p>
<ul>
<li>
<p>Determine the number of nodes at the current level with <code>levelSize = nodeQueue.size()</code>.</p>
</li>
<li>
<p>Initialize <code>nextLevelSum</code> to <code>0</code> for accumulating the sum of the next level.</p>
</li>
<li>
<p>For each node in the current level (loop <code>levelSize</code> times):</p>
<ul>
<li>
<p>Remove the front node from the queue and assign it to <code>currentNode</code>.</p>
</li>
<li>
<p>Update <code>currentNode.val</code> to <code>currentLevelSum - currentNode.val</code> (replace its value with the cousin sum).</p>
</li>
<li>
<p>Calculate the <code>siblingSum</code> as the sum of the values of <code>currentNode</code>'s left and right children (if they exist):</p>
<ul>
<li>If <code>currentNode.left</code> is not null, add its value to <code>nextLevelSum</code> and update <code>currentNode.left.val</code> to <code>siblingSum</code>, then enqueue <code>currentNode.left</code>.</li>
<li>If <code>currentNode.right</code> is not null, add its value to <code>nextLevelSum</code> and update <code>currentNode.right.val</code> to <code>siblingSum</code>, then enqueue <code>currentNode.right</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Update <code>currentLevelSum</code> to <code>nextLevelSum</code> for the next iteration.</p>
</li>
</ul>
</li>
<li>
<p>After processing all levels, return the modified <code>root</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/dnB3neCy/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse each node in the binary tree exactly once. During the traversal, we perform constant-time operations to update the node values and calculate sibling sums. Since there are <span class="math inline">\(n\)</span> nodes in total, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is primarily determined by the queue used in the BFS. In the worst case, when the tree is completely unbalanced (like a linked list), the queue can grow to hold all <span class="math inline">\(n\)</span> nodes at once, leading to a space complexity of <span class="math inline">\(O(n)\)</span>. While there are no additional data structures like arrays that grow with the number of nodes, the queue remains the primary contributor to space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/covid-spread--141631/1" target="_blank" rel="noopener noreferrer">Covid Spread</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Aterp is the head nurse at a city hospital. City hospital contains R*C&nbsp;number of wards and the structure of a hospital is in the form of a 2-D matrix.<br />Given a matrix of dimension <strong>R</strong>*<strong>C</strong> where each cell in the matrix can have values 0, 1, or 2 which has the following meaning:<br /><strong>0</strong>: Empty ward<br /><strong>1</strong>: Cells have uninfected patients<br /><strong>2</strong>: Cells have infected patients</p>
<p>An infected patient at ward [i,j] can infect other uninfected patient at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (<strong>up</strong>, <strong>down</strong>, <strong>left</strong> and <strong>right</strong>) in unit time. Help Aterp&nbsp;determine the minimum units of time after which there won't remain any uninfected patient i.e all patients would be infected.&nbsp;If all patients are not infected after infinite units of time then simply return -1.</p>
<p>&nbsp;</p>
<p><br /><strong>Example 1:</strong></p>
<pre><strong>Input:</strong>
3 5
2 1 0 2 1
1 0 1 2 1
1 0 0 2 1 
<strong>Output:</strong>
2
<strong>Explanation:
</strong>Patients at positions {0,0}, {0, 3}, {1, 3}
and {2, 3} will infect patient at {0, 1}, 
{1, 0},{0, 4}, {1, 2}, {1, 4}, {2, 4} during 1st 
unit time. And, during 2nd unit time, patient at 
{1, 0} will get infected and will infect patient 
at {2, 0}. Hence, total 2 unit of time is
required to infect all patients.</pre>
<p><strong>Example 2:</strong></p>
<pre><strong>Input:</strong>
3 5
2 1 0 2 1
0 0 1 2 1
1 0 0 2 1
<strong>Output:</strong>
-1
<strong>Explanation:</strong>
All patients will not be infected.</pre>
<p>&nbsp;</p>
<p><strong>Your Task:</strong>&nbsp;&nbsp;<br />You don't need to read input or print anything. Your task is to complete the function <strong>helpaterp</strong>()&nbsp;which takes a 2-D Matrix <strong>hospital&nbsp;</strong>as input parameter&nbsp;and returns the minimum units of time in which all patients will be infected or -1 if it is impossible.</p>
<p><br /><strong>Constraints:</strong><br />1 &le; R,C&nbsp;&le; 1000<br />0 &le; mat[i][j]&nbsp;&le; 2</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cut-off-trees-for-golf-event/description" target="_blank" rel="noopener noreferrer">Cut Off Trees for Golf Event</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an <code>m x n</code> matrix. In this matrix:</p>

<ul>
	<li><code>0</code> means the cell cannot be walked through.</li>
	<li><code>1</code> represents an empty cell that can be walked through.</li>
	<li>A number greater than <code>1</code> represents a tree in a cell that can be walked through, and this number is the tree&#39;s height.</li>
</ul>

<p>In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.</p>

<p>You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes <code>1</code> (an empty cell).</p>

<p>Starting from the point <code>(0, 0)</code>, return <em>the minimum steps you need to walk to cut off all the trees</em>. If you cannot cut off all the trees, return <code>-1</code>.</p>

<p><strong>Note:</strong> The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> forest = [[1,2,3],[0,0,4],[7,6,5]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> forest = [[1,2,3],[0,0,0],[7,6,5]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The trees in the bottom row cannot be accessed as the middle row is blocked.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> forest = [[2,3,4],[0,0,5],[8,7,6]]
<strong>Output:</strong> 6
<b>Explanation:</b> You can follow the same path as Example 1 to cut off all the trees.
Note that you can cut off the first tree at (0, 0) before making any steps.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == forest.length</code></li>
	<li><code>n == forest[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>0 &lt;= forest[i][j] &lt;= 10<sup>9</sup></code></li>
	<li>Heights of all trees are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-framework">Approach Framework</h3>
<p><strong>Explanation</strong></p>
<p>Starting from <code>(0, 0)</code>, for each tree in height order, we will calculate the distance from where we are to the next tree (and move there), adding that distance to the answer.</p>
<p>We frame the problem as providing some distance function <code>dist(forest, sr, sc, tr, tc)</code> that calculates the path distance from source <code>(sr, sc)</code> to target <code>(tr, tc)</code> through obstacles <code>dist[i][j] == 0</code>. (This distance function will return <code>-1</code> if the path is impossible.)</p>
<p>What follows is code and complexity analysis that is common to all three approaches. After, the algorithms presented in our approaches will focus on only providing our <code>dist</code> function.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">cutOffTree</span>(<span style="color:#999">self</span>, forest):
</span></span><span style="display:flex;"><span>        trees <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">sorted</span>((v, r, c) <span style="color:#000;font-weight:bold">for</span> r, row <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(forest)
</span></span><span style="display:flex;"><span>                       <span style="color:#000;font-weight:bold">for</span> c, v <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(row) <span style="color:#000;font-weight:bold">if</span> v <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>        sr <span style="color:#000;font-weight:bold">=</span> sc <span style="color:#000;font-weight:bold">=</span> ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> _, tr, tc <span style="color:#000;font-weight:bold">in</span> trees:
</span></span><span style="display:flex;"><span>            d <span style="color:#000;font-weight:bold">=</span> dist(forest, sr, sc, tr, tc)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> d <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">0</span>: <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>            ans <span style="color:#000;font-weight:bold">+=</span> d
</span></span><span style="display:flex;"><span>            sr, sc <span style="color:#000;font-weight:bold">=</span> tr, tc
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> dr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">{-</span>1<span style="color:#000;font-weight:bold">,</span> 1<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> dc <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">{</span>0<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">,</span> 1<span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">cutOffTree</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> trees <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> ArrayList<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> r <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> r <span style="color:#000;font-weight:bold">&lt;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#000;font-weight:bold">++</span>r<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> c <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> c <span style="color:#000;font-weight:bold">&lt;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#000;font-weight:bold">++</span>c<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> v <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>c<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>v <span style="color:#000;font-weight:bold">&gt;</span> 1<span style="color:#000;font-weight:bold">)</span> trees<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>v<span style="color:#000;font-weight:bold">,</span> r<span style="color:#000;font-weight:bold">,</span> c<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Collections<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">sort</span><span style="color:#000;font-weight:bold">(</span>trees<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">,</span> b<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">-&gt;</span> Integer<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">compare</span><span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">],</span> b<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> sr <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> sc <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> tree<span style="color:#000;font-weight:bold">:</span> trees<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> d <span style="color:#000;font-weight:bold">=</span> dist<span style="color:#000;font-weight:bold">(</span>forest<span style="color:#000;font-weight:bold">,</span> sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">,</span> tree<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">],</span> tree<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">]);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>d <span style="color:#000;font-weight:bold">&lt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            ans <span style="color:#000;font-weight:bold">+=</span> d<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            sr <span style="color:#000;font-weight:bold">=</span> tree<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">];</span> sc <span style="color:#000;font-weight:bold">=</span> tree<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<p>All three algorithms have similar worst-case complexities, but in practice, each successive algorithm presented performs faster on random data.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((RC)^2)\)</span> where there are <span class="math inline">\(R\)</span> rows and <span class="math inline">\(C\)</span> columns in the given <code>forest</code>. We walk to <span class="math inline">\(R*C\)</span> trees, and each walk could spend <span class="math inline">\(O(R*C)\)</span> time searching for the tree.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(R*C)\)</span>, the maximum size of the data structures used.</p>
</li>
</ul>
<hr />
<h3 id="approach-1-bfs-accepted">Approach #1: BFS [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We perform a breadth-first-search, processing nodes (grid positions) in a queue. <code>seen</code> keeps track of nodes that have already been added to the queue at some point - those nodes will be already processed or are in the queue awaiting processing.</p>
<p>For each node next to be processed, we look at its neighbors. If they are in the forest (grid), they haven't been enqueued, and they aren't an obstacle, we will enqueue that neighbor.</p>
<p>We also keep a side count of the distance traveled for each node. If the node we are processing is our destination 'target' <code>(tr, tc)</code>, we'll return the answer.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">bfs</span>(forest, sr, sc, tr, tc):
</span></span><span style="display:flex;"><span>    R, C <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(forest), <span style="color:#0086b3">len</span>(forest[<span style="color:#099">0</span>])
</span></span><span style="display:flex;"><span>    queue <span style="color:#000;font-weight:bold">=</span> collections<span style="color:#000;font-weight:bold">.</span>deque([(sr, sc, <span style="color:#099">0</span>)])
</span></span><span style="display:flex;"><span>    seen <span style="color:#000;font-weight:bold">=</span> {(sr, sc)}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> queue:
</span></span><span style="display:flex;"><span>        r, c, d <span style="color:#000;font-weight:bold">=</span> queue<span style="color:#000;font-weight:bold">.</span>popleft()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">and</span> c <span style="color:#000;font-weight:bold">==</span> tc:
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> d
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> nr, nc <span style="color:#000;font-weight:bold">in</span> ((r<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, c), (r<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, c), (r, c<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>), (r, c<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>)):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">and</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">and</span>
</span></span><span style="display:flex;"><span>                    (nr, nc) <span style="color:#000;font-weight:bold">not</span> <span style="color:#000;font-weight:bold">in</span> seen <span style="color:#000;font-weight:bold">and</span> forest[nr][nc]):
</span></span><span style="display:flex;"><span>                seen<span style="color:#000;font-weight:bold">.</span>add((nr, nc))
</span></span><span style="display:flex;"><span>                queue<span style="color:#000;font-weight:bold">.</span>append((nr, nc, d<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">bfs</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sc<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> R <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">(),</span> C <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    Queue<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> queue <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> LinkedList<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">boolean</span><span style="color:#000;font-weight:bold">[][]</span> seen <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">boolean</span><span style="color:#000;font-weight:bold">[</span>R<span style="color:#000;font-weight:bold">][</span>C<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>    seen<span style="color:#000;font-weight:bold">[</span>sr<span style="color:#000;font-weight:bold">][</span>sc<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(!</span>queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">isEmpty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> cur <span style="color:#000;font-weight:bold">=</span> queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">poll</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>cur<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">&amp;&amp;</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">return</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> di <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> di <span style="color:#000;font-weight:bold">&lt;</span> 4<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>di<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> r <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">+</span> dr<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> c <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">+</span> dc<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>0 <span style="color:#000;font-weight:bold">&lt;=</span> r <span style="color:#000;font-weight:bold">&amp;&amp;</span> r <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">&amp;&amp;</span> 0 <span style="color:#000;font-weight:bold">&lt;=</span> c <span style="color:#000;font-weight:bold">&amp;&amp;</span> c <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">!</span>seen<span style="color:#000;font-weight:bold">[</span>r<span style="color:#000;font-weight:bold">][</span>c<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>c<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&gt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                seen<span style="color:#000;font-weight:bold">[</span>r<span style="color:#000;font-weight:bold">][</span>c<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>r<span style="color:#000;font-weight:bold">,</span> c<span style="color:#000;font-weight:bold">,</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">]+</span>1<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><hr />
<h3 id="approach-2-a-search-accepted">Approach #2: A* Search [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>The A* star algorithm is another path-finding algorithm.  For every node at position <code>(r, c)</code>, we have some estimated cost <code>node.f = node.g + node.h</code>, where <code>node.g</code> is the actual distance from <code>(sr, sc)</code> to <code>(r, c)</code>, and <code>node.h</code> is our <em>heuristic</em> (guess) of the distance from <code>(r, c)</code> to <code>(tr, tc)</code>.  In this case, our guess will be the taxicab distance, <code>node.h = abs(r-tr) + abs(c-tc)</code>.</p>
<p>We keep a priority queue to decide what node to search in (<em>expand</em>) next. We can prove that if we find the target node, we must have traveled the lowest possible distance <code>node.g</code>. By considering the last time when two backward paths are the same, without loss of generality we could suppose the penultimate square of the two paths are different, and then in this case <code>node.f = node.g + 1</code>, showing the path with less actual distance travelled is expanded first as desired.</p>
<p>It might be useful for solvers familiar with <em>Dijkstra's Algorithm</em> to know that Dijkstra's algorithm is a special case of <em>A* Search</em> with <code>node.h = 0</code> always.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">astar</span>(forest, sr, sc, tr, tc):
</span></span><span style="display:flex;"><span>    R, C <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(forest), <span style="color:#0086b3">len</span>(forest[<span style="color:#099">0</span>])
</span></span><span style="display:flex;"><span>    heap <span style="color:#000;font-weight:bold">=</span> [(<span style="color:#099">0</span>, <span style="color:#099">0</span>, sr, sc)]
</span></span><span style="display:flex;"><span>    cost <span style="color:#000;font-weight:bold">=</span> {(sr, sc): <span style="color:#099">0</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> heap:
</span></span><span style="display:flex;"><span>        f, g, r, c <span style="color:#000;font-weight:bold">=</span> heapq<span style="color:#000;font-weight:bold">.</span>heappop(heap)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">and</span> c <span style="color:#000;font-weight:bold">==</span> tc: <span style="color:#000;font-weight:bold">return</span> g
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> nr, nc <span style="color:#000;font-weight:bold">in</span> ((r<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>,c), (r<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>,c), (r,c<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>), (r,c<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>)):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">and</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">and</span> forest[nr][nc]:
</span></span><span style="display:flex;"><span>                ncost <span style="color:#000;font-weight:bold">=</span> g <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">abs</span>(nr <span style="color:#000;font-weight:bold">-</span> tr) <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">abs</span>(nc <span style="color:#000;font-weight:bold">-</span> tc)
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> ncost <span style="color:#000;font-weight:bold">&lt;</span> cost<span style="color:#000;font-weight:bold">.</span>get((nr, nc), <span style="color:#099">9999</span>):
</span></span><span style="display:flex;"><span>                    cost[nr, nc] <span style="color:#000;font-weight:bold">=</span> ncost
</span></span><span style="display:flex;"><span>                    heapq<span style="color:#000;font-weight:bold">.</span>heappush(heap, (ncost, g<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, nr, nc))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">cutOffTree</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sc<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> R <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">(),</span> C <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    PriorityQueue<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> heap <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> PriorityQueue<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;(</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">,</span> b<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">-&gt;</span> Integer<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">compare</span><span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">],</span> b<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]));</span>
</span></span><span style="display:flex;"><span>    heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offer</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>0<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">,</span> sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    HashMap<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">,</span> Integer<span style="color:#000;font-weight:bold">&gt;</span> cost <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashMap<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    cost<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">put</span><span style="color:#000;font-weight:bold">(</span>sr <span style="color:#000;font-weight:bold">*</span> C <span style="color:#000;font-weight:bold">+</span> sc<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(!</span>heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">isEmpty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> cur <span style="color:#000;font-weight:bold">=</span> heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">poll</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> g <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">],</span> r <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">],</span> c <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>3<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">&amp;&amp;</span> c <span style="color:#000;font-weight:bold">==</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">return</span> g<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> di <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> di <span style="color:#000;font-weight:bold">&lt;</span> 4<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>di<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> nr <span style="color:#000;font-weight:bold">=</span> r <span style="color:#000;font-weight:bold">+</span> dr<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">],</span> nc <span style="color:#000;font-weight:bold">=</span> c <span style="color:#000;font-weight:bold">+</span> dc<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>0 <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&amp;&amp;</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">&amp;&amp;</span> 0 <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&amp;&amp;</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">&amp;&amp;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nr<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&gt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> ncost <span style="color:#000;font-weight:bold">=</span> g <span style="color:#000;font-weight:bold">+</span> 1 <span style="color:#000;font-weight:bold">+</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>nr<span style="color:#000;font-weight:bold">-</span>tr<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>nc<span style="color:#000;font-weight:bold">-</span>tr<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>ncost <span style="color:#000;font-weight:bold">&lt;</span> cost<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getOrDefault</span><span style="color:#000;font-weight:bold">(</span>nr <span style="color:#000;font-weight:bold">*</span> C <span style="color:#000;font-weight:bold">+</span> nc<span style="color:#000;font-weight:bold">,</span> 9999<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    cost<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">put</span><span style="color:#000;font-weight:bold">(</span>nr <span style="color:#000;font-weight:bold">*</span> C <span style="color:#000;font-weight:bold">+</span> nc<span style="color:#000;font-weight:bold">,</span> ncost<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                    heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offer</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>ncost<span style="color:#000;font-weight:bold">,</span> g<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">,</span> nr<span style="color:#000;font-weight:bold">,</span> nc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><hr />
<h3 id="approach-3-hadlocks-algorithm-accepted">Approach #3: Hadlock's Algorithm [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Without any obstacles, the distance from <code>source = (sr, sc)</code> to <code>target = (tr, tc)</code> is simply <code>taxi(source, target) = abs(sr-tr) + abs(sc-tc)</code>. This represents a sort of minimum distance that must be traveled. Whenever we walk &quot;away&quot; from the target, we increase this minimum by 2, as we stepped 1 move, plus the taxicab distance from our new location has increased by one.</p>
<p>Let's call such a move that walks away from the target a <em>detour</em>. It can be proven that the distance from source to target is simply <code>taxi(source, target) + 2 * detours</code>, where <code>detours</code> is the smallest number of detours in any path from <code>source</code> to <code>target</code>.</p>
<p><strong>Algorithm</strong></p>
<p>With respect to a <code>source</code> and <code>target</code>, call the <em>detour number</em> of a square to be the lowest number of detours possible in any path from <code>source</code> to that square.  (Here, detours are defined with respect to <code>target</code> - the number of away steps from that target.)</p>
<p>We will perform a priority-first search in order of detour number. If the target is found, it was found with the lowest detour number and therefore the lowest corresponding distance.  This motivates using <code>processed</code>, keeping track of when nodes are expanded, not visited - nodes could potentially be visited twice.</p>
<p>As each neighboring node can only have the same detour number or a detour number one higher, we will only consider at most 2 priority classes at a time. Thus, we can use a deque (double-ended queue) to perform this implementation.  We will place nodes with the same detour number to be expanded first, and nodes with a detour number one higher to be expanded after all nodes with the current number are done.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">hadlocks</span>(forest, sr, sc, tr, tc):
</span></span><span style="display:flex;"><span>    R, C <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(forest), <span style="color:#0086b3">len</span>(forest[<span style="color:#099">0</span>])
</span></span><span style="display:flex;"><span>    processed <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">set</span>()
</span></span><span style="display:flex;"><span>    deque <span style="color:#000;font-weight:bold">=</span> collections<span style="color:#000;font-weight:bold">.</span>deque([(<span style="color:#099">0</span>, sr, sc)])
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> deque:
</span></span><span style="display:flex;"><span>        detours, r, c <span style="color:#000;font-weight:bold">=</span> deque<span style="color:#000;font-weight:bold">.</span>popleft()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (r, c) <span style="color:#000;font-weight:bold">not</span> <span style="color:#000;font-weight:bold">in</span> processed:
</span></span><span style="display:flex;"><span>            processed<span style="color:#000;font-weight:bold">.</span>add((r, c))
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">and</span> c <span style="color:#000;font-weight:bold">==</span> tc:
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">abs</span>(sr<span style="color:#000;font-weight:bold">-</span>tr) <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">abs</span>(sc<span style="color:#000;font-weight:bold">-</span>tc) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span><span style="color:#000;font-weight:bold">*</span>detours
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> nr, nc, closer <span style="color:#000;font-weight:bold">in</span> ((r<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, c, r <span style="color:#000;font-weight:bold">&gt;</span> tr), (r<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, c, r <span style="color:#000;font-weight:bold">&lt;</span> tr),
</span></span><span style="display:flex;"><span>                                   (r, c<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, c <span style="color:#000;font-weight:bold">&gt;</span> tc), (r, c<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, c <span style="color:#000;font-weight:bold">&lt;</span> tc)):
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">and</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">and</span> forest[nr][nc]:
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> closer:
</span></span><span style="display:flex;"><span>                        deque<span style="color:#000;font-weight:bold">.</span>appendleft((detours, nr, nc))
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>                        deque<span style="color:#000;font-weight:bold">.</span>append((detours<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, nr, nc))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">hadlocks</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sc<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> R <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">(),</span> C <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    Set<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;</span> processed <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashSet<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    Deque<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> deque <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> ArrayDeque<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offerFirst</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>0<span style="color:#000;font-weight:bold">,</span> sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(!</span>deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">isEmpty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> cur <span style="color:#000;font-weight:bold">=</span> deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">pollFirst</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> detours <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">],</span> r <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">],</span> c <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(!</span>processed<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">contains</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">*</span>C <span style="color:#000;font-weight:bold">+</span> c<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            processed<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">*</span>C <span style="color:#000;font-weight:bold">+</span> c<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">&amp;&amp;</span> c <span style="color:#000;font-weight:bold">==</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>sr<span style="color:#000;font-weight:bold">-</span>tr<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>sc<span style="color:#000;font-weight:bold">-</span>tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> 2 <span style="color:#000;font-weight:bold">*</span> detours<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> di <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> di <span style="color:#000;font-weight:bold">&lt;</span> 4<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>di<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> nr <span style="color:#000;font-weight:bold">=</span> r <span style="color:#000;font-weight:bold">+</span> dr<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> nc <span style="color:#000;font-weight:bold">=</span> c <span style="color:#000;font-weight:bold">+</span> dc<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">boolean</span> closer<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>di <span style="color:#000;font-weight:bold">&lt;=</span> 1<span style="color:#000;font-weight:bold">)</span> closer <span style="color:#000;font-weight:bold">=</span> di <span style="color:#000;font-weight:bold">==</span> 0 <span style="color:#000;font-weight:bold">?</span> r <span style="color:#000;font-weight:bold">&gt;</span> tr <span style="color:#000;font-weight:bold">:</span> r <span style="color:#000;font-weight:bold">&lt;</span> tr<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">else</span> closer <span style="color:#000;font-weight:bold">=</span> di <span style="color:#000;font-weight:bold">==</span> 2 <span style="color:#000;font-weight:bold">?</span> c <span style="color:#000;font-weight:bold">&gt;</span> tc <span style="color:#000;font-weight:bold">:</span> c <span style="color:#000;font-weight:bold">&lt;</span> tc<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>0 <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&amp;&amp;</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">&amp;&amp;</span> 0 <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&amp;&amp;</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">&amp;&amp;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nr<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&gt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>closer<span style="color:#000;font-weight:bold">)</span> deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offerFirst</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>detours<span style="color:#000;font-weight:bold">,</span> nr<span style="color:#000;font-weight:bold">,</span> nc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">else</span> deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offerLast</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>detours<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">,</span> nr<span style="color:#000;font-weight:bold">,</span> nc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/deepest-leaves-sum/description" target="_blank" rel="noopener noreferrer">Deepest Leaves Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given the <code>root</code> of a binary tree, return <em>the sum of values of its deepest leaves</em>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png" style="width: 273px; height: 265px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
<strong>Output:</strong> 15
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
<strong>Output:</strong> 19
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/detect-cycles-in-2d-grid/description" target="_blank" rel="noopener noreferrer">Detect Cycles in 2D Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D array of characters <code>grid</code> of size <code>m x n</code>, you need to find if there exists any cycle consisting of the <strong>same value</strong> in <code>grid</code>.</p>

<p>A cycle is a path of <strong>length 4 or more</strong> in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the <strong>same value</strong> of the current cell.</p>

<p>Also, you cannot move to the cell that you visited in your last move. For example, the cycle <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> is invalid because from <code>(1, 2)</code> we visited <code>(1, 1)</code> which was the last visited cell.</p>

<p>Return <code>true</code> if any cycle of the same value exists in <code>grid</code>, otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/1.png" style="width: 231px; height: 152px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]
<strong>Output:</strong> true
<strong>Explanation: </strong>There are two valid cycles shown in different colors in the image below:
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/11.png" style="width: 225px; height: 163px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/22.png" style="width: 236px; height: 154px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]
<strong>Output:</strong> true
<strong>Explanation: </strong>There is only one valid cycle highlighted in the image below:
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/2.png" style="width: 229px; height: 157px;" />
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/3.png" style="width: 183px; height: 120px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/detonate-the-maximum-bombs/description" target="_blank" rel="noopener noreferrer">Detonate the Maximum Bombs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">geometry</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a list of bombs. The <strong>range</strong> of a bomb is defined as the area where its effect can be felt. This area is in the shape of a <strong>circle</strong> with the center as the location of the bomb.</p>

<p>The bombs are represented by a <strong>0-indexed</strong> 2D integer array <code>bombs</code> where <code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>. <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> denote the X-coordinate and Y-coordinate of the location of the <code>i<sup>th</sup></code> bomb, whereas <code>r<sub>i</sub></code> denotes the <strong>radius</strong> of its range.</p>

<p>You may choose to detonate a <strong>single</strong> bomb. When a bomb is detonated, it will detonate <strong>all bombs</strong> that lie in its range. These bombs will further detonate the bombs that lie in their ranges.</p>

<p>Given the list of <code>bombs</code>, return <em>the <strong>maximum</strong> number of bombs that can be detonated if you are allowed to detonate <strong>only one</strong> bomb</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> bombs = [[2,1,3],[6,1,4]]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
The above figure shows the positions and ranges of the 2 bombs.
If we detonate the left bomb, the right bomb will not be affected.
But if we detonate the right bomb, both bombs will be detonated.
So the maximum bombs that can be detonated is max(1, 2) = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> bombs = [[1,1,5],[10,10,5]]
<strong>Output:</strong> 1
<strong>Explanation:
</strong>Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
<strong>Output:</strong> 5
<strong>Explanation:</strong>
The best bomb to detonate is bomb 0 because:
- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.
- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.
- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.
Thus all 5 bombs are detonated.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>
	<li><code>bombs[i].length == 3</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/description" target="_blank" rel="noopener noreferrer">Disconnect Path in a Binary Matrix by at Most One Flip</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> <strong>binary</strong> matrix <code>grid</code>. You can move from a cell <code>(row, col)</code> to any of the cells <code>(row + 1, col)</code> or <code>(row, col + 1)</code> that has the value <code>1</code>.&nbsp;The matrix is <strong>disconnected</strong> if there is no path from <code>(0, 0)</code> to <code>(m - 1, n - 1)</code>.</p>

<p>You can flip the value of <strong>at most one</strong> (possibly none) cell. You <strong>cannot flip</strong> the cells <code>(0, 0)</code> and <code>(m - 1, n - 1)</code>.</p>

<p>Return <code>true</code> <em>if it is possible to make the matrix disconnect or </em><code>false</code><em> otherwise</em>.</p>

<p><strong>Note</strong> that flipping a cell changes its value from <code>0</code> to <code>1</code> or from <code>1</code> to <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png" style="width: 441px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,0],[1,1,1]]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/distance-of-nearest-cell-having-1-1587115620/1" target="_blank" rel="noopener noreferrer">Distance of nearest cell having 1</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary grid of <strong>n*m</strong>. Find the distance of the nearest 1 in the grid&nbsp;for each cell.<br />The distance is calculated as&nbsp;<strong>|i<sub>1</sub>&nbsp; - i<sub>2</sub>| + |j<sub>1</sub>&nbsp;- j<sub>2</sub>|</strong>, where i<sub>1</sub>, j<sub>1</sub>&nbsp;are the row number and column number of the current cell, and i<sub>2</sub>, j<sub>2</sub>&nbsp;are the row number and column number of the nearest cell having value 1.</span>&nbsp;<span style="font-size: 18px;">There should be atleast one 1 in the grid.</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = [[0,1,1,0], [1,1,0,0], [0,0,1,1]]
<strong>Output: <br /></strong>[[1,0,0,1], [0,0,1,1], [1,1,0,0]]
<strong>Explanation: <br /></strong>The grid is-
0 1 1 0&nbsp;
1 1 0 0&nbsp;
0 0 1 1&nbsp;
- 0's at (0,0), (0,3), (1,2), (1,3), (2,0) and (2,1) are at a distance of 1 from 1's at (0,1), (0,2), (0,2), (2,3), (1,0) and (1,1) respectively.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701275/Web/Other/blobid0_1745302650.jpg" width="183" height="162" /> </pre>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = [[1,0,1], [1,1,0], [1,0,0]]
<strong>Output: <br /></strong>[[0,1,0], [0,0,1], [0,1,2]]
<strong>Explanation:</strong></span><span style="font-size: 18px;">&nbsp;<br />The grid is-
1 0 1
1 1 0
1 0 0
- 0's at (0,1), (1,2), (2,1) and (2,2) are at a  distance of 1, 1, 1 and 2 from 1's at (0,0), (0,2), (2,0) and (1,1) respectively.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701275/Web/Other/blobid1_1745302675.jpg" width="196" height="173" /> </pre>
<p><span style="font-size: 18px;"><strong>Yout Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;<strong>nearest()&nbsp;</strong>which takes the grid as an input parameter and returns a matrix of the same dimensions where the value at index (i, j) in the resultant matrix signifies the <strong>minimum distance</strong> of 1 in the matrix from grid[i][j].</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/description" target="_blank" rel="noopener noreferrer">Divide Nodes Into the Maximum Number of Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing the number of nodes in an <strong>undirected</strong> graph. The nodes are labeled from <code>1</code> to <code>n</code>.</p>

<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code> indicates that there is a <strong>bidirectional</strong> edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. <strong>Notice</strong> that the given graph may be disconnected.</p>

<p>Divide the nodes of the graph into <code>m</code> groups (<strong>1-indexed</strong>) such that:</p>

<ul>
	<li>Each node in the graph belongs to exactly one group.</li>
	<li>For every pair of nodes in the graph that are connected by an edge <code>[a<sub>i, </sub>b<sub>i</sub>]</code>, if <code>a<sub>i</sub></code> belongs to the group with index <code>x</code>, and <code>b<sub>i</sub></code> belongs to the group with index <code>y</code>, then <code>|y - x| = 1</code>.</li>
</ul>

<p>Return <em>the maximum number of groups (i.e., maximum </em><code>m</code><em>) into which you can divide the nodes</em>. Return <code>-1</code> <em>if it is impossible to group the nodes with the given conditions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/13/example1.png" style="width: 352px; height: 201px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> As shown in the image we:
- Add node 5 to the first group.
- Add node 1 to the second group.
- Add nodes 2 and 4 to the third group.
- Add nodes 3 and 6 to the fourth group.
We can see that every edge is satisfied.
It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[1,2],[2,3],[3,1]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.
It can be shown that no grouping is possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There is at most one edge between any pair of vertices.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a graph with <code>n</code> nodes, represented by a 2D array edges, where <code>edges[i] = [u, v]</code> means there is a bidirectional edge between nodes <code>u</code> and <code>v</code>. Our task is to divide the nodes into the largest number of numbered groups (1, 2, 3, ...) such that:</p>
<ul>
<li>Each node belongs to exactly one group.</li>
<li>If there is an edge <code>[u, v]</code>, and <code>u</code> is in group <code>x</code>, then <code>v</code> must be in either group <code>x - 1</code> or <code>x + 1</code>.</li>
</ul>
<p>Sometimes, this kind of split is not possible. For example, consider this graph:</p>
<p><img src="../Figures/2493/2493_impossible_split.png" alt="Impossible Split" /></p>
<p>Here, no valid split exists. In such cases, we return <code>-1</code>.</p>
<p>A key observation is that if it’s possible to divide the nodes into <code>x</code> groups (<code>x &gt; 2</code>), we can also divide them into <code>x - 1</code> groups. Intuitively, this works because the nodes in the first and third groups can’t be directly connected, but they must all connect to nodes in the second group. By combining groups <code>1</code> and <code>3</code>, we get a valid split with <code>x - 1</code> groups.</p>
<p><img src="../Figures/2493/2493_combine_node_groups.png" alt="Combining Node Groups to Get A Valid Split With One Less Group" /></p>
<p>So, to check if a valid split is possible, we just need to see if the graph can be split into two groups—in other words, whether it is <em>bipartite</em>.</p>
<blockquote>
<p>A graph is <strong>bipartite</strong> when we can divide its nodes into two distinct sets where:</p>
<ul>
<li>All edges connect vertices from one set to vertices in the other set.</li>
<li>No edges exist between vertices within the same set.</li>
</ul>
</blockquote>
<p>Another key detail to consider is that the given graph is not always connected. In this case, we calculate the largest number of groups for each connected part of the graph, and then take the sum of these numbers.</p>
<p>To sum up, the problem boils down to these two steps:</p>
<ol>
<li>Check if the graph is bipartite to see if a valid split exists.</li>
<li>For each connected part of the graph, find the largest number of groups we can divide the nodes into and return their sum.</li>
</ol>
<hr />
<h3 id="approach-1-graph-coloring--longest-shortest-path">Approach 1: Graph Coloring + Longest Shortest Path</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve the first part of the problem, note that once we assign a single node to one of the two groups, the rest of the assignments are automatically determined. Nodes directly connected to the first node must go in the second group, their neighbors must return to the first group, and so on.</p>
<p>To check if the graph is bipartite, we &quot;color&quot; the nodes using two colors (one for each group), ensuring that any two connected nodes have different colors. If this coloring fails, the graph is not bipartite, and we can immediately return <code>-1</code>.</p>
<p><img src="../Figures/2493/2493_graph_coloring.png" alt="Impossible Graph Coloring" /></p>
<p>If the graph is bipartite, we calculate the maximum number of groups we can divide the nodes into for each connected component separately. Intuitively, to achieve the largest number of groups, we spread the nodes as far apart as possible. This means that instead of simply assigning a neighboring node to the same group as the one it was previously associated with, we always try to assign it to a new group.</p>
<p>An important observation here is that the maximum number of groups in a component is determined by the longest shortest path between any pair of nodes in that component. This is similar to finding the &quot;height&quot; of the component if it were structured like a tree, with different nodes as potential roots. The longest shortest path essentially tells us how many layers or groups can be created based on the distances between the nodes.</p>
<p>Finally, we repeat this for all connected components in the graph and sum up the results to get the answer.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="isbipartiteadjlist-node-colors-function"><code>isBipartite(adjList, node, colors)</code> function</h5>
<ul>
<li>Iterate over the neighbors of <code>node</code> and attempt to assign them the opposite color of <code>node</code>:
<ul>
<li>If <code>neighbor</code> already has the same color as <code>node</code> (i.e., <code>colors[neighbor] == colors[node]</code>), return <code>false</code>.</li>
<li>If <code>neighbor</code> has already been assigned a color (i.e., <code>colors[neighbor] != -1</code>), skip to the next <code>neighbor</code>.</li>
<li>Assign <code>colors[neighbor] = (colors[node] + 1) % 2</code>.</li>
<li>Recursively call <code>isBipartite(adjList, neighbor, colors)</code> and return <code>false</code> if the call returns <code>false</code>.</li>
</ul>
</li>
<li>If all neighbors are successfully assigned the opposite color without conflicts, return <code>true</code>.</li>
</ul>
<h5 id="getlongestshortestpathadjlist-srcnode-n-function"><code>getLongestShortestPath(adjList, srcNode, n)</code> function</h5>
<ul>
<li>Initialize a queue, <code>nodesQueue</code> and a <code>visited</code> array of size <code>n</code>.</li>
<li>Push<code>srcNode</code> into the queue and mark it as visited.</li>
<li>Initialize <code>distance</code> to <code>0</code>.</li>
<li>While the <code>nodesQueue</code> is not empty:
<ul>
<li>Initialize <code>numOfNodesInLayer</code> to the size of the queue.</li>
<li>Process all nodes in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>numOfNodesInLayer - 1</code>:
<ul>
<li>Pop out the first element from the queue as <code>currentNode</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:</li>
<li>If the <code>neighbor</code> is visited, skip it.</li>
<li>Otherwise, mark it as visited and push it into the <code>nodesQueue</code>.</li>
</ul>
</li>
<li>Increment <code>distance</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>distance</code>.</li>
</ul>
<h5 id="getnumberofgroupsforcomponentadjlist-node-distances-visited-function"><code>getNumberOfGroupsForComponent(adjList, node, distances, visited)</code> function</h5>
<ul>
<li>Initialize <code>maxNumberOfGroups</code> to <code>distances[node]</code>.</li>
<li>Mark the current node as visited.</li>
<li>Explore the rest of the nodes in the component, i.e. for each <code>neighbor</code> of <code>node</code>:
<ul>
<li>If the <code>neighbor</code> is visited, skip it.</li>
<li>Otherwise, set <code>maxNumberOfGroups</code> to the maximum of its current value and <code>getNumberOfComponentsInGroup(adjList, neighbor, distances, visited)</code>.</li>
</ul>
</li>
<li>Return <code>maxNumberOfGroups</code>.</li>
</ul>
<h5 id="in-the-main-magnificentsetsn-edges-function">In the main <code>magnificentSets(n, edges)</code> function:</h5>
<ul>
<li>Create the <code>adjList</code> of the graph.</li>
<li>Create a <code>colors</code> array of size <code>n</code> with all elements initially set to <code>-1</code>.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>If the <code>node</code> have not been assigned a color, i.e. (<code>colors[node] == -1</code>):
<ul>
<li>Fix the color of the first node of the component, i.e. set <code>colors[node] = 0</code>.</li>
<li>Call <code>isBipartite(adjList, node, colors)</code> to determine if the current component is bipartite. If not, return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an array <code>distances</code> to store the length of the longest shortest path from any node to any other.</li>
<li>Fill the <code>distances</code> array using the <code>getLongestShortestPath</code> function.</li>
<li>Initialize <code>maxNumberOfGroups</code> to <code>0</code> and a <code>visited</code> array with all elements set to <code>false</code>.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>If <code>node</code> has not been visited:
<ul>
<li>Get the number of groups for its component and add it to the total number of groups, i.e. <code>maxNumberOfGroups += getNumberOfGroupsForComponent(adjList, node, distances, visited)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxNumberOfGroups</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/BbpVEPXV/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph and <span class="math inline">\(m\)</span> the size of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (n + m))\)</span></p>
<p>To check whether the graph is bipartite, we perform a DFS traversal, assigning a color to each node exactly once and visiting each edge exactly once. Thus, this step has a time complexity of <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Next, calculating the longest shortest path for each node involves <span class="math inline">\(n\)</span> BFS traversals (one for each node as the source), resulting in a time complexity of <span class="math inline">\(O(n \times (n + m))\)</span>.</p>
<p>Finally, another DFS is performed to compute the sum of the longest shortest paths across all components, which adds an additional <span class="math inline">\(O(n + m)\)</span> to the total.</p>
<p>Overall, the total time complexity is <span class="math inline">\(O(n + m) + O(n \times (n + m)) + O(n + m) = O(n \times (n + m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Constructing the adjacency list from the list of edges requires <span class="math inline">\(O(n + m)\)</span> space, which is an additional space requirement rather than part of the input itself. Therefore, the total auxiliary space complexity is determined by both the adjacency list and the additional data structures (<code>visited</code>, <code>nodesQueue</code>, <code>colors</code>), all of which take <span class="math inline">\(O(n)\)</span> space. As a result, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bfs--union-find">Approach 2: BFS + Union-Find</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, instead of checking bipartiteness to find if there is a valid split, we attempt to directly maximize the number of groups the graph can be partitioned into. Let's first consider the strategy for a single component:</p>
<p>We begin by assigning each node in the component to the first group. From there, we attempt to propagate this group assignment to the neighboring nodes, creating a new group for each &quot;layer&quot; of neighbors. This means that nodes at the same distance from the starting node would belong to the same group, while nodes at different distances would belong to different groups.</p>
<p>However, if we ever come across a neighbor that has already been assigned the same group as the current node, it means that it's not possible to partition the graph in the way we're attempting. In that case, the graph is not partitionable, and we return <code>-1</code>.</p>
<p>Once we explore all possible groups for the component by starting the process at each node in the component, we find the maximum number of groups that can be formed. This maximum value will be the largest number of groups we can use to partition the nodes of that particular component.</p>
<p>Finally, to compute the answer for the entire graph, we repeat this process for each connected component, summing the maximum number of groups from all components. To efficiently track the connected nodes and perform the necessary computations, we use the Union-Find data structure, which helps us manage and combine the connected components as we progress through the graph.</p>
<blockquote>
<p>For a more comprehensive understanding of Union-Find / Disjoint Set, check out the <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union-Find/Disjoint Set Explore Card</a>. This resource provides an in-depth look at union-find, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h4 id="getnumberofgroupsadjlist-srcnode-n"><code>getNumberOfGroups(adjList, srcNode, n)</code></h4>
<ul>
<li>Initialize a queue, <code>nodesQueue</code>, and an array, <code>layerSeen</code> of size <code>n</code> with all values set to <code>-1</code>.</li>
<li>Push<code>srcNode</code> into the queue and set <code>layerSeen[srcNode]</code> to <code>0</code>.</li>
<li>Initialize <code>deepestLayer</code> to <code>0</code>.</li>
<li>While the <code>nodesQueue</code> is not empty:
<ul>
<li>Initialize <code>numOfNodesInLayer</code> to the size of the queue.</li>
<li>Process all nodes in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>numOfNodesInLayer - 1</code>:
<ul>
<li>Pop out the first element from the queue as <code>currentNode</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:
<ul>
<li>If the <code>neighbor</code> is not visited, i.e. <code>layerSeen[neighbor] == -1</code>:
<ul>
<li>Set <code>layerSeen[neighbor] = deepestLayer + 1</code>.</li>
<li>Push <code>neighbor</code> into the queue.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>If the <code>neighbor</code> is seen in the current layer (<code>deepestLayer</code>), then the split is invalid; return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>deepestLayer</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>deepestLayer</code>.</li>
</ul>
<h5 id="findnode-parent-function"><code>find(node, parent)</code> function</h5>
<ul>
<li>While <code>node</code> is not the root of its subtree, i.e. <code>parent[node] != -1</code>:
<ul>
<li>Set <code>node = parent[node]</code>.</li>
</ul>
</li>
<li>Return <code>node</code>.</li>
</ul>
<h5 id="unionnode1-node2-parent-depth-function"><code>Union(node1, node2, parent, depth)</code> function</h5>
<ul>
<li>Replace <code>node1</code> and <code>node2</code> by the roots of their subtrees, by setting <code>node1 = find(node1, parent)</code> and <code>node2 = find(node2, parent)</code>.</li>
<li>If <code>node1 == node2</code>, the two nodes already belong in the same set, so simply return.</li>
<li>If <code>node1</code> has a smaller depth than <code>node2</code>, swap the two nodes.</li>
<li>Set <code>node1</code> to be the parent of <code>node2</code>.</li>
<li>If the depths of the two nodes are equal, increment <code>depth[node1]</code> by <code>1</code>.</li>
</ul>
<h5 id="in-the-main-magnificentsetsn-edges-function-1">In the main <code>magnificentSets(n, edges)</code> function:</h5>
<ul>
<li>Create a 2D array, <code>adjList</code>.</li>
<li>Initialize two arrays of size <code>n</code>, <code>parent</code>, and <code>depth</code> for the Union-Find. Set the parent of each node to <code>-1</code> and its depth to <code>0</code>.</li>
<li>For each <code>edge = [node1, node2]</code> in <code>edges</code>:
<ul>
<li>Push <code>node1 - 1</code> to <code>adjList[node2 - 1]</code> (transitioning to 0-index).</li>
<li>Push <code>node2 - 1</code> to <code>adjList[node1 - 1]</code>.</li>
<li>Call <code>Union(node1 - 1, node2 - 1, parent, depth)</code>.</li>
</ul>
</li>
<li>Initialize a map, <code>numOfGroupsForComponent</code> to store the greatest number of groups that can be achieved for each component of the graph.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>Calculate the number of groups the nodes of its component will be split into, if we assign <code>node</code> to the first group: <code>numberOfGroups = getNumberOfGroups(adjList, node, n)</code>.</li>
<li>If <code>numberOfGroups = -1</code>, then a split is impossible for that component, so return <code>-1</code>.</li>
<li>Find the <code>rootNode</code> of <code>node</code>s component, <code>root = find(node, parent)</code>.</li>
<li>Update the greatest number of groups that can be achieved for this component (<code>numOfGroupsForComponent[rootNode]</code>) to the maximum of its current value and <code>numberOfGroups</code>.</li>
</ul>
</li>
<li>Initialize <code>totalNumberOfGroups</code> to <code>0</code>.</li>
<li>For every <code>[rootNode, numberOfGroups]</code> in <code>numOfGroupsForComponent</code>:
<ul>
<li>Add <code>numberOfGroups</code> to <code>totalNumberOfGroups</code>.</li>
</ul>
</li>
<li>Return <code>totalNumberOfGroups</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7q5R733V/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph and <span class="math inline">\(m\)</span> the size of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (n + m))\)</span></p>
<p>We use the Union-Find method to detect the connected components of the graph. Each call to the find function traverses the nodes in the component of the given node until it reaches the root. By using the <code>depth</code> array, we maintain balanced sets, ensuring that the find operation has a time complexity of <span class="math inline">\(O(\log n)\)</span>. As a result, the process of identifying the connected components takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Next, we perform a BFS traversal starting from each node. Since the time complexity of BFS is <span class="math inline">\(O(m + n)\)</span>, the total time for this operation is <span class="math inline">\(O(n \times (m + n))\)</span>.</p>
<p>Since <span class="math inline">\(n \log n = O(n \times (m + n))\)</span>, the overall time complexity is dominated by the BFS traversals, giving us a final time complexity of <span class="math inline">\(O(n \times (n + m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>As in the previous approach, representing the graph using an adjacency list requires <span class="math inline">\(O(n + m)\)</span> space. This is an additional space requirement rather than part of the input itself. The auxiliary space complexity is determined by both the adjacency list and the additional data structures used (<code>parent</code>, <code>depth</code>, <code>numberOfGroupsForComponent</code>), which can grow up to <span class="math inline">\(O(n)\)</span> in size. Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/employee-importance/description" target="_blank" rel="noopener noreferrer">Employee Importance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a data structure of employee information, including the employee&#39;s unique ID, importance value, and direct subordinates&#39; IDs.</p>

<p>You are given an array of employees <code>employees</code> where:</p>

<ul>
	<li><code>employees[i].id</code> is the ID of the <code>i<sup>th</sup></code> employee.</li>
	<li><code>employees[i].importance</code> is the importance value of the <code>i<sup>th</sup></code> employee.</li>
	<li><code>employees[i].subordinates</code> is a list of the IDs of the direct subordinates of the <code>i<sup>th</sup></code> employee.</li>
</ul>

<p>Given an integer <code>id</code> that represents an employee&#39;s ID, return <em>the <strong>total</strong> importance value of this employee and all their direct and indirect subordinates</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/31/emp1-tree.jpg" style="width: 400px; height: 258px;" />
<pre>
<strong>Input:</strong> employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1
<strong>Output:</strong> 11
<strong>Explanation:</strong> Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.
They both have an importance value of 3.
Thus, the total importance value of employee 1 is 5 + 3 + 3 = 11.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/31/emp2-tree.jpg" style="width: 362px; height: 361px;" />
<pre>
<strong>Input:</strong> employees = [[1,2,[5]],[5,-3,[]]], id = 5
<strong>Output:</strong> -3
<strong>Explanation:</strong> Employee 5 has an importance value of -3 and has no direct subordinates.
Thus, the total importance value of employee 5 is -3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= employees.length &lt;= 2000</code></li>
	<li><code>1 &lt;= employees[i].id &lt;= 2000</code></li>
	<li>All <code>employees[i].id</code> are <strong>unique</strong>.</li>
	<li><code>-100 &lt;= employees[i].importance &lt;= 100</code></li>
	<li>One employee has at most one direct leader and may have several subordinates.</li>
	<li>The IDs in <code>employees[i].subordinates</code> are valid IDs.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Let's use a hashmap <code>emap = {employee.id -&gt; employee}</code> to query employees quickly.</p>
<p>Now to find the total importance of an employee, it will be the importance of that employee, plus the total importance of each of that employee's subordinates.  This is a straightforward depth-first search.</p>
<p><a href="https://leetcode.com/playground/jnJd8b9P/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of employees. We might query each employee in <code>dfs</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the implicit call stack when evaluating <code>dfs</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/escape-a-large-maze/description" target="_blank" rel="noopener noreferrer">Escape a Large Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are <code>(x, y)</code>.</p>

<p>We start at the <code>source = [s<sub>x</sub>, s<sub>y</sub>]</code> square and want to reach the <code>target = [t<sub>x</sub>, t<sub>y</sub>]</code> square. There is also an array of <code>blocked</code> squares, where each <code>blocked[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a blocked square with coordinates <code>(x<sub>i</sub>, y<sub>i</sub>)</code>.</p>

<p>Each move, we can walk one square north, east, south, or west if the square is <strong>not</strong> in the array of <code>blocked</code> squares. We are also not allowed to walk outside of the grid.</p>

<p>Return <code>true</code><em> if and only if it is possible to reach the </em><code>target</code><em> square from the </em><code>source</code><em> square through a sequence of valid moves</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
<strong>Output:</strong> false
<strong>Explanation:</strong> The target square is inaccessible starting from the source square because we cannot move.
We cannot move north or east because those squares are blocked.
We cannot move south or west because we cannot go outside of the grid.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> blocked = [], source = [0,0], target = [999999,999999]
<strong>Output:</strong> true
<strong>Explanation:</strong> Because there are no blocked cells, it is possible to reach the target square.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= blocked.length &lt;= 200</code></li>
	<li><code>blocked[i].length == 2</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt; 10<sup>6</sup></code></li>
	<li><code>source.length == target.length == 2</code></li>
	<li><code>0 &lt;= s<sub>x</sub>, s<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub> &lt; 10<sup>6</sup></code></li>
	<li><code>source != target</code></li>
	<li>It is guaranteed that <code>source</code> and <code>target</code> are not blocked.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/escape-the-spreading-fire/description" target="_blank" rel="noopener noreferrer">Escape the Spreading Fire</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code> which represents a field. Each cell has one of three values:</p>

<ul>
	<li><code>0</code> represents grass,</li>
	<li><code>1</code> represents fire,</li>
	<li><code>2</code> represents a wall that you and fire cannot pass through.</li>
</ul>

<p>You are situated in the top-left cell, <code>(0, 0)</code>, and you want to travel to the safehouse at the bottom-right cell, <code>(m - 1, n - 1)</code>. Every minute, you may move to an <strong>adjacent</strong> grass cell. <strong>After</strong> your move, every fire cell will spread to all <strong>adjacent</strong> cells that are not walls.</p>

<p>Return <em>the <strong>maximum</strong> number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse</em>. If this is impossible, return <code>-1</code>. If you can <strong>always</strong> reach the safehouse regardless of the minutes stayed, return <code>10<sup>9</sup></code>.</p>

<p>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.</p>

<p>A cell is <strong>adjacent</strong> to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg" style="width: 650px; height: 404px;" />
<pre>
<strong>Input:</strong> grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The figure above shows the scenario where you stay in the initial position for 3 minutes.
You will still be able to safely reach the safehouse.
Staying for more than 3 minutes will not allow you to safely reach the safehouse.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg" style="width: 515px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The figure above shows the scenario where you immediately move towards the safehouse.
Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.
Thus, -1 is returned.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg" style="width: 174px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0],[2,2,0],[1,2,0]]
<strong>Output:</strong> 1000000000
<strong>Explanation:</strong> The figure above shows the initial grid.
Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.
Thus, 10<sup>9</sup> is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 300</code></li>
	<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/evaluate-division/description" target="_blank" rel="noopener noreferrer">Evaluate Division</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>

<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>

<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>

<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>

<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]
<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]
<strong>Explanation:</strong> 
Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>
queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined =&gt; -1.0</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]
<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]
<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= equations.length &lt;= 20</code></li>
	<li><code>equations[i].length == 2</code></li>
	<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>
	<li><code>values.length == equations.length</code></li>
	<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>
	<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/even-odd-tree/description" target="_blank" rel="noopener noreferrer">Even Odd Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A binary tree is named <strong>Even-Odd</strong> if it meets the following conditions:</p>

<ul>
	<li>The root of the binary tree is at level index <code>0</code>, its children are at level index <code>1</code>, their children are at level index <code>2</code>, etc.</li>
	<li>For every <strong>even-indexed</strong> level, all nodes at the level have <strong>odd</strong> integer values in <strong>strictly increasing</strong> order (from left to right).</li>
	<li>For every <b>odd-indexed</b> level, all nodes at the level have <b>even</b> integer values in <strong>strictly decreasing</strong> order (from left to right).</li>
</ul>

<p>Given the <code>root</code> of a binary tree, <em>return </em><code>true</code><em> if the binary tree is <strong>Even-Odd</strong>, otherwise return </em><code>false</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/sample_1_1966.png" style="width: 362px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> The node values on each level are:
Level 0: [1]
Level 1: [10,4]
Level 2: [3,7,9]
Level 3: [12,8,6,2]
Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/sample_2_1966.png" style="width: 363px; height: 167px;" />
<pre>
<strong>Input:</strong> root = [5,4,2,3,3,7]
<strong>Output:</strong> false
<strong>Explanation:</strong> The node values on each level are:
Level 0: [5]
Level 1: [4,2]
Level 2: [3,3,7]
Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/22/sample_1_333_1966.png" style="width: 363px; height: 167px;" />
<pre>
<strong>Input:</strong> root = [5,9,1,3,5,7]
<strong>Output:</strong> false
<strong>Explanation:</strong> Node values in the level 1 should be even integers.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to determine whether a given binary tree is an <strong>Even-Odd</strong> tree.</p>
<p>To be considered an <strong>Even-Odd</strong> tree, a tree must meet the following conditions:</p>
<ul>
<li>Nodes at <strong>even</strong> levels must have <strong>odd</strong> values and be in <strong>increasing (left to right)</strong> order.</li>
<li>Nodes at <strong>odd</strong> levels must have <strong>even</strong> values and be in <strong>decreasing (left to right)</strong> order.</li>
</ul>
<p>Some of the conditions involve parity, the property of an integer with respect to being odd or even. We can determine the parity of an integer by using the modulo operation, <code>%</code>. For an odd integer <code>x</code>, <code>x % 2</code> always evaluates to <code>1</code> while for even integers <code>y</code>, <code>y % 2</code> always evaluates to <code>0</code>.</p>
<p>To determine whether a tree is <strong>Even-Odd</strong>, we need to traverse the tree, checking whether each node meets the above conditions.</p>
<blockquote>
<p>If you are not familiar with tree traversal, check out our <a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/">Explore Card</a></p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The conditions depend on the level or depth of the tree, which we will need to track.</p>
<p>One of the primary ways to traverse a tree is a Depth-First Search (DFS). We will use this approach with a preorder traversal.</p>
<p>Binary trees are often traversed using recursive methods. Below is an example pseudocode for a preorder traversal.</p>
<h5 id="recursive-preorder-traversal">Recursive Preorder Traversal</h5>
<ol>
<li>If the tree is empty, return.</li>
<li>Handle the root.</li>
<li>Traverse the right subtree - call Preorder(root.left).</li>
<li>Traverse the left subtree - call Preorder(root.right).</li>
</ol>
<p>We can implement a recursive function, <code>dfs</code>, to traverse the tree and check the <strong>Even-Odd</strong> conditions.</p>
<p>When writing recursive functions, we start with the base case. When the tree is empty, we return <code>true</code>; an empty tree is <strong>Even-Odd</strong>.</p>
<p>From there, we can build the rest of our recursive function <code>dfs</code>. The parameters will be a tree node <code>current</code> and <code>level</code> because when we encounter a node, we need to know what level we are on because the conditions are different for even and odd levels.</p>
<p>We also need to know whether the level we are on is even or odd. We can calculate <code>level % 2</code>, which will evaluate to <code>1</code> on odd levels and  <code>0</code> on even levels.</p>
<p>We also need to know the value of the previous node on this level so we can compare the current node and determine whether the values are increasing or decreasing. Depth-First Search does not visit the levels in order, so we will need to save the previously visited node from each level. We will use an array <code>prev</code>, indexed by <code>level</code>. The previous node on level 1 will be stored at <code>prev[1]</code>, and the previous node on level 2 will be stored at <code>prev[2]</code>. After handling each node, we will update <code>prev[level]</code> to the current node's value for use with the next node on this level.</p>
<p>To handle a node, we must check the conditions to determine whether it meets the requirements to be an <strong>Even-Odd</strong> tree:</p>
<p>Check whether the current value has the correct parity:</p>
<ul>
<li>Nodes on <strong>even</strong> levels must have <strong>odd</strong> values</li>
<li>Nodes on <strong>odd</strong> levels must have <strong>even</strong> values</li>
</ul>
<p>The level and the value should have opposite parity. We can use <code>current-&gt;val % 2 == level % 2</code> to compare the parity. If the parities are the same, the node breaks <strong>Even-Odd</strong> tree conditions, and we return <code>false</code>.</p>
<p>Check whether the current value is in the correct order:</p>
<ul>
<li>
<p>Nodes on <strong>even</strong> levels must be in strictly <strong>increasing</strong> order.</p>
<pre><code> node.val &lt;= prev[level] // True when node.val is less than or equal to `prev`
</code></pre>
</li>
</ul>
<p>If true, the node breaks the <strong>increasing</strong> condition, and we can return false.</p>
<ul>
<li>
<p>Nodes on <strong>odd</strong> levels must be in strictly <strong>decreasing</strong> order.</p>
<pre><code> node.val &gt;= prev[level] // True when node.val is greater than or equal to `prev`
</code></pre>
</li>
</ul>
<p>If true, the node breaks the <strong>decreasing</strong> condition, and we can return false.</p>
<p>After handling a node, we recursively call <code>dfs</code> on its children.</p>
<p>After defining <code>dfs</code>, all we have to do to solve the problem is call the function and return.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1609/1609_dfs_slideshow.json:960,480!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Declare an array <code>prev</code> to store the previous value on each level.</li>
<li>Initialize a node <code>current</code> to <code>root</code> for traversing the tree.</li>
<li>Define a function <code>dfs</code> whose parameters are a TreeNode <code>current</code> and <code>level</code> that performs a depth-first search, checking that the nodes meet the requirements for being an <strong>Even-Odd</strong> tree. If the tree is <strong>Even-Odd</strong>, it returns <code>true</code>; otherwise, it returns <code>false</code>.
<ol>
<li>Base case: if the tree is empty, return <code>true</code>. An empty tree is <strong>Even-Odd</strong>.</li>
<li>Check whether the current value has the correct parity compared with the level: <code>current-&gt;val % 2 == level % 2</code>. Return <code>false</code> if not.</li>
<li>Resize and add a new level to <code>prev</code> if we've reached a new level.</li>
<li>If we have already visited a node on this level, check that the current value is in the correct order depending on the level.
<ul>
<li>If on an even level, check that <code>current.val</code> is greater than the previous.</li>
<li>If on an odd level, check that <code>current.val</code> is less than the previous.</li>
<li>Otherwise, return <code>false</code>.</li>
</ul>
</li>
<li>Add <code>current</code>'s value to the <code>prev</code> array. Only the most recent node on this level matters to the next node.</li>
<li>Recursively call <code>dfs</code> on the left and right child, incrementing <code>level</code>.</li>
</ol>
</li>
<li>Call and return <code>dfs(current, 0)</code> because the first level will be <code>0</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p>In the below implementation, we will use tail recursion. Many times, we use tail recursion without even recognizing it. It's a significant concept and an optimization strategy often overlooked in interviews. Tail recursion is a specific optimization technique used in functional programming to avoid the use of explicit loops and improve performance.</p>
<p>In a recursive function, each recursive call creates a new stack frame, which can lead to a stack overflow if the function is called too many times. Tail recursion reduces this problem by reusing the current stack frame instead of creating a new one.</p>
<p>To use tail recursion, the last statement of a function must be a recursive call, and the function must have a base case that can be reached by the recursive call. The base case is used to stop the recursion and return a value.<br />
Since our approach has both conditions, we can use tail recursion in the below implementation.</p>
<p><a href="https://leetcode.com/playground/FHwmAU3N/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Traversing the tree with a DFS costs <span class="math inline">\(O(n)\)</span> as we visit each node exactly once. At each visit, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of DFS, when implemented recursively, is determined by the maximum depth of the call stack, which corresponds to the depth of the tree. In the worst case, if the tree is entirely unbalanced (e.g., a linked list or a left/right skewed tree), the call stack can grow as deep as the number of nodes, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>. We also use an array, <code>prev</code>, which can grow as large as the depth of the tree, making the overall time complexity <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The other primary way to traverse a tree is a Breath-First Search (BFS). This traversal method, also known as level-order traversal, could apply to this problem because the algorithm visits all the nodes in each level before moving on to the next level. BFS could be helpful because on each level, we need to check that all nodes on the level meet certain conditions. The general algorithm for Breadth-First Search is below.</p>
<h5 id="breadth-first-search">Breadth-First Search</h5>
<ol>
<li>Create a queue for storing the nodes on each level.</li>
<li>Add the first node to the queue.</li>
<li>While the queue is not empty:
<ol>
<li>Remove the front node of the queue.</li>
<li>Add the adjacent nodes to the queue.</li>
</ol>
</li>
</ol>
<p>We will adjust a Breath-First Search to determine whether a tree is <strong>Even-Odd</strong>.</p>
<p>We create a flag <code>even</code> to track the current level's parity. It is set to <code>true</code> on even levels and <code>false</code> on odd levels. The size of the level is tracked to iterate through its nodes. After handling a node and enqueueing its children, we decrement <code>size</code>. The <code>even</code> flag is flipped with <code>!even</code> after processing all nodes on a level, alternating between <code>true</code> and <code>false</code> for even and odd levels.</p>
<p>To determine whether a tree is <strong>Even-Odd</strong>, we must handle each node, testing its parity.  We must also check the node's value compared to the other nodes on this level. Our BFS traversal will visit each node in each level in order, so we can use a variable <code>prev</code> to store the previous node's value. We can use this to check that the current node is greater than or less than the  <code>prev</code>, as needed.</p>
<p>Below are the conditions we will check to ensure the tree is <strong>Even-Odd</strong> :</p>
<p>Nodes on even levels must have <strong>odd</strong> values and must be in strictly <strong>increasing</strong> order. We check the following conditions:</p>
<ul>
<li><code>node.val % 2 == 0</code> // True when <code>node.val</code> is even</li>
<li><code>node.val &lt;= prev</code> // True when <code>node.val</code> is less than or equal to <code>prev</code></li>
</ul>
<p>If either of these are <code>true</code>, the node breaks <strong>Even-Odd</strong> tree conditions, and we can return <code>false</code>.</p>
<p>Nodes on odd levels must have <strong>even</strong> values and must be in strictly <strong>decreasing</strong> order. We check the following conditions:</p>
<ul>
<li><code>node.val % 2 == 1</code> // True when <code>node.val</code> is odd</li>
<li><code>node.val &gt;= prev</code> // True when <code>node.val</code> is greater than or equal to <code>prev</code></li>
</ul>
<p>If either of these are <code>true</code>, the node breaks <strong>Even-Odd</strong> tree conditions, and we can return <code>false</code>.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1609/1609_bfs_slideshow.json:685,540!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a Queue <code>queue</code> for storing the nodes on each level.</li>
<li>Declare a node <code>current</code> and set it to <code>root</code>. Add <code>current</code> to the queue.</li>
<li>Declare a boolean <code>even</code>, which will evaluate to <code>true</code> on even levels and <code>false</code> on odd levels. Initialize to <code>true</code>; we will start on level <code>0</code> which is even.</li>
<li>While <code>queue</code> is not empty:
<ol>
<li>Initialize a variable <code>size</code> to store the size of this level.</li>
<li>Declare a variable <code>prev</code> to store the value of the previous node on this level, so we can determine whether the nodes are in increasing or decreasing order. Set to <code>INT_MAX</code> on odd levels, which will ensure <code>current.val</code> is less than <code>prev</code>, and set to <code>INT_MIN</code> on even levels, which will ensure <code>current.val</code> is greater than <code>prev</code>.</li>
<li>For each node on this level:
<ol>
<li>Remove the front node from the queue and save in <code>current</code>.</li>
<li>Check to make sure this node meets the conditions of being even-odd:
<ul>
<li>If on an even level, make sure the current node's value is odd and greater than the previous value.</li>
<li>If on an odd level, make sure the current node's value is even, and less than the previous value.</li>
<li>Otherwise return <code>false</code>.</li>
</ul>
</li>
<li>Set <code>prev</code> to the current value.</li>
<li>If <code>current</code> has a left child, add it to <code>queue</code>.</li>
<li>If <code>current</code> has a right child, add it to <code>queue</code>.</li>
<li>Decrement <code>size</code>, we have handled a node on this level.</li>
</ol>
</li>
<li>Flip the value of <code>even</code> with <code>!even</code>. The next level will have the opposite parity.</li>
</ol>
</li>
<li>If the loop completes, every node in the tree has been visited and the whole tree is <strong>Even-Odd</strong>. Return <code>true</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/KJibuLLw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We perform BFS, which costs <span class="math inline">\(O(n)\)</span> because we don't visit a node more than once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space for the queue during the BFS for <code>queue</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/eventual-safe-states/1" target="_blank" rel="noopener noreferrer">Eventual Safe States</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">A directed graph of <strong>V</strong> vertices and <strong>E</strong> edges is given in the form of an adjacency list <strong>adj</strong>. Each node of the graph is labelled with a distinct integer in the range <strong>0</strong> to <strong>V - 1</strong>.</span></p>
<p><span style="font-size: 18px;">A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong>.</span></p>
<p><span style="font-size: 18px;">You have to return an array containing all the <strong>safe nodes</strong> of the graph. The answer should be sorted in <strong>ascending</strong> order.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711095/Web/Other/blobid0_1745299307.jpg" width="355" height="314" /><br /><span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">2 4 5 6</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">The given graph is shown above.</span>
<span style="font-size: 18px;">Nodes 5 and 6 are terminal nodes as there are no 
outgoing edges from either of them. </span>
<span style="font-size: 18px;">Every path starting at nodes 2, 4, 5, and 6 all 
lead to either node 5 or 6.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711095/Web/Other/blobid1_1745299371.jpg" width="361" height="237" /><br /><strong><span style="font-size: 18px;">Output:</span> </strong><span style="font-size: 18px;">3</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">Only node 3 is a terminal node, and every path 
starting at node 3 leads to node 3.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>eventualSafeNodes</strong><strong>()&nbsp;</strong>which takes an integer&nbsp;<strong>V</strong> denoting no. of vertices and <strong>adj</strong> denoting adjacency list of the graph and returns an array of <strong>safe nodes</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(V + E)</span></p>
<p><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(V)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= V &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">0 &lt;= E &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">The graph won't contain self loops.</span></li>
<li><span style="font-size: 18px;">Each node in the graph has a distinct value in the range 0 to V - 1.</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description" target="_blank" rel="noopener noreferrer">Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two binary trees <code>original</code> and <code>cloned</code> and given a reference to a node <code>target</code> in the original tree.</p>

<p>The <code>cloned</code> tree is a <strong>copy of</strong> the <code>original</code> tree.</p>

<p>Return <em>a reference to the same node</em> in the <code>cloned</code> tree.</p>

<p><strong>Note</strong> that you are <strong>not allowed</strong> to change any of the two trees or the <code>target</code> node and the answer <strong>must be</strong> a reference to a node in the <code>cloned</code> tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/21/e1.png" style="width: 544px; height: 426px;" />
<pre>
<strong>Input:</strong> tree = [7,4,3,null,null,6,19], target = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/21/e2.png" style="width: 221px; height: 159px;" />
<pre>
<strong>Input:</strong> tree = [7], target =  7
<strong>Output:</strong> 7
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/21/e3.png" style="width: 459px; height: 486px;" />
<pre>
<strong>Input:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the <code>tree</code> is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li>The values of the nodes of the <code>tree</code> are unique.</li>
	<li><code>target</code> node is a node from the <code>original</code> tree and is not <code>null</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you solve the problem if repeated values on the tree are allowed?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p><strong>How to Solve</strong></p>
<p>Let's traverse both trees in parallel, and once the target node is identified in the first tree, return the corresponding node from the second tree.</p>
<p><strong>How to Traverse the Tree: DFS vs BFS</strong></p>
<p>There are two ways to traverse the tree: DFS <em>depth first search</em> and BFS <em>breadth first search</em>. Here is a small summary</p>
<p><img src="../Figures/1379/traversals.png" alt="diff" /></p>
<p>Both start from the root and go down, both use additional structures, what's the difference? Here is how it looks at the big scale: BFS traverses level by level, and DFS first goes to the leaves.</p>
<p><img src="../Figures/1379/dfs_bfs_2.png" alt="diff" /></p>
<blockquote>
<p>Description doesn't give us any clue which traversal is better to use here. Interview-simple solutions are DFS in order traversals.</p>
</blockquote>
<p>In Approach 1 and Approach 2, we're going to discuss recursively inorder DFS and iterative inorder DFS traversals. They both need up to <span class="math inline">\(\mathcal{O}(H)\)</span> space to keep stack, where <span class="math inline">\(H\)</span> is a tree height.</p>
<p>In Approach 3, we provide a BFS solution. Normally, it's a bad idea to use BFS during the interview, unless the interviewer would push for it by adding new details into the problem description.</p>
<p><strong>Could We Solve in Constant Space?</strong></p>
<p>No. The problem could be solved in constant space using the DFS Morris inorder traversal algorithm, but it modifies the tree, and that isn't allowed here.</p>
<p><strong>Follow up: Repeated Values are Allowed</strong></p>
<p>If duplicate values are not allowed, one could compare node values:</p>
<p><a href="https://leetcode.com/playground/XvE3tVVZ/shared">code</a></p>
<p>Otherwise, one has to compare the nodes:</p>
<p><a href="https://leetcode.com/playground/gdNRDRYo/shared">code</a></p>
<br />
<br />
<hr />
<h3 id="approach-1-dfs-recursive-inorder-traversal">Approach 1: DFS: Recursive Inorder Traversal.</h3>
<p>Recursive inorder traversal is extremely simple: follow <code>Left-&gt;Node-&gt;Right</code> direction, <em>i.e.</em>, do the recursive call for the <em>left</em> child, then do all the business with the node (= check if the node is a target one or not), and then do the recursive call for the <em>right</em> child.</p>
<p><img src="../Figures/1379/dfs.png" alt="diff" /><br />
<em>Figure 1. The nodes are enumerated in the order of visits. To compare different DFS strategies, follow <code>1-2-3-4-5</code> direction.</em></p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8CVVBmSp/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. Since one has to visit each node, where <span class="math inline">\(N\)</span> is the number of nodes.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. In the degenerative tree case (where the tree is shaped like a linked list), all nodes will be on the run-time stack while the deepest node is being processed. If the tree is balanced, the space complexity will be nearer to <span class="math inline">\(\mathcal{O}(\log N)\)</span>, but remember that for the purposes of complexity analysis, we mostly consider the worst case.</p>
</li>
</ul>
<br />
<br />
<hr />
<h3 id="approach-2-dfs-iterative-inorder-traversal">Approach 2: DFS: Iterative Inorder Traversal.</h3>
<p>Iterative inorder traversal is straightforward: go left as far as you can, then one step right. Repeat till the end of nodes in the tree.</p>
<p>!?!../Documents/1379_LIS.json:1000,310!?!</p>
<p><strong>Implementation</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html">Don't use Stack in Java, use ArrayDeque instead</a>.</p>
<p><a href="https://leetcode.com/playground/2UFXYe3o/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. Since one has to visit each node.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. In the degenerative tree case (where the tree is shaped like a linked list), all nodes will be on the stack while the deepest node is being processed. If the tree is balanced, the space complexity will be nearer to <span class="math inline">\(\mathcal{O}(\log N)\)</span>, but remember that for the purposes of complexity analysis, we mostly consider the worst case.</p>
</li>
</ul>
<br />
<hr />
<h3 id="approach-3-bfs-iterative-traversal">Approach 3: BFS: Iterative Traversal.</h3>
<p><strong>Algorithm</strong></p>
<p>Here we implement standard BFS traversal with the queue:</p>
<ul>
<li>
<p>Add root into queue.</p>
</li>
<li>
<p>While queue is not empty:</p>
<ul>
<li>
<p>Pop out a node from queue.</p>
</li>
<li>
<p>If the node is a target, we're done.</p>
</li>
<li>
<p>Add first <em>left</em> and then <em>right</em> child node into queue.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Implementation</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html">Don't use Stack in Java, use ArrayDeque instead</a>.</p>
<p><a href="https://leetcode.com/playground/mnfHHeRK/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since one has to visit each node.</p>
</li>
<li>
<p>Space complexity: up to <span class="math inline">\(\mathcal{O}(N)\)</span> to keep the queue. Let's use the last level to estimate the queue size. This level could contain up to <span class="math inline">\(N/2\)</span> tree nodes in the case of <a href="https://leetcode.com/problems/count-complete-tree-nodes/">complete binary tree</a>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-groups-of-farmland/description" target="_blank" rel="noopener noreferrer">Find All Groups of Farmland</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>land</code> where a <code>0</code> represents a hectare of forested land and a <code>1</code> represents a hectare of farmland.</p>

<p>To keep the land organized, there are designated rectangular areas of hectares that consist <strong>entirely</strong> of farmland. These rectangular areas are called <strong>groups</strong>. No two groups are adjacent, meaning farmland in one group is <strong>not</strong> four-directionally adjacent to another farmland in a different group.</p>

<p><code>land</code> can be represented by a coordinate system where the top left corner of <code>land</code> is <code>(0, 0)</code> and the bottom right corner of <code>land</code> is <code>(m-1, n-1)</code>. Find the coordinates of the top left and bottom right corner of each <strong>group</strong> of farmland. A <strong>group</strong> of farmland with a top left corner at <code>(r<sub>1</sub>, c<sub>1</sub>)</code> and a bottom right corner at <code>(r<sub>2</sub>, c<sub>2</sub>)</code> is represented by the 4-length array <code>[r<sub>1</sub>, c<sub>1</sub>, r<sub>2</sub>, c<sub>2</sub>].</code></p>

<p>Return <em>a 2D array containing the 4-length arrays described above for each <strong>group</strong> of farmland in </em><code>land</code><em>. If there are no groups of farmland, return an empty array. You may return the answer in <strong>any order</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-23-15-copy-of-diagram-drawio-diagrams-net.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> land = [[1,0,0],[0,1,1],[0,1,1]]
<strong>Output:</strong> [[0,0,0,0],[1,1,2,2]]
<strong>Explanation:</strong>
The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].
The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-30-26-copy-of-diagram-drawio-diagrams-net.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> land = [[1,1],[1,1]]
<strong>Output:</strong> [[0,0,1,1]]
<strong>Explanation:</strong>
The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-32-24-copy-of-diagram-drawio-diagrams-net.png" style="width: 100px; height: 100px;" />
<pre>
<strong>Input:</strong> land = [[0]]
<strong>Output:</strong> []
<strong>Explanation:</strong>
There are no groups of farmland.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == land.length</code></li>
	<li><code>n == land[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>land</code> consists of only <code>0</code>&#39;s and <code>1</code>&#39;s.</li>
	<li>Groups of farmland are <strong>rectangular</strong> in shape.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary matrix of <code>0s</code> and <code>1s</code> of size <code>M x N</code>. The value <code>0</code> represents the forest land and <code>1</code> represents the farmland. We need to return a list with the top left and bottom right coordinates of each farmland in the matrix. All farmlands are rectangular. We can leverage this fact to make our search for farmland more efficient. From a given farmland cell, we can determine which of the eight neighboring cells is farmland by checking just four neighbors (left, right, up, and down). We don't need to check the diagonal neighbors because we can infer whether they are farmland. For example, if the cells on the right and below a farmland cell are also farmland, then the diagonal cell, as shown below, will have to be a farmland cell for this farmland to be rectangular.</p>
<p><img src="../Figures/1992/1992B.png" alt="fig" /></p>
<p>Therefore, this problem is similar to this <a href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a> problem, except the components (islands of farmland) here will always be rectangular. We will use this property in our third greedy approach. The first two approaches, DFS &amp; BFS, are similar to the one applied in <a href="https://leetcode.com/problems/number-of-islands/solution/">Number of Islands soluton</a>.</p>
<p><img src="../Figures/1992/1992A.png" alt="fig" /></p>
<blockquote>
<p>Note: In the following two approaches below, we used a separate array to keep track of visited cells; this could be done using the original input matrix. However, in an interview setting, altering the inputs is not recommended. We have applied this input-altering strategy in our last approach to demonstrate how it can be done.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find all the cells in each farmland. We will apply a depth-first search from each of the cells with the value <code>1</code> that has not yet been visited. In the depth-first search process, we will traverse each of the four connected neighbors with the value <code>1</code> and apply DFS. This way, we can traverse over all the cells in each farmland.</p>
<p>We need a way to find the top left and bottom right cell coordinates of each farmland. Since the order of cell traversal in DFS is not fixed, there is no way to find when the last cell will be visited. To solve this, we can keep the maximum <code>x</code> and <code>y</code> coordinates we have seen so far. This way the maximum <code>x</code> and <code>y</code> coordinates will refer to the bottom right coordinates, and the coordinate of the cell with which we started the DFS will be the top left coordinate.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Iterate over each cell in the matrix <code>land</code>, and for each cell <code>(row1, col1)</code>, do the following:</p>
<ul>
<li>If the cell is a farmland cell, i.e. <code>land[row1][col1] = 1</code>, and hasn't been visited yet (<code>visited[row1][col1] = 0</code>), start DFS from <code>(row1, col1)</code>. Also, keep two variables <code>row2</code> and <code>col2</code> as the coordinates of the bottom right corner initialized with <code>0</code> each.</li>
<li>In the DFS, mark the current coordinates as visited and update the values of <code>row2</code> and <code>col2</code> to the maximum compared with the current coordinates.</li>
<li>Traverse over the four neighbors and apply DFS if the neighbor is within the matrix boundary, a farmland cell, and hasn't been visited yet.</li>
<li>When the DFS is complete, store the top left coordinate as <code>(row1, col1)</code> and the bottom right as <code>(row2, col2)</code> in the list <code>ans</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Nmdf4uzS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows in the matrix and <span class="math inline">\(N\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will iterate over each cell in the matrix at most once because we used the <code>visited</code> array to prevent re-processing cells. All other helper functions like <code>isWithinFarm</code> are <span class="math inline">\(O(1)\)</span>. Hence, the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>The array <code>visited</code> is of size <span class="math inline">\(M \cdot N\)</span>; also, there will be stack space consumed by DFS that will be equal to the maximum number of active stack calls, which will be equal to <span class="math inline">\(M * N\)</span> if all cells are <code>1</code> in the matrix. Apart from this, there is also array <code>ans</code>, but the space used to store the result isn't considered part of space complexity. Hence, the total space complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Similarly to the previous approach, we will traverse over each farmland and store the top left and bottom right corner coordinates in our answer. We will use the breadth-first search here to iterate over each cell. Iterating over the matrix, we will enqueue the first cell and mark it visited in the array <code>visited</code>. In the BFS, we will pop the cell from the queue, iterate over the four neighbors, and add them to the queue if the farmland cells have not been visited yet.</p>
<p>In BFS, the cells are visited in fixed order using a queue, and hence, we can identify the last visited cell in this group of farmland. Therefore, we don't need to keep the maximum coordinates we have seen. We can store the last cell we visit from the current group of farmland in the BFS, which would be the coordinates of the current farmland in the bottom right corner.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Iterate over each cell in the matrix <code>land</code> and for each cell <code>(row1, col1)</code> do the following:</p>
<ul>
<li>If the cell is a farmland cell, i.e <code>land[row1][col1] = 1</code> and isn't visited yet (<code>visited[row1][col1] = 0</code>), enqueue it to the queue start BFS from <code>(row1, col1)</code>.</li>
<li>Traverse over the four neighbors and add them to the queue for BFS if the neighbor is within the matrix boundary and is a farmland cell and hasn't visited yet. Also, mark these coordinates as visited.</li>
<li>When the BFS completes return the last coordinate that was popped from the queue and store the top left coordinate as <code>(row1, col1)</code> and the bottom right as the last visited node in the list <code>ans</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QpeHLgK4/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows in the matrix and <span class="math inline">\(N\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will iterate over each cell in the matrix at most once because of the <code>visited</code> array. All other helper functions like <code>isWithinFarm</code> are <span class="math inline">\(O(1)\)</span>. Hence, the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>The array <code>visited</code> is of size <span class="math inline">\(M \cdot N\)</span>, also there will be space consumed by the queue that can be equal to <span class="math inline">\(M * N\)</span> if all cells are <code>1</code> in the matrix. Apart from this, there is also array <code>ans</code>, but the space used to store the result isn't considered as part of the space complexity. Hence, the total space complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-greedy">Approach 3: Greedy</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can solve this problem with a greedy approach because all farmlands will be rectangular. DFS and BFS approaches are able to find irregularly shaped farmland. Since farmlands are rectangular, we can just start from the first farmland cell, the top left corner, and iterate over the cells in the current row until we find a cell with the value <code>0</code>. The y-coordinate of this cell will be the <code>y</code> coordinate of the bottom right corner. We can then iterate over the cells with this <code>y</code> coordinate and increase the <code>x</code> coordinate until we find the cell with value <code>0</code>, this will be the bottom right corner of the current farmland.</p>
<p>We will also need to keep track of which cells have already been visited. We could use a separate array <code>visited</code> as we did in the last two approaches, but we will use the input matrix here to demonstrate another strategy. We mark all cells with values <code>1</code> to <code>0</code> in the farmland so that we don't visit them again and consider them as separate farmland. Please note that in an interview setting changing the input is generally discouraged.</p>
<p>This way, we will start from the first cell with the value <code>1</code> and then find the bottom right corner coordinate using the above strategy, then store the resulting coordinates in the list <code>ans</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize dimensions <code>M</code> and <code>N</code> to represent the number of rows and columns in the <code>land</code> grid.</p>
</li>
<li>
<p>Create a <code>res</code> array to store the top-left and bottom-right coordinates of each farmland plot.</p>
</li>
<li>
<p>Iterate through each cell in the grid using nested loops:</p>
<ul>
<li>For every cell <code>(row1, col1)</code>, check if it is part of farmland (<code>land[row1][col1] == 1</code>).</li>
<li>If farmland is found, initialize <code>x</code> to <code>row1</code> and <code>y</code> to <code>col1</code>.</li>
</ul>
</li>
<li>
<p>Expand the farmland boundaries:</p>
<ul>
<li>Increment <code>x</code> until you find the last row where <code>land[x][col1] == 1</code>.</li>
<li>For each row in this range, increment <code>y</code> until you find the last column where <code>land[x][y] == 1</code>.</li>
<li>Mark all cells in the identified rectangle as <code>0</code> to avoid revisiting them.</li>
</ul>
</li>
<li>
<p>Record the top-left <code>(row1, col1)</code> and bottom-right <code>(x - 1, y - 1)</code> coordinates of the current farmland plot in <code>res</code>.</p>
</li>
<li>
<p>Return the <code>res</code> array containing the coordinates of all identified farmland plots.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/ADduxYQV/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows in the matrix and <span class="math inline">\(N\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will iterate over each cell in the matrix at most once because we mark the visited cells in the <code>land</code>  array.  Hence, the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only space required is <code>ans</code> but the space used to store the result isn't considered as part of space complexity. Hence, the total space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-people-with-secret/description" target="_blank" rel="noopener noreferrer">Find All People With Secret</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> indicating there are <code>n</code> people numbered from <code>0</code> to <code>n - 1</code>. You are also given a <strong>0-indexed</strong> 2D integer array <code>meetings</code> where <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> indicates that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> have a meeting at <code>time<sub>i</sub></code>. A person may attend <strong>multiple meetings</strong> at the same time. Finally, you are given an integer <code>firstPerson</code>.</p>

<p>Person <code>0</code> has a <strong>secret</strong> and initially shares the secret with a person <code>firstPerson</code> at time <code>0</code>. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person <code>x<sub>i</sub></code> has the secret at <code>time<sub>i</sub></code>, then they will share the secret with person <code>y<sub>i</sub></code>, and vice versa.</p>

<p>The secrets are shared <strong>instantaneously</strong>. That is, a person may receive the secret and share it with people in other meetings within the same time frame.</p>

<p>Return <em>a list of all the people that have the secret after all the meetings have taken place. </em>You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,5]
<strong>Explanation:
</strong>At time 0, person 0 shares the secret with person 1.
At time 5, person 1 shares the secret with person 2.
At time 8, person 2 shares the secret with person 3.
At time 10, person 1 shares the secret with person 5.​​​​
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>Output:</strong> [0,1,3]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 3.
At time 2, neither person 1 nor person 2 know the secret.
At time 3, person 3 shares the secret with person 0 and person 1.
Thus, people 0, 1, and 3 know the secret after all the meetings.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,4]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 1.
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
Note that person 2 can share the secret at the same time as receiving it.
At time 2, person 3 shares the secret with person 4.
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
	<li><code>meetings[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem,</p>
<ul>
<li>
<p>We have <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and</p>
</li>
<li>
<p>Initially (at time <code>t = 0</code>), person <code>0</code> and <code>firstPerson</code> know the secret.</p>
</li>
<li>
<p>Multiple <code>meetings</code> take place between people. Each meeting is characterized by an array <code>[x, y, t]</code>, where <code>x</code> and <code>y</code> are the labels of the two people that meet, and <code>t</code> is the time of the meeting. If any one of the two people who meet knows the secret at a time <code>t</code>, then both of them will know the secret instantly at the time <code>t</code>.</p>
<p>More than one meeting can take place at the same time <code>t</code></p>
<p>A person can attend multiple meetings at the same time <code>t</code></p>
<blockquote>
<p>If at a time <code>t</code>, we are given the following meetings:</p>
<ul>
<li><code>x</code> and <code>y</code></li>
<li><code>x</code> and <code>z</code></li>
<li><code>z</code> and <code>w</code></li>
<li><code>a</code> and <code>b</code></li>
</ul>
<p>Then we can deduce that all <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code> are in the same meeting at the time <code>t</code>.</p>
</blockquote>
<p>Thus, given fixed time <code>t</code>, meetings evolve as <a href="https://en.wikipedia.org/wiki/Equivalence_relation">Equivalence Relation</a>. Particularly meetings are <a href="https://en.wikipedia.org/wiki/Transitive_relation"><strong>transitive</strong></a> in nature.</p>
<p>It's worth noting that it is <strong>NOT</strong> necessary that all participants of the meeting happening at a time <code>t</code>  are in the same meeting. Meetings can be disjoint even if they are happening at the same time <code>t</code>.</p>
<blockquote>
<p>For example, there are two meetings in the above-mentioned example. In the first meeting, we have <code>(x, y, z, w)</code> and in the second meeting, we have <code>(a, b)</code>. Both meetings are happening at the same time <code>t</code> but they are disjoint.</p>
</blockquote>
</li>
</ul>
<p>We are supposed to find and return the labels of all the people who know the secret after all the meetings have taken place.</p>
<p>The editorial systematically solves the problem using multiple approaches.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given that person <code>0</code> and <code>firstPerson</code> know the secret at time <code>t = 0</code>.</p>
<p>Let's restrict our attention to person <code>0</code> only.<br />
<em>(We may generalize our solution for <code>firstPerson</code> similarly)</em></p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_1.PNG" alt="p0" /></p>
<p><code>0</code> knows the secret at time <code>t = 0</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_2.PNG" alt="t0" /></p>
<p>Assume person <code>0</code> takes part in following meetings <code>[0, 1, 3]</code>, <code>[0, 2, 5]</code>, <code>[0, 3, 6]</code>, sorted in ascending order of time.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_3.PNG" alt="m0" /></p>
<p>Highlighted meetings take place <strong>after or at time <code>t = 0</code></strong>, the time at which person <code>0</code> learned the secret.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide2_1.PNG" alt="mt0" /></p>
<p>Hence we can say that all those persons corresponding to highlighted meetings will know the secret at the time of the meeting.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide2_2.PNG" alt="mp0" /></p>
<p>Now let's assume that person <code>1</code> takes part in the following meetings <code>[1, 4, 2]</code>, <code>[1, 9, 4]</code>. There is also a meeting <code>[1, 0, 3]</code>, but it has been processed already.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide3.PNG" alt="m1" /></p>
<p>Out of these two, only one meeting <code>[1, 9, 4]</code> takes place <strong>after or at time <code>t = 3</code></strong>, the time at which person <code>1</code> learned the secret, as per the current state of knowledge. Hence, we can say that only person <code>9</code> will know the secret after meeting <code>1</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide4.PNG" alt="mp1" /></p>
<p>Can we now say that person <code>4</code> will NEVER know the secret?<br />
No, we can't. Person <code>4</code> may know the secret in the future.</p>
<p>Hence, we can draft the following approach:</p>
<ul>
<li>
<p>We will start with person <code>0</code> and person <code>firstPerson</code>. They both know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Process people whom they meet after the time at which they learned the secret. All these people will know the secret at the time of the meeting.</p>
<p>Moreover, they will propagate the secret to people they meet after the time they learn the secret. Hence, process these individuals in the same manner as <code>0</code> and <code>firstPerson</code> were processed, except they learned the secret at a different time.</p>
</li>
<li>
<p>Repeat the above step until we have processed all the meetings.</p>
</li>
</ul>
<blockquote>
<p>We are processing persons in a <strong>level-by-level</strong> manner. Whenever we realize that a person knows the secret, we make sufficient efforts to process all the people whom he/she meets after the time at which he/she learned the secret, since we know that they will ultimately know the secret.</p>
<p><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/"><strong>Breadth First Search (BFS)</strong></a> is a natural choice to explore level by level, usually implemented with the help of the queue.<br />
It is a graph traversal algorithm that explores the neighbor nodes first, before moving to the next level neighbors. If readers are not familiar with the BFS, they are strongly encouraged to dive into our <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/"><strong>Queue Explore Card</strong></a> and <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/"><strong>Graph Explore Card</strong></a></p>
</blockquote>
<p>Readers are encouraged to implement the above approach. It is worth mentioning that in <code>meetings</code> we are given meetings in the form of <code>[x, y, t]</code>. However, we are interested that given <code>x</code>, we should be able to find the <code>(y, t)</code> pair for all the meetings in which <code>x</code> participated. Hence, we should use an appropriate data structure to store the information.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create a queue <code>q</code> to store the people whom we need to process. It will store <code>(person, time of knowing the secret)</code>.</p>
<p>Initially, we will add <code>(0, 0)</code> and <code>(firstPerson, 0)</code> to the queue since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create an <code>earliest</code> array of size <code>n</code>. It will store the earliest time at which a person learned the secret as per the current state of knowledge. It will be initialized with <code>INT.MAX</code> for all the people indicating that no one knows the secret.</p>
<p>However, for person <code>0</code> and <code>firstPerson</code>, we will update the <code>earliest</code> array with <code>0</code> since they know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Do the following while the <code>q</code> is not empty:</p>
<ol>
<li>
<p>Deque the front of <code>q</code> and store it in <code>(person, time)</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>earliest[nextPerson] &gt; t</code>, then update <code>earliest[nextPerson] = t</code> and add <code>(nextPerson, t)</code> to the queue.</p>
<blockquote>
<p>We are adding <code>(nextPerson, t)</code> to the queue because we have updated <code>earliest[nextPerson]</code> and we need to process all the people whom <code>nextPerson</code> meets after time <code>t</code>.</p>
</blockquote>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>earliest[nextPerson] &gt; t</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>earliest[nextPerson] &lt;= t</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>Iterate over the <code>earliest</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>earliest[i] != INT.MAX</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EpvjQ4P4/shared">code</a></p>
<p><strong>Implementation Note:</strong> The above implementation is slightly different from the standard <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth First Search</a>. In standard Breadth First Search, we never process a node twice, and we facilitate this by maintaining a separate <code>visited</code> array.</p>
<p>However, in the above implementation, we may process a node again if we get to know that the earliest time at which a person learns the secret decreases. To facilitate this we are maintaining the <code>earliest</code> array.</p>
<p>Let's assume we will NOT revisit a node.</p>
<pre><code class="language-testcase">4
[[0,1,4],[1,3,3],[2,1,2]]
2
</code></pre>
<p>This can be represented in the graph as follows. The green-colored people are those who initially know the secret.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_1.PNG" alt="graph" /></p>
<p>The front of the queue <code>(0, 0)</code> will be processed first. We will process person <code>0</code>, and will add its neighbors to the queue. Hence, <code>(1, 4)</code> will be added to the queue.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_2.PNG" alt="q0" /></p>
<p>Next in the queue is <code>(2, 2)</code>. We will process person <code>2</code>. However, all its neighbors are already processed. Hence, we will not add any new person to the queue.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_3.PNG" alt="q1" /></p>
<p>Next in the queue is <code>(1, 4)</code>. We will process person <code>1</code>, and due to state information, we will assume that it was informed of the secret at time <code>t = 4</code>. Hence, it can inform the secret only to those people it meets after time <code>t = 4</code>. However, it meets person <code>3</code> at time <code>t = 3</code>, hence we will not add person <code>3</code> to the queue.</p>
<p>Turns out we are incorrect. Person <code>1</code> was informed of the secret at time <code>t = 2</code>, because of meeting <code>[2, 1, 2]</code>. Hence, <code>1</code> can inform the secret to person <code>3</code> at time <code>t = 3</code>.</p>
<p>We are arriving at an incorrect answer because of the incorrect assumption that we will not revisit a node. Hence, we need to revisit a node if we realize that the earliest time at which a person learns the secret decreases.</p>
<blockquote>
<p><strong>Connecting the Dots:</strong> <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's algorithm</a> is used for finding shortest path in a graph. It works when the weights of edges are non-negative.</p>
<p>However, we can modify the algorithm to work for graphs where the weights of edges can be negative, but no negative cycle is present. The above algorithm captures the essence of the <strong>modified Dijkstra's algorithm</strong>. The key idea is to revisit a node if we realize that the shortest distance to a node decreases.</p>
<p>However, readers must note that this problem, ideally <strong>cannot</strong> be modeled as the shortest path problem, particularly because meeting time is not the weight of edges. What we have done is to use the idea of modified Dijkstra's algorithm to solve the problem.</p>
</blockquote>
<p>Readers should also note that since the initial queue contains more than one element, the process is often called <strong>Multi-Source BFS</strong></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \cdot (M + N) )\)</span></p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we are initializing <code>q</code> by enqueuing two people. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>earliest</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are dequeuing one element from <code>q</code>. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we iterate over neighbors of the dequeued element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and enqueuing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(1 + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was enqueued because of meeting with some other person. Hence, there will be at most <span class="math inline">\(M + N\)</span> iterations of the <code>while</code> loop.</p>
<p>Thus, the <code>while</code> loop takes <span class="math inline">\(O( (M + N) \cdot M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>earliest</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, total time complexity will be <span class="math inline">\(O(M + 1 + N + (M + N) \cdot M + N)\)</span>, which is <span class="math inline">\(O( M \cdot (M + N) )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>earliest</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>q</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the queue. It is worth noting that there can be multiple instances of person <code>x</code> in the queue, with multiple times of knowing the secret</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In <a href="#approach-1-breadth-first-search">previous approach</a>, we were essentially traversing the graph, keeping in mind the condition that we can visit a node only if we are confident that the person will know the secret at the time of the meeting. After traversal, we were returning indices of all the people who were visited.</p>
<p>The graph can be traversed primarily in two ways:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth First Search</a> using <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Queue</a></li>
<li><a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth First Search</a> using <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/">Stack</a></li>
</ul>
<p>In this approach, let's try to solve the problem using Depth First Search. It can be implemented using Recursion or Stack. It is worth noting that Recursion implicitly uses Call Stack.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create an <code>earliest</code> array of size <code>n</code>. It will store the earliest time at which a person learned the secret as per the current state of knowledge. It will be initialized with <code>INT.MAX</code> for all the people indicating that no one knows the secret.</p>
<p>However, for person <code>0</code> and <code>firstPerson</code>, we will update the <code>earliest</code> array with <code>0</code> since they know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create a stack <code>stack</code> to store the people whom we need to process. It will store <code>(person, time of knowing the secret)</code>.</p>
<p>Initially, we will add <code>(0, 0)</code> and <code>(firstPerson, 0)</code> to the stack since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Do the following while the <code>stack</code> is not empty:</p>
<ul>
<li>
<p>Pop the top of <code>stack</code> and store it in <code>(person, time)</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>earliest[nextPerson] &gt; t</code>, then update <code>earliest[nextPerson] = t</code> and add <code>(nextPerson, t)</code> to the stack.</p>
<blockquote>
<p>We are adding <code>(nextPerson, t)</code> to the stack because we have updated <code>earliest[nextPerson]</code> and we need to process all the people whom <code>nextPerson</code> meets after time <code>t</code>.</p>
</blockquote>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>earliest[nextPerson] &gt; t</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>earliest[nextPerson] &lt;= t</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Iterate over the <code>earliest</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>earliest[i] != INT.MAX</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ctKAU7Bo/shared">code</a></p>
<p><strong>Implementation Note:</strong> The above implementation is slightly different from the standard <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth First Search</a>. In standard Depth First Search, we never process a node twice, and we facilitate this by maintaining a separate <code>visited</code> array.</p>
<p>However, in the above implementation, we may process a node again if we get to know that the earliest time at which a person learns the secret decreases. To facilitate this, we are maintaining the <code>earliest</code> array. We are doing this for the same reason mentioned in <a href="#implementation">previous approach</a>.</p>
<p>Here is the implementation using Recursion.</p>
<p><a href="https://leetcode.com/playground/8yJEFXxD/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \cdot (M + N) )\)</span></p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>earliest</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are popping one element from <code>stack</code>. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we iterate over neighbors of the popped element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and pushing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(1 + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was pushed because of meeting with some other person. Hence, there will be at most <span class="math inline">\(M + N\)</span> iterations of the <code>while</code> loop.</p>
<p>Thus, the <code>while</code> loop takes <span class="math inline">\(O( (M + N) \cdot M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>earliest</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M + N + (M + N) \cdot M + N)\)</span>, which is <span class="math inline">\(O( M \cdot (M + N) )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>earliest</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>stack</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the stack. It is worth noting that there can be multiple instances of person <code>x</code> in the stack, with multiple times of knowing the secret.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-earliest-informed-first-traversal">Approach 3: Earliest Informed First Traversal</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's revisit the <a href="#approach-1-breadth-first-search">Approach 1</a>, and particularly the test case discussed in <a href="#implementation">Implementation Note</a>.</p>
<pre><code class="language-testcase">4
[[0,1,4],[1,3,3],[2,1,2]]
2
</code></pre>
<p>If we process each node exactly once, then we will arrive at the incorrect answer. The reason was that person <code>1</code> could know the secret through two different meetings.<br />
<strong>(a)</strong> <code>[0, 1, 4]</code>, from person <code>0</code> at time <code>t = 4</code><br />
<strong>(b)</strong> <code>[2, 1, 2]</code>, from person <code>2</code> at time <code>t = 2</code></p>
<p>If we process the meeting <strong>(a)</strong> before meeting <strong>(b)</strong>, then we will arrive at the incorrect answer.</p>
<p>What if we process the meeting <strong>(b)</strong> before meeting <strong>(a)</strong>? Will we arrive at the correct answer?<br />
Yes, we will, at least for this test case.</p>
<p>In general, we must process that person in the queue whose time of knowing the secret is the minimum. We will dequeue the person with the minimum time of knowing the secret. Moreover, <strong>the person should be marked as visited after it is dequeued from the queue (and not when it is enqueued) because the time the person is enqueued might not be the earliest time the person learned the secret, but the time the person is dequeued will be the earliest time a person learned the secret</strong>. This way, we are ensuring that given a person, if he/she learned the secret through multiple meetings, then we will process the earliest meeting first.</p>
<p>For efficiently dequeuing the person with the minimum time of knowing the secret, we may use <a href="https://leetcode.com/explore/learn/card/heap/">Binary Heap</a> with Min Heap property.</p>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/heap/"><strong>Binary Heap</strong></a> is a specialized binary tree-based data structure that is a complete tree that satisfies the heap property.</p>
<p>In a Min-Heap, the key at the root must be minimum among all keys present in the Binary Heap. The same property must be recursively true for all nodes in the Binary Tree. We can pop and push elements in time proportional to the logarithm of the number of elements present in the heap.</p>
</blockquote>
<blockquote>
<p>The approach is similar to <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's algorithm</a> with a notable difference that the weight of edges represents absolute time and not the time difference.</p>
</blockquote>
<p>Readers are encouraged to implement this approach.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create a priority queue (min-heap) <code>pq</code> to store the people whom we need to process. It will store <code>(time of knowing the secret, person)</code>.</p>
<p>The <code>time of knowing the secret</code> will be used to maintain the Min Heap property. The person with minimum <code>time of knowing the secret</code> will be at the top of the heap.</p>
</li>
<li>
<p>Push <code>(0, 0)</code> and <code>(0, firstPerson)</code> to the queue since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create a <code>visited</code> array of size <code>n</code>. It will store if a person is visited or not. Initially, all the people are not visited.</p>
<p>We will mark a person as visited after it is popped from the queue. This will be the earliest time at which a person learns the secret because we are processing the person with the minimum time of knowing the secret.</p>
</li>
<li>
<p>Do the following while the <code>pq</code> is not empty:</p>
<ol>
<li>
<p>Deque the front of <code>pq</code> and store it in <code>(time, person)</code>.</p>
</li>
<li>
<p>If <code>visited[person]</code> is <code>True</code>, then continue to the next iteration of the <code>while</code> loop. We have already processed <code>person</code> at an earlier time, and we don't need to process it again.</p>
</li>
<li>
<p>Mark <code>visited[person]</code> as <code>True</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>visited[nextPerson]</code> is <code>False</code>, then push <code>(t, nextPerson)</code> to the queue.</p>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>visited[nextPerson]</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>visited[nextPerson]</code> is <code>True</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>Iterate over the <code>visited</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>visited[i]</code> is <code>True</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/W6xzxQjv/shared">code</a></p>
<p><strong>Implementation Note:</strong> In <code>for</code> loop under <code>while</code>, we are checking every <code>(t, nextPerson)</code> pair of <code>graph[person]</code> to find all those <code>t &gt;= time</code>, where <code>time</code> is earliest time person learned the secret.</p>
<p>However, if <code>graph[person]</code> was sorted in increasing order of <code>t</code>, then instead of starting from the very beginning of <code>graph[person]</code>, we can start from the index where <code>t &gt;= time</code>. This index can be found using <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search</a> because <code>graph[person]</code> is sorted. This will reduce the number of iterations of the <code>for</code> loop. Readers are encouraged to implement this optimization and comment on their implementation.</p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( (N + M) \log (N + M) + N M )\)</span>.</p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we are initializing min-heap <code>pq</code> by enqueuing two people. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>visited</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are popping one element from <code>pq</code>. It will take <span class="math inline">\(O(\log (N + M))\)</span> time because, at any instance, there can be at most <span class="math inline">\(N + M\)</span> elements in the heap.</p>
</li>
<li>
<p>Then we iterate over neighbors of the popped element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and pushing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(\log (N + M) + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was enqueued because of meeting with some other person. Hence, there will be at most <span class="math inline">\(N + M\)</span> iterations of the <code>while</code> loop.</p>
<p>However, we will process the <code>for</code> loop only for those neighbors of a person who has not been visited. Hence, the <code>for</code> loop of time complexity <span class="math inline">\(O(M)\)</span> will run for at most <span class="math inline">\(N\)</span> iterations of the <code>while</code> loop.</p>
<ul>
<li>
<p>Thus, for <span class="math inline">\(N\)</span> iterations of the <code>while</code> loop, it will take <span class="math inline">\(O( \log (N + M) + M )\)</span> time.</p>
</li>
<li>
<p>For <span class="math inline">\(M\)</span> iterations of the <code>while</code> loop, it will take <span class="math inline">\(O( \log (N + M))\)</span> time. The <code>for</code> loop will not run for these iterations.</p>
</li>
</ul>
<p>Thus, <code>while</code> loop takes <span class="math inline">\(O( N \cdot ( \log (N + M) + M )  + M \cdot \log (N + M) )\)</span> time, which is <span class="math inline">\(O( N \cdot \log (N + M) + N \cdot M + \log (N + M) \cdot M )\)</span> time. This can be rearranged as <span class="math inline">\(O(  (N + M) \log (N + M) + N M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>visited</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, total time complexity will be <span class="math inline">\(O(M + 1 + N + (N + M) \log (N + M) + N M + N)\)</span>, which is <span class="math inline">\(O( (N + M) \log (N + M) + N M )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>pq</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the queue. It is worth noting that there can be multiple instances of person <code>x</code> in the queue, with multiple times of knowing the secret.</p>
</li>
<li>
<p>The <code>visited</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-breadth-first-search-on-time-scale">Approach 4: Breadth First Search on Time Scale</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let's minutely analyze an arbitrary meeting <code>[x, y, t]</code>:</p>
<ul>
<li>
<p>If any one of <code>x</code> or <code>y</code> were informed the secret <strong>before or at time <code>t</code></strong>, then both <code>x</code> and <code>y</code> will know the secret at time <code>t</code>.</p>
<blockquote>
<p>This will be true for all participants of all transitive meetings happening at time <code>t</code> as well.</p>
</blockquote>
<blockquote>
<p>However, for disjoint meetings happening at the time <code>t</code>, this may or may not be true. To decide on disjoint meetings, we need to separately analyze each disjoint meeting at the time <code>t</code>.</p>
</blockquote>
</li>
<li>
<p>If none of <code>x</code> and <code>y</code> <em>(or as a general case, no participant of transitive meeting)</em> were informed the secret <strong>before or at time <code>t</code></strong>, then none of <code>x</code> and <code>y</code> <em>(or as a general case, no participant of transitive meeting)</em> will know the secret at time <code>t</code>.</p>
<blockquote>
<p>However, for disjoint meetings happening at the time <code>t</code>, this may or may not be true. To decide on disjoint meetings, we need to separately analyze each disjoint meeting at the time <code>t</code>.</p>
</blockquote>
<p>Let's assume that one participant of a transitive meeting gets to know the secret <strong>after time <code>t</code></strong>. It is worth noting that knowing after time <code>t</code> will not affect meetings happening at the time <code>t</code>.</p>
<p>More particularly, if none of <code>x</code> and <code>y</code> knew the secret <strong>before or at the time <code>t</code></strong>, and assume one of them gets to know the secret <strong>after time <code>t</code></strong>, then it will not affect meeting <code>[x, y, t]</code>.</p>
</li>
</ul>
<p>From minutely analyzing, we can agree on the fact that processing <code>meetings</code> in ascending order of <code>t</code> will be helpful.<br />
<em>We also incorporated this fact in <a href="#approach-3-earliest-informed-first-traversal">previous approach</a></em>.</p>
<p>Moreover, we should consider all meetings happening at the same time <code>t</code> together.</p>
<p>Assume at a time <code>t</code>, we have <code>[x, y], [y, z], [z, w], [a, b], [c, d], [d, e]</code> meetings taking place. We can form the following three groups of people meeting each other at the time <code>t</code>.</p>
<ul>
<li><code>[x, y, z, w]</code>: If any one of these four knows the secret, then all of them will get to know the secret.</li>
<li><code>[a, b]</code>: If any one of these two knows the secret, then both of them will get to know the secret.</li>
<li><code>[c, d, e]</code>: If any one of these three knows the secret, then all of them will get to know the secret.</li>
</ul>
<p>Thus at every timestamp <code>t</code>, we can do graph traversal to <strong>find all those people to whom the secret can propagate</strong>. The traversal will be started by people who already know the secret at the time <code>t</code>. We need to do so in increasing order of time <code>t</code>.</p>
<p>For traversal, we can do either BFS or DFS. The purpose of traversal is to find the connectedness of the graph at a particular time.</p>
<p>We, in this approach, will use BFS to find the connectedness of the graph at a particular time and leave DFS as an exercise for readers.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Sort <code>meetings</code> in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a HashMap <code>sameTimeMeetings</code> for grouping meetings happening at the same time <code>t</code>. The key of HashMap will be time <code>t</code>, and the value will be a list of <code>(x, y)</code> pairs.</p>
<p>Make sure that <code>sameTimeMeetings</code> remembers the order of insertion, since we are inserting meetings in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a Boolean Array <code>knowsSecret</code> of size <code>n</code>. It will tell if a person knows the secret or not.</p>
<p>Initially, only person <code>0</code> and <code>firstPerson</code> knows the secret. Hence, mark <code>knowsSecret[0]</code> and <code>knowsSecret[firstPerson]</code> as <code>True</code>.</p>
</li>
<li>
<p>Iterate over <code>sameTimeMeetings</code> in increasing order of <code>t</code>. Let's say <code>t</code> is the time.</p>
<ul>
<li>
<p>For each person, save all the people whom he/she meets at the time <code>t</code> in a HashMap <code>meet</code>. The key of HashMap will be person, and value will be a list of people whom he/she meets at the time <code>t</code>.</p>
</li>
<li>
<p>Create a set <code>q</code>. Add to <code>q</code> those people who have some meeting scheduled at time <code>t</code>, and who already know the secret at time <code>t</code>.</p>
<blockquote>
<p>We are using <code>set</code> to avoid redundancy. A person can be in multiple meetings, so to avoid adding the same person multiple times, we are using <code>set</code>.</p>
</blockquote>
</li>
<li>
<p>Convert set <code>q</code> to queue <code>q</code> to do BFS.</p>
</li>
<li>
<p>While <code>q</code> is not empty, do the following:</p>
<ul>
<li>
<p>Dequeue the front of <code>q</code> and store it in <code>person</code>.</p>
</li>
<li>
<p>Iterate over all those persons whom <code>person</code> meets at the time <code>t</code>. Let's say the person is <code>nextPerson</code>.</p>
<p>If <code>knowsSecret[nextPerson]</code> is <code>False</code>, then mark <code>knowsSecret[nextPerson]</code> as <code>True</code> and enqueue <code>nextPerson</code> to <code>q</code>.</p>
<p>This is because after meeting <code>person</code> at a time <code>t</code>, <code>nextPerson</code> will know the secret at the time <code>t</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate over the <code>knowsSecret</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>knowsSecret[i]</code> is <code>True</code>.</p>
</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/FGJS7GCK/shared">code</a></p>
<p><strong>Implementation Note:</strong> For every <code>t</code>, the initial queue is created using <code>set</code> to avoid redundancy. We are populating the initial queue using meetings. A person can be in multiple meetings, so to avoid adding the same person multiple times, we are using <code>set</code>.</p>
<p>Afterward, the queue is populated only when the person doesn't know the secret, and as soon as we populate, we mark the person as known. Hence, there won't be redundancy in the queue.</p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \log M + N )\)</span></p>
<ul>
<li>
<p>Sorting <code>meetings</code> will take <span class="math inline">\(O(M \log M)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and takes <span class="math inline">\(O(M \log M)\)</span> time in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Populating <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>knowsSecret</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Then there is a <code>for</code> loop. The number of iterations of the <code>for</code> loop depends on the number of unique meeting times. It will be at most <span class="math inline">\(M\)</span>. Let's narrow our analysis to one iteration of the <code>for</code> loop.</p>
<ul>
<li>
<p>Creating <code>meet</code> and initiating <code>q</code> may vary from <span class="math inline">\(O(1)\)</span> time to <span class="math inline">\(O(M)\)</span> time, depending on the number of meetings happening at the time <code>t</code>. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
<p>(<strong>Amortized time complexity</strong> is the time taken per operation averaged over all operations)</p>
<blockquote>
<ul>
<li>If one iteration of creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(1)\)</span> time (when a single meeting is happening at the time <code>t</code>), then there may be the next iteration of the <code>for</code> loop. However, it will be limited to <span class="math inline">\(M\)</span> iterations.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>If one iteration of creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(M)\)</span> time, then there will be no next iteration of the <code>for</code> loop because all meetings happening will get processed in the current iteration.</li>
</ul>
</blockquote>
<blockquote>
<p>Hence, when creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(1)\)</span> time, the number of <code>for</code> loop iterations will be <span class="math inline">\(O(M)\)</span>. When creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(M)\)</span> time, the number of <code>for</code> loop iterations will be <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
<p>Thus, the amortized time complexity for creating <code>meet</code> and initiating <code>q</code> per iteration of the <code>for</code> loop will be <span class="math inline">\(O(1)\)</span></p>
</li>
<li>
<p>The BFS may take <span class="math inline">\(O(N)\)</span> time in the worst case because, at any instance, there can be at most <span class="math inline">\(N\)</span> nodes in the queue. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
<blockquote>
<ul>
<li>If every meeting time has only <span class="math inline">\(2\)</span> participants, then there will be <span class="math inline">\(O(M)\)</span> unique meeting times deciding the number of iterations of the <code>for</code> loop. In each iteration of the <code>for</code> loop, there will be <span class="math inline">\(O(2)\)</span> people in the queue. Hence, the time complexity will be <span class="math inline">\(O(2 \cdot M)\)</span> which is <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>If every meeting time has <span class="math inline">\(N\)</span> participants, then there will be <span class="math inline">\(O(\frac{M}{N})\)</span> unique meeting times deciding the number of iterations of the <code>for</code> loop. In each iteration of the <code>for</code> loop, there will be <span class="math inline">\(O(N)\)</span> people in the queue. Hence, the time complexity will be <span class="math inline">\(O(N \cdot \frac{M}{N})\)</span> which is <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</blockquote>
<p>Thus, the amortized time complexity of BFS per iteration of the <code>for</code> loop will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Thus, each iteration of the <code>for</code> loop will take amortized <span class="math inline">\(O(1)\)</span> time for creating <code>meet</code>, initiating <code>q</code>, and BFS.</p>
</li>
</ul>
</li>
<li>
<p>Finally, we are iterating over the <code>knowsSecret</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M \log M + M + N + M \cdot 1 + N)\)</span>, which is <span class="math inline">\(O( M \log M + N )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>We are sorting the <code>meetings</code> array in place. When we sort an array in place, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(M)\)</span> space in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>The <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>knowsSecret</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>meet</code> HashMap will take <span class="math inline">\(O(M)\)</span> space per iteration of <code>for</code> loop. After iteration, it will be empty. Hence, the total space complexity will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
<li>
<p>The <code>q</code> may grow up to <span class="math inline">\(O(N)\)</span> per iteration of the <code>for</code> loop because any person can be in the queue at most once. After iteration, it will be empty. Hence, the total space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-union-find-with-reset">Approach 5: Union-Find with Reset</h3>
<h4 id="intuition-4">Intuition</h4>
<p>In the <a href="#intuition-3">intuition of the previous approach</a>, we noted the following.</p>
<blockquote>
<p>The purpose of traversal is to find the connectedness of the graph at a particular time.</p>
</blockquote>
<p>We initiated traversal from people who already knew the secret at the time <code>t</code>.</p>
<p>Instead of doing traversal, we can use <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union-Find</a> to find the connectedness of the graph at a particular time. For each person taking part in a meeting, we can union the person with the other person taking part in the meeting, and check if they are connected to any person who already knows the secret, one such person being <code>0</code>.</p>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/"><strong>Union-Find</strong></a>, also known as <strong>Disjoint Set</strong>, is a data structure that keeps track of elements that are split into one or more disjoint sets. It provides near-constant-time operations to add new sets, merge existing sets, and determine whether elements are in the same set.</p>
<p>If readers are not familiar with Union-Find, then they are encouraged to visit <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/"><strong>Union-Find Explore Card</strong></a> to learn about it. It includes the heuristics to optimize the Union-Find data structure.</p>
<ul>
<li><em>union by rank</em> (height) or <em>union by size</em>. We can use either of these.</li>
<li><em>path compression</em></li>
</ul>
<p>We, in this approach, will use <strong>Union by Rank</strong> and <strong>Path Compression</strong> heuristics to optimize the Union-Find data structure.</p>
</blockquote>
<p>Thus, in this approach, we will process meetings in increasing order of time <code>t</code>, and for each meeting <code>[x, y]</code>, we will unite the two persons.</p>
<p>After performing all the unions, we will again visit all <code>[x, y]</code>, and check if any one of them is connected to <code>0</code> or not <em>(if any of them is connected to <code>0</code>, then both of them will be connected to <code>0</code> because we united them)</em>. If yes, then both of them will end up knowing the secret.</p>
<p>At the end, we will return indices of all the people who know the secret.</p>
<p>Is that enough? Let's try to find out through an example.</p>
<pre><code class="language-testcase">6
[[2, 3, 1], [1, 2, 2], [3, 4, 3], [5, 4, 4], [5, 0, 4]]
1
</code></pre>
<p>The <code>meetings</code> are already sorted in increasing order of <code>t</code>. Initially, our graph looks like the following. <code>1</code> is connected to <code>0</code>, because <code>1</code> is the <code>firstPerson</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_1.PNG" alt="t0" /></p>
<p>After meeting <code>[2, 3, 1]</code>, one more connection is added to the graph. However, both of them are not connected to <code>0</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_2.PNG" alt="t1" /></p>
<p>Let's process the next meeting <code>[1, 2, 2]</code>. After this meeting, <code>2</code> will get connected to <code>0</code>, because <code>1</code> is already connected to <code>0</code>. Thus, <code>2</code> will know the secret.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_3.PNG" alt="t2" /></p>
<p>The third meeting <code>[3, 4, 3]</code> will add a connection between <code>3</code> and <code>4</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_4.PNG" alt="t3" /></p>
<p>Now <code>3</code> was already connected to <code>0</code>, but <code>3</code> doesn't know the secret yet. However, it got connected to <code>0</code> because <code>2</code> got connected to <code>0</code> after the second meeting, and <code>3</code> had met <code>2</code> in the first meeting. However, this is incorrect. <code>3</code> technically doesn't know the secret yet.</p>
<p>Hence, it seems connection with <code>0</code> is not enough. We may need to maintain a flag array <code>knowsSecret</code> to mark if a person knows the secret or not, which is indicated by the green color in the above figures.</p>
<p>Let's process further to see if it will work or not!</p>
<p>We have two meetings taking place at time <code>t = 4</code>. Their union is represented by red color in the following figure.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_5.PNG" alt="t4" /></p>
<p>Now, we will revisit every meeting at time <code>t = 4</code> again. The first one being <code>[5, 4, 4]</code>. Both of them are connected to <code>0</code>, but none of them knows the secret. Hence, we will not mark them as known. However, this is incorrect. Ideally, both of them should know the secret.</p>
<p>If we had visited <code>[5, 0, 4]</code> first, then we would have marked <code>5</code> as known, and then we would have visited <code>[5, 4, 4]</code>, and marked <code>4</code> as known.</p>
<p>However, given the fixed time, we don't have devised any strategy to visit meetings in a particular order.</p>
<p>We can overcome this by doing two passes after uniting, at least for this test case. However, to guarantee it to work every time, we must do as many passes as the number of meetings at that fixed time. This isn't efficient!</p>
<p>Thus, introducing the <code>knowsSecret</code> flag array doesn't seem to lead to an efficient solution.</p>
<p><strong>We need to proceed only with the fact that if a person is connected to <code>0</code>, then he/she knows the secret.</strong></p>
<p>In <a href="#intuition-3">intuition of the previous approach</a>, we noted the following.</p>
<blockquote>
<p>Let's assume that one participant of a transitive meeting gets to know the secret <strong>after time <code>t</code></strong>. It is worth noting that knowing after time <code>t</code> will not affect meetings happening at the time <code>t</code>.</p>
<p>More particulary, if none of <code>x</code> and <code>y</code> knew the secret <strong>before or at time <code>t</code></strong>, and assume one of them gets to know the secret <strong>after time <code>t</code></strong>, then it will have no effect on meeting <code>[x, y, t]</code>.</p>
</blockquote>
<p>Let's focus more on the last sentence of the above quote. If none of them knew the secret, then meeting <code>[x, y, t]</code> will not have any effect on them. To trigger the effect of the meeting, we united <code>x</code> and <code>y</code> using the Union-Find data structure.</p>
<p><strong>What to do to dissolve the effect?</strong><br />
Well, we can do the opposite of uniting them. We can disunite <code>x</code> and <code>y</code> into single components.</p>
<p>Since even after doing all the unions, they weren't able to receive the secret, all the meetings happening at or before the time <code>t</code> were not able to propagate the secret to them. Hence, we can safely disunite them.</p>
<p>Now to disunite them into single components, we just need to reset the initial properties of Union-Find. We need to do this only for these two persons.</p>
<p>After processing all the <code>meetings</code>, all those persons who are connected to <code>0</code> will know the secret.</p>
<p>Here is the animation explaining the approach for the following input.</p>
<pre><code class="language-input">6
[[2, 3, 1], [1, 2, 2], [3, 4, 3], [5, 4, 4], [5, 0, 4]]
1
</code></pre>
<p>!?!../Documents/2092/2092_slideshow_union_find.json:960,540!?!<br />
<br/></p>
<p>It is worth noting that we don't need a separate flag array <code>knowsSecret</code>. Connection with <code>0</code> is enough to conclude that a person knows the secret. That's why the above animation doesn't highlight with green color.</p>
<p>With this intuition, let's discuss the implementable algorithm.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ol>
<li>
<p>Define a class <code>UnionFind</code> to implement the Union-Find data structure.</p>
<p>The <strong>constructor</strong> of <code>UnionFind</code> will take <code>n</code> as input, and initialize <code>parent</code> and <code>rank</code> arrays of size <code>n</code>. The <code>parent</code> array will store the parent of each node, and the <code>rank</code> array will store the rank of each node.</p>
<p>Initially, every node is the parent of itself, and the rank of every node is <code>0</code>.</p>
<p>It will have the following <strong>methods</strong>:</p>
<ul>
<li>
<p><code>find(x)</code>: Find the parent of node <code>x</code>. It will use the <em>Path Compression</em> heuristic.</p>
</li>
<li>
<p><code>unite(x, y)</code>: Unite two nodes <code>x</code> and <code>y</code>. It will use the <em>Union by Rank</em> heuristic.</p>
</li>
<li>
<p><code>connected(x, y)</code>: Check if two nodes <code>x</code> and <code>y</code> are connected or not.</p>
</li>
<li>
<p><code>reset(x)</code>: Reset the initial properties of node <code>x</code>. It will set the parent of node <code>x</code> to <code>x</code>, and the rank of node <code>x</code> to <code>0</code>.</p>
</li>
</ul>
</li>
<li>
<p>Sort <code>meetings</code> in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a HashMap <code>sameTimeMeetings</code> for grouping meetings happening at the same time <code>t</code>. The key of HashMap will be time <code>t</code>, and the value will be a list of <code>(x, y)</code> pairs.</p>
<p>Make sure that <code>sameTimeMeetings</code> remembers the order of insertion, since we are inserting meetings in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a <code>graph</code>. It will be an instance of the <code>UnionFind</code> class and will have <code>n</code> nodes.</p>
</li>
<li>
<p>Unite <code>firstPerson</code> with <code>0</code> in <code>graph</code>.</p>
</li>
<li>
<p>Process <code>sameTimeMeetings</code> in increasing order of <code>t</code>. Let's say <code>t</code> is the time.</p>
<ul>
<li>
<p>Unite all two persons taking part in a meeting.</p>
</li>
<li>
<p>If any one of them is connected to <code>0</code>, then both of them will be connected to <code>0</code>.</p>
<p>Similarly, if any one of them is NOT connected to <code>0</code>, then both of them will be NOT connected to <code>0</code>, since they were united among themselves. In this case, we need to reset them.</p>
</li>
</ul>
</li>
<li>
<p>Return indices of all those people who are connected to <code>0</code> in the <code>graph</code>.</p>
</li>
</ol>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/b4ZMoceH/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Before analyzing the time complexity, let's first understand the time complexity of Union-Find. If an instance of Union-Find is created with <span class="math inline">\(\text{nodes}\)</span>, then the following are the time complexities of Union-Find methods:</p>
<blockquote>
<ul>
<li><strong>Constructor</strong>: <span class="math inline">\(O(\text{nodes})\)</span>, because we are initializing <code>parent</code> and <code>rank</code> arrays of size <span class="math inline">\(\text{nodes}\)</span>. However, the constructor is called only once.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>find(x)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>unite(x, y)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>connected(x, y)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>In actuality, the time complexity of the above three methods after using <em>Path Compression</em> and <em>Union by Rank</em> heuristics is <span class="math inline">\(O\left( \boldsymbol{\alpha}(\text{nodes}) \right)\)</span> time, where <span class="math inline">\(\boldsymbol{\alpha}\)</span> is <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse">Inverse Ackermann Function</a>. However, <span class="math inline">\(\boldsymbol{\alpha}(\text{nodes})\)</span> is less than <span class="math inline">\(5\)</span> for all practical purposes. More <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3843/">here</a></p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li><code>reset(x)</code>: It is <span class="math inline">\(O(1)\)</span> time because we are just resetting the initial properties of node <code>x</code>.</li>
</ul>
</blockquote>
<p>For analyzing the time complexity of our algorithm, let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \log M + N)\)</span></p>
<ul>
<li>
<p>Sorting <code>meetings</code> will take <span class="math inline">\(O(M \log M)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and takes <span class="math inline">\(O(M \log M)\)</span> time in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Populating <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Creating <code>graph</code> will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Uniting <code>firstPerson</code> with <code>0</code> will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Upon looking at the <code>for</code> loop, we can observe that we will process each meeting exactly twice, once for uniting, and once while checking if any one of them is connected to <code>0</code> or not.</p>
<ul>
<li>
<p>For uniting, it will be amortized <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>For checking if any one of them is connected to <code>0</code> or not, it will be amortized <span class="math inline">\(O(1)\)</span> time. Resetting, if required, will be <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity of the <code>for</code> loop will be <span class="math inline">\(O(2 \cdot M \cdot 1)\)</span>, which is <span class="math inline">\(O(M)\)</span>.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>graph</code> to find indices that are connected to <code>0</code>. It will take <span class="math inline">\(O(N \cdot 1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M \log M + M + N + M + N)\)</span>, which is <span class="math inline">\(O( M \log M + N )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>We are sorting the <code>meetings</code> array in place. When we sort an array in place, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(M)\)</span> space in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>The <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(N)\)</span> space for <code>parent</code> and <code>rank</code> arrays.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<p>As a challenge, try to implement the <a href="#implementation-4">Union-Find approach</a> <em>without</em> using the <code>sameTimeMeetings</code> HashMap! We perhaps may need some iterators to process all the meetings happening at the same time. Readers can comment their code below.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-safe-walk-through-a-grid/description" target="_blank" rel="noopener noreferrer">Find a Safe Walk Through a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code> and an integer <code>health</code>.</p>

<p>You start on the upper-left corner <code>(0, 0)</code> and would like to get to the lower-right corner <code>(m - 1, n - 1)</code>.</p>

<p>You can move up, down, left, or right from one cell to another adjacent cell as long as your health <em>remains</em> <strong>positive</strong>.</p>

<p>Cells <code>(i, j)</code> with <code>grid[i][j] = 1</code> are considered <strong>unsafe</strong> and reduce your health by 1.</p>

<p>Return <code>true</code> if you can reach the final cell with a health value of 1 or more, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png" style="width: 301px; height: 121px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>A minimum of 4 health points is needed to reach the final cell safely.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png" style="width: 361px; height: 161px;" /></div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png" style="width: 181px; height: 121px;" /></p>

<p>Any path that does not go through the cell <code>(1, 1)</code> is unsafe since your health will drop to 0 when reaching the final cell.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code><font face="monospace">2 &lt;= m * n</font></code></li>
	<li><code>1 &lt;= health &lt;= m + n</code></li>
	<li><code>grid[i][j]</code> is either 0 or 1.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-bottom-left-tree-value/description" target="_blank" rel="noopener noreferrer">Find Bottom Left Tree Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" style="width: 302px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" style="width: 432px; height: 421px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,null,5,6,null,null,7]
<strong>Output:</strong> 7
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to find the leftmost value at the bottom level of the tree. We are provided with the root of the tree.</p>
<p>Since we need to find a specific value at the bottom of a tree, we will need to traverse the tree, searching for the leftmost node at the bottom level. When we find that node, we can return its value.</p>
<blockquote>
<p>If you are not familiar with tree traversal, check out our <a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/">Explore Card</a></p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find the leftmost node in the bottom level of the tree. As we are concerned with the bottom level specifically, we will need to keep track of the current level/depth as we traverse.</p>
<p>One of the primary ways to traverse a tree is a Depth-First Search (DFS). We will use this approach to search for the leftmost node in the bottom level because it will be easy to keep track of the depth. We will use a preorder traversal, visiting each subtree's root first so that we can keep track of the level and visiting the left child first so that when we get to a new depth, we know that the current node is the leftmost node of that level.</p>
<p>Binary trees are often traversed using recursive methods. Below is an example pseudocode for a preorder traversal.</p>
<h5 id="standard-recursive-preorder-traversal">Standard Recursive Preorder Traversal</h5>
<ol>
<li>If the tree is empty, return.</li>
<li>Handle the root.</li>
<li>Traverse the left subtree - call Preorder(root.left).</li>
<li>Traverse the right subtree - call Preorder(root.right).</li>
</ol>
<p>Below is an example tree, with each level's depth labeled.</p>
<p><img src="../Figures/513/513_1.png" alt="Binary Tree with [1, 2, 3, 4, null, 5, 6, null, null, 7]" /></p>
<p>A preorder traversal visits the nodes in this order: 1, 2, 4, 3, 5, 7, 6.</p>
<p>We can implement a recursive function <code>dfs</code> to search for the leftmost node in the bottom level, which we will call <code>bottomLeftValue</code>.</p>
<p>Generally, when working recursively with trees, the base case is when the tree is empty. If the current node is empty, we return.</p>
<p>From there, we can build the rest of our recursive function <code>dfs</code>. We keep track of the deepest level of the tree we have encountered so far in <code>maxDepth</code>. We store the value of the deepest leftmost node we have found thus far in <code>bottomLeftValue</code>. To perform a pre-order traversal, we first handle the root, then recursively search the left subtree, then the right subtree. Each time we recursively call <code>dfs</code>, we increment the depth by one because the left or right child of the current node is one level deeper than the current node. When we visit the current node, we will check if it is deeper than any node we have discovered yet. If the current node is the deepest we have found so far, we have discovered a new level of the tree. We visit nodes to the left first, so we know this is the leftmost node in this level. We can update <code>bottomLeftValue</code> to the current node's value and also update <code>maxDepth</code>.</p>
<p>After defining <code>dfs</code>, all we have to do to solve the problem is call the function and then return `bottomLeftValue``.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a variable <code>maxDepth</code> to store the depth of the bottom level of the tree.</li>
<li>Initialize a variable <code>bottomLeftValue</code> to store the leftmost value in the last row of the tree.</li>
<li>Implement a recursive function, <code>dfs</code>, that traverses the tree and finds the leftmost value in the last row of the tree. The parameters are <code>current</code>, the current node, and <code>depth</code>, its depth.
<ol>
<li>Check whether <code>current</code> is empty. If so, return.</li>
<li>Check if the current depth exceeds the global variable <code>maxDepth</code>. If it does, that means we have found a new level.
<ol>
<li>Set <code>maxDepth</code> to <code>depth</code>.</li>
<li>Set <code>bottomLeftValue</code> to the value of the current node.</li>
</ol>
</li>
<li>Recursively call <code>dfs</code> on the current node's left subtree and increment <code>depth</code> by one.</li>
<li>Recursively call <code>dfs</code> on the current node's right subtree and increment <code>depth</code> by one.</li>
</ol>
</li>
<li>Call <code>dfs</code> with <code>root</code> and the initial <code>depth</code> of <code>0</code>.</li>
<li>Return <code>bottomLeftValue</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/795bdDWi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Traversing the tree with a DFS costs <span class="math inline">\(O(n)\)</span> as we visit each node exactly once. At each visit, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of DFS, when implemented recursively, is determined by the maximum depth of the call stack, which corresponds to the depth of the tree. In the worst case, if the tree is entirely unbalanced (e.g., a linked list), the call stack can grow as deep as the number of nodes, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-right-to-left">Approach 2: Breadth-First Search Right to Left</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The other primary way to traverse a tree is a Breath-First Search (BFS). This traversal method, also known as level-order traversal, could apply to this problem because the algorithm visits all the nodes in each level before moving on to the next level. BFS could be helpful because we are concerned with the last level specifically, and visiting the levels in order means that the final nodes we encounter are on the bottom level. The general algorithm for Breadth-First Search is below.</p>
<h5 id="standard-breadth-first-search">Standard Breadth-First Search</h5>
<ol>
<li>Create a queue for storing the nodes on each level.</li>
<li>Add the root node to the queue.</li>
<li>While the queue is not empty:
<ol>
<li>Remove the front node of the queue.</li>
<li>Handle the node and add its children to the back of the queue.</li>
</ol>
</li>
</ol>
<p>Below is an example tree to visualize how BFS works.</p>
<p><img src="../Figures/513/513_2.png" alt="Binary Tree with [1, 2, 3, 4, null, 5, 6, null, null, 7]" /></p>
<p>Breath First Search visits the nodes in this order: 1, 2, 3, 4, 5, 6, 7.</p>
<p>In the depth-first search implementation above, we kept track of the depth and <code>maxDepth</code> of the tree using a variable. We could use the same strategy to track the depth during the BFS, but it may not be necessary. BFS performs a level order search, meaning the last nodes we encounter will be on the bottom level. We are searching for the leftmost node in the bottom level of the tree.</p>
<blockquote>
<p>How can we find the leftmost node in the bottom level?</p>
</blockquote>
<p>BFS of a tree is often implemented such that the left child of a given node is visited first, then the right child. If we implement BFS such that the right child of a given node is visited first, then the left child, the last node we visit is the leftmost node in the bottom level of the tree. This makes a variable for depth unnecessary. We can just return the value of the last node we encounter during the search.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a Queue <code>queue</code> for storing the nodes on each level.</li>
<li>Create a new node <code>current</code> and set it to <code>root</code>.</li>
<li>Add <code>current</code> to <code>queue</code>.</li>
<li>While <code>queue</code> is not empty:
<ol>
<li>Remove the front node from the queue and save it in <code>current</code>.</li>
<li>If the <code>current</code> has a right child, add it to <code>queue</code>.</li>
<li>If the <code>current</code> has a left child, add it to <code>queue</code>.</li>
</ol>
</li>
<li>After the while loop, each node in the tree has been visited. The search traversed the whole tree, top to bottom, right to left, so the last node stored in <code>current</code> is the leftmost node in the bottom level of the tree, and we return its value.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/g6zXpErc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We perform BFS, which costs <span class="math inline">\(O(n)\)</span> because we don't visit a node more than once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space for the queue during the BFS for <code>queue</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-edges-in-shortest-paths/description" target="_blank" rel="noopener noreferrer">Find Edges in Shortest Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected weighted graph of <code>n</code> nodes numbered from 0 to <code>n - 1</code>. The graph consists of <code>m</code> edges represented by a 2D array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>

<p>Consider all the shortest paths from node 0 to node <code>n - 1</code> in the graph. You need to find a <strong>boolean</strong> array <code>answer</code> where <code>answer[i]</code> is <code>true</code> if the edge <code>edges[i]</code> is part of <strong>at least</strong> one shortest path. Otherwise, <code>answer[i]</code> is <code>false</code>.</p>

<p>Return the array <code>answer</code>.</p>

<p><strong>Note</strong> that the graph may not be connected.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/05/graph35drawio-1.png" style="height: 129px; width: 250px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,true,true,false,true,true,true,false]</span></p>

<p><strong>Explanation:</strong></p>

<p>The following are <strong>all</strong> the shortest paths between nodes 0 and 5:</p>

<ul>
	<li>The path <code>0 -&gt; 1 -&gt; 5</code>: The sum of weights is <code>4 + 1 = 5</code>.</li>
	<li>The path <code>0 -&gt; 2 -&gt; 3 -&gt; 5</code>: The sum of weights is <code>1 + 1 + 3 = 5</code>.</li>
	<li>The path <code>0 -&gt; 2 -&gt; 3 -&gt; 1 -&gt; 5</code>: The sum of weights is <code>1 + 1 + 2 + 1 = 5</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/05/graphhhh.png" style="width: 185px; height: 136px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,false,false,true]</span></p>

<p><strong>Explanation:</strong></p>

<p>There is one shortest path between nodes 0 and 3, which is the path <code>0 -&gt; 2 -&gt; 3</code> with the sum of weights <code>1 + 2 = 3</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= m &lt;= min(5 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description" target="_blank" rel="noopener noreferrer">Find Elements in a Contaminated Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree with the following rules:</p>

<ol>
	<li><code>root.val == 0</code></li>
	<li>For any <code>treeNode</code>:
	<ol type="a">
		<li>If <code>treeNode.val</code> has a value <code>x</code> and <code>treeNode.left != null</code>, then <code>treeNode.left.val == 2 * x + 1</code></li>
		<li>If <code>treeNode.val</code> has a value <code>x</code> and <code>treeNode.right != null</code>, then <code>treeNode.right.val == 2 * x + 2</code></li>
	</ol>
	</li>
</ol>

<p>Now the binary tree is contaminated, which means all <code>treeNode.val</code> have been changed to <code>-1</code>.</p>

<p>Implement the <code>FindElements</code> class:</p>

<ul>
	<li><code>FindElements(TreeNode* root)</code> Initializes the object with a contaminated binary tree and recovers it.</li>
	<li><code>bool find(int target)</code> Returns <code>true</code> if the <code>target</code> value exists in the recovered binary tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4-1.jpg" style="width: 320px; height: 119px;" />
<pre>
<strong>Input</strong>
[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,null,-1]],[1],[2]]
<strong>Output</strong>
[null,false,true]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True </pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4.jpg" style="width: 400px; height: 198px;" />
<pre>
<strong>Input</strong>
[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
<strong>Output</strong>
[null,true,true,false]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/07/untitled-diagram-4-1-1.jpg" style="width: 306px; height: 274px;" />
<pre>
<strong>Input</strong>
[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
<strong>Output</strong>
[null,true,false,false,true]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>TreeNode.val == -1</code></li>
	<li>The height of the binary tree is less than or equal to <code>20</code></li>
	<li>The total number of nodes is between <code>[1, 10<sup>4</sup>]</code></li>
	<li>Total calls of <code>find()</code> is between <code>[1, 10<sup>4</sup>]</code></li>
	<li><code>0 &lt;= target &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary tree <code>root</code> which follows the following 3 rules:</p>
<ol>
<li>The value of the root node <code>root</code> is always 0</li>
<li>Given a node in the tree with value <code>x</code>, the value of its left child (if it exists) is always <code>x * 2 + 1</code></li>
<li>Given a node in the tree with value <code>x</code>, the value of its right child (if it exists) is always <code>x * 2 + 2</code></li>
</ol>
<p>This tree is then &quot;contaminated&quot;, which means the values of all nodes are overwritten to <code>-1</code>. We now have to find out what values existed in the tree before it was contaminated. We do this by implementing two functions:</p>
<ol>
<li><code>FindElements(TreeNode* root)</code> is our constructor that gives us the contaminated binary tree <code>root</code></li>
<li><code>bool find(int target)</code> should return whether or not <code>target</code> is one of the original values in <code>root</code> before contamination</li>
</ol>
<h3 id="approach-1-tree-traversal-dfs">Approach 1: Tree Traversal (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Our goal is to restore the original values of the tree before it was contaminated. The problem gives us three key rules that define how values are assigned to nodes based on their parent. If we carefully analyze these rules, we can see that the root node always has a value of <code>0</code>. From this starting point, we can apply the second rule to determine that the left child (if it exists) must have a value of <code>0 * 2 + 1 = 1</code>, and the third rule tells us that the right child must have a value of <code>0 * 2 + 2 = 2</code>. Once we establish these values, we can continue applying the same logic to the children of these nodes, propagating the correct values throughout the tree.</p>
<p>This observation naturally leads to a recursive approach. Since each node's value is determined by its parent, we can traverse the tree while applying these rules at every step, ensuring that each node is assigned its correct value. To keep track of the values we recover, we store them in a set called <code>seen</code>. This allows us to efficiently check whether a given value exists in the tree whenever needed.</p>
<p>The best way to traverse the tree in this scenario is <a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/">depth-first search (DFS)</a>. DFS is particularly useful here because it allows us to fully process one branch of the tree before moving to the next, making it a straightforward way to assign values as we traverse. The DFS process follows a simple structure:</p>
<ol>
<li>If we reach a <code>null</code> node, we stop and return immediately, as there’s nothing left to explore.</li>
<li>For each valid node, we store its recovered value in our <code>seen</code> set.</li>
<li>We then move to the left child, using rule 2 (<code>currentValue * 2 + 1</code>) to compute its value before making a recursive DFS call.</li>
<li>We move to the right child next, using rule 3 (<code>currentValue * 2 + 2</code>) before making another recursive DFS call.</li>
</ol>
<p>To implement this, we define a function <code>DFS(currentNode, currentValue)</code>, where <code>currentNode</code> represents the node we are currently processing, and <code>currentValue</code> is its correct original value. This function will handle the recursive traversal and ensure each node gets assigned its correct value.</p>
<p>Since we always know the parent’s value, we can immediately compute the child's values and pass them into the next recursive call. By the end of this process, we will have fully reconstructed the tree’s original values, and since all recovered values are stored in <code>seen</code>, checking for the existence of a number in the tree becomes a simple lookup operation.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Declare a HashSet <code>seen</code> as a  member of the <code>FindElements</code> class</li>
<li>For <code>FindElements(root)</code> constructor:
<ul>
<li>Initialize <code>seen</code> to an empty set.</li>
<li>Call the helper function <code>dfs(root, 0)</code>.</li>
</ul>
</li>
<li>For helper function <code>dfs(currentNode, currentValue, seen)</code>:
<ul>
<li>If the <code>currentNode</code> is <code>null</code>, then we return.</li>
<li>Otherwise, we process the value of <code>currentNode</code> by adding <code>currentValue</code> to <code>seen</code>.</li>
<li>We then recurse to the left and right children:
<ul>
<li>For left child, we call <code>dfs(currentNode.left, currentValue * 2 + 1, seen)</code>.</li>
<li>For right child, we call <code>dfs(currentNode.right, currentValue * 2 + 2, seen)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>For <code>find(target)</code> function:
<ul>
<li>We return whether or not <code>seen</code> contains <code>target</code>: return <code>seen.contains(target)</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LSchxPfd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span> for <code>FindElements</code>, <span class="math inline">\(O(1)\)</span> for <code>find</code></p>
<p>For the <code>FindElements</code> constructor, traversing through <code>root</code> and processing all nodes takes <span class="math inline">\(O(N)\)</span> time. Afterwards, each call of <code>find</code> looks up a value in our set, which takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>After the <code>FindElements</code> constructor is called, our set contains the values of all the nodes of <code>root</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-tree-traversal-bfs">Approach 2: Tree Traversal (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In our previous approach, we used depth-first search (DFS) to traverse the tree, assigning the correct values to nodes and storing these values in a set. Now, we will take a different approach using <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">breadth-first search (BFS)</a>, which follows a different traversal pattern but ultimately achieves the same goal.</p>
<p>To understand the difference, recall that DFS explores a tree by going as deep as possible along one branch before backtracking to explore others. BFS, on the other hand, processes nodes <strong>level by level</strong>, meaning it explores all nodes at a given depth before moving to the next level. This fundamental difference in traversal order leads to a different way of structuring our solution.</p>
<p>To implement BFS, we use a queue, which allows us to control the flow of traversal systematically. We start by inserting the root node into the queue, using it as our initial entry point. Then, as long as the queue is not empty, we repeatedly take the front node, determine its correct original value, and store it in a set for quick lookups later.</p>
<p>Once a node has been processed, we compute the values of its children based on the given rules. If the node has a left child, we use <strong>rule 2</strong> (<code>n.val * 2 + 1</code>) to compute its value and enqueue it for future processing. Similarly, if the node has a right child, we use <strong>rule 3</strong> (<code>n.val * 2 + 2</code>) and enqueue it as well. This ensures that by the time these children are processed, they already hold their correct recovered values.</p>
<p>Unlike DFS, where we explicitly pass the recovered value through recursive calls, BFS allows us to overwrite the node values directly as we process them. This means that when we remove a node from the queue, its left and right children already have their correct values assigned.</p>
<p>Since BFS naturally ensures that nodes are visited in level order, this guarantees a systematic reconstruction of the entire tree. By the end of the traversal, every node will hold its correct original value, and checking whether a number exists in the tree becomes a simple lookup operation in our set.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Declare a HashSet <code>seen</code> as a member of the <code>FindElements</code> class</li>
<li>For <code>FindElements(root)</code> constructor:
<ul>
<li>Initialize <code>seen</code> to an empty set.</li>
<li>Call the helper function <code>bfs(root)</code>.</li>
</ul>
</li>
<li>For helper function <code>bfs(TreeNode root)</code>:
<ul>
<li>Initialize a queue which first contains <code>root</code>. <code>root.val</code> should be set to <code>0</code>.</li>
<li>While the queue is not empty:
<ul>
<li>Pop the front element of the queue: <code>currentNode = queue.pop()</code>.</li>
<li>Save the recovered value by adding <code>currentNode.val</code> into <code>seen</code>.</li>
<li>If left child exists, overwrite its value <code>currentNode.left.val = currentNode.val * 2 + 1</code> and then enqueue it.</li>
<li>If right child exists, overwrite its value <code>currentNode.right.val = currentNode.val * 2 + 2</code> and then enqueue it.</li>
</ul>
</li>
</ul>
</li>
<li>For <code>find(target)</code> function:
<ul>
<li>We return whether or not <code>seen</code> contains <code>target</code>: return <code>seen.contains(target)</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/aUjXxUTe/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span> for <code>FindElements</code>, <span class="math inline">\(O(1)\)</span> for <code>find</code></p>
<p>For the <code>FindElements</code> constructor, traversing through <code>root</code> and processing all nodes takes <span class="math inline">\(O(N)\)</span> time. Afterwards, each call of <code>find</code> looks up a value in our set, which takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>After the <code>FindElements</code> constructor is called, our set contains the values of all the nodes of <code>root</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-eventual-safe-states/description" target="_blank" rel="noopener noreferrer">Find Eventual Safe States</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a <strong>0-indexed</strong> 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes adjacent to node <code>i</code>, meaning there is an edge from node <code>i</code> to each node in <code>graph[i]</code>.</p>

<p>A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong> (or another safe node).</p>

<p>Return <em>an array containing all the <strong>safe nodes</strong> of the graph</em>. The answer should be sorted in <strong>ascending</strong> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="Illustration of graph" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" style="height: 171px; width: 600px;" />
<pre>
<strong>Input:</strong> graph = [[1,2],[2,3],[5],[0],[5],[],[]]
<strong>Output:</strong> [2,4,5,6]
<strong>Explanation:</strong> The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
<strong>Output:</strong> [4]
<strong>Explanation:</strong>
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= graph[i].length &lt;= n</code></li>
	<li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li>
	<li><code>graph[i]</code> is sorted in a strictly increasing order.</li>
	<li>The graph may contain self-loops.</li>
	<li>The number of edges in the graph will be in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes that have an incoming edge from node <code>i</code>.</p>
<p>The problem states that a node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a terminal node (or another safe node).</p>
<p>Our task is to return a sorted array of all the safe nodes of the graph.</p>
<hr />
<h3 id="approach-1-topological-sort-using-kahns-algorithm">Approach 1: Topological Sort Using Kahn's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve the problem, we must first consider when a node is safe or unsafe. If we begin at any node and proceed along any path from that node, we will eventually reach either a terminal node or enter a cycle and continue to loop in it without ever reaching a terminal node.</p>
<p>If there is no path from the node that enters a cycle, we will always be able to reach a terminal node. As a result, such a node is a safe node and should be added to our answer array.</p>
<blockquote>
<p>The problem is reduced to finding the nodes that do not have any paths that lead to a cycle.</p>
</blockquote>
<p>Intuitively, we can realize that a node is safe if all of its outgoing edges are to nodes that are also safe. This is due to the fact that if no neighbor leads to a cycle, no path from the node can either.</p>
<p>We know the terminal nodes are safe. As a result, nodes that solely have outgoing edges to terminal nodes are eventually safe nodes. Then we may check the nodes that have just outgoing edges to safe nodes again and keep updating until no new safe node is discovered.</p>
<p>The question is, how do we efficiently traverse from terminal nodes to nodes that only have outgoing edges to terminal nodes? We can reverse the edges of the graph to create a new graph with reversed edges. After we have visited all of the terminal nodes, we can use this new graph to go to the nodes that have edges to the terminal nodes in the original graph by using the reverse edges that we added.</p>
<p>Let's put this new graph to use now. A node is a safe node if all of its incoming edges come from previously identified safe nodes in the graph. If we erase the edges outgoing from the safe node and discover a node with no incoming edges, it is a new safe node. This gives us hints for thinking about Kahn's method, which does a topological sort by removing the edges in the exact way we want.</p>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge <code>u -&gt; v</code> from vertex <code>u</code> to vertex <code>v</code>, <code>u</code> comes before <code>v</code> in the ordering.</p>
<p>In a directed acyclic graph, we can use Kahn's algorithm to get the topological ordering. Kahn’s algorithm works by keeping track of the number of incoming edges into each node (indegree). It works by repeatedly visiting the nodes with an indegree of zero and deleting all the edges associated with it leading to a decrement of indegree for the nodes whose incoming edges are deleted. This process continues until no elements with zero indegree can be found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">LeetCode Explore Card</a>.</p>
<p>The advantage of using Kahn's technique is that it also aids in the discovery of graph cycles. The Kahn's method does not visit any node in a cycle. As a result, nodes with outgoing edges from nodes in the cycle (in this reversed graph) will never be visited and so will never be marked safe. Nodes with outgoing edges from these unsafe nodes will never be visited as well, and so on. Basically, every node in the original network that has a path to the cycle will never be visited by Kahn's algorithm, which is exactly what we want.</p>
<p>Let's perform Kahn's algorithm on a directed graph having a cycle. Here's a visual step-by-step representation of how it would work:</p>
<p><img src="../Figures/802/802-1.png" alt="img" /></p>
<p>We can see that if there is a cycle, the indegree of nodes in the cycle cannot be set to <code>0</code> due to cyclic dependency. We are unable to visit the cycle's nodes. We are also unable to visit any node with an incoming edge from any node in the cycle. Similarly, realize that any node with an incoming edge from nodes <code>3</code> or <code>5</code> would not have been visited as well.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer <code>n</code> equal to the length of <code>graph</code> to get the number of nodes in the given graph.</li>
<li>Create an array <code>indegree</code> of length <code>n</code> where <code>indegree[x]</code> stores the number of edges entering node <code>x</code>.</li>
<li>We create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all the nodes with an incoming edge from node <code>x</code>, i.e., neighbors of node <code>x</code>. We create this adjacency list by iterating over <code>graph</code> and adding the <strong>reverse edges</strong>. For a node <code>i</code> which originally has outgoing edges to nodes in <code>graph[i]</code>, we push <code>i</code> into <code>adj[node]</code> to add a reverse edge from <code>node</code> to <code>i</code>.</li>
<li>Initialize a queue of integers <code>q</code> and start a BFS algorithm moving from the leaf nodes to the parent nodes.</li>
<li>Begin the BFS traversal by pushing all of the leaf nodes (<code>indegree</code> equal to <code>0</code>) in the queue.</li>
<li>Create a boolean array <code>safe</code> of size <code>n</code> to track the safe nodes in the graph.</li>
<li>While the queue is not empty;
<ul>
<li>Dequeue the first <code>node</code> from the queue.</li>
<li>Mark <code>node</code> as safe.</li>
<li>For each <code>neighbor</code> (nodes that have an incoming edge from <code>node</code>) of <code>node</code>, we decrement <code>indegree[neighbor]</code>by <code>1</code> to delete the <code>node -&gt; neighbor</code> edge.</li>
<li>If <code>indegree[neighbor] == 0</code>, it means that <code>neighbor</code> behaves as a leaf node, so we push <code>neighbor</code> in the queue.</li>
</ul>
</li>
<li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>.</li>
<li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FWjfs3PY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes and <span class="math inline">\(m\)</span> is number of edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Initializing the <code>adj</code> list takes <span class="math inline">\(O(m)\)</span> time as we go through all the edges. The <code>indegree</code> array take <span class="math inline">\(O(n)\)</span> time.</li>
<li>Initializing the boolean <code>safe</code> array also takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Each queue operation takes <span class="math inline">\(O(1)\)</span> time, and a single node will be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. We iterate over the neighbors of each node that is popped out of the queue iterating over all the edges once. Since there are total of <code>m</code> edges, it would take <span class="math inline">\(O(m)\)</span> time to iterate over the edges.</li>
<li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>The <code>adj</code> arrays takes <span class="math inline">\(O(m)\)</span> space. The <code>indegree</code> array takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The <code>safe</code> array also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The queue can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also use a depth-first search (DFS) traversal to detect the nodes that lead to a cycle, i.e., unsafe nodes.</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>A node remains in the DFS recursion stack until all of its branches (all nodes in its subtree) have not been explored. When we have examined all of a node's branches, i.e. visited all of the nodes in its subtree, the node is removed from the DFS recursive stack.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<p>To find the unsafe nodes, we must first recognize a cycle in the graph. If we find a cycle, we will mark all of the nodes in the cycle as unsafe and then go back and mark all of the nodes that led to this cycle as unsafe. Let's find a cycle first.</p>
<p>If the graph has a cycle, we must have a <strong>back edge</strong> connecting a node to one of its ancestors while traversing nodes in the DFS manner.</p>
<p>Let's think how we can establish whether or not a node's neighbor is an ancestor when navigating from one node to another.</p>
<p>If the neighboring node has not yet been visited, it cannot be an ancestor (it is a child node).</p>
<p>Otherwise, if a neighboring node is visited, it may or may not be an ancestor. If the neighboring node is an ancestor, i.e. there is a back edge, it means that we visited this ancestor node first in the DFS traversal, then visited and explored some other nodes, and eventually visited a node that connects back to the ancestor node. As we are still exploring the ancestor node's subtree while iterating over this path, hence this node must be in the current DFS recursive stack.</p>
<p>However, if a neighboring node is visited but not in the recursion stack, it signifies we have previously explored that node in a different branch, and it does not form a cycle in the current branch.</p>
<p>As a result, to detect the cycle we must keep track of the visited nodes (like in a normal DFS) and also the nodes in the function's recursion call stack for DFS traversal. The nodes in the stack store the current path that we are on. There is a cycle in the graph if a node is reached that is already in the recursion stack. We use a boolean array <code>inStack</code> of length <code>n</code> to track which nodes are in the call stack so we can check if a node exists in <span class="math inline">\(O(1)\)</span>. Note that this <code>inStack</code> array is emulating the call stack that the computer is using under the hood to execute recursion. We mark an unvisited node in <code>inStack</code> when we make a recursive call to it and then unmark it when we return from that call.</p>
<p>Now that we've identified the cycle, let's look for the unsafe nodes. When we get a cycle, all of the nodes in the recursion stack either form or lead to a cycle. If we start a DFS traversal from node <code>1</code> in a graph <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 2</code>, nodes <code>2</code>, <code>3</code>, and <code>4</code> form a cycle. When we discovered this cycle, node <code>1</code> was also in the stack. So, when we have a cycle, all the nodes in the recursion stack are unsafe since they form or lead to a loop.</p>
<p>In addition to detecting cycles, we can use the same <code>inStack</code> array to store the unsafe nodes. We do not unmark any of the unsafe nodes from <code>inStack</code> to keep track of them. When any <code>node</code> has an outgoing edge to any of the unsafe nodes, we can immediately return the DFS call for <code>node</code> without unmarking it from <code>inStack</code>, i.e, we do not perform <code>inStack[node] = false</code>. This is because if any <code>neighbor</code> of <code>node</code> is marked <code>inStack</code>, it signifies that either <code>neighbor</code> and <code>node</code> are part of a cycle or <code>neighbor</code> is a previously detected unsafe node. In both the cases, <code>node</code> is also an unsafe node and hence we return the DFS call without unmarking <code>node</code> from <code>inStack</code>.</p>
<p>We only unmark a node from <code>inStack</code>, if we have explored all of its branches and no branch leads to an unsafe node.</p>
<h4 id="algorithm-1">Algorithm</h4>
<blockquote>
<p>Here, we can use the input graph as the adjacency list <code>adj</code></p>
</blockquote>
<ol>
<li>Create two boolean arrays, <code>visit</code> and <code>inStack</code>, each of size <code>n</code>. The <code>visit</code> array keeps track of visited nodes and <code>inStack</code> keeps track of nodes that are currently in the ongoing DFS stack. It will help us to detect a cycle in the graph and the unsafe nodes.</li>
<li>For each node we begin a DFS traversal. We implement the <code>dfs</code> method which takes four parameters: an integer <code>node</code> from which the current traversal begins, <code>adj</code>, <code>visit</code>, and <code>inStack</code>. It returns a boolean indicating whether <code>node</code> is unsafe. We perform the following in this method:
<ul>
<li>If <code>node</code> is already present in <code>inStack</code>, either we just got a cycle or a previously detected unsafe node. We return <code>true</code> in this case as the <code>node</code> is unsafe.</li>
<li>If <code>node</code> is already visited (but not in <code>inStack</code>), we return <code>false</code> because we already visited this <code>node</code> and didn't find it as unsafe node. It is a safe node.</li>
<li>We mark <code>node</code> as visited and also mark it in <code>inStack</code> (<code>inStack[node] = true</code>).</li>
<li>We iterate over all the outgoing edges of <code>node</code> and for each <code>neighbor</code>, we recursively call <code>dfs(neighbor, adj, visit, inStack)</code>. If we get a cycle from <code>neighbor</code> (or <code>neighbor</code> is a previously detected unsafe node), we return <code>true</code> without unmarking <code>node</code> in <code>inStack</code>.</li>
<li>After we have processed all the outgoing edges of <code>node</code>, we mark <code>inStack[node] = false</code> to mark <code>node</code> as safe. We return <code>false</code>.</li>
</ul>
</li>
<li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>, i.e., the nodes with <code>inStack[node] == false</code>.</li>
<li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/V99UanNc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes and <span class="math inline">\(m\)</span> is number of edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> and <code>inStack</code> arrays take <span class="math inline">\(O(n)\)</span> time each.</li>
<li>The <code>dfs</code> function handles each node once, which takes <span class="math inline">\(O(n)\)</span> time in total. From each node, we iterate over all the outgoing edges, which further takes <span class="math inline">\(O(m)\)</span> time to iterate over all the edges as there are a total of <code>m</code> edges.</li>
<li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The <code>visit</code> and <code>inStack</code> arrays take <span class="math inline">\(O(n)\)</span> space each.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-if-path-exists-in-graph/description" target="_blank" rel="noopener noreferrer">Find if Path Exists in Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>bi-directional</strong> graph with <code>n</code> vertices, where each vertex is labeled from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>). The edges in the graph are represented as a 2D integer array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a bi-directional edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by <strong>at most one</strong> edge, and no vertex has an edge to itself.</p>

<p>You want to determine if there is a <strong>valid path</strong> that exists from vertex <code>source</code> to vertex <code>destination</code>.</p>

<p>Given <code>edges</code> and the integers <code>n</code>, <code>source</code>, and <code>destination</code>, return <code>true</code><em> if there is a <strong>valid path</strong> from </em><code>source</code><em> to </em><code>destination</code><em>, or </em><code>false</code><em> otherwise</em><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png" style="width: 141px; height: 121px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> There are two paths from vertex 0 to vertex 2:
- 0 &rarr; 1 &rarr; 2
- 0 &rarr; 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png" style="width: 281px; height: 141px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no path from vertex 0 to vertex 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= source, destination &lt;= n - 1</code></li>
	<li>There are no duplicate edges.</li>
	<li>There are no self edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-largest-value-in-each-tree-row/description" target="_blank" rel="noopener noreferrer">Find Largest Value in Each Tree Row</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>an array of the largest value in each row</em> of the tree <strong>(0-indexed)</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" style="width: 300px; height: 172px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5,3,null,9]
<strong>Output:</strong> [1,3,9]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> [1,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
</blockquote>
<p>BFS is perfect when we are dealing specifically with rows/levels of a binary tree. With BFS, we handle one row of the tree at a time.</p>
<p>Here, we need to find the maximum value in each row. We can simply perform a BFS and for each row, keep track of the maximum value we have seen so far. We will initialize an integer <code>currMax</code> to a small value like negative infinity. Then we go through the row and try to update <code>currMax</code> when we see larger values. After handling the row, we add <code>currMax</code> to our answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>If the <code>root</code> is null (empty) tree, just return an empty list.</li>
<li>Initialize the answer list <code>ans</code> and a <code>queue</code> with the <code>root</code> to perform BFS.</li>
<li>Perform BFS - while the <code>queue</code> is not empty:
<ul>
<li>Initialize <code>currMax</code> to a small value and save the length of the queue in <code>currentLength</code>.</li>
<li>Iterate <code>currentLength</code> times:
<ul>
<li>Remove a <code>node</code> from the <code>queue</code>.</li>
<li>Update <code>currMax</code> with <code>node.val</code> if it is larger.</li>
<li>For each child of <code>node</code>, if it is not null, push it to the <code>queue</code>.</li>
</ul>
</li>
<li>Add <code>currMax</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/P7pFhbid/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the BFS, we visit each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In a perfect binary tree, the final row has <span class="math inline">\(O(\frac{n}{2}) = O(n)\)</span> nodes, all of which will be in <code>queue</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-depth-first-search-dfs">Approach 2: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>Note: This problem is perfect for BFS, but an interviewer might you to implement DFS as a follow-up. We have included a DFS approach for completeness.</p>
</blockquote>
<p>In BFS, we handle each row explicitly, so it's easy to just keep track of the maximum value as we traverse through the row.</p>
<p>In DFS, the order in which we move through the tree is not related to the rows. Thus, we need to be more creative to find the maximum value in each row. The first observation to make is that each row can be described by the depth of its nodes.</p>
<p><img src="../Figures/515/1.png" alt="depth" /><br />
<br></p>
<p>The depth of a node is its distance from the root. The root has a depth of <code>0</code>, and every child has a depth of <code>1</code> greater than its parent. You may also notice that in terms of indices, each node's depth corresponds to its index in the answer.</p>
<p>For example, if <code>ans</code> is our answer list, then <code>ans[2]</code> holds the maximum value of all nodes with depth <code>2</code>.</p>
<p>If we keep track of each node's depth during the traversal, then we can update <code>ans</code> directly. How do we keep track of the depth? We will pass an additional argument <code>depth</code> in our <code>dfs</code> function. When we initially call <code>dfs</code> with <code>root</code>, we will pass <code>depth = 0</code>. When we call <code>dfs</code> on a child, we will pass <code>depth + 1</code>.</p>
<p>There is one problem: how do we know what length <code>ans</code> should be? We will initialize <code>ans</code> as an empty list. If we are at a <code>depth</code> that would be out of bounds if we tried to access <code>ans[depth]</code>, then we will simply initialize the current <code>node.val</code> as the maximum value seen at <code>depth</code> so far by pushing <code>node.val</code> to <code>ans</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>ans</code> as an empty list.</li>
<li>Define a function <code>dfs(node, depth)</code>:
<ul>
<li>If <code>node</code> is null, return.</li>
<li>If <code>depth == ans.length</code>, then push <code>node.val</code> to <code>ans</code>. Otherwise, try to update <code>ans[depth]</code> with <code>node.val</code> if its larger.</li>
<li>Call <code>dfs</code> on <code>node.left</code> and <code>node.right</code> with <code>depth + 1</code> as the second argument.</li>
</ul>
</li>
<li>Call <code>dfs(root, 0)</code> and then <code>return ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/CmiiemQN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree and <span class="math inline">\(h\)</span> as the max depth of the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(h)\)</span></p>
<p>We use extra space for the recursion call stack. The most calls in the call stack at any given time will be the max depth of the tree. In the worst-case scenario where the tree is like a linked list, the max depth will be <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-dfs-iterative">Approach 3: DFS, Iterative</h3>
<p><strong>Intuition</strong></p>
<p>We can also implement DFS iteratively using a stack. Each entry in the stack will be a pair <code>node, depth</code>. We will use a while loop to perform the DFS, with each iteration being analogous to a function call from the previous approach. As such, we will perform the same process in each while loop iteration: try to update <code>ans</code> with <code>node.val</code>, then push the children of <code>node</code> to the stack if they exist.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>If the <code>root</code> is null (empty) tree, just return an empty list.</li>
<li>Initialize the answer list <code>ans</code> and a <code>stack</code> with <code>(root, 0)</code>.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop <code>(node, depth)</code> from the stack.</li>
<li>If <code>depth == ans.length</code>, then push <code>node.val</code> to <code>ans</code>. Otherwise, try to update <code>ans[depth]</code> with <code>node.val</code> if its larger.</li>
<li>If <code>node.left</code> is not null, push <code>(node.left, depth + 1)</code> to <code>stack</code>.</li>
<li>If <code>node.right</code> is not null, push <code>(node.right, depth + 1)</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/Gc9wyzzK/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree and <span class="math inline">\(h\)</span> as the max depth of the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(h)\)</span></p>
<p>We use extra space for the recursion call stack. The most calls in the call stack at any given time will be the max depth of the tree. In the worst-case scenario where the tree is like a linked list, the max depth will be <span class="math inline">\(O(n)\)</span>.</p>
<p>We pop the top node from the stack and then push its child nodes onto the stack based on the DFS traversal strategy. This process of pushing and popping forms a path-like structure within the stack, and the length of this path will not exceed the height of the tree. Therefore, <span class="math inline">\(O(h)\)</span> space will be used.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/description" target="_blank" rel="noopener noreferrer">Find Minimum Diameter After Merging Two Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exist two <strong>undirected </strong>trees with <code>n</code> and <code>m</code> nodes, numbered from <code>0</code> to <code>n - 1</code> and from <code>0</code> to <code>m - 1</code>, respectively. You are given two 2D integer arrays <code>edges1</code> and <code>edges2</code> of lengths <code>n - 1</code> and <code>m - 1</code>, respectively, where <code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the first tree and <code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the second tree.</p>

<p>You must connect one node from the first tree with another node from the second tree with an edge.</p>

<p>Return the <strong>minimum </strong>possible <strong>diameter </strong>of the resulting tree.</p>

<p>The <strong>diameter</strong> of a tree is the length of the <em>longest</em> path between any two nodes in the tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example11-transformed.png" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>We can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/04/22/example211.png" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>We can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>edges1.length == n - 1</code></li>
	<li><code>edges2.length == m - 1</code></li>
	<li><code>edges1[i].length == edges2[i].length == 2</code></li>
	<li><code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; m</code></li>
	<li>The input is generated such that <code>edges1</code> and <code>edges2</code> represent valid trees.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two trees: one with <code>n</code> nodes and the other with <code>m</code> nodes. Our goal is to add an edge between a node from the first tree and a node from the second tree, in such a way that the <em>diameter</em> of the resulting tree is minimized.</p>
<blockquote>
<p>The <em>diameter</em> of a tree is the longest path between any two nodes in the tree.</p>
</blockquote>
<p>Let us consider the two ways that the longest path can be formed:</p>
<ol>
<li>
<p>The path starts and ends at nodes within the same tree.</p>
 <img src="../Figures/3203/3203_overview2.png" alt="Second way to form longest path" width="400px">
<p>In this case, the problem reduces to finding the maximum diameter of the two original trees.</p>
</li>
<li>
<p>The path starts at a node in the first tree and ends at a node in the second.</p>
 <img src="../Figures/3203/3203_overview1.png" alt="First way to form longest path" width="400px">
<p>In this case, the selection of the nodes to connect is crucial for minimizing the overall diameter. Intuitively, we aim to select these nodes so that, if chosen as roots, the heights of their respective trees are minimized. In practice, this often involves selecting nodes near the &quot;center&quot; of each tree, ensuring their subtrees are as balanced as possible.</p>
 <details>
 <summary>Click here for a formal proof</summary>
<p>Specifically, for the node that is in the middle of the diameter, the following holds:</p>
<ol>
<li>Its maximum distance to any node of the tree is equal to <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.<br />
This is because its maximum distance is determined by the farthest endpoint of the diameter. We can prove this by contradiction. Suppose the maximum distance were to some other node outside the diameter path. This would require the existence of a longer path than the diameter, contradicting the definition of the diameter as the longest path in the tree. Therefore:
<ul>
<li>If the <span class="math inline">\(\text{diameter}\)</span> is even, the middle node is equidistant from both endpoints of the diameter, with a distance of <span class="math inline">\(\frac{\text{diameter}}{2}\)</span> to each.</li>
<li>If the <span class="math inline">\(\text{diameter}\)</span> is odd, each of the two middle nodes has distances <span class="math inline">\(\frac{\text{diameter} - 1}{2}\)</span> to one endpoint and <span class="math inline">\(\frac{\text{diameter} + 1}{2}\)</span> to the other. In this case, the maximum distance is <span class="math inline">\(\frac{\text{diameter} + 1}{2}\)</span> = <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.</li>
</ul>
</li>
<li>For any other node in the tree, its maximum distance to another node is greater than or equal to <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.<br />
Again, the maximum distance for any node is towards one of the endpoints of the diameter, denoted as <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Consider a node <span class="math inline">\(u\)</span>, and assume <span class="math inline">\(u\)</span> is closer to <span class="math inline">\(a\)</span> than <span class="math inline">\(b\)</span>. The distance of <span class="math inline">\(u\)</span> to <span class="math inline">\(b\)</span> can be lower-bounded as follows:</li>
</ol>
<ul>
<li>Let <span class="math inline">\(m\)</span> be the midpoint of the diameter, located at a distance of at least <span class="math inline">\(\lfloor \frac{\text{diameter}}{2} \rfloor\)</span> to <span class="math inline">\(b\)</span>.</li>
<li>Since <span class="math inline">\(u\)</span> is closer to <span class="math inline">\(a\)</span>, it lies either on the path between <span class="math inline">\(a\)</span> and <span class="math inline">\(m\)</span>, or off the diameter in a subtree connected to this path.</li>
<li>In either case, the shortest path from <span class="math inline">\(u\)</span> to <span class="math inline">\(b\)</span> must pass through <span class="math inline">\(m\)</span> or a point even farther from <span class="math inline">\(b\)</span>. Thus, the distance from <span class="math inline">\(u\)</span> to <span class="math inline">\(b\)</span> is at least the distance from <span class="math inline">\(m\)</span> to <span class="math inline">\(b\)</span> plus 1, or <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>.</li>
</ul>
 </details>
<p>By adding an edge between the two centers of the trees, the maximum distance between each of them and a node within the same tree is at most <span class="math inline">\(\lceil \frac{\text{diameter}}{2} \rceil\)</span>. Thus, the combined diameter of the tree is the sum of the halves of the original diameters plus one for the extra edge:</p>
<p><span class="math display">\[\begin{aligned}
    \lceil \frac{\text{diameter}_1}{2} \rceil + \lceil \frac{\text{diameter}_2}{2} \rceil + 1.
\end{aligned}
\]</span></p>
<p>Therefore, the problem simplifies to returning the maximum among the diameter of each tree and the above value.</p>
</li>
</ol>
<p>Feel free to try solving these problems first as great prerequisites to this one:<br />
1. <a href="https://leetcode.com/problems/minimum-height-trees/description/">Minimum Height Trees</a>.<br />
2. <a href="https://leetcode.com/problems/tree-diameter/description/">Tree Diameter</a></p>
<hr />
<h3 id="approach-1-farthest-of-farthest-bfs">Approach 1: Farthest of Farthest (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's break down the problem of calculating the diameter of a tree. First of all, we observe that any tree can be seen as:</p>
<ul>
<li>The sequence of nodes on the diameter itself, plus</li>
<li>Additional subtrees branching out from nodes along the diameter.</li>
</ul>
<img alt="Tree = sequence of nodes on the diameter + subtrees" src="../Figures/3203/3203_first_approach.png" width="400px" />
<p>For any node in the tree, its minimum distance to one of the diameter's endpoints (say <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>) is always less than or equal to the diameter. This can be proven via contradiction. If one endpoint of the diameter (<span class="math inline">\(a\)</span>) is known, the other endpoint (<span class="math inline">\(b\)</span>) is simply the farthest node from <span class="math inline">\(a\)</span>.</p>
<p>Based on that, one naive way to find the diameter is:</p>
<ol>
<li>Assume each node is one endpoint of the diameter.</li>
<li>Calculate the farthest node from it.</li>
<li>Record the longest path found.</li>
</ol>
<p>However, this approach involves computing the farthest node for all nodes, leading to a time complexity of <span class="math inline">\(O(n^2)\)</span>, which will result in a TLE (Time Limit Exceeded) for the given constraints.</p>
<p>For the optimized approach, we observe that we only need to find the farthest node of a single arbitrary node <span class="math inline">\(u\)</span> and that node would be one of the endpoints of the diameter. Why does this work? Let's consider the following cases:</p>
<ul>
<li>
<p>Case 1: <span class="math inline">\(u\)</span> lies on the diameter<br />
Running a BFS for the longest path from <span class="math inline">\(u\)</span> will find an endpoint of the diameter.</p>
  <details>
  <summary>Click here for a formal proof</summary>
  <br>
<p>We will prove this statement by contradiction. Let <span class="math inline">\(v\)</span> (<span class="math inline">\(v \neq a, b\)</span>) be the farthest node from <span class="math inline">\(u\)</span>, implying <span class="math inline">\(\text{dist}(u, b) < \text{dist}(u, v)\)</span>. Assume <span class="math inline">\(u\)</span> is closer to <span class="math inline">\(a\)</span> than <span class="math inline">\(b\)</span>, so <span class="math inline">\(\text{dist}(u, a) \leq \text{dist}(u, b)\)</span>. Combining these inequalities gives us:</p>
<p><span class="math display">\[\begin{aligned}
\text{dist}(u, b) + \text{dist}(u, a) &< \text{dist}(u, v) + \text{dist}(u, b)  \\
\text{dist}(a, b) &< \text{dist}(v, b),
\end{aligned}
\]</span></p>
<p>which is a contradiction, since the diameter (<span class="math inline">\(a \rightarrow b\)</span>) is the longest path in the tree.</p>
  </details>
</li>
<li>
<p>Case 2: <span class="math inline">\(u\)</span> does not lie on the diameter<br />
The path from <span class="math inline">\(u\)</span> to the farthest node passes through the diameter so the problem reduces to Case 1.</p>
  <details>
  <summary>Click here for a formal proof</summary>
  <br>
<p>Let <span class="math inline">\(v\)</span> (<span class="math inline">\(v \neq a, b\)</span>) be the farthest node from <span class="math inline">\(u\)</span>, and <span class="math inline">\(u^*\)</span> the root of <span class="math inline">\(u\)</span>'s subtree. The path <span class="math inline">\(u \to v\)</span> avoids the diameter only if <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are within the same subtree. In this case:</p>
<p><span class="math display">\[\begin{aligned}
\text{dist}(u, v) &> \text{dist}(u, b) \\
\text{dist}(u, u^*) + \text{dist}(u^*, v) \geq \text{dist}(u, v) &> \text{dist}(u, u^*) + \text{dist}(u^*, b) \\
\text{dist}(u^*, v) &> \text{dist}(u^*, b) \\
\text{dist}(a, u^*) + \text{dist}(u^*, v) &> \text{dist}(a, u^*) + \text{dist}(u^*, b) \\
\text{dist}(a, v) &> \text{dist}(a, b) \\
\end{aligned}
\]</span></p>
<pre><code>which is a contradiction, since the diameter ($a \rightarrow b$) is the longest path in the tree.
</code></pre>
  </details>
</li>
</ul>
<p>Therefore, to calculate the diameter of a tree, only two BFS calls are needed:</p>
<ol>
<li>First BFS starting from any arbitrary node to find the <em>farthest</em> node from it, which is also an endpoint of the diameter.</li>
<li>Second BFS starting from this <em>farthest</em> node to find the <em>farthest node</em> from it, which is equal to the second endpoint of the diameter.</li>
</ol>
<blockquote>
<p><strong>Breadth-First Search (BFS)</strong>: For a more comprehensive understanding of breadth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<h5 id="main-function-minimumdiameteraftermerge">Main Function: <code>minimumDiameterAfterMerge</code></h5>
<ul>
<li>
<p>Calculate the number of nodes for each tree:</p>
<ul>
<li><code>n</code> is the number of nodes in Tree 1.</li>
<li><code>m</code> is the number of nodes in Tree 2.</li>
</ul>
</li>
<li>
<p>Build adjacency lists for both trees:</p>
<ul>
<li>Call <code>buildAdjList(n, edges1)</code> to construct the adjacency list for the first tree.</li>
<li>Call <code>buildAdjList(m, edges2)</code> to construct the adjacency list for the second tree.</li>
</ul>
</li>
<li>
<p>Calculate the diameters of both trees:</p>
<ul>
<li>Call <code>findDiameter(n, adjList1)</code> to find the diameter of the first tree.</li>
<li>Call <code>findDiameter(m, adjList2)</code> to find the diameter of the second tree.</li>
</ul>
</li>
<li>
<p>Calculate the longest path that spans across both trees:</p>
<ul>
<li>Calculate <code>combinedDiameter</code> as the sum of half the diameters of both trees, plus 1 (rounded up).</li>
</ul>
</li>
<li>
<p>Return the maximum of the three possibilities:</p>
<ul>
<li>Return the maximum of <code>diameter1</code>, <code>diameter2</code>, and <code>combinedDiameter</code>.</li>
</ul>
</li>
</ul>
<h5 id="buildadjlist-function"><code>buildAdjList</code> function:</h5>
<ul>
<li>Create an adjacency list of size <code>size</code>.</li>
<li>For each edge in <code>edges</code>, add the nodes to each other's adjacency list.</li>
</ul>
<h5 id="finddiameter-function"><code>findDiameter</code> function:</h5>
<ul>
<li>Call <code>findFarthestNode(n, adjList, 0)</code> to find the farthest node from an arbitrary starting node (e.g., node 0).</li>
<li>Call <code>findFarthestNode(n, adjList, farthestNode)</code> from the previously found farthest node to determine the tree diameter.</li>
</ul>
<h5 id="findfarthestnode-function"><code>findFarthestNode</code> function:</h5>
<ul>
<li>Initialize a queue and a visited array to perform BFS starting from <code>sourceNode</code>.</li>
<li>Traverse the graph, updating the farthest node each time a node is dequeued.</li>
<li>Return the farthest node and the distance (diameter).</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4boc29Fs/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the first tree and <span class="math inline">\(m\)</span> the number of nodes in the second tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>To calculate the diameter of a tree, we perform two BFS calls using the <code>findFarthestNode</code> function. Each BFS visits every node and edge exactly once, and since the number of edges is <span class="math inline">\(k - 1 = O(k)\)</span> for a tree of size <span class="math inline">\(k\)</span>, the time complexity of one BFS is <span class="math inline">\(O(k)\)</span>. Thus, finding the diameter of the first tree takes <span class="math inline">\(O(n)\)</span>, and for the second tree, it takes <span class="math inline">\(O(m)\)</span>, as each involves two BFS calls.</p>
<p>The combined diameter of the tree is calculated using constant-time operations like addition and comparison, contributing <span class="math inline">\(O(1)\)</span> to the overall time complexity of <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>All the data structures used in the algorithm, including the adjacency lists, the <code>visited</code> array, and the <code>nodesQueue</code>, have linear space complexity in terms of the size of the tree being processed. Therefore, the total space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let’s start with a simple observation based on the definition of the diameter:</p>
<ul>
<li>For each node in the tree, we calculate the length of the longest path passing through it. The longest of these paths represents the diameter of the tree.</li>
</ul>
<p>To determine the longest path that passes through a node <span class="math inline">\(u\)</span>, we perform a DFS to calculate the two longest distances from <span class="math inline">\(u\)</span> to any leaf nodes in the tree. The sum of these two distances gives the length of the longest path through <span class="math inline">\(u\)</span>.</p>
<p>During the recursive calls, each node returns two values:</p>
<ol>
<li>The diameter of its subtree.</li>
<li>The longest path to a leaf in its subtree, or its <em>depth</em>. This avoids redundant calculations, reusing previously computed values.</li>
</ol>
<blockquote>
<p><strong>Depth-First Search (DFS)</strong>: For a more comprehensive understanding of depth-first search, check out the <a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/">DFS Explore Card</a>. This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="main-function-minimumdiameteraftermerge-1">Main Function: <code>minimumDiameterAfterMerge</code></h5>
<ul>
<li>
<p>Calculate the number of nodes for each tree:</p>
<ul>
<li><code>n</code> is the number of nodes in Tree 1.</li>
<li><code>m</code> is the number of nodes in Tree 2.</li>
</ul>
</li>
<li>
<p>Build adjacency lists for both trees:</p>
<ul>
<li>Use the <code>buildAdjList</code> function to construct the adjacency list for both trees (<code>adjList1</code> and <code>adjList2</code>).</li>
</ul>
</li>
<li>
<p>Find the diameter of Tree 1:</p>
<ul>
<li>Call <code>findDiameter(adjList1, 0, -1)</code> to start a DFS from node 0 in Tree 1.</li>
<li>Store the diameter of Tree 1 in <code>diameter1</code>.</li>
</ul>
</li>
<li>
<p>Find the diameter of Tree 2:</p>
<ul>
<li>Call <code>findDiameter(adjList2, 0, -1)</code> to start a DFS from node 0 in Tree 2.</li>
<li>Store the diameter of Tree 2 in <code>diameter2</code>.</li>
</ul>
</li>
<li>
<p>Calculate the diameter of the combined tree:</p>
<ul>
<li>The combined diameter accounts for the longest path spanning both trees.</li>
<li>It is calculated as <code>ceil(diameter1 / 2.0) + ceil(diameter2 / 2.0) + 1</code>.</li>
</ul>
</li>
<li>
<p>Return the maximum diameter:</p>
<ul>
<li>Return the maximum of the three values: <code>diameter1</code>, <code>diameter2</code>, and <code>combinedDiameter</code>.</li>
</ul>
</li>
</ul>
<h5 id="helper-function-buildadjlist">Helper Function: <code>buildAdjList</code></h5>
<ul>
<li>Given the number of nodes <code>size</code> and an edge list <code>edges</code>, build an adjacency list (<code>adjList</code>):
<ul>
<li>Iterate through each edge and add the corresponding nodes to the adjacency list.</li>
</ul>
</li>
</ul>
<h5 id="helper-function-finddiameter">Helper Function: <code>findDiameter</code></h5>
<ul>
<li>
<p>Given the adjacency list <code>adjList</code>, the current <code>node</code>, and its <code>parent</code>, calculate the diameter of the tree:</p>
<ul>
<li>Initialize two variables <code>maxDepth1</code> and <code>maxDepth2</code> to track the two largest depths from the current node.</li>
<li>Initialize <code>diameter</code> to track the diameter of the subtree.</li>
</ul>
</li>
<li>
<p>For each neighbor of the current node:</p>
<ul>
<li>Skip the parent node to avoid cycles.</li>
<li>Recursively calculate the diameter and depth of the neighbor’s subtree.</li>
<li>Update <code>diameter</code> with the maximum of the current diameter and the child’s diameter.</li>
<li>Increment the depth and update the two largest depths (<code>maxDepth1</code> and <code>maxDepth2</code>).</li>
</ul>
</li>
<li>
<p>The diameter of the current node is updated as <code>maxDepth1 + maxDepth2</code>.</p>
</li>
<li>
<p>Return the <code>diameter</code> and <code>maxDepth1</code> (to be used by the parent).</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/BB9kPcpo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the first tree and <span class="math inline">\(m\)</span> the number of nodes in the second tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The <code>findDiameter</code> function uses Depth-First Search (DFS) on the tree, with a time complexity of <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> is the tree's size. The diameter calculation itself takes <span class="math inline">\(O(n + m)\)</span> time. Since combining the diameters involves only constant-time operations, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The space complexity depends on the size of the data structures and the recursion depth. Using an adjacency list representation of the trees requires <span class="math inline">\(O(n + m)\)</span> space. Additionally, the recursion depth can reach <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> is the number of nodes in the processed tree. Thus, the total space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<h3 id="approach-3-topological-sorting">Approach 3: Topological Sorting</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this approach, we will again calculate the diameter of each tree separately and then apply the method described in <a href="#overview">the overview section</a> to determine the diameter of the resulting tree.</p>
<p>First, observe that the diameter endpoints must be leaves, as any non-leaf endpoints would allow the diameter to extend further in the opposite direction, contradicting the definition of the diameter.</p>
<p>Therefore, removing all leaves reduces the diameter by 2, and the remaining diameter becomes the diameter of the reduced tree. As a result, the remaining part of the diameter will still be the diameter of the reduced tree.</p>
<p>If we continue removing the leaves, the remaining diameter will get progressively smaller until only one or two nodes are left.</p>
<ul>
<li>If one node is left, the diameter equals the number of nodes removed during the reduction.</li>
<li>If two nodes remain, we count the edge connecting them as part of the diameter.</li>
</ul>
<p>To track the current leaves of the reduced tree, we will update the counters of their neighboring nodes, also known as the <em>degree</em> of each node. Once a node's degree reaches 1, we will enqueue that node in the <code>nodesQueue</code> for further processing.</p>
<h4 id="algorithm-2">Algorithm</h4>
<h5 id="main-function-minimumdiameteraftermerge-2">Main Function: <code>minimumDiameterAfterMerge</code></h5>
<ul>
<li>
<p>Calculate the number of nodes for each tree:</p>
<ul>
<li><code>n</code> is the number of nodes in Tree 1.</li>
<li><code>m</code> is the number of nodes in Tree 2.</li>
</ul>
</li>
<li>
<p>Build adjacency lists for both trees:</p>
<ul>
<li>Use the <code>buildAdjList</code> function to construct the adjacency list for each tree (<code>adjList1</code> for Tree 1 and <code>adjList2</code> for Tree 2).</li>
</ul>
</li>
<li>
<p>Calculate the diameters of both trees:</p>
<ul>
<li>Call <code>findDiameter(n, adjList1)</code> to find the diameter of Tree 1 (<code>diameter1</code>).</li>
<li>Call <code>findDiameter(m, adjList2)</code> to find the diameter of Tree 2 (<code>diameter2</code>).</li>
</ul>
</li>
<li>
<p>Calculate the longest path that spans both trees:</p>
<ul>
<li>Compute <code>combinedDiameter</code> as the sum of half of <code>diameter1</code>, half of <code>diameter2</code>, and an additional 1 to account for the merging edge.</li>
<li>The formula is: <code>combinedDiameter = ceil(diameter1 / 2.0) + ceil(diameter2 / 2.0) + 1</code>.</li>
</ul>
</li>
<li>
<p>Return the maximum value among <code>diameter1</code>, <code>diameter2</code>, and <code>combinedDiameter</code>.</p>
</li>
</ul>
<h5 id="buildadjlist-function-1"><code>buildAdjList</code> function:</h5>
<ul>
<li>Initialize an empty adjacency list <code>adjList</code> of the given size (<code>size</code>).</li>
<li>Iterate through the edges and populate the adjacency list by adding neighbors for each node.</li>
</ul>
<h5 id="finddiameter-function-1"><code>findDiameter</code> function:</h5>
<ul>
<li>Initialize a queue <code>leavesQueue</code> to hold leaves (nodes with degree 1) and a <code>degrees</code> vector to track the degree (number of neighbors) of each node.</li>
<li>Add all leaves (nodes with degree 1) to the <code>leavesQueue</code>.</li>
<li>Process the leaves iteratively, removing them and updating the degrees of their neighbors.</li>
<li>Continue until only 2 or fewer nodes remain:
<ul>
<li>For each leaf, reduce the degree of its neighbors, and if a neighbor becomes a leaf, add it to the queue.</li>
</ul>
</li>
<li>If exactly two nodes remain, return the diameter as twice the number of layers of leaves removed + 1 (final connecting edge).</li>
<li>If only one node remains, return twice the number of layers of leaves removed.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YdcDg6AS/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the first tree and <span class="math inline">\(m\)</span> the number of nodes in the second tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>In the <code>findDiameter</code> function, each node is added and removed from the <code>leavesQueue</code> once. Each edge is processed once when updating the degrees of neighboring nodes. Therefore, the time complexity is <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> is the size of the input tree. Consequently, calculating the diameter for both trees takes <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The calculation of the diameter of the combined tree involves only a few constant-time operations, such as adding and comparing values. This step contributes <span class="math inline">\(O(1)\)</span> to the total time complexity, which is still <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Similar to the first approach, all the data structures used (adjacency lists, <code>leavesQueue</code> and,the <code>degrees</code> array), have a linear space complexity in terms of the size of the tree being processed. Therefore, the total space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-number-of-closed-islands/1" target="_blank" rel="noopener noreferrer">Find number of closed islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <a href="https://www.geeksforgeeks.org/program-to-check-if-a-matrix-is-binary-matrix-or-not/">binary matrix</a> <strong>mat[][]</strong> of dimensions <strong>NxM</strong> such that 1 denotes land and <strong>0</strong> denotes water. Find the number of closed islands in the given matrix.<br />An island is a 4-directional(up,right,down and left) connected part of 1's.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> A closed island is a group of <strong>1s</strong> surrounded by only <strong>0s</strong> on all the boundaries <strong>(except diagonals)</strong>. In simple words, a closed island is an island whose none of the <strong>1s</strong> lie on the edges of the matrix.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 5, M = 8
mat[][] =</span> <span style="font-size: 18px;">{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 0, 1},&nbsp;
           {0, 1, 0, 1, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 1, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output:</strong>
2
<strong>Explanation</strong>:
</span><span style="font-size: 18px;">mat[][] =&nbsp;{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, 0, 1},&nbsp;
           {0, <strong>1</strong>, 0, <strong>1</strong>, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, <strong>1</strong>, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}&nbsp;
There are 2 closed islands. The islands in dark are closed because they are completely surrounded by 0s (water). There are two more islands in the last column of the matrix, but they are not completely surrounded by 0s. Hence they are not closed islands. </span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 3, M = 3
mat[][] = {{1, 0, 0},
           {0, 1, 0},
           {0, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output: <br /></strong></span><span style="font-size: 18px;">1<strong><br />Explanation:<br /></strong>mat[][] = {{1, 0, 0},<br />          {0, <strong>1</strong>, 0},<br />          {0, 0, 1}}<br />There is just a one closed island.</span></pre>
<p><span style="font-size: 18px;"><strong>Your task:</strong></span><br /><span style="font-size: 18px;">You dont need to read input or print anything. Your task is to complete the function <strong>closedIslands()</strong>&nbsp;which takes two integers N and M, and a 2D binary matrix mat as input parameters and returns the number of closed islands.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(N*M)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*M)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N,M &le; 500<br /><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-longest-string--170645/1" target="_blank" rel="noopener noreferrer">Find the longest string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="font-size: 18px;">Given an array of strings&nbsp;<strong>words</strong></span><strong style="font-size: 18px;">[]</strong><span style="font-size: 18px;">. Find the </span><strong style="font-size: 18px;">longest</strong><span style="font-size: 18px;"> string in words[] such that </span><strong style="font-size: 18px;">every prefix</strong><span style="font-size: 18px;"> of it is also present in the array words[].&nbsp;</span><br /></span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><strong>Note:&nbsp;</strong></span></span><span style="font-size: 18px;">If multiple strings have the same maximum length, return the <strong>lexicographically smallest one</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> words[] = ["p", "pr", "pro", "probl", "problem", "pros", "process", "processor"]</span>
<span style="font-size: 18px;"><strong>Output:</strong> pros</span>
<strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">"pros" is the longest word with all prefixes ("p", "pr", "pro", "pros") present in the array words[].</span></pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">words[] = ["</span><span style="font-size: 18px;">ab", "a", "abc", "abd"]</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">abc</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong><span style="font-size: 18px;"> Both "abc" and "abd" has all the prefixes in words[]. Since, "abc" is lexicographically smaller than "abd", so the output is "abc".
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; words.length() &le; 10<sup>3</sup><br />1 &le; words[i].length &le; </span><span style="font-size: 18px;">10</span><sup>3</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-safest-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Find the Safest Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>n x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A cell containing a thief if <code>grid[r][c] = 1</code></li>
	<li>An empty cell if <code>grid[r][c] = 0</code></li>
</ul>

<p>You are initially positioned at cell <code>(0, 0)</code>. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.</p>

<p>The <strong>safeness factor</strong> of a path on the grid is defined as the <strong>minimum</strong> manhattan distance from any cell in the path to any thief in the grid.</p>

<p>Return <em>the <strong>maximum safeness factor</strong> of all paths leading to cell </em><code>(n - 1, n - 1)</code><em>.</em></p>

<p>An <strong>adjacent</strong> cell of cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> and <code>(r - 1, c)</code> if it exists.</p>

<p>The <strong>Manhattan distance</strong> between two cells <code>(a, b)</code> and <code>(x, y)</code> is equal to <code>|a - x| + |b - y|</code>, where <code>|val|</code> denotes the absolute value of val.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example1.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example2.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1],[0,0,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example3.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length == n &lt;= 400</code></li>
	<li><code>grid[i].length == n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one thief in the <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <code>grid</code> representing a city layout where some cells contain thieves and others are empty, and we need to find the maximum safeness factor of all paths from the top-left corner to the bottom-right corner. The safeness factor of a path is defined as the minimum Manhattan distance from any cell in the path to any thief in the <code>grid</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>Manhattan distance between two cells is the sum of the absolute differences of their row and column indices.</li>
<li>All the cells in the <code>grid</code> contain either 0 or 1, representing empty cells and cells containing thieves respectively.</li>
<li>You start from the top-left corner <code>(0, 0)</code> and can move to adjacent cells in any of the four directions.</li>
<li>The maximum level of safety one can achieve while traversing from the starting point to the destination is by ensuring the least proximity to any cell containing a thief.</li>
</ol>
<h3 id="approach-1-breadth-first-search--binary-search">Approach 1: Breadth-First Search + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Since we need to find the safeness factor of a path from the source to the destination, the initial intuition to solve this problem is that we should first find the safeness factors of the cells in the path. The path can span across the entire <code>grid</code>, so we need to find the safeness factors for all the cells in the <code>grid</code>.</p>
<p>One approach to find the safeness factors of the cells would be to iterate over each cell in the <code>grid</code> and find its distance from all the thieves in the <code>grid</code>. We can then pick the smallest distance as the safeness factor for that cell.</p>
<p>However, this brute force approach would have a time complexity of <span class="math inline">\(O(n^4)\)</span>, which would not satisfy the constraints of the problem. Therefore, a more optimized approach is needed.</p>
<p>To optimize the solution, we can leverage the properties of a multi-source breadth-first Search (BFS). Instead of finding the distance of each cell from all the thieves, we can do the opposite: find the distance of all the thieves from each cell.</p>
<blockquote>
<p>Note: A multi-source breadth-first search is a BFS where multiple starting nodes are explored simultaneously. This is an efficient method to find the shortest distances from any of the starting nodes to all reachable nodes in the graph. You can refer to this excellent <strong><a href="https://leetcode.com/problems/rotting-oranges/">problem</a></strong> to gain some practice on multi-source BFS.</p>
</blockquote>
<p>The intuition for this can be,</p>
<ul>
<li>We start by adding all the thief coordinates to a queue as the initial points of exploration.</li>
<li>We then explore the neighboring cells (up, down, left, and right) from all the thieves in one iteration, like ripples spreading outwards from each thief.</li>
<li>As we visit each cell, we mark it with the minimum distance from the nearest thief. This is because the first time a cell is visited, it means that the current thief is the closest one to that cell.</li>
<li>We continue the BFS traversal until all the cells in the <code>grid</code> are marked with their corresponding safeness values.</li>
</ul>
<p>The following slideshow demonstrates how the BFS gradually populates the <code>grid</code> with its minimum distances from a thief.</p>
<p>!?!../Documents/2812/bfs_slideshow.json:412,291!?!</p>
<p>Now that we have the safeness factor of each cell, we need to find the maximum safeness factor for which a path exists from the source cell to the destination cell. This implies that for all safeness values greater than it, no path exists, and at least one path exists for all values less than it. We can visualize these safeness factors as a monotonic sequence on a number line. The values that satisfy the constraints of the problem will be a contiguous series. These will be followed by a series of values that do not satisfy the constraints. We will name this breakpoint the inflection point.</p>
<p>The following slideshow visualizes how we iteratively converge to the location of the inflection point using binary search.</p>
<p>!?!../Documents/2812/bs_slideshow.json:482,160!?!</p>
<p>During the binary search, to determine if a safeness value meets the problem constraints, we employ another breadth-first search (BFS) traversal on the <code>grid</code>. The traversal attempts to find a path where every cell in the path satisfies this minimum safeness value. If such a path is found, it indicates that the given safeness value is a valid solution to the problem.</p>
<p>Thus, to find the maximum safeness factor, we can use binary search to efficiently locate the inflection point in this monotonic sequence. The last &quot;True&quot; value at the inflection point will be the maximum safeness factor for which a path exists.</p>
<p>In summary, the final solution involves two key steps:</p>
<ol>
<li>Perform a breadth-first search to compute the safeness factor for each cell, leveraging the fact that the first time a cell is visited, it represents the minimum distance from the nearest thief.</li>
<li>Apply binary search to find the maximum safeness factor for which a path exists from the source to the destination cell.</li>
</ol>
<p>This approach is more efficient than the initial brute-force solution, as it avoids the need to calculate the distance of each cell from all the thieves. Instead, it focuses on finding the distance of each cell from all the thieves, which can be done more optimally manner using BFS.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
<li>Define <code>isValidSafeness</code> method to check if a path exists with a minimum safeness value.</li>
</ul>
<h5 id="isvalidcell-method"><code>isValidCell</code> Method</h5>
<ol>
<li>Take the <code>grid</code>, row <code>i</code>, and column <code>j</code> as input.</li>
<li>Get the size of the <code>grid</code>, denoted by <code>n</code>.</li>
<li>Check if the cell at (<code>i</code>, <code>j</code>) is within the <code>grid</code> boundaries.</li>
<li>Return <code>true</code> if the cell is valid, <code>false</code> otherwise.</li>
</ol>
<h5 id="isvalidsafeness-method"><code>isValidSafeness</code> Method</h5>
<ol>
<li>
<p>Take the <code>grid</code> and the minimum safeness value as input.</p>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
<li><code>visited</code> as a 2-D array to mark visited cells.</li>
</ul>
</li>
<li>
<p>Check if the source and destination cells satisfy the minimum safeness.</p>
</li>
<li>
<p>Perform a breadth-first search (BFS) to find a valid path:</p>
<ul>
<li>Initialize a queue <code>q</code> to contain the coordinates.</li>
<li>Add the source cell (<code>0</code>, <code>0</code>) to the queue.</li>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells in all directions:
<ul>
<li>If the neighboring cell is valid, unvisited and has a safeness value greater than or equal to the minimum safeness value:
<ul>
<li>Mark the cell as visited and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If a valid path is found, return <code>true</code>.</li>
</ul>
</li>
<li>
<p>Return <code>false</code> if no valid path is found.</p>
</li>
</ol>
<h5 id="signature-function-maximumsafenessfactor">Signature function <code>maximumSafenessFactor</code></h5>
<ol>
<li>
<p>Initialize a queue <code>q</code> to store the positions of thieves.</p>
</li>
<li>
<p>Mark thieves as <code>0</code> and empty cells as <code>-1</code>, and push thieves to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform a binary search for the maximum safeness factor:</p>
<ul>
<li>Initialize <code>start</code> and <code>end</code> variables.</li>
<li>Initialize <code>res</code> to store the maximum safeness value.</li>
<li>Loop through the <code>grid</code> to find the maximum safeness factor and assign it to <code>end</code>.</li>
<li>While <code>start</code> is less than or equal to <code>end</code>:
<ul>
<li>Calculate <code>mid</code>.</li>
<li>Check if a valid safeness exists for <code>mid</code> using <code>isValidSafeness</code> method.</li>
<li>Update <code>res</code> if valid safeness is found.</li>
<li>Update <code>start</code> or <code>end</code> based on the result of <code>isValidSafeness</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum safeness factor <code>res</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3UY5NMSg/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The time complexity for the initial BFS is <span class="math inline">\(O(n^2)\)</span>, as each cell in the <span class="math inline">\(n \cdot n\)</span> <code>grid</code> is visited once during the traversal.</p>
<p>The binary search occurs in the range [0, maximum safeness factor possible], where the maximum safeness factor possible is <span class="math inline">\(2 \cdot n\)</span>. The time complexity of the binary search is <span class="math inline">\(O(\log (2 \cdot n))\)</span>, which is equivalent to <span class="math inline">\(O(\log n)\)</span>.</p>
<p>For each iteration of the binary search, a breadth-first Search is conducted to verify validity, which has a time complexity of <span class="math inline">\(O(n^2)\)</span>. Thus, the total time complexity of the binary search portion is <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log n)\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The data structure used in the algorithm is a queue, which takes linear space. Since the total number of cells in the <code>grid</code> is <span class="math inline">\(n^2\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-bfs--greedy">Approach 2: BFS + Greedy</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a binary search strategy to find the maximum safeness factor for which a path exists from the source to the destination. While this was an efficient solution, the intuition behind this approach is to directly find the optimal path from the source to the destination by leveraging Dijkstra's algorithm.</p>
<p>Similar to the previous approach, we first need to populate the <code>grid</code> with the safeness values for each cell. The algorithm to achieve this is the same as before, using the breadth-first Search (BFS) technique to compute the distance of each cell from the nearest thief.</p>
<p>The key idea here is to use Dijkstra's single source shortest path algorithm to find the optimal path from the source cell <code>[0, 0]</code> to the destination cell <code>[n-1, n-1]</code>. However, since each cell in the <code>grid</code> already contains its safeness factor, we need to modify Dijkstra's algorithm to find the path with the maximum safeness factor. In our modified Dijkstra's algorithm, we can greedily prioritize cells with a higher safeness factor to append to our path. The safeness factor of the path would be the minimum of the safeness values encountered in that path so far. Once we reach the destination cell, the safeness factor of the path would represent the required maximum safeness factor.</p>
<p>The modified Dijkstra's algorithm works as follows:</p>
<ul>
<li>We start with the source cell <code>[0, 0]</code> in a priority queue, where the priority is based on the highest safeness factor encountered in the path so far.</li>
<li>For efficiency, cells we've explored are marked as -1 in the <code>grid</code> itself.</li>
<li>If the current cell is the destination <code>[n-1, n-1]</code>, the traversal is over, and we return the maximum safeness factor encountered so far.</li>
<li>If the current cell is not the destination, we explore the valid adjacent cells. A cell is considered valid if it is within the <code>grid</code> boundaries and not visited yet (not -1).</li>
<li>For each valid neighbor, we calculate the potential safeness factor considering the current path's safeness and the new cell's distance to thieves. The minimum of these two values becomes the new safeness for the path with the addition of the neighbor.</li>
<li>We add the valid neighbors to the priority queue, prioritizing them based on their safeness factor.</li>
<li>We continue the exploration until we reach the destination cell.</li>
</ul>
<p>The key advantage of this approach is that it directly finds the optimal path from the source to the destination instead of relying on a binary search to find the maximum safeness factor. By using Dijkstra's algorithm, we can ensure that we find the path with the maximum safeness factor, without the need to perform a separate binary search.</p>
<p>Additionally, this approach may be more intuitive for some users, as it closely resembles the problem of finding the shortest path with the maximum weight (safeness factor) on a weighted graph.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define the <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
</ul>
<ol>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
</ul>
</li>
<li>
<p>Mark thieves as 0 and empty cells as -1 in the <code>grid</code>. Push thieves' coordinates to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize a priority queue <code>pq</code> to prioritize cells with a higher safeness factor. Push the starting cell to <code>pq</code>.</p>
</li>
<li>
<p>Perform BFS to find the path with the maximum safeness factor:</p>
<ul>
<li>While the priority queue <code>pq</code> is not empty:
<ul>
<li>Retrieve the top element <code>curr</code> from <code>pq</code>.</li>
<li>If the destination is reached, return the safeness factor of the path.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and not marked as visited:
<ul>
<li>Update the safeness factor for the path and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no path is found, return -1.</p>
</li>
</ol>
<blockquote>
<p>Note: In the C++ implementation, the elements in the priority queue are stored as <code>[safeness, row, col]</code> to leverage C++'s default comparison capabilities.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/UHkVoNQF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2 \cdot \log (n))\)</span></p>
<p>Similar to Approach 1, the time complexity of the initial BFS is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>To find the optimal path, we use Dijkstra's single source shortest path algorithm, which has a time complexity of <span class="math inline">\(O(n^2 \cdot \log (n))\)</span> when implemented in a <code>grid</code> of size <span class="math inline">\(n \cdot n\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log (n))\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log (n))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The two data structures used in this approach are the queue and the priority queue, both of which have a linear space complexity. Since the maximum number of elements that can be present in the queues is <span class="math inline">\(n \cdot n\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-whether-path-exist5238/1" target="_blank" rel="noopener noreferrer">Find whether path exist</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a grid of size <strong>n</strong>*<strong>n</strong>&nbsp;filled with 0, 1, 2, 3. Check whether there is a path possible from the source to destination.&nbsp;You can traverse up, down, right and left.<br />The description of cells is as follows:</span></p>
<ul>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>1</strong>&nbsp;means Source.</span></li>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>2</strong>&nbsp;means Destination.</span></li>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>3</strong>&nbsp;means Blank cell.</span></li>
<li><span style="font-size: 18px;">A value of cell <strong>0&nbsp;</strong>means Wall (blocked cell which we cannot traverse).</span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Note</strong>: There are only a single source and a single destination.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{3,0,3,0,0},{3,0,0,0,3},{3,3,3,3,3},{0,2,3,0,0},{3,0,0,1,3}}
<strong>Output: </strong>0
<strong>Explanation: </strong>The grid is-
3 0 3 0 0&nbsp;
3 0 0 0 3&nbsp;
3 3 3 3 3&nbsp;
0 2 3 0 0&nbsp;
3 0 0 1 3&nbsp;
There is no path to reach at (3,1) i,e at destination from (4,3) i,e source.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{1,3},{3,2}}
<strong>Output: </strong>1
<strong>Explanation: </strong>The grid is-
<span style="color: #000000;">1 3
3 2
</span>There is a path from (0,0) i,e source to (1,1) i,e destination.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(n<sup>2</sup>)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/firing-employees5306/1" target="_blank" rel="noopener noreferrer">Firing employees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">primenumber</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Geek is the founder of Geek Constructions. He always maintains a black-list&nbsp;of potential employees which can be fired at any moment.</span></p>
<p><span style="font-size: 18px;">The company has N employees (including Geek), and each employee is assigned a distinct rank (1 &lt;= rank &lt;= N) at the time of joining. The company has a hierarchical &nbsp;management such that each employee always has one immediate senior.&nbsp;</span></p>
<p><span style="font-size: 18px;">Geek has a strange and unfair way of evaluating an employees performance. He sums the employee's rank and the number of seniors the employee has. If it is a prime number, the employee is put up on the black-list.</span></p>
<p><span style="font-size: 18px;">Given an&nbsp;array arr[] in order of the rank of company employees. For rank i, arr[i] represents the rank of the immediate senior of the employee with the ith rank. If geek's rank is i, then arr[i] is always equal to 0 as there is no one senior to him. Find out the number of Black-Listed employees.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> The black-list can not&nbsp;contain Geeks name as he is the founder of the company and he is the one that makes the list.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 4
arr[] = {0, 1, 1, 2}</span>

<strong><span style="font-size: 18px;">Output: 1</span></strong>

<span style="font-size: 18px;"><strong>Explanation:</strong>
The hierarchy is as follows</span>

<span style="font-size: 18px;">       (Geek)
       Rank 1
        /   \
  Rank 2     Rank 3  
      /
Rank 4</span>

<span style="font-size: 18px;">Performance = rank + number of seniors
Performance for rank 1 = not considered.
Performance for rank 2 = 2+1 = 3 (prime)
Performance for rank 3 = 3+1 = 4 (not prime)
Performance for rank 4 = 4+2 = 6 (not prime)
Therefore, only employee 1 is black-listed.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 3
arr[] = {2, 3, 0}</span>

<span style="font-size: 18px;"><strong>Output:</strong> 2</span>

<span style="font-size: 18px;"><strong>Explanation: </strong>
The hierarchy is as follows</span>

<span style="font-size: 18px;">       (Geek)
       Rank 3
        /   
  Rank 2     
      /
Rank 1
</span>
<span style="font-size: 18px;">Performance for rank 3 = not considered. 
Performance for rank 2 = 2+1 = 3 (prime) 
Performance for rank 1 = 1+2 = 3 (prime)</span>
<span style="font-size: 18px;">Rank 1 and 2 are both black-listed.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task: &nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function<strong> firingEmployees()</strong> which takes the array arr[] and its size N as input parameters. It returns the number of black-listed employees.&nbsp;</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(N)<br /><strong>Expected Auxiliary Space:</strong> O(N)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>5</sup><br />1 &lt;= i &lt;= N<br />1 &lt;= arr[i] &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flood-fill/description" target="_blank" rel="noopener noreferrer">Flood Fill</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an image represented by an <code>m x n</code> grid of integers <code>image</code>, where <code>image[i][j]</code> represents the pixel value of the image. You are also given three integers <code>sr</code>, <code>sc</code>, and <code>color</code>. Your task is to perform a <strong>flood fill</strong> on the image starting from the pixel <code>image[sr][sc]</code>.</p>

<p>To perform a <strong>flood fill</strong>:</p>

<ol>
	<li>Begin with the starting pixel and change its color to <code>color</code>.</li>
	<li>Perform the same process for each pixel that is <strong>directly adjacent</strong> (pixels that share a side with the original pixel, either horizontally or vertically) and shares the <strong>same color</strong> as the starting pixel.</li>
	<li>Keep <strong>repeating</strong> this process by checking neighboring pixels of the <em>updated</em> pixels&nbsp;and modifying their color if it matches the original color of the starting pixel.</li>
	<li>The process <strong>stops</strong> when there are <strong>no more</strong> adjacent pixels of the original color to update.</li>
</ol>

<p>Return the <strong>modified</strong> image after performing the flood fill.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[[2,2,2],[2,2,0],[2,0,1]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg" style="width: 613px; height: 253px;" /></p>

<p>From the center of the image with position <code>(sr, sc) = (1, 1)</code> (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.</p>

<p>Note the bottom corner is <strong>not</strong> colored 2, because it is not horizontally or vertically connected to the starting pixel.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">[[0,0,0],[0,0,0]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == image.length</code></li>
	<li><code>n == image[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>0 &lt;= image[i][j], color &lt; 2<sup>16</sup></code></li>
	<li><code>0 &lt;= sr &lt; m</code></li>
	<li><code>0 &lt;= sc &lt; n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>We perform the algorithm explained in the problem description: paint the starting pixels, plus adjacent pixels of the same color, and so on.</p>
<p><strong>Algorithm</strong></p>
<p>Say <code>color</code> is the color of the starting pixel. Let's flood fill the starting pixel: we change the color of that pixel to the new color, then check the 4 neighboring pixels to make sure they are valid pixels of the same <code>color</code>, and of the valid ones, we flood fill those, and so on.</p>
<p>We can use a function <code>dfs</code> to perform a flood fill on a target pixel.</p>
<p><a href="https://leetcode.com/playground/StwTP8bA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of pixels in the image. We might process every pixel.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the implicit call stack when calling <code>dfs</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flower-planting-with-no-adjacent/description" target="_blank" rel="noopener noreferrer">Flower Planting With No Adjacent</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> gardens, labeled from <code>1</code> to <code>n</code>, and an array <code>paths</code> where <code>paths[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> describes a bidirectional path between garden <code>x<sub>i</sub></code> to garden <code>y<sub>i</sub></code>. In each garden, you want to plant one of 4 types of flowers.</p>

<p>All gardens have <strong>at most 3</strong> paths coming into or leaving it.</p>

<p>Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.</p>

<p>Return <em><strong>any</strong> such a choice as an array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the type of flower planted in the </em><code>(i+1)<sup>th</sup></code><em> garden. The flower types are denoted </em><code>1</code><em>, </em><code>2</code><em>, </em><code>3</code><em>, or </em><code>4</code><em>. It is guaranteed an answer exists.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, paths = [[1,2],[2,3],[3,1]]
<strong>Output:</strong> [1,2,3]
<strong>Explanation:</strong>
Gardens 1 and 2 have different types.
Gardens 2 and 3 have different types.
Gardens 3 and 1 have different types.
Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, paths = [[1,2],[3,4]]
<strong>Output:</strong> [1,2,1,2]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
<strong>Output:</strong> [1,2,3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>paths[i].length == 2</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li>Every garden has <strong>at most 3</strong> paths coming into or leaving it.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/freedom-trail/description" target="_blank" rel="noopener noreferrer">Freedom Trail</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In the video game Fallout 4, the quest <strong>&quot;Road to Freedom&quot;</strong> requires players to reach a metal dial called the <strong>&quot;Freedom Trail Ring&quot;</strong> and use the dial to spell a specific keyword to open the door.</p>

<p>Given a string <code>ring</code> that represents the code engraved on the outer ring and another string <code>key</code> that represents the keyword that needs to be spelled, return <em>the minimum number of steps to spell all the characters in the keyword</em>.</p>

<p>Initially, the first character of the ring is aligned at the <code>&quot;12:00&quot;</code> direction. You should spell all the characters in <code>key</code> one by one by rotating <code>ring</code> clockwise or anticlockwise to make each character of the string key aligned at the <code>&quot;12:00&quot;</code> direction and then by pressing the center button.</p>

<p>At the stage of rotating the ring to spell the key character <code>key[i]</code>:</p>

<ol>
	<li>You can rotate the ring clockwise or anticlockwise by one place, which counts as <strong>one step</strong>. The final purpose of the rotation is to align one of <code>ring</code>&#39;s characters at the <code>&quot;12:00&quot;</code> direction, where this character must equal <code>key[i]</code>.</li>
	<li>If the character <code>key[i]</code> has been aligned at the <code>&quot;12:00&quot;</code> direction, press the center button to spell, which also counts as <strong>one step</strong>. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.</li>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2018/10/22/ring.jpg" style="width: 450px; height: 450px;" />
<pre>
<strong>Input:</strong> ring = &quot;godding&quot;, key = &quot;gd&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong>
For the first key character &#39;g&#39;, since it is already in place, we just need 1 step to spell this character. 
For the second key character &#39;d&#39;, we need to rotate the ring &quot;godding&quot; anticlockwise by two steps to make it become &quot;ddinggo&quot;.
Also, we need 1 more step for spelling.
So the final output is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ring = &quot;godding&quot;, key = &quot;godding&quot;
<strong>Output:</strong> 13
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>
	<li><code>ring</code> and <code>key</code> consist of only lower case English letters.</li>
	<li>It is guaranteed that <code>key</code> could always be spelled by rotating <code>ring</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to find the minimum number of steps required to spell the keyword (given as <code>key</code>), using the metal dial (given as <code>ring</code>). The characters of the keyword must be spelled in order.</p>
<p>Any one of the following operations counts as one step:</p>
<ol>
<li>Rotate the metal dial clockwise by one place.</li>
<li>Rotate the metal dial anticlockwise by one place.</li>
<li>Press the center button to spell a character.</li>
</ol>
<p>When spelling a given character <code>key[i]</code>, the number of steps it takes to spell the character will be the number of rotations made to put the character in the <code>&quot;12:00&quot;</code> position plus one, which represents pressing the center button to spell the character.</p>
<hr />
<h3 id="approach-1-top-down-dynamic-programming">Approach 1: Top-Down Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>We want to find the minimum number of steps required to spell the keyword, which is made up of one or more characters. Let's start by finding the minimum number of steps required to spell one character.</p>
<p>To spell a character, we must align the character with the <code>&quot;12:00&quot;</code> direction on the metal dial <code>ring</code>. To determine the number of steps required to do so, let's define a function called <code>countSteps</code>. The parameters for this function are:</p>
<ul>
<li><code>curr</code>: the position, or index, in the <code>ring</code> of the character currently located at the <code>&quot;12:00&quot;</code> position.</li>
<li><code>next</code>: the index in the <code>ring</code> of the character that needs to be spelled out in <code>key</code>.</li>
</ul>
<p>The metal dial can be turned clockwise or anticlockwise to reach the desired character in <code>key</code>.</p>
<p>Assuming <code>curr</code> comes before <code>next</code>, we calculate the difference between <code>curr</code> and <code>next</code>, denoted as <code>curr - next</code>. Since <code>next</code> could be either before or after <code>curr</code>, potentially resulting in a negative difference, we obtain the absolute value of the difference to represent the number of steps between the indices. Let's store this value in the variable <code>stepsBetween</code>.</p>
<blockquote>
<p>An example of this process is the string <code>godding</code>, where <code>'o'</code> is at index <code>1</code> and <code>'n'</code> is at index <code>5</code>. When <code>curr = 1</code> and <code>next = 5</code>, we compute <code>|5 - 1| = 4</code>, and when <code>cur = 5</code> and <code>next = 1</code>  we compute <code>|1 - 5| = 4</code>.</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>o</td>
<td>d</td>
<td>d</td>
<td>i</td>
<td>n</td>
<td>g</td>
</tr>
</tbody>
</table>
</blockquote>
<p>To calculate the steps required to rotate from <code>curr</code> to <code>next</code> by wrapping around the metal dial, we subtract the value of <code>stepsBetween</code> from the length of the <code>ring</code>, denoted as <code>ringLength - stepsBetween</code>. Let's store this result in the variable <code>stepsAround</code>.</p>
<blockquote>
<p>Using the previous example, traversing <code>'o'</code> to <code>'n'</code>,  <code>ringLength</code> is <code>7</code> and <code>stepsBetween</code> is 4.  <code>7 - 4 = 3</code>.</p>
</blockquote>
<p>Finally, <code>countSteps</code> returns the minimum of the two distances, <code>stepsAround</code> and <code>stepsBetween</code>.</p>
<p><img src="../Figures/514/metal_dial.png" alt="Possible Paths Between o and n" /></p>
<blockquote>
<p>Steps from <code>'o'</code> to <code>'n'</code> in <code>godding</code>.</p>
<ul>
<li>The red arrow represents <code>stepsBetween</code>, where <code>'n'</code> is reached without wrapping around the end of the string.</li>
<li>The blue arrow represents <code>stepsAround</code>, where <code>'n'</code> is reached by wrapping around the end of the string.</li>
</ul>
</blockquote>
<p><strong><code>countSteps</code> function</strong></p>
<ol>
<li>Calculate <code>stepsBetween</code> by taking the absolute value of <code>curr - next</code>.</li>
<li>Calculate <code>stepsAround</code> using <code>ringLength - stepsBetween</code>.</li>
<li>Return <code>min(steps_around, steps_between)</code>.</li>
</ol>
<p><strong>Brute Force</strong></p>
<p>To achieve our goal using a naive approach, we could calculate the minimum steps for each character in the keyword individually and then sum them to find the minimum steps needed to spell the entire keyword. This method would be considered greedy because it selects the locally optimal next character. However, what if a word has multiple occurrences of the same character?</p>
<p>Let's understand this through example. Assume the <code>ring</code> is <code>repetitive</code> and the key is <code>per</code>.</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>e</td>
<td>p</td>
<td>e</td>
<td>t</td>
<td>i</td>
<td>t</td>
<td>i</td>
<td>v</td>
<td>e</td>
</tr>
</tbody>
</table>
<p>There are at least two ways to spell the keyword:</p>
<ol>
<li>
<ul>
<li>Let's spell the <code>p</code> at index <code>2</code>. It will take <code>|2 - 0| + 1 = 3</code> steps.</li>
<li>Then, let's choose the <code>e</code> at index <code>3</code>. It will take <code>|3 - 2| + 1 = 2</code> steps.</li>
<li>Going back to <code>r</code> at index <code>0</code> will take <code>|0 - 3| + 1 = 4</code> steps.</li>
</ul>
<p>This totals <code>9</code> steps.</p>
</li>
<li>
<ul>
<li>Let's spell the <code>p</code> at index <code>2</code>. It will take <code>|2 - 0| + 1 = 3</code> steps.</li>
<li>Then, let's choose the <code>e</code> at index <code>1</code>. It will take <code>|1 - 2| + 1 = 2</code> steps.</li>
<li>Going back to <code>r</code> at index <code>0</code> will take <code>|0 - 1| + 1 = 2</code> steps.</li>
</ul>
<p>This totals <code>7</code> steps.</p>
</li>
</ol>
<p>Therefore, we need to consider which character we were at previously.</p>
<p>For this problem, the greedy method does not lead to an optimal solution. If a word has multiple occurrences of the same character, the minimum steps to the next character are affected by which character was previously at the <code>&quot;12:00&quot;</code> position.</p>
<p>We will define a recursive function, <code>tryLock</code>, to calculate the number of steps to spell the keyword. The parameters are:</p>
<ul>
<li><code>ringIndex</code>: the current index of <code>ring</code>.</li>
<li><code>keyIndex</code>: the current index of <code>key</code>.</li>
<li><code>minSteps</code>: the minimum steps to spell the keyword so far.</li>
</ul>
<p>This function returns the minimum number of steps required to spell the whole keyword, stored in the variable <code>minSteps</code>.</p>
<p>When we reach the end of the keyword, we have spelled the whole word. Therefore, our base case is <code>keyIndex == key.length()</code>. At that point, the <code>keyIndex</code> is past the end of the keyword, and no steps need to be taken, so we return zero.</p>
<p>Given two characters, if there is only one occurrence of each character in <code>ring</code>, then there are only two ways between those characters. Our function <code>countSteps</code> will provide the number of steps of the better way. We simply need to add one to signify pressing the center button.</p>
<p>To find <code>minSteps</code> for the whole word based on a given choice between characters, we can recursively call <code>tryLock</code>, calculating the steps from the character we just visited to the next character in <code>key</code>. This will tell us how visiting a given occurrence of a character affects the overall <code>minSteps</code>. Since there are multiple options for spelling when there are multiple occurrences of a character, we will loop through the keyword and calculate <code>bestSteps</code> for each duplicate occurrence.</p>
<p>When we call <code>tryLock</code>, we will pass the largest integer as a parameter because a path has not been determined between the zeroth index of <code>ring</code> and the first character in <code>key</code>. This way, when we update <code>minSteps</code>, the calculation will always be less than the initial amount, so we can accurately calculate the number of steps.</p>
<p><strong>Brute Force Algorithm</strong></p>
<ol>
<li>Define a function <code>countSteps</code> that gives the minimum path between two indices of <code>ring</code>.</li>
<li>Define a function <code>tryLock</code> that returns the minimum number of steps to spell the keyword. The parameters are <code>ringIndex</code>, the current index of <code>ring</code>, <code>keyIndex</code>, the current index of <code>key</code>, and <code>minSteps</code>, the minimum steps to spell the keyword so far:
<ol>
<li>If <code>key_index</code> is equal to <code>key.length()</code>, then return <code>0</code>; <code>key</code> has been spelled.</li>
<li>Iterate through each character in the <code>ring</code> using <code>i</code>:
<ol>
<li>If <code>ring[i]</code> equals the current character <code>key[keyIndex]</code>:
<ul>
<li>Calculate <code>totalSteps</code>, the steps it takes to spell <code>key</code> when we visit <code>ring[i]</code> by adding the following three terms:
<ul>
<li>The output of <code>countSteps</code> which finds the number of steps from the <code>ringIndex</code> to <code>ring[i]</code>.</li>
<li><code>1</code>, signifying pressing the center button.</li>
<li>The output of <code>tryLock</code>, which calculates how many steps to each character in <code>key</code> are required if we choose to visit <code>ring[i]</code>.</li>
</ul>
</li>
<li>Save the minimum between <code>totalSteps</code> and the best so far in <code>minSteps</code>.</li>
</ul>
</li>
</ol>
</li>
<li>Return <code>minSteps</code>.</li>
</ol>
</li>
<li>Call <code>tryLock(0, 0, INT_MAX)</code> as we start with the zeroth index of <code>ring</code> in the  <code>&quot;12:00&quot;</code> position and start spelling with the first character in <code>key</code>. The largest integer is passed as the final parameter because a path has not been determined between the zeroth index of <code>ring</code> and the first character in <code>key</code>.</li>
</ol>
<p><a href="https://leetcode.com/playground/Hs2Uuf4G/shared">code</a></p>
<p>This solution is inefficient and is not accepted because the time limit is exceeded. We compute the output of the same argument multiple times.</p>
<p><img src="../Figures/514/repeated_subproblems.png" alt="repeated_subproblems" /></p>
<p>Is there a more efficient way to solve this problem? The problem involves finding a minimum, which is a hint that it could be solved with a greedy or dynamic programming approach. Since one decision affects others, a greedy approach is not likely to solve the problem, but dynamic programming could be an effective approach. Can we use dynamic programming to make this approach more efficient?</p>
<blockquote>
<p>Dynamic programming is a programming paradigm in which we break a problem into sub-problems, store the result of each sub-problem, and use it when required. If you are not familiar with dynamic programming, we recommend checking out <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming Explore Card</a>.</p>
</blockquote>
<p>We can optimize our calculations by storing values as we calculate them. To do this, we can utilize a map called <code>bestSteps</code>, where we store the best path we have found to reach a particular <code>keyIndex</code> of <code>key</code> when the <code>ringIndex</code> of <code>ring</code> is aligned with the <code>&quot;12:00&quot;</code> position.</p>
<p>We adjust our <code>tryLock</code> function in two ways:</p>
<ol>
<li>We check whether the <code>ringIndex</code> and <code>keyIndex</code> pair is already in the map. If it is, we return the stored <code>minSteps</code> value.</li>
<li>We only calculate the optimum for new <code>(ringIndex, keyIndex)</code> pairs, and when we do, we add them to the map.</li>
</ol>
<p>This approach saves computational time by avoiding redundant calculations and utilizing stored values whenever possible.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Define a function <code>countSteps</code> that gives the minimum path between two indices of <code>ring</code>.</li>
<li>Create the variables <code>ringLen</code> to store the length of the <code>ring</code> and <code>keyLen</code> to store the length of the <code>key</code>.</li>
<li>Create a map, <code>bestSteps</code>, to store the minimum number of steps to find the character at <code>keyIndex</code> when the <code>ringIndex</code> of <code>ring</code> is aligned with the <code>&quot;12:00&quot;</code> position.</li>
<li>Define a function <code>tryLock</code> that returns the minimum number of steps to spell the keyword. The parameters are <code>ringIndex</code>, <code>keyIndex</code>, and <code>minSteps</code>, the minimum steps to spell the keyword so far:
<ol>
<li>Check whether <code>keyIndex</code> equals <code>keyLen</code>; if so return <code>0</code>; <code>key</code> has been spelled.</li>
<li>Check whether the <code>(ringIndex, keyIndex)</code> pair is in <code>bestSteps</code>. If it is, return <code>bestSteps[ringIndex][keyIndex]</code>; we have already calculated the best path.</li>
<li>Iterate through each <code>charIndex</code> in <code>ring</code>:
<ol>
<li>If <code>ring[charIndex]</code> equals the current character <code>key[keyIndex]</code>:
<ul>
<li>Calculate <code>totalSteps</code>, the steps it takes to spell <code>key</code> when we visit this occurrence of <code>ring[charIndex]</code> by adding the following three terms:
<ul>
<li>The output of <code>countSteps</code>, which finds the number of steps from the <code>ringIndex</code> to the <code>ring[charIndex]</code>.</li>
<li><code>1</code>, which signifies pressing the center button.</li>
<li>The output of <code>tryLock</code>, which calculates the number of steps to each character in <code>key</code>, granted we chose to visit this occurrence of <code>ring[charIndex]</code>.</li>
</ul>
</li>
<li>Save the minimum between <code>totalSteps</code> and the best so far in <code>minSteps</code>.</li>
<li>Save the <code>minSteps</code> for this <code>(ringIndex, keyIndex)</code> pair in <code>bestSteps</code>.</li>
</ul>
</li>
</ol>
</li>
<li>Return <code>minSteps</code>.</li>
</ol>
</li>
<li>Call <code>tryLock(0, 0, INT_MAX)</code> as we start with the zeroth index of <code>ring</code> in the <code>&quot;12:00&quot;</code> position and start spelling with the first character in <code>key</code>. The largest integer is passed as the final parameter because a path has not been determined between the zeroth index of <code>ring</code> and the first character in <code>key</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/avfRubs9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(R\)</span> be the length of <code>ring</code> and <span class="math inline">\(K\)</span> be the length of <code>key</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(K \cdot R^2)\)</span>.</p>
<p>When every character in <code>ring</code> is unique, <span class="math inline">\(K\)</span> recursive calls are made, one for each letter in the keyword.</p>
<p>At worst, when every character of <code>ring</code> is the same, we initially call <code>trylock</code> <span class="math inline">\(R\)</span> times. For each of these <span class="math inline">\(R\)</span> recursive calls, <code>tryLock</code> is called for each occurrence of the character in <code>ring</code> for each character in the keyword. This means the <code>trylock</code> function is called a total of <span class="math inline">\(R \cdot K \cdot R\)</span> times.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(K \cdot R^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(K \cdot R)\)</span></p>
<p><span class="math inline">\(O(K \cdot R)\)</span> space is used for the map. The call stack can grow as deep as <span class="math inline">\(K\)</span> since a recursive call is made for each character in <code>key</code>. This makes the overall space complexity <span class="math inline">\(O(K \cdot R)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bottom-up-dynamic-programming">Approach 2: Bottom-Up Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The top-down solution involves recursion, which requires a significant amount of overhead to maintain the call stack. We can convert our top-down solution to a bottom-up solution to save space.</p>
<p>We can utilize the previously defined <code>tryLock</code> function. Additionally, we create a variable <code>ringLen</code> to store the length of the <code>ring</code> and a variable <code>keyLen</code> to store the length of the <code>key</code>.</p>
<p>In our top-down solution, we use a map <code>bestSteps</code> to store the minimum number of steps to <code>keyIndex</code> starting from the <code>ringIndex</code> of <code>ring</code>. To generate a bottom-up solution, we will use a 2D array <code>bestSteps[ringIndex][keyIndex]</code> to store the minimum number of steps to the <code>keyIndex</code> when the <code>ringIndex</code> of <code>ring</code> is aligned with the <code>&quot;12:00&quot;</code> position.</p>
<p>We declare the 2D array <code>bestSteps</code> with <code>ringLen</code> in the <code>ringIndex</code> dimension and <code>keyLen + 1</code> in the <code>keyIndex</code> dimension because our base case is when the whole <code>key</code> has been spelled, and zero additional steps need to be taken. We initialize every value in the array to the largest integer value. This way, when we iterate through the array updating the minimum number of steps, the steps calculation will always be less than the initialized amount, allowing us to correctly calculate the number of steps.</p>
<p>In a bottom-up solution, we start by addressing the base case. For every index pair <code>(ringIndex, keyLen)</code> in <code>bestSteps</code>, we initialize the value to zero because when the entire <code>key</code> has been spelled, no additional steps are needed.</p>
<p>Our bottom-up solution will be iterative. We need to iterate through both dimensions of <code>bestSteps</code>, so we'll use a nested for loop. We iterate through the indices <code>keyIndex</code> of <code>key</code>, starting with the last character in <code>key</code>, and for each, we iterate through the indices <code>ringIndex</code> of <code>ring</code>.</p>
<p>Similar to our top-down solution, we iterate through the characters using <code>charIndex</code> of <code>ring</code>, searching for indices in <code>ring</code> that contain the same character as <code>key[keyIndex]</code>. Each iteration of the innermost loop represents a state. We can utilize the function call we made in the top-down solution to build our recurrence relation. The calculations we performed in the top-down solution will be replicated here, but instead of recursion, we'll use our array <code>bestSteps</code>.</p>
<p>The recurrence relation calculates the minimum number of steps to find the character at <code>keyIndex</code> of <code>key</code> when the <code>ringIndex</code> of <code>ring</code> is aligned with the <code>&quot;12:00&quot;</code> position. Our recurrence relation is:</p>
<blockquote>
<p><code>bestSteps[r][k] = min(bestSteps[r][k], 1 + countSteps[r, charIndex] + bestSteps[charIndex][key_index + 1])</code></p>
</blockquote>
<p>The terms in the recurrence relation represent:</p>
<ul>
<li><code>bestSteps[ringIndex][keyIndex]</code>: the previous minimum number of steps to that occurrence of that character.</li>
<li><code>countSteps[ringIndex, charIndex]</code>: the minimum number of steps between the <code>ringIndex</code> aligned with the <code>&quot;12:00&quot;</code> position of <code>ring</code>, and the index of <code>charIndex</code>, the next character of the <code>key</code>.</li>
<li><code>1</code>: represents selecting the character by pressing the center button.</li>
<li><code>bestSteps[charIndex][keyIndex + 1]</code>: the number of steps it took to reach <code>charIndex</code> from the last character <code>key[keyIndex + 1]</code> the <code>ring</code> spelled.</li>
</ul>
<p>After iterating through both strings, we return <code>bestSteps[0][0]</code> which stores the minimum number of steps it took to spell <code>key</code> when <code>ring</code> begins with its zeroth index in the <code>&quot;12:00&quot;</code> position.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Define a function <code>countSteps</code> that gives the minimum path between two indices of <code>ring</code>.</p>
</li>
<li>
<p>Create the variables <code>ringLen</code> to store the length of <code>ring</code> and <code>keyLen</code> to store the length of <code>key</code>.</p>
</li>
<li>
<p>Declare a 2D array <code>bestSteps</code>. It will have <code>ringLen</code> rows and <code>keyLen + 1</code> columns.</p>
<blockquote>
<p><code>bestSteps</code> has one extra column because we want to store the base case of <code>0</code> steps.</p>
</blockquote>
</li>
<li>
<p>Initialize all values in <code>bestSteps</code> to the largest integer to indicate that a path has not been determined.</p>
</li>
<li>
<p>Set each index <code>ringIndex, keyLength</code> of <code>bestSteps</code>, to <code>0</code> for the base case of zero steps.</p>
</li>
<li>
<p>Iterate from the end to the beginning of <code>key</code> with <code>keyIndex</code> and through <code>ring</code> with <code>ringIndex</code>:</p>
<ul>
<li>For each character <code>ring[charIndex]</code> in <code>ring</code>:
<ul>
<li>If <code>ring[charIndex]</code> equals <code>key</code> at <code>keyIndex</code>: Use the recurrence relation <code>bestSteps[ringIndex][k] = min(bestSteps[ringIndex][k], 1 + countSteps[ringIndex, charIndex] + bestSteps[charIndex][keyIndex + 1])</code> to calculate the minimum number of steps to find the character at <code>keyIndex</code> of the keyword when the <code>ringIndex</code> of <code>ring</code> is aligned with the <code>&quot;12:00&quot;</code> position.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>bestSteps[0][0]</code> which stores the minimum number of steps to spell <code>key</code> when <code>ring</code> begins with its zeroth index in the <code>&quot;12:00&quot;</code> position.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/modUNNXg/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(R\)</span> be the length of <code>ring</code> and <span class="math inline">\(K\)</span> be the length of <code>key</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(K \cdot R^2)\)</span></p>
<p>We use nested loops iterating <span class="math inline">\(K\)</span> times through <code>key</code> and <span class="math inline">\(R\)</span> times through <code>ring</code> for all <span class="math inline">\(R\)</span> characters in <code>ring</code>. This gives an overall time complexity of <span class="math inline">\(O(K \cdot R^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(KR)\)</span></p>
<p>We use a 2D array with the dimensions <span class="math inline">\(K + 1\)</span> and <span class="math inline">\(R\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-space-optimized-bottom-up-dynamic-programming">Approach 3: Space-Optimized Bottom-Up Dynamic Programming</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Upon analyzing the bottom-up solution, we observe that when calculating the minimum number of steps for the <code>keyIndex</code> column of <code>bestSteps</code>, the only other column we refer to is the <code>keyIndex + 1</code> column. This means we can space-optimize the bottom-up solution, using two 1-D arrays to store the step calculations we need to reference. One array is for the current column, and the other array is for the previous column.</p>
<p>We will create the array <code>prev</code> to store the values of the last column and <code>curr</code> to store the values of the current column. We initialize the indices of <code>prev</code> to zero to represent that when the whole <code>key</code> has been spelled, zero additional steps need to be taken. We initialize the indices of <code>curr</code> to the largest integer to indicate that a path has not been determined between those indices.</p>
<p>For the space-optimized approach, we iterate through <code>key</code> and <code>ring</code> similarly to the bottom-up approach, but we adjust the recurrence relation to use our two columns <code>prev</code> and <code>curr</code>.</p>
<p>The recurrence relation finds the minimum number of steps to find the <code>key[keyIndex]</code> when the <code>ring[ringIndex]</code> is aligned with the <code>&quot;12:00&quot;</code> position and stores it in <code>curr[ringIndex]</code>. The adjusted relation is:</p>
<p><code>curr[ringIndex] = min(curr[ringIndex], 1 + countSteps[ringIndex, charIndex] + prev[charIndex])</code></p>
<p>The terms in the recurrence relation represent:</p>
<ul>
<li><code>curr[ringIndex]</code>: the current minimum number of steps to that index.</li>
<li><code>1</code>: represents selecting the character by pressing the center button.</li>
<li><code>countSteps[ringIndex, charIndex]</code>: gives the minimum number of steps between <code>ringIndex</code>, the index aligned with the position of <code>ring</code>, and the index of <code>charIndex</code>, the next character of the <code>key</code>.</li>
<li><code>prev[charIndex]</code>: the number of steps it took to reach <code>charIndex</code> from the last character the <code>key[keyIndex + 1]</code> the <code>ring</code> spelled.</li>
</ul>
<p>After iterating through both strings, we return <code>prev[0]</code> which stores the minimum number of steps to spell <code>key</code> when <code>ring</code> begins with its index <code>0</code> in the <code>&quot;12:00&quot;</code> position.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Define a function <code>countSteps</code> that gives the minimum path between two indices of <code>ring</code>.</li>
<li>Create the variables <code>ringLen</code> to store the length of <code>ring</code> and <code>keyLen</code> to store the length of <code>key</code>.</li>
<li>Declare a 1D array <code>prev</code> of size <code>ringLen</code> to store the previous column and initialize all indices to <code>0</code> for the base case of zero steps.</li>
<li>Declare a 1D array <code>curr</code> of size <code>ringLen</code> to store the current column and initialize all indices to the largest integer to indicate that a path has not been determined.</li>
<li>Iterate from the end to the beginning of <code>key</code> with <code>keyIndex</code>:
<ul>
<li>Reset all of the indices of <code>curr</code> to the largest integer.</li>
<li>For each character <code>charIndex</code> in <code>ring</code>:
<ul>
<li>If <code>ring</code> at <code>charIndex</code> equals <code>key</code> at <code>keyIndex</code>:</li>
<li>Use the recurrence relation <code>curr[ringIndex] = min(curr[ringIndex], 1 + countSteps[ringIndex, charIndex] + prev[charIndex])</code> to calculate the minimum number of steps to find the character at <code>keyIndex</code> of key when the <code>ringIndex</code> of <code>ring</code> is aligned with the <code>&quot;12:00&quot;</code> position.</li>
</ul>
</li>
<li>Set <code>prev</code> to <code>curr</code>.</li>
</ul>
</li>
<li>Return <code>prev[0]</code> which stores the minimum number of steps to spell <code>key</code> when <code>ring</code> begins with its zeroth index in the <code>&quot;12:00&quot;</code> position.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/gSzUnwFA/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(R\)</span> be the length of <code>ring</code> and <span class="math inline">\(K\)</span> be the length of <code>key</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(K \cdot R^2)\)</span></p>
<p>We use nested loops iterating <span class="math inline">\(K\)</span> times through <code>key</code> and <span class="math inline">\(R\)</span> times through <code>ring</code> for all <span class="math inline">\(R\)</span> characters in <code>ring</code>. This gives an overall time complexity of <span class="math inline">\(O(K \cdot R^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(R)\)</span>.</p>
<p>We used two arrays of length <span class="math inline">\(R\)</span> to store the minimum steps between the characters. This gives an overall space complexity of <span class="math inline">\(O(R)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-shortest-path">Approach 4: Shortest Path</h3>
<h4 id="intuition-3">Intuition</h4>
<p>If we think of the possible paths between the characters as a graph, we can spell the keyword using a modified Dijkstra’s algorithm. Dijkstra’s algorithm is used to find the shortest path from a source vertex to each of the other vertices in a weighted graph. It uses a priority queue (min-heap) to greedily determine which edges to use to find the shortest path to the other vertices.</p>
<blockquote>
<p>If you are not familiar with Dijkstra’s algorithm, we suggest you read our relevant <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Leetcode Explore Card</a>.</p>
</blockquote>
<p>We discussed in the first approach that a greedy solution that just considers the locally optimal next character will not solve the problem optimally. This shortest path solution works because we always choose the next character with the shortest total steps, not the shortest next steps.</p>
<p>For our purposes, each vertex is a character in the <code>ring</code> that is present in the keyword.</p>
<p>Dijkstra's algorithm generally uses an adjacency list that contains the neighbors of each vertex. We must visit vertices, or characters, in a certain order to spell the keyword. We need to decide which occurrence of a given character in <code>ring</code> we should visit. We use a hash map that stores the indices of each character in <code>ring</code>, where the key is the character and the value is the list of indices where it occurs in <code>ring</code>. The duplicate occurrences of specific characters are the &quot;neighbors&quot;.</p>
<p>Dijkstra's algorithm often uses a data structure to store vertices that have already been visited. We can use a hash map to store <code>(keyIndex, ringIndex)</code> pairs we have seen before.</p>
<p>We can track how many steps it takes to spell each character with <code>totalSteps</code>.</p>
<p>We use a min-heap to store the steps it takes to spell a given character in the keyword from a given index in <code>ring</code>. We start by adding the initial indices to the heap.</p>
<p>When we reach the end of the keyword, we have spelled the whole word. Therefore, our base case is when <code>keyIndex</code> equals <code>keyLen</code>. <code>totalSteps</code> accounts for the steps taken to spell the characters in the keyword but does not account for pressing the center button to spell a character. We press the center button exactly <code>keyLen</code> times to spell the keyword, once for each character. Therefore, we return the sum of <code>totalSteps</code> and <code>keyLen</code>.</p>
<p>When the keyword has not yet been spelled, we first check whether this <code>(keyIndex, ringIndex)</code> pair has been seen before. If so, we continue.</p>
<p>If we haven't seen this pair before, we need to find the minimum number of steps between the current and next character of the keyword using the metal dial.</p>
<p>For each occurrence of the current <code>key[keyIndex]</code> in <code>ring</code>, <code>nextIndex</code>, we add an entry to the heap that represents turning the metal dial to the next character in the keyword. The entry consists of three parts:</p>
<ul>
<li><code>totalSteps</code>: the sum of <code>toalSteps</code> and the output of <code>count_steps(ringIndex, nextIndex)</code>.</li>
<li><code>nextIndex</code>: the index of <code>ring</code> that will be at the <code>&quot;12:00&quot;</code> position, and</li>
<li><code>keyIndex + 1</code>: the next character in the keyword.</li>
</ul>
<p>Once the keyword has been spelled, we will have the answer, because we have greedily chosen the next character with the lowest total steps.</p>
<p><img src="../Figures/514/graph.png" alt="graph" /></p>
<blockquote>
<p>Possible paths to spell the keyword visualized as a graph. The shortest path is highlighted in green.</p>
</blockquote>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Define a function <code>countSteps</code> that gives the minimum path between two indices of <code>ring</code>.</li>
<li>Create the variables <code>ringLen</code> to store the length of <code>ring</code> and <code>keyLen</code> to store the length of <code>key</code>.</li>
<li>Create a hash map <code>characterIndices</code> and add each character in <code>ring</code> as a key and a list with the indices of the occurrences as the value.</li>
<li>Initialize a priority queue (min-heap) <code>heap</code> that stores the <code>totalSteps</code> for a <code>ringIndex</code> and <code>keyIndex</code> pair. The top of the heap will contain the smallest <code>totalSteps</code>. Add the starting steps, ring position, and key position, which are all <code>0</code> to the heap.</li>
<li>Create a hash set <code>seen</code> to store <code>ringIndex</code> and <code>keyIndex</code> pairs we have already seen.</li>
<li>While the <code>heap</code> is not empty:
<ul>
<li>Pop the element from the top of the heap.</li>
<li>Check whether the <code>keyIndex</code> equals the <code>keyLen</code>. If so, we have spelled the whole keyword.</li>
<li>Check whether this <code>ringIndex</code> and <code>keyIndex</code> pair has already been seen. If so, continue.</li>
<li>Otherwise, add this <code>ringIndex</code> and <code>keyIndex</code> pair to <code>seen</code>.</li>
<li>For each occurrence <code>nextIndex</code> in <code>ring</code> of the letter <code>key[keyIndex]</code>:
<ul>
<li>Add a heap entry that calculates the steps from <code>nextIndex</code> to the next character in <code>key</code>. The values for this entry are as follows:</li>
<li><code>totalSteps</code>: <code>totalSteps + count_steps(ringIndex, nextIndex)</code>.</li>
<li><code>ringIndex</code>: <code>nextIndex</code>.</li>
<li><code>keyIndex</code>: <code>keyIndex + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalSteps + keyLen</code>. We add <code>keyLen</code> to the steps to account for the center button being pressed once for each character in <code>key</code>.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/c2CkhwRQ/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(R\)</span> be the length of <code>ring</code> and <span class="math inline">\(K\)</span> be the length of <code>key</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(RK \cdot \log (RK))\)</span></p>
<p>Building the <code>characterIndices</code> hashmap takes <span class="math inline">\(O(R)\)</span> time as we add an entry for each character in <code>ring</code>.</p>
<p>The main loop will run once for each pair that we visit. We use the <code>seen</code> set, so we never visit the same <code>(keyIndex, ringIndex)</code> pair more than once. The maximum number of pairs we visit is the number of unique possible pairs, which is <span class="math inline">\(R \cdot K\)</span>.</p>
<p>Looking up a pair in <code>seen</code> takes <span class="math inline">\(O(1)\)</span> time in the average case.</p>
<p>It takes the priority queue <span class="math inline">\(O(RK \cdot \log (RK))\)</span> time to push or pop <span class="math inline">\(R \cdot K\)</span> elements from the queue.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(RK \cdot \log (RK))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(R \cdot K)\)</span></p>
<p>The <code>characterIndices</code> hashmap is size <span class="math inline">\(R\)</span> because it stores a total of <span class="math inline">\(R\)</span> <code>(character, index)</code> mappings.</p>
<p>The main space used is by the priority queue, which can store up to <span class="math inline">\(R \cdot K\)</span> pairs.</p>
<p>We also use the <code>seen</code> hash set, which can grow up to size <span class="math inline">\(R \cdot K\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/frog-position-after-t-seconds/description" target="_blank" rel="noopener noreferrer">Frog Position After T Seconds</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an undirected tree consisting of <code>n</code> vertices numbered from <code>1</code> to <code>n</code>. A frog starts jumping from <strong>vertex 1</strong>. In one second, the frog jumps from its current vertex to another <strong>unvisited</strong> vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.</p>

<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p><em>Return the probability that after <code>t</code> seconds the frog is on the vertex <code>target</code>. </em>Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg" style="width: 338px; height: 304px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
<strong>Output:</strong> 0.16666666666666666 
<strong>Explanation:</strong> The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after <strong>second 1</strong> and then jumping with 1/2 probability to vertex 4 after <strong>second 2</strong>. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg" style="width: 304px; height: 304px;" /></strong>

<pre>
<strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
<strong>Output:</strong> 0.3333333333333333
<strong>Explanation: </strong>The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after <strong>second 1</strong>. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>1 &lt;= t &lt;= 50</code></li>
	<li><code>1 &lt;= target &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/geeks-village-and-wells--170647/1" target="_blank" rel="noopener noreferrer">Geek&#39;s Village and Wells</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geek&#39;s village is represented by a 2-D matrix of characters of size n*m, where</span></p>

<p><span style="font-size:18px">H - Represents a house<br />
W - Represents a well<br />
. - Represents an open ground<br />
N - Prohibited area(Not allowed to enter this area)</span></p>

<p><span style="font-size:18px">Every house in the village needs to take water from a well, as the family members are so busy with their work, so every family wants to take the water from a well in minimum time, which is possible only if they have to cover as less distance as possible. Your task is to determine the minimum distance that a person in the house should travel to take out the water and carry it back to the house.</span></p>

<p><span style="font-size:18px">A person is allowed to move only in four directions left, right, up, and down. That means if he/she is the cell (i,j), then the possible cells he/she can reach in one move are (i,j-1),(i,j+1),(i-1,j),(i+1,j), and the person is not allowed to move out of the grid.</span></p>

<p><span style="font-size:18px"><strong>Note:</strong> For all the cells containing &#39;N&#39;, &#39;W&#39; and &#39;.&#39; our answer should be 0, and for all the houses where there is no possibility of taking water our answer should be -1.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 3
m = 3
c[][]: H H H
       H W H
&nbsp;      H H H</span>
<span style="font-size:18px"><strong>Output:</strong>
4 2 4 
2 0 2 
4 2 4</span>
<span style="font-size:18px"><strong>Explanation:</strong>
There is only one well hence all the houses present
in the corner of matrix will have to travel a minimum
distance of 4, 2 is for house to well and other two is
for well to house. And rest of the houses have to travel
a minimum distance of 2 (House -&gt; Well -&gt; House).</span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 5
m = 5
c[][]: H N H H H
&nbsp;      N N H H W
&nbsp;      W H H H H
&nbsp;      H H H H H
&nbsp;      H H H H H</span>
<span style="font-size:18px"><strong>Output:</strong>
-1 0 6 4 2 
0 0 4 2 0 
0 2 4 4 2 
2 4 6 6 4 
4 6 8 8 6</span>
<span style="font-size:18px"><strong>Explanation:</strong>
There is no way any person from the house in
cell (0,0) can take the water from any well, and
for rest of the houses there is same type of
strategy we have to follow as followed in example 1. </span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function geekAndWells() which takes n and m, dimensions of the grid, and a 2-D grid of size n*m and returns a 2-D array containing the minimum distance for all the houses as explained above.</span></p>

<p><strong><span style="font-size:18px">Expected Time Complexity: O(n*m)<br />
Expected Space Complexity: O(n*m)</span></strong></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n &lt;= 10^3<br />
1 &lt;= m &lt;= 10^3</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/get-watched-videos-by-your-friends/description" target="_blank" rel="noopener noreferrer">Get Watched Videos by Your Friends</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> people, each person has a unique <em>id</em> between <code>0</code> and <code>n-1</code>. Given the arrays <code>watchedVideos</code> and <code>friends</code>, where <code>watchedVideos[i]</code> and <code>friends[i]</code> contain the list of watched videos and the list of friends respectively for the person with <code>id = i</code>.</p>

<p>Level <strong>1</strong> of videos are all watched videos by your&nbsp;friends, level <strong>2</strong> of videos are all watched videos by the friends of your&nbsp;friends and so on. In general, the level <code>k</code> of videos are all&nbsp;watched videos by people&nbsp;with the shortest path <strong>exactly</strong> equal&nbsp;to&nbsp;<code>k</code> with you. Given your&nbsp;<code>id</code> and the <code>level</code> of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.&nbsp;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_1.png" style="width: 144px; height: 200px;" /></strong></p>

<pre>
<strong>Input:</strong> watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1
<strong>Output:</strong> [&quot;B&quot;,&quot;C&quot;] 
<strong>Explanation:</strong> 
You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):
Person with id = 1 -&gt; watchedVideos = [&quot;C&quot;]&nbsp;
Person with id = 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;]&nbsp;
The frequencies of watchedVideos by your friends are:&nbsp;
B -&gt; 1&nbsp;
C -&gt; 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_2.png" style="width: 144px; height: 200px;" /></strong></p>

<pre>
<strong>Input:</strong> watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2
<strong>Output:</strong> [&quot;D&quot;]
<strong>Explanation:</strong> 
You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == watchedVideos.length ==&nbsp;friends.length</code></li>
	<li><code>2 &lt;= n&nbsp;&lt;= 100</code></li>
	<li><code>1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100</code></li>
	<li><code>1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8</code></li>
	<li><code>0 &lt;= friends[i].length &lt; n</code></li>
	<li><code>0 &lt;= friends[i][j]&nbsp;&lt; n</code></li>
	<li><code>0 &lt;= id &lt; n</code></li>
	<li><code>1 &lt;= level &lt; n</code></li>
	<li>if&nbsp;<code>friends[i]</code> contains <code>j</code>, then <code>friends[j]</code> contains <code>i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/grid-teleportation-traversal/description" target="_blank" rel="noopener noreferrer">Grid Teleportation Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D character grid <code>matrix</code> of size <code>m x n</code>, represented as an array of strings, where <code>matrix[i][j]</code> represents the cell at the intersection of the <code>i<sup>th</sup></code> row and <code>j<sup>th</sup></code> column. Each cell is one of the following:</p>

<ul>
	<li><code>&#39;.&#39;</code> representing an empty cell.</li>
	<li><code>&#39;#&#39;</code> representing an obstacle.</li>
	<li>An uppercase letter (<code>&#39;A&#39;</code>-<code>&#39;Z&#39;</code>) representing a teleportation portal.</li>
</ul>

<p>You start at the top-left cell <code>(0, 0)</code>, and your goal is to reach the bottom-right cell <code>(m - 1, n - 1)</code>. You can move from the current cell to any adjacent cell (up, down, left, right) as long as the destination cell is within the grid bounds and is not an obstacle<strong>.</strong></p>

<p>If you step on a cell containing a portal letter and you haven&#39;t used that portal letter before, you may instantly teleport to any other cell in the grid with the same letter. This teleportation does not count as a move, but each portal letter can be used<strong> at most </strong>once during your journey.</p>

<p>Return the <strong>minimum</strong> number of moves required to reach the bottom-right cell. If it is not possible to reach the destination, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [&quot;A..&quot;,&quot;.A.&quot;,&quot;...&quot;]</span></p>

<p><strong>Output:</strong> 2</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/example04140.png" style="width: 151px; height: 151px;" /></p>

<ul>
	<li>Before the first move, teleport from <code>(0, 0)</code> to <code>(1, 1)</code>.</li>
	<li>In the first move, move from <code>(1, 1)</code> to <code>(1, 2)</code>.</li>
	<li>In the second move, move from <code>(1, 2)</code> to <code>(2, 2)</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [&quot;.#...&quot;,&quot;.#.#.&quot;,&quot;.#.#.&quot;,&quot;...#.&quot;]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/ezgifcom-animated-gif-maker.gif" style="width: 251px; height: 201px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == matrix.length &lt;= 10<sup>3</sup></code></li>
	<li><code>1 &lt;= n == matrix[i].length &lt;= 10<sup>3</sup></code></li>
	<li><code>matrix[i][j]</code> is either <code>&#39;#&#39;</code>, <code>&#39;.&#39;</code>, or an uppercase English letter.</li>
	<li><code>matrix[0][0]</code> is not an obstacle.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/description" target="_blank" rel="noopener noreferrer">Height of Binary Tree After Subtree Removal Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary tree</strong> with <code>n</code> nodes. Each node is assigned a unique value from <code>1</code> to <code>n</code>. You are also given an array <code>queries</code> of size <code>m</code>.</p>

<p>You have to perform <code>m</code> <strong>independent</strong> queries on the tree where in the <code>i<sup>th</sup></code> query you do the following:</p>

<ul>
	<li><strong>Remove</strong> the subtree rooted at the node with the value <code>queries[i]</code> from the tree. It is <strong>guaranteed</strong> that <code>queries[i]</code> will <strong>not</strong> be equal to the value of the root.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>m</code><em> where </em><code>answer[i]</code><em> is the height of the tree after performing the </em><code>i<sup>th</sup></code><em> query</em>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>The queries are independent, so the tree returns to its <strong>initial</strong> state after each query.</li>
	<li>The height of a tree is the <strong>number of edges in the longest simple path</strong> from the root to some node in the tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png" style="width: 495px; height: 281px;" />
<pre>
<strong>Input:</strong> root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The diagram above shows the tree after removing the subtree rooted at node with value 4.
The height of the tree is 2 (The path 1 -&gt; 3 -&gt; 2).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png" style="width: 301px; height: 284px;" />
<pre>
<strong>Input:</strong> root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]
<strong>Output:</strong> [3,2,3,2]
<strong>Explanation:</strong> We have the following queries:
- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 4).
- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -&gt; 8 -&gt; 1).
- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 6).
- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -&gt; 9 -&gt; 3).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= n</code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= m &lt;= min(n, 10<sup>4</sup>)</code></li>
	<li><code>1 &lt;= queries[i] &lt;= n</code></li>
	<li><code>queries[i] != root.val</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The approaches outlined below have similar time and space complexities. Rather than representing significant improvements over one another, they offer different methods and perspectives for solving the problem. You can either review all of them and choose the one that appeals to you, or explore each one in detail to understand the various ways to tackle the problem.</p>
<hr />
<h3 id="approach-1-left-and-right-traversal">Approach 1: Left and Right Traversal</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem asks us to find the height of a tree (the longest path from the root) after removing a subtree rooted at nodes listed in <code>queries</code>.</p>
<p>A brute force solution would process each query separately by removing the specified subtree and recalculating the height of the remaining tree. However, this approach is inefficient due to its high time complexity.</p>
<p>To optimize, we can track the tree's height as we traverse from the root. For any node, the height after removing its subtree is simply the height of the tree before reaching that node. This allows us to avoid recalculating the height repeatedly.</p>
<p>We’ll perform a preorder traversal, tracking the maximum distance from the root. However, if the maximum height is achieved in the right subtree, we may miss it when traversing the left. To address this, we perform a second traversal in reverse preorder (root, right, left).</p>
<p>We maintain an array <code>heights</code> where <code>heights[i]</code> stores the tree height after removing the subtree rooted at node <code>i</code>. During the first traversal, we update <code>heights</code> with the height at each node as we explore its left and right subtrees. In the reverse traversal, we update <code>heights</code> if the current height is greater than the stored value.</p>
<p>Finally, we iterate over <code>queries</code> and return the corresponding heights for each specified node.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a static array <code>maxHeightAfterRemoval</code> to store the maximum height of the tree after removing each node.</li>
<li>a variable <code>currentMaxHeight</code> to 0, which will track the current maximum height during traversals.</li>
</ul>
</li>
</ul>
<p>Main method <code>treeQueries</code>:</p>
<ul>
<li>
<p>Call the <code>traverseLeftToRight</code> method with the root node and initial height 0.</p>
</li>
<li>
<p>Reset <code>currentMaxHeight</code> to 0 for the second traversal.</p>
</li>
<li>
<p>Now call the <code>traverseRightToLeft</code> method with the root node and initial height 0.</p>
</li>
<li>
<p>Initialize an array <code>queryResults</code> to store the results of the queries.</p>
</li>
<li>
<p>Iterate through the queries:</p>
<ul>
<li>For each query, retrieve the corresponding maximum height from <code>maxHeightAfterRemoval</code>.</li>
<li>Store this height in <code>queryResults</code>.</li>
</ul>
</li>
<li>
<p>Return the <code>queryResults</code> array.</p>
</li>
<li>
<p>Define a method <code>traverseLeftToRight</code>:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Store the current <code>currentMaxHeight</code> in <code>maxHeightAfterRemoval</code> for the current node's value.</li>
<li>Update <code>currentMaxHeight</code> to be the maximum of itself and the current height.</li>
<li>Recursively call <code>traverseLeftToRight</code> for the left and right child, incrementing the height.</li>
</ul>
</li>
<li>
<p>Define a method <code>traverseRightToLeft</code>:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Update <code>maxHeightAfterRemoval</code> for the current node's value to be the maximum of its current value and <code>currentMaxHeight</code>.</li>
<li>Update <code>currentMaxHeight</code> to be the maximum of the current height and itself.</li>
<li>Recursively call <code>traverseRightToLeft</code> for the right and left child, incrementing the height.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TynrBwcK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The solution performs two traversals of the binary tree, followed by processing the queries. In both the traversals, each node in the tree is visited exactly once. Thus, the traversals take linear time.</p>
<p>To process the queries, the algorithm iterates through the queries array once, taking <span class="math inline">\(O(q)\)</span> time.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(2 \cdot O(n) + O(q) = O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by mainly 2 factors:</p>
<ol>
<li>The <code>maxHeightAfterRemoval</code> array, which has a fixed size of <span class="math inline">\(100,001\)</span>. This contributes <span class="math inline">\(O(1)\)</span> to the space complexity as it's constant regardless of input size.</li>
<li>The recursion stack used in the tree traversals. In the worst case (a completely unbalanced tree), this could reach a depth of <span class="math inline">\(n\)</span>, resulting in <span class="math inline">\(O(n)\)</span> space.</li>
</ol>
<p>Combining these factors, the overall space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
<blockquote>
<p>Note: The size of the output array is not included in the space complexity calculations since it is a part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-2-single-traversal">Approach 2: Single Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's optimize our solution to use just one traversal. We'll perform a preorder traversal starting from the root, similar to our previous approach. During this traversal, we’ll track a variable <code>maxVal</code> representing the maximum height encountered so far.</p>
<p>For each node, we store its corresponding answer (the <code>maxVal</code> at that point) in a <code>resultMap</code> for quick lookups during queries. We’ll also keep track of the depth as we traverse.</p>
<p>To determine the maximum height if a node is removed, we consider two values:</p>
<ol>
<li>The current <code>maxVal</code> on the path from the root to the node.</li>
<li>The node’s depth plus one (to include itself) and the height of its sibling subtree.</li>
</ol>
<p>To calculate the height of a sibling subtree, we’ll use a memoized helper function that finds the maximum distance from a given node to its leaf nodes.</p>
<p>Starting the DFS from the root, we populate <code>resultMap</code> with heights for each node. Once the traversal completes, we can answer queries using the information stored in <code>resultMap</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a map:</p>
<ul>
<li><code>resultMap</code> to store the maximum height of the tree after removing each node.</li>
<li><code>heightCache</code> to store pre-computed heights of subtrees.</li>
</ul>
</li>
<li>
<p>Call the <code>dfs</code> method with initial parameters: root node, <code>depth</code> 0, <code>maxVal</code> 0, <code>resultMap</code>, and <code>heightCache</code>.</p>
</li>
<li>
<p>Initialize an array <code>result</code> to store the final query results.</p>
</li>
<li>
<p>Iterate through the queries:</p>
<ul>
<li>For each query, retrieve the corresponding maximum height from <code>resultMap</code>.</li>
<li>Store this height in the <code>result</code> array.</li>
</ul>
</li>
<li>
<p>Return the <code>result</code> array.</p>
</li>
<li>
<p>Define the <code>height</code> method to calculate the height of a tree:</p>
<ul>
<li>If the node is <code>null</code>, return -1.</li>
<li>If the height of the node is already in <code>heightCache</code>, return the cached value.</li>
<li>Calculate the height recursively as 1 plus the maximum of left and right subtree heights.</li>
<li>Store the calculated height in <code>heightCache</code>.</li>
<li>Return the calculated height.</li>
</ul>
</li>
<li>
<p>Define the <code>dfs</code> method for the depth-first search:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Store the current <code>maxVal</code> in <code>resultMap</code> for the current node's value.</li>
<li>Recursively call <code>dfs</code> for the left child:
<ul>
<li>Increment the depth.</li>
<li>Update maxVal as the maximum of current maxVal and (depth + 1 + height of right subtree).</li>
</ul>
</li>
<li>Recursively call <code>dfs</code> for the right child:
<ul>
<li>Increment the depth.</li>
<li>Update maxVal as the maximum of current maxVal and (depth + 1 + height of left subtree).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GFsjLbDT/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The main <code>dfs</code> function visits each node in the tree exactly once. For each node, it calls the <code>height</code> function (which uses memoization) to calculate the heights of the subtrees. In the worst case, when we first encounter a node, we might need to calculate its height by traversing its entire subtree. However, subsequent calls for the same node or its ancestors will use the memoized value. Given that each node is visited once by <code>dfs</code>, and each node's height is calculated once and then cached, the overall time complexity for processing the tree is <span class="math inline">\(O(n)\)</span>.</p>
<p>The algorithm also iterates over the <code>queries</code> array to create the result, taking <span class="math inline">\(O(q)\)</span> time.</p>
<p>Thus, the time complexity of the algorithm is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>resultMap</code> and <code>heightCache</code> each take <span class="math inline">\(O(n)\)</span> space. The recursion stack for the DFS can go as deep as the height of the tree, which is <span class="math inline">\(O(n)\)</span> in the worst case.</p>
<p>Thus, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-subtree-size">Approach 3: Subtree Size</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In a preorder traversal of a tree, a subtree starts at its root's index and ends at the index equal to the start index plus the subtree's size. If we know the index and size of the subtree to be removed, we can remove this section from the traversal list. The maximum depth in the remaining traversal then represents the tree’s maximum height after removal.</p>
<p>For example, given the indices and depths of nodes, removing a subtree will leave us with the highest depth among the remaining nodes as our answer. To understand this better, have a look at the visualization below:</p>
<p><img src="../Figures/2458_re/preorderdepth_fix.png" alt="" /></p>
<p>To implement this, we’ll perform a preorder traversal to:</p>
<ol>
<li>Assign an index to each node</li>
<li>Track the depth of each node</li>
</ol>
<p>We then create two arrays, <code>maxDepthsFromLeft</code> and <code>maxDepthsFromRight</code>, to store the maximum depth to the left and right of each index, respectively. These arrays are filled by iterating through the nodes and updating each index with the maximum of the previous result and the current node’s depth.</p>
<p>Finally, to process each query, we compute the result as the maximum of:</p>
<ol>
<li>The maximum depth from the left up to the starting index</li>
<li>The maximum depth from the right beyond the ending index, if available.</li>
</ol>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize a map:</p>
<ul>
<li><code>nodeIndexMap</code> to store the index of each node value.</li>
<li><code>subtreeSize</code> to store the number of nodes in the subtree for each node.</li>
</ul>
</li>
<li>
<p>Initialize lists <code>nodeDepths</code>, <code>maxDepthFromLeft</code>, and <code>maxDepthFromRight</code> to store node depths and maximum depths from left and right.</p>
</li>
<li>
<p>Call the <code>dfs</code> method to populate <code>nodeIndexMap</code> and <code>nodeDepths</code>.</p>
</li>
<li>
<p>Store the total number of nodes in <code>totalNodes</code>.</p>
</li>
<li>
<p>Call <code>calculateSubtreeSize</code> method to populate the <code>subtreeSize</code> map.</p>
</li>
<li>
<p>Initialize <code>maxDepthFromLeft</code> and <code>maxDepthFromRight</code> with the first and last node depths respectively.</p>
</li>
<li>
<p>Iterate through the nodes to calculate <code>maxDepthFromLeft</code> and <code>maxDepthFromRight</code>:</p>
<ul>
<li>Update <code>maxDepthFromLeft</code> with the maximum of the previous max and current depth.</li>
<li>Update <code>maxDepthFromRight</code> with the maximum of the previous max and current depth (in reverse order).</li>
</ul>
</li>
<li>
<p>Reverse the <code>maxDepthFromRight</code> list.</p>
</li>
<li>
<p>Initialize an array <code>results</code> to store the query results.</p>
</li>
<li>
<p>Process each query. For each query node:</p>
<ul>
<li>Calculate the end index as the node's index minus 1.</li>
<li>Calculate the start index as the end index plus the subtree size plus 1.</li>
<li>Initialize <code>maxDepth</code> with the value from <code>maxDepthFromLeft</code> at the end index.</li>
<li>If the start index is within bounds, update <code>maxDepth</code> with the maximum of current <code>maxDepth</code> and the value from <code>maxDepthFromRight</code> at the start index.</li>
<li>Store the <code>maxDepth</code> in the <code>results</code> array.</li>
</ul>
</li>
<li>
<p>Return the <code>results</code> array.</p>
</li>
<li>
<p>Define a method <code>dfs</code> for the depth-first search:</p>
<ul>
<li>If the current node is null, return.</li>
<li>Add the current node's value and index to <code>nodeIndexMap</code>.</li>
<li>Add the current depth to <code>nodeDepths</code>.</li>
<li>Recursively call <code>dfs</code> for left and right children, incrementing the depth.</li>
</ul>
</li>
<li>
<p>Define a method <code>calculateSubtreeSize</code> :</p>
<ul>
<li>If the current node is <code>null</code>, return 0.</li>
<li>Recursively calculate the size of left and right subtrees.</li>
<li>Calculate the total size as left size plus right size plus 1.</li>
<li>Store the total size in <code>subtreeSize</code> for the current node.</li>
<li>Return the total size.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/X7rHFYHY/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>This solution employs a four-step approach to solve the problem:</p>
<ol>
<li>The initial depth-first search traverses each node once, populating <code>nodeIndexMap</code> and <code>nodeDepths</code>. This takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>The calculation of subtree sizes (<code>calculateSubtreeSize</code> method) also visits each node once, taking <span class="math inline">\(O(n)\)</span> time.</li>
<li>Computing <code>maxDepthFromLeft</code> and <code>maxDepthFromRight</code> involves iterating through the <code>nodeDepths</code> list once, which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Processing the queries and populating the result array takes <span class="math inline">\(O(q)\)</span> time.</li>
</ol>
<p>Summing up the parts, the algorithm has a time complexity of <span class="math inline">\(3 \cdot O(n) + O(q) = O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>nodeIndexMap</code> and <code>subtreeSize</code> maps each store information for every node, taking <span class="math inline">\(O(n)\)</span> space each. The <code>nodeDepths</code>, <code>maxDepthFromLeft</code>, and <code>maxDepthFromRight</code> lists each contain an entry for every node, also taking <span class="math inline">\(O(n)\)</span> space each.</p>
<p>Similar to the previous approach, the recursion stack has a <span class="math inline">\(O(n)\)</span> complexity.</p>
<p>Thus, the space complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-eulerian-tour">Approach 4: Eulerian Tour</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The previous approach can be generalized using an Eulerian tour. An Eulerian tour traverses the tree such that each node is visited twice, once when first encountered, and again when leaving after exploring all its subtrees.</p>
<p><img src="../Figures/2458_re/eulertour_fix.png" alt="" /></p>
<p>In this tour, a subtree is bounded by the first and last occurrences of its root node. To find the maximum height of the tree after removing a subtree, we can simply look at the maximum depth before the first occurrence and after the last occurrence of the subtree's root node.</p>
<p>To create the Eulerian tour, we perform a DFS over the tree, recording the first and last occurrences of each node in the <code>firstOccurrence</code> and <code>lastOccurrence</code> maps, respectively, while tracking each node's depth.</p>
<p>Like the previous approach, we calculate <code>maxDepthLeft</code> and <code>maxDepthRight</code> for each node for quick access. For each query, we can then retrieve the maximum depths at the first and last occurrences of the queried node and return the greater of the two as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize a list <code>eulerTour</code> to store the Euler tour of the tree.</p>
</li>
<li>
<p>Initialize maps <code>nodeHeights</code>, <code>firstOccurrence</code>, and <code>lastOccurrence</code> to store information about each node.</p>
</li>
<li>
<p>Call the <code>dfs</code> function to build the Euler tour and populate the maps.</p>
</li>
<li>
<p>Set <code>tourSize</code> to the size of <code>eulerTour</code>.</p>
</li>
<li>
<p>Initialize arrays <code>maxDepthLeft</code> and <code>maxDepthRight</code> of size <code>tourSize</code>.</p>
</li>
<li>
<p>Set the first element of <code>maxDepthLeft</code> and last element of <code>maxDepthRight</code> to the height of the root node.</p>
</li>
<li>
<p>Iterate from 1 to <code>tourSize - 1</code>:</p>
<ul>
<li>Set <code>maxDepthLeft[i]</code> to the maximum of the previous max height and the current node's height.</li>
</ul>
</li>
<li>
<p>Iterate backward from <code>tourSize - 2</code> to 0:</p>
<ul>
<li>Set <code>maxDepthRight[i]</code> to the maximum of the next max height and the current node's height.</li>
</ul>
</li>
<li>
<p>Initialize an array <code>results</code> with the same length as <code>queries</code>.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
<ul>
<li>Set <code>queryNode</code> to the current query value.</li>
<li>Calculate <code>leftMax</code> and <code>rightMax</code> as the max height to the left and right of the node's first occurrence, respectively.</li>
<li>Store the maximum of <code>leftMax</code> and <code>rightMax</code> in <code>results</code>.</li>
</ul>
</li>
<li>
<p>Return the <code>results</code> array.</p>
</li>
<li>
<p>Define the <code>dfs</code> function:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Add the current node's height to <code>nodeHeights</code>.</li>
<li>Set the first occurrence of the current node in <code>firstOccurrence</code>.</li>
<li>Add the current node's value to <code>eulerTour</code>.</li>
<li>Recursively call <code>dfs</code> for left and right children, incrementing the height.</li>
<li>Set the last occurrence of the current node in <code>lastOccurrence</code>.</li>
<li>Add the current node's value to <code>eulerTour</code> again.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/hxAu4KY5/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The <code>dfs</code> method traverses each node twice (down and up) to construct the Euler tour, which takes <span class="math inline">\(O(n)\)</span> time. The <code>maxDepthLeft</code> and <code>maxDepthRight</code> arrays are then built by iterating over the Euler tour in both directions and since the tour has a length of <span class="math inline">\(2n\)</span>, this step also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Processing the queries takes <span class="math inline">\(O(q)\)</span> time, making the total time complexity <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The Euler tour, stored in a list, contains <span class="math inline">\(2 \cdot n\)</span> elements and occupies <span class="math inline">\(O(n)\)</span> space. Three maps - <code>nodeHeights</code>, <code>firstOccurrence</code>, and <code>lastOccurrence</code> - each store information for every node, also taking <span class="math inline">\(O(n)\)</span> space. Two arrays, <code>maxDepthLeft</code> and <code>maxDepthRight</code>, mirror the Euler tour's length and consume <span class="math inline">\(O(n)\)</span> space each. Additionally, the recursion stack, as is typical, requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-two-largest-cousins">Approach 5: Two Largest Cousins</h3>
<h4 id="intuition-4">Intuition</h4>
<p>At any node, the longest path through it is the sum of its depth and the height of its subtree. For each depth, the maximum tree height at that level will be the depth plus the maximum height of any node at that depth.</p>
<p><img src="../Figures/2458_re/cousinheights_fix.png" alt="" /></p>
<p>To optimize this, we organize nodes by their depths and precalculate their heights. If a query removes a node, we find the maximum height at that depth, excluding the removed node.</p>
<p>To streamline further, the maximum height from a given depth can be found using two precomputed values:</p>
<ol>
<li>The maximum height at that depth, excluding the current node.</li>
<li>The second-highest height at that depth, if the maximum height subtree is removed.</li>
</ol>
<p>Thus, we only need the two largest heights at each depth. We maintain two lists, <code>firstLargestHeight</code> and <code>secondLargestHeight</code>, where each index stores the two largest heights for each depth. We then use DFS to populate these lists, along with each node's depth and height. For each query, if a node’s height matches the largest height at its depth, we return the second-largest height at that level; otherwise, we return the largest height.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>
<p>Initialize a map:</p>
<ul>
<li><code>nodeDepths</code> to store the depth of each node.</li>
<li><code>subtreeHeights</code> to store the height of the subtree rooted at each node.</li>
</ul>
</li>
<li>
<p>Initialize maps <code>firstLargestHeight</code> and <code>secondLargestHeight</code> to store the first and second largest heights at each level.</p>
</li>
<li>
<p>Call the <code>dfs</code> function to populate these maps.</p>
</li>
<li>
<p>Initialize an array <code>results</code> with the same length as <code>queries</code>.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
<ul>
<li>Set <code>queryNode</code> to the current query value.</li>
<li>Set <code>nodeLevel</code> to the depth of the query node.</li>
<li>If the height of the query node's subtree equals the first largest height at its level:
<ul>
<li>Set the result to the sum of node level and second largest height at that level, minus 1.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Otherwise:</p>
<ul>
<li>Set the result to the sum of node level and first largest height at that level, minus 1.</li>
</ul>
</li>
<li>
<p>Return the <code>results</code> array.</p>
</li>
<li>
<p>Define the <code>dfs</code> function:</p>
<ul>
<li>If the current node is <code>null</code>, return 0.</li>
<li>Add the current node's depth to <code>nodeDepths</code>.</li>
<li>Recursively call <code>dfs</code> for left and right children, incrementing the level.</li>
<li>Calculate <code>currentHeight</code> as 1 plus the maximum of left and right subtree heights.</li>
<li>Add the current node's subtree height to <code>subtreeHeights</code>.</li>
<li>Set <code>currentFirstLargest</code> to the first largest height at the current level.</li>
<li>If <code>currentHeight</code> is greater than <code>currentFirstLargest</code>:
<ul>
<li>Update <code>secondLargestHeight</code> at the current level with <code>currentFirstLargest</code>.</li>
<li>Update <code>firstLargestHeight</code> at the current level with <code>currentHeight</code>.</li>
</ul>
</li>
<li>Else if <code>currentHeight</code> is greater than the second largest height at the current level:
<ul>
<li>Update <code>secondLargestHeight</code> at the current level with <code>currentHeight</code>.</li>
</ul>
</li>
<li>Return <code>currentHeight</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: The C++ implementation opts for vectors instead of unordered_maps. This choice stems from unordered_maps' reputation for slower performance in certain scenarios.</p>
</blockquote>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/5NYL6aFg/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The <code>dfs</code> method traverses each node in the tree exactly once. For each node, it performs several comparison and update operations, all of which take constant time. So, this step takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>To process each query, the algorithm does some map lookups and a comparison, both taking constant time. Thus, processing all the queries requires <span class="math inline">\(O(q)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>nodeDepths</code> and <code>subtreeHeights</code> maps store information for every node, taking <span class="math inline">\(O(n)\)</span> space each.</p>
<p>The <code>firstLargestHeight</code> and <code>secondLargestHeight</code> maps typically store <span class="math inline">\(log n\)</span> (balanced trees) elements, but in the worst case (skewed trees), could store information for all <span class="math inline">\(n\)</span> levels. Thus, these take a further <span class="math inline">\(O(n)\)</span> space.</p>
<p>The recursion stack goes as deep as the height of the tree, which can be <span class="math inline">\(n\)</span> in the worst case.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/invert-binary-tree/description" target="_blank" rel="noopener noreferrer">Invert Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" style="width: 500px; height: 165px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3,6,9]
<strong>Output:</strong> [4,7,2,9,6,3,1]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" style="width: 500px; height: 120px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,3,1]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/is-graph-bipartite/description" target="_blank" rel="noopener noreferrer">Is Graph Bipartite?</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p>

<ul>
	<li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li>
	<li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li>
	<li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li>
	<li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li>
</ul>

<p>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p>

<p>Return <code>true</code><em> if and only if it is <strong>bipartite</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>graph.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= graph[u].length &lt; n</code></li>
	<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>
	<li><code>graph[u]</code>&nbsp;does not contain&nbsp;<code>u</code>.</li>
	<li>All the values of <code>graph[u]</code> are <strong>unique</strong>.</li>
	<li>If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/island-perimeter/description" target="_blank" rel="noopener noreferrer">Island Perimeter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>row x col</code> <code>grid</code> representing a map where <code>grid[i][j] = 1</code> represents&nbsp;land and <code>grid[i][j] = 0</code> represents water.</p>

<p>Grid cells are connected <strong>horizontally/vertically</strong> (not diagonally). The <code>grid</code> is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>

<p>The island doesn&#39;t have &quot;lakes&quot;, meaning the water inside isn&#39;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2018/10/12/island.png" style="width: 221px; height: 213px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
<strong>Output:</strong> 16
<strong>Explanation:</strong> The perimeter is the 16 yellow stripes in the image above.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1]]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0]]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>row == grid.length</code></li>
	<li><code>col == grid[i].length</code></li>
	<li><code>1 &lt;= row, col &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li>There is exactly one island in <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/jump-game-iii/description" target="_blank" rel="noopener noreferrer">Jump Game III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of non-negative integers <code>arr</code>, you are initially positioned at <code>start</code>&nbsp;index of the array. When you are at index <code>i</code>, you can jump&nbsp;to <code>i + arr[i]</code> or <code>i - arr[i]</code>, check if you can reach&nbsp;<strong>any</strong> index with value 0.</p>

<p>Notice that you can not jump outside of the array at any time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,2,3,0,3,1,2], start = 5
<strong>Output:</strong> true
<strong>Explanation:</strong> 
All possible ways to reach at index 3 with value 0 are: 
index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 
index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,2,3,0,3,1,2], start = 0
<strong>Output:</strong> true 
<strong>Explanation: 
</strong>One possible way to reach at index 3 with value 0 is: 
index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,0,2,1,2], start = 2
<strong>Output:</strong> false
<strong>Explanation: </strong>There is no way to reach at index 1 with value 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;&nbsp;arr.length</code></li>
	<li><code>0 &lt;= start &lt; arr.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/jump-game-iv/description" target="_blank" rel="noopener noreferrer">Jump Game IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of&nbsp;integers <code>arr</code>, you are initially positioned at the first index of the array.</p>

<p>In one step you can jump from index <code>i</code> to index:</p>

<ul>
	<li><code>i + 1</code> where:&nbsp;<code>i + 1 &lt; arr.length</code>.</li>
	<li><code>i - 1</code> where:&nbsp;<code>i - 1 &gt;= 0</code>.</li>
	<li><code>j</code> where: <code>arr[i] == arr[j]</code> and <code>i != j</code>.</li>
</ul>

<p>Return <em>the minimum number of steps</em> to reach the <strong>last index</strong> of the array.</p>

<p>Notice that you can not jump outside of the array at any time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [100,-23,-23,404,100,23,23,23,3,404]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [7]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Start index is the last index. You do not need to jump.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [7,6,9,6,9,6,9,7]
<strong>Output:</strong> 1
<strong>Explanation:</strong> You can jump directly from index 0 to index 7 which is last index of the array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>8</sup> &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>You probably can guess from the problem title, this is the fourth problem in the series of <a href="https://leetcode.com/problems/jump-game/">Jump Game</a> problems. Those problems are similar, but have considerable differences, making their solutions quite different.</p>
<p>Here, two approaches are introduced: <em>Breadth-First Search</em> approach and <em>Bidirectional BFS</em> approach.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth-First Search</h3>
<p>Most solutions start from a brute force approach and are optimized by removing unnecessary calculations. Same as this one.</p>
<p>A naive brute force approach is to iterate all the possible routes and check if there is one reaches the last index. However, if we already checked one index, we do not need to check it again. We can mark the index as visited by storing them in a <code>visited</code> set.</p>
<p>From convenience, we can store nodes with the same value together in a <code>graph</code> dictionary. With this method, when searching, we do not need to iterate the whole list to find the nodes with the same value as the next steps, but only need to ask the precomputed dictionary. However, to prevent stepping back, we need to clear the dictionary after we get to that value.</p>
<p><a href="https://leetcode.com/playground/Fe28Khke/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Assume <span class="math inline">\(N\)</span> is the length of <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since we will visit every node at most once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since it needs <code>curs</code> and <code>nex</code> to store nodes.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bidirectional-bfs">Approach 2: Bidirectional BFS</h3>
<p>In the later part of our original BFS method, the layer may be long and takes a long time to compute the next layer. In this situation, we can compute the layer from the end, which may be short and takes less time.</p>
<p><a href="https://leetcode.com/playground/NGZeg5uX/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Assume <span class="math inline">\(N\)</span> is the length of <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since we will visit every node at most once, but usually faster than approach 1.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since it needs <code>curs</code>, <code>other</code> and <code>nex</code> to store nodes.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/keys-and-rooms/description" target="_blank" rel="noopener noreferrer">Keys and Rooms</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code>&nbsp;and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>

<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>

<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> rooms = [[1],[2],[3],[]]
<strong>Output:</strong> true
<strong>Explanation:</strong> 
We visit room 0 and pick up key 1.
We then visit room 1 and pick up key 2.
We then visit room 2 and pick up key 3.
We then visit room 3.
Since we were able to visit every room, we return true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]
<strong>Output:</strong> false
<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == rooms.length</code></li>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
	<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>
	<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>
	<li>All the values of <code>rooms[i]</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>When visiting a room for the first time, look at all the keys in that room.  For any key that hasn't been used yet, add it to the todo list (<code>stack</code>) for it to be used.</p>
<p>See the comments of the code for more details.</p>
<p><a href="https://leetcode.com/playground/dRqvjiWp/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N + E)\)</span>, where <span class="math inline">\(N\)</span> is the number of rooms, and <span class="math inline">\(E\)</span> is the total number of keys.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span> in additional space complexity, to store <code>stack</code> and <code>seen</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-highest-ranked-items-within-a-price-range/description" target="_blank" rel="noopener noreferrer">K Highest Ranked Items Within a Price Range</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code> that represents a map of the items in a shop. The integers in the grid represent the following:</p>

<ul>
	<li><code>0</code> represents a wall that you cannot pass through.</li>
	<li><code>1</code> represents an empty cell that you can freely move to and from.</li>
	<li>All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.</li>
</ul>

<p>It takes <code>1</code> step to travel between adjacent grid cells.</p>

<p>You are also given integer arrays <code>pricing</code> and <code>start</code> where <code>pricing = [low, high]</code> and <code>start = [row, col]</code> indicates that you start at the position <code>(row, col)</code> and are interested only in items with a price in the range of <code>[low, high]</code> (<strong>inclusive</strong>). You are further given an integer <code>k</code>.</p>

<p>You are interested in the <strong>positions</strong> of the <code>k</code> <strong>highest-ranked</strong> items whose prices are <strong>within</strong> the given price range. The rank is determined by the <strong>first</strong> of these criteria that is different:</p>

<ol>
	<li>Distance, defined as the length of the shortest path from the <code>start</code> (<strong>shorter</strong> distance has a higher rank).</li>
	<li>Price (<strong>lower</strong> price has a higher rank, but it must be <strong>in the price range</strong>).</li>
	<li>The row number (<strong>smaller</strong> row number has a higher rank).</li>
	<li>The column number (<strong>smaller</strong> column number has a higher rank).</li>
</ol>

<p>Return <em>the </em><code>k</code><em> highest-ranked items within the price range <strong>sorted</strong> by their rank (highest to lowest)</em>. If there are fewer than <code>k</code> reachable items within the price range, return <em><strong>all</strong> of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png" style="width: 200px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
<strong>Output:</strong> [[0,1],[1,1],[2,1]]
<strong>Explanation:</strong> You start at (0,0).
With a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).
The ranks of these items are:
- (0,1) with distance 1
- (1,1) with distance 2
- (2,1) with distance 3
- (2,2) with distance 4
Thus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png" style="width: 200px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
<strong>Output:</strong> [[2,1],[1,2]]
<strong>Explanation:</strong> You start at (2,3).
With a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).
The ranks of these items are:
- (2,1) with distance 2, price 2
- (1,2) with distance 2, price 3
- (1,1) with distance 3
- (0,1) with distance 4
Thus, the 2 highest ranked items in the price range are (2,1) and (1,2).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/30/example3.png" style="width: 149px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
<strong>Output:</strong> [[2,1],[2,0]]
<strong>Explanation:</strong> You start at (0,0).
With a price range of [2,3], we can take items from (2,0) and (2,1). 
The ranks of these items are: 
- (2,1) with distance 5
- (2,0) with distance 6
Thus, the 2 highest ranked items in the price range are (2,1) and (2,0). 
Note that k = 3 but there are only 2 reachable items within the price range.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>pricing.length == 2</code></li>
	<li><code>2 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>
	<li><code>start.length == 2</code></li>
	<li><code>0 &lt;= row &lt;= m - 1</code></li>
	<li><code>0 &lt;= col &lt;= n - 1</code></li>
	<li><code>grid[row][col] &gt; 0</code></li>
	<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/kill-captain-america0228/1" target="_blank" rel="noopener noreferrer">Kill Captain America</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Captain America is hiding from Thanos in a maze full of <strong>n</strong> rooms connected by <strong>m</strong> gates. The maze is designed in such a way that each room leads to another room via gates. All connecting gates are unidirectional. Captain America is hiding only in those rooms which are accessible directly/indirectly through every other room in the maze.<br />Help Thanos find the number of rooms in which Captain America can hide.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: n = 5, gates[][] = [[1, 2], [2, 3], [3, 4], [4, 3], [5, 4]]
<strong>Output:</strong>&nbsp;2
<strong>Explanation</strong>:
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/704857/Web/Other/blobid0_1745301369.jpg" width="420" height="186" /> <br />We can look closesly after forming graph than captain america only can hide in a room 3 and 4 because they are the only room which have gates through them. So, answer is 2.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, gates[][] = [[1, 2]]
</span><span style="font-size: 18px;"><strong>Output: </strong>1<br /></span><strong style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">:  <span style="font-size: 14pt;">Room 2 is the only room that can be visited from other rooms</span></span><span style="font-size: 14pt;">.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 30000<br />1 &le; m &le; 200000<br />1 &le; gates[i][0], gates[i][1] &le; n</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/knight-in-geekland--170647/1" target="_blank" rel="noopener noreferrer">Knight in Geekland</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Knight is at <strong>(start_x,start_y)</strong> in Geekland which is represented by an <strong>NxM</strong> 2D matrix.<br />Each cell in the matrix contains some points. In the ith step, the knight can collect all the points from all the cells that can be visited in exactly i steps without revisiting any cell.<br />Also, the knight has some magical powers that enable him to fetch coins from the future i.e. If the knight can collect y coins in the xth step he can fetch all the coins that he will collect in the (x + y)th step and if the knight can collect z coins in the (x + y)th step he can fetch all the coins that he will collect in the (x + y + z)th step and so on without increasing the step count i.e. knight will stay on xth step and will get all the coins of the future steps mentioned above((x + y)th step coins + (x + y+z)th steps + ...).</span></p>
<p><span style="font-size: 18px;"><strong>For example</strong>, If in 1st step knight can collect 1 point, then knight will also collect all the points which are at (1+1)th step i.e. 2 steps, and if knight can collect 3 points in (1+1)th step then knight will also collect all the points at (1+1+3)th step and so on. Hence being only at the first step knight can collect overall 1+3 = 4 points if there are no points available at (1+1+3)th step.</span></p>
<p><span style="font-size: 18px;">Find the minimum number of steps required to collect the maximum points.<br /><strong>Note:</strong> The <a href="https://en.wikipedia.org/wiki/Knight_(chess)#:~:text=Compared%20to%20other%20chess%20pieces,pieces%20to%20reach%20its%20destination.">knight moves</a> exactly the same as the knight on a chess board. Please follow 0 indexing.</span></p>
<p><span style="font-size: 18px;">Example 1:</span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
n = 9
m = 10
start_x = 4, start_y = 5
arr =
0 0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0
0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0
0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0 <span style="color: #ff0000;"><strong>1</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> 0 0 <span style="color: #00ff00;"><strong>2</strong></span>
0 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0
0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #000000;"><strong><span style="background-color: #ffff00;">0</span></strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span>
0 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0
0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0 <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> 0 0 <span style="color: #00ff00;"><strong>2</strong></span>
0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0
0 0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0
<strong>Output:</strong> 1
<strong>Explanation:</strong> minimum knight have to take 1 steps to gain maximum points.
Initially, the knight has 0 coins, he will take 1 step to collect 1 point (sum of cells denoted in red color).
Now in the second step, he can collect points from all the cells colored green i.e. 64 points.
But with his magical power, at the 1st step, he can fetch points from the (1 + 1)th step. Therefore he can collect 1 + 64 coins at step 1 only. Hence answer is 1.</span>
</pre>
<p><span style="font-size: 18px;">Example 2:</span></p>
<pre><span style="font-size: 18px;">Input:
n = 3 
m = 3
start_x = 2, start_y = 1
arr =
7 6 8
9 1 4
6 2 8
Output:0
Explanation:
Initially, the knight has 2 points, or more formally we can say that at the 0th step knight has 2 points.
In the first step, he can collect points from cells (0, 0) and (0, 2) i.e. 15 points.
In the second step, he can collect points from cells (1, 0) and (1, 2) i.e. 13 coins.
In the third step, he can collect points from cells (2, 0) and (2, 2) i.e. 14 points.
In the fourth step, he can collect points from the cell (0, 1) i.e. 6 points.
So in each step, he can collect coins like -You can see in the below image  Knight can collect 15 coins in the 0th step only
<img style="height: 430px; width: 500px;" src="https://media.geeksforgeeks.org/img-practice/rect46213-1668840290.png" alt="" /></span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function knightInGeekland() which takes 2-d array <strong>arr[][],</strong>&nbsp;starting coordinates of knight <strong>start_x, and start_y&nbsp;</strong>as input, and return an integer value as min steps to gain max points.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N*M)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N*M)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />&nbsp;&nbsp;&nbsp;1 &lt;= len(arr), len(arr[0])&nbsp;&lt;&nbsp;10<sup>3</sup><br />&nbsp; &nbsp;0&nbsp;&lt;= values in arr &lt;=100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/knight-walk4521/1" target="_blank" rel="noopener noreferrer">Knight Walk</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square chessboard, the initial position of Knight and position of a target. Find out the minimum steps a Knight will take to reach the target position.If it cannot reach the target position return -1.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong><br />The initial and the target position co-ordinates of&nbsp;Knight have been given accoring to 1-base indexing.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N=6
knightPos[ ] = {4, 5}
targetPos[ ] = {1, 1}
<strong>Output:</strong>
3
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/KnightChess.jpg" />
Knight takes 3 step to reach from
(4, 5) to (1, 1):
(4, 5) -&gt; (5, 3) -&gt; (3, 2) -&gt; (1, 1). </span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N=8
knightPos[ ] = {7, 7}
targetPos[ ] = {1, 5}
<strong>Output:</strong>
4
<strong>Explanation:</strong></span>
<span style="font-size: 18px;">Knight takes 4 steps to reach from
(7, 7) to (1, 5):
(4, 5) -&gt; (6, 5) -&gt; (5, 3) -&gt; (7, 2) -&gt; (1, 5).</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>minStepToReachTarget()</strong>&nbsp;which takes the inital position of Knight (KnightPos), the target position of Knight (TargetPos) and the size of the chess board (N) as an input parameters&nbsp;and returns the minimum number of steps required by the knight to reach from its current position to the given target position.If it cannot reach the target position return -1.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N<sup>2</sup>).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N<sup>2</sup>).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 1000<br />1 &lt;= Knight_pos(X, Y), Targer_pos(X, Y)&nbsp;&lt;= N</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-similar-strings/description" target="_blank" rel="noopener noreferrer">K-Similar Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Strings <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong> (for some non-negative integer <code>k</code>) if we can swap the positions of two letters in <code>s1</code> exactly <code>k</code> times so that the resulting string equals <code>s2</code>.</p>

<p>Given two anagrams <code>s1</code> and <code>s2</code>, return the smallest <code>k</code> for which <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;ab&quot;, s2 = &quot;ba&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The two string are 1-similar because we can use one swap to change s1 to s2: &quot;ab&quot; --&gt; &quot;ba&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;abc&quot;, s2 = &quot;bca&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The two strings are 2-similar because we can use two swaps to change s1 to s2: &quot;abc&quot; --&gt; &quot;bac&quot; --&gt; &quot;bca&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s1.length &lt;= 20</code></li>
	<li><code>s2.length == s1.length</code></li>
	<li><code>s1</code> and <code>s2</code> contain only lowercase letters from the set <code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code>.</li>
	<li><code>s2</code> is an anagram of <code>s1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-ancestor-of-a-tree-node/description" target="_blank" rel="noopener noreferrer">Kth Ancestor of a Tree Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a tree with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> in the form of a parent array <code>parent</code> where <code>parent[i]</code> is the parent of <code>i<sup>th</sup></code> node. The root of the tree is node <code>0</code>. Find the <code>k<sup>th</sup></code> ancestor of a given node.</p>

<p>The <code>k<sup>th</sup></code> ancestor of a tree node is the <code>k<sup>th</sup></code> node in the path from that node to the root node.</p>

<p>Implement the <code>TreeAncestor</code> class:</p>

<ul>
	<li><code>TreeAncestor(int n, int[] parent)</code> Initializes the object with the number of nodes in the tree and the parent array.</li>
	<li><code>int getKthAncestor(int node, int k)</code> return the <code>k<sup>th</sup></code> ancestor of the given node <code>node</code>. If there is no such ancestor, return <code>-1</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/28/1528_ex1.png" style="width: 396px; height: 262px;" />
<pre>
<strong>Input</strong>
[&quot;TreeAncestor&quot;, &quot;getKthAncestor&quot;, &quot;getKthAncestor&quot;, &quot;getKthAncestor&quot;]
[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]
<strong>Output</strong>
[null, 1, 0, -1]

<strong>Explanation</strong>
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);
treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3
treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5
treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>parent.length == n</code></li>
	<li><code>parent[0] == -1</code></li>
	<li><code>0 &lt;= parent[i] &lt; n</code> for all <code>0 &lt; i &lt; n</code></li>
	<li><code>0 &lt;= node &lt; n</code></li>
	<li>There will be at most <code>5 * 10<sup>4</sup></code> queries.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-largest-sum-in-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Kth Largest Sum in a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree and a positive integer <code>k</code>.</p>

<p>The <strong>level sum</strong> in the tree is the sum of the values of the nodes that are on the <strong>same</strong> level.</p>

<p>Return<em> the </em><code>k<sup>th</sup></code><em> <strong>largest</strong> level sum in the tree (not necessarily distinct)</em>. If there are fewer than <code>k</code> levels in the tree, return <code>-1</code>.</p>

<p><strong>Note</strong> that two nodes are on the same level if they have the same distance from the root.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png" style="width: 301px; height: 284px;" />
<pre>
<strong>Input:</strong> root = [5,8,9,2,1,3,7,4,6], k = 2
<strong>Output:</strong> 13
<strong>Explanation:</strong> The level sums are the following:
- Level 1: 5.
- Level 2: 8 + 9 = 17.
- Level 3: 2 + 1 + 3 + 7 = 13.
- Level 4: 4 + 6 = 10.
The 2<sup>nd</sup> largest level sum is 13.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png" style="width: 181px; height: 181px;" />
<pre>
<strong>Input:</strong> root = [1,2,null,3], k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> The largest level sum is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the <code>root</code> of a binary tree and an integer <code>k</code>, where we want to find the <code>k-th</code> largest level sum of the tree. A level sum of a tree for a given level can be defined as the sum of the values of all nodes that all have equal distance from the <code>root</code>.</p>
<h3 id="approach-1-level-order-traversal--max-heap">Approach 1: Level Order Traversal + Max Heap</h3>
<h3 id="intuition">Intuition</h3>
<p>To calculate the sum of each level in a tree, we can use level order traversal, which processes nodes level by level. This is similar to breadth-first search (BFS), where we visit all neighbors of a node before moving on. However, unlike traditional BFS, all nodes at a given level are processed together in level-order traversal. So, for each level <code>i</code>, we visit all nodes and maintain a <code>sum</code> variable to track the sum of nodes for that level.</p>
<p>Since we need to find the <code>k-th</code> largest sum, we can store each level's sum in a max heap. By removing the first <code>k-1</code> elements from the heap, the <code>k-th</code> largest element remains at the top and can be accessed directly.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>Initialize a max heap/priority queue <code>pq</code></li>
<li>Initialize a queue <code>bfsQueue</code> to maintain the ordering of which nodes to visit for our level order traversal</li>
<li>Start by adding <code>root</code> to <code>bfsQueue</code></li>
<li>Perform level order traversal. While <code>bfsQueue</code> is not empty:
<ul>
<li>Initialize <code>size</code> to be the current number of nodes of <code>bfsQueue</code>, which are all the nodes for the current level that we want to visit</li>
<li>For <code>size</code> iterations:
<ul>
<li>Initialize <code>sum</code> to <code>0</code></li>
<li>Visit the next node by removing the next node in <code>bfsQueue</code>. Store it in <code>poppedNode</code></li>
<li>Update <code>sum</code>: <code>sum += poppedNode.val</code></li>
<li>Add the left and right children of <code>poppedNode</code> to the queue, if they exist. These children will be a part of the next level of the tree that will be visited in the next iteration.</li>
</ul>
</li>
<li><code>sum</code> now contains a level order sum. Add it to <code>pq</code></li>
</ul>
</li>
<li>If <code>pq</code> has less than <code>k</code> sums, then return -1 because we have less than <code>k</code> levels in our tree</li>
<li>Otherwise, remove the first <code>k-1</code> elements from <code>pq</code>, and then return the top element: <code>pq.peek()</code></li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/iupTHRrb/shared">code</a></p>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the total number of nodes in our tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((N + K) \cdot \log N)\)</span></p>
<p>The level order traversal takes <span class="math inline">\(O(N)\)</span> time. Since our heap can have a maximum of <span class="math inline">\(O(N)\)</span> elements, adding a sum to the heap takes <span class="math inline">\(O(\log N)\)</span> time, resulting in a total heap build time of <span class="math inline">\(O(N \cdot \log N)\)</span>. Popping <span class="math inline">\(k-1\)</span> elements from the heap takes <span class="math inline">\(O(k \cdot \log N)\)</span> time. Therefore, the overall time complexity is <span class="math inline">\(O((N + K) \cdot \log N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space usage is determined by both the level-order traversal queue and the heap. The queue, which reaches its maximum size when storing all nodes at the last level, requires <span class="math inline">\(O(N)\)</span> space. The heap, in the worst case (such as when the tree is a single path of <span class="math inline">\(N\)</span> nodes), can also take up to <span class="math inline">\(O(N)\)</span> space. Therefore, the overall space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-level-order-traversal--min-heap">Approach 2: Level Order Traversal + Min Heap</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In Approach 1, our max heap stored sums for all levels of the tree, making heap operations costly. In Approach 2, we use a min heap instead, where the smallest level sum is at the top. As we add new level sums, if the heap size exceeds <code>k</code>, we remove the top element. This ensures that, after processing all level sums, our heap contains the <code>k</code> largest sums, with the <code>k-th</code> largest at the top, which we can return. All smaller sums would have been evicted earlier whenever the heap size exceeded <code>k</code>. By limiting the heap size to <code>k</code>, where <span class="math inline">\(k \leq \log N\)</span>, we reduce the overall time complexity.</p>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>Initialize a min heap/priority queue <code>pq</code></li>
<li>Initialize a queue <code>bfsQueue</code> to maintain the ordering of which nodes to visit for our level order traversal</li>
<li>Start by adding <code>root</code> to <code>bfsQueue</code></li>
<li>Perform level order traversal. While <code>bfsQueue</code> is not empty:
<ul>
<li>Initialize <code>size</code> to be the current number of nodes of <code>bfsQueue</code>, which are all the nodes for the current level that we want to visit</li>
<li>For <code>size</code> iterations:
<ul>
<li>Initialize <code>sum</code> to <code>0</code></li>
<li>Visit the next node by removing the next node in <code>bfsQueue</code>. Store it in <code>poppedNode</code></li>
<li>Update <code>sum</code>: <code>sum += poppedNode.val</code></li>
<li>Add the left and right children of <code>poppedNode</code> to the queue, if they exist. These children will be a part of the next level of the tree that will be visited in the next iteration.</li>
</ul>
</li>
<li><code>sum</code> now contains a level order sum. Add it to <code>pq</code></li>
<li>If size of <code>pq</code> now exceeds <code>k</code> elements, remove the top element.</li>
</ul>
</li>
<li>If <code>pq</code> has less than <code>k</code> sums, then return -1 because we have less than <code>k</code> levels in our tree</li>
<li>Top element is the <code>k-th</code> largest sum so return it: <code>pq.peek()</code></li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/AHjgz2oC/shared">code</a></p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the total number of nodes in our tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot \log k)\)</span></p>
<p>The level order traversal requires <span class="math inline">\(O(N)\)</span> time. We add to the heap a maximum of <span class="math inline">\(O(N)\)</span> times, with a maximum heap size of <span class="math inline">\(k\)</span>, so building the heap takes <span class="math inline">\(O(N \cdot \log k)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is dominated by the level order traversal queue and the heap. The queue will reach <span class="math inline">\(O(N)\)</span> at the last level, while the heap has a maximum size of <span class="math inline">\(O(k)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/last-day-where-you-can-still-cross/description" target="_blank" rel="noopener noreferrer">Last Day Where You Can Still Cross</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>1-based</strong> binary matrix where <code>0</code> represents land and <code>1</code> represents water. You are given integers <code>row</code> and <code>col</code> representing the number of rows and columns in the matrix, respectively.</p>

<p>Initially on day <code>0</code>, the <strong>entire</strong> matrix is <strong>land</strong>. However, each day a new cell becomes flooded with <strong>water</strong>. You are given a <strong>1-based</strong> 2D array <code>cells</code>, where <code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> represents that on the <code>i<sup>th</sup></code> day, the cell on the <code>r<sub>i</sub><sup>th</sup></code> row and <code>c<sub>i</sub><sup>th</sup></code> column (<strong>1-based</strong> coordinates) will be covered with <strong>water</strong> (i.e., changed to <code>1</code>).</p>

<p>You want to find the <strong>last</strong> day that it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells. You can start from <strong>any</strong> cell in the top row and end at <strong>any</strong> cell in the bottom row. You can only travel in the<strong> four</strong> cardinal directions (left, right, up, and down).</p>

<p>Return <em>the <strong>last</strong> day where it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/1.png" style="width: 624px; height: 162px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/2.png" style="width: 504px; height: 178px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/3.png" style="width: 666px; height: 167px;" />
<pre>
<strong>Input:</strong> row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>cells.length == row * col</code></li>
	<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>
	<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>
	<li>All the values of <code>cells</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/level-of-nodes-1587115620/1" target="_blank" rel="noopener noreferrer">Level of Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer <strong>x</strong> and an undirected acyclic graph with <strong>v nodes</strong>, labeled from <strong>0 </strong>to <strong>v-1</strong>, and <strong>e </strong>edges, return the <strong>level </strong>of node labeled as <strong>x</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Level </strong>is the <strong>minimum </strong>number of edges you must travel from the node 0 to some target.</span></p>
<p><span style="font-size: 18px;">If there doesn't exists such a node that is labeled as <strong>x</strong>, <strong>return -1</strong>.<br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">x</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> = 4</span></span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701248/Web/Other/blobid0_1745299763.jpg" width="414" height="366" /><br /><span style="font-size: 18px;"><strong>Output: </strong>2
<strong>Explanation</strong>:
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701248/Web/Other/blobid1_1745299817.jpg" width="461" height="307" /><br /><span style="font-size: 18px;">We can clearly see that Node 4 lies at Level 2.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">x</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> = 1</span></span>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701248/Web/Other/blobid2_1745299852.jpg" width="314" height="209" /> <br /><span style="font-size: 18px;"><strong>Output: </strong>1
<strong>Explanation</strong>: Node 1 lies at level 1, immediate after Node 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(v)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(v)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />2 </span> <span style="font-size: 18px;">&le;</span> v<span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;">&le;</span> <span style="font-size: 18px;"> 10<sup>4<br /></sup></span><span style="font-size: 18px;">1 &le;<span style="font-size: medium;"> e</span>&nbsp;&le;<span style="font-size: medium;">&nbsp;</span>10<sup>4</sup><br />0 </span> <span style="font-size: 18px;">&le;</span> adj<span style="font-size: 18px;"><sub>i, j</sub> &lt; v</span><br /><span style="font-size: 18px;">1 </span> <span style="font-size: 18px;">&le;</span> x<span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;">&lt;</span> <span style="font-size: 14pt;">v</span><span style="font-size: 18px;"><br /></span></p>
<p><span style="font-size: 18px;"><strong>Note : </strong>Graph doesn't contain multiple edges and self loops.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/description" target="_blank" rel="noopener noreferrer">Lexicographically Smallest String After Applying Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of <strong>even length</strong> consisting of digits from <code>0</code> to <code>9</code>, and two integers <code>a</code> and <code>b</code>.</p>

<p>You can apply either of the following two operations any number of times and in any order on <code>s</code>:</p>

<ul>
	<li>Add <code>a</code> to all odd indices of <code>s</code> <strong>(0-indexed)</strong>. Digits post <code>9</code> are cycled back to <code>0</code>. For example, if <code>s = &quot;3456&quot;</code> and <code>a = 5</code>, <code>s</code> becomes <code>&quot;3951&quot;</code>.</li>
	<li>Rotate <code>s</code> to the right by <code>b</code> positions. For example, if <code>s = &quot;3456&quot;</code> and <code>b = 1</code>, <code>s</code> becomes <code>&quot;6345&quot;</code>.</li>
</ul>

<p>Return <em>the <strong>lexicographically smallest</strong> string you can obtain by applying the above operations any number of times on</em> <code>s</code>.</p>

<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>. For example, <code>&quot;0158&quot;</code> is lexicographically smaller than <code>&quot;0190&quot;</code> because the first position they differ is at the third letter, and <code>&#39;5&#39;</code> comes before <code>&#39;9&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;5525&quot;, a = 9, b = 2
<strong>Output:</strong> &quot;2050&quot;
<strong>Explanation:</strong> We can apply the following operations:
Start:  &quot;5525&quot;
Rotate: &quot;2555&quot;
Add:    &quot;2454&quot;
Add:    &quot;2353&quot;
Rotate: &quot;5323&quot;
Add:    &quot;5222&quot;
Add:    &quot;5121&quot;
Rotate: &quot;2151&quot;
Add:    &quot;2050&quot;​​​​​
There is no way to obtain a string that is lexicographically smaller than &quot;2050&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;74&quot;, a = 5, b = 1
<strong>Output:</strong> &quot;24&quot;
<strong>Explanation:</strong> We can apply the following operations:
Start:  &quot;74&quot;
Rotate: &quot;47&quot;
​​​​​​​Add:    &quot;42&quot;
​​​​​​​Rotate: &quot;24&quot;​​​​​​​​​​​​
There is no way to obtain a string that is lexicographically smaller than &quot;24&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0011&quot;, a = 4, b = 2
<strong>Output:</strong> &quot;0011&quot;
<strong>Explanation:</strong> There are no sequence of operations that will give us a lexicographically smaller string than &quot;0011&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 100</code></li>
	<li><code>s.length</code> is even.</li>
	<li><code>s</code> consists of digits from <code>0</code> to <code>9</code> only.</li>
	<li><code>1 &lt;= a &lt;= 9</code></li>
	<li><code>1 &lt;= b &lt;= s.length - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/lexicographical-smallest-string/1" target="_blank" rel="noopener noreferrer">Lexicographical Smallest String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string<strong>&nbsp;s </strong>of length <strong>N</strong>, the task is to find the lexicographically smallest string&nbsp;of minimum characters that do not exist as a substring&nbsp;in <strong>s</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">s = "aabacdefghijklmnopqrstuvwxyz"</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">ad</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">All the single digit strings from [a-z] occur in the 
given string and in two character strings, strings 
{aa, ab, ac} occur but ad is not present in the given 
string.</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">s = "geeksforgeeks"</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">a</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">Single digit string "a" is not present in the given 
string.</span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">Your task is to complete the function <strong>lexicographicalSmallestString()</strong> which takes a string <strong>s</strong> as the only argument and returns the lexicographically smallest string which is not present as the substring in the string <strong>s</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>&nbsp;* log(N))</span></p>
<p><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(N<sup>2</sup>)</span></p>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= N &lt;= 10<sup>3</sup></span></li>
<li><span style="font-size: 18px;">String s consists of lowercase English alphabets.</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-cycle-in-a-graph/description" target="_blank" rel="noopener noreferrer">Longest Cycle in a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>directed</strong> graph of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, where each node has <strong>at most one</strong> outgoing edge.</p>

<p>The graph is represented with a given <strong>0-indexed</strong> array <code>edges</code> of size <code>n</code>, indicating that there is a directed edge from node <code>i</code> to node <code>edges[i]</code>. If there is no outgoing edge from node <code>i</code>, then <code>edges[i] == -1</code>.</p>

<p>Return <em>the length of the <strong>longest</strong> cycle in the graph</em>. If no cycle exists, return <code>-1</code>.</p>

<p>A cycle is a path that starts and ends at the <strong>same</strong> node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png" style="width: 335px; height: 191px;" />
<pre>
<strong>Input:</strong> edges = [3,3,4,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest cycle in the graph is the cycle: 2 -&gt; 4 -&gt; 3 -&gt; 2.
The length of this cycle is 3, so 3 is returned.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png" style="width: 171px; height: 161px;" />
<pre>
<strong>Input:</strong> edges = [2,-1,3,1]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no cycles in this graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-1 &lt;= edges[i] &lt; n</code></li>
	<li><code>edges[i] != i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-increasing-path-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Longest Increasing Path in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>

<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description" target="_blank" rel="noopener noreferrer">Lowest Common Ancestor of Deepest Leaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the lowest common ancestor of its deepest leaves</em>.</p>

<p>Recall that:</p>

<ul>
	<li>The node of a binary tree is a leaf if and only if it has no children</li>
	<li>The depth of the root of the tree is <code>0</code>. if the depth of a node is <code>d</code>, the depth of each of its children is <code>d + 1</code>.</li>
	<li>The lowest common ancestor of a set <code>S</code> of nodes, is the node <code>A</code> with the largest depth such that every node in <code>S</code> is in the subtree with root <code>A</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" style="width: 600px; height: 510px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]
<strong>Output:</strong> [2,7,4]
<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest leaf-nodes of the tree.
Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The root is the deepest node in the tree, and it&#39;s the lca of itself.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0,1,3,null,2]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The deepest leaf node in the tree is 2, the lca of one node is itself.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
	<li>The values of the nodes in the tree are <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 865: <a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/" target="_blank">https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursion">Approach 1: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem gives a binary tree and requires returning the lowest common ancestor of its deepest leaf node. The depth of the tree's root node is <span class="math inline">\(0\)</span>. We note that all nodes with the maximum depth are leaf nodes. For convenience, we refer to the lowest common ancestor of the deepest leaf nodes as the <span class="math inline">\(\textit{lca}\)</span> node.</p>
<p>We use a recursive method to perform a depth-first search, recursively traversing each node in the tree and returning the maximum depth <span class="math inline">\(d\)</span> of the current subtree and the <span class="math inline">\(\textit{lca}\)</span> node. If the current node is null, we return depth <span class="math inline">\(0\)</span> and an null node. In each search, we recursively search the left and right subtrees, and then compare the depths of the left and right subtrees:</p>
<ul>
<li>If the left subtree is deeper, the deepest leaf node is in the left subtree, we return {left subtree depth + <span class="math inline">\(1\)</span>, the <span class="math inline">\(\textit{lca}\)</span> node of the left subtree}</li>
<li>If the right subtree is deeper, the deepest leaf node is in the right subtree, we return {right subtree depth + <span class="math inline">\(1\)</span>, the <span class="math inline">\(\textit{lca}\)</span> node of the right subtree}</li>
<li>If both left and right subtrees have the same depth and both have the deepest leaf nodes, we return {left subtree depth + <span class="math inline">\(1\)</span>, current node}.</li>
</ul>
<p>Finally, we return the root node's <span class="math inline">\(\textit{lca}\)</span> node.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/V5MKhFYN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of tree nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We only need to traverse all the nodes in the tree once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is mainly the recursive space, with the worst case being <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/making-a-large-island/description" target="_blank" rel="noopener noreferrer">Making A Large Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> binary matrix <code>grid</code>. You are allowed to change <strong>at most one</strong> <code>0</code> to be <code>1</code>.</p>

<p>Return <em>the size of the largest <strong>island</strong> in</em> <code>grid</code> <em>after applying this operation</em>.</p>

<p>An <strong>island</strong> is a 4-directionally connected group of <code>1</code>s.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Change one 0 to 1 and connect two 1s, then we get an island with area = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1],[1,0]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>Change the 0 to 1 and make the island bigger, only one island with area = 4.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1],[1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Can&#39;t change any 0 to 1, only one island with area = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-dfs">Approach 1: Using DFS</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a binary matrix where each cell is either <code>0</code> (representing water) or <code>1</code> (representing land) and the ability to flip at most one <code>0</code> to <code>1</code>. Our task is to find the largest island in the matrix, or in other words, the largest group of <code>1</code>s connected with each other either up, down, left, or right (4-directionally) after the flip operation.</p>
<p>At first, we might think of flipping each <code>0</code> to <code>1</code> and then calculating the size of the largest island in the modified matrix. However, this brute-force approach is inefficient, especially for larger grids, as it involves multiple recalculations for each flip, which would lead to Time Limit Exceeded (TLE) error.</p>
<p>Instead of recalculating island sizes for every flip, we can take advantage of the fact that flipping a single <code>0</code> only affects the islands adjacent to it. Specifically, flipping a <code>0</code> merges neighboring islands into one larger island. This insight allows us to efficiently compute the largest island after flipping by precomputing the sizes of all islands first.</p>
<p>Check out the diagram below, where we can see that we can merge two islands into one by flipping a zero in between.</p>
<p><img src="../Figures/827/make_large_island.png" alt="make_large_island" /></p>
<p>We start by traversing the grid and identifying all the islands using Depth-First Search (DFS). During this traversal, we give each island a unique identifier (like a color). At the same time, we also calculate and store the size of each island in a map, where the key is the island’s unique identifier and the value is its size. This precomputation allows us to avoid recalculating island sizes later.</p>
<blockquote>
<p>For a more comprehensive understanding of depth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">DFS Explore Card</a>.</p>
</blockquote>
<p>After labeling the islands and knowing their sizes, we then look at each <code>0</code> in the grid. Flipping a <code>0</code> to <code>1</code> might connect neighboring islands, creating a larger island. For each <code>0</code>, we examine the islands around it and collect their unique identifiers using a set (to avoid counting the same island more than once). We then sum up the sizes of these islands to calculate the size of the new island that would be formed if this <code>0</code> were flipped to <code>1</code>.</p>
<p>As we evaluate each potential flip, we compare the size of the island that would be formed with the largest island we’ve seen so far. This ensures that we find the largest possible island we can form by flipping a single <code>0</code>. We will handle special edge cases (e.g., the grid is full with <code>1</code>s or <code>0</code>s) separately.</p>
<p>This strategy is efficient because the grid is only traversed twice:</p>
<ol>
<li>To label the islands and compute their sizes.</li>
<li>To evaluate the potential island size for each <code>0</code> flip.</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<h5 id="exploreisland-helper-function"><code>exploreIsland</code> helper function:</h5>
<ul>
<li>
<p>Define the <code>exploreIsland</code> function which recursively explores an island with the given id <code>islandId</code> starting from the given cell <code>(currentRow, currentColumn)</code>.</p>
</li>
<li>
<p>Check if the current cell is out of bounds, is not part of an island or is already visited (i.e., its value is not <code>1</code>):</p>
<ul>
<li>If so, return <code>0</code>, indicating no land is found at this cell.</li>
</ul>
</li>
<li>
<p>Mark the current cell with the given <code>islandId</code> to indicate it has been visited.</p>
</li>
<li>
<p>Recursively explore the four neighboring cells (up, down, left, right) and accumulate the area of the island:</p>
<ul>
<li>Call <code>exploreIsland</code> for the cell below <code>(currentRow + 1, currentColumn)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell above <code>(currentRow - 1, currentColumn)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell to the right <code>(currentRow, currentColumn + 1)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell to the left <code>(currentRow, currentColumn - 1)</code>.</li>
</ul>
</li>
<li>
<p>Return the total area of the island (i.e., 1 + the sum of all reachable land cells from the current position).</p>
</li>
</ul>
<h5 id="largestisland-main-function"><code>largestIsland</code> main function:</h5>
<ul>
<li>
<p>Initialize <code>islandSizes</code> to store sizes of islands, and <code>islandId</code> starting at <code>2</code> (to mark islands).</p>
</li>
<li>
<p>Traverse through the grid to mark all islands and calculate their sizes:</p>
<ul>
<li>For each cell in the grid, if the cell contains a land (value <code>1</code>), call <code>exploreIsland()</code> to mark the island and calculate its size.</li>
<li>For each island, store the size in <code>islandSizes</code> using the <code>islandId</code> as the key and increment <code>islandId</code> for the next island.</li>
</ul>
</li>
<li>
<p>Check if there are no islands (empty grid), in which case return 1 (since flipping one <code>0</code> would form a new island).</p>
</li>
<li>
<p>If only one island exists in the entire grid, check if the size of that island is equal to the total grid size:</p>
<ul>
<li>If true, return the size of the island.</li>
<li>Otherwise, return the size of the island + 1 (as we can expand the island by flipping one <code>0</code>).</li>
</ul>
</li>
<li>
<p>Initialize <code>maxIslandSize</code> to 1, which will store the size of the largest island.</p>
</li>
<li>
<p>Traverse through the grid again to try converting each <code>0</code> to a <code>1</code> and calculate the resulting island size:</p>
<ul>
<li>For each <code>0</code>, check its neighboring cells (up, down, left, right) to find which islands are connected to it.</li>
<li>Use a unordered set to store unique neighboring island IDs.</li>
<li>Sum the sizes of all unique neighboring islands and add 1 (to account for the flipped <code>0</code> turning into a <code>1</code>).</li>
<li>Update <code>maxIslandSize</code> with the maximum island size found.</li>
</ul>
</li>
<li>
<p>Return <code>maxIslandSize</code>, the size of the largest island after trying to expand all possible <code>0</code>s.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fqsaoAuS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the grid, <span class="math inline">\(m\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The algorithm consists of two main phases. In the first phase, we iterate over every cell in the grid to identify and mark islands using a Depth-First Search (DFS) approach. During this process, each cell is visited at most once, ensuring that the DFS traversal contributes <span class="math inline">\(O(n \times m)\)</span> to the time complexity.</p>
<p>In the second phase, we iterate over every cell again to explore the possibility of converting each <code>0</code> to <code>1</code> and calculating the potential island size. For each <code>0</code>, we check its four neighboring cells, which is a constant-time operation. The use of an unordered set ensures that neighboring islands are counted uniquely, and the total work done in this phase is also <span class="math inline">\(O(n \times m)\)</span>.</p>
<p>Thus, the overall time complexity is dominated by the grid traversal and DFS, resulting in <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The space complexity is primarily determined by the recursion stack used during the DFS traversal and the storage required for the unordered map that keeps track of island sizes. In the worst case, the recursion depth of the DFS can be <span class="math inline">\(O(n \times m)\)</span> if the entire grid forms a single large island. The unordered map stores the sizes of all islands, and in the worst case, the number of islands can be proportional to the number of cells, contributing <span class="math inline">\(O(n \times m)\)</span> to the space complexity.</p>
<p>Furthermore, the unordered set used to store neighboring islands for each <code>0</code> cell has a maximum size of 4, as there are only four possible neighboring cells. This does not significantly impact the overall space complexity.</p>
<p>Therefore, the dominant factors are the recursion stack and the unordered map, resulting in an overall space complexity of <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-disjoint-set-union-dsu">Approach 2: Using Disjoint Set Union (DSU)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Another way to solve this problem is by using a data structure called <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Disjoint Set Union (DSU)</a>, also known as Union-Find.</p>
<p>In DSU, the main goal is to keep track of groups (or sets) of elements where each set has a representative. The key operations in DSU are:</p>
<ol>
<li><strong>Find</strong>: This operation helps to find the representative (or &quot;leader&quot;) of the set to which an element belongs. If two elements are in the same set, they will have the same representative.</li>
<li><strong>Union</strong>: This operation merges two sets together. If two elements belong to different sets, they are combined into a single set, and the representative of one set becomes the representative of the merged set.</li>
</ol>
<p>The idea behind DSU is that we represent each island as a set, and then we merge islands when we encounter an adjacent land cell. This helps us keep track of which cells belong to which island and how big each island is.</p>
<p>First, we initialize a DSU structure where each land cell is its own representative (each cell is its own island), meaning that  <code>parent[node] = node</code> for every land cell node. We also initialize the <code>islandSize</code> array, where each island starts with a size of 1 (since each island is just one land cell initially). This is represented as <code>islandSize[node] = 1</code>.</p>
<p>As we traverse the grid, whenever we encounter a land cell (<code>1</code>), we check its adjacent cells (up, down, left, right). If an adjacent cell is also land, we union their corresponding sets. This means we merge the two islands (sets) into one larger island. The merging process ensures that the larger island becomes the representative of the merged set, keeping the data structure efficient.</p>
<p>During the merging step, we also update the size of the new island (set) by adding the size of the two merged islands. This is done by maintaining the <code>islandSize</code> array, where <code>islandSize[node]</code> is updated after each union operation.</p>
<p>After the initial union of all adjacent land cells, we then evaluate the potential effect of flipping a <code>0</code> (water) cell to <code>1</code> (land). When flipping a <code>0</code> to <code>1</code>, it will create a new island that merges with its adjacent islands (if any). To calculate the size of the new island formed by flipping a <code>0</code>, we simply look at the neighboring islands (sets) and calculate the size of the combined island. We do this by finding the representatives of the neighboring sets using find operations and summing their sizes.</p>
<p>As we evaluate each potential flip, we keep track of the largest island size encountered. If the grid is already filled with <code>1</code>s or <code>0</code>s, we handle these edge cases accordingly, but the main idea remains to maximize the island size formed by flipping a single <code>0</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="define-the-disjointset-class">Define the <code>DisjointSet</code> class:</h5>
<ul>
<li>
<p>Initialize <code>parent</code> and <code>islandSize</code> arrays:</p>
<ul>
<li><code>parent</code> stores the parent of each node.</li>
<li><code>islandSize</code> stores the size of the connected island for each root.</li>
</ul>
</li>
<li>
<p>Initialize the <code>DisjointSet</code> constructor with <code>n</code> elements:</p>
<ul>
<li>For each node from <code>l</code> to <code>n-1</code>:
<ul>
<li>Set <code>parent[node] = node</code>, meaning each node is initially its own parent.</li>
<li>Set <code>islandSize[node] = 1</code>, indicating each island starts with size 1.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Implement <code>findRoot</code> function with path compression:</p>
<ul>
<li>If the current node is its own parent, return the node as the root.</li>
<li>Otherwise, recursively find the root of the parent and apply path compression by updating the parent of the node.</li>
</ul>
</li>
<li>
<p>Implement <code>unionNodes(nodeA, nodeB)</code> function to union two sets based on size:</p>
<ul>
<li>Find the roots of both <code>nodeA</code> and <code>nodeB</code> using the <code>findRoot</code> function.</li>
<li>If both nodes are already in the same set (i.e., have the same root), do nothing.</li>
<li>Otherwise, union the sets by size:
<ul>
<li>Attach the smaller island to the larger one:
<ul>
<li>If the island of <code>nodeA</code> is smaller, set <code>parent[rootA] = rootB</code> and update the size of <code>rootB</code>’s island.</li>
<li>If the island of <code>nodeB</code> is smaller, set <code>parent[rootB] = rootA</code> and update the size of <code>rootA</code>’s island.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="in-the-given-solution-class">In the given <code>Solution</code> class:</h5>
<ul>
<li>
<p>Initialize <code>rows</code> and <code>columns</code> to store the grid's dimensions.</p>
</li>
<li>
<p>Initialize a Disjoint Set Union (DSU) for the entire grid with <code>rows * columns</code> size.</p>
</li>
<li>
<p>Define direction arrays (<code>rowDirections</code>, <code>columnDirections</code>) for traversing up, down, left, and right.</p>
</li>
</ul>
<p>Step 1: Union adjacent <code>1</code>s in the grid:</p>
<ul>
<li>Iterate through each cell in the grid:
<ul>
<li>If the current cell contains <code>1</code>, calculate the flattened 1D index for the current cell, as <code>(columns * currentRow) + currentColumn</code>.</li>
<li>For each of the four possible directions (up, down, left, right), check if the neighbor is within bounds and also contains <code>1</code>.</li>
<li>If the neighbor is valid, flatten the 2D index and use the DSU to union the current cell and the neighbor.</li>
</ul>
</li>
</ul>
<p>Step 2: Calculate the maximum possible island size:</p>
<ul>
<li>Initialize <code>maxIslandSize</code> to store the largest island size and <code>hasZero</code> as a flag to check if there are any zeros in the grid.</li>
<li>Initialize a <code>uniqueRoots</code> set to store the unique roots of neighboring <code>1</code>s for each <code>0</code> in the grid.</li>
<li>Iterate through the grid to find all zeros (<code>0</code> cells):
<ul>
<li>For each <code>0</code>, initialize the <code>currentIslandSize</code> to <code>1</code> (since we are flipping the <code>0</code>).</li>
<li>For each direction (up, down, left, right), check if the neighboring cell contains <code>1</code> and if so, add the root of the neighboring island to <code>uniqueRoots</code>.</li>
<li>Sum the sizes of the unique neighboring islands using their roots.</li>
<li>Update <code>maxIslandSize</code> with the largest island size found.</li>
</ul>
</li>
</ul>
<p>Step 3: Return the result:</p>
<ul>
<li>If there are no zeros in the grid, return the size of the entire grid (i.e., <code>rows * columns</code>).</li>
<li>Otherwise, return <code>maxIslandSize</code>, the largest island size after flipping a zero.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/fFCPs4tS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the grid, <span class="math inline">\(m\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The algorithm consists of two main phases. In the first phase, we iterate over every cell in the grid and we use a Disjoint Set Union (DSU) data structure to union adjacent <code>1</code>s. For each cell, we check its four neighboring cells, which is a constant-time operation. The DSU operations, including <code>findRoot</code> and <code>unionNodes</code>, are nearly constant time due to path compression and union by size optimizations. Thus, the first phase contributes <span class="math inline">\(O(n \times m)\)</span> to the time complexity.</p>
<p>In the second phase, we iterate over every cell again to explore the possibility of converting each <code>0</code> to <code>1</code> and calculating the potential island size. For each <code>0</code>, we check its four neighboring cells and use the DSU to find the roots of neighboring islands. The unordered set ensures that neighboring islands are counted uniquely, and the total work done in this phase is also <span class="math inline">\(O(n \times m)\)</span>.</p>
<p>Therefore, the overall time complexity is dominated by the grid traversal and DSU operations, resulting in <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The space complexity is primarily determined by the DSU data structure, which stores the parent and size of each cell. Both the <code>parent</code> and <code>islandSize</code> arrays require <span class="math inline">\(O(n \times m)\)</span> space. Additionally, the unordered set used to store unique roots for neighboring islands has a maximum size of 4, as there are only four possible neighboring cells. This does not significantly impact the overall space complexity.</p>
<p>Therefore, the dominant factor is the DSU data structure, resulting in an overall space complexity of <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/making-a-large-island/1" target="_blank" rel="noopener noreferrer">Making A Large Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an<strong> n x n </strong>binary matrix<strong> grid[][]</strong>. You are allowed to change at most one<strong> 0</strong> to <strong>1</strong>.&nbsp;</span><span style="font-size: 18.6667px;">A group of <strong>connected 1s</strong> forms an island. Two 1s are connected if they share one of their sides with each other.</span></p>
<p><span style="font-size: 14pt;">Return the size of the <strong>largest island</strong> in the grid after applying this operation.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><span style="font-size: 14pt;"><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,0],[0,1]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">3</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Change any one 0 to 1 and connect two 1s, then we get an island with area = 3.</span></span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,1],[1,0]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">4</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Change the only 0 to 1 and make the island bigger, then we get an island with area = 4.</span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,1],[1,1]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">4</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Can't change any 0 to 1, only one island possible with area = 4.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Constraints:</span></strong></p>
<p><span style="font-size: 18.6667px;">1 &lt;= n &lt;= 500<br />0 &lt;= grid[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/map-of-highest-peak/description" target="_blank" rel="noopener noreferrer">Map of Highest Peak</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer matrix <code>isWater</code> of size <code>m x n</code> that represents a map of <strong>land</strong> and <strong>water</strong> cells.</p>

<ul>
	<li>If <code>isWater[i][j] == 0</code>, cell <code>(i, j)</code> is a <strong>land</strong> cell.</li>
	<li>If <code>isWater[i][j] == 1</code>, cell <code>(i, j)</code> is a <strong>water</strong> cell.</li>
</ul>

<p>You must assign each cell a height in a way that follows these rules:</p>

<ul>
	<li>The height of each cell must be non-negative.</li>
	<li>If the cell is a <strong>water</strong> cell, its height must be <code>0</code>.</li>
	<li>Any two adjacent cells must have an absolute height difference of <strong>at most</strong> <code>1</code>. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</li>
</ul>

<p>Find an assignment of heights such that the maximum height in the matrix is <strong>maximized</strong>.</p>

<p>Return <em>an integer matrix </em><code>height</code><em> of size </em><code>m x n</code><em> where </em><code>height[i][j]</code><em> is cell </em><code>(i, j)</code><em>&#39;s height. If there are multiple solutions, return <strong>any</strong> of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png" style="width: 220px; height: 219px;" /></strong></p>

<pre>
<strong>Input:</strong> isWater = [[0,1],[0,0]]
<strong>Output:</strong> [[1,0],[2,1]]
<strong>Explanation:</strong> The image shows the assigned heights of each cell.
The blue cell is the water cell, and the green cells are the land cells.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png" style="width: 300px; height: 296px;" /></strong></p>

<pre>
<strong>Input:</strong> isWater = [[0,0,1],[1,0,0],[0,0,0]]
<strong>Output:</strong> [[1,1,0],[0,1,1],[1,2,2]]
<strong>Explanation:</strong> A height of 2 is the maximum possible height of any assignment.
Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == isWater.length</code></li>
	<li><code>n == isWater[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>isWater[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li>There is at least <strong>one</strong> water cell.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 542: <a href="https://leetcode.com/problems/01-matrix/description/" target="_blank">https://leetcode.com/problems/01-matrix/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D matrix <code>isWater</code> of dimensions <code>m x n</code>, which represents a map consisting of land and water cells. Specifically:</p>
<ul>
<li>If <code>isWater[i][j] = 0</code>, the cell <code>(i, j)</code> represents land.</li>
<li>If <code>isWater[i][j] = 1</code>, the cell <code>(i, j)</code> represents water.</li>
</ul>
<p>The goal is to assign a height to each cell such that the highest peak on the map (i.e., the greatest height of any cell) is as high as possible. This assignment must follow these rules:</p>
<ol>
<li>The height of each cell must be non-negative.</li>
<li>The height of all water cells is fixed at 0. These cells have fixed heights and cannot be changed.</li>
<li>The height difference between two adjacent cells (cells that share a side) must not be greater than one. For example, if the height of cell <code>(2, 3)</code> is <code>4</code>, then the heights of its adjacent cells—<code>(1, 3)</code>, <code>(3, 3)</code>, <code>(2, 4)</code>, and <code>(2, 2)</code>—must be either <code>3</code>, <code>4</code> or <code>5</code>.</li>
</ol>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Let’s first break the problem down into a simpler, one-dimensional version.</p>
<p>Imagine a row of cells with only one water cell. Intuitively, as we move away from the water cell, the heights of the land cells should gradually increase. The height of each land cell can naturally be determined by its distance from the water cell.</p>
<p><img src="../Figures/1765/1765_approach1a.png" alt="One-dimensional version of the problem with a single water cell" /></p>
<p>Now, let’s add a second water cell to the row. The idea stays the same, but now each land cell’s height is determined by its smallest distance to any water cell. This ensures a smooth increase in height as we move away from both water cells.</p>
<p><img src="../Figures/1765/1765_approach1b.png" alt="One-dimensional version of the problem with two water cells" /></p>
<p>When we extend this logic to two dimensions, the concept is identical. For every cell in the grid, we calculate its smallest distance to any water cell and assign that value as its height.</p>
<ul>
<li>Heights increase smoothly from water cells, ensuring the highest peak is at the farthest distance from all water cells.<br />
This can be visualized as a &quot;ripple effect&quot; where water cells propagate their distances outward, assigning heights to nearby land cells.</li>
</ul>
<p><img src="../Figures/1765/1765_approach1c.png" alt="Two-dimensional version" /></p>
<p>This approach works intuitively for two reasons:</p>
<ul>
<li>It follows the rule that the height difference between two adjacent cells is at most one. This is because the minimum distance to water for any two neighboring cells cannot differ by more than one.</li>
<li>It’s optimal because it ensures that the height of the cells increases consistently as we move farther from water cells, maximizing the highest peak on the map.</li>
</ul>
<p>To find the shortest distance from any cell to a water cell, we use Breadth-First Search (BFS) starting from all water cells. When a land cell is reached for the first time, its shortest distance to a water cell is set.</p>
<blockquote>
<p>For a more comprehensive understanding of breadth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card 🔗</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define two arrays of size <code>4</code>: <code>dx = [0, 0, 1, -1]</code> and <code>dy = [1, -1, 0, 0]</code>. Each pair <code>(dx[d], dy[d])</code> represents one of the four possible directions to an adjacent cell.</li>
<li>Initialize a 2D matrix, named <code>cellHeights</code>, of the same dimension as <code>isWater</code>. Set all of its cells to an invalid value, i.e. <code>-1</code>.</li>
<li>Initialize an empty queue of pairs, <code>cellQueue</code>.</li>
<li>Iterate over the <code>isWater</code> matrix:
<ul>
<li>Push every water cell into the <code>cellQueue</code>.</li>
<li>Set the height of each water cell to be <code>0</code>.</li>
</ul>
</li>
<li>Initialize <code>heightOfNextLayer</code> to <code>1</code> - that is the height of the neighbors of the cells currently in queue.</li>
<li>While the <code>cellQueue</code> is not empty:
<ul>
<li>Set <code>layerSize</code> to the size of the queue.</li>
<li>For each cell in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>layerSize - 1</code>:
<ul>
<li>Pop the top cell <code>currentCell</code> out of the queue.</li>
<li>For each direction, i.e. for <code>d</code> from <code>0</code> to <code>3</code>:
<ul>
<li>Find the neighbor of the current cell to that direction, <code>neighborCell = (currentCell.x + dx[d], currentCell.y + dy[d])</code>.</li>
<li>If <code>neighbor</code> is a valid cell (i.e. it is not out of the bounds of the matrix) and it is not already visited (i.e. <code>cellHeights[neighbor.x][neighbor.y] == -1</code>):
<ul>
<li>Set <code>cellHeights[neighbor.x][neighbor.y]</code> to <code>heightOfNextLayer</code>.</li>
<li>Push <code>neighbor</code> into the <code>cellQueue</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>heightOfNextLayer</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>cellHeights</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AbkNMEXz/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns in the <code>isWater</code> matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We perform a single multi-source BFS traversal over the cells of the matrix. The time complexity of BFS is <span class="math inline">\(O(V + E)\)</span>, where <span class="math inline">\(V\)</span> is the number of vertices (cells in the grid, <span class="math inline">\(m \times n\)</span>) and <span class="math inline">\(E\)</span> is the number of edges (connections between neighboring cells).</p>
<p>In a grid, each cell has at most 4 neighbors, resulting in at most <span class="math inline">\(4 \cdot m \times n\)</span> edges. Since <span class="math inline">\(E\)</span> is proportional to <span class="math inline">\(V\)</span> in a grid, the total time complexity simplifies to <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We use a 2D matrix <code>cellHeights</code> of size <span class="math inline">\(m \times n\)</span> to store the calculated heights. Additionally, the BFS queue can hold up to <span class="math inline">\(m \times n\)</span> cells in the worst case. Therefore, the overall space complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we build on the idea that the height of each cell should be the smallest distance to any water cell. From there, we observe that once we know the smallest distances of a cell’s neighboring cells, calculating the distance for the current cell becomes straightforward — it’s just the smallest of the neighbors’ distances plus one. The core idea is to use dynamic programming to compute these distances efficiently.</p>
<p>Dynamic programming works well here because:</p>
<ol>
<li>Each cell's height can be derived from the heights of its neighboring cells.</li>
<li>By iterating over the grid in a specific order, we can ensure that all necessary states are computed before being used.</li>
</ol>
<p>However, the challenge is figuring out the correct order to compute these states. In DP terms, we need to ensure all necessary states are computed before using them.</p>
<p>Let’s simplify by imagining we can only move down or right. In that case, the top-left corner has no choices — it’s either a water cell or not reachable. Similarly, for the first row and column, we only have options from neighboring cells directly below or to the right.</p>
<p>Using this, we can fill the DP table row by row and column by column, in common order.</p>
<p>Finally, we perform a second pass, moving upward or left, to correct any distances that were overestimated during the first pass, which only considered partial directions (top and left).</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>rows</code> to the number of rows and <code>columns</code> to the number of columns of the <code>isWater</code> matrix.</li>
<li>Initialize a 2D matrix, named <code>cellHeights</code>, of the same dimension as <code>isWater</code>. Set all of its cells to a large value, i.e. <code>INF</code>.</li>
<li>Iterate over the <code>cellHeights</code> matrix and set the height of all water cells to <code>0</code>.</li>
<li>Loop with <code>row</code> from <code>0</code> to <code>rows - 1</code>:
<ul>
<li>Loop with <code>col</code> from <code>0</code> to <code>columns - 1</code>:
<ul>
<li>Initialize <code>minNeighborDistance</code> to <code>INF</code>.</li>
<li>Find the neighbor above the current cell, i.e. <code>neighborRow = row - 1, neighborCol = col</code>.</li>
<li>If the neighbor is valid, i.e. if it is not out of the bounds of the grid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Find the neighbor to the left of the current cell, i.e. <code>neighborRow = row, neighborCol = col - 1</code>.</li>
<li>If the neighbor is valid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Set the height of the current cell to the minimum of its current value <code>minNeighborDistance + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Perform the second pass over <code>cellHeights</code> moving in the opposite directions:</li>
<li>Loop with <code>row</code> from <code>rows - 1</code> to <code>0</code>:
<ul>
<li>Loop with <code>col</code> from <code>columns - 1</code> to <code>0</code>:
<ul>
<li>Initialize <code>minNeighborDistance</code> to <code>INF</code>.</li>
<li>Find the neighbor below the current cell, i.e. <code>neighborRow = row + 1, neighborCol = col</code>.</li>
<li>If the neighbor is valid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Find the neighbor to the right of the current cell, i.e. <code>neighborRow = row, neighborCol = col + 1</code>.</li>
<li>If the neighbor is valid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Set the height of the current cell to the minimum of its current value <code>minNeighborDistance + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>cellHeights</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/oYC2r7oo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns in the <code>isWater</code> matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We iterate over the cells of the matrix 3 times and perform constant-time operations, including comparisons and assignments, on each iteration. Therefore, the time complexity of the algorithm is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We use a 2D matrix <code>cellHeights</code> of size <span class="math inline">\(m \times n\)</span> to store the calculated heights resulting in a space complexity of <span class="math inline">\(O(m \times n)\)</span>. Unlike the previous approach that used a queue as an additional data structure, this method only relies on the input grid and the resulting matrix, keeping the space complexity factor lower.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-area-of-island/description" target="_blank" rel="noopener noreferrer">Max Area of Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>&#39;s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>

<p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p>

<p>Return <em>the maximum <strong>area</strong> of an island in </em><code>grid</code>. If there is no island, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" style="width: 500px; height: 310px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The answer is not 11, because the island must be connected 4-directionally.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,0,0,0,0,0,0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-recursive-accepted">Approach #1: Depth-First Search (Recursive) [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We want to know the area of each connected shape in the grid, then take the maximum of these.</p>
<p>If we are on a land square and explore every square connected to it 4-directionally (and recursively squares connected to those squares, and so on), then the total number of squares explored will be the area of that connected shape.</p>
<p>To ensure we don't count squares in a shape more than once, let's use <code>seen</code> to keep track of squares we haven't visited before. It will also prevent us from counting the same shape more than once.</p>
<p><a href="https://leetcode.com/playground/CQGNqDhr/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(R*C)\)</span>, where <span class="math inline">\(R\)</span> is the number of rows in the given <code>grid</code>, and <span class="math inline">\(C\)</span> is the number of columns.  We visit every square once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(R*C)\)</span>, the space used by <code>seen</code> to keep track of visited squares and the space used by the call stack during our recursion.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-iterative-accepted">Approach #2: Depth-First Search (Iterative) [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can try the same approach using a stack-based, (or &quot;iterative&quot;) depth-first search.</p>
<p>Here, <code>seen</code> will represent squares that have either been visited or are added to our list of squares to visit (<code>stack</code>). For every starting land square that hasn't been visited, we will explore 4-directionally around it, adding land squares that haven't been added to <code>seen</code> to our <code>stack</code>.</p>
<p>On the side, we'll keep a count <code>shape</code> of the total number of squares seen during the exploration of this shape. We'll want the running max of these counts.</p>
<p><a href="https://leetcode.com/playground/khZHhSir/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(R*C)\)</span>, where <span class="math inline">\(R\)</span> is the number of rows in the given <code>grid</code>, and <span class="math inline">\(C\)</span> is the number of columns. We visit every square once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(R*C)\)</span>, the space used by <code>seen</code> to keep track of visited squares and the space used by <code>stack</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-amount-after-two-days-of-conversions/description" target="_blank" rel="noopener noreferrer">Maximize Amount After Two Days of Conversions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>initialCurrency</code>, and you start with <code>1.0</code> of <code>initialCurrency</code>.</p>

<p>You are also given four arrays with currency pairs (strings) and rates (real numbers):</p>

<ul>
	<li><code>pairs1[i] = [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code> denotes that you can convert from <code>startCurrency<sub>i</sub></code> to <code>targetCurrency<sub>i</sub></code> at a rate of <code>rates1[i]</code> on <strong>day 1</strong>.</li>
	<li><code>pairs2[i] = [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code> denotes that you can convert from <code>startCurrency<sub>i</sub></code> to <code>targetCurrency<sub>i</sub></code> at a rate of <code>rates2[i]</code> on <strong>day 2</strong>.</li>
	<li>Also, each <code>targetCurrency</code> can be converted back to its corresponding <code>startCurrency</code> at a rate of <code>1 / rate</code>.</li>
</ul>

<p>You can perform <strong>any</strong> number of conversions, <strong>including zero</strong>, using <code>rates1</code> on day 1, <strong>followed</strong> by any number of additional conversions, <strong>including zero</strong>, using <code>rates2</code> on day 2.</p>

<p>Return the <strong>maximum</strong> amount of <code>initialCurrency</code> you can have after performing any number of conversions on both days <strong>in order</strong>.</p>

<p><strong>Note: </strong>Conversion rates are valid, and there will be no contradictions in the rates for either day. The rates for the days are independent of each other.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">initialCurrency = &quot;EUR&quot;, pairs1 = [[&quot;EUR&quot;,&quot;USD&quot;],[&quot;USD&quot;,&quot;JPY&quot;]], rates1 = [2.0,3.0], pairs2 = [[&quot;JPY&quot;,&quot;USD&quot;],[&quot;USD&quot;,&quot;CHF&quot;],[&quot;CHF&quot;,&quot;EUR&quot;]], rates2 = [4.0,5.0,6.0]</span></p>

<p><strong>Output:</strong> <span class="example-io">720.00000</span></p>

<p><strong>Explanation:</strong></p>

<p>To get the maximum amount of <strong>EUR</strong>, starting with 1.0 <strong>EUR</strong>:</p>

<ul>
	<li>On Day 1:
	<ul>
		<li>Convert <strong>EUR </strong>to <strong>USD</strong> to get 2.0 <strong>USD</strong>.</li>
		<li>Convert <strong>USD</strong> to <strong>JPY</strong> to get 6.0 <strong>JPY</strong>.</li>
	</ul>
	</li>
	<li>On Day 2:
	<ul>
		<li>Convert <strong>JPY</strong> to <strong>USD</strong> to get 24.0 <strong>USD</strong>.</li>
		<li>Convert <strong>USD</strong> to <strong>CHF</strong> to get 120.0 <strong>CHF</strong>.</li>
		<li>Finally, convert <strong>CHF</strong> to <strong>EUR</strong> to get 720.0 <strong>EUR</strong>.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">initialCurrency = &quot;NGN&quot;, pairs1 = </span>[[&quot;NGN&quot;,&quot;EUR&quot;]]<span class="example-io">, rates1 = </span>[9.0]<span class="example-io">, pairs2 = </span>[[&quot;NGN&quot;,&quot;EUR&quot;]]<span class="example-io">, rates2 = </span>[6.0]</p>

<p><strong>Output:</strong> 1.50000</p>

<p><strong>Explanation:</strong></p>

<p>Converting <strong>NGN</strong> to <strong>EUR</strong> on day 1 and <strong>EUR</strong> to <strong>NGN</strong> using the inverse rate on day 2 gives the maximum amount.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">initialCurrency = &quot;USD&quot;, pairs1 = [[&quot;USD&quot;,&quot;EUR&quot;]], rates1 = [1.0], pairs2 = [[&quot;EUR&quot;,&quot;JPY&quot;]], rates2 = [10.0]</span></p>

<p><strong>Output:</strong> <span class="example-io">1.00000</span></p>

<p><strong>Explanation:</strong></p>

<p>In this example, there is no need to make any conversions on either day.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= initialCurrency.length &lt;= 3</code></li>
	<li><code>initialCurrency</code> consists only of uppercase English letters.</li>
	<li><code>1 &lt;= n == pairs1.length &lt;= 10</code></li>
	<li><code>1 &lt;= m == pairs2.length &lt;= 10</code></li>
	<li><code>pairs1[i] == [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code><!-- notionvc: c31b5bb8-4df6-4987-9bcd-6dff8a5f7cd4 --></li>
	<li><code>pairs2[i] == [startCurrency<sub>i</sub>, targetCurrency<sub>i</sub>]</code><!--{C}%3C!%2D%2D%20notionvc%3A%20c31b5bb8-4df6-4987-9bcd-6dff8a5f7cd4%20%2D%2D%3E--></li>
	<li><code>1 &lt;= startCurrency<sub>i</sub>.length, targetCurrency<sub>i</sub>.length &lt;= 3</code></li>
	<li><code>startCurrency<sub>i</sub></code> and <code>targetCurrency<sub>i</sub></code> consist only of uppercase English letters.</li>
	<li><code>rates1.length == n</code></li>
	<li><code>rates2.length == m</code></li>
	<li><code>1.0 &lt;= rates1[i], rates2[i] &lt;= 10.0</code></li>
	<li>The input is generated such that there are no contradictions or cycles in the conversion graphs for either day.</li>
	<li>The input is generated such that the output is <strong>at most</strong> <code>5 * 10<sup>10</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i/description" target="_blank" rel="noopener noreferrer">Maximize the Number of Target Nodes After Connecting Trees I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exist two <strong>undirected </strong>trees with <code>n</code> and <code>m</code> nodes, with <strong>distinct</strong> labels in ranges <code>[0, n - 1]</code> and <code>[0, m - 1]</code>, respectively.</p>

<p>You are given two 2D integer arrays <code>edges1</code> and <code>edges2</code> of lengths <code>n - 1</code> and <code>m - 1</code>, respectively, where <code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the first tree and <code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the second tree. You are also given an integer <code>k</code>.</p>

<p>Node <code>u</code> is <strong>target</strong> to node <code>v</code> if the number of edges on the path from <code>u</code> to <code>v</code> is less than or equal to <code>k</code>. <strong>Note</strong> that a node is <em>always</em> <strong>target</strong> to itself.</p>

<p>Return an array of <code>n</code> integers <code>answer</code>, where <code>answer[i]</code> is the <strong>maximum</strong> possible number of nodes <strong>target</strong> to node <code>i</code> of the first tree if you have to connect one node from the first tree to another node in the second tree.</p>

<p><strong>Note</strong> that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[9,7,9,8,8]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>For <code>i = 0</code>, connect node 0 from the first tree to node 0 from the second tree.</li>
	<li>For <code>i = 1</code>, connect node 1 from the first tree to node 0 from the second tree.</li>
	<li>For <code>i = 2</code>, connect node 2 from the first tree to node 4 from the second tree.</li>
	<li>For <code>i = 3</code>, connect node 3 from the first tree to node 4 from the second tree.</li>
	<li>For <code>i = 4</code>, connect node 4 from the first tree to node 4 from the second tree.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3982-1.png" style="width: 600px; height: 169px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">[6,3,3,3,3]</span></p>

<p><strong>Explanation:</strong></p>

<p>For every <code>i</code>, connect node <code>i</code> of the first tree with any node of the second tree.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3928-2.png" style="height: 281px; width: 500px;" /></div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n, m &lt;= 1000</code></li>
	<li><code>edges1.length == n - 1</code></li>
	<li><code>edges2.length == m - 1</code></li>
	<li><code>edges1[i].length == edges2[i].length == 2</code></li>
	<li><code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; m</code></li>
	<li>The input is generated such that <code>edges1</code> and <code>edges2</code> represent valid trees.</li>
	<li><code>0 &lt;= k &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-depth-first-search">Approach: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem statement, for the <span class="math inline">\(i\)</span>-th query, when we connect the <span class="math inline">\(i\)</span>-th node of the first tree to a node <span class="math inline">\(j\)</span> of the second tree, the distances from node <span class="math inline">\(i\)</span> to nodes in the second tree decrease, so more target nodes become reachable.</p>
<p>We must therefore compute:</p>
<ul>
<li><span class="math inline">\(\textit{count}_1[i]\)</span>: the number of nodes in the <strong>first</strong> tree within distance <span class="math inline">\(\le k\)</span> of node <span class="math inline">\(i\)</span>;</li>
<li><span class="math inline">\(\textit{count}_2[j]\)</span>: the number of nodes in the <strong>second</strong> tree within distance <span class="math inline">\(\le k-1\)</span> of node <span class="math inline">\(j\)</span>.</li>
</ul>
<p>Because <span class="math inline">\(\textit{count}_2[j]\)</span> does not depend on the specific query, we can pre-compute it with a depth-first search (DFS) on the second tree. Afterward, we take the maximum value over all <span class="math inline">\(j\)</span>, denoted <span class="math inline">\(\textit{maxCount}_2 = \max_j \textit{count}_2[j]\)</span>.</p>
<p>For each query <span class="math inline">\(i\)</span>, we run a DFS on the first tree to obtain <span class="math inline">\(\textit{count}_1[i]\)</span> and then return</p>
<p><span class="math display">\[\textit{count}_1[i] + \textit{maxCount}_2
\]</span></p>
<p>as the answer.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JsYZMG3p/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the numbers of nodes in the undirected trees defined by <span class="math inline">\(\textit{edges}_1\)</span> and <span class="math inline">\(\textit{edges}_2\)</span>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + m^2)\)</span>.</p>
<p>We run a depth-first search (DFS) starting from every node in each tree, and each DFS visits all nodes of its tree.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span>.</p>
<p>We use two auxiliary arrays - one for each tree.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii/description" target="_blank" rel="noopener noreferrer">Maximize the Number of Target Nodes After Connecting Trees II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exist two <strong>undirected </strong>trees with <code>n</code> and <code>m</code> nodes, labeled from <code>[0, n - 1]</code> and <code>[0, m - 1]</code>, respectively.</p>

<p>You are given two 2D integer arrays <code>edges1</code> and <code>edges2</code> of lengths <code>n - 1</code> and <code>m - 1</code>, respectively, where <code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the first tree and <code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the second tree.</p>

<p>Node <code>u</code> is <strong>target</strong> to node <code>v</code> if the number of edges on the path from <code>u</code> to <code>v</code> is even.&nbsp;<strong>Note</strong> that a node is <em>always</em> <strong>target</strong> to itself.</p>

<p>Return an array of <code>n</code> integers <code>answer</code>, where <code>answer[i]</code> is the <strong>maximum</strong> possible number of nodes that are <strong>target</strong> to node <code>i</code> of the first tree if you had to connect one node from the first tree to another node in the second tree.</p>

<p><strong>Note</strong> that queries are independent from each other. That is, for every query you will remove the added edge before proceeding to the next query.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[8,7,7,8,8]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>For <code>i = 0</code>, connect node 0 from the first tree to node 0 from the second tree.</li>
	<li>For <code>i = 1</code>, connect node 1 from the first tree to node 4 from the second tree.</li>
	<li>For <code>i = 2</code>, connect node 2 from the first tree to node 7 from the second tree.</li>
	<li>For <code>i = 3</code>, connect node 3 from the first tree to node 0 from the second tree.</li>
	<li>For <code>i = 4</code>, connect node 4 from the first tree to node 4 from the second tree.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3982-1.png" style="width: 600px; height: 169px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,6,6,6,6]</span></p>

<p><strong>Explanation:</strong></p>

<p>For every <code>i</code>, connect node <code>i</code> of the first tree with any node of the second tree.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/09/24/3928-2.png" style="height: 281px; width: 500px;" /></div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>edges1.length == n - 1</code></li>
	<li><code>edges2.length == m - 1</code></li>
	<li><code>edges1[i].length == edges2[i].length == 2</code></li>
	<li><code>edges1[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>edges2[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; m</code></li>
	<li>The input is generated such that <code>edges1</code> and <code>edges2</code> represent valid trees.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-depth-first-search">Approach: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>For the <span class="math inline">\(i\)</span>-th query, after joining the two trees, the answer has two parts:</p>
<ol>
<li>The number of nodes in the first tree that are an even distance from node <span class="math inline">\(i\)</span>.</li>
<li>The number of nodes in the second tree that are an even distance from node <span class="math inline">\(i\)</span>.</li>
</ol>
<p>Suppose a tree contains <span class="math inline">\(\textit{count}\)</span> &quot;target&quot; nodes for node <span class="math inline">\(u\)</span>, and node <span class="math inline">\(v\)</span> itself is a target of <span class="math inline">\(u\)</span>. Then node <span class="math inline">\(v\)</span> also has exactly <span class="math inline">\(\textit{count}\)</span> target nodes.</p>
<p>To retrieve these counts quickly, we first color each tree with depth-first search: assign the root color 0 (white); every node at an even distance from the root also gets color 0, and every node at an odd distance gets color 1 (black). We record the total number of white and black nodes. For any node, the number of its target nodes equals the number of nodes that share its color.</p>
<p>This yields two arrays, <span class="math inline">\(\textit{color}_1\)</span> and <span class="math inline">\(\textit{color}_2\)</span>, storing the colors of the nodes in the two trees, along with the counts of white and black nodes in each tree. Then, for the <span class="math inline">\(i\)</span>-th query:</p>
<ol>
<li>Look up <span class="math inline">\(\textit{color}_1[i]\)</span>; the count of nodes with that color in the first tree gives the first part of the answer.</li>
<li>Regardless of how the trees are connected, node <span class="math inline">\(i\)</span> &quot;sees&quot; only one color in the second tree, so the second part is simply <span class="math inline">\(\max(\text{white}_2,\ \text{black}_2)\)</span>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/gypTT525/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the numbers of nodes in the undirected trees represented by <span class="math inline">\(\textit{edges}_1\)</span> and <span class="math inline">\(\textit{edges}_2\)</span>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Coloring all nodes in both trees takes <span class="math inline">\(O(n + m)\)</span> time, and each query can then be answered in <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Two arrays are required to store the colors of the nodes in each tree.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-candies-you-can-get-from-boxes/description" target="_blank" rel="noopener noreferrer">Maximum Candies You Can Get from Boxes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> boxes labeled from <code>0</code> to <code>n - 1</code>. You are given four arrays: <code>status</code>, <code>candies</code>, <code>keys</code>, and <code>containedBoxes</code> where:</p>

<ul>
	<li><code>status[i]</code> is <code>1</code> if the <code>i<sup>th</sup></code> box is open and <code>0</code> if the <code>i<sup>th</sup></code> box is closed,</li>
	<li><code>candies[i]</code> is the number of candies in the <code>i<sup>th</sup></code> box,</li>
	<li><code>keys[i]</code> is a list of the labels of the boxes you can open after opening the <code>i<sup>th</sup></code> box.</li>
	<li><code>containedBoxes[i]</code> is a list of the boxes you found inside the <code>i<sup>th</sup></code> box.</li>
</ul>

<p>You are given an integer array <code>initialBoxes</code> that contains the labels of the boxes you initially have. You can take all the candies in <strong>any open box</strong> and you can use the keys in it to open new boxes and you also can use the boxes you find in it.</p>

<p>Return <em>the maximum number of candies you can get following the rules above</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
<strong>Output:</strong> 16
<strong>Explanation:</strong> You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.
Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.
In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.
Total number of candies collected = 7 + 4 + 5 = 16 candy.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
<strong>Output:</strong> 6
<strong>Explanation:</strong> You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.
The total number of candies will be 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == status.length == candies.length == keys.length == containedBoxes.length</code></li>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>status[i]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= candies[i] &lt;= 1000</code></li>
	<li><code>0 &lt;= keys[i].length &lt;= n</code></li>
	<li><code>0 &lt;= keys[i][j] &lt; n</code></li>
	<li>All values of <code>keys[i]</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt;= containedBoxes[i].length &lt;= n</code></li>
	<li><code>0 &lt;= containedBoxes[i][j] &lt; n</code></li>
	<li>All values of <code>containedBoxes[i]</code> are unique.</li>
	<li>Each box is contained in one box at most.</li>
	<li><code>0 &lt;= initialBoxes.length &lt;= n</code></li>
	<li><code>0 &lt;= initialBoxes[i] &lt; n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-breadth-first-search">Approach: Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can solve this problem using <strong>breadth-first search</strong> combined with a <strong>queue</strong>.</p>
<p>For the <span class="math inline">\(\textit{i}\)</span>-th box, we can only obtain the candies inside if we own the box (either from the beginning or from some other box) and can open it (either it is already open from the beginning or we have obtained the key to it). We use the array <span class="math inline">\(\text{hasBox}\)</span> to indicate whether each box is owned, and the array <span class="math inline">\(\text{canOpen}\)</span> to indicate whether each box can be opened. Before the search begins, we only have the boxes listed in the array <span class="math inline">\(\textit{initialBoxes}\)</span>, and can open those boxes corresponding to <span class="math inline">\(\textit{status}\)</span> array values of <span class="math inline">\(\textit{1}\)</span>. Any box that meets these two conditions before the search starts is placed into the queue.</p>
<p>During the breadth-first search, in each iteration, we take the box at the front of the queue, <span class="math inline">\(\textit{k}\)</span>, open it, and obtain the candies inside, the boxes in <span class="math inline">\(\textit{containedBoxes}[\textit{k}]\)</span>, and the keys in <span class="math inline">\(\textit{keys}[\textit{k}]\)</span>. We add the candies to the answer and then iterate over each box and each key. When enumerating boxes, if a box can be opened, we add it to the end of the queue; similarly, when enumerating keys, if the corresponding box is already owned, we add that box to the end of the queue. When the queue is empty, the search ends, and we have obtained the maximum number of candies possible.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JTrKBp4c/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The problem does not guarantee that each key appears no more than once across all boxes. While each list of keys is unique per box, the same key can appear in multiple boxes. Similarly, boxes in <code>containedBoxes</code> can also repeat. Therefore, during the breadth-first search, we may process up to <span class="math inline">\(O(n^2)\)</span> total keys and contained boxes, resulting in a worst-case time complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We need to use several arrays and queues, each of length <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-connected-group/1" target="_blank" rel="noopener noreferrer">Maximum Connected group</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a square&nbsp;binary grid. A grid is considered binary if every value in the grid is either&nbsp;<strong>1 or 0.&nbsp;</strong></span><span style="font-size: 18px;">You can change&nbsp;<strong>at most one</strong>&nbsp;cell in the grid from&nbsp;<strong>0 to 1</strong>.&nbsp;</span><span style="font-size: 18px;">You need to find the largest group of connected&nbsp;&nbsp;<strong>1's</strong>.&nbsp;</span><span style="font-size: 18px;">Two cells are said to be connected if both are&nbsp;<strong>adjacent</strong>(top, bottom, left, right)&nbsp;to each other and both have the same value.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">grid = [1, 1]
             [0, 1]
<strong>Output</strong>: 4
<strong>Explanation</strong>: By changing cell (2,1), we can obtain a connected group of 4 1's
[1, 1]
[<strong>1,</strong> 1]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: grid = [1, 0, 1]<br /></span><span style="font-size: 18px;">             [1, 0, 1]
             [1, 0, 1]
<strong>Output</strong>: 7
<strong>Explanation</strong>: By changing cell (3,2), we can obtain a connected group of 7 1's
[1, 0, 1]<br />[1, 0, 1]
[1, <strong>1,</strong> 1]</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity</strong>: O(n<sup>2</sup>)<br /><strong>Expected Auxiliary Space</strong>: O(</span><span style="font-size: 18px;">n</span><sup>2</sup><span style="font-size: 18px;">)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints</strong>:<br />1 &lt;= size of the grid&lt;= 500<br />0 &lt;= grid[i][j] &lt;= 1<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-depth-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Depth of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>

<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" style="width: 400px; height: 277px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-depth-of-n-ary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Depth of N-ary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a n-ary tree, find its maximum depth.</p>

<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" style="width: 100%; max-width: 300px;" /></p>

<pre>
<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" style="width: 296px; height: 241px;" /></p>

<pre>
<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The total number of nodes is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Level Sum of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, the level of its root is <code>1</code>, the level of its children is <code>2</code>, and so on.</p>

<p>Return the <strong>smallest</strong> level <code>x</code> such that the sum of all the values of nodes at level <code>x</code> is <strong>maximal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/03/capture.JPG" style="width: 200px; height: 175px;" />
<pre>
<strong>Input:</strong> root = [1,7,0,7,-8,null,null]
<strong>Output:</strong> 2
<strong>Explanation: </strong>
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [989,null,10250,98693,-89388,null,null,null,-32127]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the <code>root</code> of a binary tree.</p>
<p>Our task is to return the smallest level <code>x</code> such that the sum of all the values of nodes at level <code>x</code> is maximal.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The task is to compute the sum of all node values at each level to get the smallest level with the maximum sum.</p>
<p>We can simply use a standard breadth-first search traversal because we need to analyze nodes by level.</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>). BFS is implemented with a queue.</p>
<p>Here is an example with the steps:</p>
<p><img src="../Figures/1161/1161-bfs1.png" alt="img" /></p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">LeetCode Explore Card</a>.</p>
<p>We initialize a queue of integers and an integer <code>level = 0</code> to track the current level. In the queue, we push the <code>root</code> node.</p>
<p>We perform a level-wise traversal, incrementing <code>level</code> by <code>1</code> each time when we move to a new level. At each iteration, we remove all nodes at <code>level</code>, compute the sum of all node values at this level, and insert all their neighbouring nodes at <code>level + 1</code>.</p>
<p>Because we are popping all of the nodes at <code>level</code> and inserting all of the nodes at <code>level + 1</code>, the size of the queue will represent the number of nodes at the next level at the end of this iteration.</p>
<p>So we have two loops: the outer loop runs until the queue is empty, and the inner loop runs the number of times equal to the size of the queue to just cover the nodes at the current level. We will pop all the nodes at <code>level</code>, compute the sum of all the values, and insert all the nodes at <code>level + 1</code> into the queue.</p>
<p>Here is a visual representation of how we will iterate using the loops:</p>
<p><img src="../Figures/1161/1161-bfs2.png" alt="img" /></p>
<p>To get the answer, we compare the sum of all node values at the current level to the maximum sum of values we've already seen. If the current sum of node values is greater than what we've seen before, we update our answer to <code>level</code>, and the current sum becomes our largest sum of values seen thus far. Since we are traversing the higher levels first, by only updating the answer when the level sum is <strong>greater</strong> than what we've seen before, we handle the tiebreakers automatically.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>maxSum</code> to keep track of the maximum sum of node values at any level. We start with a large negative value.</li>
<li>Create another variable <code>ans</code> to store the answer to the problem.</li>
<li>Create another integer variable <code>level</code> to store the current level through which we are iterating. We initialize it with <code>0</code>.</li>
<li>Initialize a queue <code>q</code> of <code>TreeNode</code> and push <code>root</code> into it.</li>
<li>Perform a BFS traversal until the queue is empty:
<ul>
<li>Increment <code>level</code> by <code>1</code> and initialize <code>sumAtCurrentLevel = 0</code> to compute the sum of all values of nodes at this level.</li>
<li>Iterate through all the nodes at <code>level</code> using only the <code>q.size()</code> number of nodes. Within this inner loop, pop out all the nodes at the current level one by one, adding their values to <code>sumAtCurrentLevel</code> and pushing the left and right children (if they exist) into the queue.</li>
<li>Realize that after traversing all of the nodes at <code>level</code>, the queue only has nodes at <code>level + 1</code>.</li>
<li>After traversing through all the nodes at <code>level</code>, we check if <code>sumAtCurrentLevel</code> is greater than <code>maxSum</code>. If <code>maxSum &lt; sumAtCurrentLevel</code>, update our answer variable to <code>ans = level</code> and set <code>maxSum = sumAtCurrentLevel</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LvBJUd6F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes in the given binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can only be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes.</li>
<li>The computation of sum of all the values of nodes at a level also takes <span class="math inline">\(O(n)\)</span> time as each node's value is used once.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>As the BFS queue stores the nodes in level-wise manner, the maximum number of nodes in the BFS queue would equal to the most number of nodes at any level. So, the best case would be <span class="math inline">\(O(1)\)</span> where all the levels have just one node.</li>
<li>The worst case would be a complete binary tree. In a complete binary tree, the last or second last level would have the most nodes (the last level can have multiple null nodes). Because we are iterating by level, the BFS queue will be most crowded when all of the nodes from the last level (or second last level) are in the queue. Assume we have a complete binary tree with height <span class="math inline">\(h\)</span> and a fully filled last level having <span class="math inline">\(2^h\)</span> nodes. All the nodes at each level add up to <span class="math inline">\(1 + 2 + 4 + 8 +... + 2^h = n\)</span>. This implies that <span class="math inline">\(2^{h + 1} - 1 = n\)</span>, and thus <span class="math inline">\(2^h = (n + 1) / 2\)</span>. Because the last level <span class="math inline">\(h\)</span> has <span class="math inline">\(2^h\)</span> nodes, the BFS queue will have <span class="math inline">\((n + 1) / 2 = O(n)\)</span> elements in the worst-case scenario.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also use another traversal method, depth-first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p><img src="../Figures/547/547-dfs.png" alt="img" /></p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
<p>Because our task is to compute the sum of all the values of nodes at each level, we can perform a DFS traversal and pass the level of each node as an extra parameter.</p>
<p>We can initialize a list of integers <code>sumOfNodesAtLevel</code>, where <code>sumOfNodesAtLevel[i]</code> stores the sum of all the values of nodes at level <code>i</code>. Whenever we visit a node at a level, say <code>l</code>, we increment the index <code>l</code> in the list by the value of the current node. According to the problem definition, the levels should begin with <code>1</code>, but to keep the list as <code>0-indexed</code>, we will begin with level <code>0</code> (the root's level) and increment our answer by <code>1</code> at the end.</p>
<p>The question that may arise is how long this list should be.</p>
<p>We know that in a DFS traversal, we either move down the tree (until we can) to a node at the next level or we backtrack to a node at a lower level. As we descend the tree, if we come across a level <code>l</code> we haven't seen before, we add the node's value to <code>sumOfNodesAtLevel</code>, which places the entry at index <code>l</code> itself. This is due to the fact that all levels from <code>0</code> to <code>l - 1</code> must have already been seen and have corresponding values in <code>sumOfNodesAtLevel</code>.</p>
<p>So, if the size of <code>sumOfNodesAtLevel</code> equals <code>l</code>, it means we've seen nodes from levels <code>0</code> to <code>l - 1</code> but not any nodes at level <code>l</code> yet. At level <code>l</code>, this is the first node we see.</p>
<p>If the level <code>l</code> is smaller than the size of <code>sumOfNodesAtLevel</code>, it means we've seen some nodes at this level before, and we simply increment <code>sumOfNodesAtLevel[l]</code> by the value of the current node.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a list of integers <code>sumOfNodesAtLevel</code> to store the sum of all the values of nodes at a level. The value <code>sumOfNodesAtLevel[i]</code> stores the sum of all the values of nodes at level <code>i</code> (0-indexed). We would start our levels from <code>0</code> to keep the array <code>0-indexed</code> and finally increment our answer by <code>1</code> to align with the problem definition of the level (levels begin with <code>1</code> as stated in the problem).</li>
<li>Perform the DFS traversal over the given binary tree. We call <code>dfs(root, 0, sumOfNodesAtLevel)</code> where <code>dfs</code> is a recursive method that takes three parameters: <code>TreeNode node</code> from which the traversal begins, the level of <code>node</code>, and <code>sumOfNodesAtLevel</code>. We perform the following in this method:
<ul>
<li>If <code>node</code> is <code>null</code>, return.</li>
<li>If the size of <code>sumOfNodesAtLevel</code> equals <code>level</code>, we haven't encountered any nodes at this level. Hence, we insert <code>node.val</code> in <code>sumOfNodesAtLevel</code>. Otherwise, if we've seen this level before, we simply perform <code>sumOfNodesAtLevel[level] += node.val</code> to add <code>node.val</code> to the corresponding <code>level</code>.</li>
<li>Recursively perform DFS from <code>node.left</code>.</li>
<li>Recursively perform DFS from <code>node.right</code>.</li>
</ul>
</li>
<li>Create a variable <code>maxSum</code> to keep track of the maximum sum of node values at any level. We start with a large negative value.</li>
<li>Create another variable <code>ans</code> to store the answer to the problem.</li>
<li>Iterate over the sum of nodes of all the levels, i.e., iterate over <code>sumOfNodesAtLevel</code> and perform the following:
<ul>
<li>If <code>maxSum &lt; sumOfNodesAtLevel[i]</code>, we set <code>maxSum = sumOfNodesAtLevel[i]</code> and update <code>ans</code> to the level <code>i + 1</code> (<code>+1</code> is added to align with the definition of level).</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YxvJa36T/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes in the given binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We traverse once over each node of the tree using DFS traversal which takes <span class="math inline">\(O(n)\)</span> time. We also take <span class="math inline">\(O(1)\)</span> time to add a node's value into <code>sumOfNodesAtLevel</code> for each node, which takes <span class="math inline">\(O(n)\)</span> time for <span class="math inline">\(n\)</span> nodes.</li>
<li>The size of <code>sumOfNodesAtLevel</code> is equal to the height of tree. We iterate over all the values in <code>sumOfNodesAtLevel</code> to get the level with maximum sum of node values. In the worst-case scenario, when the tree is a straight line, the height would be <span class="math inline">\(O(n)\)</span>, requiring <span class="math inline">\(O(n)\)</span> time to iterate over <code>sumOfNodesAtLevel</code>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The DFS traversal is recursive and would take some space to store the stack calls. The maximum number of active stack calls at a time would be the tree's height, which in the worst case would be <span class="math inline">\(O(n)\)</span> when the tree is a straight line.</li>
<li>The <code>sumOfNodesAtLevel</code> would also take linear space in the worst case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-fish-in-a-grid/description" target="_blank" rel="noopener noreferrer">Maximum Number of Fish in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>m x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A <strong>land</strong> cell if <code>grid[r][c] = 0</code>, or</li>
	<li>A <strong>water</strong> cell containing <code>grid[r][c]</code> fish, if <code>grid[r][c] &gt; 0</code>.</li>
</ul>

<p>A fisher can start at any <strong>water</strong> cell <code>(r, c)</code> and can do the following operations any number of times:</p>

<ul>
	<li>Catch all the fish at cell <code>(r, c)</code>, or</li>
	<li>Move to any adjacent <strong>water</strong> cell.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or </em><code>0</code> if no water cell exists.</p>

<p>An <strong>adjacent</strong> cell of the cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> or <code>(r - 1, c)</code> if it exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/29/example.png" style="width: 241px; height: 161px;" />
<pre>
<strong>Input:</strong> grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The fisher can start at cell <code>(1,3)</code> and collect 3 fish, then move to cell <code>(2,3)</code>&nbsp;and collect 4 fish.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/29/example2.png" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <code>grid</code> of size <code>m x n</code>, where each cell <code>(r, c)</code> can either be land or water. The grid is represented by an integer matrix where:</p>
<ul>
<li>A land cell is denoted by <code>0</code>.</li>
<li>A water cell contains a number of fish, indicated by a value greater than <code>0</code>.</li>
</ul>
<p>We need to find the largest number of fish that a fisher can collect by starting at an optimal water cell and moving to connected water cells. The fisher can collect fish from any water cell they start from, and then they can move to any adjacent water cell to continue collecting more fish. The fisher can repeat this operation as many times as needed, moving between connected water cells to collect fish.</p>
<p>This problem is closely related to the &quot;<a href="https://leetcode.com/problems/max-area-of-island/description/">Max Area of Island</a>&quot; problem, which also deals with connected regions in a grid. However, the key difference here is that in this problem, the value in each water cell is not simply <code>1</code>, but rather the number of fish in that cell, which adds an extra layer of complexity.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can think of the grid as a map of a graph, where each water cell is a node connected to other water cells around it, either up, down, left, or right. The water cells are grouped together, forming distinct regions that are separated by land cells. The goal is to find the largest group of connected water cells, which represents the region with the most fish.</p>
<p>To solve this, we can use a <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">Depth-First Search (DFS)</a>. DFS works by exploring every connected node (in this case, the water cells) starting from a given cell. When we find a water cell, we start a DFS from that cell. The DFS will look at all neighboring water cells (in all four directions), marking them as visited to ensure we don’t count them again.</p>
<p>As we traverse each connected water region, we also keep a running total of the number of fish in that region. This means that for every new DFS call, we add up all the fish in that group of connected cells.</p>
<p>After exploring all the water cells in one region, we move on to the next unvisited water cell and repeat the process. While doing this, we always track the greatest number of fish encountered in any of the regions. By the time we finish going through the whole grid, we will have found the region with the most fish and that will be our result.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ol>
<li>Initialize <code>m</code> and <code>n</code> to represent the number of rows and columns in <code>grid</code>.</li>
<li>Create a 2D vector <code>visited</code> of size <code>m x n</code> to track visited cells, initialized to <code>false</code>.</li>
<li>Initialize <code>result</code> to <code>0</code>, which will store the maximum fish count from any connected component.</li>
<li>Iterate through each cell <code>(i, j)</code> in the grid:
<ul>
<li>If the cell is a water cell (<code>grid[i][j] &gt; 0</code>) and has not been visited, call <code>countFishes(grid, visited, i, j)</code> to calculate the total fish in the connected component starting from <code>(i, j)</code>.</li>
<li>Update <code>result</code> to the maximum of <code>result</code> and the fish count returned by <code>countFishes</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ol>
<p>Helper Function: <code>countFishes(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int r, int c)</code></p>
<ol>
<li>If the current cell <code>(r, c)</code>, is out of bounds, is a land cell (<code>grid[r][c] == 0</code>), or, has already been visited (<code>visited[r][c] == true</code>), return <code>0</code>.</li>
<li>Mark the current cell <code>(r, c)</code> as visited by setting <code>visited[r][c] = true</code>.</li>
<li>Recursively calculate the total fish count from all connected water cells:
<ul>
<li>Call <code>countFishes</code> for the cells to the right, left, bottom, and top.</li>
</ul>
</li>
<li>Return the sum of fish in the current cell (<code>grid[r][c]</code>) and the fish counts from all valid neighboring cells.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VHJhrpCk/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>In the worst case, where the <code>grid</code> is completely filled with water cells, the algorithm iterates through all <code>m x n</code> cells. For each cell, it performs a depth-first search (DFS) to calculate the total fish in the connected region. Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm uses a <code>visited</code> matrix of size <code>m x n</code> to track visited cells. Additionally, the depth-first search (DFS) can recurse to explore all connected cells, contributing to the space complexity. Hence, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Similar to Depth-First Search (DFS), we can also use a <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Breadth-First Search (BFS)</a> to explore the grid and find the connected water regions. BFS works by exploring all neighboring cells at the present depth level before moving on to cells at the next level. This means that BFS explores level by level, starting from a water cell and expanding outward to its neighboring water cells.</p>
<p>We start by iterating through the grid and whenever we encounter a water cell that hasn't been visited yet, we initiate a BFS. From that cell, we explore its four neighboring cells (up, down, left, right), checking if they are also water cells and marking them as visited. This continues until all water cells in the current region have been explored.</p>
<p>While performing the BFS, we accumulate the number of fish in the connected region by adding up the values of all the visited water cells. This ensures that we get the total number of fish in that region.</p>
<p>After exploring all neighboring water cells in the current region, we move on to the next unvisited water cell and repeat the BFS process. Throughout the BFS traversal, we keep track of the largest fish count encountered. By the end of the grid traversal, we will have identified the connected water region with the most fish and return that as our result.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li><code>numRows</code> and <code>numCols</code> to represent the number of rows and columns in <code>grid</code>.</li>
<li><code>result</code> to store the maximum fish count found in any connected component. Initialized to <code>0</code>.</li>
<li><code>visited</code> as a 2D matrix of size <code>numRows x numCols</code> to track visited cells, initialized to <code>false</code>.</li>
</ul>
</li>
<li>
<p>Iterate through the Grid:</p>
<ul>
<li>For each cell <code>(i, j)</code> in the grid:
<ul>
<li>If the cell contains water (<code>grid[i][j] &gt; 0</code>) and has not been visited, call <code>countFishes(grid, visited, i, j)</code> to calculate the total fish in the connected component starting from <code>(i, j)</code>.</li>
<li>Update <code>result</code> to the maximum of <code>result</code> and the fish count returned by <code>countFishes</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return Result:</p>
<ul>
<li>After iterating through all cells, return the <code>result</code>.</li>
</ul>
</li>
</ol>
<p>Helper Function: <code>countFishes(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int row, int col)</code></p>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li><code>numRows</code> and <code>numCols</code> to represent the dimensions of the grid.</li>
<li><code>fishCount</code> to accumulate the number of fish in the connected component, initialized to <code>0</code>.</li>
<li><code>q</code> as a queue for BFS traversal starting from the initial cell <code>(row, col)</code>.</li>
</ul>
</li>
<li>
<p>BFS Traversal:</p>
<ul>
<li>Push the initial cell <code>(row, col)</code> onto the queue and mark it as visited.</li>
<li>While the queue is not empty:
<ul>
<li>Dequeue the front element to get current coordinates <code>(row, col)</code>.</li>
<li>Add the fish count from the current cell to <code>fishCount</code>.</li>
<li>Explore all four directions (up, down, left, right) for connected water cells:
<ul>
<li>If the neighboring cell is within bounds, contains water, and hasn't been visited, add it to the queue and mark it as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return Fish Count:</p>
<ul>
<li>After exploring all possible connected cells, return <code>fishCount</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/afuZyzJQ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>In the worst case, where the <code>grid</code> is completely filled with water cells, the algorithm iterates through all <code>m \cdot n</code> cells. For each cell, it performs a Breadth-first search (BFS) to calculate the total fish in the connected region. Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm uses a <code>visited</code> matrix of size <code>m \cdot n</code> to track visited cells. Hence, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find-algorithm">Approach 3: Union Find Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving problems based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a union-find data structure or merge-find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. More specifically, it allows us to perform two main operations:</p>
<ol>
<li><strong>Find</strong>: This operation helps us determine which set a particular element belongs to. In our case, it will help us check if two water cells are part of the same connected region.</li>
<li><strong>Union</strong>: This operation merges two sets into one. It allows us to combine two connected water cells into the same region.</li>
</ol>
<p>For this problem, we can think of each water cell as an individual set, and the goal is to merge them into larger sets based on their connectivity. As we perform the &quot;Union&quot; operation, we also need to keep track of the total number of fish in each connected component (group of connected water cells).</p>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">LeetCode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Our task, as with the previous approaches, is to count the maximum sum of fishes among all the connected components formed in the graph with water cells acting as nodes and an edge between directly connected cells.</p>
<p>First, we treat each water cell as its own separate component, initializing a structure to store the number of fish in each component. Initially, each water cell holds its own fish count.</p>
<p>We then iterate over all the cells in the grid. For each water cell, we check its four neighbors (up, down, left, right). If a neighboring cell is also water, we perform a &quot;Union&quot; operation to merge their components, effectively connecting the two cells. As we do this, we update the fish count for the newly merged component by adding the fish counts from both cells.</p>
<p>After merging the cells, we keep track of the maximum fish count encountered in any connected component. This can be done by maintaining a separate array (let's call it <code>fishes</code>) where each entry corresponds to the total fish count of a particular connected component.</p>
<p>At the end of this process, the largest value in the <code>totalFish</code> array will give us the largest sum of fish in any connected component.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ul>
<li>
<p>Initialize Variables:</p>
<ul>
<li>Determine the number of rows (<code>rows</code>) and columns (<code>cols</code>) in the grid.</li>
<li>Compute the total number of cells (<code>totalCells</code>) which is <code>rows * cols</code>.</li>
</ul>
</li>
<li>
<p>Union-Find Initialization:</p>
<ul>
<li>Create arrays <code>parent</code>, <code>componentSize</code>, and <code>totalFish</code>:
<ul>
<li><code>parent</code> keeps track of the root for each cell.</li>
<li><code>componentSize</code> tracks the size of the component (number of cells) each root represents.</li>
<li><code>totalFish</code> tracks the total fish count in the connected component represented by each root.</li>
</ul>
</li>
<li>Use <code>iota(parent.begin(), parent.end(), 0)</code> to initialize <code>parent</code> such that each cell is its own parent initially.</li>
</ul>
</li>
<li>
<p>Setting Initial Fish Count:</p>
<ul>
<li>Traverse the grid and populate the <code>totalFish</code> array with the fish count of each cell.</li>
</ul>
</li>
<li>
<p>Union Operation:</p>
<ul>
<li>Use direction vectors <code>dRow</code> and <code>dCol</code> to explore neighboring cells (right, left, down, up).</li>
<li>For each water cell (<code>grid[row][col] &gt; 0</code>), union its connected neighbors using the <code>unionComponents</code> function.</li>
</ul>
</li>
<li>
<p>After processing all cells and merging components, iterate through the <code>totalFish</code> array to find the maximum fish count among all components that have a unique root.</p>
</li>
<li>
<p>Return the maximum fish count found.</p>
</li>
</ul>
<p>Helper Function: <code>unionComponents(vector&lt;int&gt;&amp; parent, vector&lt;int&gt;&amp; componentSize, vector&lt;int&gt;&amp; totalFish, int x, int y)</code></p>
<ul>
<li>
<p>Find the root of <code>x</code>: Use <code>findParent</code> to get the root of component containing <code>x</code>.</p>
</li>
<li>
<p>Find the root of <code>y</code>: Use <code>findParent</code> to get the root of component containing <code>y</code>.</p>
</li>
<li>
<p>Union by size: If the roots are different, attach the smaller tree under the root of the larger tree, ensuring optimization.</p>
</li>
<li>
<p>Update Component Size and Fish Count: After merging, update the size of the new component and the total fish count accordingly.</p>
</li>
</ul>
<p>Helper Function: <code>findParent(vector&lt;int&gt;&amp; parent, int x)</code></p>
<ul>
<li>If <code>parent[x]</code> equals <code>x</code>, then <code>x</code> is its own root. Otherwise, recursively find the parent of <code>parent[x]</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/goJL6dcH/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n \cdot m) \cdot \alpha(n \cdot m))\)</span></p>
<p>The outer loop iterates over all cells in the grid, which takes <span class="math inline">\(O(n \cdot m)\)</span> time.</p>
<p>For each cell, the algorithm checks its four neighbors (right, left, down, up), which is a constant <span class="math inline">\(O(4)\)</span> operation.</p>
<p>The <code>findParent</code> and <code>unionComponents</code> operations are performed using the Union-Find data structure with path compression and union by size. These operations have an amortized time complexity of <span class="math inline">\(O(\alpha(n \cdot m))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function, which is very small and can be considered almost constant.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((n \cdot m) \cdot \alpha(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses three auxiliary arrays: <code>parent</code>, <code>componentSize</code>, and <code>totalFish</code>, each of size <span class="math inline">\(n \cdot m\)</span>.</p>
<p>The space required for these arrays is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>Additionally, the recursion stack for the <code>findParent</code> function is bounded by the height of the Union-Find tree, which is <span class="math inline">\(O(\alpha(n \cdot m))\)</span> due to path compression. However, this is negligible compared to the space used by the arrays.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-moves-to-kill-all-pawns/description" target="_blank" rel="noopener noreferrer">Maximum Number of Moves to Kill All Pawns</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <code>50 x 50</code> chessboard with <strong>one</strong> knight and some pawns on it. You are given two integers <code>kx</code> and <code>ky</code> where <code>(kx, ky)</code> denotes the position of the knight, and a 2D array <code>positions</code> where <code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> denotes the position of the pawns on the chessboard.</p>

<p>Alice and Bob play a <em>turn-based</em> game, where Alice goes first. In each player&#39;s turn:</p>

<ul>
	<li>The player <em>selects </em>a pawn that still exists on the board and captures it with the knight in the <strong>fewest</strong> possible <strong>moves</strong>. <strong>Note</strong> that the player can select <strong>any</strong> pawn, it <strong>might not</strong> be one that can be captured in the <strong>least</strong> number of moves.</li>
	<li><span>In the process of capturing the <em>selected</em> pawn, the knight <strong>may</strong> pass other pawns <strong>without</strong> capturing them</span>. <strong>Only</strong> the <em>selected</em> pawn can be captured in <em>this</em> turn.</li>
</ul>

<p>Alice is trying to <strong>maximize</strong> the <strong>sum</strong> of the number of moves made by <em>both</em> players until there are no more pawns on the board, whereas Bob tries to <strong>minimize</strong> them.</p>

<p>Return the <strong>maximum</strong> <em>total</em> number of moves made during the game that Alice can achieve, assuming both players play <strong>optimally</strong>.</p>

<p>Note that in one <strong>move, </strong>a chess knight has eight possible positions it can move to, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.</p>

<p><img src="https://assets.leetcode.com/uploads/2024/08/01/chess_knight.jpg" style="width: 275px; height: 273px;" /></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">kx = 1, ky = 1, positions = [[0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/16/gif3.gif" style="width: 275px; height: 275px;" /></p>

<p>The knight takes 4 moves to reach the pawn at <code>(0, 0)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">kx = 0, ky = 2, positions = [[1,1],[2,2],[3,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/08/16/gif4.gif" style="width: 320px; height: 320px;" /></strong></p>

<ul>
	<li>Alice picks the pawn at <code>(2, 2)</code> and captures it in two moves: <code>(0, 2) -&gt; (1, 4) -&gt; (2, 2)</code>.</li>
	<li>Bob picks the pawn at <code>(3, 3)</code> and captures it in two moves: <code>(2, 2) -&gt; (4, 1) -&gt; (3, 3)</code>.</li>
	<li>Alice picks the pawn at <code>(1, 1)</code> and captures it in four moves: <code>(3, 3) -&gt; (4, 1) -&gt; (2, 2) -&gt; (0, 3) -&gt; (1, 1)</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">kx = 0, ky = 0, positions = [[1,2],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Alice picks the pawn at <code>(2, 4)</code> and captures it in two moves: <code>(0, 0) -&gt; (1, 2) -&gt; (2, 4)</code>. Note that the pawn at <code>(1, 2)</code> is not captured.</li>
	<li>Bob picks the pawn at <code>(1, 2)</code> and captures it in one move: <code>(2, 4) -&gt; (1, 2)</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= kx, ky &lt;= 49</code></li>
	<li><code>1 &lt;= positions.length &lt;= 15</code></li>
	<li><code>positions[i].length == 2</code></li>
	<li><code>0 &lt;= positions[i][0], positions[i][1] &lt;= 49</code></li>
	<li>All <code>positions[i]</code> are unique.</li>
	<li>The input is generated such that <code>positions[i] != [kx, ky]</code> for all <code>0 &lt;= i &lt; positions.length</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-points-from-grid-queries/description" target="_blank" rel="noopener noreferrer">Maximum Number of Points From Grid Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an array <code>queries</code> of size <code>k</code>.</p>

<p>Find an array <code>answer</code> of size <code>k</code> such that for each integer <code>queries[i]</code> you start in the <strong>top left</strong> cell of the matrix and repeat the following process:</p>

<ul>
	<li>If <code>queries[i]</code> is <strong>strictly</strong> greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any <strong>adjacent</strong> cell in all <code>4</code> directions: up, down, left, and right.</li>
	<li>Otherwise, you do not get any points, and you end this process.</li>
</ul>

<p>After the process, <code>answer[i]</code> is the <strong>maximum</strong> number of points you can get. <strong>Note</strong> that for each query you are allowed to visit the same cell <strong>multiple</strong> times.</p>

<p>Return <em>the resulting array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/image1.png" style="width: 571px; height: 152px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
<strong>Output:</strong> [5,8,1]
<strong>Explanation:</strong> The diagrams above show which cells we visit to get points for each query.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png" />
<pre>
<strong>Input:</strong> grid = [[5,2,1],[1,1,2]], queries = [3]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> We can not get any points because the value of the top left cell is already greater than or equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>k == queries.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an <code>m x n</code> matrix <code>grid</code> and an array of queries, <code>queries</code>. For each query, we attempt to collect as many points as possible while following specific movement rules that dictate how far we can traverse the grid.</p>
<p>For each <code>queries[i]</code>, we begin at the top-left corner of the grid. We are allowed to move in four directions: up, down, left, and right. The primary condition governing movement is the comparison between <code>queries[i]</code> and the value of the current cell:</p>
<ol>
<li>
<p>If <code>queries[i]</code> is strictly greater than the value of the current cell, then:</p>
<ul>
<li>If this is the first time visiting the cell, we earn one point.</li>
<li>We can then move to any of the adjacent cells (if they exist).</li>
</ul>
</li>
<li>
<p>If <code>queries[i]</code> is less than or equal to the value of the current cell, then:</p>
<ul>
<li>We cannot proceed further from this cell.</li>
<li>The process for this query terminates immediately.</li>
</ul>
</li>
</ol>
<p>The final result for <code>queries[i]</code> is the number of unique cells we were able to collect points from.</p>
<blockquote>
<p>Note: Each query starts independently, meaning that the traversal for one query does not affect the traversal for another.</p>
</blockquote>
<p>Another difficult but extremely practical way to phrase this problem is to imagine you're at a buffet, where you can only eat dishes that are under a certain calorie count. Each dish represents a number in the grid, and your queries are your calorie limits. You want to know how many dishes you can indulge in without exceeding your limit. The algorithm helps you quickly determine how many dishes fit your criteria, allowing you to make the most of your buffet experience! Sometimes, the representation of data is more important than the data itself.</p>
<p>To solve this problem, we need a solid understanding of BFS, priority queues, and disjoint union. While we will explain the application of these concepts, we will not go in-depth into their theoretical aspects and their basic structure.</p>
<p>For a deeper understanding of the theory or to learn how the general conceptual implementation works, please check out the following explore cards:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS and Priority Queue</a></li>
<li><a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union Find</a></li>
<li><a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search</a></li>
</ul>
<hr />
<h3 id="approach-1-brute-force-tle">Approach 1: Brute Force (TLE)</h3>
<h4 id="intuition">Intuition</h4>
<p>For each query value, we need to determine how many cells in the grid have a value strictly less than the query while ensuring we only move to adjacent cells. This naturally forms a graph traversal problem where each cell is treated as a node connected to its adjacent cells. Since we are interested in finding all reachable nodes that satisfy a condition, Breadth-First Search (BFS) is a suitable choice. BFS explores all nodes at the current level before moving to the next, ensuring we do not miss any reachable cells that meet the criteria.</p>
<p>For each query, we begin at the <code>(0,0)</code> cell and initialize a queue for BFS traversal. We also maintain a <code>visited</code> boolean matrix to ensure we do not revisit cells. The traversal continues as long as there are unprocessed cells in the queue. At each step, we check if the current cell’s value is greater than or equal to the query value. If it is, we cannot proceed further from this cell. Otherwise, we count the cell as visited, increment our result, and attempt to move to its four adjacent cells (up, down, left, and right). Any adjacent cell that has not been visited and has a value strictly less than the query is added to the queue.</p>
<p>Since each query is independent, we repeat this process for each of them. The final result for each query is the total number of unique cells that we were able to visit while following the movement constraints.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Iterate over each query:</p>
<ul>
<li>
<p>Extract <code>queryValue</code> from <code>queries</code>.</p>
</li>
<li>
<p>Initialize a BFS queue starting from <code>(0,0)</code>.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track visited cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Initialize <code>points</code> to count valid cells.</p>
</li>
<li>
<p>Perform BFS:</p>
<ul>
<li>Get the current queue size to process all elements at this level.</li>
<li>Iterate over the queue:
<ul>
<li>Extract <code>currentRow</code> and <code>currentCol</code> from the front.</li>
<li>If <code>grid[currentRow][currentCol] &gt;= queryValue</code>, skip processing.</li>
<li>Otherwise, increment <code>points</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds, not visited, and value is <code>&lt; queryValue</code>, mark <code>(newRow, newCol)</code> as visited and add it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Store <code>points</code> in <code>result</code> at the corresponding query index.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jtezm3QA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \cdot n \cdot m)\)</span></p>
<p>The outer loop runs <span class="math inline">\(k\)</span> times, once for each query. In each iteration, a BFS is performed on the grid. In the worst case, the BFS will visit every cell in the grid, which is <span class="math inline">\(n \cdot m\)</span> cells. Therefore, the time complexity for each query is <span class="math inline">\(O(n \cdot m)\)</span>, and for all queries, it becomes <span class="math inline">\(O(k \cdot n \cdot m)\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor, which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by the <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>. This matrix is used to keep track of visited cells during the BFS traversal.</p>
<p>The BFS queue can also hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case (e.g., when all cells are part of the BFS traversal). Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting-queries--min-heap-expansion">Approach 2: Sorting Queries + Min-Heap Expansion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the brute force approach, we restart the search from the top-left corner for every query, treating each query as an independent problem. This results in a significant amount of redundant work because many queries share overlapping information. If a smaller query has already determined that certain cells are accessible, then a larger query should be able to reuse that information instead of starting from scratch. This suggests that instead of treating each query separately, we can process them in an order that allows us to build on previously discovered results, avoiding unnecessary recomputation.</p>
<p>A natural way to achieve this is to <strong>sort the queries in increasing order</strong> while keeping track of their original indices. By doing this, we ensure that when we process a query, all smaller queries have already been resolved. This allows us to maintain a growing region of accessible cells rather than restarting the search for each query.</p>
<p>To efficiently manage this expanding region, we use a <strong>min-heap (priority queue)</strong>. The heap allows us to always expand from the lowest-value cell first, ensuring that we process cells in the correct order. We begin by inserting the top-left cell <code>(grid[0][0], (0,0))</code> into the heap.</p>
<p>As long as the smallest cell in the heap has a value less than the current query, we remove it from the heap, mark it as visited, and attempt to expand outward by pushing all its unvisited neighbors into the heap. Since the heap maintains the smallest-value cell at the top, this ensures that we always expand the lowest-value region before moving to higher values. If the smallest cell's value is greater than or equal to the current query's value, we store the current count of reachable cells in the answer array and continue expanding with the next query's value as the new threshold.</p>
<p>By the time we process a query, all the cells that could have been visited with smaller query values have already been handled. This allows us to directly store the number of reachable cells without restarting the traversal. Instead of performing redundant BFS searches for each query, we maintain a continuous expansion process, ensuring that each cell is processed only once.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Create a <code>sortedQueries</code> array to store queries along with their original indices.</p>
</li>
<li>
<p>Sort <code>sortedQueries</code> by query values in ascending order.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) to expand cells in increasing order of <code>grid</code> values.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track processed cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Push <code>{grid[0][0], {0, 0}}</code> into <code>minHeap</code> to start expansion.</p>
</li>
<li>
<p>Initialize <code>totalPoints</code> to count valid cells.</p>
</li>
<li>
<p>Iterate over sorted queries:</p>
<ul>
<li>Extract <code>queryValue</code> and <code>queryIndex</code>.</li>
<li>Expand cells while <code>minHeap</code> contains values <code>&lt; queryValue</code>:
<ul>
<li>Pop the smallest <code>cellValue</code> and its position.</li>
<li>Increment <code>totalPoints</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds and not visited, push <code>{grid[newRow][newCol], {newRow, newCol}}</code> into <code>minHeap</code> and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
<li>Store <code>totalPoints</code> in <code>result</code> at the corresponding query index.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3F8Ff5Ud/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span></p>
<p>The algorithm first sorts the <code>k</code> queries, which takes <span class="math inline">\(O(k \log k)\)</span> time. Then, for each query, it processes cells using a min-heap. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed and pushed into the heap. Each heap operation (push or pop) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, processing all cells takes <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m + k)\)</span></p>
<p>The space complexity is dominated by:</p>
<ol>
<li>The <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The min-heap, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case.</li>
<li>The <code>sortedQueries</code> vector, which stores <code>k</code> pairs of values and indices.</li>
</ol>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m + k)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-priority-queue-with-binary-search">Approach 3: Using Priority Queue with Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, we processed queries sequentially and used a min-heap to expand the reachable region in increasing order, allowing us to efficiently determine the number of points collected for each query. In this approach, we will separate the precomputation step from the answer calculation to improve algorithmic clarity.</p>
<p>To implement this, we can preprocess the grid <strong>once</strong> and store the results in a structured way so that queries can be answered in constant or logarithmic time. The key insight is that every cell in the grid has a <strong>minimum value threshold</strong> that must be met in order for it to be reached. If we can determine the smallest query value required to reach each number of points, we can use <strong>binary search</strong> to efficiently answer all queries.</p>
<p>So we will begin by treating this as a shortest-path problem where we want to determine the minimum &quot;effort&quot; required to reach each cell. We can use <strong>Dijkstra’s algorithm</strong> with a min-heap to explore the grid in order of increasing cost. Each cell <code>(i, j)</code> is processed in order of its minimum required value, and we update its neighbors with the maximum value seen along the way. This ensures that we always determine the optimal way to reach a cell.</p>
<p>Thus, our approach will be divided into three key steps:</p>
<ol>
<li>Reformulating the Problem as a Shortest-Path Search</li>
<li>Running Dijkstra’s Algorithm</li>
<li>Answering Queries Using Binary Search</li>
</ol>
<h5 id="step-1-reformulating-the-problem-as-a-shortest-path-search"><strong>Step 1: Reformulating the Problem as a Shortest-Path Search</strong></h5>
<p>Instead of handling each query separately, we treat the grid as a <strong>weighted graph</strong> where each cell <code>(i, j)</code> has a weight equal to <code>grid[i][j]</code>. The goal is to expand outwards from <code>(0,0)</code>, adding cells in increasing order of their values. We need to determine <strong>the minimum effort required to reach each cell</strong>, which means that a Dijkstra-like algorithm is appropriate.</p>
<p>We use a min-heap (priority queue) to always expand the cell with the lowest current value. Each time we expand to a new cell, we record the maximum value encountered along that path. This ensures that we always determine the optimal way to reach a cell before processing its neighbors.</p>
<p>To keep track of how many points can be collected for any given query threshold, we maintain an array <code>thresholdForMaxPoints</code>, where <code>thresholdForMaxPoints[k]</code> stores the <strong>smallest query value</strong> required to collect <code>k</code> points.</p>
<h5 id="step-2-running-dijkstras-algorithm"><strong>Step 2: Running Dijkstra’s Algorithm</strong></h5>
<p>We begin by initializing a min-heap with the starting cell <code>(0,0)</code>, assigning it a value equal to <code>grid[0][0]</code>. This heap will allow us to always expand towards the next reachable cell with the smallest value, ensuring that we process cells in the correct order.</p>
<p>As we expand outward, we repeatedly extract the smallest value from the heap, which represents the next cell to be processed. From there, we attempt to move to the neighboring cells, as long as they are not already visited— this guarantees that we always find the optimal path to reach it.</p>
<p>For each newly reached cell <code>(i, j)</code>, we compute the minimum threshold required to access it. This is determined by taking the maximum value encountered along the path leading to that cell. In other words, we track the largest value that must be surpassed in order to reach <code>(i, j)</code>.</p>
<p>As we continue expanding, we maintain an array <code>thresholdForMaxPoints</code>, where each entry records the smallest query value required to collect a given number of points. Each time we reach a new cell, we store its threshold in this array, associating it with the number of cells we have accessed so far.</p>
<p>By the end of this process, <code>thresholdForMaxPoints[k]</code> holds the <strong>minimum query value</strong> needed to collect exactly <code>k</code> points.</p>
<h5 id="step-3-answering-queries-using-binary-search"><strong>Step 3: Answering Queries Using Binary Search</strong></h5>
<p>Once we have preprocessed the grid, answering a query reduces to a simple binary search on <code>thresholdForMaxPoints</code>. Since we stored thresholds in increasing order, binary search allows us to determine in <strong>logarithmic time</strong> how many points can be collected for a given query.</p>
<p>For a query <code>threshold</code>, we search for the <strong>largest index <code>k</code></strong> such that <code>thresholdForMaxPoints[k] &lt; threshold</code>. The answer to the query is simply <code>k</code>, the number of points that can be collected.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2503/approach3.json:630,940!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define <code>DIRECTIONS</code> to facilitate movement in four directions.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Get <code>rowCount</code> and <code>colCount</code> from <code>grid</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Create <code>thresholdForMaxPoints</code>, where index <code>i</code> stores the minimum query value required to reach <code>i</code> cells.</p>
</li>
<li>
<p>Create <code>minValueToReach</code>, where <code>minValueToReach[i][j]</code> holds the maximum value encountered to reach <code>(i, j)</code>, initialized to <code>MAX_VALUE</code>.</p>
</li>
<li>
<p>Run Dijkstra’s algorithm:</p>
<ul>
<li>Use <code>minHeap</code> (min-priority queue) to explore cells in increasing order of encountered values.</li>
<li>Start from <code>(0,0)</code>, setting <code>minValueToReach[0][0] = grid[0][0]</code> and pushing it into <code>minHeap</code>.</li>
<li>While <code>minHeap</code> is not empty:
<ul>
<li>Extract the cell with the smallest encountered value.</li>
<li>Store the encountered value in <code>thresholdForMaxPoints[++visitedCells]</code>.</li>
<li>Explore four possible directions:
<ul>
<li>If the adjacent cell <code>(newRow, newCol)</code> is within bounds and unvisited:
<ul>
<li>Update its <code>minValueToReach</code> as the maximum of the value to reach the current cell and  <code>grid[newRow][newCol]</code>.</li>
<li>Push it into <code>minHeap</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Process queries using binary search:</p>
<ul>
<li>For each <code>queries[i]</code>, find the rightmost <code>mid</code> where <code>thresholdForMaxPoints[mid] &lt; threshold</code>.</li>
<li>Initialize <code>left = 0</code>, <code>right = totalCells</code>.</li>
<li>Perform binary search:
<ul>
<li>Compute <code>mid = (left + right + 1) / 2</code>.</li>
<li>If <code>thresholdForMaxPoints[mid] &lt; threshold</code>, move <code>left = mid</code>.</li>
<li>Otherwise, adjust <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Store <code>left</code> in <code>result[i]</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YbXEgeXX/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span></p>
<p>The algorithm uses a min-heap to perform a modified Dijkstra's traversal. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed, and each heap operation (insertion or extraction) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>For each of the <code>k</code> queries, a binary search is performed on the <code>thresholdForMaxPoints</code> array, which has a size of <span class="math inline">\((n \cdot m) + 1\)</span>. Each binary search operation takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(k \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by:</p>
<ul>
<li>The <code>minHeap</code>, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells.</li>
<li>The <code>minValueToReach</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The <code>thresholdForMaxPoints</code> array, which is of size <span class="math inline">\((n \cdot m) + 1\)</span>.</li>
</ul>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-disjoint-set-union-union-find">Approach 4: Disjoint Set Union (Union-Find)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of handling queries one by one, we can take a different approach where we process all grid cells first and answer queries afterward. This allows us to efficiently determine the number of reachable points for each query without having to traverse the grid multiple times.</p>
<p>To better understand this approach, let's reiterate our previous observation in a slightly different way. Think about what each query is asking. A query provides a threshold value and asks how many cells in the grid can be reached from the top-left corner <code>(0,0)</code>, while ensuring that all visited cells have values strictly less than this threshold. Instead of iterating over the grid every time a query is given, we can reverse the problem: first process the grid in increasing order of cell values, then efficiently answer all queries using this precomputed information.</p>
<p>To do this, we first extract all the grid cells and sort them in ascending order based on their values. By processing these cells in this order, we can simulate how the reachable area grows as the threshold increases. We maintain a <strong>disjoint set union (Union-Find) data structure</strong> to dynamically merge connected components as we encounter new cells with increasing values.</p>
<p>As we iterate through the sorted grid cells, we add each cell to our Union-Find structure. Whenever we add a cell, we also check its four adjacent neighbors (up, down, left, and right). If a neighbor has already been processed, we merge the current cell with its neighboring cell in the Union-Find structure. This ensures that, at any given moment, all connected components represent regions of the grid where all cells have values strictly less than the current threshold.</p>
<p>At the same time, we also sort the queries in ascending order based on their values. As we process each query, we continue adding cells to our Union-Find structure until the current cell values reach or exceed the query threshold. Once we finish adding all the relevant cells for a query, we determine how many of these cells are reachable from <code>(0,0)</code>. Since the Union-Find structure keeps track of the size of connected components, we can efficiently find the number of reachable cells by checking the size of the component that contains <code>(0,0)</code>.</p>
<p>If the query value is greater than <code>grid[0][0]</code>, then the number of reachable cells is simply the size of the connected component containing <code>(0,0)</code>. Otherwise, no additional cells are reachable, and the answer for this query is <code>0</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Define <code>Cell(row, col, value)</code> to represent grid cells and <code>Query(index, value)</code> to store queries with their original indices.</p>
</li>
<li>
<p>Initialize <code>ROW_DIRECTIONS</code> and <code>COL_DIRECTIONS</code> for moving in four directions.</p>
</li>
<li>
<p>Extract <code>rowCount</code> and <code>colCount</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Sort queries:</p>
<ul>
<li>Store each query as a <code>Query</code> object in <code>sortedQueries</code>.</li>
<li>Sort <code>sortedQueries</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Sort grid cells:</p>
<ul>
<li>Store each cell as a <code>Cell</code> object in <code>sortedCells</code>.</li>
<li>Sort <code>sortedCells</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Initialize <code>UnionFind</code> data structure for dynamic connectivity.</p>
</li>
<li>
<p>Process queries:</p>
<ul>
<li>Iterate over <code>sortedQueries</code>, maintaining an index <code>cellIndex</code> to track which cells have been processed.</li>
<li>While <code>sortedCells[cellIndex].value &lt; query.value</code>, mark the cell as processed and merge it with already processed adjacent cells using <code>UnionFind.union()</code>.</li>
<li>Compute the size of the connected component containing <code>(0,0)</code>, storing the result for <code>query.index</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h5 id="unionfind-class"><strong><code>UnionFind</code> Class:</strong></h5>
<ul>
<li>
<p>Define <code>UnionFind</code> class for disjoint set operations.</p>
</li>
<li>
<p>Declare <code>parent</code> array to track the representative of each set.</p>
</li>
<li>
<p>Declare <code>size</code> array to store the size of each set.</p>
</li>
<li>
<p>Constructor (<code>UnionFind(int n)</code>):</p>
<ul>
<li>Initialize <code>parent</code> with <code>-1</code>, indicating each element is its own set.</li>
<li>Initialize <code>size</code> to <code>1</code>, as each set initially has one element.</li>
</ul>
</li>
<li>
<p><code>find(int node)</code>: Implements path compression to optimize lookup.</p>
<ul>
<li>If <code>parent[node]</code> is <code>-1</code>, it is the root and returned.</li>
<li>Otherwise, recursively find the root and apply path compression (<code>parent[node] = find(parent[node])</code>).</li>
</ul>
</li>
<li>
<p><code>union(int nodeA, int nodeB)</code>:</p>
<ul>
<li>Find roots of <code>nodeA</code> and <code>nodeB</code>.</li>
<li>If both nodes share the same root, they are already in the same set, return <code>false</code>.</li>
<li>Otherwise, perform union by size:
<ul>
<li>Attach the smaller tree to the larger tree.</li>
<li>Update <code>size</code> accordingly.</li>
</ul>
</li>
<li>Return <code>true</code> to indicate a successful union.</li>
</ul>
</li>
<li>
<p><code>getSize(int node)</code>:</p>
<ul>
<li>Find the root of <code>node</code> and return the size of its set.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/8CUbzoZh/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span></p>
<p>The time complexity arises from several steps. First, sorting the <code>queries</code> array takes <span class="math inline">\(O(k \log k)\)</span>. Second, sorting the <code>sortedCells</code> array takes <span class="math inline">\(O((n \cdot m) \log (n \cdot m))\)</span>. Finally, processing each query involves iterating through the cells and performing union-find operations.</p>
<p>The union-find operations, with path compression and union by size, have an amortized time complexity of <span class="math inline">\(O(\alpha(n \cdot m))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function (practically constant).</p>
<p>Since we process up to <code>totalCells</code> cells for each query, the total time for all queries is <span class="math inline">\(O(k \cdot \alpha(n \cdot m))\)</span>. Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((n \cdot m) + k)\)</span></p>
<p>The space complexity is dominated by the <code>sortedQueries</code> array, which takes <span class="math inline">\(O(k)\)</span> space, the <code>sortedCells</code> array, which takes <span class="math inline">\(O(n \cdot m)\)</span> space, and the <code>UnionFind</code> data structure, which uses <span class="math inline">\(O(n \cdot m)\)</span> space for the <code>parent</code> and <code>size</code> arrays. Therefore, the overall space complexity is <span class="math inline">\(O((n \cdot m) + k)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-width-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Width of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the <strong>maximum width</strong> of the given tree</em>.</p>

<p>The <strong>maximum width</strong> of a tree is the maximum <strong>width</strong> among all levels.</p>

<p>The <strong>width</strong> of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.</p>

<p>It is <strong>guaranteed</strong> that the answer will in the range of a <strong>32-bit</strong> signed integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg" style="width: 359px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5,3,null,9]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The maximum width exists in the third level with length 4 (5,3,null,9).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg" style="width: 442px; height: 422px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5,null,null,9,6,null,7]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg" style="width: 289px; height: 299px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The maximum width exists in the second level with length 2 (3,2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 3000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-two-binary-trees/description" target="_blank" rel="noopener noreferrer">Merge Two Binary Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>

<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>

<p>Return <em>the merged tree</em>.</p>

<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" style="width: 600px; height: 163px;" />
<pre>
<strong>Input:</strong> root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
<strong>Output:</strong> [3,4,5,5,4,null,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root1 = [1], root2 = [1,2]
<strong>Output:</strong> [2,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in both trees is in the range <code>[0, 2000]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h3>
<p>We can traverse both the given trees in a preorder fashion. At every step, we check if the current node exists(isn't null) for both the trees. If so, we add the values in the current nodes of both the trees and update the value in the current node of the first tree to reflect this sum obtained. At every step, we also call the original function <code>mergeTrees()</code> with the left children and then with the right children of the current nodes of the two trees. If at any step, one of these children happens to be null, we return the child of the other tree(representing the corresponding child subtree) to be added as a child subtree to the calling parent node in the first tree. At the end, the first tree will represent the required resultant merged binary tree.</p>
<p>The following animation illustrates the process.</p>
<p>!?!../Documents/617_Merge_Trees_Recursion.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/d9nZDPEJ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(m)\)</span>. A total of <span class="math inline">\(m\)</span> nodes need to be traversed. Here, <span class="math inline">\(m\)</span> represents the minimum number of nodes from the two given trees.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(m)\)</span>. The depth of the recursion tree can go upto <span class="math inline">\(m\)</span> in the case of a skewed tree. In average case, depth will be <span class="math inline">\(O(logm)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-method-accepted">Approach #2 Iterative Method [Accepted]</h3>
<p><strong>Algorithm</strong></p>
<p>In the current approach, we again traverse the two trees, but this time we make use of a <span class="math inline">\(stack\)</span> to do so instead of making use of recursion. Each entry in the <span class="math inline">\(stack\)</span> stores data in the form <span class="math inline">\([node_{tree1}, node_{tree2}]\)</span>. Here, <span class="math inline">\(node_{tree1}\)</span> and <span class="math inline">\(node_{tree2}\)</span> are the nodes of the first tree and the second tree respectively.</p>
<p>We start off by pushing the root nodes of both the trees onto the <span class="math inline">\(stack\)</span>. Then, at every step, we remove a node pair from the top of the stack. For every node pair removed, we add the values corresponding to the two nodes and update the value of the corresponding node in the first tree. Then, if the left child of the first tree exists, we push the left child(pair) of both the trees onto the stack. If the left child of the first tree doesn't exist, we append the left child(subtree) of the second tree to the current node of the first tree. We do the same for the right child pair as well.</p>
<p>If, at any step, both the current nodes are null, we continue with popping the next nodes from the <span class="math inline">\(stack\)</span>.</p>
<p>The following animation depicts the process.</p>
<p>!?!../Documents/617_Merge_Trees_Stack.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/v2TK7i2x/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We traverse over a total of <span class="math inline">\(n\)</span> nodes. Here, <span class="math inline">\(n\)</span> refers to the smaller of the number of nodes in the two trees.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The depth of stack can grow upto <span class="math inline">\(n\)</span> in case of a skewed tree.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minesweeper/description" target="_blank" rel="noopener noreferrer">Minesweeper</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Let&#39;s play the minesweeper game (<a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)" target="_blank">Wikipedia</a>, <a href="http://minesweeperonline.com" target="_blank">online game</a>)!</p>

<p>You are given an <code>m x n</code> char matrix <code>board</code> representing the game board where:</p>

<ul>
	<li><code>&#39;M&#39;</code> represents an unrevealed mine,</li>
	<li><code>&#39;E&#39;</code> represents an unrevealed empty square,</li>
	<li><code>&#39;B&#39;</code> represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),</li>
	<li>digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) represents how many mines are adjacent to this revealed square, and</li>
	<li><code>&#39;X&#39;</code> represents a revealed mine.</li>
</ul>

<p>You are also given an integer array <code>click</code> where <code>click = [click<sub>r</sub>, click<sub>c</sub>]</code> represents the next click position among all the unrevealed squares (<code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>).</p>

<p>Return <em>the board after revealing this position according to the following rules</em>:</p>

<ol>
	<li>If a mine <code>&#39;M&#39;</code> is revealed, then the game is over. You should change it to <code>&#39;X&#39;</code>.</li>
	<li>If an empty square <code>&#39;E&#39;</code> with no adjacent mines is revealed, then change it to a revealed blank <code>&#39;B&#39;</code> and all of its adjacent unrevealed squares should be revealed recursively.</li>
	<li>If an empty square <code>&#39;E&#39;</code> with at least one adjacent mine is revealed, then change it to a digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) representing the number of adjacent mines.</li>
	<li>Return the board when no more squares will be revealed.</li>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2023/08/09/untitled.jpeg" style="width: 500px; max-width: 400px; height: 269px;" />
<pre>
<strong>Input:</strong> board = [[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;M&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;]], click = [3,0]
<strong>Output:</strong> [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2023/08/09/untitled-2.jpeg" style="width: 489px; max-width: 400px; height: 269px;" />
<pre>
<strong>Input:</strong> board = [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]], click = [1,2]
<strong>Output:</strong> [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;X&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>board[i][j]</code> is either <code>&#39;M&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;B&#39;</code>, or a digit from <code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>.</li>
	<li><code>click.length == 2</code></li>
	<li><code>0 &lt;= click<sub>r</sub> &lt; m</code></li>
	<li><code>0 &lt;= click<sub>c</sub> &lt; n</code></li>
	<li><code>board[click<sub>r</sub>][click<sub>c</sub>]</code> is either <code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-malware-spread/description" target="_blank" rel="noopener noreferrer">Minimize Malware Spread</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>

<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>

<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove <strong>exactly one node</strong> from <code>initial</code>.</p>

<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>

<p>Note that if a node was removed from the <code>initial</code> list of infected nodes, it might still be infected later due to the malware spread.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;= n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<p><strong>Intuition</strong></p>
<p>First, let's color (the nodes of) each component of the graph.  We can do this using a depth first search.</p>
<p>Afterwards, notice that if two nodes in <code>initial</code> have the same color (ie., belong to the same component), then removing them from <code>initial</code> won't decrease <code>M(initial)</code>.  This is because the malware will spread to reach every node in this component no matter what.</p>
<p>So, among nodes with a unique color in <code>initial</code>, we will remove the node with the largest component size.  (If there's a tie, we return the smallest index.  Also, if there aren't any nodes with a unique color, we'll just return the smallest index node.)</p>
<p><strong>Algorithm</strong></p>
<p>This algorithm has a few parts:</p>
<ul>
<li>
<p><strong>Coloring each component:</strong>  For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.</p>
</li>
<li>
<p><strong>Size of each color:</strong>  Count the number of occurrences of each color.</p>
</li>
<li>
<p><strong>Find unique colors:</strong>  Look at the colors of nodes in <code>initial</code> to see which nodes have unique colors.</p>
</li>
<li>
<p><strong>Choose answer:</strong>  For each node with a unique color, find the size of that color.  The largest size is selected, with ties broken by lowest node number.</p>
<ul>
<li>If there is no node with a unique color, the answer is <code>min(initial)</code>.</li>
</ul>
</li>
</ul>
<p><a href="https://leetcode.com/playground/cW9BUkVC/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-union-find">Approach 2: Union-Find</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>As in <em>Approach 1</em>, it is clear that we will need to consider components of the graph.  A &quot;Disjoint Set Union&quot; (DSU) data structure is ideal for this.</p>
<p>We will skip the explanation of how a DSU structure is implemented.  Please refer to <a href="https://leetcode.com/problems/redundant-connection/solution/">https://leetcode.com/problems/redundant-connection/solution/</a> for a tutorial on DSU.</p>
<p>To our DSU, we can keep a side count of the size of each component.  Whenever we union two components together, the size of those components are added.</p>
<p>With these details neatly handled by our DSU structure, we can continue in a similar manner to <em>Approach 1</em>: for each node in <code>initial</code> with a unique color, we will consider it as a candidate answer.  If no node in <code>initial</code> have a unique color, then we will take <code>min(initial)</code> as the answer.</p>
<p>Note that for brevity, our <code>DSU</code> implementation does not use union-by-rank.  This makes the asymptotic time complexity larger.</p>
<p><a href="https://leetcode.com/playground/ZQNiCZd5/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-malware-spread-ii/description" target="_blank" rel="noopener noreferrer">Minimize Malware Spread II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>

<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>

<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>

<p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>

<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-maximum-edge-weight-of-graph/description" target="_blank" rel="noopener noreferrer">Minimize the Maximum Edge Weight of Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers, <code>n</code> and <code>threshold</code>, as well as a <strong>directed</strong> weighted graph of <code>n</code> nodes numbered from 0 to <code>n - 1</code>. The graph is represented by a <strong>2D</strong> integer array <code>edges</code>, where <code>edges[i] = [A<sub>i</sub>, B<sub>i</sub>, W<sub>i</sub>]</code> indicates that there is an edge going from node <code>A<sub>i</sub></code> to node <code>B<sub>i</sub></code> with weight <code>W<sub>i</sub></code>.</p>

<p>You have to remove some edges from this graph (possibly <strong>none</strong>), so that it satisfies the following conditions:</p>

<ul>
	<li>Node 0 must be reachable from all other nodes.</li>
	<li>The <strong>maximum</strong> edge weight in the resulting graph is <strong>minimized</strong>.</li>
	<li>Each node has <strong>at most</strong> <code>threshold</code> outgoing edges.</li>
</ul>

<p>Return the <strong>minimum</strong> possible value of the <strong>maximum</strong> edge weight after removing the necessary edges. If it is impossible for all conditions to be satisfied, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s-1.png" style="width: 300px; height: 233px;" /></p>

<p>Remove the edge <code>2 -&gt; 0</code>. The maximum weight among the remaining edges is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>It is impossible to reach node 0 from node 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/s2-1.png" style="width: 300px; height: 267px;" /></p>

<p>Remove the edges <code>1 -&gt; 3</code> and <code>1 -&gt; 4</code>. The maximum weight among the remaining edges is 2.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= threshold &lt;= n - 1</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2).</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= A<sub>i</sub>, B<sub>i</sub> &lt; n</code></li>
	<li><code>A<sub>i</sub> != B<sub>i</sub></code></li>
	<li><code>1 &lt;= W<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>There <strong>may be</strong> multiple edges between a pair of nodes, but they must have unique weights.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-absolute-difference-in-bst/description" target="_blank" rel="noopener noreferrer">Minimum Absolute Difference in BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [1,0,48,null,null,12,49]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 783: <a href="https://leetcode.com/problems/minimum-distance-between-bst-nodes/" target="_blank">https://leetcode.com/problems/minimum-distance-between-bst-nodes/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Make at Least One Valid Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of <code>grid[i][j]</code> can be:</p>

<ul>
	<li><code>1</code> which means go to the cell to the right. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j + 1]</code>)</li>
	<li><code>2</code> which means go to the cell to the left. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j - 1]</code>)</li>
	<li><code>3</code> which means go to the lower cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i + 1][j]</code>)</li>
	<li><code>4</code> which means go to the upper cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i - 1][j]</code>)</li>
</ul>

<p>Notice that there could be some signs on the cells of the grid that point outside the grid.</p>

<p>You will initially start at the upper left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code> following the signs on the grid. The valid path does not have to be the shortest.</p>

<p>You can modify the sign on a cell with <code>cost = 1</code>. You can modify the sign on a cell <strong>one time only</strong>.</p>

<p>Return <em>the minimum cost to make the grid have at least one valid path</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid1.png" style="width: 400px; height: 390px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You will start at point (0, 0).
The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost = 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost = 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost = 1 --&gt; (3, 3)
The total cost = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid2.png" style="width: 350px; height: 341px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,3],[3,2,2],[1,1,4]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> You can follow the path from (0, 0) to (2, 2).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid3.png" style="width: 200px; height: 192px;" />
<pre>
<strong>Input:</strong> grid = [[1,2],[4,3]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 4</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Let’s consider a single cell (<code>row</code>, <code>col</code>) in the middle of the grid. To reach this cell, we can come from one of its four neighbors: above (<code>row - 1</code>, <code>col</code>), left (<code>row</code>, <code>col - 1</code>), below (<code>row + 1</code>, <code>col</code>), or right (<code>row</code>, <code>col + 1</code>). The cost to reach this cell depends on two factors: the cost of reaching one of its neighbors and the cost of moving from that neighbor to (<code>row</code>, <code>col</code>). This leads us to the conclusion that if we can compute the minimum cost to reach its neighbors, we can determine the minimum cost to reach the current cell as well.</p>
<p>This dependency on neighboring cells suggests a dynamic programming approach. Initially, it might seem logical to move right and down from the top-left corner towards the bottom-right corner, filling the grid as we go. However, this problem is more complex because paths aren’t restricted to just right or down movements. In fact, a more cost-effective path might involve going left or up, depending on the direction changes needed.</p>
<p>To solve this, we create a grid <code>minChanges</code> to store the minimum cost to reach each cell. Initially, we set all cells to infinity except for the starting cell <code>(0, 0)</code>, which starts at 0 because there’s no cost to begin there.</p>
<p>To find the minimum cost path, we use a two-pass system that repeats until we can't find any better paths:</p>
<ol>
<li>
<p><strong>Forward Pass</strong>: Starting from the top-left corner, we move towards the bottom-right corner. For each cell, we check the cost of reaching it from its neighbors above or to the left. If the neighbor’s direction naturally points to the current cell, there’s no additional cost; otherwise, it costs 1 to change direction. Using this information, we update the minimum cost for the current cell.</p>
</li>
<li>
<p><strong>Backward Pass</strong>: Starting from the bottom-right corner, we move back towards the top-left corner. This pass considers neighbors below or to the right. It’s particularly useful for uncovering paths where a roundabout route (moving up or left) results in a lower cost than a direct one.</p>
</li>
</ol>
<p>After each pass, we check if any cell’s minimum cost has changed. If not, it means we’ve found the optimal solution. Since the cost of a cell can only decrease with each iteration and cannot drop below 0, this process is guaranteed to converge.</p>
<p>Finally, the value in the bottom-right cell of the <code>minChanges</code> grid represents the minimum cost to create a valid path from the top-left to the bottom-right corner.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input <code>grid</code>.</li>
<li>Create a 2-D array <code>minChanges</code> with dimensions <code>numRows * numCols</code> to track the minimum changes needed to reach each cell.</li>
<li>Initialize all cells in the <code>minChanges</code> array to the maximum possible integer value.</li>
<li>Set the value of <code>minChanges[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter an infinite loop that will continue until convergence is reached.
<ul>
<li>Create a 2-D array <code>prevState</code> to store the previous state of <code>minChanges</code> for comparison.</li>
<li>Copy the current state of <code>minChanges</code> into <code>prevState</code>.</li>
<li>Begin the forward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from above and left</li>
<li>Update the <code>minChanges</code> value based on:
<ul>
<li>Whether the neighbor naturally points to the current cell (cost is 0).</li>
<li>Or needs to be changed to point to the current cell (cost is 1).</li>
</ul>
</li>
</ul>
</li>
<li>Begin the backward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from below and right</li>
<li>Apply the same cost calculation logic as in the forward pass.</li>
</ul>
</li>
<li>Compare prevState with the current <code>minChanges</code> array:
<ul>
<li>If they are identical, break the loop as convergence is reached.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minChanges[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cUHwszao/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n \cdot m)^2)\)</span></p>
<p>The algorithm has an outer loop that continues until convergence, where <span class="math inline">\(k\)</span> is the number of iterations needed. In each iteration, we perform a forward pass and a backward pass through the entire grid, each taking <span class="math inline">\(O(n \cdot m)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot k)\)</span>.</p>
<p>The value of <span class="math inline">\(k\)</span> depends on the grid configuration and in the worst case could be proportional to <span class="math inline">\(n \cdot m\)</span>, making the worst-case time complexity <span class="math inline">\(O((n \cdot m)^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses two 2D arrays - <code>minChanges</code> and <code>prevState</code>, each of size <span class="math inline">\(n \times m\)</span>. No additional space scaling with input size is needed. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dijkstras-algorithm">Approach 2: Dijkstra's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We start by thinking of the grid as a network of connected points (a graph). Each cell represents a point (node), and the cells are connected to their neighbors. These connections (edges) have specific costs:</p>
<ol>
<li>Cost is 0 if the sign in one cell points directly to its neighbor.</li>
<li>Cost is 1 in all other cases where we need to change the sign.</li>
</ol>
<p>This gives us a problem where we need to find the cheapest path through a directed graph, which is exactly what Dijkstra's algorithm is designed to handle.</p>
<p>With Dijkstra’s algorithm, we use a priority queue to explore cells based on their current cost, ensuring that we always process the lowest-cost paths first. We also maintain a grid, <code>minCost</code>, where each cell tracks the cheapest way to reach that cell from the start. The queue holds cells we are currently exploring, each entry containing three pieces of information: the total cost so far, and the row and column indices of the cell. The queue is organized such that cells with the lower cost are processed first, which helps us prioritize more promising paths over more expensive ones.</p>
<p>For each cell we explore, we evaluate all its four neighboring cells. To do this, we calculate the cost to reach the neighbor by adding the current cost to the cost of moving to the neighbor (either 0 or 1, depending on the sign). If this new cost is lower than the current recorded cost in <code>minCost</code>, we’ve found a better path to the neighbor, so we update the cost in <code>minCost</code> and add the neighbor to the queue for further exploration.</p>
<p>This process continues until all cells have been explored, and the queue is empty. At this point, the <code>minCost</code> grid holds the minimum cost required to reach each cell from the starting cell (top-left corner). Finally, the solution to the problem is simply the value stored in <code>minCost</code> at the bottom-right corner of the grid.</p>
<blockquote>
<p>For a more comprehensive understanding of Dijkstra's Algorithm, check out the <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card 🔗</a>. This resource provides an in-depth look at Dijkstra's Algorithm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a 2-D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</p>
</li>
<li>
<p>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</p>
</li>
<li>
<p>Create a minimum priority queue <code>pq</code> ordered by cost, where each element is a triplet [cost, row, col].</p>
</li>
<li>
<p>Add the starting position <code>[0, 0, 0]</code> to the priority queue with initial cost <code>0</code>.</p>
</li>
<li>
<p>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</p>
</li>
<li>
<p>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</p>
</li>
<li>
<p>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</p>
</li>
<li>
<p>Enter a loop that continues while the priority queue is not empty:</p>
<ul>
<li>Extract the current cell with minimum cost from the priority queue.</li>
<li>If a better path to this cell has been found, skip processing this cell.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Check if the new position is within the grid boundaries.</li>
<li>Calculate the new cost:
<ul>
<li>Add <code>0</code> if the current cell naturally points in this direction.</li>
<li>Add <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new cost is less than the previously known cost for the new position:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>Add the new position to the priority queue with its cost.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/8rasikDe/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span></p>
<p>The algorithm uses Dijkstra's algorithm with a priority queue. In the worst case, we might need to visit each cell multiple times until we find the optimal path, but no more than <span class="math inline">\(4\)</span> times per cell (once for each direction). For each cell, we perform a priority queue operation which takes <span class="math inline">\(O(\log(n \cdot m))\)</span> time, where <span class="math inline">\(n \cdot m\)</span> is the maximum size of the queue. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a priority queue that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-0-1-breadth-first-search">Approach 3: 0-1 Breadth-First Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Dijkstra's algorithm works well for finding the shortest path, but our problem has a unique feature: the path costs are either 0 or 1. This is key because any path with only 0-cost edges, no matter how long, will always be better than one that uses even a single 1-cost edge. Therefore, it makes sense to prioritize exploring 0-cost edges first. Only after all 0-cost edges have been explored, should we move on to the 1-cost edges. This insight leads us to a modification of the Breadth-First Search (BFS) algorithm, known as 0-1 BFS.</p>
<p>In 0-1 BFS, we adjust the traditional BFS by using a deque (double-ended queue) instead of a regular queue. The deque allows us to prioritize 0-cost edges more efficiently. Each element of the deque will store the row and column indices of a cell, and we will maintain a <code>minCost</code> grid to track the minimum cost to reach each cell.</p>
<p>As we visit each cell, we evaluate its four neighboring cells. If moving to a neighbor doesn’t require a sign change (i.e., the move is a 0-cost move), we add that neighbor to the front of the deque because we want to explore it immediately. On the other hand, if a sign change is required (making it a 1-cost move), we add the neighbor to the back of the deque, ensuring it gets explored later, after all the 0-cost moves.</p>
<p>For each neighbor we explore, we calculate the cost to reach it and compare it to the current value in the <code>minCost</code> grid. If the calculated cost is lower, we update <code>minCost</code> with the new, cheaper value.</p>
<p>Once the BFS traversal completes and all cells have been processed, the minimum cost to reach the bottom-right corner will be stored in <code>minCost</code>. We return this value as the solution to the problem.</p>
<p>The below slideshow demonstrates the algorithm in action:</p>
<p>!?!../Documents/1368/slideshow.json:1080,1080!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</li>
<li>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</li>
<li>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</li>
<li>Create a double-ended queue <code>deque</code> for 0-1 BFS implementation.</li>
<li>Add the starting position <code>[0, 0]</code> to the front of the <code>deque</code>.</li>
<li>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter a loop that continues while the <code>deque</code> is not empty:
<ul>
<li>Extract the current cell from the front of the <code>deque</code>.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Calculate the <code>cost</code>:
<ul>
<li>Set <code>cost</code> to <code>0</code> if the current cell naturally points in this direction.</li>
<li>Set <code>cost</code> to <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new position is valid and the new path is cheaper:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>If the <code>cost</code> is 1:
<ul>
<li>Add the new position to the back of the <code>deque</code>.</li>
</ul>
</li>
<li>If the <code>cost</code> is 0:
<ul>
<li>Add the new position to the front of the <code>deque</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<p>Helper method <code>isValid(row, col, numRows, numCols)</code>:</p>
<ul>
<li>Check if the given position is:
<ul>
<li>Within the grid's row boundaries.</li>
<li>Within the grid's column boundaries.</li>
</ul>
</li>
<li>Return <code>true</code> if all conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/NWGViPMb/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses 0-1 BFS approach where each cell is visited at most once for each edge weight (0 or 1). Since we process zero-weight edges before one-weight edges (by adding to the front of the deque), each cell gets its final shortest distance when it's first processed. No cell is processed more than once with the same cost. Therefore, the time complexity is linear with respect to the number of cells, giving us <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a deque that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-depth-first-search--breadth-first-search">Approach 4: Depth-First Search + Breadth-First Search</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let us extend the idea of exploring all 0-weight edges. Since some paths cost 0 to traverse, we could technically explore a sizable portion of the grid without incurring any cost at all. Now, if we are allowed a cost of 1, we could expand from the parts of the grid already explored and cover an even larger area. Like this, if we gradually increase the cost that we allow for exploration, there will be a cost value where the entire grid (along with the target cell), will be explored.</p>
<p>The primary difference between this approach and all the other ones is that previously we started with exploring the grid and populated the cost along the way. But here, we fix the cost and figure out how much we can explore adhering to it.</p>
<p>We'll use a combination of Breadth-First Search (BFS) and Depth-First Search (DFS) to implement our idea. Imagine our exploration as having levels; cells reachable with cost 0 being one level, cells with cost 1 as another, and so on. We'll use DFS to explore all cells at a given level (cost) and we'll use BFS to guide the exploration level by level until all the cells have been explored.</p>
<p>Let's break down how this works:</p>
<p>Starting at (0,0), we use DFS to follow the arrows without any modifications. If a cell points right and we follow it right, that's free! We keep following these zero-cost paths until we can't go further. Think of this as drawing a continuous line through cells, following arrows until we have to lift our pencil.</p>
<p>Every time we reach a cell through DFS, we also add it to a queue. These cells will serve as the starting points for the next level of exploration.</p>
<p>After we've explored all zero-cost paths, we switch to BFS. We take a cell from the queue, and make a modification to the direction, thereby increasing the cost by 1. With the new direction of the current cell, new cells in the grid are now reachable, and we explore all cells using DFS like before. As we explore the grid using DFS, we maintain a grid <code>minCost</code> which stores the cost at which we first visited that cell.</p>
<p>We continue this process of modification for all direction values for each cell at the current level. After the current level is explored, we increase the cost by 1 again and start modifying the direction of cells in the queue to explore further.</p>
<p>As usual, when all the cells in the grid have been explored, we'll return the bottom-right corner of the <code>minCost</code> array as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize a directions array <code>dirs</code> with four vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize the variables for <code>numRows</code>, <code>numCols</code>, and the initial <code>cost</code> (set to 0).</li>
<li>Create a 2D array <code>minCost</code> to track the minimum cost to reach each cell.</li>
<li>Fill the <code>minCost</code> array with maximum integer values to mark cells as unvisited.</li>
<li>Create a <code>queue</code> to store cells that need cost increments for the BFS part.</li>
<li>Call <code>dfs</code> from the origin <code>(0,0)</code> with the initial cost of 0.</li>
<li>In the BFS part, while the <code>queue</code> is not empty:
<ul>
<li>Increment the <code>cost</code> by 1.</li>
<li>Store the current level size.</li>
<li>Process all cells at the current level:
<ul>
<li>Poll a cell from the <code>queue</code>.</li>
<li>For each of the four directions:
<ul>
<li>Call <code>dfs</code> from the new position with the current <code>cost</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Finally, return the minimum cost to reach the bottom-right cell of the grid (<code>minCost[numRows - 1][numCols - 1]</code>).</li>
</ul>
<p>Helper method <code>dfs(grid, row, col, minCost, cost, queue)</code>:</p>
<ul>
<li>Check if the current cell is valid and unvisited using the <code>isUnvisited</code> function.</li>
<li>If not valid or already visited, return.</li>
<li>Set the current cell's cost in the <code>minCost</code> array.</li>
<li>Add the current cell to the <code>queue</code>.</li>
<li>Calculate the next direction based on the <code>grid</code> value (subtracting 1 for 0-based indexing).</li>
<li>Recursively call <code>dfs</code> in the direction pointed by the arrow without increasing the cost.</li>
</ul>
<p>Helper method <code>isUnvisited(minCost, row, col)</code>:</p>
<ul>
<li>Check if the row and column are within the grid bounds.</li>
<li>Check if the cell has not been visited (still has maximum value).</li>
<li>Return <code>true</code> only if both conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ti9zFAP6/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a hybrid DFS-BFS approach. In the DFS part, each cell is visited at most once when following zero-cost paths (following arrows). In the BFS part, each cell might be added to the queue once for exploration in different directions, but again, each cell is processed at most once since we only visit unvisited cells. Since each cell can only be visited once in both phases, and for each cell, we perform constant time operations, the total time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses multiple data structures that each can grow up to <span class="math inline">\(O(n \cdot m)\)</span>: the <code>minCost</code> array to track visited cells, the <code>queue</code> for BFS that in the worst case might contain all cells, and the recursive call stack for DFS that in worst case might go through all cells in a snake-like pattern. Thus, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-depth-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Minimum Depth of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>

<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" style="width: 432px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>5</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-distance-between-bst-nodes/description" target="_blank" rel="noopener noreferrer">Minimum Distance Between BST Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum difference between the values of any two different nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [1,0,48,null,null,12,49]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 530: <a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/" target="_blank">https://leetcode.com/problems/minimum-absolute-difference-in-bst/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/description" target="_blank" rel="noopener noreferrer">Minimum Edge Reversals So Every Node Is Reachable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>simple directed graph</strong> with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. The graph would form a <strong>tree</strong> if its edges were bi-directional.</p>

<p>You are given an integer <code>n</code> and a <strong>2D</strong> integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> represents a <strong>directed edge</strong> going from node <code>u<sub>i</sub></code> to node <code>v<sub>i</sub></code>.</p>

<p>An <strong>edge reversal</strong> changes the direction of an edge, i.e., a directed edge going from node <code>u<sub>i</sub></code> to node <code>v<sub>i</sub></code> becomes a directed edge going from node <code>v<sub>i</sub></code> to node <code>u<sub>i</sub></code>.</p>

<p>For every node <code>i</code> in the range <code>[0, n - 1]</code>, your task is to <strong>independently</strong> calculate the <strong>minimum</strong> number of <strong>edge reversals</strong> required so it is possible to reach any other node starting from node <code>i</code> through a <strong>sequence</strong> of <strong>directed edges</strong>.</p>

<p>Return <em>an integer array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the</em><em> </em> <em><strong>minimum</strong> number of <strong>edge reversals</strong> required so it is possible to reach any other node starting from node </em><code>i</code><em> through a <strong>sequence</strong> of <strong>directed edges</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img height="246" src="https://assets.leetcode.com/uploads/2023/08/26/image-20230826221104-3.png" width="312" /></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[2,0],[2,1],[1,3]]
<strong>Output:</strong> [1,1,0,2]
<strong>Explanation:</strong> The image above shows the graph formed by the edges.
For node 0: after reversing the edge [2,0], it is possible to reach any other node starting from node 0.
So, answer[0] = 1.
For node 1: after reversing the edge [2,1], it is possible to reach any other node starting from node 1.
So, answer[1] = 1.
For node 2: it is already possible to reach any other node starting from node 2.
So, answer[2] = 0.
For node 3: after reversing the edges [1,3] and [2,1], it is possible to reach any other node starting from node 3.
So, answer[3] = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img height="217" src="https://assets.leetcode.com/uploads/2023/08/26/image-20230826225541-2.png" width="322" /></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[1,2],[2,0]]
<strong>Output:</strong> [2,0,1]
<strong>Explanation:</strong> The image above shows the graph formed by the edges.
For node 0: after reversing the edges [2,0] and [1,2], it is possible to reach any other node starting from node 0.
So, answer[0] = 2.
For node 1: it is already possible to reach any other node starting from node 1.
So, answer[1] = 0.
For node 2: after reversing the edge [1, 2], it is possible to reach any other node starting from node 2.
So, answer[2] = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub> == edges[i][0] &lt; n</code></li>
	<li><code>0 &lt;= v<sub>i</sub> == edges[i][1] &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>The input is generated such&nbsp;that if the edges were bi-directional, the graph would be a tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description" target="_blank" rel="noopener noreferrer">Minimum Fuel Cost to Report to the Capital</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> roads. The capital city is city <code>0</code>. You are given a 2D integer array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists a <strong>bidirectional road</strong> connecting cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>There is a meeting for the representatives of each city. The meeting is in the capital city.</p>

<p>There is a car in each city. You are given an integer <code>seats</code> that indicates the number of seats in each car.</p>

<p>A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.</p>

<p>Return <em>the minimum number of liters of fuel to reach the capital city</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/22/a4c380025e3ff0c379525e96a7d63a3.png" style="width: 303px; height: 332px;" />
<pre>
<strong>Input:</strong> roads = [[0,1],[0,2],[0,3]], seats = 5
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
- Representative<sub>1</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>2</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>3</sub> goes directly to the capital with 1 liter of fuel.
It costs 3 liters of fuel at minimum. 
It can be proven that 3 is the minimum number of liters of fuel needed.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/16/2.png" style="width: 274px; height: 340px;" />
<pre>
<strong>Input:</strong> roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
<strong>Output:</strong> 7
<strong>Explanation:</strong> 
- Representative<sub>2</sub> goes directly to city 3 with 1 liter of fuel.
- Representative<sub>2</sub> and representative<sub>3</sub> go together to city 1 with 1 liter of fuel.
- Representative<sub>2</sub> and representative<sub>3</sub> go together to the capital with 1 liter of fuel.
- Representative<sub>1</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>5</sub> goes directly to the capital with 1 liter of fuel.
- Representative<sub>6</sub> goes directly to city 4 with 1 liter of fuel.
- Representative<sub>4</sub> and representative<sub>6</sub> go together to the capital with 1 liter of fuel.
It costs 7 liters of fuel at minimum. 
It can be proven that 7 is the minimum number of liters of fuel needed.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/27/efcf7f7be6830b8763639cfd01b690a.png" style="width: 108px; height: 86px;" />
<pre>
<strong>Input:</strong> roads = [], seats = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> No representatives need to travel to the capital city.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>roads.length == n - 1</code></li>
	<li><code>roads[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>roads</code> represents a valid tree.</li>
	<li><code>1 &lt;= seats &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-genetic-mutation/description" target="_blank" rel="noopener noreferrer">Minimum Genetic Mutation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A gene string can be represented by an 8-character long string, with choices from <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>

<p>Suppose we need to investigate a mutation from a gene string <code>startGene</code> to a gene string <code>endGene</code> where one mutation is defined as one single character changed in the gene string.</p>

<ul>
	<li>For example, <code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot;</code> is one mutation.</li>
</ul>

<p>There is also a gene bank <code>bank</code> that records all the valid gene mutations. A gene must be in <code>bank</code> to make it a valid gene string.</p>

<p>Given the two gene strings <code>startGene</code> and <code>endGene</code> and the gene bank <code>bank</code>, return <em>the minimum number of mutations needed to mutate from </em><code>startGene</code><em> to </em><code>endGene</code>. If there is no such a mutation, return <code>-1</code>.</p>

<p>Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> startGene = &quot;AACCGGTT&quot;, endGene = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> startGene = &quot;AACCGGTT&quot;, endGene = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= bank.length &lt;= 10</code></li>
	<li><code>startGene.length == endGene.length == bank[i].length == 8</code></li>
	<li><code>startGene</code>, <code>endGene</code>, and <code>bank[i]</code> consist of only the characters <code>[&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-height-trees/description" target="_blank" rel="noopener noreferrer">Minimum Height Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly</i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.</p>

<p>Given a tree of <code>n</code> nodes&nbsp;labelled from <code>0</code> to <code>n - 1</code>, and an array of&nbsp;<code>n - 1</code>&nbsp;<code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i</sub></code> and&nbsp;<code>b<sub>i</sub></code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)&nbsp; are called <strong>minimum height trees</strong> (MHTs).</p>

<p>Return <em>a list of all <strong>MHTs&#39;</strong> root labels</em>.&nbsp;You can return the answer in <strong>any order</strong>.</p>

<p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" style="width: 800px; height: 213px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,0],[1,2],[1,3]]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/e2.jpg" style="width: 800px; height: 321px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
<strong>Output:</strong> [3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are distinct.</li>
	<li>The given input is <strong>guaranteed</strong> to be a tree and there will be <strong>no repeated</strong> edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-jumps-to-reach-end-via-prime-teleportation/description" target="_blank" rel="noopener noreferrer">Minimum Jumps to Reach End via Prime Teleportation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code>.</p>

<p>You start at index 0, and your goal is to reach index <code>n - 1</code>.</p>

<p>From any index <code>i</code>, you may perform one of the following operations:</p>

<ul>
	<li><strong>Adjacent Step</strong>: Jump to index <code>i + 1</code> or <code>i - 1</code>, if the index is within bounds.</li>
	<li><strong>Prime Teleportation</strong>: If <code>nums[i]</code> is a <span data-keyword="prime-number">prime number</span> <code>p</code>, you may instantly jump to any index <code>j != i</code> such that <code>nums[j] % p == 0</code>.</li>
</ul>

<p>Return the <strong>minimum</strong> number of jumps required to reach index <code>n - 1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,4,6]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>One optimal sequence of jumps is:</p>

<ul>
	<li>Start at index <code>i = 0</code>. Take an adjacent step to index 1.</li>
	<li>At index <code>i = 1</code>, <code>nums[1] = 2</code> is a prime number. Therefore, we teleport to index <code>i = 3</code> as <code>nums[3] = 6</code> is divisible by 2.</li>
</ul>

<p>Thus, the answer is 2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4,7,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>One optimal sequence of jumps is:</p>

<ul>
	<li>Start at index <code>i = 0</code>. Take an adjacent step to index <code>i = 1</code>.</li>
	<li>At index <code>i = 1</code>, <code>nums[1] = 3</code> is a prime number. Therefore, we teleport to index <code>i = 4</code> since <code>nums[4] = 9</code> is divisible by 3.</li>
</ul>

<p>Thus, the answer is 2.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,6,5,8]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Since no teleportation is possible, we move through <code>0 &rarr; 1 &rarr; 2 &rarr; 3</code>. Thus, the answer is 3.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-jumps-to-reach-home/description" target="_blank" rel="noopener noreferrer">Minimum Jumps to Reach Home</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A certain bug&#39;s home is on the x-axis at position <code>x</code>. Help them get there from position <code>0</code>.</p>

<p>The bug jumps according to the following rules:</p>

<ul>
	<li>It can jump exactly <code>a</code> positions <strong>forward</strong> (to the right).</li>
	<li>It can jump exactly <code>b</code> positions <strong>backward</strong> (to the left).</li>
	<li>It cannot jump backward twice in a row.</li>
	<li>It cannot jump to any <code>forbidden</code> positions.</li>
</ul>

<p>The bug may jump forward <strong>beyond</strong> its home, but it <strong>cannot jump</strong> to positions numbered with <strong>negative</strong> integers.</p>

<p>Given an array of integers <code>forbidden</code>, where <code>forbidden[i]</code> means that the bug cannot jump to the position <code>forbidden[i]</code>, and integers <code>a</code>, <code>b</code>, and <code>x</code>, return <em>the minimum number of jumps needed for the bug to reach its home</em>. If there is no possible sequence of jumps that lands the bug on position <code>x</code>, return <code>-1.</code></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9
<strong>Output:</strong> 3
<strong>Explanation:</strong> 3 jumps forward (0 -&gt; 3 -&gt; 6 -&gt; 9) will get the bug home.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11
<strong>Output:</strong> -1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7
<strong>Output:</strong> 2
<strong>Explanation:</strong> One jump forward (0 -&gt; 16) then one jump backward (16 -&gt; 7) will get the bug home.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= forbidden.length &lt;= 1000</code></li>
	<li><code>1 &lt;= a, b, forbidden[i] &lt;= 2000</code></li>
	<li><code>0 &lt;= x &lt;= 2000</code></li>
	<li>All the elements in <code>forbidden</code> are distinct.</li>
	<li>Position <code>x</code> is not forbidden.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-clean-the-classroom/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Clean the Classroom</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="324" data-start="147">You are given an <code>m x n</code> grid <code>classroom</code> where a student volunteer is tasked with cleaning up litter scattered around the room. Each cell in the grid is one of the following:</p>

<ul>
	<li><code>&#39;S&#39;</code>: Starting position of the student</li>
	<li><code>&#39;L&#39;</code>: Litter that must be collected (once collected, the cell becomes empty)</li>
	<li><code>&#39;R&#39;</code>: Reset area that restores the student&#39;s energy to full capacity, regardless of their current energy level (can be used multiple times)</li>
	<li><code>&#39;X&#39;</code>: Obstacle the student cannot pass through</li>
	<li><code>&#39;.&#39;</code>: Empty space</li>
</ul>

<p>You are also given an integer <code>energy</code>, representing the student&#39;s maximum energy capacity. The student starts with this energy from the starting position <code>&#39;S&#39;</code>.</p>

<p>Each move to an adjacent cell (up, down, left, or right) costs 1 unit of energy. If the energy reaches 0, the student can only continue if they are on a reset area <code>&#39;R&#39;</code>, which resets the energy to its <strong>maximum</strong> capacity <code>energy</code>.</p>

<p>Return the <strong>minimum</strong> number of moves required to collect all litter items, or <code>-1</code> if it&#39;s impossible.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">classroom = [&quot;S.&quot;, &quot;XL&quot;], energy = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The student starts at cell <code data-end="262" data-start="254">(0, 0)</code> with 2 units of energy.</li>
	<li>Since cell <code>(1, 0)</code> contains an obstacle &#39;X&#39;, the student cannot move directly downward.</li>
	<li>A valid sequence of moves to collect all litter is as follows:
	<ul>
		<li>Move 1: From <code>(0, 0)</code> &rarr; <code>(0, 1)</code> with 1 unit of energy and 1 unit remaining.</li>
		<li>Move 2: From <code>(0, 1)</code> &rarr; <code>(1, 1)</code> to collect the litter <code>&#39;L&#39;</code>.</li>
	</ul>
	</li>
	<li>The student collects all the litter using 2 moves. Thus, the output is 2.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">classroom = [&quot;LS&quot;, &quot;RL&quot;], energy = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The student starts at cell <code data-end="262" data-start="254">(0, 1)</code> with 4 units of energy.</li>
	<li>A valid sequence of moves to collect all litter is as follows:
	<ul>
		<li>Move 1: From <code>(0, 1)</code> &rarr; <code>(0, 0)</code> to collect the first litter <code>&#39;L&#39;</code> with 1 unit of energy used and 3 units remaining.</li>
		<li>Move 2: From <code>(0, 0)</code> &rarr; <code>(1, 0)</code> to <code>&#39;R&#39;</code> to reset and restore energy back to 4.</li>
		<li>Move 3: From <code>(1, 0)</code> &rarr; <code>(1, 1)</code> to collect the second litter <code data-end="1068" data-start="1063">&#39;L&#39;</code>.</li>
	</ul>
	</li>
	<li>The student collects all the litter using 3 moves. Thus, the output is 3.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">classroom = [&quot;L.S&quot;, &quot;RXL&quot;], energy = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>No valid path collects all <code>&#39;L&#39;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == classroom.length &lt;= 20</code></li>
	<li><code>1 &lt;= n == classroom[i].length &lt;= 20</code></li>
	<li><code>classroom[i][j]</code> is one of <code>&#39;S&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, <code>&#39;X&#39;</code>, or <code>&#39;.&#39;</code></li>
	<li><code>1 &lt;= energy &lt;= 50</code></li>
	<li>There is exactly <strong>one</strong> <code>&#39;S&#39;</code> in the grid.</li>
	<li>There are <strong>at most</strong> 10 <code>&#39;L&#39;</code> cells in the grid.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Move a Box to Their Target Location</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.</p>

<p>The game is represented by an <code>m x n</code> grid of characters <code>grid</code> where each element is a wall, floor, or box.</p>

<p>Your task is to move the box <code>&#39;B&#39;</code> to the target position <code>&#39;T&#39;</code> under the following rules:</p>

<ul>
	<li>The character <code>&#39;S&#39;</code> represents the player. The player can move up, down, left, right in <code>grid</code> if it is a floor (empty cell).</li>
	<li>The character <code>&#39;.&#39;</code> represents the floor which means a free cell to walk.</li>
	<li>The character<font face="monospace">&nbsp;</font><code>&#39;#&#39;</code><font face="monospace">&nbsp;</font>represents the wall which means an obstacle (impossible to walk there).</li>
	<li>There is only one box <code>&#39;B&#39;</code> and one target cell <code>&#39;T&#39;</code> in the <code>grid</code>.</li>
	<li>The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a <strong>push</strong>.</li>
	<li>The player cannot walk through the box.</li>
</ul>

<p>Return <em>the minimum number of <strong>pushes</strong> to move the box to the target</em>. If there is no way to reach the target, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/06/sample_1_1620.png" style="width: 500px; height: 335px;" />
<pre>
<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We return only the number of times the box is pushed.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]
<strong>Output:</strong> -1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;T&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> push the box down, left, left, up and up.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 20</code></li>
	<li><code>grid</code> contains only characters <code>&#39;.&#39;</code>, <code>&#39;#&#39;</code>, <code>&#39;S&#39;</code>, <code>&#39;T&#39;</code>, or <code>&#39;B&#39;</code>.</li>
	<li>There is only one character <code>&#39;S&#39;</code>, <code>&#39;B&#39;</code>, and <code>&#39;T&#39;</code> in the <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Reach Target with Rotations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In an&nbsp;<code>n*n</code>&nbsp;grid, there is a snake that spans 2 cells and starts moving from the top left corner at <code>(0, 0)</code> and <code>(0, 1)</code>. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at&nbsp;<code>(n-1, n-2)</code>&nbsp;and&nbsp;<code>(n-1, n-1)</code>.</p>

<p>In one move the snake can:</p>

<ul>
	<li>Move one cell to the right&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>
	<li>Move down one cell&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>
	<li>Rotate clockwise if it&#39;s in a horizontal position and the two cells under it are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>.<br />
	<img alt="" src="https://assets.leetcode.com/uploads/2019/09/24/image-2.png" style="width: 300px; height: 134px;" /></li>
	<li>Rotate counterclockwise&nbsp;if it&#39;s in a vertical position and the two cells to its right are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>.<br />
	<img alt="" src="https://assets.leetcode.com/uploads/2019/09/24/image-1.png" style="width: 300px; height: 121px;" /></li>
</ul>

<p>Return the minimum number of moves to reach the target.</p>

<p>If there is no way to reach the target, return&nbsp;<code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/24/image.png" style="width: 400px; height: 439px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
&nbsp;              [0,0,0,0,1,1],
&nbsp;              [0,0,1,0,1,0],
&nbsp;              [0,1,1,0,0,0],
&nbsp;              [0,1,1,0,0,0]]
<strong>Output:</strong> 11
<strong>Explanation:
</strong>One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,1,1,1,1],
&nbsp;              [0,0,0,0,1,1],
&nbsp;              [1,1,0,0,0,1],
&nbsp;              [1,1,1,0,0,1],
&nbsp;              [1,1,1,0,0,1],
&nbsp;              [1,1,1,0,0,0]]
<strong>Output:</strong> 9
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
	<li>It is guaranteed that the snake starts at empty cells.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-spread-stones-over-grid/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Spread Stones Over Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer matrix <code>grid</code> of size <code>3 * 3</code>, representing the number of stones in each cell. The grid contains exactly <code>9</code> stones, and there can be <strong>multiple</strong> stones in a single cell.</p>

<p>In one move, you can move a single stone from its current cell to any other cell if the two cells share a side.</p>

<p>Return <em>the <strong>minimum number of moves</strong> required to place one stone in each cell</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/23/example1-3.svg" style="width: 401px; height: 281px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,0],[1,1,1],[1,2,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One possible sequence of moves to place one stone in each cell is: 
1- Move one stone from cell (2,1) to cell (2,2).
2- Move one stone from cell (2,2) to cell (1,2).
3- Move one stone from cell (1,2) to cell (0,2).
In total, it takes 3 moves to place one stone in each cell of the grid.
It can be shown that 3 is the minimum number of moves required to place one stone in each cell.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/23/example2-2.svg" style="width: 401px; height: 281px;" />
<pre>
<strong>Input:</strong> grid = [[1,3,0],[1,0,0],[1,0,3]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible sequence of moves to place one stone in each cell is:
1- Move one stone from cell (0,1) to cell (0,2).
2- Move one stone from cell (0,1) to cell (1,1).
3- Move one stone from cell (2,2) to cell (1,2).
4- Move one stone from cell (2,2) to cell (2,1).
In total, it takes 4 moves to place one stone in each cell of the grid.
It can be shown that 4 is the minimum number of moves required to place one stone in each cell.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>grid.length == grid[i].length == 3</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 9</code></li>
	<li>Sum of <code>grid</code> is equal to <code>9</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-multiplications-to-reach-end/1" target="_blank" rel="noopener noreferrer">Minimum Multiplications to reach End</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given <strong>start</strong>, <strong>end</strong> and an array <strong>arr</strong> of <strong>n</strong>&nbsp;numbers. At each step, <strong>start</strong> is multiplied with any number in the array and then mod operation with <strong>100000</strong> is done to get the new start. </span></p>
<p><span style="font-size: 18px;">Your task is to find the minimum steps in which <strong>end</strong> can be achieved starting from <strong>start</strong>. If it is not possible to reach <strong>end</strong>, then return <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
arr[] = {2, 5, 7}
start = 3, end = 30
<strong>Output:</strong>
2
<strong>Explanation:</strong>
Step 1: 3*2 = 6 % 100000 = 6 
Step 2: 6*5 = 30 % 100000 = 30
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
arr[] = {3, 4, 65}
start = 7, end = 66175
<strong>Output:</strong>
4
<strong>Explanation:</strong>
Step 1: 7*3 = 21 % 100000 = 21&nbsp;
Step 2: 21*3 = 63 % 100000 = 63&nbsp;
Step 3: 63*65 = 4095 % 100000 = 4095&nbsp;
Step 4: 4095*65 = 266175 % 100000 = 66175
</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:<br /></strong></span><span style="font-size: 18px;">You don't need to print or input anything. Complete the function <strong>minimumMultiplications()</strong> which takes an integer array <strong>arr</strong>, an integer <strong>start</strong> and an integer<strong> end</strong> as the input parameters and returns an integer, denoting the minumum steps to reach in which <strong>end</strong> can be achieved starting from <strong>start</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(10<sup>5</sup>)<br /></span><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(10<sup>5</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= n &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">1 &lt;= arr[i] &lt;= 10<sup>4</sup></span></li>
<li><span style="font-size: 18px;">1 &lt;= start, end &lt;&nbsp;10<sup>5</sup></span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-days-to-disconnect-island/description" target="_blank" rel="noopener noreferrer">Minimum Number of Days to Disconnect Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">strongly-connected-component</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary grid <code>grid</code> where <code>1</code> represents land and <code>0</code> represents water. An <strong>island</strong> is a maximal <strong>4-directionally</strong> (horizontal or vertical) connected group of <code>1</code>&#39;s.</p>

<p>The grid is said to be <strong>connected</strong> if we have <strong>exactly one island</strong>, otherwise is said <strong>disconnected</strong>.</p>

<p>In one day, we are allowed to change <strong>any </strong>single land cell <code>(1)</code> into a water cell <code>(0)</code>.</p>

<p>Return <em>the minimum number of days to disconnect the grid</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/land1.jpg" style="width: 500px; height: 169px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]

<strong>Output:</strong> 2
<strong>Explanation:</strong> We need at least 2 days to get a disconnected grid.
Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/land2.jpg" style="width: 404px; height: 85px;" />
<pre>
<strong>Input:</strong> grid = [[1,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Grid of full water is also disconnected ([[1,1]] -&gt; [[0,0]]), 0 islands.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary grid where each cell represents either land (1) or water (0). Each day, we can convert any single land cell to a water cell. Our task is to determine the minimum number of days required to modify the grid such that it either:</p>
<ul>
<li>Contains no islands, or</li>
<li>Contains more than one island.</li>
</ul>
<p>An island is a maximal group of horizontally or vertically connected land cells.</p>
<p>In this article, we will explore the applications of the Flood-Fill Algorithm, Tarjan's Algorithm, and Articulation Points, focusing on their practical uses rather than their fundamental principles. If you are unfamiliar with these algorithms, please refer to the foundational materials for a comprehensive understanding:</p>
<ol>
<li><a href="https://leetcode.com/problems/flood-fill/description/">Flood-Fill Algorithm</a></li>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/editorial/">Tarjan's Algorithm and Articulation Points</a></li>
</ol>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The binary grid can initially be in one of three states:</p>
<ol>
<li>No islands (all cells are water).</li>
<li>One island.</li>
<li>More than one island.</li>
</ol>
<p>We only need to modify the grid in the second case, aiming to reach either the first or third state with minimal changes.</p>
<p>A brute force approach would involve flipping each land cell one by one to achieve the desired conditions. However, this could generate up to <span class="math inline">\(2^{30}\)</span> states, which will not satisfy the problem constraints.</p>
<p>To reduce this complexity, we can identify a pattern. The most effective way to split an island into two parts is to find the thinnest cross-section and change those cells to water. In a binary grid, even for uniform shapes like squares or circles, the thinnest cross-section comprises at most 2 squares. Examples can be seen here:</p>
<p><img src="../Figures/1568/two_is_enough.png" alt="two flips are enough" /></p>
<p>First, we should determine if the grid already satisfies the conditions (zero or more than one island). If so, we can immediately return 0.</p>
<p>To check if we can meet the conditions in 1 step, we systematically flip each island cell to water and evaluate the resulting configuration. We iterate over each cell in the grid, temporarily changing it to water, and use a <code>countIslands</code> function to determine the number of islands in the modified grid. When we encounter a land cell, we use the <a href="https://en.wikipedia.org/wiki/Flood_fill">flood-fill algorithm</a> to count the entire island. The total number of flood-fill calls indicates the number of islands.</p>
<p>If removing one land cell does not achieve the goal, the only remaining option is to return 2.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define an array <code>DIRECTIONS</code> that contain the directions for moving right, left, down, and up.</li>
</ul>
<p>Main method <code>minDays</code>:</p>
<ul>
<li>Set <code>rows</code> and <code>cols</code> as the number of rows and columns in <code>grid</code>.</li>
<li>Initialize a variable <code>initialIslandCount</code> and set it to the initial number of islands in the grid by calling the <code>countIslands</code> method.</li>
<li>Check if <code>initialIslandCount</code> is not equal to <code>1</code> (i.e. the island is already disconnected):
<ul>
<li>If <code>true</code>, return <code>0</code>.</li>
</ul>
</li>
<li>Iterate through each cell <code>(row, col)</code> of the grid:
<ul>
<li>If the cell is water, skip it.</li>
<li>Set <code>grid[row][col]</code> to <code>0</code>.</li>
<li>Find the <code>newIslandCount</code> by calling <code>countIslands</code>.</li>
<li>If <code>newIslandCount</code> is not equal to <code>1</code>, return <code>1</code>.</li>
<li>Set  <code>grid[row][col]</code> back to <code>1</code>.</li>
</ul>
</li>
<li>Return <code>2</code>.</li>
</ul>
<p>Helper method <code>countIslands</code>:</p>
<ul>
<li>Define a method <code>countIslands</code> with parameter: the <code>grid</code>.</li>
<li>Initialize:
<ul>
<li><code>rows</code> and <code>cols</code> as the number of rows and columns in the <code>grid</code>.</li>
<li>a boolean array <code>visited</code> to track visited cells.</li>
<li>a variable <code>islandCount</code> set to <code>0</code>.</li>
</ul>
</li>
<li>Iterate through each cell <code>(row, col)</code> of the <code>grid</code>:
<ul>
<li>If the cell has not been visited and its value is <code>1</code>:
<ul>
<li>Call <code>exploreIsland</code> on <code>(row, col)</code>.</li>
<li>Increment <code>islandCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>islandCount</code>.</li>
</ul>
<p>Helper method <code>exploreIsland</code>:</p>
<ul>
<li>Define a method <code>exploreIsland</code> with parameters: <code>grid</code>, the <code>row</code> and <code>col</code> indices, and the <code>visited</code> array.</li>
<li>Set <code>visited[row][col]</code> to <code>true</code>.</li>
<li>For each <code>direction</code> in <code>DIRECTIONS</code>:
<ul>
<li>Set <code>newRow</code> to <code>row + direction[0]</code>.</li>
<li>Set <code>newCol</code> to <code>col + direction[1]</code>.</li>
<li>Check if the <code>(newRow, newCol)</code> is valid using <code>isValidLandCell</code>:
<ul>
<li>If <code>true</code>, call <code>exploreIsland</code> on <code>(newRow, newCol)</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Helper method <code>isValidLandCell</code>:</p>
<ul>
<li>Define a method <code>isValidLandCell</code> with parameters: <code>grid</code>, the <code>row</code> and <code>col</code> indices, and the <code>visited</code> array.</li>
<li>Return <code>true</code> if the cell is within the <code>grid</code> bounds, <code>grid[row][col]</code> is <code>1</code> and has not been visited yet.</li>
<li>Else, return <code>false</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TkjwpTDi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)^2)\)</span></p>
<p>The main operation in this algorithm is the <code>countIslands</code> function, which is called multiple times. <code>countIslands</code> in turn calls the <code>exploreIslands</code> method, which performs a depth-first search on the grid. The DFS in the worst case can explore all the cells in the grid, resulting in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The <code>countIslands</code> method may be called a maximum of <span class="math inline">\(1 + m \cdot n\)</span> times.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O((m \cdot n) \cdot (1 + m \cdot n))\)</span>, which simplifies to <span class="math inline">\(O((m \cdot n)^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The main space usage comes from the <code>visited</code> array in the <code>countIslands</code> function, which has a size of <span class="math inline">\(m \times n\)</span>.</p>
<p>The recursive call stack in the DFS (<code>exploreIsland</code> function) can go as deep as <span class="math inline">\(m \cdot n\)</span> in the worst case.</p>
<p>Therefore, the space complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-tarjans-algorithm">Approach 2: Tarjan's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An articulation point is a cell that will split an island in two when it is changed from land to water. If a given grid has an articulation point, we can disconnect the island in one day. Tarjan's algorithm efficiently finds articulation points in a graph.</p>
<p>The algorithm uses three key pieces of information for each node (cell): discovery time, lowest reachable time, and parent. The discovery time is when a node is first visited during the DFS. The lowest reachable time is the minimum discovery time of any node that can be reached from the subtree rooted at the current node, including the current node itself. The parent is the node from which the current node was discovered during the DFS.</p>
<p>A node can be an articulation point in two cases:</p>
<ol>
<li>A non-root node is an articulation point if it has a child whose lowest reachable time is greater than or equal to the node's discovery time. This condition means that the child (and its subtree) cannot reach any ancestor of the current node without going through the current node, making it critical for connectivity.</li>
<li>The root node of the DFS tree is an articulation point if it has more than one child. Removing the root would disconnect these children from each other.</li>
</ol>
<p>If no articulation points are found, the grid cannot be disconnected by removing a single land cell. In that case, we return 2.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define a constant array <code>DIRECTIONS</code> that contains the directions for moving right, down, left, and up.</li>
</ul>
<p>Main method <code>minDays</code>:</p>
<ul>
<li>Set <code>rows</code> and <code>cols</code> as the number of rows and columns in the <code>grid</code>.</li>
<li>Initialize an <code>ArticulationPointInfo</code> object <code>apInfo</code> with <code>hasArticulationPoint</code> set to <code>false</code> and <code>time</code> set to <code>0</code>.</li>
<li>Initialize variables:
<ul>
<li><code>landCells</code> to count the number of land cells in the grid.</li>
<li><code>islandCount</code> to count the number of islands in the grid.</li>
</ul>
</li>
<li>Initialize arrays <code>discoveryTime</code>, <code>lowestReachable</code>, and <code>parentCell</code> with default values of <code>-1</code>. These arrays store information about each cell during DFS traversal.</li>
<li>Loop through each cell <code>(i, j)</code> of the <code>grid</code>:
<ul>
<li>If the cell is land (<code>1</code>):
<ul>
<li>Increment the <code>landCells</code> count.</li>
<li>If the cell has not been visited (<code>discoveryTime[i][j]</code> = <code>-1</code>):
<ul>
<li>Call <code>findArticulationPoints</code> on <code>(i, j)</code> to find if articulation point exists.</li>
<li>Increment <code>islandCount</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If there is zero or more than one island, return <code>0</code></li>
<li>If there is only one land cell, return <code>1</code>.</li>
<li>If there is an articulation point, return <code>1</code>.</li>
<li>Otherwise, return <code>2</code>.</li>
</ul>
<p>Helper method <code>findArticulationPoints</code>:</p>
<ul>
<li>Define a method <code>findArticulationPoints</code> with parameters: <code>grid</code>, the <code>row</code> and <code>col</code> indices, <code>discoveryTime</code>, <code>lowestReachable</code>, <code>parentCell</code>, and <code>apInfo</code>.</li>
<li>Set <code>rows</code> and <code>cols</code> as the number of rows and columns in the <code>grid</code>.</li>
<li>Set <code>discoveryTime</code> of the current cell to <code>apInfo.time</code>.</li>
<li>Increment the <code>time</code> in <code>apInfo</code>.</li>
<li>Set the <code>lowestReachable</code> time of the current cell to its <code>discoveryTime</code>.</li>
<li>Initialize a variable <code>children</code> to count the number of child nodes in the DFS tree.</li>
<li>To explore adjacent cells, loop through each <code>direction</code> in <code>DIRECTIONS</code>:
<ul>
<li>Calculate <code>newRow</code> as <code>row + direction[0]</code>.</li>
<li>Calculate <code>newCol</code> as <code>col + direction[1]</code>.</li>
<li>If <code>(newRow, newCol)</code> is a valid cell:
<ul>
<li>If the <code>discoveryTime</code> of the new cell is <code>-1</code>:
<ul>
<li>Increment <code>children</code>.</li>
<li>Set the <code>parentCell</code> of the new cell to the current cell.</li>
<li>Recursively call <code>findArticulationPoints</code> for the new cell.</li>
<li>Update the <code>lowestReachable</code> time for the current cell to the minimum of <code>lowestReachable[row][col]</code> and <code>lowestReachable[newRow][newCol]</code>.</li>
<li>If <code>lowestReachable</code> of <code>(newRow, newCol)</code> is greater than or equal to <code>discoveryTime</code> of <code>(row, col)</code>, and <code>(row, col)</code> has a parent:
<ul>
<li>Set <code>hasArticulationPoint</code> of <code>apInfo</code> to <code>true</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Else if <code>(newRow, newCol)</code> is not the parent of <code>(row, col)</code>:
<ul>
<li>Set <code>lowestReachable</code> time of <code>(row, col)</code> to the minimum of <code>lowestReachable[row][col]</code> and <code>discoveryTime[newRow][newCol]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Check if <code>(row, col)</code> is the root of the DFS tree and has more than 1 <code>children</code>:
<ul>
<li>Set <code>hasArticulationPoint</code> of <code>apInfo</code> to <code>true</code>.</li>
</ul>
</li>
</ul>
<p>Helper method <code>isValidLandCell</code>:</p>
<ul>
<li>Define a method <code>isValidLandCell</code> with parameters: <code>grid</code>, and the <code>row</code> and <code>col</code> indices.</li>
<li>Return <code>true</code> if the given cell is within the bounds of the grid and is a land cell (<code>1</code>).</li>
<li>Else, return <code>false</code>.</li>
</ul>
<p>Helper class <code>ArticulationPointInfo</code>:</p>
<ul>
<li>Define a class <code>ArticulationPointInfo</code> with fields: <code>hasArticulationPoint</code> and <code>time</code>.</li>
<li>Override the default constructor to initialize <code>hasArticulationPoint</code> and <code>time</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/V5ydSy68/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Initializing the arrays <code>discoveryTime</code>, <code>lowestReachable</code>, and <code>parentCell</code> takes <span class="math inline">\(O(m \cdot n)\)</span> time each.</p>
<p>The DFS traversal by the <code>findArticulationPoints</code> method visits each cell exactly once, taking <span class="math inline">\(O(m \cdot n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The arrays <code>discoveryTime</code>, <code>lowestReachable</code>, and <code>parentCell</code> each take <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
<p>The recursive call stack for the DFS traversal can go as deep as the number of land cells in the worst case. If all cells are land, the depth of the recursive call stack can be <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(O(m \cdot n) + O(m \cdot n) = O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/description" target="_blank" rel="noopener noreferrer">Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> binary matrix <code>mat</code>. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing <code>1</code> to <code>0</code> and <code>0</code> to <code>1</code>). A pair of cells are called neighbors if they share one edge.</p>

<p>Return the <em>minimum number of steps</em> required to convert <code>mat</code> to a zero matrix or <code>-1</code> if you cannot.</p>

<p>A <strong>binary matrix</strong> is a matrix with all cells equal to <code>0</code> or <code>1</code> only.</p>

<p>A <strong>zero matrix</strong> is a matrix with all cells equal to <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/28/matrix.png" style="width: 409px; height: 86px;" />
<pre>
<strong>Input:</strong> mat = [[0,0],[0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Given matrix is a zero matrix. We do not need to change it.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,0,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> Given matrix cannot be a zero matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 3</code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-smart-enumeration">Approach 1: Smart Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>The question asks us to transform a 0-1 matrix into all 0s using the minimum number of flips, and when an element is flipped, all of its 4 neighbors (if they exist) will be flipped too. The problem is also known as the <strong>Lights Out Puzzle</strong>.</p>
<p>You might already realize that for each element, we only need to flip it at most once since flipping the same element twice cancels the previous flip. Because the size of the matrix is not large (at most 3 x 3 according to the constraints), we can just try all combinations of the decisions on each element (whether to flip it or not).</p>
<p>However, there is a better way to do the enumeration. Suppose we make each decision from the top row to the bottom row. When we're making decisions for the <span class="math inline">\(i^{th}\)</span> row, all the rows above the <span class="math inline">\((i - 1)^{th}\)</span> row should be already be 0s, because flipping the elements in the <span class="math inline">\(i^{th}\)</span> row and below cannot change the elements above the <span class="math inline">\((i - 1)^{th}\)</span> row. This means when we're working on the <span class="math inline">\(i^{th}\)</span> row, if there are still 1s in the <span class="math inline">\((i - 1)^{th}\)</span> row, they can only be changed into 0 by flips on the current row. Furthermore, if there's a 0 in the <span class="math inline">\((i - 1)^{th}\)</span> row, we shouldn't flip its neighbors in the current row. <strong>In other words, when we're working on the <span class="math inline">\(i^{th}\)</span> row, the decisions are uniquely determined by the state of the <span class="math inline">\((i - 1)^{th}\)</span> row.</strong> The <span class="math inline">\(i^{th}\)</span> row's decisions needs to make the values in the <span class="math inline">\((i - 1)^{th}\)</span> row into all 0s.</p>
<p>Here is an example:</p>
<center>
<img src="../Figures/1284/1284_Minimum_Number_of_Flips_to_Convert_Binary_Matrix_to_Zero_Matrix_1.png" width="500"/>
</center>
<br>
<p>After applying the decisions for the <span class="math inline">\(i^{th}\)</span> row, it changes into:</p>
<center>
<img src="../Figures/1284/1284_Minimum_Number_of_Flips_to_Convert_Binary_Matrix_to_Zero_Matrix_2.png" width="500"/>
</center>
<br>
<p>So we only need to try all the decisions for the first row (index = 0), for each such decision, the decisions for all the following rows are already determined. For each set of first-row decisions, if after applying all the decisions the values in the last row are all 0s, then it's a feasible solution. We're required to find the minimum number of flips of all feasible solutions.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Assume the input matrix is called mat[][] and it has <span class="math inline">\(n\)</span> columns. The algorithm works as follows:</p>
<ol>
<li>Enumerate all the possible decisions for the first row.</li>
<li>Suppose List<Integer> <code>operations</code> is a decision for the first row. Each element is either 0 or 1, indicating whether the corresponding element in <code>mat[0]</code> is flipped or not. We also need to maintain two binary arrays of size <span class="math inline">\(n\)</span> for each row. <code>lastState[]</code> which has values of the previous row and <code>changed[]</code> which represents whether the values in the current row are flipped when working on the previous row.</li>
<li>Initialize <code>lastState</code> = <code>operations</code> (need to transform from List<Integer> to int[]). Initialize <code>changed</code> into all 0s since the <span class="math inline">\(0^{th}\)</span> row doesn't have a previous row.</li>
<li>For each row in mat, use the next step to calculate the <code>state</code> which is initialized to <code>changed</code>.</li>
<li>For each position <code>j</code> in the range [0, n - 1] of the current row, the determined decision is <code>lastState[j]</code>, so change the value of <code>state[j]</code> accordingly, i.e if <code>lastState[j]</code> is 1, flip <code>state[j]</code>, <code>state[j - 1]</code> and <code>state[j + 1]</code> if they exist. Also, increase the counter of flips by 1.</li>
<li>Because of the current row's decision, the values that are flipped in the next row is exactly <code>lastState</code> and the decision for the next row is exactly the <code>state</code> array. So set <code>changed</code> = <code>lastState</code> and <code>lastState</code> = <code>state</code>, then move onto the next row</li>
<li>Once we complete all rows, check whether <code>lastState</code> contains all 0s to determine whether it's a feasible solution.</li>
<li>Return the minimum number of flips for all the feasible solutions that are proposed by step 1.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fhDWa93U/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> and <span class="math inline">\(N\)</span> are the number of rows and columns of the input matrix.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(M \cdot N \cdot 2 ^ N)\)</span>.</li>
</ul>
<p>It takes <span class="math inline">\(O(2 ^ N)\)</span> time to list all the possible decisions for the first row (index = 0). And for each such decision, it takes <span class="math inline">\(O(M \cdot N)\)</span> to further apply the uniquely determined decision for each element in the matrix. So the total time complexity is <span class="math inline">\(O(M \cdot N \cdot 2 ^ N)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(N)\)</span>.<br />
We only save/reuse one Integer List of length <span class="math inline">\(N\)</span> to enumerate all possible decisions for the first row (index = 0). And only save 2 int arrays of length <span class="math inline">\(N\)</span> to further apply the uniquely determined decision for each element. So the space complexity is <span class="math inline">\(O(N)\)</span>.</li>
</ul>
<blockquote>
<p>It's possible to transpose the input matrix if M &lt; N to lower the time and space complexities.</p>
</blockquote>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-make-x-and-y-equal/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Make X and Y Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integers <code>x</code> and <code>y</code>.</p>

<p>In one operation, you can do one of the four following operations:</p>

<ol>
	<li>Divide <code>x</code> by <code>11</code> if <code>x</code> is a multiple of <code>11</code>.</li>
	<li>Divide <code>x</code> by <code>5</code> if <code>x</code> is a multiple of <code>5</code>.</li>
	<li>Decrement <code>x</code> by <code>1</code>.</li>
	<li>Increment <code>x</code> by <code>1</code>.</li>
</ol>

<p>Return <em>the <strong>minimum</strong> number of operations required to make </em> <code>x</code> <i>and</i> <code>y</code> equal.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> x = 26, y = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can make 26 equal to 1 by applying the following operations: 
1. Decrement x by 1
2. Divide x by 5
3. Divide x by 5
It can be shown that 3 is the minimum number of operations required to make 26 equal to 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> x = 54, y = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can make 54 equal to 2 by applying the following operations: 
1. Increment x by 1
2. Divide x by 11 
3. Divide x by 5
4. Increment x by 1
It can be shown that 4 is the minimum number of operations required to make 54 equal to 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> x = 25, y = 30
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can make 25 equal to 30 by applying the following operations: 
1. Increment x by 1
2. Increment x by 1
3. Increment x by 1
4. Increment x by 1
5. Increment x by 1
It can be shown that 5 is the minimum number of operations required to make 25 equal to 30.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= x, y &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Sort a Binary Tree by Level</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree with <strong>unique values</strong>.</p>

<p>In one operation, you can choose any two nodes <strong>at the same level</strong> and swap their values.</p>

<p>Return <em>the minimum number of operations needed to make the values at each level sorted in a <strong>strictly increasing order</strong></em>.</p>

<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node<em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png" style="width: 500px; height: 324px;" />
<pre>
<strong>Input:</strong> root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- Swap 4 and 3. The 2<sup>nd</sup> level becomes [3,4].
- Swap 7 and 5. The 3<sup>rd</sup> level becomes [5,6,8,7].
- Swap 8 and 7. The 3<sup>rd</sup> level becomes [5,6,7,8].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png" style="width: 400px; height: 303px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,7,6,5,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- Swap 3 and 2. The 2<sup>nd</sup> level becomes [2,3].
- Swap 7 and 4. The 3<sup>rd</sup> level becomes [4,6,5,7].
- Swap 6 and 5. The 3<sup>rd</sup> level becomes [4,5,6,7].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png" style="width: 400px; height: 274px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Each level is already sorted in increasing order so return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>All the values of the tree are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-hash-map">Approach 1: Hash Map</h3>
<h4 id="intuition">Intuition</h4>
<p>Our first task is to traverse the tree level by level. This is known as a level order traversal of a tree. Level-order traversal involves exploring all the nodes at a given depth (or level) before moving to the next level. In other words, it prioritizes breadth-wise exploration of the tree before progressing depth-wise. To achieve this, we use Breadth-First Search (BFS).</p>
<p>We use a queue to perform BFS on the tree. As we process each node, we add all its children to the queue. This ensures that after all nodes at the current level are explored, the remaining elements in the queue represent all nodes at the next level. To process nodes at each level together, we can record the size of the queue at the start of each iteration and handle exactly that many nodes in the current level.</p>
<p>Once we retrieve the nodes at each level, our second task is to sort the values of the nodes at that level. While there are many efficient sorting algorithms, the problem specifically requires sorting the values with the minimum number of in-place swaps. The cycle sort algorithm meets our requirements perfectly.</p>
<p>The cycle sort algorithm works by cyclically placing each element in its correct sorted position by swapping it with the value currently in that position. For example, consider the array <code>[3, 0, 1]</code>. Since the correct position of <code>3</code> is index <code>2</code>, we swap it with the value at index <code>2</code> (i.e., <code>1</code>). After the swap, the array becomes <code>[1, 0, 3]</code>. While <code>3</code> is now in the correct position, <code>1</code> and <code>0</code> are still not. Next, we place <code>1</code> in its correct position (index <code>1</code>), and the process continues until the array is sorted. This cyclical placement gives the algorithm its name, cycle sort.</p>
<p>Returning to the problem, after obtaining the nodes of a level (in an arbitrary order), we create a sorted copy of this list based on the values of the nodes. This allows us to determine the correct sorted index for each value. To efficiently track the positions of nodes, we use a map that stores each value and its current index. As we iterate through the list of nodes, we check if a node is already in its correct position. If not, we perform a swap to move it to the correct position, updating the map accordingly. This process is repeated until all nodes in the level are sorted.</p>
<p>We accumulate the total swaps needed to sort each level. At the end of the BFS, we can return this total as our answer.</p>
<blockquote>
<p>For a more comprehensive understanding of Breadth-First Search on trees, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">Queue and BFS Explore Card 🔗</a>. This resource provides an in-depth look at the BFS algorithm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a <code>queue</code> to store nodes for BFS traversal.</li>
<li>a variable <code>totalSwaps</code> to track the total number of operations needed.</li>
</ul>
</li>
<li>Add the <code>root</code> node to the queue to begin traversal.</li>
<li>While the queue is not empty:
<ul>
<li>Get the size of the current level using the queue size.</li>
<li>Initialize an array <code>levelValues</code> of size equal to the current level size.</li>
<li>For each node at the current level:
<ul>
<li>Remove the node from the queue.</li>
<li>Store the node's value in the <code>levelValues</code> array.</li>
<li>Add the left and right children of the current node to <code>queue</code> if they exist.</li>
</ul>
</li>
<li>Add minimum swaps needed for the current level to <code>totalSwaps</code>.</li>
<li>Continue to the next level.</li>
</ul>
</li>
<li>Return <code>totalSwaps</code> as the final answer.</li>
</ul>
<p>For calculating minimum swaps (<code>getMinSwaps</code> function):</p>
<ul>
<li>Initialize a variable <code>swaps</code> to track swaps needed for the current level.</li>
<li>Create a copy of the input array as the <code>target</code> array.</li>
<li>Sort the <code>target</code> array to get the desired order.</li>
<li>Initialize a map <code>pos</code> to store current positions of values.</li>
<li>Store positions of all values from the original array in the <code>pos</code> map.</li>
<li>For each position in the <code>original</code> array:
<ul>
<li>If the value at the current position doesn't match the <code>target</code> array:
<ul>
<li>Increment <code>swaps</code> counter.</li>
<li>Get the position of desired value from <code>pos</code>.</li>
<li>Update the position of the current value in <code>pos</code>.</li>
<li>Update value in the <code>original</code> array at swapped position.</li>
</ul>
</li>
</ul>
</li>
<li>Return total <code>swaps</code> needed for current level.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ELALCbfh/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the total number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The BFS traversal visits each node exactly once, contributing <span class="math inline">\(O(n)\)</span>. At each level, we perform sorting of the level values array which costs <span class="math inline">\(O(w \log w)\)</span> where <span class="math inline">\(w\)</span> is the width of that level.</p>
<p>The position mapping and swap calculations take <span class="math inline">\(O(w)\)</span> time. In the worst case when the tree is a complete binary tree, <span class="math inline">\(w\)</span> could be <span class="math inline">\(n/2\)</span>, making the complexity <span class="math inline">\(2 \cdot O(n) + O(n \log n) = O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The queue used for BFS will store at most <span class="math inline">\(w\)</span> nodes at any time, where <span class="math inline">\(w\)</span> is the maximum width of the tree at any level. The <code>levelValues</code> array also stores <span class="math inline">\(w\)</span> elements for the current level. The map in <code>getMinSwaps</code> stores positions for <span class="math inline">\(w\)</span> elements.</p>
<p>The temporary arrays (<code>original</code> and <code>target</code>) also use <span class="math inline">\(O(w)\)</span> space. Since all these data structures are bounded by the maximum width of the tree, the overall space complexity is <span class="math inline">\(O(w)\)</span>. In the worst case of a complete binary tree, this becomes <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bit-manipulation">Approach 2: Bit Manipulation</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous solution, we used two arrays - one for the original values and one for the sorted values. Additionally, we needed a map to keep track of the current positions of each value. This required maintaining three separate data structures and constantly updating the hash map during swaps. This approach was cumbersome and took up a lot of redundant space. Let's try to make the swapping process more space-efficient.</p>
<p>The key insight in this new approach is that we can combine a node's value and its position into a single number using bit manipulation. Since the problem guarantees that the values and positions won't exceed <span class="math inline">\(2^{20}\)</span>, 20 bits are enough to store either piece of information. Therefore, a 40-bit long integer is technically enough to store both the value and position of a node, where the high 20 bits store the value and the low 20 bits store the original position. Let's see how the encoding works with a concrete example. Say we have a node with value 9 at position 6. To encode this:</p>
<ol>
<li>First, we shift 9 left by 20 bits: <span class="math inline">\(9 << 20\)</span>. This moves all the bits of 9 to the left by 20 positions, leaving 20 zeros on the right.</li>
<li>Then we add the position: <span class="math inline">\((9 << 20) + 6\)</span>. The 6 fills in some of those right-most zeros.</li>
</ol>
<p><img src="../Figures/2471/encoding.png" alt="" /></p>
<p>When we need to get back the original position, we use a <code>MASK</code> (0xFFFFF). In binary, this mask has twenty 1's. When we perform an AND operation with the encoded value, it's like using a filter that only lets through the rightmost 20 bits — exactly where we stored our position.</p>
<p><img src="../Figures/2471/decoding.png" alt="" /></p>
<p>The rest of the algorithm is similar to the previous approach, with some simplifications to the swapping process. We iterate through the sorted array, and for each position <code>i</code>, we check if the original position (extracted using the <code>MASK</code>) matches <code>i</code>. If it doesn't match, we know we need a swap. We perform the swap and decrement <code>i</code> to recheck the current position, as the newly swapped number might also need to be moved. We keep counting the swaps over the entire BFS and return the total count at the end as our answer.</p>
<blockquote>
<p>For a more comprehensive understanding of bit manipulation techniques, check out the <a href="https://leetcode.com/explore/learn/card/bit-manipulation/">Bit Manipulation Explore Card 🔗</a>. This resource provides an in-depth look at the various bit manipulation techniques and their applications in a variety of problems.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize constants <code>SHIFT</code> and <code>MASK</code> for bit manipulation operations.</p>
</li>
<li>
<p>Initialize:</p>
<ul>
<li>a <code>queue</code> to store nodes for BFS traversal.</li>
<li>a variable <code>swaps</code> to track the total number of operations needed.</li>
</ul>
</li>
<li>
<p>Add the <code>root</code> node to <code>queue</code> to begin traversal.</p>
</li>
<li>
<p>While the <code>queue</code> is not empty:</p>
<ul>
<li>Get the size of the current level using the <code>queue</code> size.</li>
<li>Initialize an array <code>nodes</code> of type long to store encoded values and positions.</li>
<li>For each node at the current level:
<ul>
<li>Remove the node from the <code>queue</code>.</li>
<li>Encode the node's value and current position into a single long integer:
<ul>
<li>Shift the value left by 20 bits.</li>
<li>Add the current position in the lower 20 bits.</li>
</ul>
</li>
<li>Store the encoded value in the <code>nodes</code> array.</li>
<li>Add the left and right children to the <code>queue</code> if they exist.</li>
</ul>
</li>
<li>Sort the <code>nodes</code> array by values (using the higher 20 bits).</li>
<li>For each position <code>i</code> in the sorted array:
<ul>
<li>Extract the original position from the lower 20 bits using the AND operation with <code>MASK</code>.</li>
<li>If the original position doesn't match the current position:
<ul>
<li>Swap the nodes at the current and original positions.</li>
<li>Decrement <code>i</code> to recheck current position.</li>
<li>Increment the <code>swaps</code> counter.</li>
</ul>
</li>
<li>Continue until all the nodes are in the correct positions.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the total <code>swaps</code> as the final answer.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nvkiMUoN/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the total number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The BFS traversal visits each node exactly once, contributing <span class="math inline">\(O(n)\)</span>. At each level, we sort the <code>nodes</code> array which takes <span class="math inline">\(O(w \log w)\)</span> time, where <span class="math inline">\(w\)</span> is the width of that level.</p>
<p>The swapping phase at each level takes <span class="math inline">\(O(w)\)</span> time. In the worst case of a complete binary tree, <span class="math inline">\(w\)</span> could be <span class="math inline">\(n/2\)</span>, making the complexity <span class="math inline">\(O(n) + O(n \log n) = O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>queue</code> used for the BFS will store at most <span class="math inline">\(w\)</span> nodes at any time, where <span class="math inline">\(w\)</span> is the maximum width of the tree at any level. The <code>nodes</code> array stores <span class="math inline">\(w\)</span> encoded values for the current level being processed. No additional data structures are needed since positions are encoded within the values themselves.</p>
<p>Since all space usage is bounded by the maximum width of the tree, the overall space complexity is <span class="math inline">\(O(w)\)</span>. In the worst case of a complete binary tree, this becomes <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Number of Visited Cells in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. Your initial position is at the <strong>top-left</strong> cell <code>(0, 0)</code>.</p>

<p>Starting from the cell <code>(i, j)</code>, you can move to one of the following cells:</p>

<ul>
	<li>Cells <code>(i, k)</code> with <code>j &lt; k &lt;= grid[i][j] + j</code> (rightward movement), or</li>
	<li>Cells <code>(k, j)</code> with <code>i &lt; k &lt;= grid[i][j] + i</code> (downward movement).</li>
</ul>

<p>Return <em>the minimum number of cells you need to visit to reach the <strong>bottom-right</strong> cell</em> <code>(m - 1, n - 1)</code>. If there is no valid path, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex1.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows one of the paths that visits exactly 4 cells.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex2.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The image above shows one of the paths that visits exactly 3 cells.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/26/ex3.png" style="width: 181px; height: 81px;" />
<pre>
<strong>Input:</strong> grid = [[2,1,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven that no path exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>
	<li><code>grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/description" target="_blank" rel="noopener noreferrer">Minimum Obstacle Removal to Reach Corner</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code>. Each cell has one of two values:</p>

<ul>
	<li><code>0</code> represents an <strong>empty</strong> cell,</li>
	<li><code>1</code> represents an <strong>obstacle</strong> that may be removed.</li>
</ul>

<p>You can move up, down, left, or right from and to an empty cell.</p>

<p>Return <em>the <strong>minimum</strong> number of <strong>obstacles</strong> to <strong>remove</strong> so you can move from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png" style="width: 605px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
It can be shown that we need to remove at least 2 obstacles, so we return 2.
Note that there may be other ways to remove 2 obstacles to create a path.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png" style="width: 405px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2-D matrix <code>grid</code>, where each cell is either empty or contains an obstacle. We can remove any obstacle, and our goal is to find the minimum number of obstacles that need to be removed to create a path from the top-left corner to the bottom-right corner.</p>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We can frame this problem as a shortest-path problem with a start and end point, and from each cell, we can move in four directions (up, down, left, right). There are two scenarios for movement:</p>
<ol>
<li>Moving to an empty cell costs nothing (edge weight = 0).</li>
<li>Moving to a cell with an obstacle costs 1 as we must remove it (edge weight = 1).</li>
</ol>
<p>This turns our problem into a graph with edges weighted 0 or 1. The goal is to find the shortest path from the start to the destination using Dijkstra's algorithm.</p>
<p>We’ll implement Dijkstra’s algorithm using a priority queue, where each element contains the cell's coordinates and the number of obstacles removed to reach it. The queue will be sorted by obstacle count in increasing order. For each element, we explore its four neighbors. If a neighbor contains an obstacle, we increment the obstacle count and add it to the queue for further exploration.</p>
<p>As we explore, we’ll eventually reach the destination cell. Once we do, we return its obstacle count, which is guaranteed to be the minimum, as the queue prioritizes cells with the fewest obstacles.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Set dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.
<ul>
<li>Set all cells in <code>minObstacles</code> to infinity to represent unvisited cells.</li>
</ul>
</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to the value of <code>grid[0][0]</code>, since this is the initial position.</li>
<li>Create a priority queue <code>pq</code> that orders elements based on the number of obstacles encountered.
<ul>
<li>Each element in the queue is an array containing: [obstacles count, row, column]</li>
</ul>
</li>
<li>Add the starting position to the priority queue with its obstacle count.</li>
<li>Enter a loop that continues while <code>pq</code> is not empty:
<ul>
<li>Extract the cell with minimum obstacles from the queue.</li>
<li>If this cell is the target <code>(m-1, n-1)</code>, return the obstacle count.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid:
<ul>
<li>Calculate the new obstacle count by adding the grid value of the new position.</li>
<li>If the new obstacle count is less than the previously recorded count for that cell:</li>
<li>Update the <code>minObstacles</code> array with the new count.</li>
<li>Add the new position to <code>pq</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return -1 if the main loop completes without finding the target (this shouldn't happen).</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z4CaAqmQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>The priority queue can contain up to <span class="math inline">\(O(m \cdot n)\)</span> elements (all the cells in the grid), making each operation cost <span class="math inline">\(O(\log(m \cdot n))\)</span> time. Thus, the time complexity is <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is dominated by two main components: the <code>minObstacles</code> array and the priority queue, both of which have a complexity of <span class="math inline">\(O(m \cdot n)\)</span>. The <code>directions</code> array and other variables take constant space.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-0-1-breadth-first-search-bfs">Approach 2: 0-1 Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As stated earlier, moving through cells without obstacles has no cost. Therefore, we prioritize exploring neighboring empty cells first, only moving to cells with obstacles when no free cells are left.</p>
<p>We perform a BFS using a deque to manage the queue. When exploring neighboring cells, we add empty cells to the front of the deque for immediate exploration, and cells with obstacles to the back, delaying their exploration.</p>
<p>We maintain a result grid, <code>minObstacles</code>, initialized to infinity (indicating they are unvisited), to track the minimum obstacles encountered at each cell. We'll add the top left cell to the deque and begin our exploration. At each step, we'll pop the top cell in the deque and explore its neighbors. All empty neighbors go to the front of the deque, while others go to the bottom with their obstacle count increased by 1. Simultaneously, we'll update the <code>minObstacles</code> value for each neighboring position.</p>
<p>Once all cells are explored, the value at the bottom-right cell of <code>minObstacles</code> will give the minimum obstacles encountered on the shortest path.</p>
<p>Here's a brief visualization of how the <code>minObstacles</code> matrix is filled up step by step:</p>
<p>!?!../Documents/2290/slideshow.json:702,942!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 2-D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Store the dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2-D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.</li>
<li>Initialize all cells in <code>minObstacles</code> with infinity to represent unvisited cells.</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to 0, as we start from this position.</li>
<li>Create a double-ended queue <code>deque</code> to process cells.
<ul>
<li>Add the starting position to the queue.</li>
</ul>
</li>
<li>Loop while the deque is not empty:
<ul>
<li>Extract the first cell from the queue.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid and unvisited (<code>minObstacles</code> value is infinity):
<ul>
<li>If the new cell contains an obstacle (value 1):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count plus 1.</li>
<li>Add the new position to the back of the deque.</li>
</ul>
</li>
<li>If the new cell is empty (value 0):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count.</li>
<li>Add a new position to the front of the deque.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minObstacles[m-1][n-1]</code> representing minimum obstacles removed to reach target.</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VbP4ycxv/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Each of the <span class="math inline">\(m \cdot n\)</span> cells in the grid is visited exactly once because we only process unvisited cells. The deque operations are all <span class="math inline">\(O(1)\)</span>.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The <code>minObstacles</code> array and the deque both take <span class="math inline">\(O(m \cdot n)\)</span> space. All other variables take constant space.</p>
<p>Thus, the space complexity remains <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-150">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-convert-number/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Convert Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> containing <strong>distinct</strong> numbers, an integer <code>start</code>, and an integer <code>goal</code>. There is an integer <code>x</code> that is initially set to <code>start</code>, and you want to perform operations on <code>x</code> such that it is converted to <code>goal</code>. You can perform the following operation repeatedly on the number <code>x</code>:</p>

<p>If <code>0 &lt;= x &lt;= 1000</code>, then for any index <code>i</code> in the array (<code>0 &lt;= i &lt; nums.length</code>), you can set <code>x</code> to any of the following:</p>

<ul>
	<li><code>x + nums[i]</code></li>
	<li><code>x - nums[i]</code></li>
	<li><code>x ^ nums[i]</code> (bitwise-XOR)</li>
</ul>

<p>Note that you can use each <code>nums[i]</code> any number of times in any order. Operations that set <code>x</code> to be out of the range <code>0 &lt;= x &lt;= 1000</code> are valid, but no more operations can be done afterward.</p>

<p>Return <em>the <strong>minimum</strong> number of operations needed to convert </em><code>x = start</code><em> into </em><code>goal</code><em>, and </em><code>-1</code><em> if it is not possible</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,12], start = 2, goal = 12
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can go from 2 &rarr; 14 &rarr; 12 with the following 2 operations.
- 2 + 12 = 14
- 14 - 2 = 12
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,7], start = 0, goal = -4
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can go from 0 &rarr; 3 &rarr; -4 with the following 2 operations. 
- 0 + 3 = 3
- 3 - 7 = -4
Note that the last operation sets x out of the range 0 &lt;= x &lt;= 1000, which is valid.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,8,16], start = 0, goal = 1
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no way to convert 0 into 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i], goal &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= start &lt;= 1000</code></li>
	<li><code>start != goal</code></li>
	<li>All the integers in <code>nums</code> are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-151">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-reverse-operations/description" target="_blank" rel="noopener noreferrer">Minimum Reverse Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">ordered set</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an integer <code>p</code> representing an array <code>arr</code> of length <code>n</code> where all elements are set to 0&#39;s, except position <code>p</code> which is set to 1. You are also given an integer array <code>banned</code> containing restricted positions. Perform the following operation on <code>arr</code>:</p>

<ul>
	<li>Reverse a <span data-keyword="subarray-nonempty"><strong>subarray</strong></span> with size <code>k</code> if the single 1 is not set to a position in <code>banned</code>.</li>
</ul>

<p>Return an integer array <code>answer</code> with <code>n</code> results where the <code>i<sup>th</sup></code> result is<em> </em>the <strong>minimum</strong> number of operations needed to bring the single 1 to position <code>i</code> in <code>arr</code>, or -1 if it is impossible.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, p = 0, banned = [1,2], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1,-1,1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Initially 1 is placed at position 0 so the number of operations we need for position 0 is 0.</li>
	<li>We can never place 1 on the banned positions, so the answer for positions 1 and 2 is -1.</li>
	<li>Perform the operation of size 4 to reverse the whole array.</li>
	<li>After a single operation 1 is at position 3 so the answer for position 3 is 1.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, p = 0, banned = [2,4], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,-1,-1,-1,-1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Initially 1 is placed at position 0 so the number of operations we need for position 0 is 0.</li>
	<li>We cannot perform the operation on the subarray positions <code>[0, 2]</code> because position 2 is in banned.</li>
	<li>Because 1 cannot be set at position 2, it is impossible to set 1 at other positions in more operations.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, p = 2, banned = [0,1,3], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">[-1,-1,0,-1]</span></p>

<p><strong>Explanation:</strong></p>

<p>Perform operations of size 1 and 1 never changes its position.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= p &lt;= n - 1</code></li>
	<li><code>0 &lt;= banned.length &lt;= n - 1</code></li>
	<li><code>0 &lt;= banned[i] &lt;= n - 1</code></li>
	<li><code>1 &lt;= k &lt;= n&nbsp;</code></li>
	<li><code>banned[i] != p</code></li>
	<li>all values in <code>banned</code>&nbsp;are <strong>unique</strong>&nbsp;</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-152">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description" target="_blank" rel="noopener noreferrer">Minimum Score of a Path Between Two Cities</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing <code>n</code> cities numbered from <code>1</code> to <code>n</code>. You are also given a <strong>2D</strong> array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code> indicates that there is a <strong>bidirectional </strong>road between cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with a distance equal to <code>distance<sub>i</sub></code>. The cities graph is not necessarily connected.</p>

<p>The <strong>score</strong> of a path between two cities is defined as the <strong>minimum </strong>distance of a road in this path.</p>

<p>Return <em>the <strong>minimum </strong>possible score of a path between cities </em><code>1</code><em> and </em><code>n</code>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>A path is a sequence of roads between two cities.</li>
	<li>It is allowed for a path to contain the same road <strong>multiple</strong> times, and you can visit cities <code>1</code> and <code>n</code> multiple times along the path.</li>
	<li>The test cases are generated such that there is <strong>at least</strong> one path between <code>1</code> and <code>n</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/12/graph11.png" style="width: 190px; height: 231px;" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 4. The score of this path is min(9,5) = 5.
It can be shown that no other path has less score.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/12/graph22.png" style="width: 190px; height: 231px;" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4. The score of this path is min(2,2,4,7) = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>There are no repeated edges.</li>
	<li>There is at least one path between <code>1</code> and <code>n</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-153">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/description" target="_blank" rel="noopener noreferrer">Minimum Time to Collect All Apples in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an undirected tree consisting of <code>n</code> vertices numbered from <code>0</code> to <code>n-1</code>, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. <em>Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at <strong>vertex 0</strong> and coming back to this vertex.</em></p>

<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Additionally, there is a boolean array <code>hasApple</code>, where <code>hasApple[i] = true</code> means that vertex <code>i</code> has an apple; otherwise, it does not have any apple.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png" style="width: 300px; height: 212px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
<strong>Output:</strong> 8 
<strong>Explanation:</strong> The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_2.png" style="width: 300px; height: 212px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>hasApple.length == n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-154">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Time to Visit a Cell In a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers where <code>grid[row][col]</code> represents the <strong>minimum</strong> time required to be able to visit the cell <code>(row, col)</code>, which means you can visit the cell <code>(row, col)</code> only when the time you visit it is greater than or equal to <code>grid[row][col]</code>.</p>

<p>You are standing in the <strong>top-left</strong> cell of the matrix in the <code>0<sup>th</sup></code> second, and you must move to <strong>any</strong> adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.</p>

<p>Return <em>the <strong>minimum</strong> time required in which you can visit the bottom-right cell of the matrix</em>. If you cannot visit the bottom-right cell, then return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png" /></p>

<pre>
<strong>Input:</strong> grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> One of the paths that we can take is the following:
- at t = 0, we are on the cell (0,0).
- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1.
- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2.
- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3.
- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4.
- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5.
- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6.
- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7.
The final time is 7. It can be shown that it is the minimum time possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png" style="width: 151px; height: 151px;" /></p>

<pre>
<strong>Input:</strong> grid = [[0,2,4],[3,2,1],[1,0,4]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no path from the top left to the bottom-right cell.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[0][0] == 0</code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-modified-dijkstras-algorithm">Approach: Modified Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a matrix <code>grid</code> where each cell contains the minimum time required for that cell to be accessible. In other words, if we begin at the top-left cell and each move takes 1 second, the value in each cell tells us the minimum time after which we can enter it.</p>
<p>The challenge arises when we find ourselves stuck in a cell, unable to move forward because all neighboring cells are inaccessible, with higher minimum times. In such situations, we must &quot;waste&quot; time to move forward. How do we do that? By wandering around! We can move back and forth between the current cell and any previously accessible cells until a neighboring cell becomes accessible.</p>
<p>The time we need to &quot;waste&quot; is determined by the difference between the current cell’s time and the minimum time of an accessible neighboring cell. It’s important to note that each unit of time wasted takes 2 seconds since we travel to a previous cell and return to the current cell. Therefore, if the difference between the current time and the target cell's time is odd, we can step into the target cell exactly when it becomes accessible. Here's a slideshow demonstrating that:</p>
<p>!?!../Documents/2577/odd_slideshow.json:564,822!?!</p>
<p>On the other hand, if the difference is even, we’ll arrive at the target cell 1 second after it has opened:</p>
<p>!?!../Documents/2577/even_slideshow.json:564,822!?!</p>
<p>Next, let’s discuss the base case. If we are at the top-left corner and all neighboring cells have a minimum time greater than 1, we are stuck. There are no other accessible cells to waste time on, and thus, the solution is not possible. In this case, we return -1.</p>
<p>Otherwise, a solution exists. We can apply Dijkstra’s shortest path algorithm with a priority queue, starting from the top-left cell. Each element in the queue holds the cell’s coordinates and the time taken to reach it, ordered by time in ascending order. We also maintain a <code>visited</code> matrix to track the cells we have already processed. For each cell in the queue, we check its neighbors, compute the time required to enter each one, and add any accessible neighbors to the queue, adjusting for the waiting time. When we reach the bottom-right corner, we return the associated time as the final answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Check if both initial moves (right and down) in the grid require more than 1 second:</p>
<ul>
<li>If both <code>grid[0][1] &gt; 1</code> and <code>grid[1][0] &gt; 1</code>, return <code>-1</code> because it’s impossible to proceed.</li>
</ul>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>rows</code> and <code>cols</code> store the dimensions of the grid.</li>
<li><code>directions</code> array defines the possible moves: down, up, right, and left.</li>
<li><code>visited</code> array keeps track of visited cells.</li>
<li><code>pq</code> is a priority queue that stores <code>{time, row, col}</code> tuples, ordered by minimum time to reach each cell.</li>
</ul>
</li>
<li>
<p>Add the starting point (top-left cell) to the priority queue with its initial time (<code>grid[0][0]</code>).</p>
</li>
<li>
<p>While the priority queue is not empty:</p>
<ul>
<li>
<p>Poll the cell with the minimum time (<code>time, row, col</code>).</p>
</li>
<li>
<p>If the target cell (bottom-right) is reached, return the <code>time</code>.</p>
</li>
<li>
<p>Skip the current cell if it has already been visited.</p>
</li>
<li>
<p>Mark the current cell as visited.</p>
</li>
<li>
<p>For each of the four possible directions:</p>
<ul>
<li>Calculate the next cell coordinates (<code>nextRow, nextCol</code>).</li>
<li>If the cell is valid (within bounds and not visited), calculate the additional wait time for the next cell:
<ul>
<li>If the difference between the grid value and the current time is even, the additional wait time is <code>1</code>.</li>
<li>Otherwise, the wait time is <code>0</code>.</li>
</ul>
</li>
<li>Calculate the next possible time based on the grid value and the wait time, and add the new <code>{nextTime, nextRow, nextCol}</code> to the priority queue.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the loop ends without reaching the target, return <code>-1</code> (no path found).</p>
</li>
<li>
<p>Helper function <code>isValid</code>:</p>
<ul>
<li>Check if a cell is within bounds and has not been visited.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/J2vnwBjv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>In the main loop, the priority queue operations (insertion and deletion) take <span class="math inline">\(O(\log k)\)</span> time where <span class="math inline">\(k\)</span> is the number of elements in the queue. Since each cell is added to the queue exactly once, the queue size is bounded by <span class="math inline">\(O(m \cdot n)\)</span>. Therefore, with <span class="math inline">\(O(m \cdot n)\)</span> cells and <span class="math inline">\(O(\log(m \cdot n))\)</span> time for each queue operation, the total time complexity is <span class="math inline">\(O(m \cdot n\log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is determined by two main components: the <code>visited</code> boolean matrix and the priority queue, both of which use <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-155">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-profitable-path-in-a-tree/description" target="_blank" rel="noopener noreferrer">Most Profitable Path in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>At every node <code>i</code>, there is a gate. You are also given an array of even integers <code>amount</code>, where <code>amount[i]</code> represents:</p>

<ul>
	<li>the price needed to open the gate at node <code>i</code>, if <code>amount[i]</code> is negative, or,</li>
	<li>the cash reward obtained on opening the gate at node <code>i</code>, otherwise.</li>
</ul>

<p>The game goes on as follows:</p>

<ul>
	<li>Initially, Alice is at node <code>0</code> and Bob is at node <code>bob</code>.</li>
	<li>At every second, Alice and Bob <b>each</b> move to an adjacent node. Alice moves towards some <strong>leaf node</strong>, while Bob moves towards node <code>0</code>.</li>
	<li>For <strong>every</strong> node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
	<ul>
		<li>If the gate is <strong>already open</strong>, no price will be required, nor will there be any cash reward.</li>
		<li>If Alice and Bob reach the node <strong>simultaneously</strong>, they share the price/reward for opening the gate there. In other words, if the price to open the gate is <code>c</code>, then both Alice and Bob pay&nbsp;<code>c / 2</code> each. Similarly, if the reward at the gate is <code>c</code>, both of them receive <code>c / 2</code> each.</li>
	</ul>
	</li>
	<li>If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node <code>0</code>, he stops moving. Note that these events are <strong>independent</strong> of each other.</li>
</ul>

<p>Return<em> the <strong>maximum</strong> net income Alice can have if she travels towards the optimal leaf node.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/29/eg1.png" style="width: 275px; height: 275px;" />
<pre>
<strong>Input:</strong> edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The above diagram represents the given tree. The game goes as follows:
- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.
  Alice&#39;s net income is now -2.
- Both Alice and Bob move to node 1. 
&nbsp; Since they reach here simultaneously, they open the gate together and share the reward.
&nbsp; Alice&#39;s net income becomes -2 + (4 / 2) = 0.
- Alice moves on to node 3. Since Bob already opened its gate, Alice&#39;s income remains unchanged.
&nbsp; Bob moves on to node 0, and stops moving.
- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.
Now, neither Alice nor Bob can make any further moves, and the game ends.
It is not possible for Alice to get a higher net income.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/29/eg2.png" style="width: 250px; height: 78px;" />
<pre>
<strong>Input:</strong> edges = [[0,1]], bob = 1, amount = [-7280,2350]
<strong>Output:</strong> -7280
<strong>Explanation:</strong> 
Alice follows the path 0-&gt;1 whereas Bob follows the path 1-&gt;0.
Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>1 &lt;= bob &lt; n</code></li>
	<li><code>amount.length == n</code></li>
	<li><code>amount[i]</code> is an <strong>even</strong> integer in the range <code>[-10<sup>4</sup>, 10<sup>4</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a tree with <code>n</code> nodes, where <code>n - 1</code> edges define its structure. The tree is rooted at node <code>0</code>. Additionally, we are provided with an array <code>amount</code> of size <code>n</code>, where each element represents the value of a node. All values in <code>amount</code> are even integers. Finally, we are given an integer <code>bob</code>, which indicates the starting node for Bob.</p>
<p>The two players Alice and Bob, traverse the tree simultaneously under the following conditions:</p>
<ol>
<li>Alice starts at node <code>0</code> and moves towards a leaf node (a node with only one connection).</li>
<li>Bob starts at node <code>bob</code> and moves towards node <code>0</code> along the shortest path.</li>
</ol>
<p>For each node visited, the income calculations follow these rules:</p>
<ul>
<li>If a player reaches a node first, they collect the full value of that node.</li>
<li>If both players arrive at the same node at the same time, they split the value equally.</li>
<li>If a node was previously visited by the other player, no income is collected.</li>
</ul>
<p>Our goal is to find the largest (maximum) income Alice can collect by choosing an optimal path toward a leaf node.</p>
<p>Let's look at an example of finding the maximum income that Alice can achieve:</p>
<p>!?!../Documents/2467/slideshow.json:960,540!?!</p>
<p>In the given example, Bob’s path is fixed since he must travel toward node 0, while Alice has multiple choices for reaching a leaf. Some paths might yield higher income than others due to how Bob’s movements impact the node values. The key is to strategically choose a path that maximizes Alice’s total earnings.</p>
<hr />
<h3 id="approach-1-depth-first-search-and-breadth-first-search">Approach 1: Depth-First Search and Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find Bob’s path to node <code>0</code> and then find the best path Alice can take to maximize her collected amount. Since Bob only has one possible path to node <code>0</code> — the unique path from his starting position to the root — we can take advantage of this structure to track Bob’s travel time across each node.</p>
<p>To find Bob’s path, we use <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">Depth-First Search (DFS)</a>. DFS is a natural choice because it fully explores each path before backtracking, allowing us to efficiently find the path Bob follows to the root. As we traverse, we record how long it takes Bob to reach each node along his path. Nodes not on this path are ignored since Bob never visits them.</p>
<p>Once Bob’s path is established, our next goal is to find Alice’s optimal path to a leaf node. Unlike Bob, Alice has multiple choices since a tree can have multiple leaves. This means we need an approach that considers all possible paths efficiently.</p>
<p>For this, we use <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Breadth-First Search (BFS)</a>. BFS systematically explores all nodes level by level, making it ideal for finding optimal paths. We start at the root node (<code>0</code>) and explore all adjacent nodes before moving deeper into the tree. This ensures that every possible path Alice can take is considered.</p>
<p>As Alice traverses, we use Bob’s path information to determine how much of the amount Alice can collect from each node. If Alice reaches a node before Bob, she takes the <strong>full amount</strong>. If Alice and Bob arrive at the same time, Alice only takes <strong>half</strong>. If Alice arrives after Bob, she gets <strong>nothing</strong> from that node.</p>
<p>Whenever Alice reaches a leaf node, we check her accumulated income along that path. If it is greater than the maximum recorded income, we update our maximum. By the end of the BFS traversal, we will have explored all valid paths for Alice and can return the highest income she can achieve.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>tree</code> as an adjacency list to store the tree structure.</p>
</li>
<li>
<p>Initialize <code>bobPath</code> as a hashmap to track how long it takes Bob to traverse from one node to another.</p>
</li>
<li>
<p>Initialize <code>visited</code> as an array of boolean values to track the explored nodes.</p>
</li>
<li>
<p>Store the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Define a Depth-First Search (DFS) function <code>findBobPath</code>:</p>
<ul>
<li>Set <code>bobPath[sourceNode]</code> to <code>time</code> and <code>visited[sourceNode]</code> to <code>true</code> to mark the current node as explored.</li>
<li>If <code>sourceNode</code> is 0, return <code>true</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>, recursively call <code>findBobPath</code> for the child node and return <code>true</code>.</li>
</ul>
</li>
<li>Remove <code>sourceNode</code>  from <code>bobPath</code> and return <code>false</code>, indicating that <code>sourceNode</code> is not part of Bob's path.</li>
</ul>
</li>
<li>
<p>Define <code>mostProfitablePath</code> function:</p>
<ul>
<li>Initialize <code>maxIncome</code> to 0 to track the maximum income path.</li>
<li>Initialize <code>nodeQueue</code> as a queue of integer arrays of size <code>3</code>, starting with an initial element <code>{0,0,0}</code>.</li>
<li>Set <code>n</code> as the number of nodes.</li>
<li>Resize <code>tree</code> to store <code>n</code> empty lists.</li>
<li>Resize <code>visited</code> to store <code>n</code> boolean values and set each value to <code>false</code>.</li>
<li>Iterate through <code>edges</code> and build the adjacency list representation of the tree.</li>
<li>Call <code>findBobPath(bob, 0)</code> to build Bob's path.</li>
<li>Set the values of <code>visited</code> back to <code>false</code>.</li>
<li>Iterate through the elements in <code>nodeQueue</code>. For each element:
<ul>
<li>Initialize <code>sourceNode</code>, <code>time</code>, and <code>income</code> to the values of the top element of <code>nodeQueue</code>.</li>
<li>If Alice reaches the node first (<code>sourceNode</code> is not in <code>bobPath</code> or <code>bobPath[sourceNode] &gt; time</code>), add <code>amount[sourceNode]</code> to <code>income</code>.</li>
<li>If Alice and Bob reach the node at the same time (<code>bobPath[sourceNode] == time</code>), add half of <code>amount[sourceNode]</code> to <code>income</code>.</li>
<li>If Alice reached a leaf node (<code>tree[sourceNode]</code> only has one value and <code>sourceNode</code> is not <code>0</code>), set <code>maxIncome</code> to the maximum of <code>maxIncome</code> and <code>income</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>:, push an array consisting of <code>adjacentNode</code>, <code>time + 1</code>, and <code>income</code> into <code>nodeQueue</code>.</li>
</ul>
</li>
<li>Set <code>visited[sourceNode]</code> as <code>true</code> to mark the current node as explored.</li>
<li>Remove the current element from <code>nodeQueue</code>.</li>
</ul>
</li>
<li>Return <code>maxIncome</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NTXgC95P/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To begin, to add all the edges to <code>tree</code>, we have to iterate through all the elements of <code>edges</code>, which is of size <span class="math inline">\(n - 1\)</span>. This leads to a time complexity of <span class="math inline">\(O(n - 1)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we have to figure out how long it takes Bob to find the optimal path to node 0. In the worst case, a depth-first search for Bob's path takes <span class="math inline">\(O(n)\)</span> time if Bob traverses through every node to reach node <code>0</code>. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we need to calculate the time it takes for Alice to find the optimal path to a leaf node. Here, a breadth-first search traverses each node until every node has been explored. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these time complexities, the overall time complexity of this solution is <span class="math inline">\(O(3 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the <code>bobPath</code> hashmap, <code>visited</code> and <code>tree</code> arrays,  <code>nodeQueue</code> queue, and the recursive stack.</p>
<p>Firstly, <code>bobPath</code> stores the nodes that bob traverses to reach node 0. In the worst case, Bob has to traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>visited</code> array is initialized to hold <code>n</code> boolean values corresponding to each node, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>tree</code> 2D array is initialized to hold <span class="math inline">\(n\)</span> nodes and <span class="math inline">\(n - 1\)</span> edges. Across all the nodes, the total number of elements stored in the array is <span class="math inline">\(2 \cdot (n - 1)\)</span>, since each edge is stored twice, once for each node. This leads to a space complexity of <span class="math inline">\(O(2 \cdot (n - 1))\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>nodeQueue</code> queue tracks all the nodes being traversed in the breadth-first search. In the worst case, <code>nodeQueue</code> holds all the nodes in the tree if all other nodes are directly adjacent to node 0. This leads to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these space complexities, the overall space complexity of this solution is <span class="math inline">\(O(5 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-depth-first-searches">Approach 2: Two Depth-First Searches</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used BFS to explore all possible paths Alice could take. However, BFS requires maintaining a queue to track nodes at each level, which can introduce overhead when dealing with large trees. Each node needs to be added and removed from the queue multiple times, leading to additional memory usage.</p>
<p>To optimize this, we can replace BFS with DFS for Alice’s traversal. DFS naturally fits the problem because we can reuse the recursive call stack instead of an explicit queue, reducing memory overhead. This makes the approach more space-efficient while still ensuring that all paths are explored.</p>
<p>We start with a <strong>DFS traversal to find Bob’s path</strong> to node <code>0</code>. This step remains unchanged from the previous approach. We record the time Bob takes to reach each node along his path. This information will be used later to determine how much Alice can collect from each node.</p>
<p>Once Bob’s path is identified, we initiate <strong>another DFS traversal for Alice</strong>. During this traversal, we recursively explore each path from node <code>0</code> to a leaf, keeping track of Alice’s time and accumulated income. At each node, we compare Alice’s arrival time with Bob’s recorded time:</p>
<ul>
<li>If Alice arrives <strong>before</strong> Bob, she collects the full amount.</li>
<li>If Alice and Bob arrive <strong>at the same time</strong>, she collects half.</li>
<li>If Alice arrives <strong>after</strong> Bob, she collects nothing.</li>
</ul>
<p>Since DFS explores one path at a time before backtracking, when Alice reaches a leaf node, we record her total collected income and compare it to the current maximum. We repeat this process until all paths are explored.</p>
<p>By the end of the traversal, we will have determined the largest income Alice can achieve and return this value as the result.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>maxIncome</code> to 0 to track the maximum income path.</p>
</li>
<li>
<p>Initialize <code>tree</code> as an adjacency list to store the tree structure.</p>
</li>
<li>
<p>Initialize <code>bobPath</code> as a hashmap to track how long it takes Bob to traverse from one node to another.</p>
</li>
<li>
<p>Initialize <code>visited</code> as an array of boolean values to track the explored nodes.</p>
</li>
<li>
<p>Store the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Define a Depth-First Search (DFS) function <code>findBobPath</code>:</p>
<ul>
<li>Set <code>bobPath[sourceNode]</code> to <code>time</code> and <code>visited[sourceNode]</code> to <code>true</code> to mark the current node as explored.</li>
<li>If <code>sourceNode</code> is 0, return <code>true</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>, recursively call <code>findBobPath</code> for the child node and return <code>true</code>.</li>
</ul>
</li>
<li>Remove <code>sourceNode</code>  from <code>bobPath</code> and return <code>false</code>, indicating that <code>sourceNode</code> is not part of Bob's path.</li>
</ul>
</li>
<li>
<p>Define a Depth-First Search (DFS) function  <code>findAlicePath</code>:</p>
<ul>
<li>Set <code>visited[sourceNode]</code> to <code>true</code> to mark the current node as explored.</li>
<li>If Alice and Bob reach the node at the same time (<code>bobPath[sourceNode] == time</code>), add half of <code>amount[sourceNode]</code> to <code>income</code>.</li>
<li>If Alice reached a leaf node (<code>tree[sourceNode]</code> only has one value and <code>sourceNode</code> is not <code>0</code>), set <code>maxIncome</code> to the maximum of <code>maxIncome</code> and <code>income</code>.</li>
<li>If Alice reached a leaf node (<code>tree[sourceNode]</code> only has one value and <code>sourceNode</code> is not <code>0</code>), set <code>maxIncome</code> to the maximum of <code>maxIncome</code> and <code>income</code>.</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>visited[adjacentNode]</code> is set to <code>false</code>, recursively call <code>findAlicePath</code> for the child node.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Define <code>mostProfitablePath</code> function:</p>
<ul>
<li>Set <code>n</code> as the number of nodes.</li>
<li>Resize <code>tree</code> to store <code>n</code> empty lists.</li>
<li>Resize <code>visited</code> to store <code>n</code> boolean values and set each value to <code>false</code>.</li>
<li>Iterate through <code>edges</code> and build the adjacency list representation of the tree.</li>
<li>Call <code>findBobPath(bob, 0)</code> to build Bob's path.</li>
<li>Set the values of <code>visited</code> back to <code>false</code>.</li>
<li>Call <code>findAlicePath(0, 0, 0, amount)</code> to find Alice's optimal path, starting from the root node.</li>
<li>Return <code>maxIncome</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/UjEiiB3w/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To begin, to add all the edges to <code>tree</code>, we have to iterate through all the elements of <code>edges</code>, which is of size <span class="math inline">\(n - 1\)</span>. This leads to a time complexity of <span class="math inline">\(O(n - 1)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we have to figure out how long it takes Bob to find the optimal path to node 0. In the worst case, a depth-first search for Bob's path takes <span class="math inline">\(O(n)\)</span> time if Bob traverses through every node to reach node 0. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these time complexities, the overall time complexity of this solution is <span class="math inline">\(O(3 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the hashmap <code>bobPath</code>, arrays <code>visited</code> and <code>tree</code>, queue <code>nodeQueue</code>, and recursive stack.</p>
<p>Firstly, <code>bobPath</code> stores the nodes that Bob traverses to reach node <code>0</code>. In the worst case, Bob has to traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>visited</code> array is initialized to hold <code>n</code> boolean values, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>tree</code> 2D array is initialized to hold <span class="math inline">\(n\)</span> nodes and <span class="math inline">\(n - 1\)</span> edges. Across all the nodes, the total number of elements stored in the array is <span class="math inline">\(2(n - 1)\)</span>, since each edge is stored twice, once for each node. This leads to a space complexity of <span class="math inline">\(O(2(n - 1))\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these space complexities, the overall space complexity of this solution is <span class="math inline">\(O(4 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-depth-first-search">Approach 3: Depth-First Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The previous solution used two separate DFS traversals: one to determine Bob’s path and another to explore Alice’s optimal path. However, this causes redundancy, as each node may be visited twice. Instead, we can optimize the process by combining both tasks into a <strong>single DFS traversal</strong>, ensuring that we only explore each node once.</p>
<p>Our strategy is to use DFS to simultaneously track Bob’s path and compute Alice’s best possible income. Here, we first establish Bob’s travel time to each node. We initialize all node distances to <code>n</code>, a value greater than any possible travel time. As we traverse the tree, if a node is part of Bob’s path to <code>0</code>, we update its distance to reflect how long it takes for Bob to reach it. Nodes not on Bob’s path retain their initial value, ensuring that they are always considered as being reached <strong>after</strong> Alice.</p>
<p>With Bob’s travel times recorded, we can now determine how much Alice collects from each node while recursively traversing the tree. As Alice moves, we compare her arrival time at each node to Bob’s recorded time. If she reaches a node before Bob, she collects the <strong>full amount</strong>. If she and Bob arrive at the same time, she gets <strong>half</strong>. If she arrives after Bob, she receives <strong>nothing</strong>. By structuring the traversal this way, Alice's maximum income is updated dynamically as she moves deeper into the tree. This ensures that we efficiently compute the highest possible income while keeping the traversal to just one DFS pass.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>tree</code> as an adjacency list to store the tree structure.</p>
</li>
<li>
<p>Initialize <code>distanceFromBob</code> as an array to store the shortest distance of each node from Bob.</p>
</li>
<li>
<p>Store the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Define a Depth-First Search (DFS) function <code>findPaths</code>:</p>
<ul>
<li>Initialize <code>maxIncome</code> to 0 and <code>maxChild</code> to <code>INT_MIN</code> to track the maximum income path.</li>
<li>If <code>sourceNode</code> is <code>bob</code>, set its distance to 0; otherwise, set it to <code>n</code> (a large value).</li>
<li>Iterate through <code>adjacentNode</code> of <code>sourceNode</code>:
<ul>
<li>If <code>adjacentNode</code> is not <code>parentNode</code>, recursively call <code>findPaths</code> for the child node.</li>
<li>Update <code>distanceFromBob[sourceNode]</code> as the minimum of its current value and the child's distance plus one.</li>
</ul>
</li>
<li>If Alice reaches the node first (<code>distanceFromBob[sourceNode] &gt; time</code>), add the node’s <code>amount</code> to <code>maxIncome</code>.</li>
<li>If Alice and Bob reach the node at the same time (<code>distanceFromBob[sourceNode] == time</code>), add half of <code>amount[sourceNode]</code> to <code>maxIncome</code>.</li>
<li>If <code>maxChild</code> remains <code>INT_MIN</code>, return <code>maxIncome</code> (indicating a leaf node).</li>
<li>Otherwise, return <code>maxIncome + maxChild</code> (adding the best income from child nodes).</li>
</ul>
</li>
<li>
<p>Define <code>mostProfitablePath</code> function:</p>
<ul>
<li>Set <code>n</code> as the number of nodes.</li>
<li>Resize <code>tree</code> to store <code>n</code> empty lists.</li>
<li>Iterate through <code>edges</code> and build the adjacency list representation of the tree.</li>
<li>Resize <code>distanceFromBob</code> to store <code>n</code> distances.</li>
<li>Return the result of <code>findPaths(0, 0, 0, bob, amount)</code>, starting from the root node.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/XuZtsRQF/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To begin, to add all the edges to <code>tree</code>, we have to iterate through all the elements of <code>edges</code>, which is size <span class="math inline">\(n - 1\)</span>. This leads to a time complexity of <span class="math inline">\(O(n - 1)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
<p>Then, we have to figure out how long it takes for Bob to find the path to node <code>0</code> and Alice to find an optimal path to a leaf node. Here, a depth-first search visits each node once to process Alice's maximum income based on Bob's distance from his starting point at each node. This leads to a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these time complexities, the overall time complexity of this solution is <span class="math inline">\(O(2 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the <code>distanceFromBob</code> and <code>tree</code> arrays and the recursive stack.</p>
<p>Firstly, <code>distanceFromBob</code> checks every node in the tree, checking if they were traversed by Bob and, if so, how far they are from Bob's starting point. This leads to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, the <code>tree</code> 2D array is initialized to hold <span class="math inline">\(n\)</span> nodes and <span class="math inline">\(n - 1\)</span> edges. Across all the nodes, the total number of elements stored in the array is <span class="math inline">\(2 \cdot (n - 1)\)</span>, since each edge is stored twice, once for each node. This leads to a space complexity of <span class="math inline">\(O(2 \cdot (n - 1))\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, the recursive stack stores the recursive calls performed in the depth-first search to find Bob's path. Its space is determined by the height of the tree. In the worst case, Bob has to linearly traverse through every node to reach his destination, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Combining these space complexities, the overall space complexity of this solution is <span class="math inline">\(O(3 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-156">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/n-ary-tree-level-order-traversal/description" target="_blank" rel="noopener noreferrer">N-ary Tree Level Order Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes&#39; values.</p>

<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" style="width: 100%; max-width: 300px;" /></p>

<pre>
<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]
<strong>Output:</strong> [[1],[3,2,4],[5,6]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" style="width: 296px; height: 241px;" /></p>

<pre>
<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>Output:</strong> [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>
	<li>The total number of nodes is between <code>[0, 10<sup>4</sup>]</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-157">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/nearest-exit-from-entrance-in-maze/description" target="_blank" rel="noopener noreferrer">Nearest Exit from Entrance in Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>maze</code> (<strong>0-indexed</strong>) with empty cells (represented as <code>&#39;.&#39;</code>) and walls (represented as <code>&#39;+&#39;</code>). You are also given the <code>entrance</code> of the maze, where <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> denotes the row and column of the cell you are initially standing at.</p>

<p>In one step, you can move one cell <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the <strong>nearest exit</strong> from the <code>entrance</code>. An <strong>exit</strong> is defined as an <strong>empty cell</strong> that is at the <strong>border</strong> of the <code>maze</code>. The <code>entrance</code> <strong>does not count</strong> as an exit.</p>

<p>Return <em>the <strong>number of steps</strong> in the shortest path from the </em><code>entrance</code><em> to the nearest exit, or </em><code>-1</code><em> if no such path exists</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg" style="width: 333px; height: 253px;" />
<pre>
<strong>Input:</strong> maze = [[&quot;+&quot;,&quot;+&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;,&quot;.&quot;]], entrance = [1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There are 3 exits in this maze at [1,0], [0,2], and [2,3].
Initially, you are at the entrance cell [1,2].
- You can reach [1,0] by moving 2 steps left.
- You can reach [0,2] by moving 1 step up.
It is impossible to reach [2,3] from the entrance.
Thus, the nearest exit is [0,2], which is 1 step away.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> maze = [[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;]], entrance = [1,0]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There is 1 exit in this maze at [1,2].
[1,0] does not count as an exit since it is the entrance cell.
Initially, you are at the entrance cell [1,0].
- You can reach [1,2] by moving 2 steps right.
Thus, the nearest exit is [1,2], which is 2 steps away.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg" style="width: 173px; height: 93px;" />
<pre>
<strong>Input:</strong> maze = [[&quot;.&quot;,&quot;+&quot;]], entrance = [0,0]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no exits in this maze.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>maze.length == m</code></li>
	<li><code>maze[i].length == n</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>maze[i][j]</code> is either <code>&#39;.&#39;</code> or <code>&#39;+&#39;</code>.</li>
	<li><code>entrance.length == 2</code></li>
	<li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li>
	<li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li>
	<li><code>entrance</code> will always be an empty cell.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-158">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/network-delay-time/description" target="_blank" rel="noopener noreferrer">Network Delay Time</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. You are also given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>, where <code>u<sub>i</sub></code> is the source node, <code>v<sub>i</sub></code> is the target node, and <code>w<sub>i</sub></code> is the time it takes for a signal to travel from source to target.</p>

<p>We will send a signal from a given node <code>k</code>. Return <em>the <strong>minimum</strong> time it takes for all the</em> <code>n</code> <em>nodes to receive the signal</em>. If it is impossible for all the <code>n</code> nodes to receive the signal, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" style="width: 217px; height: 239px;" />
<pre>
<strong>Input:</strong> times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 1
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 2
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= times.length &lt;= 6000</code></li>
	<li><code>times[i].length == 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= w<sub>i</sub> &lt;= 100</code></li>
	<li>All the pairs <code>(u<sub>i</sub>, v<sub>i</sub>)</code> are <strong>unique</strong>. (i.e., no multiple edges.)</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-159">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-closed-islands/description" target="_blank" rel="noopener noreferrer">Number of Closed Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D&nbsp;<code>grid</code> consists of <code>0s</code> (land)&nbsp;and <code>1s</code> (water).&nbsp; An <em>island</em> is a maximal 4-directionally connected group of <code><font face="monospace">0</font>s</code> and a <em>closed island</em>&nbsp;is an island <strong>totally</strong>&nbsp;(all left, top, right, bottom) surrounded by <code>1s.</code></p>

<p>Return the number of <em>closed islands</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png" style="width: 240px; height: 120px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
Islands in gray are closed because they are completely surrounded by water (group of 1s).</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/31/sample_4_1610.png" style="width: 160px; height: 80px;" /></p>

<pre>
<strong>Input:</strong> grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1,1,1],
&nbsp;              [1,0,0,0,0,0,1],
&nbsp;              [1,0,1,1,1,0,1],
&nbsp;              [1,0,1,0,1,0,1],
&nbsp;              [1,0,1,1,1,0,1],
&nbsp;              [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[0].length &lt;= 100</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;=1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D <code>grid</code>. Each cell of <code>grid</code> represents a land or water cell denoted by <code>0</code> and <code>1</code> respectively.</p>
<p>Our task is to return the number of closed islands where a closed island is an island totally (all left, top, right, bottom) surrounded by <code>1s</code>.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem states that an island is formed by connecting all of the '0s' in all four directions (left, top, right, and bottom), which leads us to model the problem as a graph.</p>
<p>We can treat the 2D grid as an undirected graph. A land cell in <code>grid</code> corresponds to a node in such a graph with an undirected edge between horizontally or vertically adjacent land cells.</p>
<p>Let's see what forms an island in such a graph. So, we begin at any node and proceed to its neighbors, i.e., all nodes one edge away. From the nodes 1 edge away, we move to their neighbors, i.e., all the nodes 2 edges away from the starting node, and so on. If we keep traversing until we can't anymore, all the nodes that are visited in this traversal together form an island.</p>
<p>While traversing the island, we look to see if any node in the graph corresponds to a cell at the <code>grid</code>'s boundary. The island does not form a closed island if any node on it is on the <code>grid</code>'s boundary. Otherwise, a closed island is formed if there is no node on the <code>grid</code>'s boundary.</p>
<p>We can use a graph traversal algorithm like breadth-first search (BFS) to traverse over the islands. BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Leetcode Explore Card</a>.</p>
<p>We perform a BFS from every unvisited land cell, treating it as a node. While traversing the island, we check if any node in the island is present on the <code>grid</code>'s boundary. If we have such a node, the island is not a closed island. Otherwise, we have a closed island if we never visit a cell at the <code>grid</code>'s edge. As a result, we add one to our answer variable.</p>
<p>It is important to note that we will not stop the BFS traversal if we come across a node on the boundary. We will perform the complete BFS traversal to cover the entire island so that we can mark all the nodes of the island and not visit any of its nodes again.</p>
<p>Here's a visual step-by-step example:</p>
<p>!?!../Documents/1254/1254_number_of_closed_islands.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the number of rows and columns in the given <code>grid</code>.</li>
<li>Create an answer variable <code>count</code> to keep track of the number of closed islands in <code>grid</code>. We initialize it with <code>0</code>.</li>
<li>Create a 2D array called <code>visit</code> to keep track of visited cells.</li>
<li>Iterate over all the cells of <code>grid</code> and for every cell <code>(i, j)</code> check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a BFS traversal from <code>(i, j)</code> cell:
<ul>
<li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>x</code>, <code>y</code>, <code>m</code>, <code>n</code>, <code>grid</code> and <code>visit</code> as the parameters. The <code>x</code> and <code>y</code> parameters represent the row and column of the cell from which BFS should begin. We start with <code>(i ,j)</code> cell.</li>
<li>We initialize a queue <code>q</code> of pair of integers and push <code>(x, y)</code> into it. We also mark <code>(x, y)</code> as visited.</li>
<li>Create a boolean variable <code>isClosed</code> that stores whether or not the current island is a closed island or not. We initialize it to <code>true</code> because we haven't found any nodes in the island that are on the <code>grid</code> boundary yet.</li>
<li>While the queue is not empty, we dequeue the first pair <code>(x, y)</code> from the queue and iterate over all its neighbors. If any neighboring cell is not in bounds of <code>grid</code>, it means the current <code>(x, y)</code> cell is present at the boundary of <code>grid</code>. We do not have a closed island, and we mark <code>isClosed = false</code>. For each neighboring cell, we check if it is a land cell or not. If it is a land cell and has not been visited yet, we mark it as visited and push <code>(r, c)</code> into the queue.</li>
<li>After the queue is empty, we return <code>isClosed</code>.</li>
<li>If <code>bfs</code> returns <code>true</code>, we increment <code>count</code> by 1 .</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kUdyBASY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the number of rows and columns in the given grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>We iterate over all the cells and find unvisited land cells to perform BFS traversal from those. This takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can be pushed once, leading to <span class="math inline">\(O(m \cdot n)\)</span> operations for <span class="math inline">\(m \cdot n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in <span class="math inline">\(O(4 \cdot m \cdot n) = O(m \cdot n)\)</span> operations total for all the nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> space.</li>
<li>The BFS queue takes <span class="math inline">\(O(m \cdot n)\)</span> space in the worst-case because each node is added once.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we have to traverse over <code>grid</code> modeled as a graph to find the closed islands, another method is to use a depth-first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the number of rows and columns in the given <code>grid</code>.</li>
<li>Create an answer variable <code>count</code> to keep track of the number of closed islands in <code>grid</code>. We initialize it with <code>0</code>.</li>
<li>Create a 2D array called <code>visit</code> to keep track of visited cells.</li>
<li>Iterate over all the cells of <code>grid</code> and for every cell <code>(i, j)</code> check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a DFS traversal from <code>(i, j)</code> cell:
<ul>
<li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>x</code>, <code>y</code>, and <code>grid</code> as the parameters. The <code>x</code> and <code>y</code> parameters represent the row and column of the cell from which DFS should begin. We start with <code>(i ,j)</code> cell.</li>
<li>If the cell <code>(x, y)</code> is out of bounds, it means there was a land cell at the boundary of <code>grid</code> whose neighbor is <code>(x, y)</code>. So, we return <code>false</code> to indicate that this island is not closed.</li>
<li>Else if it is a water cell or an already visited cell, we return <code>true</code>.</li>
<li>Otherwise, we visit this cell and mark it as visited. We create a boolean variable <code>isClosed</code> that stores whether or not the current island is a closed island or not. We initialize it to <code>true</code> because we haven't found any nodes in the island that are on the <code>grid</code> boundary yet.</li>
<li>We then call <code>dfs</code> recursively from each of the neighbors of <code>(x, y)</code>.</li>
<li>If any of the directions leads to a cell in the island at the <code>grid</code> boundary, the island is not closed, and we mark <code>isClosed = false</code>. As discussed above, it is worth noting that in order to mark all the cells of the island, we called <code>dfs</code> individually over each of the four neighbors. We can't simply use <code>dfs(x - 1, y, m, n, grid, visit) &amp;&amp; dfs(x + 1, y, m, n, grid, visit) &amp;&amp; dfs(x, y - 1, m, n, grid, visit) &amp;&amp; dfs(x, y + 1, m, n, grid, visit)</code> because if the first <code>dfs</code> call returns <code>false</code>, the next three <code>dfs</code> calls will not be executed.</li>
<li>If <code>dfs</code> returns <code>true</code>, we increment <code>count</code> by 1.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/HsudNnFS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the number of rows and columns in the given grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>We iterate over all the cells and find unvisited land cells to perform DFS traversal from those. This takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>The <code>dfs</code> function visits each node once, leading to <span class="math inline">\(O(m \cdot n)\)</span> operations for <span class="math inline">\(m \cdot n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in <span class="math inline">\(O(4 \cdot m \cdot n) = O(m \cdot n)\)</span> operations total for all the nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> space.</li>
<li>The recursion stack used by <code>dfs</code> can have no more than <span class="math inline">\(O(m \cdot n)\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(m \cdot n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-160">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-distinct-islands/1" target="_blank" rel="noopener noreferrer">Number of Distinct Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a boolean 2D matrix <strong>grid&nbsp;</strong>of size <strong>n</strong> * <strong>m</strong>. You have to find the number of distinct islands where a group of connected 1s (horizontally or vertically) forms an island. Two islands are considered to be distinct if and only if one island is not equal to another (not rotated or reflected).</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = [[1, 1, 0, 0, 0],
            [1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1],
            [0, 0, 0, 1, 1]]</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">grid[][] = [[<span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>, 0, 0, 0], 
&nbsp;           [<span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>, 0, 0, 0], 
&nbsp;           [0, 0, 0, <span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>], 
&nbsp;           [0, 0, 0, <span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>]]
Same colored islands are equal. We have 2 equal islands, so we have only 1 distinct island.</span>

</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = [[1, 1, 0, 1, 1],
&nbsp;           [1, 0, 0, 0, 0],
&nbsp;           [0, 0, 0, 0, 1],
&nbsp;           [1, 1, 0, 1, 1]]</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:
</strong>grid[][] = [[<span style="color: #ff0000;">1</span>, <span style="color: #ff0000;">1</span>, 0, <span style="color: #00ff00;">1</span>, <span style="color: #00ff00;">1</span>], 
&nbsp;           [<span style="color: #ff0000;">1</span>, 0, 0, 0, 0], 
&nbsp;           [0, 0, 0, 0, <span style="color: #0000cd;">1</span>], 
&nbsp;           [<span style="color: #00ff00;">1</span>, <span style="color: #00ff00;">1</span>, 0, <span style="color: #0000ff;">1</span>, <span style="color: #0000ff;">1</span>]]</span>
<span style="font-size: 18px;">Same colored islands are equal.
We have 4 islands, but 2 of them
are equal, So we have 3 distinct islands.</span>

</pre>
<p><span style="font-size: 18px;"><strong>Your Task: </strong></span><span style="font-size: 18px;">You don't need to read or print anything. Your task is to complete the function <strong>countDistinctIslands()&nbsp;</strong>which takes the <strong>grid</strong> as an input parameter and returns the total number of <strong>distinct</strong> islands.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 500<br />grid[i][j] == 0 or grid[i][j] == 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-161">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-enclaves/description" target="_blank" rel="noopener noreferrer">Number of Enclaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>, where <code>0</code> represents a sea cell and <code>1</code> represents a land cell.</p>

<p>A <strong>move</strong> consists of walking from one land cell to another adjacent (<strong>4-directionally</strong>) land cell or walking off the boundary of the <code>grid</code>.</p>

<p>Return <em>the number of land cells in</em> <code>grid</code> <em>for which we cannot walk off the boundary of the grid in any number of <strong>moves</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg" style="width: 333px; height: 333px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg" style="width: 333px; height: 333px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All 1s are either on the boundary or can reach the boundary.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-162">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-enclaves/1" target="_blank" rel="noopener noreferrer">Number Of Enclaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an <strong>n&nbsp;x m</strong>&nbsp;binary matrix <strong>grid</strong>, where <strong>0</strong> represents a sea cell and <strong>1</strong> represents a land cell.</span></p>
<p><span style="font-size: 18px;">A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.</span></p>
<p><span style="font-size: 18px;">Find the number of land cells in <strong>grid</strong> for which we cannot walk off the boundary of the grid in any number of moves.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = {{0, 0, 0, 0},
            {1, 0, 1, 0},
            {0, 1, 1, 0},
            {0, 0, 0, 0}}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">0 0 0 0
1 0 <strong>1</strong> 0
0 <strong>1</strong> <strong>1</strong> 0
0 0 0 0</span>
<span style="font-size: 18px;">The highlighted cells represents the land cells.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = {{0, 0, 0, 1},
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 1, 1, 0}}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">4</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">0 0 0 1
0 <strong>1</strong> <strong>1</strong> 0
0 <strong>1</strong> <strong>1</strong> 0
0 0 0 1
0 1 1 0</span>
<span style="font-size: 18px;">The highlighted cells represents the land cells.</span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">You don't need to print or input anything. Complete the function <strong>numberOfEnclaves()&nbsp;</strong>which takes a 2D integer matrix <strong>grid&nbsp;</strong>as the input parameter and returns an integer, denoting the number of land cells.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n * m)</span></p>
<p><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(n * m)</span></p>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= n, m &lt;= 500</span></li>
<li><span style="font-size: 18px;">grid[i][j] == 0 or 1</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-163">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-increasing-paths-in-a-grid/description" target="_blank" rel="noopener noreferrer">Number of Increasing Paths in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, where you can move from a cell to any adjacent cell in all <code>4</code> directions.</p>

<p>Return <em>the number of <strong>strictly</strong> <strong>increasing</strong> paths in the grid such that you can start from <strong>any</strong> cell and end at <strong>any</strong> cell. </em>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Two paths are considered different if they do not have exactly the same sequence of visited cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png" style="width: 181px; height: 121px;" />
<pre>
<strong>Input:</strong> grid = [[1,1],[3,4]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -&gt; 3], [1 -&gt; 4], [3 -&gt; 4].
- Paths with length 3: [1 -&gt; 3 -&gt; 4].
The total number of paths is 4 + 3 + 1 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1],[2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -&gt; 2].
The total number of paths is 2 + 1 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-164">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-islands/description" target="_blank" rel="noopener noreferrer">Number of Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>

<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-165">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/description" target="_blank" rel="noopener noreferrer">Number of Nodes in the Sub-Tree With the Same Label</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">counting</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> <code>edges</code>. The <strong>root</strong> of the tree is the node <code>0</code>, and each node of the tree has <strong>a label</strong> which is a lower-case character given in the string <code>labels</code> (i.e. The node with the number <code>i</code> has the label <code>labels[i]</code>).</p>

<p>The <code>edges</code> array is given on the form <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>, which means there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>

<p>Return <em>an array of size <code>n</code></em> where <code>ans[i]</code> is the number of nodes in the subtree of the <code>i<sup>th</sup></code> node which have the same label as node <code>i</code>.</p>

<p>A subtree of a tree <code>T</code> is the tree consisting of a node in <code>T</code> and all of its descendant nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/01/q3e1.jpg" style="width: 400px; height: 291px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = &quot;abaedcd&quot;
<strong>Output:</strong> [2,1,1,1,1,1,1]
<strong>Explanation:</strong> Node 0 has label &#39;a&#39; and its sub-tree has node 2 with label &#39;a&#39; as well, thus the answer is 2. Notice that any node is part of its sub-tree.
Node 1 has a label &#39;b&#39;. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/01/q3e2.jpg" style="width: 300px; height: 253px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[1,2],[0,3]], labels = &quot;bbbb&quot;
<strong>Output:</strong> [4,2,1,1]
<strong>Explanation:</strong> The sub-tree of node 2 contains only node 2, so the answer is 1.
The sub-tree of node 3 contains only node 3, so the answer is 1.
The sub-tree of node 1 contains nodes 1 and 2, both have label &#39;b&#39;, thus the answer is 2.
The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label &#39;b&#39;, thus the answer is 4.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/01/q3e3.jpg" style="width: 300px; height: 253px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = &quot;aabab&quot;
<strong>Output:</strong> [3,2,1,1,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>labels.length == n</code></li>
	<li><code>labels</code> is consisting of only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-166">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-operations-to-make-network-connected/description" target="_blank" rel="noopener noreferrer">Number of Operations to Make Network Connected</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> computers numbered from <code>0</code> to <code>n - 1</code> connected by ethernet cables <code>connections</code> forming a network where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a connection between computers <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Any computer can reach any other computer directly or indirectly through the network.</p>

<p>You are given an initial computer network <code>connections</code>. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.</p>

<p>Return <em>the minimum number of times you need to do this in order to make all the computers connected</em>. If it is not possible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/sample_1_1677.png" style="width: 500px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 4, connections = [[0,1],[0,2],[1,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Remove cable between computer 1 and 2 and place between computers 1 and 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/sample_2_1677.png" style="width: 500px; height: 129px;" />
<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are not enough cables.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= connections.length &lt;= min(n * (n - 1) / 2, 10<sup>5</sup>)</code></li>
	<li><code>connections[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated connections.</li>
	<li>No two computers are connected by more than one cable.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-167">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-provinces/description" target="_blank" rel="noopener noreferrer">Number of Provinces</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p>

<p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p>

<p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>i<sup>th</sup></code> city and the <code>j<sup>th</sup></code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p>

<p>Return <em>the total number of <strong>provinces</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" style="width: 222px; height: 142px;" />
<pre>
<strong>Input:</strong> isConnected = [[1,1,0],[1,1,0],[0,0,1]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" style="width: 222px; height: 142px;" />
<pre>
<strong>Input:</strong> isConnected = [[1,0,0],[0,1,0],[0,0,1]]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>n == isConnected.length</code></li>
	<li><code>n == isConnected[i].length</code></li>
	<li><code>isConnected[i][j]</code> is <code>1</code> or <code>0</code>.</li>
	<li><code>isConnected[i][i] == 1</code></li>
	<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given <code>n</code> cities, some of which are connected to other cities given by an <code>n x n</code> matrix <code>isConnected</code>. The connectivity is transitive, which means that if city <code>a</code> is directly connected with city <code>b</code> and city <code>b</code> is directly connected with city <code>c</code>, then city <code>a</code> is indirectly connected with city <code>c</code>.</p>
<p>A province is defined as a group of directly or indirectly connected cities with no other cities outside of the group.</p>
<p>Our task is to return the total number of provinces.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that two cities <code>x</code> and <code>y</code> belong to the same province if there is a <strong>path</strong> from city <code>x</code> to city <code>y</code> using the cities that are directly connected.</p>
<p>This leads us to consider the problem in terms of graphs.</p>
<p>Each city can be thought of as a node in a graph. The roads that directly connect the cities are the edges. If there is a path in this graph connecting cities <code>x</code> and <code>y</code>, then <code>x</code> and <code>y</code> are in the same province. Because the graph is undirected, <code>x</code> and <code>y</code> belong to the same province if and only if they are part of the same graph component.</p>
<p><strong>The number of required provinces is the number of connected components formed in such a graph.</strong></p>
<p>To check the number of connected components in a graph, we can use a graph traversal algorithm like depth first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p><img src="../Figures/547/547-dfs.png" alt="img" /></p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
<p>To figure out how many connected components there are in the graph, we first mark all nodes as unvisited.</p>
<p>We iterate through all the nodes from <code>0</code> to <code>n - 1</code>, checking whether each <code>node</code> has been visited or not. As the graph is undirected, a DFS traversal from <code>node</code> would visit all of the nodes in the component to which <code>node</code> belongs. Whenever we see an unvisited node while looping through all the nodes, it means we have found a new component. We run the DFS traversal from the unvisited node to traverse over all the nodes in the new component, marking all these nodes as visited to avoid counting a component more than once.</p>
<p>The number of connected components in the graph is equal to the number of unvisited nodes we encounter (the number of times we start a DFS traversal) in this process.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph. Initialize it to <code>0</code>.</li>
<li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a DFS traversal:
<ul>
<li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>node</code>, <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.</li>
<li>We mark <code>node</code> as visited.</li>
<li>We iterate over all the values in <code>isConnected[node]</code> to get the neighbors of <code>node</code>. If <code>isConnected[node][i] == 1</code>, one neighbor of <code>node</code> is <code>i</code> (as we have a direct edge between <code>node</code> and <code>i</code>). For each neighbor <code>i</code> that has not yet been visited, we recursively call <code>dfs</code> with <code>i</code> as the node.</li>
</ul>
</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z8EQGch8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>The <code>dfs</code> function visits each node once, which takes <span class="math inline">\(O(n)\)</span> time because there are <span class="math inline">\(n\)</span> nodes in total. From each <code>node</code>, we iterate over all possible edges using <code>isConnected[node]</code> which takes <span class="math inline">\(O(n)\)</span> time for each visited node. As a result, it takes a total of <span class="math inline">\(O(n^2)\)</span> time to visit all the nodes and iterate over its edges.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we just have to find the number of connected components in the graph, another method is to use a breadth-first search (BFS).</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>Here is an example with the steps:</p>
<p><img src="../Figures/547/547-bfs.png" alt="img" /></p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">LeetCode Explore Card</a>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph. Initialize it to <code>0</code>.</li>
<li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a BFS traversal:
<ul>
<li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>node</code>, <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.</li>
<li>We create an integer queue <code>q</code> and push <code>node</code> into it. We also mark <code>node</code> as visited.</li>
<li>We now loop until the queue is empty. The queue's first element, <code>node</code>, is popped out. We iterate over all the neighbors of <code>node</code> where the neighboring nodes are found using <code>isConnected[node]</code>. If any <code>neighbor</code> has not yet been visited, we mark it as visited and push it into the queue.</li>
</ul>
</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/i3nKSSz5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can only be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. As discussed above, we iterate over all possible edges using <code>isConnected[node]</code> which takes <span class="math inline">\(O(n)\)</span> time for each visited node, resulting in <span class="math inline">\(O(n^2)\)</span> operations in total in the worst-case scenario while visiting all nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The BFS queue takes <span class="math inline">\(O(n)\)</span> because each node is added, and in the worst-case scenario you could have a linear amount of nodes in the queue at once.</li>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space as well.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union-find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving questions based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a union–find data structure or merge–find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. It implements two useful operations:</p>
<ol>
<li><code>Find</code>: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.</li>
<li><code>Union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">LeetCode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Our task, as with the previous approaches, is to count the number of connected components formed in the graph with cities acting as nodes and an edge between directly connected cities.</p>
<p>We initialize all nodes as separate components in the union-find data structure. We create a variable called <code>numberOfComponents</code> to count the number of connected components in the graph and initialize it to the number to the nodes.</p>
<p>We iterate over all the edges, decrementing <code>numberOfComponents</code> by <code>1</code> for each edge whenever two different components are merged into a single one using that edge.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create an instance of <code>UnionFind</code> of size <code>n</code>.</li>
<li>Create an integer variable <code>numberOfComponents</code> to count the number of connected components in the graph. We initialize it to <code>n</code> as each node initially behaves as a separate component.</li>
<li>We iterate over <code>isConnected</code> using two loops, outer loop running from <code>i = 0</code> to <code>n - 1</code> and an inner loop running from <code>j = i + 1</code> to <code>n - 1</code>. For each pair of directly connected cities <code>i</code> and <code>j</code>, i.e., <code>isConnected[i][j] == 1</code>, we use the <code>find</code> operation to determine which components both of them belong to. If they belong to different components, i.e., <code>find(i)!= find(j)</code>, we perform a <code>union</code> operation on both nodes, combining the two different connected components into a single connected component. We also reduce <code>numberOfComponents</code> by one as we just merged two different components. We don't do anything if <code>i</code> and <code>j</code> already belong to the same component.</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/bLutVW9r/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>We need <span class="math inline">\(O(n^2)\)</span> time to iterate over all the values in <code>isConnected</code>.</li>
<li>For <span class="math inline">\(T\)</span> operations, the amortized time complexity of the union-find algorithm (using path compression with union by rank) is <span class="math inline">\(O(alpha(T))\)</span>. Here, <span class="math inline">\(\alpha(T)\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(T\)</span> (approximately <span class="math inline">\( T < 10^{600}\)</span>). You can read more about the complexity of union-find <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity">here</a>.  Because the function grows so slowly, we consider it to be <span class="math inline">\(O(1)\)</span>.</li>
<li>Initializing <code>UnionFind</code> takes <span class="math inline">\(O(n)\)</span> time beacuse we are initializing the <code>parent</code> and <code>rank</code> arrays of size <code>n</code> each.</li>
<li>We iterate through every edge and use the <code>find</code> operation to find the component of nodes connected by each edge. It takes <span class="math inline">\(O(1)\)</span> per operation and takes <span class="math inline">\(O(e)\)</span> time for all the <span class="math inline">\(e\)</span> edges. We can have a maximum of <span class="math inline">\(O(n^2)\)</span> edges in between <span class="math inline">\(n\)</span> nodes (each node is connected to other), so it would take <span class="math inline">\(O(n^2)\)</span> time. If nodes from different components are connected by an edge, we also perform <code>union</code> of the nodes, which takes <span class="math inline">\(O(1)\)</span> time per operation. In the worst-case scenario, it may be called <span class="math inline">\(O(n)\)</span> times to connect all the components to form a connected graph with only one component.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We are using the <code>parent</code> and <code>rank</code> arrays, both of which require <span class="math inline">\(O(n)\)</span> space each.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-168">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/numbers-with-same-consecutive-differences/description" target="_blank" rel="noopener noreferrer">Numbers With Same Consecutive Differences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integers n and k, return <em>an array of all the integers of length </em><code>n</code><em> where the difference between every two consecutive digits is </em><code>k</code>. You may return the answer in <strong>any order</strong>.</p>

<p>Note that the integers should not have leading zeros. Integers as <code>02</code> and <code>043</code> are not allowed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, k = 7
<strong>Output:</strong> [181,292,707,818,929]
<strong>Explanation:</strong> Note that 070 is not a valid number, because it has leading zeroes.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, k = 1
<strong>Output:</strong> [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 9</code></li>
	<li><code>0 &lt;= k &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem asks us to come up a list of digit combinations that follow the defined pattern.<br />
Before jumping to the implementation, it is always helpful to <em>manually</em> deduce some examples.</p>
<p>Suppose that we have <code>N=3</code> and <code>K=2</code>, <em>i.e.</em> we should come up a series of 3-digits numbers, where for each number the difference between each adjacent digits is 2.</p>
<p>Let us try to build the number <em><strong>digit by digit</strong></em>. Starting from the highest digit (in the image), we can pick the digit <code>1</code>.<br />
Then for the next digit, we need to pick <code>3</code> (<em>i.e.</em> <span class="math inline">\(1+2\)</span>).<br />
Finally, for the last digit, we could have two choices: <code>5</code> and <code>1</code> (<em>i.e.</em> <span class="math inline">\(3+2, 3-2\)</span>).<br />
We illustrate the process in the following graph, where each <strong><em>node</em></strong> represents a digit that we pick, and the <strong><em>level</em></strong> of the node corresponds to the position that the digit situates in the final number.</p>
<p><img src="../Figures/967/967_tree_illustration.png" alt="tree illustration" /></p>
<blockquote>
<p>As one might notice that, we just converted the problem into a tree traversal problem, where each path from the root to a leaf forms a solution for the problem.</p>
</blockquote>
<p>As we know, the common algorithms for the tree traversal problem would be <em><strong>DFS</strong></em> (Depth-First Search) and <em><strong>BFS</strong></em> (Breadth-First Search), which are exactly what we will present in the following sections.</p>
<hr />
<h3 id="approach-1-dfs-depth-first-search">Approach 1: DFS (Depth-First Search)</h3>
<p><strong>Intuition</strong></p>
<p>If one is not familiar with the concepts of DFS and BFS, we have an Explore card called <a href="https://leetcode.com/explore/learn/card/queue-stack/">Queue &amp; Stack</a> where we cover the <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">DFS traversal</a> as well as the <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">BFS traversal</a>.</p>
<p>In this section, we will start from the DFS strategy, which arguably is more intuitive for this problem.</p>
<p>As we stated in the overview section, we could build a valid digit combination <em>digit by digit</em> or (node by node in terms of tree).</p>
<p>For a number consisting of <code>N</code> digits, we start from the highest digit and walk through to the lowest digit.<br />
At each step, we might have several candidates that are eligible to be explored.</p>
<p>With the DFS strategy, we prioritize the <em>depth</em> over the <em>breadth</em>, <em>i.e.</em> we pick one of the candidates and continue the exploration before moving on to the other candidates that are of the same level.</p>
<p><strong>Algorithm</strong></p>
<p>Intuitively we could implement the DFS algorithm with recursion. Here we define a recursive function <code>DFS(N, num)</code> (in Python) whose goal is to come up the combinations for the remaining <code>N</code> digits, starting from the current <code>num</code>.<br />
Note that, the signature of the function is slightly different in our Java implementation. Yet, the semantics of the function remains the same.</p>
<p><img src="../Figures/967/967_dfs_example.png" alt="DFS example" /></p>
<p>For instance, in the previous examples, where <code>N=3</code> and <code>K=2</code>, and there is a moment we would invoke <code>DFS(1, 13)</code> which is to add another digit to the existing number <code>13</code> so that the final number meets the requirements.<br />
If the DFS function works properly, we should have the numbers of <code>135</code> and <code>131</code> as results after the invocation.</p>
<p>We could implement the recursive function in the following steps:</p>
<ul>
<li>
<p>As a base case, when <code>N=0</code> <em>i.e.</em> no more remaining digits to complete, we could return the current <code>num</code> as the result.</p>
</li>
<li>
<p>Otherwise, there are still some remaining digits to be added to the current number, <em>e.g.</em> <code>13</code>. There are two potential cases to explore, based on the last digit of the current number which we denote as <code>tail_digit</code>.</p>
<ul>
<li>
<p>Adding the difference <code>K</code> to the last digit, <em>i.e.</em> <code>tail_digit + K</code>.</p>
</li>
<li>
<p>Deducting the difference <code>K</code> from the last digit, <em>i.e.</em> <code>tail_digit - K</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the result of either above case falls into the valid digit range (<em>i.e.</em> <span class="math inline">\([0, 9]\)</span>), we then continue the exploration by invoking the function itself.</p>
</li>
</ul>
<p>Once we implement the <code>DFS(N, num)</code> function, we then simply call this function over the scope of <span class="math inline">\([1, 9]\)</span>, <em>i.e.</em> the valid digits for the highest position.</p>
<p><strong>Note</strong>: <em>If we are asked to return numbers of a single digit (<em>i.e.</em> <code>N=1</code>), then regardless of <code>K</code>, all digits are valid, including zero.</em><br />
We treat this as a special case in the code, since in our implementation of DFS function, we will never return zero as the result.</p>
<p><a href="https://leetcode.com/playground/o99eFuUT/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of digits for a valid combination, and <span class="math inline">\(K\)</span> be the difference between digits.</p>
<p>First of all, let us estimate the number of potential solutions.<br />
For the highest digit, we could have 9 potential candidates.<br />
Starting from the second highest position, we could have at most 2 candidates for each position.<br />
Therefore, at most, we could have <span class="math inline">\(9 \cdot 2^{N-1}\)</span> solutions, for <span class="math inline">\(N > 1\)</span>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>Essentially, the execution of the algorithm will unfolder itself as a binary tree, where each node in the tree represents an invocation of the <code>DFS()</code> function.<br />
The execution of the <code>DFS()</code> function itself takes a constant time.<br />
Therefore, the overall time complexity is proportional to the number of nodes in the execution binary tree.</p>
</li>
<li>
<p>In the worst case, the total number of nodes in a binary tree of depth <span class="math inline">\(N-1\)</span> is <span class="math inline">\(2^N\)</span>.<br />
Hence, the overall time complexity of the algorithm is <span class="math inline">\(\mathcal{O}(2^{N})\)</span>.</p>
</li>
<li>
<p>Note that, when <span class="math inline">\(K = 0\)</span>, at each position, there is only one possible candidate, <em>e.g.</em> <span class="math inline">\(333\)</span>.<br />
In total, we would have 9 numbers in the result set, and each number is of <span class="math inline">\(N\)</span> digits. The time complexity would then be reduced down to <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>Since we adopt a recursive solution, we would have some additional memory consumption on the function call stack. The maximum number of consecutive calls on the recursion function is <span class="math inline">\(N\)</span>. Hence, the space complexity for the call stack is <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
<li>
<p>We use a list to keep all the solutions, which could amount to <span class="math inline">\(9 \cdot 2^{N-1}\)</span> number of elements.</p>
</li>
<li>
<p>To sum up, the overall space complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N) + \mathcal{O}(9 \cdot 2^{N-1}) = \mathcal{O}(2^{N})\)</span>.</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-bfs-breadth-first-search">Approach 2: BFS (Breadth-First Search)</h3>
<p><strong>Intuition</strong></p>
<p>It might be more intuitive to come up a DFS solution as we presented before.<br />
However, it is also viable to solve this problem with <em>BFS</em> (Breadth-First Search) traversal strategy.</p>
<blockquote>
<p>Rather than building the solution one by one, we could do it <em>batch by batch</em>, <em>i.e.</em> level by level.</p>
</blockquote>
<p>Each level contains the numbers that are of the same amount of digits.<br />
Also, each level corresponds to the solutions with a specific number of digits.</p>
<p><img src="../Figures/967/967_BFS.png" alt="BFS" /></p>
<p>For example, given <code>N=3</code> and <code>K=7</code>, at the first level, we would have potentially 9 candidates (<em>i.e.</em> <code>[1, 2, 3, 4, 5, 7, 8, 9]</code>).<br />
When we move on to the second level, the candidates are reduced down to <code>[18, 29, 70, 81, 92]</code>.<br />
Finally, at the last level, we would have the solutions as <code>[181, 292, 707, 818, 929]</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Here are a few steps to implement the BFS algorithm for this problem.</p>
<ul>
<li>
<p>We could implement the algorithm with nested two-levels loops, where the outer loop iterates through levels and the inner loop handles the elements within each level.</p>
</li>
<li>
<p>We could use a list data structure to keep the numbers for a single level, <em>i.e.</em> here we name the variable as <code>queue</code>.</p>
</li>
<li>
<p>For each number in the queue, we could apply the same logics as in the DFS approach, except the last step, rather than making a recursive call for the next number we simply append the number to the queue for the next level.</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/5ajtXWDv/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of digits for a valid combination, and <span class="math inline">\(K\)</span> be the difference between digits.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>Essentially with the BFS approach, all the intermeidate candidates form a binary tree, same as the execution tree as in the DFS approach.<br />
Only this time, we traverse in a breadth-first manner, rather than the depth-first.</p>
</li>
<li>
<p>Therefore, the overall time complexity of the algorithm would be <span class="math inline">\(\mathcal{O}(2^{N})\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>We use two queues to maintain the intermediate solutions, which contain no more than two levels of elements.<br />
The number of elements at the level of <span class="math inline">\(i\)</span> is up to <span class="math inline">\(9 \cdot 2^{i-1}\)</span>.</p>
</li>
<li>
<p>To sum up, the space complexity of the algorithm would be <span class="math inline">\(\mathcal{O}(9 \cdot 2^{N-1} + 9 \cdot 2^{N-2}) = \mathcal{O}(2^N)\)</span>.</p>
</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-169">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/open-the-lock/description" target="_blank" rel="noopener noreferrer">Open the Lock</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code>. The wheels can rotate freely and wrap around: for example we can turn <code>&#39;9&#39;</code> to be <code>&#39;0&#39;</code>, or <code>&#39;0&#39;</code> to be <code>&#39;9&#39;</code>. Each move consists of turning one wheel one slot.</p>

<p>The lock initially starts at <code>&#39;0000&#39;</code>, a string representing the state of the 4 wheels.</p>

<p>You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p>

<p>Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.
Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> deadends = [&quot;8888&quot;], target = &quot;0009&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> We cannot reach the target without getting stuck.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= deadends.length &lt;= 500</code></li>
	<li><code>deadends[i].length == 4</code></li>
	<li><code>target.length == 4</code></li>
	<li>target <strong>will not be</strong> in the list <code>deadends</code>.</li>
	<li><code>target</code> and <code>deadends[i]</code> consist of digits only.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>For simplicity, let's say any combination of any state of all wheels represents one lock combination. e.g. <code>'0000', '1000', '2000', ... </code> etc. all represent a lock combination.</p>
<p>Say we are currently at combination <code>'0000'</code>, and we make one wheel turn. Now we are at combination <code>1000</code>. This combination change due to one wheel turn can be visualized as traversing a graph from node 1 (<code>combination '0000'</code>) to node 2 (<code>combination '1000'</code>).</p>
<p>It can be better understood with the help of the following image:</p>
<p><img src="../Figures/752/Slide1.jpg" alt="graph_visalization" /></p>
<p>In this graph, each node represents a lock combination, and the edge represents one wheel turn.</p>
<p>According to the problem statement, we start from the lock combination <code>'0000'</code>. We can make one wheel turn at a time and need to find the minimum steps required to reach the target lock combination.</p>
<p>As we observed, each lock combination is a graph's node, and each wheel turn is an edge connecting two nodes. The given problem statement can be re-worded as: &quot;We start from node <code>lock combination '0000'</code> and have to find the minimum number of edges to traverse to reach the target lock combination node.&quot; Thus, the given problem can be converted into a graph traversal problem.</p>
<p>To traverse nodes in a graph, we mainly utilize two algorithms: depth-first search (DFS), and breadth-first search (BFS). If you are new to these algorithms we recommend reading our <a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/3882/">Depth-First Search</a> and <a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/3883/">Breadth-First Search</a> explore cards.</p>
<p>We can solve this problem using both traversals, but given the constraints, the depth-first search will result in a TLE. This is because DFS explores as deeply as possible along each branch before backtracking. It doesn't necessarily explore nodes in any particular order; it might go deep into a branch before exploring other branches.</p>
<p>BFS is well-suited for finding the shortest path in unweighted graphs, which makes it a good fit for this problem because BFS explores nodes level by level. It starts from the source node and explores all its neighbors before moving on to the next level of neighbors. Due to its level-order exploration strategy, BFS guarantees that the first time it reaches a node, it has found the shortest path to that node.</p>
<p><img src="../Figures/752/Slide2.jpg" alt="dfs_vs_bfs" /></p>
<br />
<p><strong>Note:</strong> Being familiar with level-order traversal using breadth-first search will help you solve this problem. If you need to brush up, you can practice these LeetCode problems first:</p>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></li>
<li><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></li>
<li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></li>
</ul>
<hr />
<h3 id="approach-breadth-first-search">Approach: Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We will keep a queue, <code>pending_combinations</code>, containing the lock combinations yet to be visited using BFS.<br />
Initially, it will contain the starting combination <code>'0000'</code>.</p>
<p>We will visit each combination stored in the queue one by one. If the current popped combination is the target combination, we will return the number of edges traversed (number of wheel turns we made) to reach this combination. BFS guarantees the shortest path in an unweighted graph, so as soon as we find an answer, we know it is the optimal one.<br />
Otherwise, we will generate new combinations from the current combination, by rotating each of the four wheels to the next slot digit and the previous slot digit one by one. Then we will push the new combinations into the queue.</p>
<p><img src="../Figures/752/Slide3.jpg" alt="wheel_turn" /></p>
<p>We will keep two additional data structures to quickly fetch the next and the previous slot digits for the current slot digits whenever needed.</p>
<br />
<p>Notice that we might reach the same lock combinations, again and again, using different paths, and these duplicate combinations will always generate the same next combinations.</p>
<p><img src="../Figures/752/Slide4.jpg" alt="duplicate" /></p>
<p>So, we will keep one additional data structure to mark visited combinations to avoid traversing on a combination more than once.<br />
We also have some dead-end combinations from which we can't proceed further. We can consider these combinations as visited combinations because we cannot generate new combinations using these combinations.</p>
<p>Thus, we will keep a hash set <code>visited_combinations</code>, insert the dead-end combinations in it initially, and will insert the visited combinations while doing the BFS.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialization:</p>
<ul>
<li>Create two character maps, <code>next_slot</code> to map the current slot digit with its next slot digit, and <code>prev_slot</code> to map the current slot digit with its previous slot digit.</li>
<li>Create a hash set <code>visited_combinations</code>, initially containing all <code>deadends</code> array combinations.</li>
<li>Create a queue <code>pending_combinations</code> to traverse all combinations in level-wise BFS.</li>
<li>Create an integer variable <code>turns</code> initially storing <code>0</code>, to denote the number of wheel turns made.</li>
</ul>
</li>
<li>
<p>If <code>visited_combinations</code> contains the starting combination <code>'0000'</code> then we can never reach the target combination and will return <code>-1</code>.</p>
</li>
<li>
<p>Insert the starting combination <code>'0000'</code> in the queue and mark it as visited.</p>
</li>
<li>
<p>While there are elements in the queue, iterate on all current level combinations using a for loop:</p>
<ul>
<li>Pop the current combination from the front of the queue.</li>
<li>If the current combination is the target combination return <code>turns</code>.</li>
<li>Otherwise, iterate on all four wheels; for each wheel, generate the new combination by turning the respective wheel to the next slot and the previous slot. If the new combination is not present in <code>visited_combinations</code> then push it in the queue and mark it as visited.</li>
<li>After iterating on all current level combinations increment <code>turns</code> by <code>1</code>.</li>
</ul>
</li>
<li>
<p>If we never reach the target combination, then, return <code>-1</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ABn2uKao/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n = 10\)</span> is the number of slots on a wheel, <span class="math inline">\(w = 4\)</span> is the number of wheels, and <span class="math inline">\(d\)</span> is the number of elements in the <code>deadends</code> array.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(4(d + 10^4))\)</span>
<ul>
<li>Initializing the hash maps with <span class="math inline">\(n\)</span> key-value pairs, and the hash set with <span class="math inline">\(d\)</span> combinations of length <span class="math inline">\(w\)</span> will take <span class="math inline">\(O(2 \cdot n)\)</span> and <span class="math inline">\(O(d \cdot w)\)</span> time respectively.</li>
<li>In the worst case, we might iterate on all <span class="math inline">\(n^w\)</span> unique combinations, and for each combination, we perform <span class="math inline">\(2 \cdot w\)</span> turns. Thus, it will take <span class="math inline">\(O(n^w \cdot 2 \cdot w) = O(n^w \cdot w)\)</span> time.</li>
<li>So, this approach will take <span class="math inline">\(O(n + (d + n^w) \cdot w) = O(10 + (d + 10^4) \cdot 4) = O(4(d + 10^4))\)</span> time.</li>
</ul>
</li>
<li>Space complexity: <span class="math inline">\(O(4(d + 10^4))\)</span>
<ul>
<li>The hash maps with <span class="math inline">\(n\)</span> key-value pairs, and the hash set with <span class="math inline">\(d\)</span> combinations of length <span class="math inline">\(w\)</span> will take <span class="math inline">\(O(2 \cdot n)\)</span> and <span class="math inline">\(O(d \cdot w)\)</span> space respectively.</li>
<li>In the worst case, we might push all <span class="math inline">\(n^w\)</span> unique combinations of length <span class="math inline">\(w\)</span> in the queue and the hash set. Thus, it will take <span class="math inline">\(O(n^w \cdot w)\)</span> space.</li>
<li>So, this approach will take <span class="math inline">\(O(n + (d + n^w) \cdot w) = O(4(d + 10^4))\)</span> space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-170">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/operations-on-tree/description" target="_blank" rel="noopener noreferrer">Operations on Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a tree with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> in the form of a parent array <code>parent</code> where <code>parent[i]</code> is the parent of the <code>i<sup>th</sup></code> node. The root of the tree is node <code>0</code>, so <code>parent[0] = -1</code> since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.</p>

<p>The data structure should support the following functions:</p>

<ul>
	<li><strong>Lock:</strong> <strong>Locks</strong> the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.</li>
	<li><strong>Unlock: Unlocks</strong> the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.</li>
	<li><b>Upgrade</b><strong>: Locks</strong> the given node for the given user and <strong>unlocks</strong> all of its descendants <strong>regardless</strong> of who locked it. You may only upgrade a node if <strong>all</strong> 3 conditions are true:
	<ul>
		<li>The node is unlocked,</li>
		<li>It has at least one locked descendant (by <strong>any</strong> user), and</li>
		<li>It does not have any locked ancestors.</li>
	</ul>
	</li>
</ul>

<p>Implement the <code>LockingTree</code> class:</p>

<ul>
	<li><code>LockingTree(int[] parent)</code> initializes the data structure with the parent array.</li>
	<li><code>lock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to lock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become<strong> locked</strong> by the user with id <code>user</code>.</li>
	<li><code>unlock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to unlock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become <strong>unlocked</strong>.</li>
	<li><code>upgrade(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to upgrade the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will be <strong>upgraded</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/29/untitled.png" style="width: 375px; height: 246px;" />
<pre>
<strong>Input</strong>
[&quot;LockingTree&quot;, &quot;lock&quot;, &quot;unlock&quot;, &quot;unlock&quot;, &quot;lock&quot;, &quot;upgrade&quot;, &quot;lock&quot;]
[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
<strong>Output</strong>
[null, true, false, true, true, true, false]

<strong>Explanation</strong>
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // return true because node 2 is unlocked.
                           // Node 2 will now be locked by user 2.
lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
                           // Node 2 will now be unlocked.
lockingTree.lock(4, 5);    // return true because node 4 is unlocked.
                           // Node 4 will now be locked by user 5.
lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
lockingTree.lock(0, 1);    // return false because node 0 is already locked.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == parent.length</code></li>
	<li><code>2 &lt;= n &lt;= 2000</code></li>
	<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for <code>i != 0</code></li>
	<li><code>parent[0] == -1</code></li>
	<li><code>0 &lt;= num &lt;= n - 1</code></li>
	<li><code>1 &lt;= user &lt;= 10<sup>4</sup></code></li>
	<li><code>parent</code> represents a valid tree.</li>
	<li>At most <code>2000</code> calls <strong>in total</strong> will be made to <code>lock</code>, <code>unlock</code>, and <code>upgrade</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-171">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/pacific-atlantic-water-flow/description" target="_blank" rel="noopener noreferrer">Pacific Atlantic Water Flow</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <code>m x n</code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocean</strong> touches the island&#39;s left and top edges, and the <strong>Atlantic Ocean</strong> touches the island&#39;s right and bottom edges.</p>

<p>The island is partitioned into a grid of square cells. You are given an <code>m x n</code> integer matrix <code>heights</code> where <code>heights[r][c]</code> represents the <strong>height above sea level</strong> of the cell at coordinate <code>(r, c)</code>.</p>

<p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell&#39;s height is <strong>less than or equal to</strong> the current cell&#39;s height. Water can flow from any cell adjacent to an ocean into the ocean.</p>

<p>Return <em>a <strong>2D list</strong> of grid coordinates </em><code>result</code><em> where </em><code>result[i] = [r<sub>i</sub>, c<sub>i</sub>]</code><em> denotes that rain water can flow from cell </em><code>(r<sub>i</sub>, c<sub>i</sub>)</code><em> to <strong>both</strong> the Pacific and Atlantic oceans</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg" style="width: 400px; height: 400px;" />
<pre>
<strong>Input:</strong> heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
<strong>Output:</strong> [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
<strong>Explanation:</strong> The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -&gt; Pacific Ocean 
&nbsp;      [0,4] -&gt; Atlantic Ocean
[1,3]: [1,3] -&gt; [0,3] -&gt; Pacific Ocean 
&nbsp;      [1,3] -&gt; [1,4] -&gt; Atlantic Ocean
[1,4]: [1,4] -&gt; [1,3] -&gt; [0,3] -&gt; Pacific Ocean 
&nbsp;      [1,4] -&gt; Atlantic Ocean
[2,2]: [2,2] -&gt; [1,2] -&gt; [0,2] -&gt; Pacific Ocean 
&nbsp;      [2,2] -&gt; [2,3] -&gt; [2,4] -&gt; Atlantic Ocean
[3,0]: [3,0] -&gt; Pacific Ocean 
&nbsp;      [3,0] -&gt; [4,0] -&gt; Atlantic Ocean
[3,1]: [3,1] -&gt; [3,0] -&gt; Pacific Ocean 
&nbsp;      [3,1] -&gt; [4,1] -&gt; Atlantic Ocean
[4,0]: [4,0] -&gt; Pacific Ocean 
       [4,0] -&gt; Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> heights = [[1]]
<strong>Output:</strong> [[0,0]]
<strong>Explanation:</strong> The water can flow from the only cell to the Pacific and Atlantic oceans.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == heights.length</code></li>
	<li><code>n == heights[r].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= heights[r][c] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-172">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/pacific-atlantic-water-flow/1" target="_blank" rel="noopener noreferrer">Pacific Atlantic Water Flow</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a matrix <strong>mat[][]</strong> of dimensions <strong>n x m</strong>, where mat[i][j] represents the <strong>height of a cell</strong> in a rectangular grid island. The <strong>Pacific Ocean</strong> touches the island's <strong>left and top</strong> borders, and the <strong>Atlantic Ocean</strong> touches the island's <strong>right and bottom</strong> borders. Rainwater can flow from a cell to its neighbouring cells in the directions North, South, East, and West, but only if the <strong>neighbouring cell has a height less than or equal to the current cell's height</strong>.</span></p>
<p><span style="font-size: 18px;">The task is to determine <strong>all coordinates (x, y)</strong> such that water can flow from the cell (x, y) to <strong>both</strong> the Pacific Ocean and the Atlantic Ocean. Water can flow from any adjacent cell directly into an ocean.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[1, 2, 2, 3, 5],<br />                [3, 2, 3, 4, 4],<br />                [2, 4, 5, 3, 1],<br />                [6, 7, 1, 4, 5],<br />                [5, 1, 1, 2, 4]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> </span><span style="font-size: 18px;">In the given matrix, there are 7 coordinates through which the water can flow to both the Oceans</span>. They are  (0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), and (4, 0).</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[][] = [[2, 2], <br />               [2, 2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> </span><span style="font-size: 18px;">In the following example, all cells allow water to flow to both the Oceans.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; number of rows,&nbsp;</span><span style="font-size: 18px;">number of columns</span><span style="font-size: 18px;">&nbsp;&le; 10</span><sup>3<br /></sup><span style="font-size: 18px;">1 &le; arr[i][j] &le; 10<sup>3</sup>&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-173">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-sum/description" target="_blank" rel="noopener noreferrer">Path Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>

<p>A <strong>leaf</strong> is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" style="width: 500px; height: 356px;" />
<pre>
<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
<strong>Output:</strong> true
<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" />
<pre>
<strong>Input:</strong> root = [1,2,3], targetSum = 5
<strong>Output:</strong> false
<strong>Explanation:</strong> There are two root-to-leaf paths in the tree:
(1 --&gt; 2): The sum is 3.
(1 --&gt; 3): The sum is 4.
There is no root-to-leaf path with sum = 5.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [], targetSum = 0
<strong>Output:</strong> false
<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
	<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-174">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/path-with-minimum-effort/1" target="_blank" rel="noopener noreferrer">Path With Minimum Effort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are a hiker preparing for an upcoming hike. You are given&nbsp;<strong><code>heights[][]</code></strong>, a 2D array of size&nbsp;<code><strong>rows x columns</strong></code>, where&nbsp;<strong><code>heights[row][col]</code></strong>&nbsp;represents the height of cell&nbsp;<code><strong>(row, col)</strong></code>. You are situated in the top-left cell,&nbsp;<code><strong>(0, 0)</strong></code>, and you hope to travel to the bottom-right cell,&nbsp;<code><strong>(rows-1, columns-1)</strong></code>&nbsp;(i.e.,&nbsp;<strong>0-indexed</strong>). You can move&nbsp;<strong>up</strong>,&nbsp;<strong>down</strong>,&nbsp;<strong>left</strong>, or&nbsp;<strong>right</strong>, and you wish to find the route with minimum <strong>effort</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note: </strong>A route's <strong>effort</strong>&nbsp;is the&nbsp;<strong>maximum absolute difference</strong><strong>&nbsp;</strong>in heights between two consecutive cells of the route.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong><br />row = 3<br />columns = 3 <br />heights = [[1,2,2],[3,8,2],[5,3,5]]
<strong>Output:</strong> <br />2
<strong>Explanation:</strong> <br />The route 1-&gt;3-&gt;5-&gt;3-&gt;5 has a maximum absolute difference of 2 in consecutive cells. This is better than the route 1-&gt;2-&gt;2-&gt;2-&gt;5, where the maximum absolute difference is 3.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong><br />row = 2<br />columns = 2 <br />heights = [[7,7],[7,7]]
<strong>Output:</strong> <br />0
<strong>Explanation:</strong> <br />Any route from the top-left cell to the bottom-right cell has a maximum absolute difference of 0 in consecutive cells.<br /></span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>MinimumEffort()&nbsp;</strong>which takes intergers <strong>rows</strong>, <strong>columns,</strong> and the 2D array <strong>heights[][] </strong><strong>&nbsp;</strong>and returns the<em> </em><strong>minimum</strong>&nbsp;<strong>effort</strong>&nbsp;required to travel from the top-left cell to the bottom-right cell<em>.</em></span></p>
<p><span style="font-size: 18px;"><strong style="font-family: monospace; font-size: 18px;">Expected Time Complexity:&nbsp;</strong><span style="font-family: monospace; font-size: 18px; background-color: #b4d7ff;">O(rowsxcolumns)</span><br style="font-family: monospace; font-size: 18px;" /><strong style="font-family: monospace; font-size: 18px;">Expected Space Complexity:&nbsp;</strong><span style="font-family: monospace; font-size: 18px; background-color: #b4d7ff;">O(rowsxcolumns)</span></span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong><span style="font-family: monospace; background-color: #b4d7ff;">1 &lt;= rows, columns &lt;= 100</span><strong><br /></strong></span><span style="font-size: 18px;"><code>rows == heights.length<br />
columns == heights[i].length<br />0 &lt;= heights[i][j] &lt;= 10<sup>6</sup></code></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-175">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-minimum-effort/description" target="_blank" rel="noopener noreferrer">Path With Minimum Effort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are a hiker preparing for an upcoming hike. You are given <code>heights</code>, a 2D array of size <code>rows x columns</code>, where <code>heights[row][col]</code> represents the height of cell <code>(row, col)</code>. You are situated in the top-left cell, <code>(0, 0)</code>, and you hope to travel to the bottom-right cell, <code>(rows-1, columns-1)</code> (i.e.,&nbsp;<strong>0-indexed</strong>). You can move <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>, and you wish to find a route that requires the minimum <strong>effort</strong>.</p>

<p>A route&#39;s <strong>effort</strong> is the <strong>maximum absolute difference</strong><strong> </strong>in heights between two consecutive cells of the route.</p>

<p>Return <em>the minimum <strong>effort</strong> required to travel from the top-left cell to the bottom-right cell.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex1.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,2],[3,8,2],[5,3,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex2.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,3],[3,8,4],[5,3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex3.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> This route does not require any effort.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == heights.length</code></li>
	<li><code>columns == heights[i].length</code></li>
	<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
	<li><code>1 &lt;= heights[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-176">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/perfect-squares/description" target="_blank" rel="noopener noreferrer">Perfect Squares</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p>

<p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 12
<strong>Output:</strong> 3
<strong>Explanation:</strong> 12 = 4 + 4 + 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 13
<strong>Output:</strong> 2
<strong>Explanation:</strong> 13 = 4 + 9.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-177">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/populating-next-right-pointers-in-each-node/description" target="_blank" rel="noopener noreferrer">Populating Next Right Pointers in Each Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>

<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>

<p>Initially, all next pointers are set to <code>NULL</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" style="width: 500px; height: 171px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]
<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong></p>

<ul>
	<li>You may only use constant extra space.</li>
	<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-178">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description" target="_blank" rel="noopener noreferrer">Populating Next Right Pointers in Each Node II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree</p>

<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>

<p>Initially, all next pointers are set to <code>NULL</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" style="width: 500px; height: 171px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,null,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]
<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 6000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong></p>

<ul>
	<li>You may only use constant extra space.</li>
	<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-179">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/possible-bipartition/description" target="_blank" rel="noopener noreferrer">Possible Bipartition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We want to split a group of <code>n</code> people (labeled from <code>1</code> to <code>n</code>) into two groups of <strong>any size</strong>. Each person may dislike some other people, and they should not go into the same group.</p>

<p>Given the integer <code>n</code> and the array <code>dislikes</code> where <code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that the person labeled <code>a<sub>i</sub></code> does not like the person labeled <code>b<sub>i</sub></code>, return <code>true</code> <em>if it is possible to split everyone into two groups in this way</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, dislikes = [[1,2],[1,3],[2,4]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The first group has [1,4], and the second group has [2,3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, dislikes = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> false
<strong>Explanation:</strong> We need at least 3 groups to divide them. We cannot put them in two groups.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2000</code></li>
	<li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li>
	<li><code>dislikes[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= n</code></li>
	<li>All the pairs of <code>dislikes</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-180">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/power-grid-maintenance/description" target="_blank" rel="noopener noreferrer">Power Grid Maintenance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="401" data-start="120">You are given an integer <code data-end="194" data-start="191">c</code> representing <code data-end="211" data-start="208">c</code> power stations, each with a unique identifier <code>id</code> from 1 to <code>c</code> (1‑based indexing).</p>

<p data-end="401" data-start="120">These stations are interconnected via <code data-end="295" data-start="292">n</code> <strong>bidirectional</strong> cables, represented by a 2D array <code data-end="357" data-start="344">connections</code>, where each element <code data-end="430" data-start="405">connections[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates a connection between station <code>u<sub>i</sub></code> and station <code>v<sub>i</sub></code>. Stations that are directly or indirectly connected form a <strong>power grid</strong>.</p>

<p data-end="626" data-start="586">Initially, <strong>all</strong> stations are online (operational).</p>

<p data-end="720" data-start="628">You are also given a 2D array <code data-end="667" data-start="658">queries</code>, where each query is one of the following <em>two</em> types:</p>

<ul data-end="995" data-start="722">
	<li data-end="921" data-start="722">
	<p data-end="921" data-start="724"><code data-end="732" data-start="724">[1, x]</code>: A maintenance check is requested for station <code data-end="782" data-start="779">x</code>. If station <code>x</code> is online, it resolves the check by itself. If station <code>x</code> is offline, the check is resolved by the operational station with the smallest <code>id</code> in the same <strong>power grid</strong> as <code>x</code>. If <strong>no</strong> <strong>operational</strong> station <em>exists</em> in that grid, return -1.</p>
	</li>
	<li data-end="995" data-start="923">
	<p data-end="995" data-start="925"><code data-end="933" data-start="925">[2, x]</code>: Station <code data-end="946" data-start="943">x</code> goes offline (i.e., it becomes non-operational).</p>
	</li>
</ul>

<p data-end="1106" data-start="997">Return an array of integers representing the results of each query of type <code data-end="1080" data-start="1072">[1, x]</code> in the <strong>order</strong> they appear.</p>

<p data-end="1106" data-start="997"><strong>Note:</strong> The power grid preserves its structure; an offline (non‑operational) node remains part of its grid and taking it offline does not alter connectivity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">c = 5, connections = [[1,2],[2,3],[3,4],[4,5]], queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/15/powergrid.jpg" style="width: 361px; height: 42px;" /></p>

<ul>
	<li data-end="223" data-start="143">Initially, all stations <code>{1, 2, 3, 4, 5}</code> are online and form a single power grid.</li>
	<li data-end="322" data-start="226">Query <code>[1,3]</code>: Station 3 is online, so the maintenance check is resolved by station 3.</li>
	<li data-end="402" data-start="325">Query <code>[2,1]</code>: Station 1 goes offline. The remaining online stations are <code>{2, 3, 4, 5}</code>.</li>
	<li data-end="557" data-start="405">Query <code>[1,1]</code>: Station 1 is offline, so the check is resolved by the operational station with the smallest <code>id</code> among <code>{2, 3, 4, 5}</code>, which is station 2.</li>
	<li data-end="641" data-start="560">Query <code>[2,2]</code>: Station 2 goes offline. The remaining online stations are <code>{3, 4, 5}</code>.</li>
	<li data-end="800" data-start="644">Query <code>[1,2]</code>: Station 2 is offline, so the check is resolved by the operational station with the smallest <code>id</code> among <code>{3, 4, 5}</code>, which is station 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">c = 3, connections = [], queries = [[1,1],[2,1],[1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li data-end="976" data-start="909">There are no connections, so each station is its own isolated grid.</li>
	<li data-end="1096" data-start="979">Query <code>[1,1]</code>: Station 1 is online in its isolated grid, so the maintenance check is resolved by station 1.</li>
	<li data-end="1135" data-start="1099">Query <code>[2,1]</code>: Station 1 goes offline.</li>
	<li data-end="1237" data-start="1138">Query <code>[1,1]</code>: Station 1 is offline and there are no other stations in its grid, so the result is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="155" data-start="139"><code>1 &lt;= c &lt;= 10<sup>5</sup></code></li>
	<li data-end="213" data-start="158"><code>0 &lt;= n == connections.length &lt;= min(10<sup>5</sup>, c * (c - 1) / 2)</code></li>
	<li data-end="244" data-start="216"><code>connections[i].length == 2</code></li>
	<li data-end="295" data-start="247"><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= c</code></li>
	<li data-end="338" data-start="298"><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="374" data-start="341"><code>1 &lt;= queries.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li data-end="401" data-start="377"><code>queries[i].length == 2</code></li>
	<li data-end="436" data-start="404"><code>queries[i][0]</code> is either 1 or 2.</li>
	<li data-end="462" data-start="439"><code>1 &lt;= queries[i][1] &lt;= c</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-181">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/print-binary-tree/description" target="_blank" rel="noopener noreferrer">Print Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, construct a <strong>0-indexed</strong> <code>m x n</code> string matrix <code>res</code> that represents a <strong>formatted layout</strong> of the tree. The formatted layout matrix should be constructed using the following rules:</p>

<ul>
	<li>The <strong>height</strong> of the tree is <code>height</code>&nbsp;and the number of rows <code>m</code> should be equal to <code>height + 1</code>.</li>
	<li>The number of columns <code>n</code> should be equal to <code>2<sup>height+1</sup> - 1</code>.</li>
	<li>Place the <strong>root node</strong> in the <strong>middle</strong> of the <strong>top row</strong> (more formally, at location <code>res[0][(n-1)/2]</code>).</li>
	<li>For each node that has been placed in the matrix at position <code>res[r][c]</code>, place its <strong>left child</strong> at <code>res[r+1][c-2<sup>height-r-1</sup>]</code> and its <strong>right child</strong> at <code>res[r+1][c+2<sup>height-r-1</sup>]</code>.</li>
	<li>Continue this process until all the nodes in the tree have been placed.</li>
	<li>Any empty cells should contain the empty string <code>&quot;&quot;</code>.</li>
</ul>

<p>Return <em>the constructed matrix </em><code>res</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg" style="width: 141px; height: 181px;" />
<pre>
<strong>Input:</strong> root = [1,2]
<strong>Output:</strong> 
[[&quot;&quot;,&quot;1&quot;,&quot;&quot;],
&nbsp;[&quot;2&quot;,&quot;&quot;,&quot;&quot;]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg" style="width: 207px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4]
<strong>Output:</strong> 
[[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;],
&nbsp;[&quot;&quot;,&quot;2&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;3&quot;,&quot;&quot;],
&nbsp;[&quot;&quot;,&quot;&quot;,&quot;4&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 2<sup>10</sup>]</code>.</li>
	<li><code>-99 &lt;= Node.val &lt;= 99</code></li>
	<li>The depth of the tree will be in the range <code>[1, 10]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-182">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/waves-b18625d7/" target="_blank" rel="noopener noreferrer">Printing patterns</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">implementation</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are required to form a matrix of size <span class="mathjax-latex">\(r\times c\)</span> where <span class="mathjax-latex">\(r\)</span> is the number of rows and <span class="mathjax-latex">\(c\)</span> is the number of columns. You are required to form the waves of numbers around the provided center, <span class="mathjax-latex">\((C_i,\ C_j)\)</span> (0-based indexing).</p>

<p>Example:</p>

<ul>
	<li>Size of the matrix: <span class="mathjax-latex">\(r = 9\)</span> and <span class="mathjax-latex">\(c = 9\)</span></li>
	<li>Center coordinates: <span class="mathjax-latex">\(C_i = 4\)</span> and <span class="mathjax-latex">\(C_j = 4\)</span> (0 based indexing)</li>
	<li>Pattern:</li>
</ul>

<p style="margin-left: 40px;">            4 4 4 4 4 4 4 4 4 <br>
            4 3 3 3 3 3 3 3 4 <br>
            4 3 2 2 2 2 2 3 4 <br>
            4 3 2 1 1 1 2 3 4 <br>
            4 3 2 1 0 1 2 3 4 <br>
            4 3 2 1 1 1 2 3 4 <br>
            4 3 2 2 2 2 2 3 4 <br>
            4 3 3 3 3 3 3 3 4 <br>
            4 4 4 4 4 4 4 4 4</p>

<p>You are given the values of <span class="mathjax-latex">\(r,\ c,\ C_i,\ C_j\)</span> (the values of <span class="mathjax-latex">\(C_i\)</span> and <span class="mathjax-latex">\(C_j\)</span> is 0-based indexed). Your task is to print the provided pattern.</p>

<p><strong>Input format</strong></p>

<p>The first line contains four integers <span class="mathjax-latex">\(r\)</span>, <span class="mathjax-latex">\(c\)</span>, <span class="mathjax-latex">\(C_i\)</span>, and <span class="mathjax-latex">\(C_j\)</span> denoting the number of rows, number of columns, <span class="mathjax-latex">\(x\)</span> coordinate of center, and <span class="mathjax-latex">\(y\)</span> coordinate of center.</p>

<p><strong>Output format</strong></p>

<p>Print the pattern for the provided input.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \le r \le 1e3\\
1 \le c \le 1e3\\
0 \le C_i &lt; r\\
0 \le C_j &lt; c\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Given input have shown output.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-183">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/properties-graph/description" target="_blank" rel="noopener noreferrer">Properties Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>properties</code> having dimensions <code>n x m</code> and an integer <code>k</code>.</p>

<p>Define a function <code>intersect(a, b)</code> that returns the <strong>number of distinct integers</strong> common to both arrays <code>a</code> and <code>b</code>.</p>

<p>Construct an <strong>undirected</strong> graph where each index <code>i</code> corresponds to <code>properties[i]</code>. There is an edge between node <code>i</code> and node <code>j</code> if and only if <code>intersect(properties[i], properties[j]) &gt;= k</code>, where <code>i</code> and <code>j</code> are in the range <code>[0, n - 1]</code> and <code>i != j</code>.</p>

<p>Return the number of <strong>connected components</strong> in the resulting graph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The graph formed has 3 connected components:</p>

<p><img height="171" src="https://assets.leetcode.com/uploads/2025/02/27/image.png" width="279" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,2,3],[2,3,4],[4,3,5]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The graph formed has 1 connected component:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/02/27/screenshot-from-2025-02-27-23-58-34.png" style="width: 219px; height: 171px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,1],[1,1]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><code>intersect(properties[0], properties[1]) = 1</code>, which is less than <code>k</code>. This means there is no edge between <code>properties[0]</code> and <code>properties[1]</code> in the graph.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == properties.length &lt;= 100</code></li>
	<li><code>1 &lt;= m == properties[i].length &lt;= 100</code></li>
	<li><code>1 &lt;= properties[i][j] &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= m</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-184">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Pseudo-Palindromic Paths in a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be <strong>pseudo-palindromic</strong> if at least one permutation of the node values in the path is a palindrome.</p>

<p><em>Return the number of <strong>pseudo-palindromic</strong> paths going from the root node to leaf nodes.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png" style="width: 300px; height: 201px;" /></p>

<pre>
<strong>Input:</strong> root = [2,3,1,3,1,null,1]
<strong>Output:</strong> 2 
<strong>Explanation:</strong> The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png" style="width: 300px; height: 314px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [2,1,1,1,3,null,null,null,null,null,1]
<strong>Output:</strong> 1 
<strong>Explanation:</strong> The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [9]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p><strong>Two subproblems</strong></p>
<p>The problem consists of two subproblems:</p>
<ul>
<li>
<p>Traverse the tree to build all root-to-leaf paths.</p>
</li>
<li>
<p>For each root-to-leaf path, check if it's a pseudo-palindromic path or not.</p>
</li>
</ul>
<p><img src="../Figures/1457/split.png" alt="diff" /><br />
<em>Figure 1. Two subproblems.</em></p>
<p><strong>How to traverse the tree to build all root-to-leaf paths</strong></p>
<p>There are three DFS ways to traverse the tree: preorder, postorder and inorder. Please check two minutes picture explanation if you don't remember them quite well: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/283746/all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line">here is the Python version</a> and <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/328601/all-dfs-traversals-preorder-postorder-inorder-in-java-in-5-lines">here is the Java version</a>.</p>
<p><img src="../Figures/1457/dfs.png" alt="diff" /><br />
<em>Figure 2. The nodes are enumerated in the order of visits. To compare different DFS strategies, follow <code>1-2-3-4-5</code> direction.</em></p>
<blockquote>
<p>Root-to-leaf traversal is so-called <em>DFS preorder traversal</em>. To implement it, one has to follow the straightforward strategy Root-&gt;Left-&gt;Right.</p>
</blockquote>
<blockquote>
<p>There are three ways to implement preorder traversal: iterative, recursive, and Morris. Here we're going to implement the first two.</p>
</blockquote>
<p>Iterative and recursive approaches here do the job in one pass, but they both need up to <span class="math inline">\(\mathcal{O}(H)\)</span> space to keep the stack, where <span class="math inline">\(H\)</span> is a tree height.</p>
<p><strong>How to check if the path is pseudo-palindromic or not</strong></p>
<blockquote>
<p>It's quite evident that the path is pseudo-palindromic if it has at most one digit with an odd frequency.</p>
</blockquote>
<p>How to check that?</p>
<p>The straightforward way is to save each root-to-leaf path into a list and then check each digit for parity.</p>
<p><a href="https://leetcode.com/playground/Sd5dj9ZY/shared">code</a></p>
<p>This method requires keeping each root-to-leaf path, and that becomes space-consuming for the large trees. To save space, let's compute the parity on the fly using bitwise operators.</p>
<blockquote>
<p>The idea is to keep the frequency of digit <code>1</code> in the first bit, <code>2</code> in the second bit, etc: <code>path ^= (1 &lt;&lt; node.val)</code>.</p>
</blockquote>
<p><a href="(https://wiki.python.org/moin/BitwiseOperators)">Left shift operator</a> is used to define the bit, and <a href="https://leetcode.com/problems/single-number-ii/solution/">XOR operator</a> - to compute the digit frequency.</p>
<p><img src="../Figures/1457/xor.png" alt="diff" /><br />
<em>Figure 3. XOR of zero and a bit results in that bit. XOR of two equal bits (even if they are zeros) results in a zero. Hence, one could see the bit in a path only if it appears an odd number of times.</em></p>
<p><a href="https://leetcode.com/playground/Lf7nxpsk/shared">code</a></p>
<p>Now, to ensure that at most one digit has an odd frequency, one has to check that <code>path</code> is a <a href="https://leetcode.com/problems/power-of-two/solution/">power of two</a>, <em>i.e.</em>, at most one bit is set to one. That could be done by turning off (= setting to 0) the rightmost 1-bit: <code>path &amp; (path - 1) == 0</code>. You might want to check the article <a href="https://leetcode.com/problems/power-of-two/solution/">Power of Two</a> for the detailed explanation of this bitwise trick.</p>
<p><img src="../Figures/1457/turn_off.png" alt="diff" /><br />
<em>Figure 4. <code>x &amp; (x - 1)</code> is a way to set the rightmost 1-bit to zero, <em>i.e.</em>, <code>x &amp; (x - 1) == 0</code> for the power of two. To subtract 1 means to change the rightmost 1-bit to 0 and to set all the lower bits to 1. Now AND operator: the rightmost 1-bit will be turned off because <code>1 &amp; 0 = 0</code>, and all the lower bits as well.</em></p>
<p><a href="https://leetcode.com/playground/AGbMsChr/shared">code</a></p>
<br />
<br />
<hr />
<h3 id="approach-1-iterative-preorder-traversal">Approach 1: Iterative Preorder Traversal.</h3>
<p><strong>Intuition</strong></p>
<p>Note: The visual below shows how a stack is used for an inorder traversal. The algorithm and implementation use a preorder traversal. These are both methods for depth-first search, and the only difference is the order in which the nodes are handled.</p>
<p>!?!../Documents/1457_LIS.json:1000,310!?!</p>
<p>Here we implement standard iterative preorder traversal with the stack:</p>
<ul>
<li>
<p>Initialize the counter to zero.</p>
</li>
<li>
<p>Push root into the stack.</p>
</li>
<li>
<p>While the stack is not empty:</p>
<ul>
<li>
<p>Pop out a node from the stack and update the current number.</p>
</li>
<li>
<p>If the node is a leaf, update the root-to-leaf path, check it for being pseudo-palindromic, and update the count.</p>
</li>
<li>
<p>Push right and left child nodes into the stack.</p>
</li>
</ul>
</li>
<li>
<p>Return count.</p>
</li>
</ul>
<p><strong>Implementation</strong></p>
<p>Note, that <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html">Javadocs recommends using ArrayDeque, and not Stack as a stack implementation</a>.</p>
<p><a href="https://leetcode.com/playground/CiKngyXi/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since one has to visit each node, where <span class="math inline">\(N\)</span> is a number of nodes.</p>
</li>
<li>
<p>Space complexity: up to <span class="math inline">\(\mathcal{O}(H)\)</span> to keep the stack, where <span class="math inline">\(H\)</span> is a tree height.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursive-preorder-traversal">Approach 2: Recursive Preorder Traversal.</h3>
<p>Iterative approach 1 could be converted into a recursive one.</p>
<p>Recursive preorder traversal is extremely simple: follow Root-&gt;Left-&gt;Right direction, <em>i.e.</em>, do all the business with the node (<em>i.e.</em>, update the current path and the counter), and then do the recursive calls for the left and right child nodes.</p>
<p>P.S. Here is the difference between <em>preorder</em> and the other DFS recursive traversals.</p>
<p><img src="../Figures/1457/dfs.png" alt="diff" /><br />
<em>Figure 5. The nodes are enumerated in the order of visits. To compare different DFS strategies, follow <code>1-2-3-4-5</code> direction.</em></p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/BExGA3yJ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since one has to visit each node, check if at most one digit has an odd frequency.</p>
</li>
<li>
<p>Space complexity: up to <span class="math inline">\(\mathcal{O}(H)\)</span> to keep the recursion stack, where <span class="math inline">\(H\)</span> is a tree height.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="further-reading">Further Reading</h3>
<p>The problem could be solved in constant space using the Morris inorder traversal algorithm, as it was done in <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/solution/">Sum Root-to-Leaf Numbers</a>. It is unlikely that one can come up with a Morris Traversal solution during an interview, but it is worth knowing anyway.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-185">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/pyramid-transition-matrix/description" target="_blank" rel="noopener noreferrer">Pyramid Transition Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains <strong>one less block</strong> than the row beneath it and is centered on top.</p>

<p>To make the pyramid aesthetically pleasing, there are only specific <strong>triangular patterns</strong> that are allowed. A triangular pattern consists of a <strong>single block</strong> stacked on top of <strong>two blocks</strong>. The patterns are given&nbsp;as a list of&nbsp;three-letter strings <code>allowed</code>, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.</p>

<ul>
	<li>For example, <code>&quot;ABC&quot;</code> represents a triangular pattern with a <code>&#39;C&#39;</code> block stacked on top of an <code>&#39;A&#39;</code> (left) and <code>&#39;B&#39;</code> (right) block. Note that this is different from <code>&quot;BAC&quot;</code> where <code>&#39;B&#39;</code> is on the left bottom and <code>&#39;A&#39;</code> is on the right bottom.</li>
</ul>

<p>You start with a bottom row of blocks <code>bottom</code>, given as a single string, that you <strong>must</strong> use as the base of the pyramid.</p>

<p>Given <code>bottom</code> and <code>allowed</code>, return <code>true</code><em> if you can build the pyramid all the way to the top such that <strong>every triangular pattern</strong> in the pyramid is in </em><code>allowed</code><em>, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/26/pyramid1-grid.jpg" style="width: 600px; height: 232px;" />
<pre>
<strong>Input:</strong> bottom = &quot;BCD&quot;, allowed = [&quot;BCC&quot;,&quot;CDE&quot;,&quot;CEA&quot;,&quot;FFF&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> The allowed triangular patterns are shown on the right.
Starting from the bottom (level 3), we can build &quot;CE&quot; on level 2 and then build &quot;A&quot; on level 1.
There are three triangular patterns in the pyramid, which are &quot;BCC&quot;, &quot;CDE&quot;, and &quot;CEA&quot;. All are allowed.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/26/pyramid2-grid.jpg" style="width: 600px; height: 359px;" />
<pre>
<strong>Input:</strong> bottom = &quot;AAAA&quot;, allowed = [&quot;AAB&quot;,&quot;AAC&quot;,&quot;BCD&quot;,&quot;BBE&quot;,&quot;DEF&quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> The allowed triangular patterns are shown on the right.
Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= bottom.length &lt;= 6</code></li>
	<li><code>0 &lt;= allowed.length &lt;= 216</code></li>
	<li><code>allowed[i].length == 3</code></li>
	<li>The letters in all input strings are from the set <code>{&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;}</code>.</li>
	<li>All the values of <code>allowed</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-186">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reachable-nodes-with-restrictions/description" target="_blank" rel="noopener noreferrer">Reachable Nodes With Restrictions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> edges.</p>

<p>You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given an integer array <code>restricted</code> which represents <strong>restricted</strong> nodes.</p>

<p>Return <em>the <strong>maximum</strong> number of nodes you can reach from node </em><code>0</code><em> without visiting a restricted node.</em></p>

<p>Note that node <code>0</code> will <strong>not</strong> be a restricted node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png" style="width: 402px; height: 322px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The diagram above shows the tree.
We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png" style="width: 412px; height: 312px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The diagram above shows the tree.
We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>1 &lt;= restricted.length &lt; n</code></li>
	<li><code>1 &lt;= restricted[i] &lt; n</code></li>
	<li>All the values of <code>restricted</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-187">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/redundant-connection/description" target="_blank" rel="noopener noreferrer">Redundant Connection</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p>

<p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong> vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p>

<p>Return <em>an edge that can be removed so that the resulting graph is a tree of </em><code>n</code><em> nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg" style="width: 382px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
<strong>Output:</strong> [1,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>3 &lt;= n &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= edges.length</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
	<li>The given graph is connected.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a graph consisting of <span class="math inline">\(N\)</span> nodes and <span class="math inline">\(N − 1\)</span> edges, which means the graph initially forms a tree. A tree is a special type of graph that is connected (there is a path between any two nodes) and acyclic (it does not contain any cycles). However, a new edge is added to the tree, connecting two nodes that are already part of the graph. This new edge creates a cycle because there are now two distinct paths between some pairs of nodes. As a result, the graph is no longer a tree but a single-cycle graph.</p>
<p>Our goal is to identify the edge that, if removed, will restore the graph to its original state as a tree. Since the tree must be connected and acyclic, removing any edge from the cycle will break the cycle and turn the graph into a tree. However, if there are multiple edges that can be removed to achieve this, we are required to return the edge that appears last in the given list of edges.</p>
<hr />
<h3 id="approach-1-depth-first-search---brute-force">Approach 1: Depth-First Search - Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The key idea is that we can safely discard an edge if it connects two nodes that are already part of the same connected component. In simple terms, this means that if there's already a path between the two nodes (even without the current edge), adding this edge would create a cycle, making it redundant.</p>
<p>To check if a path exists between two nodes, we can use graph traversal techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS). In this approach, we will use DFS to verify whether the two nodes of each edge are already connected. If you're unfamiliar with DFS, you can explore this helpful <a href="https://leetcode.com/explore/featured/card/graph/">DFS guide</a>.</p>
<p>Now, as we go through the edges, we examine each one. For every edge, we use DFS to determine if the two nodes it connects are already part of the same connected component. If a path already exists, that means the nodes are connected, and we can safely discard the edge because it would create a cycle. If there’s no existing path, we know that the edge is essential for connecting the nodes, so we add it to our graph.</p>
<p>One important thing to remember is that we process the edges in the order they appear in the input list. This ensures that if multiple redundant edges are present, the last one we process will be the one that forms the cycle.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Define the function <code>isConnected</code> that takes the source node <code>src</code>, target node <code>target</code>, boolean array <code>visited</code>, and the adjacency list <code>adjList</code>. This returns true if there's a path between <code>src</code> and <code>target</code> with the edges in the list <code>adjList</code> using DFS:
<ul>
<li>Mark the current node <code>src</code> as visited.</li>
<li>Initialize the variable <code>isFound</code> to <code>false</code>, this is going to denote the answer.</li>
<li>Recursively traverse to the unvisited adjacent nodes and check if the <code>target</code> node is found.</li>
<li>Return <code>isFound</code> in the end.</li>
</ul>
</li>
<li>Iterate over the list <code>edges</code> from left to and right and for each <code>edge</code>:
<ul>
<li>Initialize an empty array <code>visited</code> with all indices as <code>false</code>.</li>
<li>Call the method <code>isConnected</code> and if it returns <code>true</code> return <code>edge</code></li>
<li>Otherwise, add the edge to the adjacency list <code>adjList</code>.</li>
</ul>
</li>
<li>If the input is valid, this part of the code should be unreachable. Return an empty list <code>{}</code> in such cases.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ydw6rbYM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span>.</p>
<p>Iterating over each of the <span class="math inline">\(N\)</span> edges and performing a DFS to check if the nodes are already connected would result in <span class="math inline">\(N \times N\)</span> operations. The time complexity of a DFS is <span class="math inline">\(O(V+E)\)</span>, where <span class="math inline">\(V\)</span> is the number of vertices and <span class="math inline">\(E\)</span> is the number of edges. In this problem, both <span class="math inline">\(V\)</span> and <span class="math inline">\(E\)</span> are equal to <span class="math inline">\(N\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The adjacency list <code>adjList</code> will store <span class="math inline">\(N\)</span> edges, and the size of the <code>visited</code> array is <span class="math inline">\(N\)</span>. Additionally, space is required for the active stack calls in the DFS, which can be as large as one per node. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search---single-traversal">Approach 2: Depth-First Search - Single Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We cannot remove just any edge from the graph, as doing so might disconnect the graph. The edge we remove must be part of the cycle. If we can identify the edges or nodes involved in the cycle, we can choose to remove the edge that appears last in the input edge list.</p>
<p>To detect the cycle in the graph, we need to identify at least one node that belongs to it. This can be accomplished using DFS while keeping track of the parent of each node, where the parent represents the node from which we reached the current node. If we encounter a node that has already been visited and the node we are coming from is different from its parent, we can conclude that the node is part of the cycle.</p>
<p>Once we identify a node in the cycle, we can backtrack through the parent array to find all the other nodes that are part of the cycle, until we return to the starting node. We will mark all these cycle nodes in an unordered map. Then, we iterate over the edges in reverse order, and if both nodes of an edge are marked in the map, we can discard this edge as it forms the cycle. Finally, we can return this redundant edge.</p>
<p><img src="../Figures/684/684A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li>Set <code>cycleStart</code> to <code>-1</code> to mark the start of the cycle.</li>
<li>Create a <code>visited</code> array to keep track of visited nodes.</li>
<li>Create a <code>parent</code> array to store the parent of each node in the DFS traversal.</li>
<li>Initialize an adjacency list <code>adjList</code> to represent the graph.</li>
</ul>
</li>
<li>
<p>Build the Graph:</p>
<ul>
<li>Loop through each edge in the input <code>edges</code> list.</li>
<li>For each edge <code>[u, v]</code>, add <code>v</code> to <code>adjList[u]</code> and <code>u</code> to <code>adjList[v]</code> to make the graph undirected.</li>
</ul>
</li>
<li>
<p>Start a DFS from node <code>0</code> (or any node, as the graph is connected).</p>
<ul>
<li>In the DFS function:
<ul>
<li>Mark the current node as visited.</li>
<li>For each adjacent node, check if it's visited:
<ul>
<li>If not visited, recursively call DFS on the adjacent node, and update its parent.</li>
<li>If the node is visited and its parent is different from the previous one, mark it as <code>cycleStart</code> to identify the cycle.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Track Cycle Nodes:</p>
<ul>
<li>Using the <code>parent</code> array, backtrack from <code>cycleStart</code> to collect all nodes in the cycle.</li>
<li>Store these nodes in the <code>cycleNodes</code> map for quick lookup.</li>
</ul>
</li>
<li>
<p>Identify the Redundant Edge:</p>
<ul>
<li>Iterate through the edges in reverse order.</li>
<li>For each edge, check if both nodes of the edge are in the <code>cycleNodes</code> map:
<ul>
<li>If both nodes are in the cycle, return this edge as the redundant connection.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5URgLFer/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>We perform the DFS starting from node <code>0</code> only once, which has a time complexity of <span class="math inline">\(O(N)\)</span>. Then, we iterate over the cycle nodes using the <code>parent</code> array, with a maximum of <span class="math inline">\(N\)</span> iterations if all nodes are part of the cycle. Finally, we iterate over all edges and check the map in <span class="math inline">\(O(1)\)</span> time for each edge. Therefore, the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The adjacency list <code>adjList</code> will store <span class="math inline">\(N\)</span> edges, and the size of the visited array is <span class="math inline">\(N\)</span>. Additionally, space is required for the active stack calls during DFS, which can be as large as one per node. The map <code>cycleNodes</code> can contain at most <span class="math inline">\(N\)</span> entries. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-dsu">Approach 3: Disjoint Set Union (DSU)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We’re still working with the same core idea as in the first approach: an edge can be discarded if the nodes it connects are already part of the same component. In the previous approach, we used DFS to check if a path existed between the nodes. However, there's an alternative and more efficient way to do this using a data structure called Disjoint Set Union (DSU).</p>
<blockquote>
<p>If you are not familiar with DSU, please go through our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Explore Card</a>. We will not talk about implementation details here and assume you are already familiar with the interface of DSU.</p>
</blockquote>
<p>The idea behind DSU is that each node is in its own a separate set. As we go through the edges, we perform a union operation that merges the sets of the two connected nodes. This helps us track which nodes are in the same component. If, during this process, we encounter an edge where the two nodes are already in the same component (i.e., they share the same representative), we know that adding this edge would create a cycle, so it’s redundant and can be safely discarded.</p>
<p>The great thing about DSU is that it can check whether two nodes are in the same component in nearly constant time, specifically in <span class="math inline">\(O(α(N))\)</span>, where <span class="math inline">\(α(N)\)</span> is the inverse Ackermann function (which grows extremely slowly). This makes DSU much faster than DFS for this type of problems.</p>
<p>In this approach, we treat each node as its own component at the start. As we process each edge, we perform the union operation to merge the components of the two nodes connected by the edge. If the nodes are in different components, we unite them and update their representatives. If the nodes are already in the same component, we’ve found a redundant edge and return it as the result.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Define DSU (Disjoint Set Union):</p>
<ul>
<li>Initialize two arrays:
<ul>
<li><code>size[]</code> to store the size of each component (starts with 1 for each node).</li>
<li><code>representative[]</code> to track the representative (or root) of each component (initially, each node is its own representative).</li>
<li>Find Operation (<code>find</code>):
<ul>
<li>For each node, find its ultimate representative (root of the component).</li>
<li>Path Compression: During the recursive search, update the representative of each visited node to directly point to the root, speeding up future lookups.</li>
</ul>
</li>
<li>Union Operation (<code>doUnion</code>):
<ul>
<li>Check if the two nodes belong to the same component:</li>
<li>If they already share the same representative, they are part of the same component, so adding this edge would form a cycle. Return <code>false</code>.</li>
<li>If the nodes belong to different components, union them:</li>
<li>Attach the smaller component to the larger one (union by size), ensuring the tree remains balanced to minimize depth.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate Through Edges:</p>
<ul>
<li>Process each edge in the list of edges:
<ul>
<li>Convert the 1-based indices from the input to 0-based for array indexing.</li>
<li>Use <code>doUnion</code> to attempt connecting the nodes of the edge.</li>
<li>If <code>doUnion</code> returns <code>false</code>, it means adding this edge would form a cycle, so return the current edge as the redundant edge.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the input is valid, this part of the code should be unreachable. Return an empty list <code>{}</code> in such cases.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/JWuYpx4d/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot \alpha(N))\)</span></p>
<p>We iterate over all edges, and for each edge, we invoke the <code>doUnion</code> function, which has a time complexity of <span class="math inline">\(O(\alpha(N))\)</span>, given that both union by size and path compression are employed. Consequently, the overall time complexity of the algorithm is <span class="math inline">\(O(N \cdot \alpha(N))\)</span>. It is important to note that <span class="math inline">\(\alpha(N)\)</span> represents the inverse Ackermann function, which grows so slowly that it is often considered asymptotically constant, or <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The list <code>representative</code>, used to store the representatives, and the list <code>size</code>, used to store the size of each component, will each contain <span class="math inline">\(N\)</span> entries. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-188">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/redundant-connection-ii/description" target="_blank" rel="noopener noreferrer">Redundant Connection II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>

<p>The given input is a directed graph that started as a rooted tree with <code>n</code> nodes (with distinct values from <code>1</code> to <code>n</code>), with one additional directed edge added. The added edge has two different vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed.</p>

<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u<sub>i</sub>, v<sub>i</sub>]</code> that represents a <b>directed</b> edge connecting nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, where <code>u<sub>i</sub></code> is a parent of child <code>v<sub>i</sub></code>.</p>

<p>Return <em>an edge that can be removed so that the resulting graph is a rooted tree of</em> <code>n</code> <em>nodes</em>. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg" style="width: 222px; height: 382px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
<strong>Output:</strong> [4,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>3 &lt;= n &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Starting from a rooted tree with <code>N-1</code> edges and <code>N</code> vertices, let's enumerate the possibilities for the added &quot;redundant&quot; edge. If there is no loop, then either one vertex must have two parents (or no edge is redundant). If there is a loop, then either one vertex has two parents, or every vertex has one parent.</p>
<p>In the first two cases, there are only two candidates for deleting an edge, and we can try removing the last one and seeing if that works. In the last case, the last edge of the cycle can be removed: for example, when <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>, we want the last edge (by order of occurrence) in the cycle <code>1-&gt;2-&gt;3-&gt;4-&gt;1</code> (but not necessarily <code>1-&gt;5</code>).</p>
<p><strong>Algorithm</strong></p>
<p>We'll first construct the underlying graph, keeping track of edges coming from nodes with multiple parents. After, we either have 2 or 0 <code>candidates</code>.</p>
<p>If there are no candidates, then every vertex has one parent, such as in the case <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>. From any node, we walk towards its parent until we revisit a node - then we must be inside the cycle, and any future seen nodes are part of that cycle.  Now we take the last edge that occurs in the cycle.</p>
<p>Otherwise, we'll see if the graph induced by <code>parent</code> is a rooted tree. We again take the <code>root</code> by walking from any node towards the parent until we can't, then we perform a depth-first search on this <code>root</code>. If we visit every node, then removing the last of the two edge candidates is acceptable, and we should.  Otherwise, we should remove the first of the two edge candidates.</p>
<p>In our solution, we use <code>orbit</code> to find the result upon walking from a node <code>x</code> towards its parent repeatedly until you revisit a node or can't walk anymore.  <code>orbit(x).node</code> (or <code>orbit(x)[0]</code> in Python) will be the resulting node, while <code>orbit(x).seen</code> (or <code>orbit(x)[1]</code>) will be all the nodes visited.</p>
<p><a href="https://leetcode.com/playground/GbE4kZpx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span> where <span class="math inline">\(N\)</span> is the number of vertices (and also the number of edges) in the graph. We perform a depth-first search.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the graph.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-189">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/regions-cut-by-slashes/description" target="_blank" rel="noopener noreferrer">Regions Cut By Slashes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <code>n x n</code> grid is composed of <code>1 x 1</code> squares where each <code>1 x 1</code> square consists of a <code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, or blank space <code>&#39; &#39;</code>. These characters divide the square into contiguous regions.</p>

<p>Given the grid <code>grid</code> represented as a string array, return <em>the number of regions</em>.</p>

<p>Note that backslash characters are escaped, so a <code>&#39;\&#39;</code> is represented as <code>&#39;\\&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/1.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [&quot; /&quot;,&quot;/ &quot;]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/2.png" style="width: 200px; height: 198px;" />
<pre>
<strong>Input:</strong> grid = [&quot; /&quot;,&quot;  &quot;]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/4.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [&quot;/\\&quot;,&quot;\\/&quot;]
<strong>Output:</strong> 5
<strong>Explanation: </strong>Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either <code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, or <code>&#39; &#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Many have found this problem to be a difficult medium problem, so if that is how you are feeling, you are not alone. <a href="https://leetcode.com/problems/number-of-islands/description/">Number of Islands</a> is a good starter problem if you find yourself struggling with this one.</p>
<p>We are given an array of strings called <code>grid</code>, which contains three types of characters: forward slash <code>/</code>, backslash <code>\\</code>, and space <code>' '</code>. Each slash divides its cell into two contiguous sections, as shown in the following image:</p>
<p><img src="../Figures/959__re/image_1.png" alt="examples to show how the grid is formed" /></p>
<p>Our objective is to determine the total number of distinct regions formed within the grid as a result of these slash divisions.</p>
<hr />
<h3 id="approach-1-expanded-grid">Approach 1: Expanded Grid</h3>
<h4 id="intuition">Intuition</h4>
<p>When a cell in the grid contains a slash, it effectively divides it into two parts. A forward slash divides the cell into top-left and bottom-right sections, while a backslash divides it into top-right and bottom-left sections. As you can see in Example 2 of the problem, counting the regions directly is challenging since a divided cell does not always lead to an additional region.</p>
<p>To address this, we can magnify the grid by expanding each cell into a <span class="math inline">\(3 \times 3\)</span> sub-grid, with slashes represented by diagonal cells marked as barriers:</p>
<p><img src="../Figures/959__re/image_2.png" alt="" /></p>
<p>This transformation simplifies our task. If we treat the slashes and grid boundaries as water, and the remaining cells as land, the problem becomes analogous to the <a href="https://leetcode.com/problems/number-of-islands/description/">Number of Islands</a>.</p>
<p>We can solve this using the <a href="https://en.wikipedia.org/wiki/Flood_fill">flood-fill algorithm</a> to visit each connected region in the grid. We iterate over each cell of the grid and invoke <code>floodfill</code> whenever we encounter an unvisited land cell. The <code>floodfill</code> function explores all reachable land cells from the current cell and marks them as visited.  Then, we continue to iterate over each cell in the grid until we reach the next unvisited cell, which signifies the next land region. The total number of <code>floodfill</code> calls corresponds to the number of regions in the grid, which is our desired answer.</p>
<blockquote>
<p>Note: In our implementation, we use Breadth-First Search (BFS) for the flood-fill algorithm. Alternatively, Depth-First Search (DFS) can also be employed, yielding similar time and space complexities.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize an array <code>DIRECTIONS</code> to specify traversal directions: right, left, down, and up.</li>
</ul>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Set <code>gridSize</code> as the size of the original grid.</li>
<li>Create a new 2D array <code>expandedGrid</code> with dimensions three times the original grid size.</li>
<li>Iterate through each cell <code>(i, j)</code> in the original <code>grid</code>:
<ul>
<li>Calculate <code>baseRow</code> and <code>baseCol</code> as three times of <code>i</code> and <code>j</code>.</li>
<li>Check the character in the current cell:
<ul>
<li>If it is a backslash (<code>\\</code>):
<ul>
<li>Mark the cells in the main diagonal <code>(baseRow, baseCol)</code>, <code>(baseRow+1, baseCol+1)</code>, <code>(baseRow+2, baseCol+2)</code> as <code>1</code>.</li>
</ul>
</li>
<li>If it is a forward slash (<code>/</code>):
<ul>
<li>Mark the other diagonal <code>(baseRow, baseCol+2)</code>, <code>(baseRow+1, baseCol+1)</code>, <code>(baseRow+2, baseCol)</code> as <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize a counter <code>regionCount</code> to <code>0</code>.</li>
<li>Iterate through each cell <code>(i, j)</code> in <code>expandedGrid</code>:
<ul>
<li>If the cell is unvisited (value <code>0</code>):
<ul>
<li>Call the <code>floodfill</code> method to fill the region.</li>
<li>Increment <code>regionCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>regionCount</code> as the total number of distinct regions.</li>
</ul>
<p>Helper method <code>floodfill</code>:</p>
<ul>
<li>Define a method <code>floodfill</code> with parameters: <code>expandedGrid</code> and the <code>row</code> and <code>col</code> indices.</li>
<li>Initialize a queue and add the starting cell <code>(row, col)</code> to it.</li>
<li>Mark the starting cell as visited by setting <code>expandedGrid[row][col]</code> to <code>1</code>.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Dequeue <code>currentCell</code>.</li>
<li>For each <code>direction</code> in <code>DIRECTIONS</code>:
<ul>
<li>Set <code>newRow</code> as <code>currentCell[0] + direction[0]</code>.</li>
<li>Set <code>newCol</code> as <code>currentCell[1] + direction[1]</code>.</li>
<li>Check if the new cell is valid and unvisited using the <code>isValidCell</code> method:
<ul>
<li>If valid, mark the cell as visited and add it to the <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Helper method <code>isValidCell</code>.</p>
<ul>
<li>Define a method <code>isValidCell</code> with parameters: <code>expandedGrid</code>, <code>row</code>, and <code>col</code>.</li>
<li>Return <code>true</code> if the cell <code>(row, col)</code> is within bounds and unvisited.</li>
<li>Otherwise, return <code>false</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MHLtBUxW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm populates the expanded grid by iterating over the original grid, which takes <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>In the worst case, the flood fill algorithm will visit every cell in the expanded grid once. The expanded grid is <span class="math inline">\(3n \times 3n\)</span>, resulting in <span class="math inline">\(O((3n)^2) = O(9n^2) = O(n^2)\)</span> operations.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(2 \cdot O(n^2)\)</span>, which simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The expanded grid has dimensions <span class="math inline">\(3n \times 3n\)</span>, which requires <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>In the flood fill algorithm, the queue can store all <span class="math inline">\(9n^2\)</span> cells of the expanded grid in the worst case. This results in a space complexity of <span class="math inline">\(O(9n^2) = O(n^2)\)</span>.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n^2) + O(n^2) = O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-disjoint-set-union-triangles">Approach 2: Disjoint Set Union (Triangles)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our previous approach involved magnifying each cell into a <span class="math inline">\(3 \times 3\)</span> grid, increasing the number of unit cells by a factor of 9. We can further optimize this process by reconceptualizing how regions are formed and connected. Instead of viewing the grid as squares, let's envision each cell divided into four triangles. This allows for a more precise representation of slashes.</p>
<p><img src="../Figures/959__re/image_3.png" alt="cell divided into four triangles" /></p>
<p>Initially, each triangle is considered its own region. As we traverse the grid, we can group together all triangles not separated by slashes as belonging to one component (region). The total number of these groups will be our required answer.</p>
<p>A widely used data structure for grouping connected components is the Disjoint Set Union (DSU). A DSU assigns each component (a unit triangle) a parent, which is initially itself. To connect or union two components, we assign them to the same parent, meaning units with the same parent belong to the same connected component. To learn more about how the disjoint set union data structure is implemented, refer to this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Explore Card</a>.</p>
<p>We iterate over the grid and perform two main types of operations:</p>
<ol>
<li>
<p>Union adjacent components:</p>
<p>Regardless of whether a cell contains a forward slash or backslash, the top triangle of a cell will always connect to the bottom triangle of the cell above it. The same principle applies to the left triangle of a cell and the right triangle of the cell to its left.</p>
<p><img src="../Figures/959__re/image_4.png" alt="connecting top and left cells" /></p>
</li>
<li>
<p>Union intra-cell components:</p>
<p>A slash divides the cell diagonally, allowing us to combine the two adjacent triangles on each side of the diagonal.</p>
</li>
</ol>
<p>We begin with the total number of triangles as our initial region count. Each successful union operation indicates that two distinct components have been merged into one, reducing the total number of regions by one. After processing all cells, the remaining count represents the number of distinct regions.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Set <code>gridSize</code> as the size of the <code>grid</code>.</li>
<li>Calculate <code>totalTriangles</code> in the grid as <code>gridSize * gridSize * 4</code>.</li>
<li>Create a <code>parentArray</code> to represent the disjoint sets of triangles and initialize each element to <code>-1</code>.</li>
<li>Initialize <code>regionCount</code> to <code>totalTriangles</code>, assuming each triangle is initially a separate region.</li>
<li>Iterate through each cell of <code>grid</code>:
<ul>
<li>If there is a cell above the current cell, union the bottom triangle of the above cell with the top triangle of the current cell.</li>
<li>If there is a cell to the left of the current cell, union the right triangle of the left cell with the left triangle of the current cell.</li>
<li>If the current cell is not <code>/</code>:
<ul>
<li>Union the top triangle with the right triangle.</li>
<li>Union the bottom triangle with the left triangle.</li>
</ul>
</li>
<li>If the current cell is not <code>\\</code>:
<ul>
<li>Union the top triangle with the left triangle.</li>
<li>Union the bottom triangle with the right triangle.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>regionCount</code> as our answer.</li>
</ul>
<p>Helper method <code>getTriangleIndex</code>:</p>
<ul>
<li>Define a method <code>getTriangleIndex</code> with parameters: <code>gridSize</code>, the <code>row</code> and <code>col</code> indices, and the <code>triangleNum</code>.</li>
<li>Return <code>(gridSize * row + col) * 4 + triangleNum</code>.</li>
</ul>
<p>Helper method <code>unionTriangles</code>:</p>
<ul>
<li>Define a method <code>unionTriangles</code> with parameters: <code>parentArray</code> and the two indices <code>x</code> and <code>y</code>.</li>
<li>Find <code>parentX</code> and <code>parentY</code> using the <code>findParent</code> method.</li>
<li>If <code>parentX</code> is not equal to <code>parentY</code>:
<ul>
<li>Set <code>parentArray[parentX]</code> to <code>parentY</code> and return <code>1</code>.</li>
</ul>
</li>
<li>Return <code>0</code>.</li>
</ul>
<p>Helper method <code>findParent</code>:</p>
<ul>
<li>Define a method <code>findParent</code> with parameters: <code>parentArray</code> and the index <code>x</code>.</li>
<li>If <code>parentArray[x]</code> is equal to <code>-1</code>:
<ul>
<li><code>x</code> has no parent. Return <code>x</code>.</li>
</ul>
</li>
<li>Set <code>parentArray[x]</code> to the parent of <code>parentArray[x]</code> using <code>findParent</code>. Return <code>parentArray[x]</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gejLBoVS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha (n))\)</span></p>
<p>Initializing the <code>parentArray</code> takes <span class="math inline">\(O(4 \cdot n^2)\)</span> time.</p>
<p>The main loop iterates over all <span class="math inline">\(n^2\)</span> cells in the grid. In each iteration, it calls the <code>unionTriangles</code> method which includes <code>findPath</code> operations. With path compression, the amortized time complexity of <code>findPath</code> is denoted as <span class="math inline">\(\alpha(n)\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function. Thus, the time complexity of the loop comes out to be <span class="math inline">\(O(n^2 \cdot \alpha (n))\)</span>.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(4 \cdot n^2) + O(n^2 \cdot \alpha (n)) = O(n^2 \cdot \alpha (n))\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The only additional data structure used by the algorithm is the <code>parentArray</code>, which takes <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>The recursive <code>find</code> operation can have a call stack of size <span class="math inline">\(O(\log n)\)</span> in the worst case.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-graph">Approach 3: Disjoint Set Union (Graph)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's shift our perspective and consider slashes as connectors rather than dividers. Imagine each cell as a graph with four vertices at its corners, with slashes acting as edges between these vertices. The following diagram illustrates this concept:</p>
<p><img src="../Figures/959__re/image_5.png" alt="cell as a graph" /></p>
<p>In this paradigm, a slash can be represented as follows:</p>
<ul>
<li>A <code>/</code> slash connects the top-right point of a cell to the bottom-left point.</li>
<li>A <code>\</code> slash connects the top-left point to the bottom-right point.</li>
<li>An empty space doesn't add any new connections.</li>
</ul>
<p>The edges of the grid form the boundaries of the graph, creating an initial region. As we connect vertices (slashes), cycles may form, indicating the creation of new regions within the graph. By tracking the total number of cycles formed while iterating over all slashes, we determine the final count of regions.</p>
<p>To manage connected components, we use a DSU (Disjoint Set Union) data structure. We start by connecting the boundary points as the first region. As we process each cell, we treat each slash as an edge and union the corresponding vertices. If a union operation reveals that the vertices already share the same parent, it indicates a cycle, prompting us to increment our counter.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Initialize variables:
<ul>
<li><code>gridSize</code> to the length of <code>grid</code>.</li>
<li><code>pointsPerSide</code> to <code>gridSize + 1</code>.</li>
<li><code>totalPoints</code> to <code>pointsPerSide * pointsPerSide</code>.</li>
</ul>
</li>
<li>Create an array <code>parentArray</code> to represent the disjoint set, initialized with <code>-1</code>.</li>
<li>Loop over the each point:
<ul>
<li>If the point lies on the border, set its <code>parent</code> to <code>0</code>.</li>
</ul>
</li>
<li>Set <code>parent[0]</code> (top-left corner) to <code>-1</code> to make it the root.</li>
<li>Initialize <code>regionCount</code> to <code>1</code>, accounting for the border region.</li>
<li>Iterate through each cell <code>(i, j)</code> in the <code>grid</code>:
<ul>
<li>If it's a forward slash (<code>/</code>):
<ul>
<li>Calculate the <code>topRight</code> and <code>bottomLeft</code> indices.</li>
<li>Call <code>union</code> on these points and add the result to <code>regionCount</code>.</li>
</ul>
</li>
<li>If it's a backslash (<code>\\</code>):
<ul>
<li>Calculate the <code>topLeft</code> and <code>bottomRight</code> indices.</li>
<li>Call <code>union</code> on these points and add the result to <code>regionCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final <code>regionCount</code>.</li>
</ul>
<p>Helper method <code>find</code>:</p>
<ul>
<li>Define a method <code>find</code> with parameters: <code>parentArray</code> and the <code>node</code>.</li>
<li>If <code>parentArray[node]</code> is equal to <code>-1</code>:
<ul>
<li><code>node</code> does not have any parent. Return <code>node</code>.</li>
</ul>
</li>
<li>Set <code>parentArray[node]</code> to the parent of <code>parentArray[node]</code> using the <code>find</code> method. Return <code>parentArray[node]</code>.</li>
</ul>
<p>Helper method <code>union</code>:</p>
<ul>
<li>Define a method union with parameters: <code>parentArray</code> and nodes <code>node1</code> and <code>node2</code>.</li>
<li>Set <code>parent1</code> to <code>parent2</code> to the parents of <code>node1</code> and <code>node2</code> respectively.</li>
<li>If <code>parent1</code> is equal to <code>parent2</code>, return <code>1</code>.</li>
<li>Set <code>parentArray[parent2]</code> to <code>parent1</code>.</li>
<li>Return <code>0</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/C84Mt6ZN/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha (n^2))\)</span></p>
<p>Filling the parent array requires <span class="math inline">\(O((n+1) \cdot (n+1))\)</span> time, which can be simplified to <span class="math inline">\(O(n^2)\)</span>. Connecting the border points requires another <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>As the algorithm iterates over the grid, it potentially performs two <code>union</code> operations for each cell. The time complexity of a single <code>find</code>/<code>union</code> operation is <span class="math inline">\(O(\alpha (n^2))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function. We perform at most <span class="math inline">\(O(n^2)\)</span> union operations, making the complexity of this part <span class="math inline">\(O(n^2 \cdot \alpha (n^2))\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(2 \cdot O(n^2) + O(n^2 \cdot 2 \alpha (n^2)) = O(n^2 \cdot \alpha (n^2))\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm creates an array of size <span class="math inline">\((n+1)^2\)</span>, which is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The recursive call stack for <code>find</code> operation is <span class="math inline">\(O(\log n)\)</span> in the worst case.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-190">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-invalid-parentheses/description" target="_blank" rel="noopener noreferrer">Remove Invalid Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.</p>

<p>Return <em>a list of <strong>unique strings</strong> that are valid with the minimum number of removals</em>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;()())()&quot;
<strong>Output:</strong> [&quot;(())()&quot;,&quot;()()()&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(a)())()&quot;
<strong>Output:</strong> [&quot;(a())()&quot;,&quot;(a)()()&quot;]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;)(&quot;
<strong>Output:</strong> [&quot;&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 25</code></li>
	<li><code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>
	<li>There will be at most <code>20</code> parentheses in <code>s</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<p><strong>Intuition</strong></p>
<p>For this question, we are given an expression consisting of parentheses and there can be some misplaced or extra brackets in the expression that cause it to be invalid. An expression consisting of parentheses is considered valid only when every closing bracket has a corresponding opening bracket and vice versa.</p>
<p>This means if we start looking at each of the bracket from left to right, as soon as we encounter a closing bracket, there should be an unmatched opening bracket available to match it. Otherwise the expression would become invalid. The expression can also become invalid if the number of opening parentheses i.e. <code>(</code> are more than the number of closing parentheses i.e. <code>)</code>.</p>
<p>Let us look at an invalid expression and all the possible valid expressions that can be formed from it by removing some of the brackets. There is no restriction on which parentheses we can remove. We simply have to make the expression valid.</p>
<blockquote>
<p>The only condition is that we should be removing the minimum number of brackets to make an invalid expression, valid. If this condition was not present, we could potentially remove most of the brackets and come down to say 2 brackets in the end which form <code>()</code> and that would be a valid expression.</p>
</blockquote>
<center>
<img src="../Figures/301/Diag_1.png" width="800"></center>
<p>An important thing to observe in the above diagram is that there are multiple ways of reaching the same solution i.e. say the optimal number of parentheses to be removed to make the original expression valid is K. We can remove multiple different sets of K brackets that will eventually give us the same final expression. But, each valid expression should be recorded only once. We have to take care of this in our solution. Note that there are other possible ways of reaching one of the two valid expressions shown above. We have simply shown 3 ways each for the two valid expressions.</p>
<p>Coming back to our problem, the question that now arises is, how to decide which of the parentheses to remove?</p>
<blockquote>
<p>Since we don't know which of the brackets can possibly be removed, we try out all the options!</p>
</blockquote>
<p>For every bracket we have two choices:</p>
<ul>
<li>Either it can be considered a part of the final expression OR</li>
<li>It can be ignored i.e. we can delete it from our final expression.</li>
</ul>
<p>Such kind of problems where we have multiple options and we have no strategy or metric of deciding greedily which option to take, we try out all of the options and see which ones lead to an answer. These type of problems are perfect candidates for the programming paradigm, <code>Recursion</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize an array that will store all of our valid expressions finally.</li>
<li>Start with the leftmost bracket in the given sequence and proceed right in the recursion.</li>
<li>The state of recursion is defined by the index which we are currently processing in the original expression. Let this index be represented by the character <code>i</code>. Also, we have two different variables <code>left_count</code> and <code>right_count</code> that represent the number of left and right parentheses we have added to our expression till now. These are the parentheses that were considered.</li>
<li>If the current character i.e. <code>S[i]</code> (considering S is the expression string) is neither a closing or an opening parenthesis, then we simply add this character to our final solution string for the current recursion.</li>
<li>However, if the current character is either of the two brackets i.e. <code>S[i] == '(' or S[i] == ')'</code>, then we have two options. We can either discard this character by marking it an invalid character or we can consider this bracket to be a part of the final expression.</li>
<li>When all of the parentheses in the original expression have been processed, we simply check if the expression represented by <code>expr</code> i.e. the expression formed till now is valid one or not. The way we check if the final expression is valid or not is by looking at the values in <code>left_count</code> and <code>right_count</code>. For an expression to be valid <code>left_count == right_count</code>. If it is indeed valid, then it could be one of our possible solutions.
<ul>
<li>Even though we have a valid expression, we also need to keep track of the number of removals we did to get this expression. This is done by another variable passed in recursion called <code>rem_count</code>.</li>
<li>Once recursion finishes we check if the current value of <code>rem_count</code> is &lt; the least number of steps we took to form a valid expression till now i.e. the global minima. If this is not the case, we don't record the new expression, else we record it.</li>
</ul>
</li>
</ol>
<p>One small optimization that we can do from an implementation perspective is introducing some sort of pruning in our algorithm. Right now we simply go till the very end i.e. process all of the parentheses and when we are done processing all of them, we check if the expression we have can be considered or not.</p>
<p>We have to wait till the very end to decide if the expression formed in recursion is a valid expression or not. Is there a way for us to cutoff from some of the recursion paths early on because they wouldn't lead to a solution? The answer to this is Yes! The optimization is based on the following idea.</p>
<p>For a left bracket encountered during recursion, if we decide to consider it, then it may or may not lead to an invalid final expression. It may lead to an invalid expression eventually if there are no matching closing bracket available afterwards. But, we don't know for sure if this will happen or not.</p>
<blockquote>
<p>However, for a closing bracket, if we decide to keep it as a part of our final expression (remember for every bracket we have two options, either to keep it or to remove it and recurse further) and there is no corresponding opening bracket to match it in the expression till now, then it will definitely lead to an invalid expression no matter what we do afterwards.</p>
</blockquote>
<p>e.g.</p>
<pre>
( (  ) ) )
</pre>
<p>In this case the third closing bracket will make the expression invalid. No matter what comes afterwards, this will give us an invalid expression and if such a thing happens, we shouldn't recurse further and simply prune the recursion tree.</p>
<p>That is why, in addition to having the index in the original string/expression which we are currently processing and the expression string formed till now, we also keep track of the number of left and right parentheses. Whenever we keep a left parenthesis in the expression, we increment its counter. For a right parenthesis, we check if <code>right_count &lt; left_count</code>. If this is the case then only we consider that right parenthesis and recurse further. Otherwise we don't as we know it will make the expression invalid. This simple optimization saves a lot of runtime.</p>
<p>Now, let us look at the implementation for this algorithm.</p>
<p><a href="https://leetcode.com/playground/ZNSLoChx/shared">code</a></p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time Complexity : <span class="math inline">\(O(2^N)\)</span> since in the worst case we will have only left parentheses in the expression and for every bracket we will have two options i.e. whether to remove it or consider it. Considering that the expression has <span class="math inline">\(N\)</span> parentheses, the time complexity will be <span class="math inline">\(O(2^N)\)</span>.</li>
<li>Space Complexity : <span class="math inline">\(O(N)\)</span> because we are resorting to a recursive solution and for a recursive solution there is always stack space used as internal function states are saved onto a stack during recursion. The maximum depth of recursion decides the stack space used. Since we process one character at a time and the base case for the recursion is when we have processed all of the characters of the expression string, the size of the stack would be <span class="math inline">\(O(N)\)</span>. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.<br />
<br /><br />
<br /></li>
</ul>
<hr />
<h3 id="approach-2-limited-backtracking">Approach 2: Limited Backtracking!</h3>
<p>Although the previous solution does get accepted on the platform, it is a very inefficient solution because we try removing each and every possible parentheses from the expression and in the end we check two things:</p>
<ol>
<li>if the expression is valid or not</li>
<li>if the total number of removed parentheses removed in the current recursion is less than the global minimum till now or not.</li>
</ol>
<p>We cannot determine which of the parentheses are misplaced because, as the problem statement puts across, we can remove multiple combinations of parentheses and end up with a valid expression. This means there can be multiple valid expressions from a single invalid expression and we have to find all of them.</p>
<blockquote>
<p>The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed.</p>
</blockquote>
<p>What if we could determine this count?</p>
<p>What if in addition to determining this count of characters to be removed, we could also determine the number of left parentheses and number of right parentheses to be removed from the original expression to get <strong>any</strong> valid expression?</p>
<p>This would cut down the computations immensely and the runtime would plummet as a result. The reason for this is, if we knew how many left and right parentheses are to be removed from the original expression to get a valid expression, we would cut down on so many unwanted recursive calls.</p>
<p>Imagine the original expression to be 1000 characters with only 3 misplaced <code>(</code> parentheses and 2 misplaced <code>)</code> parentheses. In our previous solution we would end up trying to remove each one of left and right parentheses and try to reach a valid expression in the end whereas we should only be trying out removing 3 <code>(</code> brackets and 2 <code>)</code> brackets.</p>
<blockquote>
<p>This is the exact number of <code>(</code> and <code>)</code> that have to be removed to get a valid expression. No more, no less.</p>
</blockquote>
<p>Let us look at how we can find out the number of misplaced left and right parentheses in a given expression first and then we will slightly modify our original algorithm to incorporate these counts as well.</p>
<ol>
<li>We process the expression one bracket at a time starting from the left.</li>
<li>Suppose we encounter an opening bracket i.e. <code>(</code>, it may or may not lead to an invalid expression because there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we simply increment the counter keeping track of left parentheses till now. <code>left += 1</code></li>
<li>If we encounter a closing bracket, this has two meanings:
<ul>
<li>Either there was no matching opening bracket for this closing bracket and in that case we have an invalid expression. This is the case when <code>left == 0</code> i.e. when there are no unmatched left brackets available. In such a case we increment another counter say <code>right += 1</code> to represent misplaced right parentheses.</li>
<li>Or, we had some unmatched opening bracket available to match this closing bracket. This is the case when <code>left &gt; 0</code>. In this case we simply decrement the left counter we had i.e. <code>left -= 1</code></li>
</ul>
</li>
<li>Continue processing the string until all parentheses have been processed.</li>
<li>In the end the values of <code>left</code> and <code>right</code> would tell us the number of unmatched <code>(</code> and <code>)</code> parentheses respectively.</li>
</ol>
<p>Now that we have these two values available that tell us the total number of left i.e. <code>(</code> and right i.e. <code>)</code> parentheses that have to be removed to make the invalid expression valid, we will modify our original algorithm discussed in the previous session to avoid unwanted recursions.</p>
<p><strong>Algorithm</strong></p>
<p>The overall algorithm remains exactly the same as before. The changes that we will incorporate are listed below:</p>
<ul>
<li>The state of the recursion is now defined by five different variables:
<ol>
<li><code>index</code> which represents the current character that we have to process in the original string.</li>
<li><code>left_count</code> which represents the number of left parentheses that have been added to the expression we are building.</li>
<li><code>right_count</code> which represents the number of right parentheses that have been added to the expression we are building.</li>
<li><code>left_rem</code> is the number of left parentheses that remain to be removed.</li>
<li><code>right_rem</code> represents the number of right parentheses that remain to be removed. Overall, for the final expression to be valid, <code>left_rem == 0</code> and <code>right_rem == 0</code>.</li>
</ol>
</li>
<li>When we decide to not consider a parenthesis i.e. delete a parenthesis, be it a left or a right parentheses, we have to consider their corresponding remaining counts as well. This means that we can only discard a left parentheses if <code>left_rem &gt; 0</code> and similarly for the right one we will check for <code>right_rem &gt; 0</code>.</li>
<li>There are no changes to checks for <strong>considering</strong> a parenthesis. Only the conditions change for <strong>discarding</strong> a parenthesis.</li>
<li>Condition for an expression being valid in the base case would now become <code>left_rem == 0 and right_rem == 0</code>. Note that we don't have to check if <code>left_count == right_count</code> anymore because in the case of a valid expression, we would have removed all the misplaced or invalid parenthesis by the time the recursion ends. So, the only check we need if <code>left_rem == 0 and right_rem == 0</code>.</li>
</ul>
<blockquote>
<p>The most important thing here is that we have completely gotten rid of checking if the number of parentheses removed is lesser than the current minimum or not. The reason for this is we always remove the same number of parentheses as defined by <code>left_rem + right_rem</code> at the start of recursion.</p>
</blockquote>
<p>Now let us look at the implementation for this modified version of algorithm.</p>
<p><a href="https://leetcode.com/playground/bjCaADnt/shared">code</a></p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time Complexity : The optimization that we have performed is simply a better form of pruning. Pruning here is something that will vary from one test case to another. In the worst case, we can have something like <code>(((((((((</code> and the <code>left_rem = len(S)</code> and in such a case we can discard all of the characters because all are misplaced. So, in the worst case we <strong>still</strong> have 2 options per parenthesis and that gives us a complexity of <span class="math inline">\(O(2^N)\)</span>.</li>
<li>Space Complexity : The space complexity remains the same i.e. <span class="math inline">\(O(N)\)</span> as previous solution. We have to go to a maximum recursion depth of <span class="math inline">\(N\)</span> before hitting the base case. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.</li>
</ul>
<br />
<br /></div>
				</div>
		</div>

<div class="question-card" id="question-191">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-methods-from-project/description" target="_blank" rel="noopener noreferrer">Remove Methods From Project</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are maintaining a project that has <code>n</code> methods numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given two integers <code>n</code> and <code>k</code>, and a 2D integer array <code>invocations</code>, where <code>invocations[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that method <code>a<sub>i</sub></code> invokes method <code>b<sub>i</sub></code>.</p>

<p>There is a known bug in method <code>k</code>. Method <code>k</code>, along with any method invoked by it, either <strong>directly</strong> or <strong>indirectly</strong>, are considered <strong>suspicious</strong> and we aim to remove them.</p>

<p>A group of methods can only be removed if no method <strong>outside</strong> the group invokes any methods <strong>within</strong> it.</p>

<p>Return an array containing all the remaining methods after removing all the <strong>suspicious</strong> methods. You may return the answer in <em>any order</em>. If it is not possible to remove <strong>all</strong> the suspicious methods, <strong>none</strong> should be removed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, k = 1, invocations = [[1,2],[0,1],[3,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,1,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/18/graph-2.png" style="width: 200px; height: 200px;" /></p>

<p>Method 2 and method 1 are suspicious, but they are directly invoked by methods 3 and 0, which are not suspicious. We return all elements without removing anything.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, k = 0, invocations = [[1,2],[0,2],[0,1],[3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/18/graph-3.png" style="width: 200px; height: 200px;" /></p>

<p>Methods 0, 1, and 2 are suspicious and they are not directly invoked by any other method. We can remove them.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, k = 2, invocations = [[1,2],[0,1],[2,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/20/graph.png" style="width: 200px; height: 200px;" /></p>

<p>All methods are suspicious. We can remove them.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= k &lt;= n - 1</code></li>
	<li><code>0 &lt;= invocations.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>invocations[i] == [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>invocations[i] != invocations[j]</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-192">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description" target="_blank" rel="noopener noreferrer">Reorder Routes to Make All Paths Lead to the City Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.</p>

<p>Roads are represented by <code>connections</code> where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a road from city <code>a<sub>i</sub></code> to city <code>b<sub>i</sub></code>.</p>

<p>This year, there will be a big event in the capital (city <code>0</code>), and many people want to travel to this city.</p>

<p>Your task consists of reorienting some roads such that each city can visit the city <code>0</code>. Return the <strong>minimum</strong> number of edges changed.</p>

<p>It&#39;s <strong>guaranteed</strong> that each city can reach city <code>0</code> after reorder.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png" style="width: 311px; height: 189px;" />
<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>Change the direction of edges show in red such that each node can reach the node 0 (capital).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png" style="width: 509px; height: 79px;" />
<pre>
<strong>Input:</strong> n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
<strong>Output:</strong> 2
<strong>Explanation: </strong>Change the direction of edges show in red such that each node can reach the node 0 (capital).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3, connections = [[1,0],[2,0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>connections.length == n - 1</code></li>
	<li><code>connections[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a tree with <code>n</code> nodes where each node is a city numbered from <code>0</code> to <code>n - 1</code>. The edges are referred to as roads between the cities.</p>
<p>The tree given in the problem has directed edges provided by <code>connections</code>.</p>
<p>We need to return the number of edges that need to be flipped so that from every node, you can somehow reach node <code>0</code>, i.e., there is a path from every node to node <code>0</code>.</p>
<p>Before moving on to the solution, consider some of the graph terminologies that will be used later:</p>
<p><img src="../Figures/1466/1466-1.png" alt="img" /></p>
<ol>
<li><strong>Child</strong>: A node that is one edge further away from a given node in a rooted tree. In the above image, nodes <code>3, 4</code> are children of <code>1</code>, which is called the parent. (When we consider <code>0</code> as the root)</li>
<li><strong>Descendants</strong>: Descendants of a node are children, children of children, and so on. In the above image, nodes <code>3, 4, 6, 7, 9</code> are all descendants of <code>1</code>.</li>
<li><strong>Subtree</strong>: A subtree of a node <code>T</code> is a tree <code>S</code> consisting of a node <code>T</code> and all of its descendants in <code>T</code>. The subtree corresponding to the root node is the entire tree.</li>
</ol>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Because we need to bring everyone to node <code>0</code>, we can model the graph as a tree rooted at node <code>0</code> (the problem statement hints at this by stating that the network forms a tree structure). We can imagine that in order to move from any node to the root, all edges must be directed from a child to its parent. If there is an edge from a parent node to its child node, no node in the subtree of the child can reach the root node. This edge must be flipped.</p>
<p>Let's take a visual example to understand this.</p>
<p><img src="../Figures/1466/1466-2.png" alt="img" /></p>
<p><strong>So, our task is to count the number of edges in a tree rooted at node '0' that are directed from the parent node to a child node.</strong></p>
<p>We must traverse the entire tree to determine the number of such edges that are directed from the parent to the child node. To traverse the tree, we can use a graph traversal algorithm such as depth-first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<p>The caveat is that our edges are directed. To count the number of edges that are directed from a parent to its child node, we must traverse the entire tree. If there is an edge from a child to its parent node, we will be unable to reach the child from the parent.</p>
<p>To traverse the entire tree, we must find a way to get from node <code>0</code> to all of the nodes in any case. This is possible if the edges are treated as undirected. We add an opposite edge from node <code>b</code> to node <code>a</code> for every given edge in <code>connections</code> from node <code>a</code> to node <code>b</code>. Let us refer to the edge we added as an &quot;artificial&quot; edge and the edge present in <code>connections</code> as an &quot;original&quot; edge.</p>
<p>If we use an &quot;artificial&quot; edge to move from the parent node to the child node, we know that the original edge is directed from the child node to the parent node. We don't need to flip the &quot;original&quot; edge.</p>
<p>If we use an &quot;original&quot; edge to move from the parent node to the child node, it means we need to flip this edge. Whenever we encounter such an edge, we will increment our answer variable by <code>1</code>.</p>
<p>We can distinguish between an &quot;original&quot; and an &quot;artificial&quot; edge in many different ways (assigning booleans, specific numbers, etc.). In this article, we will associate an extra value with each edge - <code>1</code> for &quot;original&quot; edges and <code>0</code> for &quot;artificial&quot; edges.</p>
<p>We also set an answer variable <code>count = 0</code> to count the number of edges that must be flipped. Now we start a DFS from node <code>0</code> and work our way down the tree (from parent to child). If we come across an &quot;original&quot; edge during the traversal, that is, an edge labeled with a <code>1</code>, we increase the <code>count</code> by one. We don't modify <code>count</code> if we come across an &quot;artificial&quot; edge. We can combine these two operations and perform <code>count += sign</code> where <code>sign</code> is either <code>0</code> or <code>1</code> indicating an &quot;artificial&quot; or &quot;original&quot; edge.</p>
<p>We have our answer in <code>count</code> at the end of the traversal.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>count</code> to count the number of edges that must be flipped. We initialize it with <code>0</code>.</li>
<li>Create an adjacency list <code>adj</code> that contains a list of pairs of integers such that <code>adj[node]</code> contains all the neighbors of <code>node</code> in the form of <code>(neighbor, sign)</code> where <code>neighbor</code> is the neighboring node of <code>node</code> and <code>sign</code> denotes the direction of the edge i.e., whether its an &quot;original&quot; or &quot;artificial&quot; edge.</li>
<li>Start a DFS traversal.
<ul>
<li>We use a function <code>dfs</code> to perform the traversal. For each call, pass <code>node, parent, adj</code> as the parameters. We start with node <code>0</code> and parent as <code>-1</code>.</li>
<li>Iterate over all the neighbors of the <code>node</code> (nodes that share an edge) using <code>adj[node]</code>. For every <code>neighbor, sign</code> in <code>adj[node]</code>, check if <code>neighbor</code> is equal to <code>parent</code>. If <code>neighbor</code> is equal to <code>parent</code>, we will not visit it again.</li>
<li>If <code>neighbor</code> is not equal to <code>parent</code>, we perform <code>count += sign</code> and recursively call the <code>dfs</code> with <code>node = neighbor</code> and <code>parent = node</code>. At the end of the <code>dfs</code> traversal, we have the total edges that are required to be flipped in <code>count</code>.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ELVVivHQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We need <span class="math inline">\(O(n)\)</span> time to initialize the adjacency list.</li>
<li>The <code>dfs</code> function visits each node once, which takes <span class="math inline">\(O(n)\)</span> time in total. Because we have undirected edges, each edge can only be iterated twice (by nodes at the end), resulting in <span class="math inline">\(O(e)\)</span> operations total while visiting all nodes, where <span class="math inline">\(e\)</span> is the number of edges. Because the given graph is a tree, there are <span class="math inline">\(n - 1\)</span> undirected edges, so <span class="math inline">\(O(n + e) = O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Another method is to use a breadth-first search (BFS) because we only need to find the number of edges that are directed from the parent node to the child node in a rooted tree. This approach is identical to the first one, we are just using BFS instead of DFS to perform the traversal.</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Leetcode Explore Card</a>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an integer variable <code>count</code> to count the number of edges that are to be flipped. We initialize it with <code>0</code>.</li>
<li>Create an adjacency list <code>adj</code> that contains a list of pairs of integers such that <code>adj[node]</code> contains all the neighbors of <code>node</code> in the form of <code>(neighbor, sign)</code> where <code>neighbor</code> is the neighboring node of <code>node</code> and <code>sign</code> denotes the direction of the edge i.e., whether its an &quot;original&quot; or &quot;artificial&quot; edge.</li>
<li>Start a BFS traversal.
<ul>
<li>We use a function <code>bfs</code> to perform the traversal. Pass <code>node, n, adj</code> as the parameters. We start with node <code>0</code>.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>We initialize a queue <code>q</code> of integers and push <code>0</code> into it. We also mark <code>0</code> as visited.</li>
<li>While the queue is not empty, we dequeue the first element <code>node</code> from the queue and iterate over all its neighbors using <code>adj[node]</code>. For each <code>neighbor, sign</code> in <code>adj[node]</code>, we check if <code>neighbor</code> has been visited already. If <code>neighbor</code> has not yet been visited, we mark it visited, perform <code>count += sign</code>, and push <code>neighbor</code> into the queue.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/SLiFjRGY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We need <span class="math inline">\(O(n)\)</span> time to initialize the adjacency list and <span class="math inline">\(O(n)\)</span> to initialize the <code>visit</code> array.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can only be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue, so for an undirected edge, a given edge could be iterated at most twice (by nodes at both ends), resulting in <span class="math inline">\(O(e)\)</span> operations total for all the nodes. As mentioned in the previous approach, <span class="math inline">\(O(e) = O(n)\)</span> since the graph is a tree.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space as well.</li>
<li>The BFS queue takes <span class="math inline">\(O(n)\)</span> space in the worst-case because each node is added once.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-193">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-odd-levels-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Reverse Odd Levels of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a <strong>perfect</strong> binary tree, reverse the node values at each <strong>odd</strong> level of the tree.</p>

<ul>
	<li>For example, suppose the node values at level 3 are <code>[2,1,3,4,7,11,29,18]</code>, then it should become <code>[18,29,11,7,4,3,1,2]</code>.</li>
</ul>

<p>Return <em>the root of the reversed tree</em>.</p>

<p>A binary tree is <strong>perfect</strong> if all parent nodes have two children and all leaves are on the same level.</p>

<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/28/first_case1.png" style="width: 626px; height: 191px;" />
<pre>
<strong>Input:</strong> root = [2,3,5,8,13,21,34]
<strong>Output:</strong> [2,5,3,8,13,21,34]
<strong>Explanation:</strong> 
The tree has only one odd level.
The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/28/second_case3.png" style="width: 591px; height: 111px;" />
<pre>
<strong>Input:</strong> root = [7,13,11]
<strong>Output:</strong> [7,11,13]
<strong>Explanation:</strong> 
The nodes at level 1 are 13, 11, which are reversed and become 11, 13.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]
<strong>Output:</strong> [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]
<strong>Explanation:</strong> 
The odd levels have non-zero values.
The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.
The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 2<sup>14</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>root</code> is a <strong>perfect</strong> binary tree.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the <code>root</code> of a perfect binary tree, and our task is to return the <code>root</code> after reversing the values at the odd levels of the tree.</p>
<blockquote>
<p>A binary tree is considered perfect if all parent nodes have exactly two children and all leaves are on the same level.<br />
The level of a node is defined as the number of edges along the path between it and the root node.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The structure of binary trees is inherently recursive; that is, each node's left and right children can themselves be considered the roots of smaller binary trees. This allows us to traverse the tree using recursion, breaking the problem into smaller, independent subproblems.</p>
<p>As we traverse the tree recursively, we process the left and right children of the current <code>root</code>. For nodes at even levels, we swap the values at their left and right child nodes to reverse the arrangement of nodes below their level, while leaving the children of odd levels unchanged.</p>
<p>Let's discuss the implementation of the recursive function <code>traverseDFS(node, leftChild, rightChild, int level)</code>:</p>
<ul>
<li>
<p>Base case: If <code>leftChild</code> or <code>rightChild</code> is null, then we can stop the recursive traversal for further child nodes.</p>
</li>
<li>
<p>Even level: If the current level is even, swap the values rooted at <code>leftChild</code> and <code>rightChild</code>.</p>
</li>
<li>
<p>Perfect binary tree: Since the binary tree is perfect, it is symmetrical in nature. Therefore, to reverse the levels, we would want to swap the left value of the left child with the right value of the right child, and the right value of the left child with the left value of the right child. This can be illustrated using the slideshow shown below:</p>
</li>
</ul>
<p>!?!../Documents/2415/slideshow.json:960,540!?!</p>
<blockquote>
<p>For a more comprehensive understanding of depth-first search, check out the <a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/">DFS Explore Card 🔗</a>. This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<p>Main function - <code>reverseOddLevels(Node root)</code></p>
<ul>
<li>Call <code>traverseDFS</code> with the left and right children of the root, starting at level 0.</li>
</ul>
<p><code>traverseDFS</code> function:</p>
<ul>
<li>
<p>If either <code>leftChild</code> or <code>rightChild</code> is null, return immediately (base case).</p>
</li>
<li>
<p>If the current <code>level</code> is even (odd-level swapping occurs at 0-based indexing):</p>
<ul>
<li>Swap the values of <code>leftChild</code> and <code>rightChild</code> using a temporary variable.</li>
</ul>
</li>
<li>
<p>Recursively call <code>traverseDFS</code> for the next level:</p>
<ul>
<li>Call <code>traverseDFS</code> with <code>leftChild.left</code> and <code>rightChild.right</code> (mirroring structure).</li>
<li>Call <code>traverseDFS</code> with <code>leftChild.right</code> and <code>rightChild.left</code> (mirroring structure).</li>
</ul>
</li>
<li>
<p>Continue recursion until all levels of the tree are processed.</p>
</li>
<li>
<p>Return the updated <code>root</code> after all odd levels are reversed.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/GrucV3hM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the given tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, the algorithm visits each node exactly once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>. The swapping at each recursive step takes constant time. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log n))\)</span></p>
<p>The space complexity is determined by the recursion depth of the DFS. Since we are given a perfect binary tree, the height of the tree is bounded by <span class="math inline">\(\log n\)</span>. Therefore, the space complexity is given by <span class="math inline">\(O(\log n))\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of DFS, we can use a breadth-first search (BFS) to traverse the tree level by level and reverse values at odd levels. We start by adding the root node to a queue, which helps manage nodes at each level.</p>
<p>For each level, we will pop all the nodes currently in the queue, which represent the nodes at the current level. Then, we will push their children to the queue to represent the next level. This ensures that the queue always contains the nodes for just one level at a time. When processing odd levels, we will collect the values of the nodes in an array, reverse that array, and then update the nodes' values with the reversed values. This step only happens for odd levels, while even levels remain unchanged.</p>
<p>This process continues until all levels are traversed. Finally, we return the root with the values at odd levels reversed.</p>
<blockquote>
<p>For a more comprehensive understanding of breadth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card 🔗</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a queue <code>queue</code> to store the level-order traversal of the tree. Initialize it with the <code>root</code> node.</li>
<li>Initialize a variable <code>level</code> to <code>0</code> to keep track of the current tree level.</li>
<li>Perform BFS traversal:
<ul>
<li>While the <code>queue</code> is not empty, process the nodes level by level:
<ul>
<li>Retrieve the size of the current level using the queue size.</li>
<li>Create a list, <code>currentLevelNodes</code>, to store all nodes at the current level.</li>
<li>Iterate over all nodes in the current level:
<ul>
<li>Dequeue each node and add it to <code>currentLevelNodes</code>.</li>
<li>Enqueue its left and right children (if they exist) to the queue for the next level.</li>
</ul>
</li>
<li>Check if the current level is odd:
<ul>
<li>If <code>level % 2 == 1</code>, reverse the values of nodes in <code>currentLevelNodes</code>.</li>
<li>Use two pointers (<code>left</code> and <code>right</code>) to swap values from the leftmost and rightmost ends of the list.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Increment the <code>level</code> counter after processing each level.</li>
<li>Return the <code>root</code> node after completing the traversal and reversing odd levels.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/LQ6yoTvx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the tree, processing each level of nodes. The main loop performs BFS traversal, visiting each node exactly once, which results in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, at each level, the algorithm checks if it is odd and reverses the node values if necessary. This operation occurs for each node in the queue and takes constant time per node. The overall time complexity is dominated by the BFS traversal, resulting in <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space used by the algorithm is determined by the queue that holds the nodes at each level during BFS traversal. At most, the queue will hold all the nodes at one level, which is bounded by the number of nodes in the tree, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Other space requirements are constant and do not contribute significantly to the space complexity. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-194">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotting-oranges/description" target="_blank" rel="noopener noreferrer">Rotting Oranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values:</p>

<ul>
	<li><code>0</code> representing an empty cell,</li>
	<li><code>1</code> representing a fresh orange, or</li>
	<li><code>2</code> representing a rotten orange.</li>
</ul>

<p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p>

<p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" style="width: 650px; height: 137px;" />
<pre>
<strong>Input:</strong> grid = [[2,1,1],[1,1,0],[0,1,1]]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[2,1,1],[0,1,1],[1,0,1]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since there are already no fresh oranges at minute 0, the answer is just 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10</code></li>
	<li><code>grid[i][j]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-195">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/same-tree/description" target="_blank" rel="noopener noreferrer">Same Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>

<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" style="width: 622px; height: 182px;" />
<pre>
<strong>Input:</strong> p = [1,2,3], q = [1,2,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" style="width: 382px; height: 182px;" />
<pre>
<strong>Input:</strong> p = [1,2], q = [1,null,2]
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" style="width: 622px; height: 182px;" />
<pre>
<strong>Input:</strong> p = [1,2,1], q = [1,1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-196">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/second-minimum-time-to-reach-destination/description" target="_blank" rel="noopener noreferrer">Second Minimum Time to Reach Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A city is represented as a <strong>bi-directional connected</strong> graph with <code>n</code> vertices where each vertex is labeled from <code>1</code> to <code>n</code> (<strong>inclusive</strong>). The edges in the graph are represented as a 2D integer array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a bi-directional edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by <strong>at most one</strong> edge, and no vertex has an edge to itself. The time taken to traverse any edge is <code>time</code> minutes.</p>

<p>Each vertex has a traffic signal which changes its color from <strong>green</strong> to <strong>red</strong> and vice versa every&nbsp;<code>change</code> minutes. All signals change <strong>at the same time</strong>. You can enter a vertex at <strong>any time</strong>, but can leave a vertex <strong>only when the signal is green</strong>. You <strong>cannot wait </strong>at a vertex if the signal is <strong>green</strong>.</p>

<p>The <strong>second minimum value</strong> is defined as the smallest value<strong> strictly larger </strong>than the minimum value.</p>

<ul>
	<li>For example the second minimum value of <code>[2, 3, 4]</code> is <code>3</code>, and the second minimum value of <code>[2, 2, 4]</code> is <code>4</code>.</li>
</ul>

<p>Given <code>n</code>, <code>edges</code>, <code>time</code>, and <code>change</code>, return <em>the <strong>second minimum time</strong> it will take to go from vertex </em><code>1</code><em> to vertex </em><code>n</code>.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li>You can go through any vertex <strong>any</strong> number of times, <strong>including</strong> <code>1</code> and <code>n</code>.</li>
	<li>You can assume that when the journey <strong>starts</strong>, all signals have just turned <strong>green</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e1.png" style="width: 200px; height: 250px;" /> &emsp; &emsp; &emsp; &emsp;<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e2.png" style="width: 200px; height: 250px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
<strong>Output:</strong> 13
<strong>Explanation:</strong>
The figure on the left shows the given graph.
The blue path in the figure on the right is the minimum time path.
The time taken is:
- Start at 1, time elapsed=0
- 1 -&gt; 4: 3 minutes, time elapsed=3
- 4 -&gt; 5: 3 minutes, time elapsed=6
Hence the minimum time needed is 6 minutes.

The red path shows the path to get the second minimum time.
- Start at 1, time elapsed=0
- 1 -&gt; 3: 3 minutes, time elapsed=3
- 3 -&gt; 4: 3 minutes, time elapsed=6
- Wait at 4 for 4 minutes, time elapsed=10
- 4 -&gt; 5: 3 minutes, time elapsed=13
Hence the second minimum time is 13 minutes.      
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/eg2.png" style="width: 225px; height: 50px;" />
<pre>
<strong>Input:</strong> n = 2, edges = [[1,2]], time = 3, change = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong>
The minimum time path is 1 -&gt; 2 with time = 3 minutes.
The second minimum time path is 1 -&gt; 2 -&gt; 1 -&gt; 2 with time = 11 minutes.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>Each vertex can be reached directly or indirectly from every other vertex.</li>
	<li><code>1 &lt;= time, change &lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<h3 id="overview">Overview</h3>
<p>The problem is to find the second minimum distance (&quot;strictly larger value&quot; than minimum value) in a weighted graph where the traversal over any edge is only possible at certain intervals. The second minimum distance can either come by iterating over some nodes in the path multiple times (as shown in second example of the description) or there could be a longer path than the shortest path with all the nodes occurring just once (as shown in first example of the description).</p>
<h3 id="approach-1-dijkstra">Approach 1: Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>The shortest distance problem in a weighted graph directly leads to thinking about the Dijkstra algorithm. However, the standard Dijkstra does not work here, since we want to find the second minimum distance to reach node <code>n</code>. We may need to modify it a bit to make it work.</p>
<p>Let’s try to recap quickly how the standard Dijkstra looks and the corresponding changes we would need to solve this problem.</p>
<h5 id="standard-dijkstra">Standard Dijkstra</h5>
<ul>
<li>We use an array <code>distance</code> to maintain the shortest distance to each node so far. For any node <code>X</code> except the source node, <code>distance[X]</code> is initialized with infinity. We also maintain a priority queue storing the node and its shortest distance. Whenever any of <code>X</code>'s neighbors is popped out of the priority queue, if the total distance to <code>X</code> via the neighbors is lesser than the <code>distance[X]</code>, <code>distance[X]</code> is updated to the new shortest distance and get pushed into the priority queue.</li>
<li>Whenever a node <code>Y</code> is popped out of the queue, we have the minimum distance for the node <code>Y</code> which cannot be reduced further. If there was a shorter path for <code>Y</code>, it would have been covered before since we use a priority queue in the implementation. We iterate over the neighbors of <code>Y</code> to check if any child could be updated.</li>
</ul>
<h5 id="modified-dijkstra">Modified Dijkstra</h5>
<p>Since we need to find the second minimal distance, an idea is to maintain both the minimal and the second minimal distance.</p>
<ul>
<li>We would use two distance arrays, <code>dist1</code> and <code>dist2</code> to maintain the shortest and second shortest distance (&quot;strictly larger value&quot; than the minimum value) to each node so far. For any node <code>X</code> except the source node, <code>dist1[X]</code> and <code>dist2[X]</code> are initialized with infinity. We would maintain a priority queue storing the node, its shortest distance, and also its second shortest distance. Whenever any of <code>X</code>'s neighbors is popped out of the priority queue, if the total distance to <code>X</code> via the neighbors is less than <code>dist1[X]</code>, <code>dist1[X]</code> is updated and pushed to the queue. Else, we try to update <code>dist2[X]</code> if possible and push it to the priority queue.</li>
<li>Whenever a node <code>Y</code> is popped out of the queue for the first time, we have the minimum distance for the node <code>Y</code> which cannot be reduced further. In this case, we would use <code>dist1[Y]</code> as the distance to reach node <code>Y</code> to compute the total distance of its neighbours. If it pops out a second time, we have the second minimum distance for the node <code>Y</code>. Now, we would use <code>dist2[Y]</code> as the distance to reach node <code>Y</code> to compute the total distance of its neighbours.</li>
</ul>
<h4 id="green-and-red-light-constraint">Green and Red Light Constraint</h4>
<p>In the previous analysis, we discussed how to solve the second minimal distance problem generally with modified Dijkstra. Still, the problem has another part: the constraint on the green and red lights. Let's think about how to handle it.</p>
<p>Under the green and red traffic light constraint, the time it takes to pass the edge is no longer the weight of the edge. We need to be careful when updating the distance in the Dijkstra algorithm.</p>
<p>Please take a look at the image which helps to handle this constraint (<code>c</code> in the figure means the value <code>change</code>):</p>
<p><img src="../Figures/2045/2045-1.png" alt="img" /></p>
<p>There are some observations from the figure. If the current time falls between <code>2 * m * c</code> and <code>2 * m * c + c</code>, where <code>m</code> is any integer, we have a green signal for the node, otherwise, we have a red signal. We can pass the green signal straight way but would have to wait at the red signal till it turns green.</p>
<p>The time taken to go through an edge could be presented as the following code:</p>
<pre><code>// `timeTaken` represent the total time taken to reach the current node,
// and we want to move to its neighbors.
if ((timeTaken / change) % 2) {
    // red light, we need to wait for the next green light
    timeTakenToReachNeighbor = change * (timeTaken / change + 1) + time;
} else {
    // green light, just pass
    timeTakenToReachNeighbor = timeTaken + time;
}
</code></pre>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an adjacency list where <code>adj[X]</code> contains all the neighbors of node <code>X</code>.</li>
<li>Initialize two distance arrays <code>dist1</code> and <code>dist2</code> storing the minimum and the second minimum distance from node <code>1</code> for all the nodes. We would initialize these arrays with large integer values.</li>
<li>Initialize a frequency array <code>freq</code> to store the number of times when a node is popped out of the queue. Since we need the second minimal distance, each node can be poped out at most twice.</li>
<li>Initialize a priority queue storing a <code>{distance, node_id}</code> pair, ordered by the distance. Insert node <code>1</code> with distance <code>0</code> into the queue as <code>{0, 1}</code>.</li>
<li>Perform the Dijkstra until the priority queue is empty.
<ul>
<li>Pop out the top pair of integers, and fetch the node (let's say it is <code>Y</code>) and distance to reach node <code>Y</code>.</li>
<li>Increase <code>freq[Y]</code> by 1.</li>
<li>If <code>Y == n</code> and <code>freq[n] == 2</code>, it means we’ve encountered this node via the second minimum distance. In this case, we return <code>dist2[n]</code>.</li>
<li>Else, iterate over all the neighbors of <code>Y</code>.</li>
<li>For each <code>neighbor</code>, check if <code>dist1[neighbor]</code> could be updated using <code>distance[Y]</code>. If not, check if <code>dist2[neighbor]</code> could be updated.</li>
<li>Push pair <code>{distance_neighbor, neighbor}</code> into the queue whenever <code>dist1[neighbor]</code> or <code>dist2[neighbor]</code> is updated.</li>
</ul>
</li>
<li>If we do not return the answer after the queue is empty, we know that the graph only has one node. Therefore, we just return <code>0</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/eWxFfyDc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of cities and <span class="math inline">\(E\)</span> be the total edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + E \cdot \log N)\)</span>.</p>
<ul>
<li>Our algorithm has twice the complexity as the Dijkstra algorithm. We pop twice and use the node to calculate the minimum and second miimum distance. Since 2 is a constant factor, it actually has the same time complexity as the standard Dijkstra algorithm.</li>
<li>For standard Dijkstra, the maximum number of vertices that could be added to the priority queue is <span class="math inline">\(E\)</span> and each operation takes <span class="math inline">\(O(log E)\)</span> time. Thus, push and pop operations on the priority queue take <span class="math inline">\(O(E \cdot log E)\)</span> time. The value of <span class="math inline">\(E\)</span> can be at most <span class="math inline">\(N \cdot (N−1)\)</span>, so  <span class="math inline">\(O(E \cdot log E) = O(E \cdot log(N^2)) = O(E \cdot log N)\)</span>. It also takes <span class="math inline">\(O(N + E)\)</span> for adjacency list and dist array initializations. Therefore, the total complexity is <span class="math inline">\(O(N+E \cdot log N)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(N + E)\)</span> space. For the Dijkstra algorithm, each vertex is added to the queue at most <span class="math inline">\(N−1\)</span> times, so the space it takes is <span class="math inline">\(N \cdot (N−1) = O(N^2) = O(E)\)</span>. For the distance and frequency arrays, they take <span class="math inline">\(O(N)\)</span> space.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>If you are not much familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">Leetcode Explore Card</a> and have some knowledge of it beforehand.</p>
<p>The given problem involves a city, which is represented as a bi-directionally connected graph with <code>n</code> vertices and some edges. The cost of passing through each edge takes an equal amount of <code>time</code>. We also have some red-to-green signal transitions that happen at the same time, i.e., all signals switch from red to green (and vice-versa) at the same time after every <code>change</code> interval.</p>
<p>Since each edge takes an equal amount of time to cross and the red-signal transitions happen at the same time, we can observe that the time taken for any equal-length path in terms of steps taken would be similar. This is because we would be taking <code>time</code> to cross each edge and would also be waiting at the red signals at the same time.</p>
<p>Let's use an example to understand this more. If we start at the time <code>T = 0</code> from node <code>1</code>, we can reach any node one edge away at <code>T = time</code>. Let's assume we've got a green signal now. We would cross another edge to reach any node two edges away at <code>T = 2 * time</code>. Suppose, we have a red signal now and it takes <code>c</code> time to switch back to green. We would start moving from the current node at <code>T = 2 * time + c</code> and reach any node three edges away at <code>T = 3 * time + c</code>. We cannot reach nodes at level three earlier than <code>3 * time + c</code>. If we take the longer route, it will undoubtedly take more time.</p>
<p>This shows that the shortest length path in terms of steps would be the ideal path to compute the minimum time to reach node <code>n</code> and the second shortest length path would be the ideal path to compute the second minimum time. In this case, all the weight is <code>1</code> so the graph is unweighted. Therefore, we only need to focus on the number of steps to reach the target node instead of time. Hence, Dijkstra was overkill.</p>
<p>As we know, the path used in BFS traversal always has the least number of edges. The BFS algorithm does a level-wise iteration of the graph. As a result, it first finds all paths that are one edge away from the source node, followed by all paths that are two edges away from the source node, and so on. This allows BFS to find the shortest path in terms of steps from the source node to any other node. The time spent at red light crossings will be calculated in the same way as in the first approach. We will use this concept to solve the problem.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an adjacency list where <code>adj[X]</code> contains all the neighbors of node <code>X</code>.</li>
<li>Initialise two distance arrays <code>dist1</code> and <code>dist2</code> storing the minimum and second minimum distance from node 1 for all the nodes. We would initialize these arrays with <code>-1</code>.</li>
<li>Initialize a queue with a pair of integers <code>(node, freq)</code> and insert  <code>{1, 1}</code> where the first integer denotes the node and the second denotes the frequency of the visit.</li>
<li>Pop out the front pair from the queue and iterate over the neighbors of the node updating the <code>dist1</code> and <code>dist2</code> accordingly (as we did above).</li>
<li>If <code>dist1[child] = -1</code>, it means this is the first time we are visiting this node, so update the <code>dist1[child]</code>. This is the minimum distance of the node <code>child</code>. Else, check similarly for <code>dist2[child]</code> to compute the second minimum distance and ensure it is not equal to <code>dist1[child]</code>.</li>
</ol>
<blockquote>
<p>The important point to learn here is that this approach works only because the graph is equally weighted for all edges.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YgLQPMf5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of cities and <span class="math inline">\(E\)</span> be the total edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>The complexity would be similar to the standard BFS algorithm since we’re iterating at most twice over a node.</li>
<li>For the BFS algorithm, each single queue operation takes <span class="math inline">\(O(1)\)</span>, and a single node could be pushed at most once leading <span class="math inline">\(O(N)\)</span> operations. For each node popped out of the queue we iterate over all its neighbors, so for an undirected edge, a given edge could be iterated at most twice (by nodes at the end) which leads to <span class="math inline">\(O(E)\)</span> operations in total for all the nodes and a total <span class="math inline">\(O(N + E)\)</span> time complexity.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span>.</p>
<ul>
<li>Building the adjacency list takes <span class="math inline">\(O(E)\)</span> space. The BFS queue takes <span class="math inline">\(O(N)\)</span> because each vertex is added at most once. The other distance arrays take <span class="math inline">\(O(N)\)</span> space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-197">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/serialize-and-deserialize-binary-tree/description" target="_blank" rel="noopener noreferrer">Serialize and Deserialize Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>

<p><strong>Clarification:</strong> The input/output format is the same as <a href="https://support.leetcode.com/hc/en-us/articles/32442719377939-How-to-create-test-cases-on-LeetCode#h_01J5EGREAW3NAEJ14XC07GRW1A" target="_blank">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" style="width: 442px; height: 324px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,null,4,5]
<strong>Output:</strong> [1,2,3,null,null,4,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-198">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/serialize-and-deserialize-bst/description" target="_blank" rel="noopener noreferrer">Serialize and Deserialize BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>

<p><b>The encoded string should be as compact as possible.</b></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,1,3]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-199">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/shift-string-2-e1383bdd/" target="_blank" rel="noopener noreferrer">Shift String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">brute-forcesearch</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string,&nbsp;<span class="mathjax-latex">\(s\)</span>, of length,&nbsp;<span class="mathjax-latex">\(n\)</span>,&nbsp;and a list of&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;strings, <span class="mathjax-latex">\(x_{1}, x_{2}, ..., x_{m}\)</span>.&nbsp; All <span class="mathjax-latex">\(m\)</span> strings in the list are distinct and have length <span class="mathjax-latex">\(n\)</span>&nbsp;<strong>i.e</strong> <span class="mathjax-latex">\(\forall i \hspace{0.1cm} |x_{i}| = n\)</span>, and none of the given strings is equal to&nbsp;<span class="mathjax-latex">\(s\)</span>.</p>

<p>You can perform any number of operations <span class="mathjax-latex">\(s\)</span>.</p>

<p>In an operation you are allowed to choose <strong>one</strong> position in the string, <span class="mathjax-latex">\(s\)</span>, and change the character at the position to the next or previous character in the English alphabet <strong>cyclically </strong>(<em>'<strong>a'</strong></em><strong><strong>&nbsp;</strong>-&gt;</strong>&nbsp;<strong><em>'b'</em></strong>, <strong><em>'b'</em></strong>&nbsp;<strong>-&gt;</strong> <strong><em>'c'</em></strong>, <strong><em>'c'</em></strong>&nbsp;<strong>-&gt;</strong> <strong><em>'d'</em></strong>, ...,&nbsp;<strong><em>'z'</em> -&gt; <em>'a', 'b' -&gt; 'a', ...</em></strong>).</p>

<p>What is the minimum number of operations that you have to perform on, <span class="mathjax-latex">\(s\)</span>, so for all the given&nbsp;<span class="mathjax-latex">\(m\)</span> strings,&nbsp;<span class="mathjax-latex">\(s\)</span> becomes <span class="mathjax-latex">\(x_{i}\)</span> at least once after one of the performed operations.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>INPUT FORMAT&nbsp;</strong></p>

<p>The first line of the input contains an integer,&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;<span class="mathjax-latex">\((1 &lt;= n &lt;= 5)\)</span>&nbsp;&nbsp; - denoting the length of the string <span class="mathjax-latex">\(s\)</span>.&nbsp;</p>

<p>The second line of the input contains a string, <span class="mathjax-latex">\(s\)</span>&nbsp;- denoting the string which you can perform operations on. Each character in <span class="mathjax-latex">\(s\)</span>&nbsp;is a lowercase English alphabet (<em><strong>'a' - 'z'</strong></em>).&nbsp;</p>

<p>The next line of the input contains an integer, <span class="mathjax-latex">\(m\)</span> <span class="mathjax-latex">\((1 &lt;= m &lt;= 15)\)</span>&nbsp;- denoting the number of strings that will be in the list.</p>

<p>The next&nbsp;<span class="mathjax-latex">\(m\)</span> lines <strong>distinct</strong> strings,&nbsp;<span class="mathjax-latex">\(x_{i}\)</span>&nbsp;(<span class="mathjax-latex">\(|x_{i}| = n\)</span>, <span class="mathjax-latex">\(x_{i} \neq s\)</span>)&nbsp; &nbsp;- denoting a string in the list. Each character in&nbsp;<span class="mathjax-latex">\(x_{i}\)</span>&nbsp;is a lowercase english alphabet (<em><strong>'a' - 'z'</strong></em>)</p>

<p>&nbsp;</p>

<p><strong>OUTPUT FORMAT&nbsp;</strong></p>

<p>The output should contain one line denoting the minimum amount of operations that need to be performed on <span class="mathjax-latex">\(s\)</span>, to reach each of the <span class="mathjax-latex">\(m\)</span> strings at least once.&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the sample input,&nbsp;<span class="mathjax-latex">\(s\)</span>&nbsp;= <strong>abc</strong>, and we have <strong>3</strong> strings <em><strong>zbe</strong></em>, <em><strong>zbc</strong></em>, and <em><strong>abd</strong></em>, that&nbsp;<span class="mathjax-latex">\(s\)</span> must become at least once, in one of the operations.&nbsp;</p>

<p>One way of reaching all <span class="mathjax-latex">\(3\)</span> strings using the minimum number of operations is:&nbsp;</p>

<ul>
	<li><strong>OPERATION 1: </strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> forward, <strong>s</strong> becomes = <strong>"abd" (s has now become <strong><span class="mathjax-latex">\(x_{3}\)</span></strong>)</strong>.&nbsp;</li>
	<li><strong>OPERATION 2:&nbsp;</strong>shift index <strong>0</strong> (0-indexed) in <strong>s</strong> backward, <strong>s</strong> becomes = <strong>"zbd"</strong>.</li>
	<li><strong>OPERATION 3:&nbsp;</strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> forward, <strong>s</strong> becomes = <strong>"zbe" (s has now become&nbsp;<strong><span class="mathjax-latex">\(x_{1}\)</span></strong>).</strong></li>
	<li><strong>OPERATION 4:&nbsp;</strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> backward, <strong>s</strong> becomes <strong>"zbd".</strong></li>
	<li><strong>OPERATION 5:&nbsp;</strong>shift index <strong>2</strong> (0-indexed) in <strong>s</strong> backward, <strong>s</strong> becomes <strong>"zbc" (s has now become&nbsp;<strong><span class="mathjax-latex">\(x_{2}\)</span></strong>).</strong></li>
</ul>

<p>It is not possible to reach all&nbsp;<span class="mathjax-latex">\(3\)</span> strings using less than&nbsp;<span class="mathjax-latex">\(5\)</span> operations. Hence, the answer to this input is <span class="mathjax-latex">\(5\)</span>.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-200">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-bridge/description" target="_blank" rel="noopener noreferrer">Shortest Bridge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> binary matrix <code>grid</code> where <code>1</code> represents land and <code>0</code> represents water.</p>

<p>An <strong>island</strong> is a 4-directionally connected group of <code>1</code>&#39;s not connected to any other <code>1</code>&#39;s. There are <strong>exactly two islands</strong> in <code>grid</code>.</p>

<p>You may change <code>0</code>&#39;s to <code>1</code>&#39;s to connect the two islands to form <strong>one island</strong>.</p>

<p>Return <em>the smallest number of </em><code>0</code><em>&#39;s you must flip to connect the two islands</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,1],[1,0]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,1,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There are exactly two islands in <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>As shown in the examples below, we need to flip at least <strong>3</strong> cells to connect island <code>A</code> and island <code>B</code> in the left case, and flip at least <strong>5</strong> cells in the right case.</p>
<p><img src="../Figures/934/intro.png" alt="img" /></p>
<hr />
<h3 id="approach-1-depth-first-search--breadth-first-search">Approach 1: Depth-First-Search + Breadth-First-Search</h3>
<h4 id="intuition">Intuition</h4>
<p>If you are not familiar with the Depth-First-Search (DFS) or the Breadth-First-Search (BFS) algorithms, please refer to our explore cards:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth-First-Search Explore Card</a></li>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth-First-Search Explore Card</a></li>
</ul>
<p>In order to find the minimum number of flips required to reach the destination island, or in other words, the minimum distance between the two islands, we can use a combination of DFS and BFS algorithms. Start by finding all the land cells on the first island (let's call it island <code>A</code>) using the DFS method.</p>
<p>Here's how: we start with one cell of island <code>A</code> and try to move to its four neighboring cells. If there is an unvisited neighboring land cell, we move to that cell and change its value to a number like <code>2</code> to avoid revisiting it again in the future and distinguish it from the land cells of the other island. We then repeat the same strategy from the new cell. If we find that the current cell has no unvisited neighbors, we will backtrack to the previous cell and try the next neighboring cell from there. The numbers on the cells in the following figure represent the order of our visits.</p>
<p><img src="../Figures/934/2.png" alt="img" /></p>
<p>Now that we have found all the cells in island <code>A</code> and set them to <code>2</code>, in <code>grid</code> we have:</p>
<ul>
<li><code>0</code> for the water cells.</li>
<li><code>2</code> for the land cells of the first island (island <code>A</code>)</li>
<li><code>1</code> for the land cells of the second island (island <code>B</code>)</li>
</ul>
<p>Then, we can use BFS to find the shortest distance from island <code>A</code> to island <code>B</code>. Here is the step-by-step process for the BFS algorithm:</p>
<ol>
<li>We start with all the cells in island <code>A</code> as the source, and set <code>distance</code> to <code>0</code>.</li>
<li>Add all the cells of island <code>A</code> to a list <code>bfs_queue</code>.</li>
<li>While <code>bfs_queue</code> is not empty, we build an empty list <code>new_bfs</code> as the candidate cells for the next BFS round, then we iterate over every cell <code>(x, y)</code> in <code>bfs_queue</code>.</li>
<li>Check the four neighbors of <code>(x, y)</code> (up, down, left, and right). If a valid neighbor has value of <code>0</code>, we can mark it as visited by setting the value as <code>-1</code>, then we can add this cell to the list <code>new_bfs</code>. If a neighbor cell has a value of <code>1</code>, it means that we have found a land cell of the second island (island <code>B</code>). Since we are traversing water cells in BFS approach, it means that the first cell of island <code>B</code> we found has the shortest distance from island <code>A</code> among all cells on island <code>B</code>.</li>
<li>Once the iteration (current round) ends, if we still haven't reached island <code>B</code>, it means that we should look for cells that have a longer distance from island <code>A</code>. Therefore, we increment <code>distance</code> by 1, set <code>bfs_queue = new_bfs</code>, and repeat step 3.</li>
</ol>
<p>This approach is shown in the picture below. The distance of each cell from island <code>A</code> is also shown.</p>
<ul>
<li>We start with all cells in island <code>A</code> that have a distance of 0.</li>
<li>In the first round, we visit all water cells that have a distance of 1 from island <code>A</code>.</li>
<li>In the second round, we visit all water cells that have a distance of 2 from island <code>A</code>.</li>
<li>In the third round, we visit all water cells that have a distance of 3 from island <code>A</code>.</li>
</ul>
<p>After 3 rounds of BFS search, we find some land cells of island <code>B</code> being the neighbors of water cells that have a distance of <code>3</code> from island <code>A</code>, we can stop the BFS search.</p>
<p><img src="../Figures/934/4.png" alt="img" /></p>
<p>The shortest distance between the two islands is 3, so we need at least 3 flips (highlighted in yellow) to connect them.</p>
<blockquote>
<p>Note that in this approach we are directly modifying the input to help us distinguish cells. It is generally not good practice to modify the input, and if the interviewer is against it, you can accomplish the same functionality by using a set to store cells that have already been visited instead.</p>
</blockquote>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Iterate over the grid <code>grid</code> until we find a land cell, suppose it is <code>grid[first_x][first_y]</code>.</p>
</li>
<li>
<p>Start from <code>grid[first_x][first_y]</code> and use depth-first search to find and set the values of all cells of the same island (island <code>A</code>) to <code>2</code>.</p>
</li>
<li>
<p>Create a list <code>bfs_queue</code> and add all cells on island <code>A</code> to it, starting with <code>distance = 0</code>.</p>
</li>
<li>
<p>While <code>bfs_queue</code> is not empty, we create another list <code>new_bfs</code> to collect the water cells we need to visit in the next round. Iterate over cells in <code>bfs_queue</code>, for each cell <code>(x, y)</code>:</p>
<ul>
<li>if <code>grid[x][y] = 1</code>, it means we have reached the second island, return <code>distance</code>.</li>
<li>Otherwise, we look for its unvisited water neighbors (cells with value <code>0</code>), mark them as <code>-1</code>, and add them to <code>new_bfs</code>.</li>
</ul>
</li>
<li>
<p>Once the iteration ends, set <code>bfs_queue = new_bfs</code>, increment <code>distance</code> by 1, and start the next round by repeating step 4.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/XZAZVSEy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \times n\)</span> be the size of the input matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>
<p>The general time complexity of Depth-First-Search is <span class="math inline">\(O(V + E)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of cells in the first island is <span class="math inline">\(n^2\)</span>, so iterating over its cells will take <span class="math inline">\(O(n^2)\)</span> time. <span class="math inline">\(E\)</span> is a constant here since we are only allowed to traverse in up to 4 directions.</p>
</li>
<li>
<p>The general time complexity of Breadth-First-Search is <span class="math inline">\(O(V + E)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of water cells we need to check before reaching the second island is <span class="math inline">\(n^2\)</span>, which will take <span class="math inline">\(O(n^2)\)</span> time.</p>
</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>
<p>The general space complexity of Depth-First-Search is <span class="math inline">\(O(V)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of cells in the first island is <span class="math inline">\(n^2\)</span>, thus the space used by the recursive stack during DFS is <span class="math inline">\(O(n^2)\)</span></p>
</li>
<li>
<p>The general space complexity of Breadth-First-Search is <span class="math inline">\(O(V)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of water cells we need to check using BFS before reaching the second island is <span class="math inline">\(n^2\)</span>, thus the space used by the queue is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>To sum up, the overall space complexity is <span class="math inline">\(O(n^2)\)</span></p>
</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First-Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we will use the same strategy as in the previous approach, but we will use BFS instead of DFS to search for all cells of island <code>A</code>. Again, we will first traverse <code>grid</code>, take the first land found (assume it is <code>grid[first_x][first_y]</code>) and treat it as a land cell of Island <code>A</code>. Then, we BFS over all cells of island <code>A</code> and set their values to <code>2</code> to distinguish them from the other island.</p>
<p><img src="../Figures/934/3.png" alt="img" /></p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Iterate over the <code>grid</code> until we find the first land cell, suppose it is <code>grid[first_x][first_y]</code>.</p>
</li>
<li>
<p>Create:</p>
<ul>
<li>a list <code>bfs_queue</code> and add <code>grid[first_x][first_y]</code> on island <code>A</code> to it.</li>
<li>an empty list <code>new_bfs</code> for the next round's search.</li>
<li>an empty list <code>second_bfs_queue</code> for searching the distance between two islands later.</li>
</ul>
</li>
<li>
<p>Iterate over <code>bfs_queue</code>, for each cell <code>grid[x][y]</code>, if <code>grid[x][y] = 1</code>:</p>
<ul>
<li>set <code>grid[x][y] = 2</code></li>
<li>add <code>(x, y)</code> to <code>new_bfs</code> for the next round's search.</li>
<li>add <code>(x, y)</code> to <code>second_bfs_queue</code> for searching over water cells later.</li>
</ul>
</li>
<li>
<p>If <code>new_bfs</code> is not empty, we set <code>bfs_queue = new_bfs</code> and repeat step 3. Otherwise, move on to step 5.</p>
</li>
<li>
<p>Set <code>distance = 0</code>.</p>
</li>
<li>
<p>Now we start BFS on water cells. While <code>second_bfs_queue</code> is not empty, we create an empty list <code>new_bfs</code> to collect the cells we need to visit in the next round. Iterate over cells in <code>second_bfs_queue</code>, for each cell <code>(x, y)</code>:</p>
<ul>
<li>if <code>grid[x][y] = 1</code>, it means we have reached the second island, return <code>distance</code>.</li>
<li>Otherwise, we look for its unvisited water neighbors (cells with value of <code>0</code>), mark them as <code>-1</code> and add them to <code>new_bfs</code>.</li>
</ul>
</li>
<li>
<p>Once the iteration ends, set <code>second_bfs_queue = new_bfs</code>, increment <code>distance</code> by 1, and repeat the step 6.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/n5yNZrVo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \times n\)</span> be the size of the input matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>The maximum number of water cells and the maximum number of land cells in island <code>A</code> we need to check are <span class="math inline">\(n^2\)</span>, which will take <span class="math inline">\(O(n^2)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>The maximum number of land cells of island <code>A</code> that we need to check with BFS is <span class="math inline">\(n^2\)</span>, thus the space used by <code>bfs_queue</code> is <span class="math inline">\(O(n^2)\)</span>.</li>
<li>The maximum number of water cells we need to check using BFS before reaching the second island is <span class="math inline">\(n^2\)</span>, thus the space used by <code>second_bfs_queue</code> is also <span class="math inline">\(O(n^2)\)</span>.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n^2)\)</span><br />
<br/></li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-201">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-cycle-in-a-graph/description" target="_blank" rel="noopener noreferrer">Shortest Cycle in a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>bi-directional </strong>graph with <code>n</code> vertices, where each vertex is labeled from <code>0</code> to <code>n - 1</code>. The edges in the graph are represented by a given 2D integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes an edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.</p>

<p>Return <em>the length of the <strong>shortest </strong>cycle in the graph</em>. If no cycle exists, return <code>-1</code>.</p>

<p>A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/04/cropped.png" style="width: 387px; height: 331px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The cycle with the smallest length is : 0 -&gt; 1 -&gt; 2 -&gt; 0 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png" style="width: 307px; height: 307px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[0,1],[0,2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no cycles in this graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>1 &lt;= edges.length &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-202">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-distance-after-road-addition-queries-i/description" target="_blank" rel="noopener noreferrer">Shortest Distance After Road Addition Queries I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and a 2D integer array <code>queries</code>.</p>

<p>There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code>. Initially, there is a <strong>unidirectional</strong> road from city <code>i</code> to city <code>i + 1</code> for all <code>0 &lt;= i &lt; n - 1</code>.</p>

<p><code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> represents the addition of a new <strong>unidirectional</strong> road from city <code>u<sub>i</sub></code> to city <code>v<sub>i</sub></code>. After each query, you need to find the <strong>length</strong> of the <strong>shortest path</strong> from city <code>0</code> to city <code>n - 1</code>.</p>

<p>Return an array <code>answer</code> where for each <code>i</code> in the range <code>[0, queries.length - 1]</code>, <code>answer[i]</code> is the <em>length of the shortest path</em> from city <code>0</code> to city <code>n - 1</code> after processing the <strong>first </strong><code>i + 1</code> queries.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, queries = [[2,4],[0,2],[0,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,1]</span></p>

<p><strong>Explanation: </strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg" style="width: 350px; height: 60px;" /></p>

<p>After the addition of the road from 2 to 4, the length of the shortest path from 0 to 4 is 3.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg" style="width: 350px; height: 60px;" /></p>

<p>After the addition of the road from 0 to 2, the length of the shortest path from 0 to 4 is 2.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg" style="width: 350px; height: 96px;" /></p>

<p>After the addition of the road from 0 to 4, the length of the shortest path from 0 to 4 is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, queries = [[0,3],[0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg" style="width: 300px; height: 70px;" /></p>

<p>After the addition of the road from 0 to 3, the length of the shortest path from 0 to 3 is 1.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg" style="width: 300px; height: 70px;" /></p>

<p>After the addition of the road from 0 to 2, the length of the shortest path remains 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= queries.length &lt;= 500</code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= queries[i][0] &lt; queries[i][1] &lt; n</code></li>
	<li><code>1 &lt; queries[i][1] - queries[i][0]</code></li>
	<li>There are no repeated roads among the queries.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>According to the problem statement:</p>
<ul>
<li>There are <span class="math inline">\(n\)</span> cities, numbered from <span class="math inline">\(0\)</span> to <span class="math inline">\(n-1\)</span>.</li>
<li>Initially, each pair of consecutive cities is connected by a one-way road.
<ul>
<li>Formally, for each <span class="math inline">\(i\)</span> where <span class="math inline">\(0 \leq i \leq n-2\)</span>, there exists a directed and unweighted edge from city <span class="math inline">\(i\)</span> to city <span class="math inline">\(i+1\)</span>.</li>
</ul>
</li>
</ul>
<p>Additionally, we are given an array of length <span class="math inline">\(q\)</span>, called <span class="math inline">\(queries\)</span>, where each element represents a new road to be added:</p>
<ul>
<li>Each element in <span class="math inline">\(queries\)</span> is defined as <span class="math inline">\(\text{queries}[i] = [u_i, v_i]\)</span>, where:
<ul>
<li><span class="math inline">\(u_i\)</span> and <span class="math inline">\(v_i\)</span> are the cities between which a new directed and unweighted road will be added at step <span class="math inline">\(i\)</span>.</li>
<li>It is guaranteed that <span class="math inline">\(u_i < v_i\)</span>.</li>
</ul>
</li>
</ul>
<p>After adding each road in <span class="math inline">\(queries\)</span>, we have to determine the length of the shortest path between city <span class="math inline">\(0\)</span> and city <span class="math inline">\(n-1\)</span>. Then we will return the result as an array of length <span class="math inline">\(q\)</span>, where each element corresponds to the shortest path length after each step.</p>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem statement naturally suggests a graphical representation, where cities are modeled as nodes and the roads connecting them are represented as edges. This transforms our task into a well-known graph problem: finding the shortest path between two nodes.</p>
<p>However, there's an important distinction: our graph is dynamic, with new edges added at each step. A logical approach is to update the graph with each new road and apply a path-finding algorithm at each step to find the shortest path.</p>
<p>To select the appropriate algorithm, we need to consider the properties of our graph. One notable characteristic is that the edges are unweighted. This implies that the total cost of a path is equivalent to the number of steps taken to reach the destination, or, in other words, the number of layers of nodes that must be explored.</p>
<p>This understanding leads us to implement the <a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/">Breadth-First Search (BFS)</a> algorithm, which is particularly suited for this type of problem.</p>
<p>!?!../Documents/3243/3243_Approach1.json:960,540!?!</p>
<p>If you need a refresher on how BFS works, you can refer to the classic problem <a href="https://leetcode.com/problems/rotting-oranges/description">994. Rotting Oranges</a>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define a helper function <code>bfs</code> that, given the number of nodes <code>n</code> and the graph's adjacency list <code>adjList</code>, returns the number of edges in the shortest path between node <code>0</code> and node <code>n - 1</code>.</p>
<ul>
<li>Initialize a boolean array <code>visited</code> to mark the processed nodes.</li>
<li>Initialize a queue <code>nodeQueue</code>.</li>
<li>Push node <code>0</code> into the queue and mark it as visited.</li>
<li>Initialize a variable <code>currentLayerNodeCount</code> to <code>1</code> (since node <code>0</code> is already in the queue), <code>nextLayerNodeCount</code> to <code>0</code>, and <code>layersExplored</code> to <code>0</code>.</li>
<li>Perform BFS until the queue is empty:
<ul>
<li>Iterate over the nodes in the current layer, with <code>i</code> ranging from <code>0</code> to <code>currentLayerNodeCount - 1</code>:
<ul>
<li>Pop the first node, called <code>currentNode</code>, from the queue and check whether it is the target node (<code>n - 1</code>).
<ul>
<li>If the condition is true, return <code>layersExplored</code>.</li>
</ul>
</li>
<li>For every <code>neighbor</code> in <code>adjList[currentNode]</code>:
<ul>
<li>If <code>neighbor</code> has already been visited, continue.</li>
<li>Otherwise:
<ul>
<li>Push <code>neighbor</code> into the queue.</li>
<li>Increment <code>nextLayerNodeCount</code> by <code>1</code>.</li>
<li>Mark <code>neighbor</code> as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>When the loop is over and all nodes in the current layer are processed:
<ul>
<li>Set <code>currentLayerNodeCount = nextLayerNodeCount</code>.</li>
<li>Set <code>nextLayerNodeCount = 0</code>.</li>
<li>Increment <code>layersExplored</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Since the initial constraint that every two consecutive nodes are connected guarantees that there is always a path between node <code>0</code> and node <code>n - 1</code>, the algorithm will never exit the BFS loop without having found and returned the shortest path length. Here, simply return a random value, e.g., <code>-1</code>.</li>
</ul>
</li>
<li>
<p>In the main function <code>shortestDistanceAfterQueries</code>:</p>
<ul>
<li>Initialize the result array <code>answer</code>.</li>
<li>Initialize a 2D array <code>adjList</code>.</li>
<li>Iterate over the first <code>n - 1</code> nodes with <code>i</code> ranging from <code>0</code> to <code>n - 2</code>:
<ul>
<li>Push <code>i + 1</code> to <code>adjList[i]</code>.</li>
</ul>
</li>
<li>Enter a new loop to process each query <code>query[i] = [u, v]</code>:
<ul>
<li>Push <code>v</code> to <code>adjList[u]</code>.</li>
<li>Run <code>bfs</code> and push the result to the <code>answer</code> array.</li>
</ul>
</li>
<li>Finally, return <code>answer</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/SYe9kez7/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of cities and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n + q))\)</span>.</p>
<p>At first glance, the <code>bfs</code> function appears to contain three nested loops, which might suggest a time complexity of <span class="math inline">\(O(n^3)\)</span>. However, this is misleading. A closer look shows that each part of the BFS algorithm runs in relation to the nodes and edges in the graph after each road (edge) addition.</p>
<ul>
<li>Node Processing (first inner loop): Each node is added to and removed from the queue exactly once, giving a time complexity of <span class="math inline">\(O(n)\)</span> for processing all nodes.</li>
<li>Edge Exploration (second inner loop): For each dequeued node, the algorithm checks all its neighbors. Each edge is examined only once, so the total time for edge exploration is <span class="math inline">\(O(e)\)</span>, where <span class="math inline">\(e\)</span> is the number of edges in the graph.</li>
</ul>
<p>Combining these, the time complexity of each BFS run is <span class="math inline">\(O(n + e)\)</span>.</p>
<ul>
<li>Layer-wise Node Processing (outer loop): The outer loop runs based on the number of graph layers rather than the number of nodes, ensuring the BFS explores nodes systematically. This does not increase the overall complexity, which remains <span class="math inline">\(O(n + e)\)</span>.</li>
</ul>
<p>Each BFS after adding a road incrementally increases the edge count. The time complexity across all <span class="math inline">\(q\)</span> queries is thus:</p>
<ol>
<li>After the 1st road: <span class="math inline">\(O(n + n)\)</span>.</li>
<li>After the 2nd road: <span class="math inline">\(O(n + n + 1)\)</span>.</li>
<li>…</li>
<li>After the <span class="math inline">\(q\)</span>-th road: <span class="math inline">\(O(n + n + q - 1)\)</span>.</li>
</ol>
<p>Summing these yields:</p>
<p><span class="math display">\[\begin{aligned}
    O(n + n) + O(n + n + 1) + \dots + O(n + n + q - 1) \\
    = O(2qn + \frac{q(q-1)}{2}) \\
    = O(q \times (n + q))
\end{aligned}
\]</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n+q)\)</span>.</p>
<p>To represent our graph, we create and continuously update its adjacency list in the form of a 2D array. Initially, this array contains <span class="math inline">\(n-1\)</span> elements, representing the edges between every two consecutive nodes. After processing all queries, the array will contain <span class="math inline">\(n + q - 1\)</span> elements, contributing <span class="math inline">\(O(n + q)\)</span> to the total space complexity.</p>
<p>In addition to the adjacency list, the <code>bfs</code> function creates a 1D array, named <code>visited</code> and a queue, called <code>nodeQueue</code>, both of which can have a maximum size of <span class="math inline">\(n\)</span>.</p>
<p>Therefore, the overall space complexity remains <span class="math inline">\(O(n+q)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursive-dynamic-programming-top-down">Approach 2: Recursive Dynamic Programming (Top-Down)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Upon closer examination of the graph, we can determine that it is a Directed Acyclic Graph (DAG). This means:</p>
<ul>
<li>
<p>Directed Edges: Each road in the graph has a specific direction (is unidirectional).</p>
</li>
<li>
<p>No Cycles: A key characteristic of a DAG is that it does not contain any cycles. In this graph, every road's destination node has a value greater than that of its source node. This property ensures that it is impossible to return to a starting node by following the directed edges.</p>
</li>
</ul>
<p>Using the language of the problem, we can say that for every node <span class="math inline">\(v_i\)</span>, the distance to the final node <span class="math inline">\(v_{n-1}\)</span> only depends on two factors:</p>
<ul>
<li>The distance from <span class="math inline">\(v_i\)</span> to the subsequent nodes <span class="math inline">\(v_{i+1}\)</span>, <span class="math inline">\(v_{i+2}\)</span>, ..., <span class="math inline">\(v_{n-1}\)</span>.</li>
<li>The distance from the subsequent nodes <span class="math inline">\(v_{i+1}\)</span>, <span class="math inline">\(v_{i+2}\)</span>, ..., <span class="math inline">\(v_{n-1}\)</span> to the final node <span class="math inline">\(v_{n-1}\)</span>.</li>
</ul>
<p>Specifically the relationship can be expressed as, <span class="math inline">\(distance_{v_i, v_{n-1}} = \min_{j} (distance_{v_i, v_j}+ distance_{v_j, v_{n-1}})\)</span>.</p>
<p>In our calculations, we notice that some states overlap, meaning they are needed in various computations but are independent of one another. This characteristic indicates that dynamic programming could help us solve this problem efficiently.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Define a recursive function <code>findMinDistance</code> that, given the number of nodes <code>n</code>, the graph's adjacency list <code>adjList</code>, the memoization array <code>dp</code>, and the node <code>currentNode</code>, returns the number of edges in the shortest path from node <code>currentNode</code> to node <code>n - 1</code>.</p>
<ul>
<li>Base case: if <code>currentNode == n - 1</code>, return <code>0</code>.</li>
<li>Computed case: if <code>dp[currentNode] != -1</code>, return <code>dp[currentNode]</code>.</li>
<li>Initialize a variable <code>minDistance</code> to <code>n</code>.</li>
<li>For every <code>neighbor</code> of <code>currentNode</code>:
<ul>
<li>Set <code>minDistace = min(minDistance, 1 + findMinDistance(..., neighbor))</code>.</li>
</ul>
</li>
<li>Store the computed <code>minDistance</code>; set <code>dp[currentNode] = minDistance</code>.</li>
<li>Return <code>minDistance</code>.</li>
</ul>
</li>
<li>
<p>In the main function <code>shortestDistanceAfterQueries</code>:</p>
<ul>
<li>Initialize an empty result array <code>answer</code>.</li>
<li>Initialize a memoization array <code>dp</code> of size <code>n</code>. Initially set all <code>dp</code> values to <code>-1</code>.</li>
<li>Initialize a 2D array <code>adjList</code> to represent the graph.</li>
<li>Iterate over the first <code>n - 1</code> nodes, with <code>i</code> ranging from <code>0</code> to <code>n - 2</code>:
<ul>
<li>Add <code>i+1</code> to <code>adjList[i]</code> to create initial consecutive edges.</li>
</ul>
</li>
<li>Process each query <code>query[i] = [u, v]</code> in a loop:
<ul>
<li>Add <code>v</code> to <code>adjList[u]</code> to represent the new edge.</li>
<li>Run <code>findMinDistance</code> for node <code>0</code> and append the result to the <code>answer</code> array.</li>
<li>Reset all values in the <code>dp</code> array to <code>-1</code>.</li>
</ul>
</li>
<li>Finally, return <code>answer</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/35b7NhLC/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of cities and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n+q))\)</span>.</p>
</li>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n+q))\)</span>.</p>
<p>The <code>findMinDistance</code> function is called on the starting node (node <code>0</code>) each time a query is processed. If the distance for a node is already computed, the function returns the cached value from the <code>dp</code> array, avoiding redundant calculations.</p>
<p>During its first call for node <code>0</code>, <code>findMinDistance</code> explores all neighbors, iterating over all outgoing edges. Each node is processed only once for distance calculation due to caching in the <code>dp</code> array.</p>
<p>The time complexity of a single <code>findMinDistance</code> call on node <code>0</code> is <span class="math inline">\(O(e)\)</span>, where <span class="math inline">\(e\)</span> represents the current number of edges in the graph. Since each edge is visited exactly once, the computation scales linearly with the number of edges.</p>
<p>Thus, the total time complexity sums to:</p>
<p><span class="math display">\[\begin{aligned}
    O(n) +  O(n+1) + \ldots +  O(n+q-1) \\
    = O(q \times (n+q))
\end{aligned}
\]</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n+q)\)</span>.</p>
<p>Once again, we choose to represent our graph using an adjacency list, the maximum size of which is <span class="math inline">\(O(n + q)\)</span>. Additionally, we create a 1D memoization array, called <code>dp</code>, with a fixed size of <span class="math inline">\(n\)</span> and we also invoke a recursive function <code>findMinDistance</code>, whose depth is <span class="math inline">\(O(n)\)</span>, as well. Combining the above, we conclude that the total space complexity is <span class="math inline">\(O(n+q)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterative-dynamic-programming-bottom-up">Approach 3: Iterative Dynamic Programming (Bottom-Up)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>While the top-down dynamic programming approach is often intuitive, it can become less effective in certain situations, particularly due to uncontrolled recursion depth. This is especially true for larger input sizes, where deep recursion can lead to stack overflow errors. To avoid this risk, it is generally considered a good idea to convert recursive dynamic programming solutions into iterative ones.</p>
<p>In an iterative approach, we essentially take each line from the previous recursive algorithm and translate it into its iterative equivalent. A key consideration in this translation is that when we compute <code>dp[u]</code>, it represents the result of the <code>findMinDistance</code> function for node <code>u</code>. Thus, both the return value and the runtime complexity of <code>findMinDistance(u)</code> can be directly replaced with <code>dp[u]</code>.</p>
<p>To implement the iterative approach effectively, we need to recognize the relationship between the calls in the recursive function. We begin our computation at the base case, which occurs when <code>currentNode</code> equals <code>n - 1</code>, and work our way up to <code>currentNode = 0</code>. This means that our bottom-up approach should process nodes in reverse order, starting from <code>currentNode = n - 1</code> and building our results incrementally until we reach <code>currentNode = 0</code>. By doing so, we ensure that all necessary values are calculated before they are needed.</p>
<p>!?!../Documents/3243/3243_Approach3.json:960,540!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define a function <code>findMinDistance</code> that, given the number of nodes <code>n</code> and the graph's adjacency list <code>adjList</code>, returns the number of edges in the shortest path from node <code>0</code> to node <code>n - 1</code>.</p>
<ul>
<li>Initialize a 1D array of size <code>n</code>, called <code>dp</code>.</li>
<li>Base case: set <code>dp[n-1] = 0</code>.</li>
<li>Iterate over the first <code>n - 1</code> nodes in reversed order, with <code>currentNode</code> from <code>n - 2</code> to <code>0</code>. On each iteration:
<ul>
<li>Initialize <code>minDistance</code> to <code>n</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:
<ul>
<li>Set <code>minDistance = min(minDistance, dp[neighbor] + 1)</code>.</li>
</ul>
</li>
<li>After exiting the inner loop, set <code>dp[currentNode] = minDistance</code>.</li>
</ul>
</li>
<li>Return <code>dp[0]</code>.</li>
</ul>
</li>
<li>
<p>In the main function <code>shortestDistanceAfterQueries</code>:</p>
<ul>
<li>Initialize an empty result array <code>answer</code>.</li>
<li>Initialize a 2D array <code>adjList</code> to represent the graph.</li>
<li>Iterate over the first <code>n-1</code> nodes, with <code>i</code> ranging from <code>0</code> to <code>n-2</code>:
<ul>
<li>Add <code>i+1</code> to <code>adjList[i]</code> to create initial consecutive edges.</li>
</ul>
</li>
<li>Process each query <code>query[i] = [u, v]</code> in a loop:
<ul>
<li>Add <code>v</code> to <code>adjList[u]</code> to represent the new edge.</li>
<li>Run <code>findMinDistance</code> and append the result to the <code>answer</code> array.</li>
</ul>
</li>
<li>Finally, return <code>answer</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/oRhhY73r/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of cities and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \times (n+q))\)</span>.</p>
<p>The <code>findMinDistance</code> function iterates over each edge exactly once, so its time complexity for a graph with <span class="math inline">\(e\)</span> edges is <span class="math inline">\(O(e)\)</span>.</p>
<p>Therefore, like the previous approaches, the total time complexity of the algorithm can be expressed as:</p>
<p><span class="math display">\[\begin{aligned}
    O(n) +  O(n+1) + ... +  O(n+q-1) = \\
    O(q \times (n+q)).
\end{aligned}
\]</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n+q)\)</span>.</p>
<p>The total space complexity is once again determined by the size of the adjacency list which is at most <span class="math inline">\(O(n+q)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-203">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1" target="_blank" rel="noopener noreferrer">Shortest Distance in a Binary Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>n * m</strong>&nbsp;matrix <strong>grid</strong> where each element can either be <strong>0</strong> or <strong>1</strong>. You&nbsp;need to find the shortest distance&nbsp;between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1.&nbsp;</span></p>
<p><span style="font-size: 18px;">If the path is not possible between source cell and destination cell, then return <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note :&nbsp;</strong>You can move into an adjacent cell if that adjacent cell is filled with element 1. Two cells are adjacent if they share a side. In other words, you can move in one of the four directions, Up, Down, Left and Right. The source and destination cell are based on the zero based indexing. The destination cell should be 1.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">grid[][] = {{1, 1, 1, 1},
            {1, 1, 0, 1},
            {1, 1, 1, 1},
            {1, 1, 0, 0},
            {1, 0, 0, 1}}</span>
<span style="font-size: 18px;">source = {0, 1}</span>
<span style="font-size: 18px;">destination = {2, 2}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">1 <strong>1</strong> 1 1
1 <strong>1</strong> 0 1
1 <strong>1</strong> <strong>1</strong> 1
1 1 0 0
1 0 0 1
The highlighted part in the matrix denotes the 
shortest path from source to destination cell.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">grid[][] = {{1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0},
            {1, 0, 1, 0, 1}}</span>
<span style="font-size: 18px;">source = {0, 0}</span>
<span style="font-size: 18px;">destination = {3, 4}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">-1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">The path is not possible between source and</span>&nbsp;
<span style="font-size: 18px;">destination, hence return -1.</span>
</pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">You don't need to read or print anything. Your task is to complete the function <strong>shortestPath()&nbsp;</strong>which takes the a 2D integer array&nbsp;<strong>grid</strong>, <strong>source</strong> cell and <strong>destination</strong> cell&nbsp;as an input parameters and returns the shortest distance between source and destination cell.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n * m)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(n * m)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &le; n, m &le; 500</span></li>
<li><span style="font-size: 18px;">grid[i][j] == 0 or grid[i][j] == 1</span></li>
<li><span style="font-size: 18px;">The source and destination cells are always inside the given matrix.</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-204">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-by-removing-k-walls/1" target="_blank" rel="noopener noreferrer">Shortest Path by Removing K walls</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a 2-D binary <strong>matrix</strong> of size <strong>n*m</strong>, where 0 represents an empty space while 1 represents a wall you cannot walk through. You are also given an integer <strong>k</strong>.<br />
You can walk up, down, left, or right. Given that you can remove up to <strong>k</strong> walls, return the minimum number of steps to walk from the top left corner (0, 0) to the bottom right corner (n-1, m-1).</span><br />
<span style="font-size:18px"><strong>Note: </strong>If there is no way to walk from the top left corner to the bottom right corner, return -1.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>n = 3, m = 3, k = 1
mat = {{0, 0, 0},
       {0, 0, 1},
       {0, 1, 0}}
<strong>Output:
</strong>4<strong>
Explanation:
</strong>We can remove any one of the walls and
reach the bottom in 4 moves. </span> 
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>n = 2, m = 2, k = 0
mat[] = {{0, 1},
         {1, 0}}
<strong>Output:
</strong>-1<strong>
Explanation:
</strong>There&#39;s no way of reaching the bottom
corner without removing any walls.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
The task is to complete the function <strong>shotestPath</strong>() which takes three integers n, m, and k and also a matrix of size n*m as input and returns the minimum number of steps to walk from the top left corner to the bottom right corner.</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n,m &le; 50<br />
0 &le; k &le; n*m<br />
Top left and bottom right corners doesn&#39;t have 1</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(n*m*k).<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(n*m*k).</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-205">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description" target="_blank" rel="noopener noreferrer">Shortest Path in a Grid with Obstacles Elimination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacle). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.</p>

<p>Return <em>the minimum number of <strong>steps</strong> to walk from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code><em> given that you can eliminate <strong>at most</strong> </em><code>k</code><em> obstacles</em>. If it is not possible to find such walk return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg" style="width: 244px; height: 405px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The shortest path without eliminating any obstacle is 10.
The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
<strong>Output:</strong> -1
<strong>Explanation:</strong> We need to eliminate at least two obstacles to find such a walk.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 40</code></li>
	<li><code>1 &lt;= k &lt;= m * n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-206">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-in-binary-matrix/description" target="_blank" rel="noopener noreferrer">Shortest Path in Binary Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> binary matrix <code>grid</code>, return <em>the length of the shortest <strong>clear path</strong> in the matrix</em>. If there is no clear path, return <code>-1</code>.</p>

<p>A <strong>clear path</strong> in a binary matrix is a path from the <strong>top-left</strong> cell (i.e., <code>(0, 0)</code>) to the <strong>bottom-right</strong> cell (i.e., <code>(n - 1, n - 1)</code>) such that:</p>

<ul>
	<li>All the visited cells of the path are <code>0</code>.</li>
	<li>All the adjacent cells of the path are <strong>8-directionally</strong> connected (i.e., they are different and they share an edge or a corner).</li>
</ul>

<p>The <strong>length of a clear path</strong> is the number of visited cells of this path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/example1_1.png" style="width: 500px; height: 234px;" />
<pre>
<strong>Input:</strong> grid = [[0,1],[1,0]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/example2_1.png" style="height: 216px; width: 500px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0],[1,1,0],[1,1,0]]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,0],[1,1,0],[1,1,0]]
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>grid[i][j] is 0 or 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-207">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph-having-unit-distance/1" target="_blank" rel="noopener noreferrer">Shortest Path in Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an adjacency list, <strong>adj&nbsp;</strong>of <strong>Undirected Graph</strong> having <strong>unit weight </strong>of the edges, find the shortest path<strong> </strong>from<strong> src </strong>to all the vertex and if it is <strong>unreachable</strong> to reach any vertex, then return<strong> -1</strong> for that vertex.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>adj[][] = [[1, 3], [0, 2], [1, 6], [0, 4], [3, 5], [4, 6], [2, 5, 7, 8], [6, 8], [7, 6]], src=0
<strong>Output: </strong>[0, 1, 2, 1, 2, 3, 3, 4, 4]<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711976/Web/Other/blobid0_1745302423.jpg" width="249" height="220" /></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>adj[][]= [[3], [3], [], [0, 1]], src=3
<strong>Output: </strong>[1, 1, -1, 0]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711976/Web/Other/blobid0_1747111194.webp" width="207" height="195" /><br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>adj[][]= [[], [], [], [4], [3], [], []], src=1
<strong>Output: </strong>[-1, 0, -1, -1, -1, -1, -1] </span></pre>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br />1&lt;=adj.size()&lt;=10<sup>4</sup><br />0&lt;=edges&lt;=</span><span style="font-size: 18px;">adj.size()</span><span style="font-size: 18px;">-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-208">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-to-get-all-keys/description" target="_blank" rel="noopener noreferrer">Shortest Path to Get All Keys</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> grid <code>grid</code> where:</p>

<ul>
	<li><code>&#39;.&#39;</code> is an empty cell.</li>
	<li><code>&#39;#&#39;</code> is a wall.</li>
	<li><code>&#39;@&#39;</code> is the starting point.</li>
	<li>Lowercase letters represent keys.</li>
	<li>Uppercase letters represent locks.</li>
</ul>

<p>You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.</p>

<p>If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.</p>

<p>For some <code><font face="monospace">1 &lt;= k &lt;= 6</font></code>, there is exactly one lowercase and one uppercase letter of the first <code>k</code> letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.</p>

<p>Return <em>the lowest number of moves to acquire all keys</em>. If it is impossible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg" style="width: 404px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [&quot;@.a..&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;]
<strong>Output:</strong> 8
<strong>Explanation:</strong> Note that the goal is to obtain all the keys not to open all the locks.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg" style="width: 404px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;]
<strong>Output:</strong> 6
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg" style="width: 244px; height: 85px;" />
<pre>
<strong>Input:</strong> grid = [&quot;@Aa&quot;]
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either an English letter, <code>&#39;.&#39;</code>, <code>&#39;#&#39;</code>, or <code>&#39;@&#39;</code>.&nbsp;</li>
	<li>There is exactly one&nbsp;<code>&#39;@&#39;</code>&nbsp;in the grid.</li>
	<li>The number of keys in the grid is in the range <code>[1, 6]</code>.</li>
	<li>Each key in the grid is <strong>unique</strong>.</li>
	<li>Each key in the grid has a matching lock.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force--permutations">Approach 1: Brute Force + Permutations</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We have to pick up the keys <span class="math inline">\(K\)</span> in some order, say <span class="math inline">\(K_{\sigma_i}\)</span>.</p>
<p>For each ordering, let's do a breadth first search to find the distance to the next key.</p>
<p>For example, if the keys are <code>'abcdef'</code>, then for each ordering such as <code>'bafedc'</code>, we will try to calculate the candidate distance from <code>'@' -&gt; 'b' -&gt; 'a' -&gt; 'f' -&gt; 'e' -&gt; 'd' -&gt; 'c'</code>.</p>
<p>Between each segment of our path (and corresponding breadth-first search), we should remember what keys we've picked up.  Keys that are picked up become part of a mask that helps us identify what locks we are allowed to walk through during the next breadth-first search.</p>
<p>Each part of the algorithm is relatively straightforward, but the implementation in total can be quite challenging.  See the comments for more details.</p>
<p><a href="https://leetcode.com/playground/bMednP5j/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(R * C * \mathcal{A} * \mathcal{A}!)\)</span>, where <span class="math inline">\(R, C\)</span> are the dimensions of the grid, and <span class="math inline">\(\mathcal{A}\)</span> is the maximum number of keys (<span class="math inline">\(\mathcal{A}\)</span> because it is the &quot;size of the alphabet&quot;.)  Each <code>bfs</code> is performed up to <span class="math inline">\(\mathcal{A} * \mathcal{A}!\)</span> times.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(R * C + \mathcal{A}!)\)</span>, the space for the <code>bfs</code> and to store the candidate key permutations.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-points-of-interest--dijkstra">Approach 2: Points of Interest + Dijkstra</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Clearly, we only really care about walking between points of interest: the keys, locks, and starting position.  We can use this insight to speed up our calculation.</p>
<p>Let's make this intuition more formal: any walk can be decomposed into <em>primitive</em> segments, where each segment (between two points of interest) is primitive if and only if it doesn't touch any other point of interest in between.</p>
<p>Then, we can calculate the distance (of a primitive segment) between any two points of interest, using a breadth first search.</p>
<p>Afterwards, we have some graph (where each node refers to at most <span class="math inline">\(13\)</span> places, and at most <span class="math inline">\(2^6\)</span> states of keys).  We have a starting node (at <code>'@'</code> with no keys) and ending nodes (at anywhere with all keys.)  We also know all the costs to go from one node to another - each node has outdegree at most 13.  This shortest path problem is now ideal for using Dijkstra's algorithm.</p>
<p>Dijkstra's algorithm uses a priority queue to continually searches the path with the lowest cost to destination, so that when we reach the target, we know it must have been through the lowest cost path.  Refer to <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">this link</a> for more detail.</p>
<p>Again, each part of the algorithm is relatively straightforward (for those familiar with BFS and Dijkstra's algorithm), but the implementation in total can be quite challenging.</p>
<p><a href="https://leetcode.com/playground/Mox2BNP6/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(RC(2\mathcal{A} + 1) + \mathcal{E} \log \mathcal{N})\)</span>, where <span class="math inline">\(R, C\)</span> are the dimensions of the grid, and <span class="math inline">\(\mathcal{A}\)</span> is the maximum number of keys, <span class="math inline">\(\mathcal{N} = (2\mathcal{A} + 1) * 2^\mathcal{A}\)</span> is the number of nodes when we perform Dijkstra's, and <span class="math inline">\(\mathcal{E} = \mathcal{N} * (2 \mathcal{A} + 1)\)</span> is the maximum number of edges.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(\mathcal{N})\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-209">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-visiting-all-nodes/description" target="_blank" rel="noopener noreferrer">Shortest Path Visiting All Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have an undirected, connected graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an array <code>graph</code> where <code>graph[i]</code> is a list of all the nodes connected with node <code>i</code> by an edge.</p>

<p>Return <em>the length of the shortest path that visits every node</em>. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg" style="width: 222px; height: 183px;" />
<pre>
<strong>Input:</strong> graph = [[1,2,3],[0],[0],[0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [1,0,2,0,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg" style="width: 382px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [0,1,4,2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>1 &lt;= n &lt;= 12</code></li>
	<li><code>0 &lt;= graph[i].length &lt;&nbsp;n</code></li>
	<li><code>graph[i]</code> does not contain <code>i</code>.</li>
	<li>If <code>graph[a]</code> contains <code>b</code>, then <code>graph[b]</code> contains <code>a</code>.</li>
	<li>The input graph is always connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-210">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-with-alternating-colors/description" target="_blank" rel="noopener noreferrer">Shortest Path with Alternating Colors</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, the number of nodes in a directed graph where the nodes are labeled from <code>0</code> to <code>n - 1</code>. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.</p>

<p>You are given two arrays <code>redEdges</code> and <code>blueEdges</code> where:</p>

<ul>
	<li><code>redEdges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is a directed red edge from node <code>a<sub>i</sub></code> to node <code>b<sub>i</sub></code> in the graph, and</li>
	<li><code>blueEdges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> indicates that there is a directed blue edge from node <code>u<sub>j</sub></code> to node <code>v<sub>j</sub></code> in the graph.</li>
</ul>

<p>Return an array <code>answer</code> of length <code>n</code>, where each <code>answer[x]</code> is the length of the shortest path from node <code>0</code> to node <code>x</code> such that the edge colors alternate along the path, or <code>-1</code> if such a path does not exist.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
<strong>Output:</strong> [0,1,-1]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
<strong>Output:</strong> [0,1,-1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= redEdges.length,&nbsp;blueEdges.length &lt;= 400</code></li>
	<li><code>redEdges[i].length == blueEdges[j].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>, u<sub>j</sub>, v<sub>j</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-211">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-source-to-destination-path3544/1" target="_blank" rel="noopener noreferrer">Shortest Source to Destination Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a&nbsp;2D binary matrix A(0-based index) of dimensions NxM. Find the minimum number of steps required to reach from (0,0) to (X, Y).<br />Note: You can only move left, right, up and down, and only through cells that <strong>contain 1</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
N=3, M=4
A=[[1,0,0,0], 
   [1,1,0,1],<br />   [0,1,1,1]]
X=2, Y=3 
<strong>Output:</strong>
5
<strong>Explanation:</strong>
The shortest path is as follows:
(0,0)-&gt;(1,0)-&gt;(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3).</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
N=3, M=4
A=[[1,1,1,1],
   [0,0,0,1],<br />   [0,0,0,1]]
X=0, Y=3
<strong>Output:</strong>
3
<strong>Explanation:</strong>
The shortest path is as follows:
(0,0)-&gt;(0,1)-&gt;(0,2)-&gt;(0,3).</span></pre>
<p><span style="font-size: 14pt;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>shortestDistance()</strong> which takes the integer N, M, X, Y, and the 2D binary matrix A as input parameters and returns the minimum number of steps required to go from (0,0) to (X, Y).If it is impossible to go from (0,0) to&nbsp;(X, Y),then function returns -1. If value of the cell (0,0) is 0&nbsp;(i.e&nbsp; A[0][0]=0)&nbsp;then return -1.</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= N,M &lt;= 250<br /></span><span style="font-size: 14pt;">0 &lt;= X &lt; N<br /></span><span style="font-size: 14pt;">0 &lt;= Y &lt; M<br />0 &lt;= A[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-212">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/similar-string-groups/description" target="_blank" rel="noopener noreferrer">Similar String Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Two strings, <code>X</code> and <code>Y</code>, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string <code>X</code>.</p>

<p>For example, <code>&quot;tars&quot;</code>&nbsp;and <code>&quot;rats&quot;</code>&nbsp;are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p>

<p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.&nbsp; Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.&nbsp; Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p>

<p>We are given a list <code>strs</code> of strings where every string in <code>strs</code> is an anagram of every other string in <code>strs</code>. How many groups are there?</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;omv&quot;,&quot;ovm&quot;]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strs.length &lt;= 300</code></li>
	<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>
	<li><code>strs[i]</code> consists of lowercase letters only.</li>
	<li>All words in <code>strs</code> have the same length and are anagrams of each other.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-213">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sliding-puzzle/description" target="_blank" rel="noopener noreferrer">Sliding Puzzle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On an <code>2 x 3</code> board, there are five tiles labeled from <code>1</code> to <code>5</code>, and an empty square represented by <code>0</code>. A <strong>move</strong> consists of choosing <code>0</code> and a 4-directionally adjacent number and swapping it.</p>

<p>The state of the board is solved if and only if the board is <code>[[1,2,3],[4,5,0]]</code>.</p>

<p>Given the puzzle board <code>board</code>, return <em>the least number of moves required so that the state of the board is solved</em>. If it is impossible for the state of the board to be solved, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[4,0,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Swap the 0 and the 5 in one move.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[5,4,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No number of moves will make the board solved.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[4,1,2],[5,0,3]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 2</code></li>
	<li><code>board[i].length == 3</code></li>
	<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>
	<li>Each value <code>board[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth-First Search (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute-force approach is feasible due to the problem's small constraints. We can explore all possible board states and track the number of moves taken to reach each one. Once we reach the solved state, we return the move count.</p>
<p>The first step is to identify the possible moves from each board position. Each move shifts the '0' (blank square) in one of the four cardinal directions. To simplify, we’ll flatten the 2-D board to a 1-D string by appending the first row to the second. The moves at each square are now converted as given below, where each index represents the position of the zero, and lists the indices in the 1-D string it can go to:</p>
<p><img src="../Figures/773/2dto1d.png" alt="" /></p>
<p>The above figure demonstrates how each tile position is mapped to an index in the 1-D string, and how the tile movements are simulated in the string.</p>
<p>We'll use depth-first search (DFS) to explore all board states. DFS is well-suited here because it allows us to explore each possible path to the solution one by one, fully exploring each path before backtracking. Starting from the initial board state as a flattened string, we maintain a <code>visited</code> map, where each board state is a key, and the value is the number of moves taken to reach it. In our DFS, if the current state already exists in the map with fewer moves, we return early. Otherwise, we update the map with the current move count and explore all possible moves.</p>
<p>Next, we can put the current state in the map with the current move count and start exploring all possible moves from this position. We modify the board based on the next move and recursively call the DFS function to explore further.</p>
<p>After exploring all moves, if the solved state appears in the map, we return its move count; if not, we return -1, as solving the board is impossible.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a 2-D array <code>directions</code> which represents the possible moves for the empty tile (<code>0</code>) at each position on a flattened 1D representation of the <span class="math inline">\(2 \times 3\)</span> board.</li>
</ul>
<p>Main method <code>slidingPuzzle</code>:</p>
<ul>
<li>Initialize a string <code>startState</code> to represent the initial state of the board in a 1-D string format.</li>
<li>Iterate over each cell in the 2-D board and append each element to <code>startState</code>.</li>
<li>Initialize a map <code>visited</code> to store each unique state of the board encountered during the search.</li>
<li>Call a helper function <code>dfs</code> on <code>startState</code>, passing <code>visited</code>, the index of <code>0</code> in <code>startState</code>, and a move count initialized to <code>0</code>.</li>
<li>Return the minimum moves required to reach the solved state (<code>&quot;123450&quot;</code>), or -1 if the state was not found in <code>visited</code>.</li>
</ul>
<p>Helper method <code>dfs</code>:</p>
<ul>
<li>Check if the <code>state</code> has already been visited with fewer or equal moves than the current count (<code>moves</code>).
<ul>
<li>If so, skip further exploration of this path.</li>
</ul>
</li>
<li>Update <code>visited</code> with the current state and move count.</li>
<li>For each adjacent position <code>nextPos</code> in <code>directions</code>:
<ul>
<li>Swap the characters at <code>zeroPos</code> and <code>nextPos</code> in <code>state</code>.</li>
<li>Recursively call <code>dfs</code> on the newly generated state with <code>moves</code> incremented by 1.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/7xoehmiw/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<blockquote>
<p>Note: The values of m and n are fixed by the problem constraints, so their complexities can be considered constant. However, we have kept them as variables for clarity and better understanding.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span></p>
<p>In DFS, each of the <span class="math inline">\((m \cdot n)!\)</span> possible board states can be revisited multiple times due to different move sequences, as DFS doesn’t prioritize the shortest path and may explore all possible paths, reaching the same state repeatedly. Since each state has up to four possible moves on a 2D board, DFS could re-explore each configuration from different directions, leading to up to <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span> recursive calls. Generating each new configuration requires <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Thus, the time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The DFS approach requires storing each of the <span class="math inline">\((m \cdot n)!\)</span> unique states in a <code>visited</code> map to avoid recalculations when a state is reached with the same or fewer moves. In the worst case, the DFS call stack can reach a maximum depth of <span class="math inline">\(O((m \cdot n)!)\)</span>, giving a space complexity of <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The DFS approach explores all possible board states before reaching the final state, which can be inefficient. Although we might find the solution early, DFS will still continue to explore all paths, potentially with non-optimal move counts. To address this, we switch to Breadth-First Search (BFS). BFS is better suited in scenarios like this because it explores all states at the current move level before going deeper, ensuring that the first time it reaches the goal, it has found the shortest path.</p>
<p>Our setup remains similar: we convert the board to a 1-D string and use a set to track visited states. A queue will handle the BFS traversal, starting from the initial state. The queue’s structure works well to support BFS’s layered exploration, since each level is processed sequentially and we stop as soon as we reach the goal.</p>
<p>We then loop while the queue is not empty, processing all states at the current move count. If we encounter the final state, we return the current move count as the answer. Otherwise, we explore all possible moves from the current state, modify the board accordingly, and, if unvisited, add the new state to the queue for further exploration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define an array <code>directions</code> to map the possible moves for the empty tile (<code>0</code>) at each position.</li>
<li>Initialize a string:
<ul>
<li><code>target</code> to &quot;123450&quot;, representing the goal state of the board.</li>
<li><code>startState</code> to store the initial configuration of the board in string form.</li>
</ul>
</li>
<li>Iterate through each row and column of <code>board</code>:
<ul>
<li>Append each tile value to <code>startState</code> to create a single string representing the initial board state.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a set <code>visited</code> to store all the board states already processed to prevent redundant calculations.</li>
<li>a <code>queue</code> for the Breadth-First Search (BFS) traversal.</li>
<li>an integer <code>moves</code> to 0, which will track the number of moves taken to reach the goal state.</li>
</ul>
</li>
<li>Add <code>startState</code> to <code>visited</code> to mark it as processed.</li>
<li>Start a while loop that continues as long as <code>queue</code> is not empty:
<ul>
<li>Store the current size of <code>queue</code> in <code>size</code>. For each item in the current level:
<ul>
<li>Remove the front element of <code>queue</code> and assign it to <code>currentState</code>.</li>
<li>Check if <code>currentState</code> matches <code>target</code>. If it does, return <code>moves</code> as the minimum moves required to reach the solved state.</li>
<li>Set <code>zeroPos</code> to the position of zero in <code>currentState</code>.</li>
<li>For each valid new position <code>newPos</code> in <code>directions[zeroPos]</code>:
<ul>
<li>Generate <code>nextState</code> by swapping <code>zeroPos</code> and <code>newPos</code>.</li>
<li>If <code>nextState</code> is already in <code>visited</code>, skip it to avoid redundant processing.</li>
<li>Otherwise, add <code>nextState</code> to both <code>visited</code> and <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>moves</code> to continue to the next level of BFS.</li>
</ul>
</li>
<li>If <code>queue</code> becomes empty without reaching the target, return -1, indicating the puzzle is unsolvable.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/2hGW2Z7j/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span></p>
<p>The algorithm uses Breadth-First Search (BFS) to explore all possible board configurations. With <span class="math inline">\((m \cdot n)!\)</span> unique configurations, BFS may process each configuration once. Each configuration requires checking moves and generating new ones, taking <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The space complexity is determined by the <code>visited</code> set and the BFS queue, each of which can hold up to <span class="math inline">\((m \cdot n)!\)</span> unique configurations in the worst case. Therefore, the space complexity is <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-214">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-string-with-swaps/description" target="_blank" rel="noopener noreferrer">Smallest String With Swaps</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>, and an array of pairs of indices in the string&nbsp;<code>pairs</code>&nbsp;where&nbsp;<code>pairs[i] =&nbsp;[a, b]</code>&nbsp;indicates 2 indices(0-indexed) of the string.</p>

<p>You can&nbsp;swap the characters at any pair of indices in the given&nbsp;<code>pairs</code>&nbsp;<strong>any number of times</strong>.</p>

<p>Return the&nbsp;lexicographically smallest string that <code>s</code>&nbsp;can be changed to after using the swaps.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]
<strong>Output:</strong> &quot;bacd&quot;
<strong>Explaination:</strong> 
Swap s[0] and s[3], s = &quot;bcad&quot;
Swap s[1] and s[2], s = &quot;bacd&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]
<strong>Output:</strong> &quot;abcd&quot;
<strong>Explaination: </strong>
Swap s[0] and s[3], s = &quot;bcad&quot;
Swap s[0] and s[2], s = &quot;acbd&quot;
Swap s[1] and s[2], s = &quot;abcd&quot;</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cba&quot;, pairs = [[0,1],[1,2]]
<strong>Output:</strong> &quot;abc&quot;
<strong>Explaination: </strong>
Swap s[0] and s[1], s = &quot;bca&quot;
Swap s[1] and s[2], s = &quot;bac&quot;
Swap s[0] and s[1], s = &quot;abc&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
	<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>
	<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt;&nbsp;s.length</code></li>
	<li><code>s</code>&nbsp;only contains lower case English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-215">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/description" target="_blank" rel="noopener noreferrer">Smallest Subtree with all the Deepest Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, the depth of each node is <strong>the shortest distance to the root</strong>.</p>

<p>Return <em>the smallest subtree</em> such that it contains <strong>all the deepest nodes</strong> in the original tree.</p>

<p>A node is called <strong>the deepest</strong> if it has the largest depth possible among any node in the entire tree.</p>

<p>The <strong>subtree</strong> of a node is a tree consisting of that node, plus the set of all descendants of that node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" style="width: 600px; height: 510px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]
<strong>Output:</strong> [2,7,4]
<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The root is the deepest node in the tree.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0,1,3,null,2]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 500]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 500</code></li>
	<li>The values of the nodes in the tree are <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1123: <a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank">https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-paint-deepest-nodes">Approach 1: Paint Deepest Nodes</h3>
<p><strong>Intuition</strong></p>
<p>We try a straightforward approach that has two phases.</p>
<p>The first phase is to identify the nodes of the tree that are deepest.  To do this, we have to annotate the depth of each node.  We can do this with a depth first search.</p>
<p>Afterwards, we will use that annotation to help us find the answer:</p>
<ul>
<li>
<p>If the <code>node</code> in question has maximum depth, it is the answer.</p>
</li>
<li>
<p>If both the left and right child of a <code>node</code> have a deepest descendant, then the answer is this parent <code>node</code>.</p>
</li>
<li>
<p>Otherwise, if some child has a deepest descendant, then the answer is that child.</p>
</li>
<li>
<p>Otherwise, the answer for this subtree doesn't exist.</p>
</li>
</ul>
<p><strong>Algorithm</strong></p>
<p>In the first phase, we use a depth first search <code>dfs</code> to annotate our nodes.</p>
<p>In the second phase, we also use a depth first search <code>answer(node)</code>, returning the answer for the subtree at that <code>node</code>, and using the rules above to build our answer from the answers of the children of <code>node</code>.</p>
<p>Note that in this approach, the <code>answer</code> function returns answers that have the deepest nodes of the <em>entire</em> tree, not just the subtree being considered.</p>
<p><a href="https://leetcode.com/playground/YbCjTSPT/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<p><strong>Intuition</strong></p>
<p>We can combine both depth first searches in <em>Approach #1</em> into an approach that does both steps in one pass.  We will have some function <code>dfs(node)</code> that returns both the answer for this subtree, and the distance from <code>node</code> to the deepest nodes in this subtree.</p>
<p><strong>Algorithm</strong></p>
<p>The <code>Result</code> (on some subtree) returned by our (depth-first search) recursion will have two parts:</p>
<ul>
<li><code>Result.node</code>: the largest depth node that is equal to or an ancestor of all the deepest nodes of this subtree.</li>
<li><code>Result.dist</code>: the number of nodes in the path from the root of this subtree, to the deepest node in this subtree.</li>
</ul>
<p>We can calculate these answers disjointly for <code>dfs(node)</code>:</p>
<ul>
<li>
<p>To calculate the <code>Result.node</code> of our answer:</p>
<ul>
<li>
<p>If one <code>childResult</code> has deeper nodes, then <code>childResult.node</code> will be the answer.</p>
</li>
<li>
<p>If they both have the same depth nodes, then <code>node</code> will be the answer.</p>
</li>
</ul>
</li>
<li>
<p>The <code>Result.dist</code> of our answer is always 1 more than the largest <code>childResult.dist</code> we have.</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/4tLcM433/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-216">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/snake-and-ladder-problem4816/1" target="_blank" rel="noopener noreferrer">Snake and Ladder Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a <strong>5x6</strong>&nbsp;snakes and ladders board, find the minimum number of dice throws required to reach the destination or last cell (<strong>30<sup>th</sup></strong>&nbsp;cell) from the source (1st cell). </span></p>

<p><span style="font-size:18px">You are given an integer&nbsp;<strong>N </strong>denoting&nbsp;the&nbsp;total number of snakes and ladders&nbsp;and an array <strong>arr[]</strong>&nbsp;of <strong>2*N</strong> size where <strong>2*i</strong> and <strong>(2*i + 1)<sup>th</sup></strong>&nbsp;values denote the starting and ending point respectively of <strong>i<sup>th&nbsp;</sup></strong>snake or ladder. The&nbsp;board looks like the following.<br />
<strong>Note:&nbsp;</strong>Assume that you have&nbsp;complete control over the 6 sided dice. No ladder starts from 1st cell.</span></p>

<p><br />
<span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="https://contribute.geeksforgeeks.org/wp-content/uploads/snake-and-ladders.jpg" style="border-style:solid; border-width:4px; height:292px; width:436px" /></span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 8
arr[] = {3, 22, 5, 8, 11, 26, 20, 29, 
&nbsp;      17, 4, 19, 7, 27, 1, 21, 9}
<strong>Output: </strong>3
<strong>Explanation:</strong>
The given board is the board shown
in the figure. For the above board 
output will be 3. 
a) For 1st throw get a 2. 
b) For 2nd throw get a 6.
c) For 3rd throw get a 2.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You do not need to read input or print anything. Your task is to complete the function <strong>minThrow()</strong> which takes <strong>N</strong> and <strong>arr</strong> as input parameters and returns the minimum number of throws required to reach the end of the game.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 10<br />
1 &le; arr[i] &le; 30&nbsp;&nbsp;</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-217">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/snakes-and-ladders/description" target="_blank" rel="noopener noreferrer">Snakes and Ladders</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n<sup>2</sup></code> in a <a href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank"><strong>Boustrophedon style</strong></a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.</p>

<p>You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:</p>

<ul>
	<li>Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n<sup>2</sup>)]</code>.

	<ul>
		<li>This choice simulates the result of a standard <strong>6-sided die roll</strong>: i.e., there are always at most 6 destinations, regardless of the size of the board.</li>
	</ul>
	</li>
	<li>If <code>next</code> has a snake or ladder, you <strong>must</strong> move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.</li>
	<li>The game ends when you reach the square <code>n<sup>2</sup></code>.</li>
</ul>

<p>A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n<sup>2</sup></code> are not the starting points of any snake or ladder.</p>

<p>Note that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> follow the subsequent&nbsp;snake or ladder.</p>

<ul>
	<li>For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do <strong>not</strong> follow the subsequent ladder to <code>4</code>.</li>
</ul>

<p>Return <em>the least number of dice rolls required to reach the square </em><code>n<sup>2</sup></code><em>. If it is not possible to reach the square, return </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" style="width: 500px; height: 394px;" />
<pre>
<strong>Input:</strong> board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
In the beginning, you start at square 1 (at row 5, column 0).
You decide to move to square 2 and must take the ladder to square 15.
You then decide to move to square 17 and must take the snake to square 13.
You then decide to move to square 14 and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
This is the lowest possible number of moves to reach the last square, so return 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> board = [[-1,-1],[-1,3]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == board.length == board[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 20</code></li>
	<li><code>board[i][j]</code> is either <code>-1</code> or in the range <code>[1, n<sup>2</sup>]</code>.</li>
	<li>The squares labeled <code>1</code> and <code>n<sup>2</sup></code> are not the starting points of any snake or ladder.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-218">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-items-by-groups-respecting-dependencies/description" target="_blank" rel="noopener noreferrer">Sort Items by Groups Respecting Dependencies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are&nbsp;<code>n</code>&nbsp;items each&nbsp;belonging to zero or one of&nbsp;<code>m</code>&nbsp;groups where <code>group[i]</code>&nbsp;is the group that the <code>i</code>-th item belongs to and it&#39;s equal to <code>-1</code>&nbsp;if the <code>i</code>-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.</p>

<p>Return a sorted list of the items such that:</p>

<ul>
	<li>The items that belong to the same group are next to each other in the sorted list.</li>
	<li>There are some&nbsp;relations&nbsp;between these items where&nbsp;<code>beforeItems[i]</code>&nbsp;is a list containing all the items that should come before the&nbsp;<code>i</code>-th item in the sorted array (to the left of the&nbsp;<code>i</code>-th item).</li>
</ul>

<p>Return any solution if there is more than one solution and return an <strong>empty list</strong>&nbsp;if there is no solution.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/11/1359_ex1.png" style="width: 191px; height: 181px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
<strong>Output:</strong> [6,3,4,1,5,2,0,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
<strong>Output:</strong> []
<strong>Explanation:</strong>&nbsp;This is the same as example 1 except that 4 needs to be before 6 in the sorted list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>group.length == beforeItems.length == n</code></li>
	<li><code>-1 &lt;= group[i] &lt;= m - 1</code></li>
	<li><code>0 &lt;= beforeItems[i].length &lt;= n - 1</code></li>
	<li><code>0 &lt;= beforeItems[i][j] &lt;= n - 1</code></li>
	<li><code>i != beforeItems[i][j]</code></li>
	<li><code>beforeItems[i]&nbsp;</code>does not contain&nbsp;duplicates elements.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-219">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/spidey-sense5556/1" target="_blank" rel="noopener noreferrer">Spidey Sense</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Spiderman is stuck in a difficult situation. His arch-enemy the Green Goblin has planted several of his infamous Pumpkin Bombs in various locations in a building. Help Spiderman activate his Spidey Sense and identify the impact zones.&nbsp;<br />
He has a blueprint of the building which is a M x N matrix that is filled with the characters O, B, and W where:&nbsp;<br />
O represents an open space.<br />
B represents a bomb.<br />
W represents a wall.<br />
You have to replace all of the Os (open spaces) in the matrix with their shortest distance from a bomb without being able to go through any walls. Also, replace the bombs with 0 and walls with -1 in the resultant matrix. If no path exists between a bomb and an open space replace the corresponding &#39;O&#39; with -1.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>N = 3, M = 3
A[] = {</span><span style="font-size:18px">{O, O, O}, 
       {W, B, B},&nbsp;
       {W, O, O</span><span style="font-size:18px">}}</span>
<span style="font-size:18px"><strong>Output:</strong> {</span><span style="font-size:18px">{2, 1, 1}, 
         {-1, 0, 0},&nbsp; 
         {-1, 1, 1</span><span style="font-size:18px">}}</span>
<span style="font-size:18px"><strong>Explanation: </strong></span><span style="font-size:18px">The walls at (1,0) and (2,0) 
are replaced by -1.</span><span style="font-size:18px"> The bombs at (1,1) and 
(1,2) are replaced by 0.</span><span style="font-size:18px"><strong> The impact zone 
for the bomb at (1,1)</strong> includes open spaces 
at index (0,0), (0,1) and (2,1) with distance 
from bomb calculated as 2,1,1 respectively.</span>
<span style="font-size:18px"><strong>The impact zone for the bomb at (1,2)</strong> 
includes open spaces at index (0,3) and (2,2) 
with distance from bomb calculated as 1,1 
respectively.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>IInput: </strong>N = 2, M = 2
A[] = {</span><span style="font-size:18px">{O, O},
       {O, O}</span><span style="font-size:18px">}</span> 
<span style="font-size:18px"><strong>Output:</strong> {{-1, -1}
         {-1, -1}
</span></pre>

<p><span style="font-size:18px"><strong>Your Task: </strong>&nbsp;<br />
You don&#39;t need to read input or print anything. Complete the function <strong>findDistance()</strong> which takes the matrix A[], M, and N as input parameters and the resultant matrix</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(M*N)<br />
<strong>Expected Auxiliary Space:</strong> O(M*N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N*M &le; 10<sup>6</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-220">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/steps-by-knight5927/1" target="_blank" rel="noopener noreferrer">Steps by Knight</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square <strong>chessboard </strong>of<strong> </strong>size <strong>(n x n)</strong>, the initial position and target postion of Knight are given. Find out the <strong>minimum steps</strong> a Knight will take to reach the target position.<br /><br /></span><span style="font-size: 18px;"><strong>Note: </strong>The initial and the target position coordinates of Knight have been given according to 1-base indexing.<br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 3<strong>, </strong>knightPos[] = [3, 3], targetPos[]= [1, 2]<strong><br />Output:</strong> 1<strong><br />Explanation:<br /></strong>Knight takes 1 step to reach from&nbsp;<br />(3, 3) to (1 ,2).</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 6, knightPos[] = [4, 5],targetPos[] = [1, 1]</span>
<span style="font-size: 18px;"><strong>Output: </strong>3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/KnightChess.jpg" />
<span style="font-size: 18px;">Knight takes 3 step to reach from 
(4, 5) to (1, 1):
(4, 5) -&gt; (5, 3) -&gt; (3, 2) -&gt; (1, 1).</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n&lt;= 1000<br />1 &lt;= knightpos </span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito; font-size: 17px;">&le; </span><span style="font-size: 18px;">[x, y], </span><span style="font-size: 18px;">targertpos[x, y] </span><span style="background-color: #ffffff; color: #1e2229; font-family: Nunito; font-size: 17px;">&le;&nbsp;</span><span style="font-size: 18px;"> n&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-221">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-left-leaves/description" target="_blank" rel="noopener noreferrer">Sum of Left Leaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p>

<p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 24
<strong>Explanation:</strong> There are two left leaves in the binary tree, with values 9 and 15 respectively.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-222">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/description" target="_blank" rel="noopener noreferrer">Sum of Nodes with Even-Valued Grandparent</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the sum of values of nodes with an <strong>even-valued grandparent</strong></em>. If there are no nodes with an <strong>even-valued grandparent</strong>, return <code>0</code>.</p>

<p>A <strong>grandparent</strong> of a node is the parent of its parent if it exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg" style="width: 504px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
<strong>Output:</strong> 18
<strong>Explanation:</strong> The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/even2-tree.jpg" style="width: 64px; height: 65px;" />
<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth-First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<p>We are given a binary tree, and we need to return the sum of nodes that has even values grandparent. The grandparent of a node is the parent of its immediate parent.</p>
<p>We need to iterate over the nodes in the binary tree in a way that we can find the value of its grandparent. We can then check if the value of its grandparent is even, and if so, add the value of that node to the answer. One way to iterate a tree is Depth-First Search, i.e., DFS. We can recursively iterate over the nodes in the tree in depth wise manner, but keeping two extra pieces of information: the value of its immediate parent, and the value of its grandparent. This enables us to decide whether the value of the current node should be added to the answer.</p>
<p>How will we find the value of parent and grandparent for each node? We can start with the root node and which has neither the parent nor the grandparent node. We can use arbitrary odd values to represent their values so that we don't add the root value to the answer. The value of the parent node for the child node and the value of the grandparent node can be obtained as the current node's value and the parent node's value of the current node, respectively.</p>
<p><img src="../Figures/1315/1315A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define the method <code>solve()</code> that takes the TreeNode <code>root</code>, the parent value <code>parent</code> and the grandparent value <code>gParent</code>. This method returns the number of nodes with even-valued grandparent under the subtree of node <code>root.</code></li>
<li>Call the recursive function <code>solve()</code> with the root node and <code>-1</code> as the parent value  <code>parent</code> and grandparent value <code>gParent</code></li>
<li>If the <code>root</code> is null, then we can return <code>0</code> as the sum.</li>
<li>Recursively iterate over the left and right child with parent value as <code>root</code> and grandparent value as <code>parent</code>.</li>
<li>If the value of <code>gParent</code> is even, then add the value of <code>root</code> to the answer.</li>
<li>Return the sum for the left and right child and the value for the current node.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/DqPDwS7k/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need to iterate over every node only once with parent and grandparent values in the recursive function. Hence the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The only space required is the stack recursion calls, the maximum number of active stack calls would be equal to <span class="math inline">\(O(N)\)</span> when the tree is skewed and there is one function call for each of the nodes in the recursive stack. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
 <br/>
<hr />
<h3 id="approach-2--breadth-first-search-bfs">Approach 2:  Breadth-First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<p>The other way to iterate over the nodes in a binary tree is using Breadth-First Search. We will iterate over the nodes in a breadth-wise manner, and for each node, we need to find a way to determine if it has a grandparent with an even value.</p>
<p>Since we will iterate over the nodes in an iterative manner using BFS, we have to use a different method to find the grandparent. What if, instead of checking the ancestor nodes of each node, we look for the grandchildren nodes of each node? This way, we don't have to keep the parent and grandparent values as we did before.</p>
<p>As shown below we will check the four grandchildren for each node which has an even value, we will add the value of all these grandchildren to the answer.</p>
<p><img src="../Figures/1315/1315B.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Initialize an empty queue <code>q</code>, and a variable <code>sum</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over the queue while it's not empty and for each node:</p>
<ol>
<li>Pop the node from the queue as <code>curr</code>.</li>
<li>If the value of <code>curr</code> is even, then check the grandchildren of this node and add the values to the variable <code>sum</code>.</li>
<li>Add the left and right child of the node <code>curr</code> if they are not null.</li>
</ol>
</li>
<li>
<p>Return <code>sum</code>.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/KRsZnFWh/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The outer while loop continues if there are nodes in the queue. Each node will be added to the queue and popped from the queue only once. If its value is even, we will keep popping the node and check its four grandchildren. All these operations are constant in terms of time complexity. Hence the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need a queue to store the nodes at a particular level of the binary tree. The number of nodes in different levels of a full binary tree will be <code>${1, 2, 4, 8......2^{N - 1}}$</code>, with total nodes equal to <span class="math inline">\(2^N\)</span>, therefore, the maximum number of nodes at a time in the queue will be of the order <span class="math inline">\(O(N)\)</span>. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-223">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/surrounded-regions/description" target="_blank" rel="noopener noreferrer">Surrounded Regions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>board</code> containing <strong>letters</strong> <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <strong>capture regions</strong> that are <strong>surrounded</strong>:</p>

<ul>
	<li><strong>Connect</strong>: A cell is connected to adjacent cells horizontally or vertically.</li>
	<li><strong>Region</strong>: To form a region <strong>connect every</strong> <code>&#39;O&#39;</code> cell.</li>
	<li><strong>Surround</strong>: The region is surrounded with <code>&#39;X&#39;</code> cells if you can <strong>connect the region </strong>with <code>&#39;X&#39;</code> cells and none of the region cells are on the edge of the <code>board</code>.</li>
</ul>

<p>To capture a <strong>surrounded region</strong>, replace all <code>&#39;O&#39;</code>s with <code>&#39;X&#39;</code>s <strong>in-place</strong> within the original board. You do not need to return anything.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" style="width: 367px; height: 158px;" />
<p>In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;X&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[&quot;X&quot;]]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-224">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swim-in-rising-water/description" target="_blank" rel="noopener noreferrer">Swim in Rising Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p>

<p>It starts raining, and water gradually rises over time. At time <code>t</code>, the water level is <code>t</code>, meaning <strong>any</strong> cell with elevation less than equal to <code>t</code> is submerged or reachable.</p>

<p>You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>

<p>Return <em>the minimum time until you can reach the bottom right square </em><code>(n - 1, n - 1)</code><em> if you start at the top left square </em><code>(0, 0)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[0,2],[1,3]]
<strong>Output:</strong> 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg" style="width: 404px; height: 405px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
<strong>Output:</strong> 16
<strong>Explanation:</strong> The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>
	<li>Each value <code>grid[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-225">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/symmetric-tree/description" target="_blank" rel="noopener noreferrer">Symmetric Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" style="width: 354px; height: 291px;" />
<pre>
<strong>Input:</strong> root = [1,2,2,3,4,4,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" style="width: 308px; height: 258px;" />
<pre>
<strong>Input:</strong> root = [1,2,2,null,3,null,3]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you solve it both recursively and iteratively?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-226">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-time-when-the-network-becomes-idle/description" target="_blank" rel="noopener noreferrer">The Time When the Network Becomes Idle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a network of <code>n</code> servers, labeled from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates there is a message channel between servers <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, and they can pass <strong>any</strong> number of messages to <strong>each other</strong> directly in <strong>one</strong> second. You are also given a <strong>0-indexed</strong> integer array <code>patience</code> of length <code>n</code>.</p>

<p>All servers are <strong>connected</strong>, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.</p>

<p>The server labeled <code>0</code> is the <strong>master</strong> server. The rest are <strong>data</strong> servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers <strong>optimally</strong>, so every message takes the <strong>least amount of time</strong> to arrive at the master server. The master server will process all newly arrived messages <strong>instantly</strong> and send a reply to the originating server via the <strong>reversed path</strong> the message had gone through.</p>

<p>At the beginning of second <code>0</code>, each data server sends its message to be processed. Starting from second <code>1</code>, at the <strong>beginning</strong> of <strong>every</strong> second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:</p>

<ul>
	<li>If it has not, it will <strong>resend</strong> the message periodically. The data server <code>i</code> will resend the message every <code>patience[i]</code> second(s), i.e., the data server <code>i</code> will resend the message if <code>patience[i]</code> second(s) have <strong>elapsed</strong> since the <strong>last</strong> time the message was sent from this server.</li>
	<li>Otherwise, <strong>no more resending</strong> will occur from this server.</li>
</ul>

<p>The network becomes <strong>idle</strong> when there are <strong>no</strong> messages passing between servers or arriving at servers.</p>

<p>Return <em>the <strong>earliest second</strong> starting from which the network becomes <strong>idle</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example 1" src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" style="width: 750px; height: 384px;" />
<pre>
<strong>Input:</strong> edges = [[0,1],[1,2]], patience = [0,2,1]
<strong>Output:</strong> 8
<strong>Explanation:</strong>
At (the beginning of) second 0,
- Data server 1 sends its message (denoted 1A) to the master server.
- Data server 2 sends its message (denoted 2A) to the master server.

At second 1,
- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.
- Server 1 has not received any reply. 1 second (1 &lt; patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.
- Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).

At second 2,
- The reply 1A arrives at server 1. No more resending will occur from server 1.
- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.
- Server 2 resends the message (denoted 2C).
...
At second 4,
- The reply 2A arrives at server 2. No more resending will occur from server 2.
...
At second 7, reply 2D arrives at server 2.

Starting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.
This is the time when the network becomes idle.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="example 2" src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" style="width: 100px; height: 85px;" />
<pre>
<strong>Input:</strong> edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Data servers 1 and 2 receive a reply back at the beginning of second 2.
From the beginning of the second 3, the network becomes idle.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == patience.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>patience[0] == 0</code></li>
	<li><code>1 &lt;= patience[i] &lt;= 10<sup>5</sup></code> for <code>1 &lt;= i &lt; n</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>Each server can directly or indirectly reach another server.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-227">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/time-needed-to-inform-all-employees/description" target="_blank" rel="noopener noreferrer">Time Needed to Inform All Employees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A company has <code>n</code> employees with a unique ID for each employee from <code>0</code> to <code>n - 1</code>. The head of the company is the one with <code>headID</code>.</p>

<p>Each employee has one direct manager given in the <code>manager</code> array where <code>manager[i]</code> is the direct manager of the <code>i-th</code> employee, <code>manager[headID] = -1</code>. Also, it is guaranteed that the subordination relationships have a tree structure.</p>

<p>The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.</p>

<p>The <code>i-th</code> employee needs <code>informTime[i]</code> minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).</p>

<p>Return <em>the number of minutes</em> needed to inform all the employees about the urgent news.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1, headID = 0, manager = [-1], informTime = [0]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The head of the company is the only employee in the company.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/27/graph.png" style="width: 404px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.
The tree structure of the employees in the company is shown.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= headID &lt; n</code></li>
	<li><code>manager.length == n</code></li>
	<li><code>0 &lt;= manager[i] &lt; n</code></li>
	<li><code>manager[headID] == -1</code></li>
	<li><code>informTime.length == n</code></li>
	<li><code>0 &lt;= informTime[i] &lt;= 1000</code></li>
	<li><code>informTime[i] == 0</code> if employee <code>i</code> has no subordinates.</li>
	<li>It is <strong>guaranteed</strong> that all the employees can be informed.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-228">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/trapping-rain-water-ii/description" target="_blank" rel="noopener noreferrer">Trapping Rain Water II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integer matrix <code>heightMap</code> representing the height of each unit cell in a 2D elevation map, return <em>the volume of water it can trap after raining</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg" style="width: 361px; height: 321px;" />
<pre>
<strong>Input:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> After the rain, water is trapped between the blocks.
We have two small ponds 1 and 3 units trapped.
The total volume of water trapped is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg" style="width: 401px; height: 321px;" />
<pre>
<strong>Input:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
<strong>Output:</strong> 10
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == heightMap.length</code></li>
	<li><code>n == heightMap[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a grid, <code>heightMap</code>, where each element represents the height of the corresponding cell in the 3D representation of the map. Our task is to calculate the total amount of water trapped on the map after it rains.</p>
<p>We can assume that it rains an infinite amount of water, but the water stays inside any area of the map only if there is a boundary that traps it. Specifically, the water remains on top of a cell as long as its combined height (the height of the cell plus the water above it) is less than or equal to the height of all its neighbors. If any neighbor is lower, the water will flow out to that lower cell.</p>
<hr />
<h3 id="approach-bfs--priority-queue">Approach: BFS + Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<p>Building on the earlier observation, the total height of any cell (its original height plus any trapped water) must not exceed the smallest total height of its neighbors. Specifically, it cannot exceed the smallest total height of its neighboring cells. This constraint propagates outward from the grid’s edges, which act as the ultimate boundary since no water can be trapped beyond them.</p>
<p>In simpler terms, the cells around a region of the grid act as a boundary, and the smallest height of this boundary determines how much water can be stored in that region. To solve the problem, we begin by treating the edges of the grid as the initial boundary since water cannot spill beyond them. From there, we move inward, processing cells in a manner that respects the relationship between a cell’s height and the boundary:</p>
<ol>
<li>
<p><strong>Trapping Water</strong>: When we process a cell, if its height is lower than the current boundary height, water can be trapped above it. The amount of water trapped is equal to the difference between the boundary height and the cell’s height. We then add this trapped water to our running total. To ensure the boundary remains valid, the cell is added to the boundary with its effective height adjusted to match the current boundary height. This adjustment prevents water from &quot;spilling&quot; through this cell and invalidating the boundary.</p>
</li>
<li>
<p><strong>Updating the Boundary</strong>: If the cell's height is greater than or equal to the boundary height, no water can be trapped above it. However, the cell still becomes part of the boundary because it might help trap water in adjacent, higher regions as we continue processing.</p>
</li>
</ol>
<p>To efficiently manage the boundary and dynamically update the smallest height, we use a min-heap (priority queue). The heap lets us quickly find the lowest boundary height and ensure the traversal always processes the most constrained regions first.</p>
<blockquote>
<p>For a more comprehensive understanding of heaps and priority queues, check out the <a href="https://leetcode.com/explore/learn/card/heap/">Heap Explore Card 🔗</a>. This resource provides an in-depth look at heap-based algorithms, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>!?!../Documents/407/407_approach1_fix.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a struct <code>Cell</code> that stores the height and the coordinates of a cell in the map.</li>
<li>Define two direction arrays, that will help us explore the neighbors of each cell: <code>dRow = [0, 0, -1, 1], dCol = [-1, 1, 0, 0]</code>.</li>
<li>Initialize <code>numOfRows</code> and <code>numOfCols</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create a <code>numOfRows x numOfCols</code> boolean grid, called <code>visited</code>, with all its values initialized to <code>false</code>.</li>
<li>Initialize a priority queue (min-heap) of <code>Cells</code>, called <code>boundary</code>.</li>
<li>Push the cells of the first and last row and column of the grid into the <code>boundary</code> and mark them as visited.</li>
<li>Initialize <code>totalWaterVolume</code> to <code>0</code>.</li>
<li>While the <code>boundary</code> is not empty:
<ul>
<li>Pop the top cell out of the <code>boundary</code>, as <code>[minBoundaryHeight, [currentRow, currentCol]]</code> - this is the cell with the minimum height in the unexplored part of the boundary.</li>
<li>Update <code>minBoundaryHeight</code> to <code>height</code>.</li>
<li>Loop through all neighbors of the current cell, with <code>direction</code> from <code>0</code> to <code>3</code>:
<ul>
<li>Initialize <code>neighborRow</code> to <code>currentRow + dRow[direction]</code> and <code>neighborCol</code> to <code>currentCol + dCol[direction]</code>.</li>
<li>If the cell <code>(neighborRow, neighborCol)</code> is valid, i.e. it is not out of the bounds of the grid and not visited:
<ul>
<li>If the height of the cell, <code>neighborHeight</code> is lower than <code>minBoundaryHeight</code>, add the difference <code>minBoundaryHeight - neighborHeight</code> to the <code>totalWaterVolume</code>.</li>
<li>Push the neighboring cell into the <code>boundary</code> with its height set to the maximum of its value and <code>minBoundayHeight</code>, as the lowest height of the boundary cannot fall below its current value.</li>
<li>Mark the neighboring cell as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalWaterVolume</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dt4uER9y/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns of the input grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \times \log{m \cdot n})\)</span></p>
<p>Each cell is pushed in the <code>boundary</code> exactly once, so the while loops runs <span class="math inline">\(O(mn)\)</span> times. On each iteration, an element is popped from the priority queue and four other elements (the neighboring cells) are potentially pushed into it. Since the push and pop operations of the priority queue have a time complexity of <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> represents the size of the priority queue, the overall time complexity of the algorithm becomes <span class="math inline">\(O(m \cdot n \times \log{m \cdot n})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>We create a <code>visited</code> grid of size <span class="math inline">\(m \times n\)</span> to keep track of the cells already explored. The priority queue, <code>boundary</code> can also grow up to <span class="math inline">\(O(m \times n)\)</span> in size, so the algorithm requires <span class="math inline">\(O(m \times n)\)</span> extra space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-229">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/till-the-end-of-the-time-d73ba7d1/" target="_blank" rel="noopener noreferrer">Travel diaries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">grammar-verified</span> <span class="topic-badge">graph</span> <span class="topic-badge">medium</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a matrix of size <span class="mathjax-latex">\(N \times M\)</span> that contains the digits <em>0</em>, <em>1</em>, or <em>2</em> only. All the cells that contain <em>1</em> and are adjacent to any cell that contains <em>2</em> will be converted from <em>1</em> to <em>2</em>, simultaneously in <em>1</em> second. Write a program to find the minimum time to convert all the cells having value <em>1</em> to <em>2</em>.</p>
<p><strong>Input format</strong><br /></p>
<ul>
<li>First line: Two space-separated integers <em>N</em> and <em>M</em><br /></li>
<li>Next <em>N</em> lines: <em>M</em> space-separated integers (denoting the matrix)</li>
</ul>
<p><strong>Output format</strong><br /></p>
<p>Print the minimum time to convert all the cells having value <em>1</em> to <em>2</em>.</p>
<p><strong>Constraints</strong><br /></p>
<p><span class="mathjax-latex">\(1 ≤ N, M ≤ 10^3 \)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>If you starts from the cell [1,4] or [3,4] and travels to [2,3] then the cost will be 2 which is maximum of all possible journeys.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-230">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/tree-journeys-fd9f8f9c/" target="_blank" rel="noopener noreferrer">Tree Trips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">bruteforce</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Bob is going to make <span class="mathjax-latex">\(m\)</span>&nbsp;trips on a <strong>tree</strong>. During each trip he goes from a node, <span class="mathjax-latex">\(x_{i}\)</span>,&nbsp;to another node, <span class="mathjax-latex">\(y_{i}\)</span>, using the simple path between the two nodes.&nbsp;</p>

<p>Alice is jealous of Bob, and doesn't want him to be able to go on any of the <span class="mathjax-latex">\(m\)</span> trips. Before Bob wakes up, Alice plans to remove some edges in the tree, in a way that Bob wouldn't be able to make <strong>any of the <span class="mathjax-latex">\(m\)</span> trips</strong>.&nbsp;</p>

<p>Please, help Alice find out the <strong>minimum </strong>number of edges she should remove from the tree, so Bob cannot make any of the trips.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>INPUT FORMAT</strong></p>

<p>The first line of input contains two integers,&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;<span class="mathjax-latex">\((2 &lt;= n &lt;= 15)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;<span class="mathjax-latex">\((1 &lt;= m &lt;= \frac{n(n - 1)}{2})\)</span>&nbsp;- denoting the number of nodes in the tree, and the number of trips Bob wants to make.&nbsp;</p>

<p>The next&nbsp;<span class="mathjax-latex">\(n - 1\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(u_{i} (1 &lt;= u_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(v_{i} (1 &lt;= v_{i} &lt;= n)\)</span>&nbsp;(<span class="mathjax-latex">\(u_{i} &lt; v_{i}\)</span>)&nbsp;- denoting the edges in the tree.&nbsp;</p>

<p>The last&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(x_{i} (1 &lt;= x_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(y_{i} (1 &lt;= y_{i} &lt;= n)\)</span>&nbsp;<span class="mathjax-latex">\((x_{i} \neq y_{i})\)</span>&nbsp;- denoting start and end nodes of the trips Bob wants to make.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>OUTPUT FORMAT</strong></p>

<p>The minimum number of edges Alice should remove from the tree to make the trips impossible.&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the sample input we have a tree with <span class="mathjax-latex">\(4\)</span> edges <span class="mathjax-latex">\((1, 2)\)</span>, <span class="mathjax-latex">\((1, 3)\)</span>, <span class="mathjax-latex">\((1, 4)\)</span> and <span class="mathjax-latex">\((1, 5)\)</span>.</p>

<p>The tree looks like:&nbsp;</p>

<p><img alt="" height="300" src="https://he-s3.s3.amazonaws.com/media/uploads/1bff5952-4c0f-4a7b-a0c2-0aee81416da9.png" width="318"></p>

<p>Bob wants to make the following trips <strong>2 -&gt; 3&nbsp;</strong>and <strong>3 -&gt; 4</strong>.&nbsp;</p>

<p>It is easy to see that if we remove the edge <span class="mathjax-latex">\((1, 3)\)</span>, then he can't make any of those trips. The resulting graphs looks like:&nbsp;</p>

<p><img alt="" height="280" src="https://he-s3.s3.amazonaws.com/media/uploads/216160d7-496e-4da9-a8b5-558d32c189b1.png" width="325"></p>

<p>Hence, the answer for this input is <span class="mathjax-latex">\(1\)</span>.&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-231">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/two-sum-iv-input-is-a-bst/description" target="_blank" rel="noopener noreferrer">Two Sum IV - Input is a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree and an integer <code>k</code>, return <code>true</code> <em>if there exist two elements in the BST such that their sum is equal to</em> <code>k</code>, <em>or</em> <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 9
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 28
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li><code>root</code> is guaranteed to be a <strong>valid</strong> binary search tree.</li>
	<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-232">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/length-of-largest-region-of-1s-1587115620/1" target="_blank" rel="noopener noreferrer">Unit Area of largest region of 1&#39;s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a grid of dimension <strong>n</strong>x<strong>m&nbsp;</strong>containing 0s and 1s. Find the unit area of the largest region of 1s.<br />
Region of 1&#39;s is a group of 1&#39;s connected 8-directionally (horizontally, vertically, diagonally).</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>grid = {{1,1,1,0},{0,0,1,0},{0,0,0,1}}
<strong>Output: </strong>5
<strong>Explanation: </strong>The grid is-
<span style="color:#FF0000">1 1 1</span> 0
0 0 <span style="color:#FF0000">1 </span>0
0 0 0 <span style="color:#FF0000">1
</span>The largest region of 1&#39;s is colored
in orange.
</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>grid = {{0,1}}
<strong>Output: </strong>1
<strong>Explanation: </strong>The grid is-
0 <span style="color:#FF0000">1
</span>The largest region of 1&#39;s is colored in 
orange.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read or print anyhting. Your task is to complete the function&nbsp;<strong>findMaxArea()&nbsp;</strong>which takes grid as input parameter and returns the area of the largest region of 1&#39;s.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(n*m)<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(n*m)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n, m &le; 500</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-233">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unit-conversion-i/description" target="_blank" rel="noopener noreferrer">Unit Conversion I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> types of units indexed from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>conversions</code> of length <code>n - 1</code>, where <code>conversions[i] = [sourceUnit<sub>i</sub>, targetUnit<sub>i</sub>, conversionFactor<sub>i</sub>]</code>. This indicates that a single unit of type <code>sourceUnit<sub>i</sub></code> is equivalent to <code>conversionFactor<sub>i</sub></code> units of type <code>targetUnit<sub>i</sub></code>.</p>

<p>Return an array <code>baseUnitConversion</code> of length <code>n</code>, where <code>baseUnitConversion[i]</code> is the number of units of type <code>i</code> equivalent to a single unit of type 0. Since the answer may be large, return each <code>baseUnitConversion[i]</code> <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">conversions = [[0,1,2],[1,2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,6]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Convert a single unit of type 0 into 2 units of type 1 using <code>conversions[0]</code>.</li>
	<li>Convert a single unit of type 0 into 6 units of type 2 using <code>conversions[0]</code>, then <code>conversions[1]</code>.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/12/example1.png" style="width: 545px; height: 118px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">conversions = [[0,1,2],[0,2,3],[1,3,4],[1,4,5],[2,5,2],[4,6,3],[5,7,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,3,8,10,6,30,24]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Convert a single unit of type 0 into 2 units of type 1 using <code>conversions[0]</code>.</li>
	<li>Convert a single unit of type 0 into 3 units of type 2 using <code>conversions[1]</code>.</li>
	<li>Convert a single unit of type 0 into 8 units of type 3 using <code>conversions[0]</code>, then <code>conversions[2]</code>.</li>
	<li>Convert a single unit of type 0 into 10 units of type 4 using <code>conversions[0]</code>, then <code>conversions[3]</code>.</li>
	<li>Convert a single unit of type 0 into 6 units of type 5 using <code>conversions[1]</code>, then <code>conversions[4]</code>.</li>
	<li>Convert a single unit of type 0 into 30 units of type 6 using <code>conversions[0]</code>, <code>conversions[3]</code>, then <code>conversions[5]</code>.</li>
	<li>Convert a single unit of type 0 into 24 units of type 7 using <code>conversions[1]</code>, <code>conversions[4]</code>, then <code>conversions[6]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>conversions.length == n - 1</code></li>
	<li><code>0 &lt;= sourceUnit<sub>i</sub>, targetUnit<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= conversionFactor<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li>It is guaranteed that unit 0 can be converted into any other unit through a <strong>unique</strong> combination of conversions without using any conversions in the opposite direction.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-234">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/univalued-binary-tree/description" target="_blank" rel="noopener noreferrer">Univalued Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A binary tree is <strong>uni-valued</strong> if every node in the tree has the same value.</p>

<p>Given the <code>root</code> of a binary tree, return <code>true</code><em> if the given tree is <strong>uni-valued</strong>, or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png" style="width: 265px; height: 172px;" />
<pre>
<strong>Input:</strong> root = [1,1,1,1,1,null,1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png" style="width: 198px; height: 169px;" />
<pre>
<strong>Input:</strong> root = [2,2,2,5,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt; 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Let's output all the values of the array.  After, we can check that they are all equal.</p>
<p>To output all the values of the array, we perform a depth-first search.</p>
<p><a href="https://leetcode.com/playground/YmASBunM/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the given tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>A tree is univalued if both its children are univalued, plus the root node has the same value as the child nodes.</p>
<p>We can write our function recursively.  <code>left_correct</code> will represent that the left child is correct: ie., that it is univalued, and the root value is equal to the left child's value.  <code>right_correct</code> will represent the same thing for the right child.  We need both of these properties to be true.</p>
<p><a href="https://leetcode.com/playground/gRV5CroQ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the given tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(H)\)</span>, where <span class="math inline">\(H\)</span> is the height of the given tree.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-235">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/validate-binary-tree-nodes/description" target="_blank" rel="noopener noreferrer">Validate Binary Tree Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> binary tree nodes numbered from <code>0</code> to <code>n - 1</code> where node <code>i</code> has two children <code>leftChild[i]</code> and <code>rightChild[i]</code>, return <code>true</code> if and only if <strong>all</strong> the given nodes form <strong>exactly one</strong> valid binary tree.</p>

<p>If node <code>i</code> has no left child then <code>leftChild[i]</code> will equal <code>-1</code>, similarly for the right child.</p>

<p>Note that the nodes have no values and that we only use the node numbers in this problem.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png" style="width: 195px; height: 287px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png" style="width: 183px; height: 272px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png" style="width: 82px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 2, leftChild = [1,0], rightChild = [-1,-1]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == leftChild.length == rightChild.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Before we go into the approaches, let's first talk about what makes a binary tree valid.</p>
<blockquote>
<p>Note that while this is not a formal definition of a binary tree, these rules are sufficient for solving the problem.</p>
</blockquote>
<p><strong>A binary tree must have a root. This is a node with no incoming edges - that is, the root has no parent.</strong></p>
<p><img src="../Figures/1361/1.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p><img src="../Figures/1361/2.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>The tree must be connected - every node must be reachable from one node (the root).</strong></p>
<p><img src="../Figures/1361/3.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>There cannot be a cycle.</strong></p>
<p><img src="../Figures/1361/4.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p>To solve this problem, we can check the nodes given to us against these rules.</p>
<blockquote>
<p>You may notice that some of these rules imply each other. For example, if a binary tree had a root, it would have a cycle only if it was not connected, or there was a node with more than one parent.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
</blockquote>
<p>One way to solve this problem would be to perform a DFS on the tree and check that all the rules are followed. Before we can start a DFS, we need to locate the root. Let's define a function <code>findRoot</code> that helps us find the root.</p>
<p>As mentioned above, the root has no parent - this also means that the root is not the child of any nodes. The input arrays <code>leftChild</code> and <code>rightChild</code> describe all children, so the root would not appear in these arrays. We can simply use a for loop from <code>0</code> to <code>n - 1</code> and for each number, check if it is present in <code>leftChild</code> or <code>rightChild</code>. If it's not present in either, then we can return it as the root. If we don't find any root, we can return <code>-1</code>.</p>
<p>To improve efficiency, we will convert <code>leftChild</code> and <code>rightChild</code> to a set for <span class="math inline">\(O(1)\)</span> checks.</p>
<p><a href="https://leetcode.com/playground/iV5vT2dM/shared">code</a></p>
<p>We will start by obtaining <code>root = findRoot()</code>. If <code>root = -1</code>, there is no node without a parent, and we can immediately return false as the tree is invalid.</p>
<p>Once we have the root, we can start a DFS from it. We will implement the DFS iteratively with a stack. How can we validate the tree? First of all, if we see a node multiple times during the DFS, it means a node has multiple parents (and there could be a cycle). We will use a set <code>seen</code> that keeps track of all the nodes we have seen so far during the traversal. When we move to a <code>child</code>, if <code>child</code> is already in <code>seen</code>, we can immediately return false since we would be visiting <code>child</code> for the second time.</p>
<p>Once the DFS finishes, every node we visited will be in <code>seen</code>. If the tree is connected, then the length of <code>seen</code> will be equal to <code>n</code>. If <code>seen.length != n</code>, it means that some nodes were not visited, and thus the tree must be disconnected. Thus, we can return <code>seen.length == n</code> at the end of the algorithm.</p>
<p>This process is sufficient in validating a binary tree:</p>
<ol>
<li>If a binary tree does not have a root, then <code>findRoot</code> will return <code>-1</code>.</li>
<li>If there is a node with more than one parent, then we will detect it with <code>seen</code>.</li>
<li>If the tree is disconnected, then <code>seen</code> will hold less than <code>n</code> nodes at the end.</li>
<li>If there is a cycle, then we will detect it with <code>seen</code>.</li>
</ol>
<p>Any other scenario we don't explicitly check for will be caught by some other rule. For example, the second rule we stated was:</p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p>You may be thinking: we are explicitly checking the case when a node has multiple parents with <code>seen</code>, but what if there is a node with no parent other than the <code>root</code>? That is, what if there are multiple roots? In that scenario, <code>findRoot</code> would give us the root with the lowest value. We would perform a DFS from there, and never reach any of the other roots. Then at the end, <code>seen</code> would have less than <code>n</code> nodes.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>stack</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop the top of the stack as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the stack and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the DFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/W65UxZEa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a DFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>stack</code> and <code>seen</code> during the DFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes an interviewer may ask you to implement both BFS and DFS. This approach is the same as the previous one, except we will use BFS to perform the traversal instead of DFS.</p>
<p>BFS uses a queue instead of a stack. If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>queue</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Pop the front of the queue as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the queue and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the BFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8LE3ZeZN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a BFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once. Note that an efficient queue implementation with <span class="math inline">\(O(1)\)</span> operations is required to achieve this complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>queue</code> and <code>seen</code> during the BFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union Find</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This is a more advanced, but interesting way to approach this problem. We have included it for the sake of completeness. It is unlikely you will be expected to implement this approach in an interview if you have already used one of the previous approaches, so we will not delve into great detail in this approach.</p>
</blockquote>
<p>A disjoint-set data structure (also called a union–find), is a data structure that stores a collection of disjoint (non-overlapping) sets. Union-find provides us with the following methods:</p>
<ol>
<li><code>find</code>: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.</li>
<li><code>union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Leetcode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Initially, all nodes belong to their own subset. We will iterate over all <code>(parent, child)</code> pairs given in <code>leftChild</code> and <code>rightChild</code> and attempt a <code>union</code>. We want to assign the subset of <code>child</code> to the subset of <code>parent</code>. For each call to <code>union(parent, child)</code>, we can see if the tree is invalid with the following checks:</p>
<ol>
<li>If <code>find(child) != child</code>, then <code>child</code> must have been assigned a parent earlier, and thus <code>child</code> has multiple parents.</li>
<li>If <code>parent</code> and <code>child</code> already belong to the same subset, then there must be a directed path from <code>child</code> to <code>parent</code> as <code>parent</code> must have been assigned to the subset of <code>child</code> earlier, and thus there exists a cycle.</li>
</ol>
<p>After performing all <code>union</code> operations successfully between parents and their children, there should only be one component in the union-find data structure. We can track the number of components by subtracting one from the count on each successful <code>union</code> operation, and then check whether the final count of components is equal to 1.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a union-find data structure <code>uf</code> that implements <code>find(node)</code> and <code>union(parent, child)</code>. It should also track the number of <code>components</code>.
<ul>
<li>In <code>union</code>, we return a boolean indicating if the union was successful. A union is unsuccessful if the parent of <code>child</code> is not <code>child</code>, or the parent of <code>parent</code> is <code>child</code>.</li>
<li>If <code>union</code> is successful, we assign the subset of <code>child</code> to the subset of <code>parent</code> and decrement the number of <code>components</code>.</li>
</ul>
</li>
<li>Iterate <code>node</code> from <code>0</code> until <code>n</code>:
<ul>
<li>Iterate over the children of <code>node</code> as <code>child</code>:
<ul>
<li>If <code>child == - 1</code>, ignore it.</li>
<li>Otherwise, perform a <code>union(node, child)</code>. If it returns false, then <code>return false</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>uf.components == 1</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note: In C++, <code>union</code> is a reserved keyword and cannot be redefined. Therefore, we need to rename the <code>union</code> method, and we call it <code>join</code> here.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/c33bCEGR/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>For <span class="math inline">\(T\)</span> operations, the amortized time complexity of the union-find algorithm with path compression and union-by rank is <span class="math inline">\(O(\alpha(T))\)</span>. Here, <span class="math inline">\(\alpha(T)\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(T\)</span> (approximately <span class="math inline">\( T < 10^{600}\)</span>). You can read more about the complexity of union-find <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity">here</a>. Because the function grows so slowly, we consider it to be <span class="math inline">\(O(1)\)</span>.</p>
<p>You may have noticed that we didn't use union-by-rank optimization as in other DSU problems. The reason for this is that the structure of this problem is not like a regular graph. More specifically, if a pair of nodes <code>(parent, child)</code> is considered valid for union, only the eligible tree root node is considered as the new child, and it will always have a rank of 0. Therefore, during the union process, the rank of all nodes will not exceed 1. As for the possibility of nodes having a rank greater than 1, it would be filtered out as required by the problem statement and won't occur. Therefore, we don't need to use union-by-rank in this problem. We encourage readers to build test cases and try them out.</p>
<p>Initializing the <code>UnionFind</code> data structure costs <span class="math inline">\(O(n)\)</span>. Then, we simply iterate over each node once and perform some union-find operations at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>UnionFind</code> data structure keeps a <code>parents</code> array that takes <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-236">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Vertical Order Traversal of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, calculate the <strong>vertical order traversal</strong> of the binary tree.</p>

<p>For each node at position <code>(row, col)</code>, its left and right children will be at positions <code>(row + 1, col - 1)</code> and <code>(row + 1, col + 1)</code> respectively. The root of the tree is at <code>(0, 0)</code>.</p>

<p>The <strong>vertical order traversal</strong> of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.</p>

<p>Return <em>the <strong>vertical order traversal</strong> of the binary tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" style="width: 431px; height: 304px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[9],[3,15],[20],[7]]
<strong>Explanation:</strong>
Column -1: Only node 9 is in this column.
Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
Column 1: Only node 20 is in this column.
Column 2: Only node 7 is in this column.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" style="width: 512px; height: 304px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7]
<strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]
<strong>Explanation:</strong>
Column -2: Only node 4 is in this column.
Column -1: Only node 2 is in this column.
Column 0: Nodes 1, 5, and 6 are in this column.
          1 is at the top, so it comes first.
          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
Column 1: Only node 3 is in this column.
Column 2: Only node 7 is in this column.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" style="width: 512px; height: 304px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,6,5,7]
<strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]
<strong>Explanation:</strong>
This case is the exact same as example 2, but with nodes 5 and 6 swapped.
Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-237">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/water-and-jug-problem/description" target="_blank" rel="noopener noreferrer">Water and Jug Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two jugs with capacities <code>x</code> liters and <code>y</code> liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach <code>target</code> using the following operations:</p>

<ul>
	<li>Fill either jug completely with water.</li>
	<li>Completely empty either jug.</li>
	<li>Pour water from one jug into another until the receiving jug is full, or the transferring jug is empty.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1: </strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> x = 3, y = 5, target = 4 </span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> true </span></p>

<p><strong>Explanation:</strong></p>

<p>Follow these steps to reach a total of 4 liters:</p>

<ol>
	<li>Fill the 5-liter jug (0, 5).</li>
	<li>Pour from the 5-liter jug into the 3-liter jug, leaving 2 liters (3, 2).</li>
	<li>Empty the 3-liter jug (0, 2).</li>
	<li>Transfer the 2 liters from the 5-liter jug to the 3-liter jug (2, 0).</li>
	<li>Fill the 5-liter jug again (2, 5).</li>
	<li>Pour from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. This leaves 4 liters in the 5-liter jug (3, 4).</li>
	<li>Empty the 3-liter jug. Now, you have exactly 4 liters in the 5-liter jug (0, 4).</li>
</ol>

<p>Reference: The <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg&amp;ab_channel=notnek01" target="_blank">Die Hard</a> example.</p>
</div>

<p><strong class="example">Example 2: </strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> x = 2, y = 6, target = 5 </span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> false </span></p>
</div>

<p><strong class="example">Example 3: </strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> x = 1, y = 2, target = 3 </span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> true </span></p>

<p><strong>Explanation:</strong> Fill both jugs. The total amount of water in both jugs is equal to 3 now.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= x, y, target&nbsp;&lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-238">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-ladder/description" target="_blank" rel="noopener noreferrer">Word Ladder</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>

<ul>
	<li>Every adjacent pair of words differs by a single letter.</li>
	<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
	<li><code>s<sub>k</sub> == endWord</code></li>
</ul>

<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>
	<li><code>endWord.length == beginWord.length</code></li>
	<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>
	<li><code>wordList[i].length == beginWord.length</code></li>
	<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>
	<li><code>beginWord != endWord</code></li>
	<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-239">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-ladder/1" target="_blank" rel="noopener noreferrer">Word Ladder I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two distinct words <strong>startWord</strong> and <strong>targetWord</strong>, and a list&nbsp;denoting <strong>wordList</strong>&nbsp;of unique words of equal lengths. Find the length of the shortest transformation sequence from startWord to targetWord.<br />Keep&nbsp;the following conditions in mind:</span></p>
<ul>
<li><span style="font-size: 18px;">A word can only consist of lowercase characters.</span></li>
<li><span style="font-size: 18px;">Only one letter can be changed in each transformation.</span></li>
<li><span style="font-size: 18px;">Each transformed word must exist in the wordList including the targetWord.</span></li>
<li><span style="font-size: 18px;">startWord may or may not be part of the&nbsp;wordList</span></li>
</ul>
<p><span style="font-size: 18px;">The second part of this problem can be found <a href="https://practice.geeksforgeeks.org/problems/word-ladder-ii/1/">here</a>.</span></p>
<p><span style="font-size: 18px;"><strong>Note</strong>: If no possible way to&nbsp;transform&nbsp;sequence from startWord to targetWord <strong>return 0</strong></span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
wordList = {"des","der","dfr","dgt","dfs"}
startWord = "der", targetWord= "dfs",
<strong>Output:
</strong>3
<strong>Explanation:
</strong>The length of the smallest transformation
sequence from "der" to "dfs" is 3
i,e "der" -&gt; "dfr" -&gt; "dfs".
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
wordList = {"geek", "gefk"}
startWord = "gedk", targetWord= "geek", 
<strong>Output:
</strong>2
<strong>Explanation:
</strong>gedk -&gt; geek</span></pre>
<p><strong><span style="font-size: 18px;">Example 3:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>
wordList = {"poon", "plee", "same", "poie","plea","plie","poin"}
startWord = "toon", targetWord= "plea",
<strong>Output: </strong>7 
<strong>Explanation:
</strong>toon -&gt; poon -&gt; poin -&gt; poie -&gt; plie -&gt; plee -&gt; plea </span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;<strong>wordLadderLength()&nbsp;</strong>which takes startWord, targetWord and wordList as input parameter and returns the&nbsp;length of the shortest transformation sequence from startWord to targetWord. If not possible return&nbsp;0.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Compelxity:&nbsp;</strong>O(N<sup>2</sup>&nbsp;* M)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N * M) where N = length of wordList and M = |wordList<sub>i</sub>|</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 100<br />1 &le; M &le; 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-240">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-ladder-ii/1" target="_blank" rel="noopener noreferrer">Word Ladder II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two distinct words <strong>startWord</strong> and <strong>targetWord</strong>, and a list&nbsp;denoting <strong>wordList</strong>&nbsp;of unique words of equal lengths. </span> <span style="font-size: 18px;">Find all shortest transformation sequence(s) from startWord to targetWord. You can return them in any order possible.</span><br /><span style="font-size: 18px;">Keep&nbsp;the following conditions in mind:</span></p>
<ul>
<li><span style="font-size: 18px;">A word can only consist of lowercase characters.</span></li>
<li><span style="font-size: 18px;">Only one letter can be changed in each transformation.</span></li>
<li><span style="font-size: 18px;">Each transformed word must exist in the wordList including the targetWord.</span></li>
<li><span style="font-size: 18px;">startWord may or may not be part of the&nbsp;wordList.</span><span style="font-size: 18px;"> </span></li>
<li><span style="font-size: 18px;">Return an empty list if there is no such transformation sequence.</span></li>
</ul>
<p><span style="font-size: 18px;">The first part of this problem can be found <a href="https://practice.geeksforgeeks.org/problems/word-ladder/1/">here</a>.</span></p>
<p><br /><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:
</span></strong><span style="font-size: 18px;">startWord = "der", targetWord = "dfs",
wordList = {"des","der","dfr","dgt","dfs"}
<strong>Output:
</strong>der dfr dfs
der des dfs
<strong>Explanation:
</strong>The length of the smallest transformation is 3.
And the following are the only two ways to get
to targetWord:-
"der" -&gt; "des" -&gt; "dfs".</span>
<span style="font-size: 18px;">"der" -&gt; "dfr" -&gt; "dfs".</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>startWord = "gedk", targetWord = "geek", 
wordList = {"geek", "gefk"}
<strong>Output:
</strong>"gedk" -&gt; "geek"</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;findSequences<strong>()&nbsp;</strong>which takes startWord, targetWord and wordList as input parameter and returns a list of list of strings of the shortest transformation sequence from startWord to targetWord.<br /><strong>Note: </strong>You don't have to return -1 in case of no possible sequence. Just return the Empty List.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Compelxity:&nbsp;</strong>O(N*(logN * M * 26))<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N * M) where N = length of wordList and M = |wordList<sub>i</sub>|</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N &le; 100<br />1 &le; M &le; 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-241">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-ladder-ii/description" target="_blank" rel="noopener noreferrer">Word Ladder II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>

<ul>
	<li>Every adjacent pair of words differs by a single letter.</li>
	<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
	<li><code>s<sub>k</sub> == endWord</code></li>
</ul>

<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]
<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:
&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;
&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]
<strong>Output:</strong> []
<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>
	<li><code>endWord.length == beginWord.length</code></li>
	<li><code>1 &lt;= wordList.length &lt;= 500</code></li>
	<li><code>wordList[i].length == beginWord.length</code></li>
	<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>
	<li><code>beginWord != endWord</code></li>
	<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>
	<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-242">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zuma-game/description" target="_blank" rel="noopener noreferrer">Zuma Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">memoization</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are playing a variation of the game Zuma.</p>

<p>In this variation of Zuma, there is a <strong>single row</strong> of colored balls on a board, where each ball can be colored red <code>&#39;R&#39;</code>, yellow <code>&#39;Y&#39;</code>, blue <code>&#39;B&#39;</code>, green <code>&#39;G&#39;</code>, or white <code>&#39;W&#39;</code>. You also have several colored balls in your hand.</p>

<p>Your goal is to <strong>clear all</strong> of the balls from the board. On each turn:</p>

<ul>
	<li>Pick <strong>any</strong> ball from your hand and insert it in between two balls in the row or on either end of the row.</li>
	<li>If there is a group of <strong>three or more consecutive balls</strong> of the <strong>same color</strong>, remove the group of balls from the board.
	<ul>
		<li>If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.</li>
	</ul>
	</li>
	<li>If there are no more balls on the board, then you win the game.</li>
	<li>Repeat this process until you either win or do not have any more balls in your hand.</li>
</ul>

<p>Given a string <code>board</code>, representing the row of balls on the board, and a string <code>hand</code>, representing the balls in your hand, return <em>the <strong>minimum</strong> number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;WRRBBW&quot;, hand = &quot;RB&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to clear all the balls. The best you can do is:
- Insert &#39;R&#39; so the board becomes WRR<u>R</u>BBW. W<u>RRR</u>BBW -&gt; WBBW.
- Insert &#39;B&#39; so the board becomes WBB<u>B</u>W. W<u>BBB</u>W -&gt; WW.
There are still balls remaining on the board, and you are out of balls to insert.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;WWRRBBWW&quot;, hand = &quot;WRBRW&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> To make the board empty:
- Insert &#39;R&#39; so the board becomes WWRR<u>R</u>BBWW. WW<u>RRR</u>BBWW -&gt; WWBBWW.
- Insert &#39;B&#39; so the board becomes WWBB<u>B</u>WW. WW<u>BBB</u>WW -&gt; <u>WWWW</u> -&gt; empty.
2 balls from your hand were needed to clear the board.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;G&quot;, hand = &quot;GGGGG&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> To make the board empty:
- Insert &#39;G&#39; so the board becomes G<u>G</u>.
- Insert &#39;G&#39; so the board becomes GG<u>G</u>. <u>GGG</u> -&gt; empty.
2 balls from your hand were needed to clear the board.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= board.length &lt;= 16</code></li>
	<li><code>1 &lt;= hand.length &lt;= 5</code></li>
	<li><code>board</code> and <code>hand</code> consist of the characters <code>&#39;R&#39;</code>, <code>&#39;Y&#39;</code>, <code>&#39;B&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;W&#39;</code>.</li>
	<li>The initial row of balls on the board will <strong>not</strong> have any groups of three or more consecutive balls of the same color.</li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>