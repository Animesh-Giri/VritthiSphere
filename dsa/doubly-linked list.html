<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>doubly-linked list - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>doubly-linked list</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">10</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">All O`one Data Structure</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Design a Text Editor</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Design Authentication Manager</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Design Browser History</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Flatten a Multilevel Doubly Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">LFU Cache</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">LRU Cache</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Merge Sort on Doubly Linked List</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-8" class="toc-link">Minimum Pair Removal to Sort Array I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Minimum Pair Removal to Sort Array II</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-oone-data-structure/description" target="_blank" rel="noopener noreferrer">All O`one Data Structure</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure to store the strings&#39; count with the ability to return the strings with minimum and maximum counts.</p>

<p>Implement the <code>AllOne</code> class:</p>

<ul>
	<li><code>AllOne()</code> Initializes the object of the data structure.</li>
	<li><code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.</li>
	<li><code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.</li>
	<li><code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>&quot;&quot;</code>.</li>
	<li><code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>&quot;&quot;</code>.</li>
</ul>

<p><strong>Note</strong> that each function must run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;AllOne&quot;, &quot;inc&quot;, &quot;inc&quot;, &quot;getMaxKey&quot;, &quot;getMinKey&quot;, &quot;inc&quot;, &quot;getMaxKey&quot;, &quot;getMinKey&quot;]
[[], [&quot;hello&quot;], [&quot;hello&quot;], [], [], [&quot;leet&quot;], [], []]
<strong>Output</strong>
[null, null, null, &quot;hello&quot;, &quot;hello&quot;, null, &quot;hello&quot;, &quot;leet&quot;]

<strong>Explanation</strong>
AllOne allOne = new AllOne();
allOne.inc(&quot;hello&quot;);
allOne.inc(&quot;hello&quot;);
allOne.getMaxKey(); // return &quot;hello&quot;
allOne.getMinKey(); // return &quot;hello&quot;
allOne.inc(&quot;leet&quot;);
allOne.getMaxKey(); // return &quot;hello&quot;
allOne.getMinKey(); // return &quot;leet&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= key.length &lt;= 10</code></li>
	<li><code>key</code> consists of lowercase English letters.</li>
	<li>It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.</li>
	<li>At most <code>5 * 10<sup>4</sup></code>&nbsp;calls will be made to <code>inc</code>, <code>dec</code>, <code>getMaxKey</code>, and <code>getMinKey</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview:</h3>
<p>We need to create a specialized data structure that efficiently handles the following operations on strings and their associated counts:</p>
<ul>
<li>Increase the count of a specified string.</li>
<li>Decrease the count of a specified string.</li>
<li>Retrieve the string with the highest count.</li>
<li>Retrieve the string with the lowest count.</li>
</ul>
<p>A key requirement is that each of these operations must be performed in constant time, <span class="math inline">\(Θ(1)\)</span> on average.</p>
<p><img src="../Figures/432/432_allOone.png" alt="AllOone" /></p>
<h3 id="approach-using-doubly-linked-list">Approach: Using Doubly Linked List</h3>
<h4 id="intuition">Intuition</h4>
<p>To manage a collection of keys and their frequencies, we need a structure that updates easily and provides quick access to maximum and minimum frequencies. We start with a hashmap to look up each key’s frequency quickly.</p>
<p>However, a hashmap alone does not track frequencies well. We need a way to group keys by their frequencies and find keys with the same frequency. We use a doubly linked list for this. Each node represents a frequency and holds all keys linked to that frequency. This setup allows us to add and remove keys efficiently as their frequencies change.</p>
<p>To handle edge cases better, we include dummy head and tail nodes in the list. These nodes make it easier to manage operations when the list is empty or when we add or remove nodes at the ends.</p>
<p>When we increment a key, we first check if it exists in the hashmap. If the key is new, we look at the node after the dummy head. If that node does not have a frequency of 1, we create a new node for frequency 1. We add the key to this node and update the hashmap. If the key already exists, we find its current frequency node and check the next node, which shows the next higher frequency. If that next node is the tail or does not have the expected frequency, we create a new node with the increased frequency. We then move the key to the right node, remove it from the old node, and delete the old node if it becomes empty.</p>
<p>When we decrement a key, we first check if it is in the hashmap. If it is, we remove it from its current node. If the key’s frequency is greater than one, we check the previous node. If needed, we create a new node for the decreased frequency and add the key to the appropriate previous node, updating the hashmap. If the frequency is one, we remove the key from the hashmap completely.</p>
<p>To find the key with the maximum frequency, we return one of the keys from the last node in the list. For the minimum frequency key, we get a key from the first node after the dummy head. If there are no keys, we return an empty string.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p><code>Node</code> Class:</p>
</li>
<li>
<p>Each <code>Node</code> contains:</p>
<ul>
<li><code>freq</code>: the frequency of the keys.</li>
<li><code>prev</code>: a pointer to the previous node.</li>
<li><code>next</code>: a pointer to the next node.</li>
<li><code>keys</code>: a set of strings representing the keys with this frequency.</li>
</ul>
</li>
<li>
<p>The constructor initializes the <code>freq</code>, and sets <code>prev</code> and <code>next</code> to <code>nullptr</code>.</p>
</li>
<li>
<p><code>AllOne</code> Class:</p>
<ul>
<li>
<p>Create a dummy head node and a dummy tail node.</p>
</li>
<li>
<p>Link the dummy head to the dummy tail and vice versa.</p>
</li>
<li>
<p>Incrementing a Key (<code>inc</code> function):</p>
<ul>
<li>
<p>If the key already exists:</p>
<ul>
<li>Retrieve the corresponding <code>node</code> from the <code>map</code>.</li>
<li>Erase the key from the current <code>node</code>.</li>
<li>Check the next node:
<ul>
<li>If it doesn’t exist or its frequency is not <code>freq + 1</code>:
<ul>
<li>Create a new node with frequency <code>freq + 1</code>.</li>
<li>Insert the key into this new node.</li>
<li>Link the new node with the current and next nodes.</li>
<li>Update the <code>map</code> to point to the new node.</li>
</ul>
</li>
<li>Otherwise, insert the key into the existing next node.</li>
</ul>
</li>
<li>If the current node has no keys left, remove it.</li>
</ul>
</li>
<li>
<p>If the key does not exist:</p>
<ul>
<li>Check the first node after the head:
<ul>
<li>If it doesn’t exist or its frequency is greater than <code>1</code>:
<ul>
<li>Create a new node with frequency <code>1</code>.</li>
<li>Insert the key into this new node.</li>
<li>Link this new node with the head and the first node.</li>
</ul>
</li>
<li>Otherwise, insert the key into the first node.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Decrementing a Key (<code>dec</code> function):</p>
<ul>
<li>If the key does not exist in the <code>map</code>, return immediately.</li>
<li>Retrieve the node corresponding to the key.</li>
<li>Erase the key from the current node.</li>
<li>If the frequency is <code>1</code>:
<ul>
<li>Remove the key from the <code>map</code>.</li>
</ul>
</li>
<li>Otherwise, check the previous node:
<ul>
<li>If it doesn’t exist or its frequency is not <code>freq - 1</code>:
<ul>
<li>Create a new node with frequency <code>freq - 1</code>.</li>
<li>Insert the key into this new node and link it with the current node and the previous node.</li>
</ul>
</li>
<li>Otherwise, insert the key into the existing previous node.</li>
</ul>
</li>
<li>If the node has no keys left, remove it.</li>
</ul>
</li>
<li>
<p>Getting the Maximum Key (<code>getMaxKey</code> function):</p>
<ul>
<li>If there are no keys (i.e., the tail's previous node points to the head), return an empty string.</li>
<li>Return one of the keys from the tail's previous node.</li>
</ul>
</li>
<li>
<p>Getting the Minimum Key (<code>getMinKey</code> function):</p>
<ul>
<li>If there are no keys (i.e., the head's next node points to the tail), return an empty string.</li>
<li>Return one of the keys from the head's next node.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Removing a Node (<code>removeNode</code> function):</p>
<ul>
<li>Link the previous node to the next node and vice versa to remove the specified node from the linked list.</li>
<li>Delete the removed node to free its memory.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/eRAv3tYP/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of unique keys.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The <code>inc</code> and <code>dec</code> methods both perform operations that are constant time. In <code>inc</code>, whether inserting a new key or updating an existing one, the operations primarily involve updating pointers in the linked list and updating the hash map, which are <span class="math inline">\(O(1)\)</span> operations.</p>
<p>Similarly, in <code>dec</code>, removing a key, updating the hash map, and possibly creating a new node or modifying the previous node also take constant time. Therefore, both operations run in <span class="math inline">\(O(1)\)</span>.</p>
<p>The <code>getMaxKey</code> and <code>getMinKey</code> methods return a key from the front or back of the linked list, which is also <span class="math inline">\(O(1)\)</span> since it involves accessing the first or last element of the list.</p>
</li>
</ul>
<blockquote>
<p>This assumes that map operations typically run in &quot;average-case <span class="math inline">\(Θ(1)\)</span>&quot;. However, in the worst case, where many hash collisions occur, these operations can degrade to <span class="math inline">\(O(N)\)</span>.</p>
</blockquote>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space used by the <code>AllOne</code> data structure is primarily due to the hash map and the linked list of <code>Node</code>s.</p>
<p>The hash map stores pointers to nodes for each unique key, requiring <span class="math inline">\(O(N)\)</span> space where <span class="math inline">\(N\)</span> is the number of unique keys.</p>
<p>Each <code>Node</code> contains a set of <code>keys</code>, which can also grow with the number of unique keys in the worst case. Hence, the total space consumed by the linked list of nodes will also contribute to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</br>
<details>
<summary>Further Thoughts: Understanding Hashmap Time Complexity [Click Here]</summary>
</br>
<p>A common question that always arises is: why are hashmap lookups considered <span class="math inline">\(O(1)\)</span> in terms of time complexity, even in worst-case scenarios? This seems counterintuitive, especially considering that hash collisions can occur.</p>
<p>If we use a predetermined hash function, the worst-case time for hashmap operations could indeed be <span class="math inline">\(O(n)\)</span>. Why? Because someone could craft a set of keys that all hash to the same value, causing a chain of collisions. This would force the lookup to scan through all <span class="math inline">\(n\)</span> elements, resulting in <span class="math inline">\(O(n)\)</span> time complexity.</p>
<p>The key to achieving <span class="math inline">\(O(1)\)</span> time complexity lies in randomization. Instead of using a fixed hash function like <code>h(x) = (constant_a . x + constant_b) % constant_prime</code>, we can use a randomized approach. For example, we might choose random values for the parameters in our hash function each time we initialize our hashmap, such as <code>h(x) = (random_a . x + random_b) % random_prime</code>. (This is just one way to construct a hash function; there are many other types you can design.)</p>
<p>This randomization makes it virtually impossible for someone to predict and exploit the hash function's behavior.</p>
<p>From a mathematical perspective, when analyzing the &quot;expected runtime&quot; of hashmap operations using a randomized hash function, it averages out to <span class="math inline">\(O(1)\)</span>. While some individual operations might take longer due to collisions, the overall average remains constant.</p>
<p>It's crucial to understand that when we say &quot;expected worst-case time is <span class="math inline">\(O(1)\)</span>&quot;, we're referring to the average over all possible random choices of the hash function, for any given input.</p>
<p>This isn't just theoretical—it’s applied in practice. For instance, Google’s Abseil library randomizes hash functions at the program start. This helps prevent attacks that exploit hash collisions and makes systems more secure. Randomization also ensures that software doesn't become dependent on a specific hash function. Hardcoding a hash function and never changing it makes future updates to improve security or performance challenging.</p>
<p>This concept illustrates a broader principle in system design: the power of introducing controlled randomness to improve system performance and security. It also relates to Hyrum's Law, which suggests that all observable behaviors of a system will eventually be depended on by somebody. By randomizing hash functions, we prevent dependencies on specific hash behaviors, making systems more robust and flexible.</p>
<p>Additionally, when we say &quot;expected value,&quot; it's not just a random term; it is formally defined, similar to worst-case and average-case scenarios. You can read the definition and understand the concept here in <a href="https://en.m.wikipedia.org/wiki/Expected_value">probability theory: Expected value</a>.</p>
</details></div>
				</div>
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-a-text-editor/description" target="_blank" rel="noopener noreferrer">Design a Text Editor</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a text editor with a cursor that can do the following:</p>

<ul>
	<li><strong>Add</strong> text to where the cursor is.</li>
	<li><strong>Delete</strong> text from where the cursor is (simulating the backspace key).</li>
	<li><strong>Move</strong> the cursor either left or right.</li>
</ul>

<p>When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that <code>0 &lt;= cursor.position &lt;= currentText.length</code> always holds.</p>

<p>Implement the <code>TextEditor</code> class:</p>

<ul>
	<li><code>TextEditor()</code> Initializes the object with empty text.</li>
	<li><code>void addText(string text)</code> Appends <code>text</code> to where the cursor is. The cursor ends to the right of <code>text</code>.</li>
	<li><code>int deleteText(int k)</code> Deletes <code>k</code> characters to the left of the cursor. Returns the number of characters actually deleted.</li>
	<li><code>string cursorLeft(int k)</code> Moves the cursor to the left <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>
	<li><code>string cursorRight(int k)</code> Moves the cursor to the right <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;TextEditor&quot;, &quot;addText&quot;, &quot;deleteText&quot;, &quot;addText&quot;, &quot;cursorRight&quot;, &quot;cursorLeft&quot;, &quot;deleteText&quot;, &quot;cursorLeft&quot;, &quot;cursorRight&quot;]
[[], [&quot;leetcode&quot;], [4], [&quot;practice&quot;], [3], [8], [10], [2], [6]]
<strong>Output</strong>
[null, null, 4, null, &quot;etpractice&quot;, &quot;leet&quot;, 4, &quot;&quot;, &quot;practi&quot;]

<strong>Explanation</strong>
TextEditor textEditor = new TextEditor(); // The current text is &quot;|&quot;. (The &#39;|&#39; character represents the cursor)
textEditor.addText(&quot;leetcode&quot;); // The current text is &quot;leetcode|&quot;.
textEditor.deleteText(4); // return 4
                          // The current text is &quot;leet|&quot;. 
                          // 4 characters were deleted.
textEditor.addText(&quot;practice&quot;); // The current text is &quot;leetpractice|&quot;. 
textEditor.cursorRight(3); // return &quot;etpractice&quot;
                           // The current text is &quot;leetpractice|&quot;. 
                           // The cursor cannot be moved beyond the actual text and thus did not move.
                           // &quot;etpractice&quot; is the last 10 characters to the left of the cursor.
textEditor.cursorLeft(8); // return &quot;leet&quot;
                          // The current text is &quot;leet|practice&quot;.
                          // &quot;leet&quot; is the last min(10, 4) = 4 characters to the left of the cursor.
textEditor.deleteText(10); // return 4
                           // The current text is &quot;|practice&quot;.
                           // Only 4 characters were deleted.
textEditor.cursorLeft(2); // return &quot;&quot;
                          // The current text is &quot;|practice&quot;.
                          // The cursor cannot be moved beyond the actual text and thus did not move. 
                          // &quot;&quot; is the last min(10, 0) = 0 characters to the left of the cursor.
textEditor.cursorRight(6); // return &quot;practi&quot;
                           // The current text is &quot;practi|ce&quot;.
                           // &quot;practi&quot; is the last min(10, 6) = 6 characters to the left of the cursor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length, k &lt;= 40</code></li>
	<li><code>text</code> consists of lowercase English letters.</li>
	<li>At most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>addText</code>, <code>deleteText</code>, <code>cursorLeft</code> and <code>cursorRight</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Could you find a solution with time complexity of <code>O(k)</code> per call?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-authentication-manager/description" target="_blank" rel="noopener noreferrer">Design Authentication Manager</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire <code>timeToLive</code> seconds after the <code>currentTime</code>. If the token is renewed, the expiry time will be <b>extended</b> to expire <code>timeToLive</code> seconds after the (potentially different) <code>currentTime</code>.</p>

<p>Implement the <code>AuthenticationManager</code> class:</p>

<ul>
	<li><code>AuthenticationManager(int timeToLive)</code> constructs the <code>AuthenticationManager</code> and sets the <code>timeToLive</code>.</li>
	<li><code>generate(string tokenId, int currentTime)</code> generates a new token with the given <code>tokenId</code> at the given <code>currentTime</code> in seconds.</li>
	<li><code>renew(string tokenId, int currentTime)</code> renews the <strong>unexpired</strong> token with the given <code>tokenId</code> at the given <code>currentTime</code> in seconds. If there are no unexpired tokens with the given <code>tokenId</code>, the request is ignored, and nothing happens.</li>
	<li><code>countUnexpiredTokens(int currentTime)</code> returns the number of <strong>unexpired</strong> tokens at the given currentTime.</li>
</ul>

<p>Note that if a token expires at time <code>t</code>, and another action happens on time <code>t</code> (<code>renew</code> or <code>countUnexpiredTokens</code>), the expiration takes place <strong>before</strong> the other actions.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png" style="width: 500px; height: 287px;" />
<pre>
<strong>Input</strong>
[&quot;AuthenticationManager&quot;, &quot;<code>renew</code>&quot;, &quot;generate&quot;, &quot;<code>countUnexpiredTokens</code>&quot;, &quot;generate&quot;, &quot;<code>renew</code>&quot;, &quot;<code>renew</code>&quot;, &quot;<code>countUnexpiredTokens</code>&quot;]
[[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]]
<strong>Output</strong>
[null, null, null, 1, null, null, null, 0]

<strong>Explanation</strong>
AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with <code>timeToLive</code> = 5 seconds.
authenticationManager.<code>renew</code>(&quot;aaa&quot;, 1); // No token exists with tokenId &quot;aaa&quot; at time 1, so nothing happens.
authenticationManager.generate(&quot;aaa&quot;, 2); // Generates a new token with tokenId &quot;aaa&quot; at time 2.
authenticationManager.<code>countUnexpiredTokens</code>(6); // The token with tokenId &quot;aaa&quot; is the only unexpired one at time 6, so return 1.
authenticationManager.generate(&quot;bbb&quot;, 7); // Generates a new token with tokenId &quot;bbb&quot; at time 7.
authenticationManager.<code>renew</code>(&quot;aaa&quot;, 8); // The token with tokenId &quot;aaa&quot; expired at time 7, and 8 &gt;= 7, so at time 8 the <code>renew</code> request is ignored, and nothing happens.
authenticationManager.<code>renew</code>(&quot;bbb&quot;, 10); // The token with tokenId &quot;bbb&quot; is unexpired at time 10, so the <code>renew</code> request is fulfilled and now the token will expire at time 15.
authenticationManager.<code>countUnexpiredTokens</code>(15); // The token with tokenId &quot;bbb&quot; expires at time 15, and the token with tokenId &quot;aaa&quot; expired at time 7, so currently no token is unexpired, so return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= timeToLive &lt;= 10<sup>8</sup></code></li>
	<li><code>1 &lt;= currentTime &lt;= 10<sup>8</sup></code></li>
	<li><code>1 &lt;= tokenId.length &lt;= 5</code></li>
	<li><code>tokenId</code> consists only of lowercase letters.</li>
	<li>All calls to <code>generate</code> will contain unique values of <code>tokenId</code>.</li>
	<li>The values of <code>currentTime</code> across all the function calls will be <strong>strictly increasing</strong>.</li>
	<li>At most <code>2000</code> calls will be made to all functions combined.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-browser-history/description" target="_blank" rel="noopener noreferrer">Design Browser History</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a <strong>browser</strong> of one tab where you start on the <code>homepage</code> and you can visit another <code>url</code>, get back in the history number of <code>steps</code> or move forward in the history number of <code>steps</code>.</p>

<p>Implement the <code>BrowserHistory</code> class:</p>

<ul>
	<li><code>BrowserHistory(string homepage)</code> Initializes the object with the <code>homepage</code>&nbsp;of the browser.</li>
	<li><code>void visit(string url)</code>&nbsp;Visits&nbsp;<code>url</code> from the current page. It clears up all the forward history.</li>
	<li><code>string back(int steps)</code>&nbsp;Move <code>steps</code> back in history. If you can only return <code>x</code> steps in the history and <code>steps &gt; x</code>, you will&nbsp;return only <code>x</code> steps. Return the current <code>url</code>&nbsp;after moving back in history <strong>at most</strong> <code>steps</code>.</li>
	<li><code>string forward(int steps)</code>&nbsp;Move <code>steps</code> forward in history. If you can only forward <code>x</code> steps in the history and <code>steps &gt; x</code>, you will&nbsp;forward only&nbsp;<code>x</code> steps. Return the current <code>url</code>&nbsp;after forwarding in history <strong>at most</strong> <code>steps</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example:</strong></p>

<pre>
<b>Input:</b>
[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]
[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]
<b>Output:</b>
[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]

<b>Explanation:</b>
BrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;);
browserHistory.visit(&quot;google.com&quot;);       // You are in &quot;leetcode.com&quot;. Visit &quot;google.com&quot;
browserHistory.visit(&quot;facebook.com&quot;);     // You are in &quot;google.com&quot;. Visit &quot;facebook.com&quot;
browserHistory.visit(&quot;youtube.com&quot;);      // You are in &quot;facebook.com&quot;. Visit &quot;youtube.com&quot;
browserHistory.back(1);                   // You are in &quot;youtube.com&quot;, move back to &quot;facebook.com&quot; return &quot;facebook.com&quot;
browserHistory.back(1);                   // You are in &quot;facebook.com&quot;, move back to &quot;google.com&quot; return &quot;google.com&quot;
browserHistory.forward(1);                // You are in &quot;google.com&quot;, move forward to &quot;facebook.com&quot; return &quot;facebook.com&quot;
browserHistory.visit(&quot;linkedin.com&quot;);     // You are in &quot;facebook.com&quot;. Visit &quot;linkedin.com&quot;
browserHistory.forward(2);                // You are in &quot;linkedin.com&quot;, you cannot move forward any steps.
browserHistory.back(2);                   // You are in &quot;linkedin.com&quot;, move back two steps to &quot;facebook.com&quot; then to &quot;google.com&quot;. return &quot;google.com&quot;
browserHistory.back(7);                   // You are in &quot;google.com&quot;, you can move back only one step to &quot;leetcode.com&quot;. return &quot;leetcode.com&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= homepage.length &lt;= 20</code></li>
	<li><code>1 &lt;= url.length &lt;= 20</code></li>
	<li><code>1 &lt;= steps &lt;= 100</code></li>
	<li><code>homepage</code> and <code>url</code> consist of&nbsp; &#39;.&#39; or lower case English letters.</li>
	<li>At most <code>5000</code>&nbsp;calls will be made to <code>visit</code>, <code>back</code>, and <code>forward</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/description" target="_blank" rel="noopener noreferrer">Flatten a Multilevel Doubly Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional <strong>child pointer</strong>. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a <strong>multilevel data structure</strong> as shown in the example below.</p>

<p>Given the <code>head</code> of the first level of the list, <strong>flatten</strong> the list so that all the nodes appear in a single-level, doubly linked list. Let <code>curr</code> be a node with a child list. The nodes in the child list should appear <strong>after</strong> <code>curr</code> and <strong>before</strong> <code>curr.next</code> in the flattened list.</p>

<p>Return <em>the </em><code>head</code><em> of the flattened list. The nodes in the list must have <strong>all</strong> of their child pointers set to </em><code>null</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg" style="width: 700px; height: 339px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
<strong>Output:</strong> [1,2,3,7,8,11,12,9,10,4,5,6]
<strong>Explanation:</strong> The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
<img src="https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg" style="width: 1000px; height: 69px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> head = [1,2,null,3]
<strong>Output:</strong> [1,3,2]
<strong>Explanation:</strong> The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
<img src="https://assets.leetcode.com/uploads/2021/11/24/list.jpg" style="width: 300px; height: 87px;" />
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
<strong>Explanation:</strong> There could be empty list in the input.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of Nodes will not exceed <code>1000</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>How the multilevel linked list is represented in test cases:</strong></p>

<p>We use the multilevel linked list from <strong>Example 1</strong> above:</p>

<pre>
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL</pre>

<p>The serialization of each level is as follows:</p>

<pre>
[1,2,3,4,5,6,null]
[7,8,9,10,null]
[11,12,null]
</pre>

<p>To serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:</p>

<pre>
[1,    2,    3, 4, 5, 6, null]
             |
[null, null, 7,    8, 9, 10, null]
                   |
[            null, 11, 12, null]
</pre>

<p>Merging the serialization of each level and removing trailing nulls we obtain:</p>

<pre>
[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
</pre>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lfu-cache/description" target="_blank" rel="noopener noreferrer">LFU Cache</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design and implement a data structure for a <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank">Least Frequently Used (LFU)</a> cache.</p>

<p>Implement the <code>LFUCache</code> class:</p>

<ul>
	<li><code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.</li>
	<li><code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.</li>
	<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.</li>
</ul>

<p>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</p>

<p>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.</p>

<p>The functions&nbsp;<code data-stringify-type="code">get</code>&nbsp;and&nbsp;<code data-stringify-type="code">put</code>&nbsp;must each run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

<strong>Explanation</strong>
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
&nbsp;                // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[4,3], cnt(4)=2, cnt(3)=3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= capacity&nbsp;&lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>2 * 10<sup>5</sup></code>&nbsp;calls will be made to <code>get</code> and <code>put</code>.</li>
</ul>

<p>&nbsp;</p>
<span style="display: none;">&nbsp;</span></div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-maintaining-2-hashmaps">Approach 1: Maintaining 2 HashMaps</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to maintain all the keys, values and frequencies. Without invalidation (removing from the data structure when it reaches capacity), they can be maintained by a HashMap&lt;Integer, Pair&lt;Integer, Integer&gt;&gt;, keyed by the original <code>key</code> and valued by the <code>frequency</code>-<code>value</code> pair.</p>
<p>With the invalidation, we need to maintain the current minimum frequency and delete particular keys. Hence, we can group the keys with the same frequency together and maintain another HashMap&lt;Integer, Set<Integer>&gt;, keyed by the frequency and valued by the set of <code>keys</code> that have the same frequency. This way, if we know the minimum frequency, we can access the potential keys to be deleted.</p>
<p>Also note that in the case of a tie, we're required to find the least recently used key and invalidate it, hence we need to keep the frequencies ordered in the Set. Instead of using a TreeSet which adds an extra <span class="math inline">\(O(log(N))\)</span> time complexity, we can maintain the keys using a LinkedList so that it supports finding both an arbitrary key and the least recently used key in constant time. Fortunately, LinkedHashSet can do the job. Once a <code>key</code> is inserted/updated, we put it to the end of the LinkedHashSet so that we can invalidate the first <code>key</code> in the LinkedHashSet corresponding to the minimum frequency.</p>
<p>The original operations can be transformed into operations on the 2 HashMaps, keeping them in sync and maintaining the minimum frequency.</p>
<p>Since C++ lacks LinkedHashSet, we have to use a workaround like maintaining a list of key and value pairs instead of the LinkedHashSet and keeping the iterator with the frequency in another unordered_map to keep this connection. The idea is similar but a little bit complicated. Another workaround would be to implement your own LRU cache with a doubly linked list.</p>
<h4 id="algorithm">Algorithm</h4>
<p>To make things simpler, assume we have 4 member variables:</p>
<ol>
<li><code>HashMap&lt;Integer, Pair&lt;Integer, Integer&gt;&gt; cache</code>, keyed by the original <code>key</code> and valued by the <code>frequency</code>-<code>value</code> pair.</li>
<li><code>HashMap&lt;Integer, LinkedListHashSet&lt;Integer&gt;&gt; frequencies</code>, keyed by frequency and valued by the set of <code>keys</code> that have the same frequency.</li>
<li><code>int minf</code>, which is the minimum frequency at any given time.</li>
<li><code>int capacity</code>, which is the <code>capacity</code> given in the input.</li>
</ol>
<p>It's also convenient to have a private utility function <code>insert</code> to insert a <code>key</code>-<code>value</code> pair with a given frequency.</p>
<h5 id="void-insertint-key-int-frequency-int-value">void insert(int key, int frequency, int value)</h5>
<ol>
<li>Insert <code>frequency</code>-<code>value</code> pair into <code>cache</code> with the given <code>key</code>.</li>
<li>Get the LinkedHashSet corresponding to the given <code>frequency</code> (default to empty Set) and insert the given <code>key</code>.</li>
</ol>
<h5 id="int-getint-key">int get(int key)</h5>
<ol>
<li>If the given <code>key</code> is not in the <code>cache</code>, return <code>-1</code>, otherwise go to step <code>2</code>.</li>
<li>Get the <code>frequency</code> and <code>value</code> from the <code>cache</code>.</li>
<li>Get the LinkedHashSet associated with <code>frequency</code> from <code>frequencies</code> and remove the given <code>key</code> from it, since the usage of the current key is increased by this function call.</li>
<li>If <code>minf</code> == <code>frequency</code> and the above LinkedHashSet is empty, that means there are no more elements used <code>minf</code> times, so increase <code>minf</code> by 1. To save some space, we can also delete the entry <code>frequency</code> from the <code>frequencies</code> hash map.</li>
<li>Call insert(<code>key</code>, <code>frequency</code> + 1, <code>value</code>), since the current key's usage has increased from this function call.</li>
<li>Return <code>value</code></li>
</ol>
<h5 id="void-putint-key-int-value">void put(int key, int value)</h5>
<ol>
<li>If <code>capacity</code> &lt;= 0, exit.</li>
<li>If the given <code>key</code> exists in <code>cache</code>, update the <code>value</code> in the original <code>frequency</code>-<code>value</code> (don't call insert here), and then increment the frequency by using get(<code>key</code>). Exit the function.</li>
<li>If <code>cache.size()</code> == <code>capacity</code>, get the first (least recently used) value in the LinkedHashSet corresponding to <code>minf</code> in <code>frequencies</code>, and remove it from <code>cache</code> and the LinkedHashSet.</li>
<li>If we didn't exit the function in step 2, it means that this element is a new one, so the minimum frequency cannot possibly be greater than one. Set <code>minf</code> to 1.</li>
<li>Call insert(<code>key</code>, 1, <code>value</code>)</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/njKVWiZK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the total number of operations.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span>, as required by the question.</p>
<p>Since we only have basic HashMap/(Linked)HashSet operations. For details,</p>
<p>Our utility function <code>insert</code> puts the <code>key</code>- <code>value</code> pair into the <code>cache</code>, queries and possibly puts an empty LinedHashSet in the <code>frequencies</code>, then queries <code>frequencies</code> again and adds a <code>key</code> into the associated <code>value</code> which is a LinkedHashSet. All the operations are based on the hash calculating for simple type (int or Integer) and the time complexity is constant.</p>
<p>For each <code>get</code> operation, in the worst case, we query the <code>frequencies</code> and remove a <code>key</code> from the associated <code>value</code> which is a LinkedHashSet and call <code>insert</code> function once. All the operations have the constant time complexity based on the hash calculating for simple type.</p>
<p>For each <code>put</code> operation, in the simple case we just insert the new <code>key</code>-<code>value</code> pair into the <code>cache</code> and call <code>get</code> function once. In the worst case, we query the <code>frequencies</code> to get the associated <code>value</code>, namely all the <code>keys</code> with the same frequencies which is a LinkedHashSet. And then we get the first key from the LinkedHashSet, remove it from both <code>cache</code> and <code>frequencies</code>. All the operations have the constant time complexity based on the hash calculating for simple type.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>We save all the <code>key</code>-<code>value</code> pairs as well as all the keys with frequencies in the 2 HashMaps (plus a LinkedHashSet), so there are at most $min(N, capacity) <code>keys</code> and <code>values</code> at any given time.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lru-cache/description" target="_blank" rel="noopener noreferrer">LRU Cache</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">design</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design a data structure that follows the constraints of a <strong><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank">Least Recently Used (LRU) cache</a></strong>.</p>

<p>Implement the <code>LRUCache</code> class:</p>

<ul>
	<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>
	<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>
	<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>
</ul>

<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>Explanation</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= capacity &lt;= 3000</code></li>
	<li><code>0 &lt;= key &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/merge-sort-on-doubly-linked-list/1" target="_blank" rel="noopener noreferrer">Merge Sort on Doubly Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given Pointer/Reference to the <strong>head</strong> of a<strong> </strong>doubly linked list, the task is to Sort<strong> </strong>the<strong> </strong>given doubly linked list<strong> </strong>using<strong> Merge Sort&nbsp;</strong>in both <strong>non-decreasing</strong> and <strong>non-increasing</strong> order.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong> Return the head of the sorted&nbsp;non-decreasing&nbsp;doubly linked list. The driver code will print it forward and backward in both directions.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList:<strong> </strong>7 &harr; 3 &harr; 5 &harr; 2 &harr; 6 &harr; 4 &harr; 1 &harr; 8
<strong>Output:
</strong>LinkedList: 1 &harr; 2 &harr; 3 &harr; 4 &harr; 5 &harr; 6 &harr; 7 &harr; 8
LinkedList: 8 &harr; 7 &harr; 6 &harr; 5 &harr; 4 &harr; 3 &harr; 2 &harr; 1<strong>
Explanation: </strong>After sorting the given linked list in both ways, the resultant matrix will be as shown in the first two lines of the output. The first line shows the output for non-decreasing order, and the next line shows the output for non-increasing order.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700538/Web/Other/blobid0_1725342004.png" width="371" height="139" /><br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>LinkedList: 9 &harr; 15 &harr; 0 &harr; -1 &harr; 0<br /><strong>Output:</strong>
LinkedList: -1 &harr; 0 &harr; 0 &harr; 9 &harr; 15
LinkedList: 15 &harr; 9 &harr; 0 &harr; 0 &harr; -1<strong>
Explanation: </strong>After sorting the given linked list in both ways, the resultant list will be -1 &rarr; 0 &rarr; 0 &rarr; 9 &rarr; 15 in non-decreasing order and 15 &rarr; 9 &rarr; 0 &rarr; 0 &rarr; -1 in non-increasing order.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700538/Web/Other/blobid1_1725342021.png" width="363" height="136" /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;=&nbsp;<span style="font-family: Arial; white-space-collapse: preserve; background-color: #ffffff;">number of nodes</span> &lt;= 10<sup>5<br /></sup>-10<sup>5</sup> &lt;= node-&gt;data &lt;= 10<sup>5<br /></sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-pair-removal-to-sort-array-i/description" target="_blank" rel="noopener noreferrer">Minimum Pair Removal to Sort Array I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code>, you can perform the following operation any number of times:</p>

<ul>
	<li>Select the <strong>adjacent</strong> pair with the <strong>minimum</strong> sum in <code>nums</code>. If multiple such pairs exist, choose the leftmost one.</li>
	<li>Replace the pair with their sum.</li>
</ul>

<p>Return the <strong>minimum number of operations</strong> needed to make the array <strong>non-decreasing</strong>.</p>

<p>An array is said to be <strong>non-decreasing</strong> if each element is greater than or equal to its previous element (if it exists).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,2,3,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The pair <code>(3,1)</code> has the minimum sum of 4. After replacement, <code>nums = [5,2,4]</code>.</li>
	<li>The pair <code>(2,4)</code> has the minimum sum of 6. After replacement, <code>nums = [5,6]</code>.</li>
</ul>

<p>The array <code>nums</code> became non-decreasing in two operations.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The array <code>nums</code> is already sorted.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-pair-removal-to-sort-array-ii/description" target="_blank" rel="noopener noreferrer">Minimum Pair Removal to Sort Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">doubly-linked list</span> <span class="topic-badge">linked list</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code>, you can perform the following operation any number of times:</p>

<ul>
	<li>Select the <strong>adjacent</strong> pair with the <strong>minimum</strong> sum in <code>nums</code>. If multiple such pairs exist, choose the leftmost one.</li>
	<li>Replace the pair with their sum.</li>
</ul>

<p>Return the <strong>minimum number of operations</strong> needed to make the array <strong>non-decreasing</strong>.</p>

<p>An array is said to be <strong>non-decreasing</strong> if each element is greater than or equal to its previous element (if it exists).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,2,3,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The pair <code>(3,1)</code> has the minimum sum of 4. After replacement, <code>nums = [5,2,4]</code>.</li>
	<li>The pair <code>(2,4)</code> has the minimum sum of 6. After replacement, <code>nums = [5,6]</code>.</li>
</ul>

<p>The array <code>nums</code> became non-decreasing in two operations.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The array <code>nums</code> is already sorted.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>